"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/Main.js":
/*!********************************!*\
  !*** ./src/components/Main.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _UploadSection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UploadSection */ \"(app-pages-browser)/./src/components/UploadSection.js\");\n/* harmony import */ var _ChartDisplay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ChartDisplay */ \"(app-pages-browser)/./src/components/ChartDisplay.js\");\n/* harmony import */ var _DownloadJson__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DownloadJson */ \"(app-pages-browser)/./src/components/DownloadJson.js\");\n/* harmony import */ var _charts_AgCharts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./charts/AgCharts */ \"(app-pages-browser)/./src/components/charts/AgCharts.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// import MUIChart from \"./charts/MuiChart\";\n// import RechartComponent from \"./charts/RechartComponent\";\n// import D3Chart from \"./charts/D3Chart\";\n\nconst Main = ()=>{\n    _s();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [chartType, setChartType] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"bar\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"flex min-h-screen flex-col items-center justify-between p-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full max-w-4xl mx-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-center text-3xl font-bold mb-8\",\n                        children: \"Upload JSON Data to Display Chart\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full gap-6 grid grid-cols-1 md:grid-cols-2 rounded-lg shadow-md animate-fadeIn\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex flex-col justify-center items-center md:items-start text-white\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                        className: \"text-2xl font-bold mb-4\",\n                                        children: \"Prepare Your Data\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                        lineNumber: 23,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg text-white mb-4\",\n                                        children: \"Upload your JSON data to start. The data will be validated and processed as you upload it. Ensure that the data adheres to JSON specifications to properly display the charts.\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                        lineNumber: 24,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                lineNumber: 22,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex flex-col items-center md:items-start\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_UploadSection__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    onFileUpload: setData,\n                                    chartType: chartType,\n                                    setChartType: setChartType\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                    lineNumber: 31,\n                                    columnNumber: 13\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                lineNumber: 30,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                        lineNumber: 21,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-1 md:grid-cols-2 gap-6 mt-8\",\n                        children: data ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ChartDisplay__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    data: data,\n                                    chartType: chartType\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                    lineNumber: 42,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_charts_AgCharts__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    data: data,\n                                    chartType: chartType\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                                    lineNumber: 47,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-center text-gray-600\",\n                            children: \"No data uploaded yet.\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                            lineNumber: 50,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                        lineNumber: 39,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed bottom-4 right-4 z-50\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DownloadJson__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n                lineNumber: 55,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\Main.js\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Main, \"wgeOCmq9C28r5Qso7NEkOg2dKew=\");\n_c = Main;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Main);\nvar _c;\n$RefreshReg$(_c, \"Main\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL01haW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNpQztBQUNXO0FBQ0Y7QUFDQTtBQUMxQyw0Q0FBNEM7QUFDNUMsNERBQTREO0FBQzVELDBDQUEwQztBQUNGO0FBRXhDLE1BQU1LLE9BQU87O0lBQ1gsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ2pDLE1BQU0sQ0FBQ1EsV0FBV0MsYUFBYSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUUzQyxxQkFDRSw4REFBQ1U7UUFBS0MsV0FBVTs7MEJBQ2QsOERBQUNDO2dCQUFJRCxXQUFVOztrQ0FDYiw4REFBQ0U7d0JBQUdGLFdBQVU7a0NBQXNDOzs7Ozs7a0NBR3BELDhEQUFDQzt3QkFBSUQsV0FBVTs7MENBQ2IsOERBQUNDO2dDQUFJRCxXQUFVOztrREFDYiw4REFBQ0U7d0NBQUdGLFdBQVU7a0RBQTBCOzs7Ozs7a0RBQ3hDLDhEQUFDRzt3Q0FBRUgsV0FBVTtrREFBMEI7Ozs7Ozs7Ozs7OzswQ0FNekMsOERBQUNDO2dDQUFJRCxXQUFVOzBDQUNiLDRFQUFDVixzREFBYUE7b0NBQ1pjLGNBQWNSO29DQUNkQyxXQUFXQTtvQ0FDWEMsY0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUtwQiw4REFBQ0c7d0JBQUlELFdBQVU7a0NBQ1pMLHFCQUNDOzs4Q0FDRSw4REFBQ0oscURBQVlBO29DQUFDSSxNQUFNQTtvQ0FBTUUsV0FBV0E7Ozs7Ozs4Q0FLckMsOERBQUNKLHdEQUFPQTtvQ0FBQ0UsTUFBTUE7b0NBQU1FLFdBQVdBOzs7Ozs7O3lEQUdsQyw4REFBQ007NEJBQUVILFdBQVU7c0NBQTRCOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFLL0MsOERBQUNDO2dCQUFJRCxXQUFVOzBCQUNiLDRFQUFDUixxREFBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJckI7R0FqRE1FO0tBQUFBO0FBbUROLCtEQUFlQSxJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL01haW4uanM/MjJkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IFVwbG9hZFNlY3Rpb24gZnJvbSBcIi4vVXBsb2FkU2VjdGlvblwiO1xyXG5pbXBvcnQgQ2hhcnREaXNwbGF5IGZyb20gXCIuL0NoYXJ0RGlzcGxheVwiO1xyXG5pbXBvcnQgRG93bmxvYWRKc29uIGZyb20gXCIuL0Rvd25sb2FkSnNvblwiO1xyXG4vLyBpbXBvcnQgTVVJQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL011aUNoYXJ0XCI7XHJcbi8vIGltcG9ydCBSZWNoYXJ0Q29tcG9uZW50IGZyb20gXCIuL2NoYXJ0cy9SZWNoYXJ0Q29tcG9uZW50XCI7XHJcbi8vIGltcG9ydCBEM0NoYXJ0IGZyb20gXCIuL2NoYXJ0cy9EM0NoYXJ0XCI7XHJcbmltcG9ydCBBR0NoYXJ0IGZyb20gXCIuL2NoYXJ0cy9BZ0NoYXJ0c1wiO1xyXG5cclxuY29uc3QgTWFpbiA9ICgpID0+IHtcclxuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICBjb25zdCBbY2hhcnRUeXBlLCBzZXRDaGFydFR5cGVdID0gdXNlU3RhdGUoXCJiYXJcIik7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8bWFpbiBjbGFzc05hbWU9XCJmbGV4IG1pbi1oLXNjcmVlbiBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHAtNlwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtYXgtdy00eGwgbXgtYXV0b1wiPlxyXG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciB0ZXh0LTN4bCBmb250LWJvbGQgbWItOFwiPlxyXG4gICAgICAgICAgVXBsb2FkIEpTT04gRGF0YSB0byBEaXNwbGF5IENoYXJ0XHJcbiAgICAgICAgPC9oMT5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBnYXAtNiBncmlkIGdyaWQtY29scy0xIG1kOmdyaWQtY29scy0yIHJvdW5kZWQtbGcgc2hhZG93LW1kIGFuaW1hdGUtZmFkZUluXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIG1kOml0ZW1zLXN0YXJ0IHRleHQtd2hpdGVcIj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCBtYi00XCI+UHJlcGFyZSBZb3VyIERhdGE8L2gxPlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIHRleHQtd2hpdGUgbWItNFwiPlxyXG4gICAgICAgICAgICAgIFVwbG9hZCB5b3VyIEpTT04gZGF0YSB0byBzdGFydC4gVGhlIGRhdGEgd2lsbCBiZSB2YWxpZGF0ZWQgYW5kXHJcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkIGFzIHlvdSB1cGxvYWQgaXQuIEVuc3VyZSB0aGF0IHRoZSBkYXRhIGFkaGVyZXMgdG8gSlNPTlxyXG4gICAgICAgICAgICAgIHNwZWNpZmljYXRpb25zIHRvIHByb3Blcmx5IGRpc3BsYXkgdGhlIGNoYXJ0cy5cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIG1kOml0ZW1zLXN0YXJ0XCI+XHJcbiAgICAgICAgICAgIDxVcGxvYWRTZWN0aW9uXHJcbiAgICAgICAgICAgICAgb25GaWxlVXBsb2FkPXtzZXREYXRhfVxyXG4gICAgICAgICAgICAgIGNoYXJ0VHlwZT17Y2hhcnRUeXBlfVxyXG4gICAgICAgICAgICAgIHNldENoYXJ0VHlwZT17c2V0Q2hhcnRUeXBlfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBnYXAtNiBtdC04XCI+XHJcbiAgICAgICAgICB7ZGF0YSA/IChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICA8Q2hhcnREaXNwbGF5IGRhdGE9e2RhdGF9IGNoYXJ0VHlwZT17Y2hhcnRUeXBlfSAvPlxyXG4gICAgICAgICAgICAgIHsvKiA8TVVJQ2hhcnQgZGF0YT17ZGF0YX0gLz5cclxuICAgICAgICAgICAgICA8UmVjaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSAvPlxyXG4gICAgICAgICAgICAgIDxEM0NoYXJ0IGRhdGE9e2RhdGF9IC8+XHJcbiAgICAgICAgICAgICAgPEFHQ2hhcnQgZGF0YT17ZGF0YX0gLz4gKi99XHJcbiAgICAgICAgICAgICAgPEFHQ2hhcnQgZGF0YT17ZGF0YX0gY2hhcnRUeXBlPXtjaGFydFR5cGV9Lz4gXHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1ncmF5LTYwMFwiPk5vIGRhdGEgdXBsb2FkZWQgeWV0LjwvcD5cclxuICAgICAgICAgICl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaXhlZCBib3R0b20tNCByaWdodC00IHotNTBcIj5cclxuICAgICAgICA8RG93bmxvYWRKc29uIC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9tYWluPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYWluO1xyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJVcGxvYWRTZWN0aW9uIiwiQ2hhcnREaXNwbGF5IiwiRG93bmxvYWRKc29uIiwiQUdDaGFydCIsIk1haW4iLCJkYXRhIiwic2V0RGF0YSIsImNoYXJ0VHlwZSIsInNldENoYXJ0VHlwZSIsIm1haW4iLCJjbGFzc05hbWUiLCJkaXYiLCJoMSIsInAiLCJvbkZpbGVVcGxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Main.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/charts/AgCharts.js":
/*!*******************************************!*\
  !*** ./src/components/charts/AgCharts.js ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var ag_charts_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-react */ \"(app-pages-browser)/./node_modules/ag-charts-react/dist/package/index.esm.mjs\");\n\n\nconst AGChart = (param)=>{\n    let { data, chartType } = param;\n    const options = {\n        data: data,\n        series: [\n            {\n                type: \"bar\",\n                xKey: \"label\",\n                yKey: \"value\"\n            }\n        ]\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"bg-white p-6 rounded-lg shadow-lg border border-gray-200\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_1__.AgChartsReact, {\n            options: options\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\charts\\\\AgCharts.js\",\n            lineNumber: 11,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\91999\\\\Projects\\\\chart_maker\\\\src\\\\components\\\\charts\\\\AgCharts.js\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, undefined);\n};\n_c = AGChart;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AGChart);\nvar _c;\n$RefreshReg$(_c, \"AGChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NoYXJ0cy9BZ0NoYXJ0cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWdEO0FBRWhELE1BQU1DLFVBQVU7UUFBQyxFQUFFQyxJQUFJLEVBQUNDLFNBQVMsRUFBQztJQUNoQyxNQUFNQyxVQUFVO1FBQ2RGLE1BQU1BO1FBQ05HLFFBQVE7WUFBQztnQkFBRUMsTUFBTTtnQkFBT0MsTUFBTTtnQkFBU0MsTUFBTTtZQUFRO1NBQUU7SUFDekQ7SUFFQSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ1YsMERBQWFBO1lBQUNJLFNBQVNBOzs7Ozs7Ozs7OztBQUc5QjtLQVhNSDtBQWFOLCtEQUFlQSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2NoYXJ0cy9BZ0NoYXJ0cy5qcz80YmJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFnQ2hhcnRzUmVhY3QgfSBmcm9tICdhZy1jaGFydHMtcmVhY3QnO1xyXG5cclxuY29uc3QgQUdDaGFydCA9ICh7IGRhdGEsY2hhcnRUeXBlfSkgPT4ge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBkYXRhOiBkYXRhLFxyXG4gICAgc2VyaWVzOiBbeyB0eXBlOiAnYmFyJywgeEtleTogJ2xhYmVsJywgeUtleTogJ3ZhbHVlJyB9XSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTYgcm91bmRlZC1sZyBzaGFkb3ctbGcgYm9yZGVyIGJvcmRlci1ncmF5LTIwMFwiPlxyXG4gICAgICA8QWdDaGFydHNSZWFjdCBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFHQ2hhcnQ7XHJcbiJdLCJuYW1lcyI6WyJBZ0NoYXJ0c1JlYWN0IiwiQUdDaGFydCIsImRhdGEiLCJjaGFydFR5cGUiLCJvcHRpb25zIiwic2VyaWVzIiwidHlwZSIsInhLZXkiLCJ5S2V5IiwiZGl2IiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/charts/AgCharts.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: function() { return /* binding */ AG_CHARTS_LOCALE_EN_US; },\n/* harmony export */   AgCharts: function() { return /* binding */ AgCharts; },\n/* harmony export */   AgErrorBarSupportedSeriesTypes: function() { return /* binding */ AgErrorBarSupportedSeriesTypes; },\n/* harmony export */   AgTooltipPositionType: function() { return /* binding */ AgTooltipPositionType; },\n/* harmony export */   ICONS_LEGACY: function() { return /* binding */ ICONS_LEGACY; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   _ModuleSupport: function() { return /* binding */ module_support_exports; },\n/* harmony export */   _Scale: function() { return /* binding */ sparklines_scale_exports; },\n/* harmony export */   _Scene: function() { return /* binding */ integrated_charts_scene_exports; },\n/* harmony export */   _Theme: function() { return /* binding */ integrated_charts_theme_exports; },\n/* harmony export */   _Util: function() { return /* binding */ sparklines_util_exports; },\n/* harmony export */   time: function() { return /* binding */ time_exports; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when the focused item becomes visible\n  ariaAnnounceVisible: \"visible\",\n  // Screen reader announcement when the focused item becomes hidden\n  ariaAnnounceHidden: \"hidden\",\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for the color picker dialog\n  ariaLabelColorPicker: \"Color picker\",\n  // Screen reader text for the financial charts toolbar\n  ariaLabelFinancialCharts: \"Financial Charts\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number], \",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Text for the series type toolbar's chart type button\n  toolbarSeriesTypeDropdown: \"Chart Type\",\n  // Text for the series type toolbar's OHLC chart type button\n  toolbarSeriesTypeOHLC: \"OHLC\",\n  // Text for the series type toolbar's HLC chart type button\n  toolbarSeriesTypeHLC: \"HLC\",\n  // Text for the series type toolbar's high low chart type button\n  toolbarSeriesTypeHighLow: \"High Low\",\n  // Text for the series type toolbar's candles chart type button\n  toolbarSeriesTypeCandles: \"Candles\",\n  // Text for the series type toolbar's hollow candles chart type button\n  toolbarSeriesTypeHollowCandles: \"Hollow Candles\",\n  // Text for the series type toolbar's line chart type button\n  toolbarSeriesTypeLine: \"Line\",\n  // Text for the series type toolbar's line with markers chart type button\n  toolbarSeriesTypeLineWithMarkers: \"Line with Markers\",\n  // Text for the series type toolbar's line with step line chart type button\n  toolbarSeriesTypeStepLine: \"Step Line\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend Line\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal Line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical Line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel Channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint Channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear All\",\n  /**\n   * Text for the annotation toolbar's color picker annotation button\n   * @deprecated v10.1.0 use `toolbarAnnotationsLineColor` instead.\n   */\n  toolbarAnnotationsColor: \"Color\",\n  // Text for the annotation toolbar's fill color picker annotation button\n  toolbarAnnotationsFillColor: \"Fill Color\",\n  // Text for the annotation toolbar's line color picker annotation button\n  toolbarAnnotationsLineColor: \"Line Color\",\n  // Text for the annotation toolbar's text color picker annotation button\n  toolbarAnnotationsTextColor: \"Text Color\",\n  // Text for the annotation toolbar's text size picker annotation button\n  toolbarAnnotationsTextSize: \"Text Size\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete\",\n  // Text for the annotation toolbar's line annotations menu button\n  toolbarAnnotationsLineAnnotations: \"Trend Lines\",\n  // Text for the annotation toolbar's text annotations menu button\n  toolbarAnnotationsTextAnnotations: \"Text Annotations\",\n  // Text for the annotation toolbar's callout button\n  toolbarAnnotationsCallout: \"Callout\",\n  // Text for the annotation toolbar's comment button\n  toolbarAnnotationsComment: \"Comment\",\n  // Text for the annotation toolbar's note button\n  toolbarAnnotationsNote: \"Note\",\n  // Text for the annotation toolbar's text button\n  toolbarAnnotationsText: \"Text\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1M\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3M\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6M\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1Y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\"\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = {};\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/toolbarOptions.ts\nvar ICONS_LEGACY = [\n  \"delete-legacy\",\n  \"disjoint-channel\",\n  \"disjoint-channel-legacy\",\n  \"horizontal-line-legacy\",\n  \"line-color-legacy\",\n  \"lock\",\n  \"lock-legacy\",\n  \"pan-end-legacy\",\n  \"pan-left-legacy\",\n  \"pan-right-legacy\",\n  \"pan-start-legacy\",\n  \"parallel-channel\",\n  \"parallel-channel-legacy\",\n  \"reset-legacy\",\n  \"trend-line\",\n  \"trend-line-legacy\",\n  \"unlock\",\n  \"unlock-legacy\",\n  \"vertical-line\",\n  \"vertical-line-legacy\",\n  \"zoom-in-legacy\",\n  \"zoom-in-alt\",\n  \"zoom-in-alt-legacy\",\n  \"zoom-out-legacy\",\n  \"zoom-out-alt\",\n  \"zoom-out-alt-legacy\"\n];\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = {};\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/function.ts\nvar doOnceState = /* @__PURE__ */ new Map();\nfunction doOnce(func, key) {\n  if (doOnceState.has(key))\n    return;\n  doOnceState.set(key, true);\n  func();\n}\ndoOnce.clear = () => doOnceState.clear();\nfunction identity(x) {\n  return x;\n}\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction throttle(callback2, waitMs = 0, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback2(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback2(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\nfunction joinFunctions(...fns) {\n  return () => {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/logger.ts\nvar Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === \"object\") {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start, stop, extend) {\n    const rangeCallback = this._rangeCallback?.(start, stop);\n    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range3 = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === \"number\" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start, stop) => {\n        const s = snapTo === \"start\" ? start : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date) => {\n      const e = this._encode(date);\n      return Math.floor((e - offset4) / step);\n    };\n    const decode13 = (encoded) => {\n      return this._decode(encoded * step + offset4);\n    };\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date) {\n  return date.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\nvar millisecond_default = millisecond;\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date) {\n  return Math.floor((date.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\nvar second_default = second;\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date) {\n  return Math.floor((date.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\nvar minute_default = minute;\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date) {\n  return Math.floor((date.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\nvar hour_default = hour;\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\nvar day_default = day;\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date) {\n    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\nvar week_default = sunday;\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\nvar month_default = month;\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date) {\n  return date.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\nvar year_default = year;\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date) {\n  return date.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction uuid() {\n  const url = URL.createObjectURL(new Blob());\n  return url.split(\"/\").at(-1);\n}\n\n// packages/ag-charts-community/src/util/iterator.ts\nfunction toIterable(value) {\n  if (typeof value !== \"object\" || value == null || !(Symbol.iterator in value)) {\n    return argsIterable(value);\n  }\n  return value;\n}\nfunction* arraysIterable(...arrays) {\n  for (const array2 of arrays) {\n    for (const e of array2) {\n      yield e;\n    }\n  }\n}\nfunction* argsIterable(...args) {\n  for (const arg of args) {\n    yield arg;\n  }\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = \"$interpolate\";\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx, y: ty } = container.transformPoint(x, y);\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared3 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared3 === 0) {\n      return { nearest, distanceSquared: distanceSquared3 };\n    } else if (distanceSquared3 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared3;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array2) {\n  const [min, max] = findMinMax(array2);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array2) {\n  if (array2.length === 0)\n    return [];\n  const result = [Infinity, -Infinity];\n  for (const val of array2) {\n    if (val < result[0])\n      result[0] = val;\n    if (val > result[1])\n      result[1] = val;\n  }\n  return result;\n}\nfunction findRangeExtent(array2) {\n  const [min, max] = findMinMax(array2);\n  return max - min;\n}\nfunction isEqual(a, b, epsilon2 = 1e-10) {\n  return Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits);\n  }\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value) {\n  if (Math.floor(value) === value)\n    return 0;\n  return String(value).split(\".\")[1]?.length ?? 0;\n}\nfunction formatNormalizedPercentage(ratio2, locale) {\n  locale = locale ?? navigator.language;\n  return new Intl.NumberFormat(locale, { style: \"percent\" }).format(ratio2);\n}\nfunction formatPercentage(percent, locale) {\n  return formatNormalizedPercentage(percent / 100, locale);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  static fromDOMRect({ x, y, width, height }) {\n    return new _BBox(x, y, width, height);\n  }\n  toDOMRect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      top: this.y,\n      left: this.x,\n      right: this.x + this.width,\n      bottom: this.y + this.height,\n      toJSON() {\n        return {};\n      }\n    };\n  }\n  clone() {\n    const { x, y, width, height } = this;\n    return new _BBox(x, y, width, height);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  intersection(other) {\n    if (!this.collidesBBox(other))\n      return;\n    const newX1 = clamp(other.x, this.x, other.x + other.width);\n    const newY1 = clamp(other.y, this.y, other.y + other.height);\n    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);\n    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);\n    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  clip(clipRect) {\n    if (clipRect === void 0)\n      return this;\n    const x1 = Math.max(this.x, clipRect.x);\n    const y1 = Math.max(this.y, clipRect.y);\n    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);\n    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);\n    this.x = x1;\n    this.y = y1;\n    this.width = Math.max(0, x2 - x1);\n    this.height = Math.max(0, y2 - y1);\n    return this;\n  }\n  shrink(amount, position) {\n    const apply2 = (pos, amt) => {\n      switch (pos) {\n        case \"top\":\n          this.y += amt;\n        case \"bottom\":\n          this.height -= amt;\n          break;\n        case \"left\":\n          this.x += amt;\n        case \"right\":\n          this.width -= amt;\n          break;\n        case \"vertical\":\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case \"horizontal\":\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case void 0:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        default:\n      }\n    };\n    if (typeof amount === \"number\") {\n      apply2(position, amount);\n    } else if (typeof amount === \"object\") {\n      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = { ...amount };\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  combine(other) {\n    const { x, y, width, height } = this;\n    this.x = Math.min(x, other.x);\n    this.y = Math.min(y, other.y);\n    this.width = Math.max(x + width, other.x + other.width) - this.x;\n    this.height = Math.max(y + height, other.y + other.height) - this.y;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));\n_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nvar RedrawType = /* @__PURE__ */ ((RedrawType2) => {\n  RedrawType2[RedrawType2[\"NONE\"] = 0] = \"NONE\";\n  RedrawType2[RedrawType2[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  RedrawType2[RedrawType2[\"MINOR\"] = 2] = \"MINOR\";\n  RedrawType2[RedrawType2[\"MAJOR\"] = 3] = \"MAJOR\";\n  return RedrawType2;\n})(RedrawType || {});\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = 1 /* TRIVIAL */,\n    type = \"normal\",\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts ?? {};\n  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey, requiredOpts);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey, requiredOpts);\n      break;\n    case \"font\":\n      setter = buildFontSetter(privateKey, requiredOpts);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {\n        this.markDirty(value, value._dirty);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty(this, redraw);\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform(redraw);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildFontSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyFont) {\n        this._dirtyFont = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nvar ChangeDetectable = class {\n  constructor() {\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar _Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements3 = [1, 0, 0, 1, 0, 0]) {\n    this.elements = elements3;\n  }\n  setElements(elements3) {\n    const e = this.elements;\n    e[0] = elements3[0];\n    e[1] = elements3[1];\n    e[2] = elements3[2];\n    e[3] = elements3[3];\n    e[4] = elements3[4];\n    e[5] = elements3[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C ?? A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements3 = new Array(6);\n    this.AxB(this.elements, other.elements, elements3);\n    return new _Matrix(elements3);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const el = this.elements;\n    const xx = el[0];\n    const xy = el[1];\n    const yx = el[2];\n    const yy = el[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    target ?? (target = new BBox(0, 0, 0, 0));\n    target.x = cx * xx + cy * yx + el[4] - w;\n    target.y = cx * xy + cy * yy + el[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return _Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX ?? 0;\n      scy = opts?.scalingCenterY ?? 0;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX ?? 0;\n      rcy = opts?.rotationCenterY ?? 0;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n};\n_Matrix.instance = new _Matrix();\nvar Matrix = _Matrix;\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node extends ChangeDetectable {\n  constructor({ isVirtual, tag, zIndex, name } = {}) {\n    super();\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = createId(this);\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this._virtualChildren = [];\n    this._children = [];\n    // Used to check for duplicate nodes.\n    this.childSet = {};\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    this.matrix = new Matrix();\n    this.dirtyTransform = false;\n    this.scalingX = 1;\n    this.scalingY = 1;\n    this.scalingCenterX = null;\n    this.scalingCenterY = null;\n    this.rotationCenterX = null;\n    this.rotationCenterY = null;\n    this.rotation = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this._childNodeCounts = {\n      groups: 0,\n      nonGroups: 0\n    };\n    this.visible = true;\n    this.dirtyZIndex = false;\n    this.zIndex = 0;\n    /** Discriminators for render order within a zIndex. */\n    this.zIndexSubOrder = void 0;\n    this.pointerEvents = 0 /* All */;\n    this.name = name;\n    this.isVirtual = isVirtual ?? false;\n    this.tag = tag ?? NaN;\n    this.zIndex = zIndex ?? 0;\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this._parent?.datum;\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n    }\n    this._datum = datum;\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this._children) {\n      child._setLayerManager(value);\n    }\n    for (const child of this._virtualChildren) {\n      child._setLayerManager(value);\n    }\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  *ancestors() {\n    let node = this;\n    while (node = node.parent) {\n      yield node;\n    }\n  }\n  *traverseUp() {\n    yield this;\n    yield* this.ancestors();\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return this._virtualChildren.length ? this._children.concat(this._virtualChildren.flatMap((next) => next.children)) : this._children;\n  }\n  get virtualChildren() {\n    return this._virtualChildren;\n  }\n  hasVirtualChildren() {\n    return this._virtualChildren.length > 0;\n  }\n  // new Set<Node>()\n  setProperties(styles, pickKeys) {\n    if (pickKeys) {\n      for (const key of pickKeys) {\n        this[key] = styles[key];\n      }\n    } else {\n      Object.assign(this, styles);\n    }\n    return this;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    nodes = toIterable(nodes);\n    for (const node of nodes) {\n      if (node.parent) {\n        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n      }\n      if (node.layerManager) {\n        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\n      }\n      if (this.childSet[node.id]) {\n        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\n      }\n      if (node.isVirtual) {\n        this._virtualChildren.push(node);\n      } else {\n        this._children.push(node);\n      }\n      this.childSet[node.id] = true;\n      node._parent = this;\n      node._setLayerManager(this.layerManager);\n    }\n    this.dirtyZIndex = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    const error = () => {\n      throw new Error(`The node to be removed is not a child of this node.`);\n    };\n    if (node.parent !== this) {\n      error();\n    }\n    if (node.isVirtual) {\n      const i = this._virtualChildren.indexOf(node);\n      if (i < 0)\n        error();\n      this._virtualChildren.splice(i, 1);\n    } else {\n      const i = this._children.indexOf(node);\n      if (i < 0)\n        error();\n      this._children.splice(i, 1);\n    }\n    delete this.childSet[node.id];\n    node._parent = void 0;\n    node._setLayerManager();\n    this.dirtyZIndex = true;\n    this.markDirty(node, 3 /* MAJOR */);\n    return node;\n  }\n  clear() {\n    for (const child of arraysIterable(this._virtualChildren, this._children)) {\n      child._parent = void 0;\n      child._setLayerManager();\n    }\n    this._virtualChildren.length = 0;\n    this._children.length = 0;\n    this.childSet = {};\n  }\n  calculateCumulativeMatrix() {\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    return matrix;\n  }\n  transformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformPoint(x, y);\n  }\n  inverseTransformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformPoint(x, y);\n  }\n  transformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformBBox(bbox);\n  }\n  inverseTransformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformBBox(bbox);\n  }\n  markDirtyTransform() {\n    this.dirtyTransform = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  destroy() {\n    this.parent?.removeChild(this);\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const { children } = this;\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint = child.computeTransformedBBox()?.containsPoint(x, y);\n        const hit = containsPoint ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  getBBox(forceRecalculation = false) {\n    if (this.cachedBBox == null || forceRecalculation) {\n      this.cachedBBox = Object.freeze(this.computeBBox());\n    }\n    return this.cachedBBox;\n  }\n  computeBBox() {\n    return;\n  }\n  computeTransformedBBox() {\n    const bbox = this.getBBox()?.clone();\n    if (!bbox) {\n      return;\n    }\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    matrix.transformBBox(bbox, bbox);\n    return bbox;\n  }\n  computeTransformMatrix() {\n    if (!this.dirtyTransform) {\n      return;\n    }\n    const {\n      matrix,\n      scalingX,\n      scalingY,\n      rotation,\n      translationX,\n      translationY,\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    } = this;\n    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    });\n    this.dirtyTransform = false;\n  }\n  transformRenderContext(renderCtx, layerCtx) {\n    this.computeTransformMatrix();\n    this.matrix.toContext(layerCtx ?? renderCtx.ctx);\n    return this.matrix;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender() {\n    this._childNodeCounts.groups = 0;\n    this._childNodeCounts.nonGroups = 1;\n    for (const child of this.children) {\n      const childCounts = child.preRender();\n      this._childNodeCounts.groups += childCounts.groups;\n      this._childNodeCounts.nonGroups += childCounts.nonGroups;\n    }\n    return this._childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = 0 /* NONE */;\n    this.cachedBBox = this.computeBBox();\n    if (stats) {\n      stats.nodesRendered++;\n    }\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */, parentType = type) {\n    this.cachedBBox = void 0;\n    if (this._dirty > type || this._dirty === type && type === parentType) {\n      return;\n    }\n    this._dirty = type;\n    if (this.parent) {\n      this.parent.markDirty(this, parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  markClean(opts) {\n    const { force = false, recursive = true } = opts ?? {};\n    if (this._dirty === 0 /* NONE */ && !force) {\n      return;\n    }\n    this._dirty = 0 /* NONE */;\n    if (recursive !== false) {\n      for (const child of this._virtualChildren) {\n        child.markClean({ force });\n      }\n    }\n    if (recursive === true) {\n      for (const child of this._children) {\n        child.markClean({ force });\n      }\n    }\n  }\n  onVisibleChange() {\n  }\n  get nodeCount() {\n    let count = 1;\n    let dirtyCount = this._dirty >= 0 /* NONE */ || this.dirtyTransform ? 1 : 0;\n    let visibleCount = this.visible ? 1 : 0;\n    const countChild = (child) => {\n      const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;\n      count += childCount;\n      visibleCount += childVisibleCount;\n      dirtyCount += childDirtyCount;\n    };\n    for (const child of this._children) {\n      countChild(child);\n    }\n    for (const child of this._virtualChildren) {\n      countChild(child);\n    }\n    return { count, visibleCount, dirtyCount };\n  }\n  onZIndexChange() {\n    if (this.parent) {\n      this.parent.dirtyZIndex = true;\n    }\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotation\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationY\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    changeCb: (target) => target.onVisibleChange()\n  })\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndexSubOrder\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return !!_Color.nameToHex[str.toLowerCase()];\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta3 = max - min;\n      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta3 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta3 + 2;\n      } else {\n        h = (r - g) / delta3 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta3 = max - min;\n      const rc = (max - r) / delta3;\n      const gc = (max - g) / delta3;\n      const bc = (max - b) / delta3;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = {\n  // @ts-expect-error\n  __proto__: null,\n  aliceblue: \"#F0F8FF\",\n  antiquewhite: \"#FAEBD7\",\n  aqua: \"#00FFFF\",\n  aquamarine: \"#7FFFD4\",\n  azure: \"#F0FFFF\",\n  beige: \"#F5F5DC\",\n  bisque: \"#FFE4C4\",\n  black: \"#000000\",\n  blanchedalmond: \"#FFEBCD\",\n  blue: \"#0000FF\",\n  blueviolet: \"#8A2BE2\",\n  brown: \"#A52A2A\",\n  burlywood: \"#DEB887\",\n  cadetblue: \"#5F9EA0\",\n  chartreuse: \"#7FFF00\",\n  chocolate: \"#D2691E\",\n  coral: \"#FF7F50\",\n  cornflowerblue: \"#6495ED\",\n  cornsilk: \"#FFF8DC\",\n  crimson: \"#DC143C\",\n  cyan: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  darkcyan: \"#008B8B\",\n  darkgoldenrod: \"#B8860B\",\n  darkgray: \"#A9A9A9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#A9A9A9\",\n  darkkhaki: \"#BDB76B\",\n  darkmagenta: \"#8B008B\",\n  darkolivegreen: \"#556B2F\",\n  darkorange: \"#FF8C00\",\n  darkorchid: \"#9932CC\",\n  darkred: \"#8B0000\",\n  darksalmon: \"#E9967A\",\n  darkseagreen: \"#8FBC8F\",\n  darkslateblue: \"#483D8B\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  darkturquoise: \"#00CED1\",\n  darkviolet: \"#9400D3\",\n  deeppink: \"#FF1493\",\n  deepskyblue: \"#00BFFF\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1E90FF\",\n  firebrick: \"#B22222\",\n  floralwhite: \"#FFFAF0\",\n  forestgreen: \"#228B22\",\n  fuchsia: \"#FF00FF\",\n  gainsboro: \"#DCDCDC\",\n  ghostwhite: \"#F8F8FF\",\n  gold: \"#FFD700\",\n  goldenrod: \"#DAA520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#ADFF2F\",\n  grey: \"#808080\",\n  honeydew: \"#F0FFF0\",\n  hotpink: \"#FF69B4\",\n  indianred: \"#CD5C5C\",\n  indigo: \"#4B0082\",\n  ivory: \"#FFFFF0\",\n  khaki: \"#F0E68C\",\n  lavender: \"#E6E6FA\",\n  lavenderblush: \"#FFF0F5\",\n  lawngreen: \"#7CFC00\",\n  lemonchiffon: \"#FFFACD\",\n  lightblue: \"#ADD8E6\",\n  lightcoral: \"#F08080\",\n  lightcyan: \"#E0FFFF\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  lightgray: \"#D3D3D3\",\n  lightgreen: \"#90EE90\",\n  lightgrey: \"#D3D3D3\",\n  lightpink: \"#FFB6C1\",\n  lightsalmon: \"#FFA07A\",\n  lightseagreen: \"#20B2AA\",\n  lightskyblue: \"#87CEFA\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#B0C4DE\",\n  lightyellow: \"#FFFFE0\",\n  lime: \"#00FF00\",\n  limegreen: \"#32CD32\",\n  linen: \"#FAF0E6\",\n  magenta: \"#FF00FF\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66CDAA\",\n  mediumblue: \"#0000CD\",\n  mediumorchid: \"#BA55D3\",\n  mediumpurple: \"#9370DB\",\n  mediumseagreen: \"#3CB371\",\n  mediumslateblue: \"#7B68EE\",\n  mediumspringgreen: \"#00FA9A\",\n  mediumturquoise: \"#48D1CC\",\n  mediumvioletred: \"#C71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#F5FFFA\",\n  mistyrose: \"#FFE4E1\",\n  moccasin: \"#FFE4B5\",\n  navajowhite: \"#FFDEAD\",\n  navy: \"#000080\",\n  oldlace: \"#FDF5E6\",\n  olive: \"#808000\",\n  olivedrab: \"#6B8E23\",\n  orange: \"#FFA500\",\n  orangered: \"#FF4500\",\n  orchid: \"#DA70D6\",\n  palegoldenrod: \"#EEE8AA\",\n  palegreen: \"#98FB98\",\n  paleturquoise: \"#AFEEEE\",\n  palevioletred: \"#DB7093\",\n  papayawhip: \"#FFEFD5\",\n  peachpuff: \"#FFDAB9\",\n  peru: \"#CD853F\",\n  pink: \"#FFC0CB\",\n  plum: \"#DDA0DD\",\n  powderblue: \"#B0E0E6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#FF0000\",\n  rosybrown: \"#BC8F8F\",\n  royalblue: \"#4169E1\",\n  saddlebrown: \"#8B4513\",\n  salmon: \"#FA8072\",\n  sandybrown: \"#F4A460\",\n  seagreen: \"#2E8B57\",\n  seashell: \"#FFF5EE\",\n  sienna: \"#A0522D\",\n  silver: \"#C0C0C0\",\n  skyblue: \"#87CEEB\",\n  slateblue: \"#6A5ACD\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#FFFAFA\",\n  springgreen: \"#00FF7F\",\n  steelblue: \"#4682B4\",\n  tan: \"#D2B48C\",\n  teal: \"#008080\",\n  thistle: \"#D8BFD8\",\n  tomato: \"#FF6347\",\n  transparent: \"#00000000\",\n  turquoise: \"#40E0D0\",\n  violet: \"#EE82EE\",\n  wheat: \"#F5DEB3\",\n  white: \"#FFFFFF\",\n  whitesmoke: \"#F5F5F5\",\n  yellow: \"#FFFF00\",\n  yellowgreen: \"#9ACD32\"\n};\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/type-guards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isObjectLike(value) {\n  return isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumKey(enumObject, enumKey) {\n  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction deepMerge(...sources) {\n  return mergeDefaults(...sources.reverse());\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object2, mapper) {\n  return Object.entries(object2).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object2);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object2, keys) {\n  const clone = { ...object2 };\n  for (const key of keys) {\n    delete clone[key];\n  }\n  return clone;\n}\nfunction getPath(object2, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object2);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object2, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      Logger.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          self[propertyKey] = self[propertyKey] instanceof PropertiesArray ? self[propertyKey].reset(value) : self[propertyKey].set(value);\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        Logger.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object2, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object2;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    return new _PropertiesArray(this.itemFactory, ...properties);\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction deepClone(source, options) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, options));\n  }\n  if (isPlainObject(source)) {\n    return mapValues(\n      source,\n      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)\n    );\n  }\n  return shallowClone(source);\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return [...source];\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  if (isArray(json)) {\n    visit(json, ...jsons);\n    json.forEach((node, index) => {\n      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));\n    });\n  } else if (isPlainObject(json)) {\n    visit(json, ...jsons);\n    for (const key of Object.keys(json)) {\n      if (opts?.skip?.includes(key)) {\n        continue;\n      }\n      const value = json[key];\n      if (isArray(value) || isPlainObject(value)) {\n        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));\n      }\n    }\n  }\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property in source) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        Logger.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"object\") {\n        if (currentValue == null) {\n          targetAny[property] = {};\n        }\n        jsonApply(currentValue ?? targetAny[property], newValue, {\n          ...params,\n          path: propertyPath,\n          matcherPath: propertyMatcherPath\n        });\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\nfunction keyMapper(data, key) {\n  return data.map((dataObject) => dataObject?.[key]);\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array2) {\n  return array2.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    if (opts.from === opts.to)\n      return 0;\n    const diff2 = typeof opts.from === \"object\" ? jsonDiff(opts.from, opts.to) : null;\n    if (diff2) {\n      return calculatedDuration;\n    }\n    return 0;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  pause() {\n    this.isPlaying = false;\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from2, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from2, to);\n    }\n    const interpolatorEntries = [];\n    for (const key in to) {\n      const interpolator = this.interpolateValue(from2[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a === void 0 || b === void 0) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b)\n            return () => a;\n          break;\n      }\n    } catch (e) {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, intermediateFn } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      const { phase, start, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null && toFinish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from2,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          node.setProperties({ ...start, ...toStart });\n        },\n        onUpdate(props) {\n          node.setProperties(props);\n          if (intermediateFn) {\n            node.setProperties(intermediateFn(node, node.datum, status, ctx));\n          }\n        },\n        onStop: () => {\n          node.setProperties({\n            ...start,\n            ...toStart,\n            ...from2,\n            ...to,\n            ...finish,\n            ...toFinish\n          });\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from2;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start, finish, phase } = extraOpts;\n  const collapsable = finish == null;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from2,\n    to,\n    ease: easeOut,\n    collapsable,\n    onPlay: () => {\n      if (!start)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n        selection.cleanup();\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date, year2 = date.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date, year2 - 1);\n}\nfunction timezone(date) {\n  const offset4 = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(x) {\n  return x instanceof Date ? x.getTime() : x;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date) => formatter(date);\n}\nfunction calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));\n  }\n  const startYear = new Date(domain[0]).getFullYear();\n  const stopYear = new Date(domain.at(-1)).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second_default.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute_default.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour_default.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day_default.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month_default.floor(value) < value) {\n    if (week_default.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year_default.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\")\n      return true;\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.length - [...formatParts].reverse().findIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale {\n  constructor() {\n    this.type = \"band\";\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = /* @__PURE__ */ new Map();\n    /**\n     * The output range values for datum at each index.\n     */\n    this.ordinalRange = [];\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  set domain(values) {\n    this.index = /* @__PURE__ */ new Map();\n    this.invalid = true;\n    this._domain = [];\n    for (const value of values) {\n      const key = dateToNumber(value);\n      if (this.getIndex(key) === void 0) {\n        this.index.set(key, this._domain.push(value) - 1);\n      }\n    }\n  }\n  get domain() {\n    return this._domain;\n  }\n  getDomain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    return this._domain;\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null) {\n      return NaN;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => p === position);\n    return this.domain[index];\n  }\n  invertNearest(position) {\n    this.refresh();\n    let nearest = -1;\n    let minDistance = Infinity;\n    const index = this.ordinalRange.findIndex((p, i) => {\n      if (p === position)\n        return true;\n      const distance3 = Math.abs(position - p);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        nearest = i;\n      }\n      return false;\n    });\n    return this.domain[index] ?? this.domain[nearest];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round3 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep, step, inset;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n      step = round3 ? Math.round(rawStep) : rawStep;\n      inset = rangeDistance * paddingOuter;\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n      step = round3 ? Math.floor(rawStep) : rawStep;\n      inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    }\n    let bandwidth = step * (1 - paddingInner);\n    if (round3) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n    this.ordinalRange = this._domain.map((_, i) => inset + step * i);\n  }\n  getIndex(value) {\n    return this.index.get(value instanceof Date ? value.getTime() : value);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      let valueString = stringify(value);\n      const maxLength = 50;\n      if (valueString != null && valueString.length > maxLength) {\n        const excessCharacters = valueString.length - maxLength;\n        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;\n      }\n      Logger.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid2 = predicate(value, ctx);\n        if (!isValid2) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid2;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar DEGREE = NUMBER.restrict({ min: -360, max: 360 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v) => options.includes(v),\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.map((option) => `'${option}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\nfunction stringify(value) {\n  if (typeof value === \"number\") {\n    if (isNaN(value))\n      return \"NaN\";\n    if (value === Infinity)\n      return \"Infinity\";\n    if (value === -Infinity)\n      return \"-Infinity\";\n  }\n  return JSON.stringify(value);\n}\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    const sequencedModules = [\"toolbar\", \"navigator\"];\n    for (const m of this.moduleMap.values()) {\n      if (sequencedModules.includes(m.module.optionsKey)) {\n        continue;\n      }\n      yield m.moduleInstance;\n    }\n    for (const key of sequencedModules) {\n      const module = this.moduleMap.get(key);\n      if (module) {\n        yield module.moduleInstance;\n      }\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback2) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from2 = propsFn(node, node.datum);\n      node.setProperties(from2);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from2 = propsFn(node, node.datum);\n    node.setProperties(from2);\n  }\n}\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale {\n  constructor(domain, range3) {\n    this.invalid = true;\n    this.nice = false;\n    this.interval = void 0;\n    this.tickCount = _ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    // TODO(olegat) should be of type D[]\n    this.niceDomain = [];\n    this.defaultClampMode = \"raw\";\n    this.domain = domain;\n    this.range = range3;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const rangeDistance = this.getPixelRange();\n    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    const clampMode = opts?.clampMode ?? this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map((d) => this.transform(d));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    x = this.transform(x);\n    if (clampMode === \"clamped\") {\n      const [start, stop] = findMinMax(domain.map(Number));\n      if (Number(x) < start) {\n        return r0;\n      } else if (Number(x) > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\n_ContinuousScale.defaultMaxTickCount = 6;\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"nice\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"interval\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"maxTickCount\", 2);\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align, sign = \"-\", symbol, zero, width, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width != null && !isNaN(width)) {\n      result = addPadding(result, width, fill ?? zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width, fill = \" \", align = \">\") {\n  let result = numString;\n  if (align === \">\" || !align) {\n    result = result.padStart(width, fill);\n  } else if (align === \"<\") {\n    result = result.padEnd(width, fill);\n  } else if (align === \"^\") {\n    const padWidth = Math.max(0, width - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/array.ts\nfunction times(n, callback2) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(callback2(i));\n  }\n  return results;\n}\nfunction extent(values) {\n  if (values.length === 0) {\n    return;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let n of values) {\n    if (n instanceof Date) {\n      n = n.getTime();\n    }\n    if (typeof n !== \"number\") {\n      continue;\n    }\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n      max = n;\n    }\n  }\n  const result = [min, max];\n  if (result.every(isFinite)) {\n    return result;\n  }\n}\nfunction normalisedExtent(d, min, max) {\n  return normalisedExtentWithMetadata(d, min, max).extent;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array2) {\n  return Array.from(new Set(array2));\n}\nfunction groupBy(array2, iteratee) {\n  return array2.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction bifurcate(isLeft, array2) {\n  return array2.reduce(\n    ([left, right], value) => isLeft(value) ? [[...left, value], right] : [left, [...right, value]],\n    [[], []]\n  );\n}\nfunction* mapIterable(src, predicate) {\n  for (const e of src) {\n    yield predicate(e);\n  }\n}\nfunction constStringsIncludes(array2, value) {\n  const casting = array2;\n  return casting.includes(value);\n}\nfunction isInStringUnion(unionValues, value) {\n  return constStringsIncludes(unionValues, value);\n}\nfunction allInStringUnion(unionValues, values) {\n  return !values.some((v) => !isInStringUnion(unionValues, v));\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second_default, durationSecond, 1),\n  tInterval(second_default, durationSecond, 5),\n  tInterval(second_default, durationSecond, 15),\n  tInterval(second_default, durationSecond, 30),\n  tInterval(minute_default, durationMinute, 1),\n  tInterval(minute_default, durationMinute, 5),\n  tInterval(minute_default, durationMinute, 15),\n  tInterval(minute_default, durationMinute, 30),\n  tInterval(hour_default, durationHour, 1),\n  tInterval(hour_default, durationHour, 3),\n  tInterval(hour_default, durationHour, 6),\n  tInterval(hour_default, durationHour, 12),\n  tInterval(day_default, durationDay, 1),\n  tInterval(day_default, durationDay, 2),\n  tInterval(week_default, durationWeek, 1),\n  tInterval(week_default, durationWeek, 2),\n  tInterval(week_default, durationWeek, 3),\n  tInterval(month_default, durationMonth, 1),\n  tInterval(month_default, durationMonth, 2),\n  tInterval(month_default, durationMonth, 3),\n  tInterval(month_default, durationMonth, 4),\n  tInterval(month_default, durationMonth, 6),\n  tInterval(year_default, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction createTicks(start, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return range(start, stop, stop - start);\n  }\n  const step = tickStep(start, stop, count, minCount, maxCount);\n  if (isNaN(step)) {\n    return [];\n  }\n  start = Math.ceil(start / step) * step;\n  stop = Math.floor(stop / step) * step;\n  return range(start, stop, step);\n}\nfunction getTickInterval(start, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start, stop, count, minCount, maxCount), 1);\n    return millisecond_default.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year_default.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start, end, count, minCount = 0, maxCount = Infinity) {\n  if (start === end) {\n    return 1;\n  }\n  if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\\.|e/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const [_integer, decimal] = x.toExponential(digits - 1).split(/\\.|e/g);\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start, end, step) {\n  const n = Math.ceil(Math.abs(end - start) / step);\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start, end);\n  return times(n + 1, (i) => Math.round((d0 + step * i) * f) / f);\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    Logger.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start, end) {\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start, end];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start / m) * m;\n    const d1 = Math.ceil(end / m) * m;\n    const error = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error) {\n      minError = error;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\nfunction estimateTickCount(rangeExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {\n  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));\n  if (isNaN(minSpacing)) {\n    minSpacing = defaultMinSpacing;\n  }\n  if (isNaN(maxSpacing)) {\n    maxSpacing = rangeExtent;\n  }\n  if (minSpacing > maxSpacing) {\n    if (minSpacing === defaultMinSpacing) {\n      minSpacing = maxSpacing;\n    } else {\n      maxSpacing = minSpacing;\n    }\n  }\n  const maxTickCount = clamp(1, Math.floor(rangeExtent / minSpacing), Math.min(Math.floor(rangeExtent), 100));\n  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / maxSpacing));\n  const tickCount = clamp(minTickCount, defaultTickCount, maxTickCount);\n  return { minTickCount, maxTickCount, tickCount };\n}\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar _LogScale = class _LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = \"log\";\n    this.base = 10;\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    this.defaultClampMode = \"clamped\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  refresh() {\n    if (this.base <= 0) {\n      this.base = 0;\n      Logger.warnOnce(\"expecting a finite Number greater than to 0\");\n    }\n    super.refresh();\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.baseLog = _LogScale.getBaseLogMethod(this.base);\n    this.basePow = _LogScale.getBasePowerMethod(this.base);\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = this.pow(roundStart(this.log(d0)));\n    const n1 = this.pow(roundStop(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  ticks() {\n    const count = this.tickCount ?? 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    const start = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start);\n    let p1 = this.log(stop);\n    if (this.interval) {\n      const inBounds = (tick) => tick >= start && tick <= stop;\n      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);\n    }\n    const ticks = [];\n    const isPositive = start > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    if (count !== Infinity && ticks == null) {\n      this.ticks();\n    }\n    specifier ?? (specifier = this.base === 10 ? \".0e\" : \",\");\n    return isString(specifier) ? numberFormat(specifier) : specifier;\n  }\n  static getBaseLogMethod(base) {\n    switch (base) {\n      case 10:\n        return Math.log10;\n      case Math.E:\n        return Math.log;\n      case 2:\n        return Math.log2;\n      default:\n        const logBase = Math.log(base);\n        return (x) => Math.log(x) / logBase;\n    }\n  }\n  static getBasePowerMethod(base) {\n    switch (base) {\n      case 10:\n        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;\n      case Math.E:\n        return Math.exp;\n      default:\n        return (x) => base ** x;\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], _LogScale.prototype, \"base\", 2);\nvar LogScale = _LogScale;\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class _TimeScale extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(x, opts) {\n    return super.convert(new Date(x), opts);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;\n    const [start, stop] = findMinMax(this.getDomain().map(dateToNumber));\n    if (interval != null) {\n      return _TimeScale.getTicksForInterval({ start, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n    } else if (nice && tickCount === 2) {\n      return this.niceDomain;\n    } else if (nice && tickCount === 1) {\n      return this.niceDomain.slice(0, 1);\n    }\n    return _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n  }\n  static getDefaultTicks({\n    start,\n    stop,\n    tickCount,\n    minTickCount,\n    maxTickCount\n  }) {\n    const t = getTickInterval(start, stop, tickCount, minTickCount, maxTickCount);\n    return t ? t.range(new Date(start), new Date(stop)) : [];\n  }\n  static getTicksForInterval({\n    start,\n    stop,\n    interval,\n    availableRange\n  }) {\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks2 = interval.range(new Date(start), new Date(stop));\n      if (isDenseInterval(ticks2.length, availableRange)) {\n        return;\n      }\n      return ticks2;\n    }\n    const absInterval = Math.abs(interval);\n    if (isDenseInterval((stop - start) / absInterval, availableRange))\n      return;\n    const reversedInterval = [...TickIntervals].reverse();\n    const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval.duration === 0);\n    if (timeInterval) {\n      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n      return i.range(new Date(start), new Date(stop));\n    }\n    let date = new Date(start);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier,\n    formatOffset\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   * This method typically modifies the scales domain, and may only extend the bounds to the nearest round value.\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start = Math.min(dateToNumber(d0), dateToNumber(d1));\n    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n    const isReversed = d0 > d1;\n    const { interval } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === \"number\" ? (stop - start) / Math.max(interval, 1) : this.tickCount;\n      i = getTickInterval(start, stop, tickCount, this.minTickCount, this.maxTickCount);\n    }\n    if (i) {\n      const intervalRange = i.range(new Date(start), new Date(stop), true);\n      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n      const n0 = domain[0];\n      const n1 = domain.at(-1);\n      this.niceDomain = [n0, n1];\n    }\n  }\n};\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nvar _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.interval = void 0;\n    this._domain = [];\n    this.timestamps = [];\n    this.sortedTimestamps = [];\n    this.visibleRange = [0, 1];\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  setVisibleRange(visibleRange) {\n    this.visibleRange = visibleRange;\n  }\n  set domain(values) {\n    this.invalid = true;\n    if (values.length === 0) {\n      this._domain = [];\n      return;\n    }\n    this._domain = values;\n    this.timestamps = unique(values.map(dateToNumber));\n    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];\n    const start = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const isReversed = t0 > t1;\n    let ticks;\n    if (this.interval == null) {\n      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);\n    } else {\n      const [r0, r1] = this.range;\n      const availableRange = Math.abs(r1 - r0);\n      ticks = TimeScale.getTicksForInterval({ start, stop, interval: this.interval, availableRange }) ?? [];\n    }\n    const tickPositions = /* @__PURE__ */ new Set();\n    return ticks.filter((tick) => {\n      const position = this.convert(tick);\n      if (isNaN(position) || tickPositions.has(position)) {\n        return false;\n      }\n      tickPositions.add(position);\n      return true;\n    });\n  }\n  getDefaultTicks(maxTickCount, isReversed) {\n    const ticks = [];\n    const count = this.timestamps.length;\n    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);\n    const tickOffset = Math.floor(tickEvery / 2);\n    for (const [index, value] of this.timestamps.entries()) {\n      if (tickEvery > 0 && (index + tickOffset) % tickEvery)\n        continue;\n      if (isReversed) {\n        ticks.push(new Date(this.timestamps[count - index - 1]));\n      } else {\n        ticks.push(new Date(value));\n      }\n    }\n    return ticks;\n  }\n  convert(d) {\n    this.refresh();\n    const n = Number(d);\n    if (n < this.sortedTimestamps[0]) {\n      return NaN;\n    }\n    let i = this.findInterval(n);\n    if (this.timestamps[0] !== this.sortedTimestamps[0]) {\n      i = this.timestamps.length - i - 1;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  findInterval(target) {\n    const { sortedTimestamps } = this;\n    let low = 0;\n    let high = sortedTimestamps.length - 1;\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => position <= p);\n    return this.domain[index];\n  }\n  invertNearest(y) {\n    return new Date(super.invertNearest(y));\n  }\n};\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"maxTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"interval\", 2);\nvar OrdinalTimeScale = _OrdinalTimeScale;\n\n// packages/ag-charts-community/src/util/compare.ts\nfunction ascendingStringNumberUndefined(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  } else if (a == null && b == null) {\n    return 0;\n  } else if (a == null) {\n    return -1;\n  } else if (b == null) {\n    return 1;\n  }\n  return String(a).localeCompare(String(b));\n}\nfunction toLiteral(v) {\n  return typeof v === \"function\" ? v() : v;\n}\nfunction compoundAscending(a, b, comparator) {\n  for (const idx in a) {\n    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff2 !== 0) {\n      return diff2;\n    }\n  }\n  return 0;\n}\n\n// packages/ag-charts-community/src/scene/group.ts\nvar _Group = class _Group extends Node {\n  constructor(opts) {\n    super({ isVirtual: opts?.isVirtual, name: opts?.name });\n    this.opts = opts;\n    this.opacity = 1;\n    this.lastBBox = void 0;\n    const { zIndex, zIndexSubOrder } = opts ?? {};\n    this.isContainerNode = true;\n    if (zIndex !== void 0) {\n      this.zIndex = zIndex;\n    }\n    if (zIndexSubOrder !== void 0) {\n      this.zIndexSubOrder = zIndexSubOrder;\n    }\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  onZIndexChange() {\n    super.onZIndexChange();\n    if (this.layer) {\n      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n  isLayer() {\n    return this.layer != null;\n  }\n  _setLayerManager(layersManager) {\n    if (this._layerManager && this.layer) {\n      this._layerManager.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    if (this.layer) {\n      throw new Error(\"AG Charts - unable to deregister scene rendering layer!\");\n    }\n    super._setLayerManager(layersManager);\n  }\n  initialiseLayer() {\n    if (this.layer)\n      return;\n    if (!this._layerManager || this.opts?.layer !== true)\n      return;\n    this.layer = this._layerManager.addLayer({\n      name: this.name,\n      zIndex: this.zIndex,\n      zIndexSubOrder: this.zIndexSubOrder,\n      getComputedOpacity: () => this.getComputedOpacity(),\n      getVisibility: () => this.getVisibility()\n    });\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    for (const node of this.traverseUp()) {\n      if (node instanceof _Group) {\n        opacity *= node.opacity;\n      }\n    }\n    return opacity;\n  }\n  getVisibility() {\n    for (const node of this.traverseUp()) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  onVisibleChange() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  markDirty(source, type = 1 /* TRIVIAL */) {\n    if (this.isVirtual) {\n      super.markDirty(source, type);\n      return;\n    }\n    let parentType = type;\n    if (type < 2 /* MINOR */ || this.layer != null) {\n      parentType = 1 /* TRIVIAL */;\n    }\n    super.markDirty(source, type, parentType);\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    this.computeTransformMatrix();\n    return _Group.computeBBox(this.children);\n  }\n  computeTransformedBBox() {\n    return this.getBBox();\n  }\n  computeTransformedRegionBBox() {\n    if (this.clipRect) {\n      this.computeTransformMatrix();\n      return this.matrix.transformBBox(this.clipRect);\n    }\n    return this.computeTransformedBBox();\n  }\n  preRender() {\n    const counts = super.preRender();\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    if (this.opts?.layer !== true || this.layer != null)\n      return counts;\n    if (counts.nonGroups > 0) {\n      this.initialiseLayer();\n    }\n    if (this.opts?.nonEmptyChildDerivedZIndex && counts.nonGroups > 0) {\n      this.deriveZIndexFromChildren();\n    }\n    return counts;\n  }\n  deriveZIndexFromChildren() {\n    const children = this.children.filter((c) => c._childNodeCounts.nonGroups > 0);\n    this.sortChildren(children);\n    const lastChild = children.at(-1);\n    this.zIndex = lastChild?.zIndex ?? -Infinity;\n    this.zIndexSubOrder = lastChild?.zIndexSubOrder;\n  }\n  render(renderCtx) {\n    const { opts: { name = void 0 } = {}, _debug: debug3 } = this;\n    const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;\n    let { ctx, forceRender, clipBBox } = renderCtx;\n    const { resized, stats } = renderCtx;\n    const canvasCtxTransform = ctx.getTransform();\n    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of children) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);\n      if (isChildDirty) {\n        break;\n      }\n    }\n    if (name) {\n      debug3?.({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });\n    }\n    if (dirtyTransform) {\n      forceRender = \"dirtyTransform\";\n    } else if (layer) {\n      const currentBBox = this.getBBox();\n      if (this.lastBBox === void 0 || !this.lastBBox.equals(currentBBox)) {\n        forceRender = \"dirtyTransform\";\n        this.lastBBox = currentBBox;\n      }\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      if (name && stats) {\n        debug3?.({ name, result: \"skipping\", renderCtx, counts: this.nodeCount, group: this });\n      }\n      if (layer && stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      this.markClean({ recursive: false });\n      return;\n    }\n    const groupVisible = this.visible;\n    if (layer) {\n      ctx = layer.context;\n      ctx.save();\n      ctx.setTransform(layer.pixelRatio, 0, 0, layer.pixelRatio, 0, 0);\n      if (forceRender !== \"dirtyTransform\") {\n        forceRender = isChildDirty || dirtyZIndex;\n      }\n      if (forceRender)\n        layer.clear();\n      if (clipBBox) {\n        const { width, height, x, y } = clipBBox;\n        debug3?.(() => ({\n          name,\n          clipBBox,\n          ctxTransform: ctx.getTransform(),\n          renderCtx,\n          group: this\n        }));\n        ctx.beginPath();\n        ctx.rect(x, y, width, height);\n        ctx.clip();\n      }\n      ctx.setTransform(canvasCtxTransform);\n    } else {\n      ctx.globalAlpha *= this.opacity;\n    }\n    const matrix = this.transformRenderContext(renderCtx, ctx);\n    if (clipRect) {\n      const { x, y, width, height } = clipRect;\n      ctx.save();\n      debug3?.(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));\n      ctx.beginPath();\n      ctx.rect(x, y, width, height);\n      ctx.clip();\n      clipBBox = matrix.transformBBox(clipRect);\n    }\n    const hasVirtualChildren = this.hasVirtualChildren();\n    if (dirtyZIndex) {\n      this.sortChildren(children);\n      if (forceRender !== \"dirtyTransform\")\n        forceRender = true;\n    } else if (hasVirtualChildren) {\n      this.sortChildren(children);\n    }\n    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    const childRenderContext = renderContextChanged ? { ...renderCtx, ctx, forceRender, clipBBox } : renderCtx;\n    let skipped = 0;\n    for (const child of children) {\n      if (!child.visible || !groupVisible) {\n        child.markClean();\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      if (!forceRender && child.dirty === 0 /* NONE */) {\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      ctx.save();\n      child.render(childRenderContext);\n      ctx.restore();\n    }\n    if (stats)\n      stats.nodesSkipped += skipped;\n    super.render(renderCtx);\n    if (clipRect) {\n      ctx.restore();\n    }\n    if (hasVirtualChildren) {\n      for (const child of this.virtualChildren) {\n        child.markClean({ recursive: \"virtual\" });\n      }\n    }\n    if (layer) {\n      if (stats)\n        stats.layersRendered++;\n      ctx.restore();\n      if (forceRender)\n        layer.snapshot();\n      layer.context.verifyDepthZero?.();\n    }\n    if (name && stats) {\n      debug3?.({ name, result: \"rendered\", skipped, renderCtx, counts: this.nodeCount, group: this });\n    }\n  }\n  sortChildren(children) {\n    this.dirtyZIndex = false;\n    children.sort(\n      (a, b) => compoundAscending(\n        [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],\n        [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],\n        ascendingStringNumberUndefined\n      )\n    );\n  }\n  static computeBBox(nodes, opts) {\n    let left = Infinity;\n    let right = -Infinity;\n    let top = Infinity;\n    let bottom = -Infinity;\n    const skipInvisible = opts?.skipInvisible ?? true;\n    for (const n of nodes) {\n      if (skipInvisible && !n.visible)\n        continue;\n      const bbox = n.computeTransformedBBox();\n      if (!bbox)\n        continue;\n      const { x, y, width, height } = bbox;\n      if (x < left) {\n        left = x;\n      }\n      if (y < top) {\n        top = y;\n      }\n      if (x + width > right) {\n        right = x + width;\n      }\n      if (y + height > bottom) {\n        bottom = y + height;\n      }\n    }\n    return new BBox(left, top, right - left, bottom - top);\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectInGroupCoordinateSpace(bbox) {\n    this.clipRect = bbox ? this.transformBBox(bbox) : void 0;\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\n\n// packages/ag-charts-community/src/util/dom.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    element2.classList.add(className);\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\nfunction downloadUrl(dataUrl, fileName) {\n  const { body } = getDocument();\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\nfunction setElementBBox(element2, bbox) {\n  if (element2) {\n    element2.style.width = `${bbox.width}px`;\n    element2.style.height = `${bbox.height}px`;\n    element2.style.left = `${bbox.x}px`;\n    element2.style.top = `${bbox.y}px`;\n  }\n}\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      node.children.forEach(traverse);\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, Class, ...ExtraClasses) {\n    return _Selection.selectAll(node, (n) => {\n      return n instanceof Class || ExtraClasses.some((C) => n instanceof C);\n    });\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      const datum = this._nodes[index].datum;\n      yield { node, datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n  at(index) {\n    return this._nodes.at(index);\n  }\n};\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleDiff(angle0, angle1, counterClockwise) {\n  if (counterClockwise) {\n    [angle0, angle1] = [angle1, angle0];\n  }\n  const a0 = normalizeAngle360(angle0);\n  const a1 = normalizeAngle360(angle1) + twoPi;\n  return (a1 - a0) % twoPi;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction displacePointFromVector(centerX, centerY, radius, angle2) {\n  const x = centerX + radius * Math.cos(angle2);\n  const y = centerY + radius * Math.sin(angle2);\n  return { x, y };\n}\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(stops = []) {\n    this.stops = stops;\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(stops, angle2 = 0) {\n    super(stops);\n    this.angle = angle2;\n  }\n  createGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { stops, angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    if (w > 0 && h > 0) {\n      const diagonal = Math.sqrt(h * h + w * w) / 2;\n      const diagonalAngle = Math.atan2(h, w);\n      let quarteredAngle;\n      if (radians < Math.PI / 2) {\n        quarteredAngle = radians;\n      } else if (radians < Math.PI) {\n        quarteredAngle = Math.PI - radians;\n      } else if (radians < 1.5 * Math.PI) {\n        quarteredAngle = radians - Math.PI;\n      } else {\n        quarteredAngle = 2 * Math.PI - radians;\n      }\n      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n      for (const stop of stops) {\n        gradient.addColorStop(stop.offset, stop.color);\n      }\n      return gradient;\n    }\n    return \"black\";\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  onFillChange() {\n    const { fill } = this;\n    let linearGradientMatch;\n    if (fill?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient(\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else {\n      this.gradient = void 0;\n    }\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start, length2) {\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n    if (length2 == null) {\n      return alignedStart;\n    } else if (length2 === 0) {\n      return 0;\n    } else if (length2 < 1) {\n      return Math.ceil(length2 * pixelRatio) / pixelRatio;\n    }\n    return Math.round((length2 + start) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    path ? ctx.fill(path) : ctx.fill();\n  }\n  applyFill(ctx) {\n    ctx.fillStyle = this.gradient?.createGradient(ctx, this.getBBox()) ?? this.fill;\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    path ? ctx.stroke(path) : ctx.stroke();\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 2 /* MINOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(px, py) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      const { x, y } = this.transformPoint(px, py);\n      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  fill: void 0,\n  strokeWidth: 1\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width = 0, height = 0) {\n  return new OffscreenCanvas(width, height).getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/lruCache.ts\nvar LRUCache = class {\n  constructor(maxCacheSize = 5) {\n    this.maxCacheSize = maxCacheSize;\n    this.store = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    if (!this.store.has(key))\n      return void 0;\n    const hit = this.store.get(key);\n    this.store.delete(key);\n    this.store.set(key, hit);\n    return hit;\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  set(key, value) {\n    this.store.set(key, value);\n    if (this.store.size > this.maxCacheSize) {\n      const iterator = this.store.keys();\n      let evictCount = this.store.size - this.maxCacheSize;\n      while (evictCount > 0) {\n        const evictKeyIterator = iterator.next();\n        if (!evictKeyIterator.done) {\n          this.store.delete(evictKeyIterator.value);\n        }\n        evictCount--;\n      }\n    }\n    return value;\n  }\n  clear() {\n    this.store.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar CachedTextMeasurerPool = class {\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureText(text);\n  }\n  static measureLines(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureLines(text);\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getMeasurer(options) {\n    const font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    const key = `${font}-${options.textAlign ?? \"start\"}-${options.textBaseline ?? \"alphabetic\"}`;\n    return this.instanceMap.get(key) ?? this.createFontMeasurer(font, options, key);\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font, options, key) {\n    const ctx = createCanvasContext();\n    ctx.font = font;\n    ctx.textAlign = options.textAlign ?? \"start\";\n    ctx.textBaseline = options.textBaseline ?? \"alphabetic\";\n    const measurer = new CachedTextMeasurer(ctx, options);\n    this.instanceMap.set(key, measurer);\n    return measurer;\n  }\n};\nCachedTextMeasurerPool.instanceMap = new LRUCache(10);\nvar CachedTextMeasurer = class {\n  constructor(ctx, options) {\n    this.ctx = ctx;\n    // cached text measurements\n    this.measureMap = new LRUCache(100);\n    if (options.textAlign) {\n      ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      ctx.textBaseline = options.textBaseline;\n    }\n    ctx.font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    this.textMeasurer = new SimpleTextMeasurer(\n      (t) => this.cachedCtxMeasureText(t),\n      options.textBaseline ?? \"alphabetic\"\n    );\n  }\n  textWidth(text, estimate) {\n    return this.textMeasurer.textWidth(text, estimate);\n  }\n  measureText(text) {\n    return this.textMeasurer.measureText(text);\n  }\n  measureLines(text) {\n    return this.textMeasurer.measureLines(text);\n  }\n  cachedCtxMeasureText(text) {\n    if (!this.measureMap.has(text)) {\n      const rawResult = this.ctx.measureText(text);\n      this.measureMap.set(text, {\n        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,\n        emHeightAscent: rawResult.emHeightAscent,\n        emHeightDescent: rawResult.emHeightDescent,\n        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,\n        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,\n        alphabeticBaseline: rawResult.alphabeticBaseline,\n        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,\n        hangingBaseline: rawResult.hangingBaseline,\n        ideographicBaseline: rawResult.ideographicBaseline,\n        width: rawResult.width\n      });\n    }\n    return this.measureMap.get(text);\n  }\n};\nvar TextUtils = class {\n  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {\n    let fontString = \"\";\n    if (fontStyle) {\n      fontString += `${fontStyle} `;\n    }\n    if (fontWeight) {\n      fontString += `${fontWeight} `;\n    }\n    fontString += `${fontSize}px`;\n    if (lineHeight) {\n      fontString += `/${lineHeight}px`;\n    }\n    fontString += ` ${fontFamily}`;\n    return fontString.trim();\n  }\n  static getLineHeight(fontSize) {\n    return Math.ceil(fontSize * this.defaultLineHeight);\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n};\nTextUtils.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextUtils.defaultLineHeight = 1.15;\n// Normally between 1.1 and 1.2\nTextUtils.lineSplitter = /\\r?\\n/g;\nvar SimpleTextMeasurer = class {\n  constructor(measureTextFn, textBaseline = \"alphabetic\") {\n    this.measureTextFn = measureTextFn;\n    this.textBaseline = textBaseline;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Measures metrics for a single line of text.\n  getMetrics(text) {\n    const m = this.measureTextFn(text);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  getMultilineMetrics(lines) {\n    let width = 0;\n    let height = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);\n    const lineMetrics = [];\n    let index = 0;\n    const length2 = lines.length;\n    for (const line of lines) {\n      const m = this.measureTextFn(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width < m.width) {\n        width = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      lineMetrics.push({\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      });\n      index++;\n    }\n    height += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width, height, offsetTop, offsetLeft, lineMetrics };\n  }\n  textWidth(text, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text.length; i++) {\n        estimatedWidth += this.textWidth(text.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text.length > 1) {\n      return this.measureTextFn(text).width;\n    }\n    return this.charMap.get(text) ?? this.charWidth(text);\n  }\n  measureText(text) {\n    return this.getMetrics(text);\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  measureLines(text) {\n    const lines = typeof text === \"string\" ? text.split(TextUtils.lineSplitter) : text;\n    return this.getMultilineMetrics(lines);\n  }\n  charWidth(char) {\n    const { width } = this.measureTextFn(char);\n    this.charMap.set(char, width);\n    return width;\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nfunction SceneFontChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"font\", changeCb });\n}\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  static computeBBox(lines, x, y, opts) {\n    const { offsetTop, offsetLeft, width, height } = CachedTextMeasurerPool.measureLines(lines, opts);\n    return new BBox(x - offsetLeft, y - offsetTop, width, height);\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return bbox ? bbox.containsPoint(point.x, point.y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    const { fill, stroke, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = TextUtils.toFontString(this);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      ctx.fillStyle = fill;\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);\n    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);\n    for (const line of lines) {\n      renderCallback(line, x, y + offsetY);\n      offsetY += lineHeight;\n    }\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n};\n_Text.className = \"Text\";\n// The default line spacing for document editors is usually 1.15\n_Text.defaultLineHeightRatio = 1.15;\n_Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0) {\n    return false;\n  }\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!(datum?.length && datum[0].label)) {\n      continue;\n    }\n    for (let index = 0, ln = datum.length; index < ln; index++) {\n      const d = datum[index];\n      const { point, label, marker } = d;\n      const { text, width, height } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width * 0.5 + r + padding) * placement.x;\n        dy = (height * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(\n        (dataDatums) => dataDatums.some(\n          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width, height)\n        )\n      );\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width, height)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({ index, text, x, y, width, height, datum: d });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding) {\n  const result = [];\n  for (let index = 0; index < data.length; index++) {\n    const datum = data[index];\n    const {\n      point: { x, y },\n      label: { text }\n    } = datum;\n    let { width, height } = datum.label;\n    width += padding ?? 0;\n    height += padding ?? 0;\n    if (result.some((l) => rectRectOverlap(l, x, y, width, height))) {\n      return true;\n    }\n    result.push({ index, text, x, y, width, height, datum });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/equal.ts\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar debugQuietColor = \"color: grey\";\nvar _StateMachine = class _StateMachine {\n  constructor(defaultState, states, enterEach) {\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {\n      return;\n    }\n    const currentState = this.state;\n    const currentStateConfig = this.states[this.state];\n    let destination = currentStateConfig[event];\n    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;\n    if (Array.isArray(destination)) {\n      destination = destination.find((transition) => {\n        if (!transition.guard)\n          return true;\n        const valid = transition.guard(data);\n        if (!valid) {\n          this.debug(`${debugPrefix} ${transition.target} (guarded)`, debugQuietColor);\n        }\n        return valid;\n      });\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {\n      this.debug(`${debugPrefix} ${destination.target} (guarded)`, debugQuietColor);\n      return;\n    }\n    if (!destination) {\n      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);\n      return;\n    }\n    const destinationState = this.getDestinationState(destination);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`${debugPrefix} ${destinationState}`, debugColor);\n    this.state = destinationState;\n    if (typeof destination === \"function\") {\n      destination(data);\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine)) {\n      destination.action?.(data);\n    }\n    exitFn?.();\n    this.enterEach?.(currentState, destinationState);\n    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {\n      this.states[destinationState].onEnter?.(currentState, data);\n    }\n  }\n  is(value) {\n    if (this.state === _StateMachine.child && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== _StateMachine.child || !this.childState)\n      return true;\n    this.childState.transition(event, data);\n    if (!this.childState.is(_StateMachine.parent))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(destination) {\n    let state = this.state;\n    if (typeof destination === \"string\") {\n      state = destination;\n    } else if (destination instanceof _StateMachine) {\n      this.childState = destination;\n      state = _StateMachine.child;\n    } else if (typeof destination === \"object\") {\n      if (destination.target instanceof _StateMachine) {\n        this.childState = destination.target;\n        state = _StateMachine.child;\n      } else {\n        state = destination.target;\n      }\n    }\n    return state;\n  }\n};\n_StateMachine.child = \"__child\";\n_StateMachine.parent = \"__parent\";\nvar StateMachine = _StateMachine;\n\n// packages/ag-charts-community/src/util/textWrapper.ts\nvar TextWrapper = class {\n  static wrapText(text, options) {\n    return this.wrapLines(text, options).join(\"\\n\");\n  }\n  static wrapLines(text, options) {\n    const clippedResult = this.textWrap(text, options);\n    if (options.overflow === \"hide\" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {\n      return [];\n    }\n    return clippedResult;\n  }\n  static appendEllipsis(text) {\n    return text.replace(/[.,]{1,5}$/, \"\") + TextUtils.EllipsisChar;\n  }\n  static truncateLine(text, measurer, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer.textWidth(TextUtils.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text.length; i++) {\n      const charWidth = measurer.textWidth(text.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text + TextUtils.EllipsisChar : text;\n    }\n    text = text.slice(0, i).trimEnd();\n    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {\n      text = text.slice(0, -1).trimEnd();\n    }\n    return text + TextUtils.EllipsisChar;\n  }\n  static textWrap(text, options) {\n    const lines = text.split(TextUtils.lineSplitter);\n    const measurer = CachedTextMeasurerPool.getMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap == null || options.textWrap === \"on-space\";\n    for (let line of lines) {\n      line = line.trimEnd();\n      if (line === \"\") {\n        result.push(line);\n        continue;\n      }\n      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          const actualWidth = measurer.textWidth(line.slice(0, i + 1));\n          if (actualWidth <= options.maxWidth) {\n            estimatedWidth = actualWidth;\n            continue;\n          }\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = -1;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer, options);\n    return this.clipLines(result, measurer, options);\n  }\n  static getWordAt(text, position) {\n    const nextSpaceIndex = text.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height, lineMetrics } = measurer.measureLines(lines);\n    if (height <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        if (options.overflow === \"hide\") {\n          return [];\n        }\n        const clippedResults = lines.slice(0, i || 1);\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer, options) {\n    if (options.avoidOrphans === false || lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction setAttribute(e, qualifiedName, value) {\n  if (value === void 0 || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\nfunction setVisibility(element2, hiddenToken, hidden) {\n  element2.ariaHidden = `${hidden}`;\n  element2.classList.toggle(hiddenToken, hidden);\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, container, bounds) {\n  let { top, right, bottom, left, width, height } = bounds;\n  if (left != null) {\n    if (width != null) {\n      right = container.width - left + width;\n    } else if (right != null) {\n      width = container.width - left - right;\n    }\n  } else if (right != null && width != null) {\n    left = container.width - right - width;\n  }\n  if (top != null) {\n    if (height != null) {\n      bottom = container.height - top - height;\n    } else if (bottom != null) {\n      height = container.height - bottom - top;\n    }\n  } else if (bottom != null && height != null) {\n    top = container.height - bottom - height;\n  }\n  if (width == null) {\n    if (height == null) {\n      width = naturalWidth;\n      height = naturalHeight;\n    } else {\n      width = Math.ceil(naturalWidth * height / naturalHeight);\n    }\n  } else if (height == null) {\n    height = Math.ceil(naturalHeight * width / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((container.width - width) / 2);\n    } else {\n      left = container.width - right - width;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((container.height - height) / 2);\n    } else {\n      top = container.height - height - bottom;\n    }\n  }\n  return { x: left, y: top, width, height };\n}\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-chart-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-chart-dark-tooltip\";\nvar EMPTY_TOOLTIP_CONTENT = { html: \"\", ariaLabel: \"\" };\nfunction toAccessibleText(inputHtml) {\n  const lineConverter = (_match, offset4, str) => {\n    if (offset4 === 0 || str[offset4 - 1] !== \".\") {\n      return \". \";\n    }\n    return \" \";\n  };\n  return inputHtml.replace(/<br\\s*\\/?>/g, lineConverter).replace(/<\\/p\\s+>/g, lineConverter).replace(/<\\/li\\s*>/g, lineConverter).replace(/<[^<>]+>/g, \"\").replace(/\\n+/g, \" \").replace(/\\s+/g, \" \");\n}\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return { html: input, ariaLabel: input };\n  }\n  const {\n    content = defaults?.content ?? \"\",\n    title = defaults?.title,\n    color = defaults?.color ?? \"white\",\n    backgroundColor = defaults?.backgroundColor ?? \"#888\"\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : \"\";\n  const titleAria = title ? `${title}: ` : \"\";\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : \"\";\n  return {\n    html: `${titleHtml}${contentHtml}`,\n    ariaLabel: toAccessibleText(`${titleAria}${content}`)\n  };\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\"\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.bounds = \"extended\";\n    this.enableInteraction = false;\n    this.lastVisibilityChange = Date.now();\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n    setAttribute(this.element, \"aria-hidden\", true);\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n  }\n  isVisible() {\n    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + \"-hidden\");\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(boundingRect, canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    if (content != null && element2 != null) {\n      element2.innerHTML = content.html;\n    } else if (!element2?.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });\n    const relativeRect = {\n      x: boundingRect.x - canvasRect.x,\n      y: boundingRect.y - canvasRect.y,\n      width: boundingRect.width,\n      height: boundingRect.height\n    };\n    const position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    const minX = relativeRect.x;\n    const minY = relativeRect.y;\n    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;\n    const maxY = relativeRect.height - element2.clientHeight + minY;\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    element2.style.pointerEvents = meta.enableInteraction ? \"auto\" : \"none\";\n    element2.setAttribute(\"data-pointer-capture\", \"retain\");\n    this.enableInteraction = meta.enableInteraction ?? false;\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  toggle(visible) {\n    if (!this.element)\n      return;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);\n    const wasVisible = this.isVisible();\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    if (wasVisible !== visible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const animatedMoveThresholdMs = 100;\n    const thrashingThresholdMs = 5;\n    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass(\"no-animation\", noAnimation);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"hidden\", !visible);\n    toggleClass(\"arrow\", this._showArrow);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    if (newValue) {\n      target.element?.classList.add(newValue);\n    }\n    if (oldValue) {\n      target.element?.classList.remove(oldValue);\n    }\n  }),\n  Validate(STRING, { optional: true })\n], Tooltip.prototype, \"class\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(UNION([\"extended\", \"canvas\"]))\n], Tooltip.prototype, \"bounds\", 2);\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new Text({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.truncated = false;\n    this.layoutStyle = \"block\";\n  }\n  registerInteraction(moduleCtx) {\n    const { regionManager, proxyInteractionService, layoutService } = moduleCtx;\n    const region = regionManager.getRegion(\"root\");\n    const destroyFns = [\n      layoutService.addListener(\"layout-complete\", () => this.updateA11yText(proxyInteractionService)),\n      region.addListener(\"hover\", (event) => this.handleMouseMove(moduleCtx, event)),\n      region.addListener(\"leave\", (event) => this.handleMouseLeave(moduleCtx, event))\n    ];\n    return joinFunctions(...destroyFns);\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth);\n    const maxHeight = this.maxHeight ?? containerHeight;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrappedText = TextWrapper.wrapText(text ?? \"\", { maxWidth, maxHeight, font: this, textWrap: wrapping });\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);\n  }\n  updateA11yText(proxyService) {\n    if (this.enabled && this.text) {\n      const bbox = this.node.computeTransformedBBox();\n      if (bbox) {\n        const { id } = this;\n        this.proxyText ?? (this.proxyText = proxyService.createProxyElement({ type: \"text\", id, parent: \"canvas-proxy\" }));\n        this.proxyText.textContent = this.text;\n        this.proxyText.updateBounds(bbox);\n      }\n    } else {\n      this.proxyText?.remove();\n      this.proxyText = void 0;\n    }\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {\n      const { offsetX, offsetY } = event;\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.text })\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN)\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"lineHeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return TextUtils.toFontString(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction calculateLabelBBox(text, bbox, labelMatrix) {\n  const { x: labelX, y: labelY, width, height } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const { x, y } = bbox;\n  return {\n    point: { x, y },\n    label: { text, width, height }\n  };\n}\n\n// packages/ag-charts-community/src/chart/layers.ts\nvar Layers = /* @__PURE__ */ ((Layers2) => {\n  Layers2[Layers2[\"SERIES_BACKGROUND_ZINDEX\"] = 0] = \"SERIES_BACKGROUND_ZINDEX\";\n  Layers2[Layers2[\"AXIS_GRID_ZINDEX\"] = 1] = \"AXIS_GRID_ZINDEX\";\n  Layers2[Layers2[\"AXIS_ZINDEX\"] = 2] = \"AXIS_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 3] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LAYER_ZINDEX\"] = 4] = \"SERIES_LAYER_ZINDEX\";\n  Layers2[Layers2[\"SERIES_HIGHLIGHT_ZINDEX\"] = 5] = \"SERIES_HIGHLIGHT_ZINDEX\";\n  Layers2[Layers2[\"AXIS_FOREGROUND_ZINDEX\"] = 6] = \"AXIS_FOREGROUND_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSHAIR_ZINDEX\"] = 7] = \"SERIES_CROSSHAIR_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LABEL_ZINDEX\"] = 8] = \"SERIES_LABEL_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 9] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_ANNOTATION_ZINDEX\"] = 10] = \"SERIES_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"CHART_ANNOTATION_ZINDEX\"] = 11] = \"CHART_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"CHART_ANNOTATION_FOCUSED_ZINDEX\"] = 12] = \"CHART_ANNOTATION_FOCUSED_ZINDEX\";\n  Layers2[Layers2[\"LEGEND_ZINDEX\"] = 13] = \"LEGEND_ZINDEX\";\n  Layers2[Layers2[\"NAVIGATOR_ZINDEX\"] = 14] = \"NAVIGATOR_ZINDEX\";\n  Layers2[Layers2[\"FOREGROUND_ZINDEX\"] = 15] = \"FOREGROUND_ZINDEX\";\n  return Layers2;\n})(Layers || {});\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start, end] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start, isContinuous2) && !isNaN(scale2.convert(start));\n  const validEnd = checkDatum(end, isContinuous2) && !isNaN(scale2.convert(end));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringify(start)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringify(end)}`);\n    }\n  } else {\n    message.push(`value ${stringify(start)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  Logger.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const w = yDirection ? bbox.width : bbox.height;\n  const h = yDirection ? bbox.height : bbox.width;\n  const xTranslation = xTranslationDirection * (padding + w / 2);\n  const yTranslation = yTranslationDirection * (padding + h / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {\n  if (yDirection) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  insideLeft: { c: POSITION_LEFT_COORDINATES },\n  insideRight: { c: POSITION_RIGHT_COORDINATES },\n  insideTop: { c: POSITION_TOP_COORDINATES },\n  insideBottom: { c: POSITION_BOTTOM_COORDINATES },\n  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"topLeft\",\n    \"topRight\",\n    \"bottomLeft\",\n    \"bottomRight\",\n    \"inside\",\n    \"insideLeft\",\n    \"insideRight\",\n    \"insideTop\",\n    \"insideBottom\",\n    \"insideTopLeft\",\n    \"insideBottomLeft\",\n    \"insideTopRight\",\n    \"insideBottomRight\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar _CartesianCrossLine = class _CartesianCrossLine extends BaseProperties {\n  constructor() {\n    super();\n    this.id = createId(this);\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new Text();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.group.append(this.crossLineRange);\n    this.labelGroup.append(this.crossLineLabel);\n    this.crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible)\n      return;\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2)\n      return;\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, { clampMode: \"clamped\" })) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, { clampMode: \"clamped\" }) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine)\n      return;\n    this.data = [clampedYStart, clampedYEnd];\n    if (this.label.enabled) {\n      const yDirection = direction === \"y\" /* Y */;\n      const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n      const { x: labelX, y: labelY } = c({\n        yDirection,\n        xStart,\n        xEnd,\n        yStart: clampedYStart,\n        yEnd: clampedYEnd\n      });\n      this.labelPoint = {\n        x: labelX,\n        y: labelY\n      };\n    }\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text)\n      return;\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.computeTransformedBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    return isRange ? _CartesianCrossLine.RANGE_LAYER_ZINDEX : _CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start = range3?.[0] ?? value;\n    let end = range3?.[1];\n    if (!isContinuous2 && end === void 0) {\n      end = start;\n    }\n    if (isContinuous2 && start === end) {\n      end = void 0;\n    }\n    return [start, end];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled)\n      return;\n    const tempText = new Text();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.computeTransformedBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.translationX = x + xTranslation;\n    tempText.translationY = y + yTranslation;\n    return tempText.computeTransformedBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine)\n      return;\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)\n      return;\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\n_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE_ZINDEX */;\n_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE_ZINDEX */;\n_CartesianCrossLine.LABEL_LAYER_ZINDEX = 8 /* SERIES_LABEL_ZINDEX */;\n_CartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], _CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], _CartesianCrossLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _CartesianCrossLine.prototype, \"label\", 2);\nvar CartesianCrossLine = _CartesianCrossLine;\n\n// packages/ag-charts-community/src/chart/interaction/regions.ts\nvar REGIONS = /* @__PURE__ */ ((REGIONS2) => {\n  REGIONS2[\"TITLE\"] = \"title\";\n  REGIONS2[\"SUBTITLE\"] = \"subtitle\";\n  REGIONS2[\"FOOTNOTE\"] = \"footnote\";\n  REGIONS2[\"LEGEND\"] = \"legend\";\n  REGIONS2[\"NAVIGATOR\"] = \"navigator\";\n  REGIONS2[\"PAGINATION\"] = \"pagination\";\n  REGIONS2[\"ROOT\"] = \"root\";\n  REGIONS2[\"SERIES\"] = \"series\";\n  REGIONS2[\"HORIZONTAL_AXES\"] = \"horizontal-axes\";\n  REGIONS2[\"VERTICAL_AXES\"] = \"vertical-axes\";\n  REGIONS2[\"TOOLBAR\"] = \"toolbar\";\n  return REGIONS2;\n})(REGIONS || {});\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.minSpacing = NaN;\n    this.color = \"#575757\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start, end) {\n  const directDistance = Math.abs(end - start);\n  if (directDistance < halfCircle)\n    return end;\n  if (start > end)\n    return end + fullCircle;\n  return end - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    intermediateFn(node, _datum, _status) {\n      return { visible: !outOfBounds(node.y) };\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        opacity = 1;\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.lineNode = this.axisGroup.appendChild(new Line({ name: `${this.id}-Axis-line` }));\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });\n    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */ });\n    this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });\n    this.gridLineGroup = this.gridGroup.appendChild(\n      new Group({\n        name: `${this.id}-gridLines`,\n        zIndex: 1 /* AXIS_GRID_ZINDEX */\n      })\n    );\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\n    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this._titleCaption = new Caption();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = void 0;\n    this.maxThickness = Infinity;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n    this.destroyFns.push(this._titleCaption.registerInteraction(this.moduleCtx));\n    this._titleCaption.node.rotation = -Math.PI / 2;\n    this.axisGroup.appendChild(this._titleCaption.node);\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    this._crossLines = [];\n    let previousSize = void 0;\n    this.destroyFns.push(\n      moduleCtx.layoutService.addListener(\"layout-complete\", (e) => {\n        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = { ...e.chart };\n      })\n    );\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  set crossLines(value) {\n    const { CrossLineConstructor } = this.constructor;\n    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));\n    this._crossLines = value.map((crossLine) => {\n      const instance = new CrossLineConstructor();\n      instance.set(crossLine);\n      return instance;\n    });\n    this._crossLines.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n    this.crossLineGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n    this.crossLineGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    scale2.setVisibleRange?.(vr);\n    scale2.range = [start, start + span];\n    this.crossLines.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n    axisNode.appendChild(this.labelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n    axisNode.removeChild(this.labelGroup);\n  }\n  getAxisGroup() {\n    return this.axisGroup;\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(x, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  onFormatChange(ticks, fractionDigits, _domain, format) {\n    const { scale: scale2 } = this;\n    const logScale = scale2 instanceof LogScale;\n    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === \"number\" ? x.toFixed(fractionDigits + formatOffset) : String(x);\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        const formatter = scale2.tickFormat({ ticks, specifier: format });\n        this.labelFormatter = formatter;\n        this.datumFormatter = formatter;\n      } catch (e) {\n        this.labelFormatter = defaultFormatter(0);\n        this.datumFormatter = defaultFormatter(1);\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultFormatter(0);\n      this.datumFormatter = defaultFormatter(1);\n    }\n  }\n  setTickInterval(interval) {\n    this.scale.interval = this.interval?.step ?? interval;\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue && !value || !prevValue && value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update(_primaryTickCount = 0, animated = true) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;\n    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (!animated || this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition(\"update\", diff2);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\n    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\n    this.updateLayoutState(tickData.fractionDigits);\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  getTickLabelProps(datum, params) {\n    const { label } = this;\n    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);\n    const visible = text !== \"\" && text != null;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 6;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    titleNode.setProperties({\n      rotation,\n      text,\n      textBaseline,\n      visible: true,\n      x,\n      y\n    });\n  }\n  calculateLayout(primaryTickCount) {\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);\n    this.updateScale();\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;\n    this.updateLayoutState(tickData.fractionDigits);\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      tickData.ticks.forEach((datum) => {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    if (this.label.enabled) {\n      const tempText = new Text();\n      tickData.ticks.forEach((datum) => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties({\n          ...labelProps,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.computeTransformedBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    if (this.title?.enabled) {\n      const caption = new Caption();\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(caption, { spacing });\n      const titleNode = caption.node;\n      const titleBox = titleNode.computeTransformedBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = this.getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout?.(anySeriesActive, this.reverse);\n    });\n    return {\n      primaryTickCount: ticksResult.primaryTickCount,\n      bbox: transformedBBox\n    };\n  }\n  updateLayoutState(fractionDigits) {\n    this.layout.label = {\n      fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  getTransformBox(bbox) {\n    const matrix = new Matrix();\n    const {\n      rotation: axisRotation,\n      translationX,\n      translationY,\n      rotationCenterX,\n      rotationCenterY\n    } = this.getAxisTransform();\n    Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n      scalingCenterX: 0,\n      scalingCenterY: 0,\n      rotationCenterX,\n      rotationCenterY\n    });\n    return matrix.transformBBox(bbox);\n  }\n  setDomain(domain) {\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.scale.domain = this.dataDomain.domain;\n  }\n  updateScale() {\n    this.updateRange();\n    this.calculateDomain();\n    this.setTickInterval(this.interval.step);\n    const { scale: scale2, nice } = this;\n    if (!ContinuousScale.is(scale2)) {\n      return;\n    }\n    scale2.nice = nice;\n    scale2.update();\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      interval: { minSpacing, maxSpacing },\n      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }\n    } = this;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      fractionDigits: 0,\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\n      for (const strategy of tickStrategies) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const labelRotation = initialRotation + autoRotation;\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelOverlap = this.label.avoidCollisions ? this.checkLabelOverlap(labelRotation, rotated, labelMatrix, tickData.ticks, labelX, textMeasurer) : false;\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\n  }\n  getTickStrategies({\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label } = this;\n    const { minSpacing } = this.interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    const { scale: scale2 } = this;\n    const { step, values, minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.fractionDigits = fractionDigits;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = step !== void 0 || values !== void 0;\n    terminate || (terminate = shouldTerminate);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textMeasurer) {\n    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\n    const labelData = this.createLabelData(tickData, labelX, labelMatrix, textMeasurer);\n    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n    return axisLabelsOverlap(labelData, labelSpacing);\n  }\n  createLabelData(tickData, labelX, labelMatrix, textMeasurer) {\n    const labelData = [];\n    for (const { tickLabel, translationY } of tickData) {\n      if (!tickLabel)\n        continue;\n      const { width, height } = textMeasurer.measureLines(tickLabel);\n      const bbox = new BBox(labelX, translationY, width, height);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { range: range3, scale: scale2, visibleRange } = this;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        rawTicks = this.interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));\n          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        } else {\n          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = /* @__PURE__ */ new Map();\n    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    const filteredTicks = rawTicks.slice(start, end);\n    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);\n    for (let i = 0; i < filteredTicks.length; i++) {\n      const tick = filteredTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !this.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = this.formatTick(tick, fractionDigits, start + i);\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });\n      if (tickLabel === \"\" || tickLabel == null) {\n        continue;\n      }\n      labelCount++;\n    }\n    return { rawTicks, fractionDigits, ticks, labelCount };\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    const { scale: scale2 } = this;\n    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {\n      if (typeof tickCount === \"number\") {\n        scale2.tickCount = tickCount;\n        scale2.minTickCount = minTickCount ?? 0;\n        scale2.maxTickCount = maxTickCount ?? Infinity;\n      } else if (scale2 instanceof TimeScale) {\n        this.setTickInterval(tickCount);\n      }\n    }\n    return scale2.ticks?.() ?? [];\n  }\n  estimateTickCount({ minSpacing, maxSpacing }) {\n    if (!this.label.avoidCollisions) {\n      return {\n        minTickCount: ContinuousScale.defaultMaxTickCount,\n        maxTickCount: ContinuousScale.defaultMaxTickCount,\n        defaultTickCount: ContinuousScale.defaultMaxTickCount\n      };\n    }\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(\n      this.defaultTickMinSpacing,\n      rangeWithBleed / ContinuousScale.defaultMaxTickCount\n    );\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    const minRectDistance = 2;\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(\n      1,\n      Math.floor(rangeWithBleed / minSpacing),\n      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100\n    );\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return { minTickCount, maxTickCount, defaultTickCount };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        crossLine.label.parallel = crossLine.label.parallel ?? this.label.parallel;\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line) => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.stroke;\n      line.x1 = sideFlag * this.getTickSize();\n      line.x2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    return findRangeExtent(this.range);\n  }\n  /**\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\n   * the visible range is only a portion of the axis.\n   */\n  calculateRangeWithBleed() {\n    const visibleScale = 1 / findRangeExtent(this.visibleRange);\n    return round(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\n    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\n    this.setDomain(domains);\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      rotationCenterX: 0,\n      rotationCenterY: 0,\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;\n    const { rotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n    axisGroup.datum = this.getAxisTransform();\n    gridLineGroupSelection.each((line) => {\n      line.x1 = gridPadding;\n      line.x2 = -sideFlag * gridLength + gridPadding;\n    });\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error(\"AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.\");\n  }\n  updateSelections(lineData, data, params) {\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(\n      this.gridLength ? data : [],\n      (group) => group.append(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLineGroupSelection.update(\n      data,\n      (group) => group.appendChild(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLabelGroupSelection.update(\n      data.map((d) => this.getTickLabelProps(d, params)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n  }\n  updateAxisLine() {\n    const { line } = this;\n    const strokeWidth = line.enabled ? line.width : 0;\n    this.lineNode.setProperties({\n      stroke: line.stroke,\n      strokeWidth\n    });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: { style, width },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        fill: void 0,\n        stroke,\n        strokeWidth: width,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    const { label } = this;\n    if (!label.enabled) {\n      return;\n    }\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, [\n        \"fill\",\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStyle\",\n        \"fontWeight\",\n        \"text\",\n        \"textAlign\",\n        \"textBaseline\"\n      ]);\n    });\n  }\n  updateTitle(params) {\n    const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;\n    let spacing = 0;\n    if (title.enabled && params.anyTickVisible) {\n      const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n      spacing += tickWidth + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    this.setTitleProps(_titleCaption, { spacing });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, fractionDigits, index) {\n    return String(this.getFormatter(index, true)(datum, fractionDigits));\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(this.getFormatter()(datum));\n  }\n  getFormatter(index = 0, isTickLabel) {\n    const {\n      label,\n      labelFormatter,\n      datumFormatter,\n      moduleCtx: { callbackCache }\n    } = this;\n    if (label.formatter) {\n      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;\n    } else if (!isTickLabel && datumFormatter) {\n      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);\n    } else if (labelFormatter) {\n      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);\n    }\n    return (datum) => String(datum);\n  }\n  getBBox() {\n    return this.axisGroup.getBBox();\n  }\n  getRegionBBoxProvider() {\n    const { axisGroup } = this;\n    return {\n      id: this.id,\n      computeTransformedBBox() {\n        return axisGroup.computeTransformedBBox();\n      },\n      computeTransformedRegionBBox() {\n        return axisGroup.computeTransformedRegionBBox();\n      },\n      get visible() {\n        return axisGroup.visible;\n      }\n    };\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width, height) {\n    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  clipGrid(x, y, width, height) {\n    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  calculatePadding(min, max) {\n    const padding = Math.abs(this.reverse ? max : min) * 0.01;\n    return [padding, padding];\n  }\n  getTitleFormatterParams() {\n    const boundSeries = this.boundSeries.reduce((acc, next) => {\n      const keys = next.getKeys(this.direction);\n      const names = next.getNames(this.direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        acc.push({ key: keys[idx], name: names[idx] });\n      }\n      return acc;\n    }, []);\n    return {\n      direction: this.direction,\n      boundSeries,\n      defaultValue: this.title?.text\n    };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      id: this.id,\n      rect: this.getBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => {\n          if (keys.indexOf(key) < 0) {\n            keys.push(key);\n          }\n        });\n        return keys;\n      }, []),\n      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),\n      scaleBandwidth: () => scale2.bandwidth ?? 0,\n      scaleDomain: () => scale2.getDomain?.(),\n      scaleConvert: (val) => scale2.convert(val),\n      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),\n      scaleInvertNearest: (val) => scale2.invertNearest?.(val),\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  getScaleValueFormatter(format) {\n    const { scale: scale2 } = this;\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        return scale2.tickFormat({ specifier: format });\n      } catch (e) {\n        Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);\n      }\n    }\n    return this.getFormatter();\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = /* @__PURE__ */ new Set();\n    const removed = /* @__PURE__ */ new Set();\n    const tickMap = {};\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum?.tickId;\n      tickMap[tick ?? prev] = tickDatum;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return { changed: added.size > 0 || removed.size > 0, added, removed };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n_Axis.CrossLineConstructor = CartesianCrossLine;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  get direction() {\n    return [\"top\", \"bottom\"].includes(this.position) ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(primaryTickCount, animated) {\n    this.updateDirection();\n    return super.update(primaryTickCount, animated);\n  }\n  calculateLayout(primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(primaryTickCount);\n  }\n  createAxisContext() {\n    return {\n      ...super.createAxisContext(),\n      position: this.position\n    };\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar CategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new BandScale()) {\n    super(moduleCtx, scale2);\n    this._paddingOverrideEnabled = false;\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  set paddingInner(value) {\n    this._paddingOverrideEnabled = true;\n    this.scale.paddingInner = value;\n  }\n  get paddingInner() {\n    this._paddingOverrideEnabled = true;\n    return this.scale.paddingInner;\n  }\n  set paddingOuter(value) {\n    this.scale.paddingOuter = value;\n  }\n  get paddingOuter() {\n    return this.scale.paddingOuter;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    return { domain, clipped: false };\n  }\n  calculateDomain() {\n    if (!this._paddingOverrideEnabled) {\n      let paddingInner = Infinity;\n      let paddingOuter = -Infinity;\n      for (const s of this.boundSeries) {\n        const padding = s.getBandScalePadding?.();\n        if (padding == null)\n          continue;\n        paddingInner = Math.min(paddingInner, padding.inner);\n        paddingOuter = Math.max(paddingOuter, padding.outer);\n      }\n      this.scale.paddingInner = Number.isFinite(paddingInner) ? paddingInner : 0;\n      this.scale.paddingOuter = Number.isFinite(paddingOuter) ? paddingOuter : 0;\n    }\n    return super.calculateDomain();\n  }\n};\nCategoryAxis.className = \"CategoryAxis\";\nCategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], CategoryAxis.prototype, \"groupPaddingInner\", 2);\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar TreeNode = class {\n  // current number in sibling group (index)\n  constructor(label = \"\", parent, number2 = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number2;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n};\nfunction ticksToTree(ticks, pad2 = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad2) {\n    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach((tick) => {\n    if (pad2) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift(\"\");\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse();\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find((child) => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio2 = shift / subtrees;\n  wp.change -= ratio2;\n  wp.shift += shift;\n  wm.change += ratio2;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\nfunction apportion(v, defaultAncestor, distance3) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node, distance3) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach((child) => {\n      firstWalk(child, distance3);\n      defaultAncestor = apportion(child, defaultAncestor, distance3);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance3;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;\n  }\n}\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const { x, y } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\n}\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach((w) => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));\n    if (node.children.length) {\n      this.nonLeafNodes.push(node);\n    } else {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach((node) => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));\n    });\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach((node) => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar GroupedCategoryAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], GroupedCategoryAxisLabel.prototype, \"grid\", 2);\nvar GroupedCategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    const scale2 = new BandScale();\n    scale2.paddingOuter = 0.1;\n    scale2.paddingInner = scale2.paddingOuter * 2;\n    super(moduleCtx, scale2);\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    this.labelColor = \"rgba(87, 87, 87, 1)\";\n    this.includeInvisibleDomains = true;\n    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, Text);\n    this.lineNode.visible = false;\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    this.tickScale.range = scale2.range = [start, start + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    const s = this.scale;\n    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(\n        Math.abs(range3[1] - range3[0]),\n        layout.depth * lineHeight,\n        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,\n        -layout.depth * lineHeight,\n        range3[1] - range3[0] < 0\n      );\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineSelection.clear();\n    this.labelSelection.clear();\n  }\n  calculateDomain() {\n    const { direction } = this;\n    let isNumericX = null;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {\n      if (direction === \"y\" /* Y */ || isNumericX) {\n        return series.getDomain(direction);\n      }\n      if (isNumericX === null) {\n        const domain2 = series.getDomain(direction);\n        isNumericX = isNumber(domain2[0]);\n        return domain2;\n      }\n      return [];\n    });\n    this.setDomain(extent(flatDomains) ?? unique(flatDomains));\n    const { domain } = this.dataDomain;\n    this.tickTreeLayout = treeLayout(ticksToTree(domain));\n    this.tickScale.domain = domain.concat(\"\");\n    this.resizeTickTree();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n  }\n  updateTitleCaption() {\n    const { _titleCaption } = this;\n    _titleCaption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    const { tickLabelLayout } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout)\n      return;\n    const { separatorLayout } = this.computedLayout;\n    const { range: range3 } = this;\n    const epsilon2 = 1e-7;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = this.tick.enabled && datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;\n      line.stroke = this.tick.stroke;\n      line.fill = void 0;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout)\n      return;\n    const { axisLineLayout } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties({\n        ...datum,\n        stroke: this.line.stroke,\n        strokeWidth: this.line.width\n      });\n      line.x1 = datum.x;\n      line.x2 = datum.x;\n      line.y1 = datum.y1;\n      line.y2 = datum.y2;\n      line.strokeWidth = this.line.width;\n      line.stroke = this.line.stroke;\n    });\n  }\n  updateCategoryGridLines() {\n    const { gridLength, gridLine, label, range: range3, tickScale } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const { width, style } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = gridLine.enabled && y >= range3[0] && y <= range3[1];\n        const { stroke, lineDash } = style[index % styleCount];\n        line.stroke = stroke;\n        line.strokeWidth = width;\n        line.lineDash = lineDash;\n        line.fill = void 0;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale: scale2,\n      label,\n      label: { parallel },\n      moduleCtx: { callbackCache },\n      range: range3,\n      title,\n      title: { formatter = (p) => p.defaultValue } = {}\n    } = this;\n    const rangeStart = scale2.range[0];\n    const rangeEnd = scale2.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale2.domain.length || 0;\n    const keepEvery = Math.ceil(label.fontSize / bandwidth);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    const lineHeight = this.lineHeight;\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale2.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = (node) => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new Text();\n    const setLabelProps = (datum, index) => {\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: \"center\",\n        textBaseline: parallelFlipFlag === -1 ? \"bottom\" : \"hanging\",\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index === 0) {\n        const isCaptionEnabled = title?.enabled && labels.length > 0;\n        if (!isCaptionEnabled) {\n          return false;\n        }\n        const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n        tempText.setProperties({\n          fill: title.color,\n          fontFamily: title.fontFamily,\n          fontSize: title.fontSize,\n          fontStyle: title.fontStyle,\n          fontWeight: title.fontWeight,\n          text,\n          textBaseline: \"hanging\",\n          translationX: datum.screenY - label.fontSize * 0.25,\n          translationY: datum.screenX\n        });\n      } else if (index % keepEvery === 0) {\n        const isInRange = datum.screenX >= range3[0] && datum.screenX <= range3[1];\n        if (!isInRange) {\n          return false;\n        }\n        if (label.formatter) {\n          tempText.text = callbackCache.call(label.formatter, {\n            value: String(datum.label),\n            index\n          }) ?? String(datum.label);\n        } else {\n          tempText.text = String(datum.label);\n        }\n      } else {\n        return false;\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible)\n        return;\n      const bbox2 = tempText.computeTransformedBBox();\n      if (!bbox2)\n        return;\n      labelBBoxes.set(index, bbox2);\n      const isLeaf = !datum.children.length;\n      if (isLeaf && bbox2.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox2.width;\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      let visible = setLabelProps(datum, index);\n      const id = index;\n      tempText.x = labelX;\n      tempText.rotationCenterX = labelX;\n      const isLeaf = !datum.children.length;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n      } else {\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox2 = labelBBoxes.get(id);\n        if (bbox2 && bbox2.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(id);\n        } else if (isHorizontal) {\n          tempText.rotation = defaultRotation;\n        } else {\n          tempText.rotation = -Math.PI / 2;\n        }\n      }\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox2 = tempText.computeTransformedBBox();\n        if (bbox2) {\n          labelBBoxes.set(index, bbox2);\n        }\n        props = { ...copyLabelProps(tempText), visible };\n      } else {\n        labelBBoxes.delete(index);\n        props = { visible };\n      }\n      tickLabelLayout.push(props);\n    });\n    let minX = 0;\n    separatorData.forEach((d) => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon2 = 1e-7;\n    separatorData.forEach((datum) => {\n      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {\n        const { x1, x2, y } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({ x1, x2, y });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });\n    }\n    const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\n    const transformedBBox = this.getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = { axisLineLayout, separatorLayout, tickLabelLayout };\n    return { bbox, primaryTickCount: void 0 };\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], GroupedCategoryAxis.prototype, \"labelColor\", 2);\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.dependents = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n        }\n      } else {\n        this.modules.push(module);\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const { dependents } = this;\n    const yielded = /* @__PURE__ */ new Set();\n    let count = 0;\n    const maxCount = 3;\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    do {\n      for (const module of modulesByType) {\n        if (yielded.has(module.optionsKey) || dependents.has(module.optionsKey)) {\n          continue;\n        }\n        yield module;\n        yielded.add(module.optionsKey);\n        for (const [key, dependencies] of dependents.entries()) {\n          dependencies.delete(module.optionsKey);\n          if (dependencies.size === 0) {\n            dependents.delete(key);\n          }\n        }\n      }\n      count++;\n    } while (yielded.size < modulesByType.length && count < maxCount);\n    if (dependents.size > 0) {\n      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    for (const key of module.dependencies) {\n      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();\n      dependencies.add(module.optionsKey);\n      this.dependencies.set(key, dependencies);\n    }\n    this.dependents.set(module.optionsKey, new Set(module.dependencies));\n  }\n};\nvar moduleRegistry = new ModuleRegistry();\n\n// packages/ag-charts-community/src/util/async.ts\nfunction sleep(sleepTimeoutMs) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(void 0), sleepTimeoutMs);\n  });\n}\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => Logger.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(async () => void 0);\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error) {\n        Logger.error(\"mutex callback error\", error);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n  clear() {\n    this.top = this.right = this.bottom = this.left = 0;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"10.1.0\";\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      if (!(originator.mementoOriginatorKey in blob)) {\n        continue;\n      }\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      if (!originator.guardMemento(memento)) {\n        Logger.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, this.encodeTypes));\n    } catch (error) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    try {\n      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);\n    } catch (error) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: String(this[key]) };\n    }\n    return value;\n  }\n  decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {\n      return;\n    }\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/util/userAgent.ts\nfunction hasConstrainedCanvasMemory() {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const iPhoneOSMatch = navigator.userAgent.match(/\\(iPhone; CPU iPhone OS (\\d+_\\d+_\\d+) like Mac OS X\\)/);\n  if (iPhoneOSMatch == null) {\n    return false;\n  }\n  const [major, minor] = iPhoneOSMatch[1].split(\"_\").map(Number);\n  return major < 16 || major === 16 && minor < 6;\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar _HdpiCanvas = class _HdpiCanvas {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width, height, pixelRatio, canvasConstructor, willReadFrequently = false } = options;\n    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow(\"devicePixelRatio\");\n    this.element = canvasConstructor?.() ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width ?? this.width) + \"px\";\n    this.element.style.height = (height ?? this.height) + \"px\";\n    this.element.width = Math.round((width ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\", { willReadFrequently });\n    this.onEnabledChange();\n    this.resize(width ?? 0, height ?? 0);\n    _HdpiCanvas.debugContext(this.context);\n  }\n  static is(value) {\n    return value instanceof _HdpiCanvas;\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width, height) {\n    if (!(width > 0 && height > 0))\n      return;\n    const { element: element2, context, pixelRatio } = this;\n    element2.width = Math.round(width * pixelRatio);\n    element2.height = Math.round(height * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width + \"px\";\n    element2.style.height = height + \"px\";\n    this.width = width;\n    this.height = height;\n  }\n  snapshot() {\n  }\n  clear() {\n    this.context.save();\n    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  static debugContext(ctx) {\n    if (Debug.check(\"canvas\")) {\n      const save = ctx.save.bind(ctx);\n      const restore = ctx.restore.bind(ctx);\n      let depth = 0;\n      Object.assign(ctx, {\n        save() {\n          save();\n          depth++;\n        },\n        restore() {\n          if (depth === 0) {\n            throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n          }\n          restore();\n          depth--;\n        },\n        verifyDepthZero() {\n          if (depth !== 0) {\n            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n          }\n        }\n      });\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], _HdpiCanvas.prototype, \"enabled\", 2);\nvar HdpiCanvas = _HdpiCanvas;\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class _LayersManager {\n  constructor(canvas, markDirty) {\n    this.canvas = canvas;\n    this.markDirty = markDirty;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextZIndex = 0;\n    this.nextLayerId = 0;\n  }\n  static sortLayers(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],\n      ascendingStringNumberUndefined\n    );\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  forEach(callback2) {\n    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback2);\n  }\n  resize(width, height) {\n    this.canvas.resize(width, height);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width, height));\n  }\n  addLayer(opts) {\n    const { width, height, pixelRatio } = this.canvas;\n    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\n    const canvas = new HdpiCanvas({ width, height, pixelRatio });\n    const newLayer = {\n      id: this.nextLayerId++,\n      name,\n      canvas,\n      zIndex,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    };\n    if (zIndex >= this.nextZIndex) {\n      this.nextZIndex = zIndex + 1;\n    }\n    this.layersMap.set(canvas, newLayer);\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return newLayer.canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.markDirty();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layersMap.get(canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.markDirty();\n      this.debug(\"Scene.moveLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};\n  const end = performance.now();\n  const { start, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start, end)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null\n  ].filter(isString);\n  const measurer = new SimpleTextMeasurer((t) => ctx.measureText(t));\n  const statsSize = new Map(stats.map((t) => [t, measurer.measureLines(t)]));\n  const width = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height = accumulate(statsSize.values(), (s) => s.height);\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, 2 + seriesRect.x, y);\n  }\n  ctx.restore();\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = node.computeTransformedBBox();\n    if (!bbox) {\n      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nfunction buildTree(node) {\n  if (!Debug.check(true, \"scene\" /* SCENE */))\n    return {};\n  return {\n    node,\n    name: node.name ?? node.id,\n    dirty: RedrawType[node.dirty],\n    ...node.parent?.isVirtual ? {\n      virtualParentDirty: RedrawType[node.parent.dirty],\n      virtualParent: node.parent\n    } : {},\n    ...node.children.map((c) => buildTree(c)).reduce((result, childTree) => {\n      let { name: treeNodeName } = childTree;\n      const {\n        node: {\n          visible,\n          opacity,\n          zIndex,\n          zIndexSubOrder,\n          translationX,\n          translationY,\n          rotation,\n          scalingX,\n          scalingY\n        },\n        node: childNode,\n        virtualParent\n      } = childTree;\n      if (!visible || opacity <= 0) {\n        treeNodeName = `(${treeNodeName})`;\n      }\n      if (childNode instanceof Group && childNode.isLayer()) {\n        treeNodeName = `*${treeNodeName}*`;\n      }\n      const key = [\n        `${treeNodeName ?? \"<unknown>\"}`,\n        `z: ${zIndex}`,\n        zIndexSubOrder && `zo: ${zIndexSubOrder.map((v) => typeof v === \"function\" ? `${v()} (fn)` : v).join(\" / \")}`,\n        virtualParent && `(virtual parent)`,\n        translationX && `x: ${translationX}`,\n        translationY && `y: ${translationY}`,\n        rotation && `r: ${rotation}`,\n        scalingX !== 1 && `sx: ${scalingX}`,\n        scalingY !== 1 && `sy: ${scalingY}`\n      ].filter((v) => !!v).join(\" \");\n      let selectedKey = key;\n      let index = 1;\n      while (result[selectedKey] != null && index < 100) {\n        selectedKey = `${key} (${index++})`;\n      }\n      result[selectedKey] = childTree;\n      return result;\n    }, {})\n  };\n}\nfunction buildDirtyTree(node) {\n  if (node.dirty === 0 /* NONE */) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = node.children.map((c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: RedrawType[node.dirty],\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start, end) {\n  const duration = end != null ? end - start : start;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor({ width, height, pixelRatio, domManager }) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.isDirty = false;\n    this.domManager = domManager;\n    const canvasOpts = {\n      width,\n      height,\n      pixelRatio\n    };\n    if (domManager) {\n      canvasOpts.canvasConstructor = () => domManager.addChild(\"canvas\", \"scene-canvas\");\n    }\n    this.canvas = new HdpiCanvas(canvasOpts);\n    this.layersManager = new LayersManager(this.canvas, () => {\n      this.isDirty = true;\n    });\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  setContainer(value) {\n    const isElement = (v) => {\n      return typeof v.tagName !== \"undefined\";\n    };\n    if (isElement(value)) {\n      const { element: element2 } = this.canvas;\n      element2.parentElement?.removeChild(element2);\n      value.appendChild(element2);\n    } else {\n      this.domManager = value;\n      this.domManager.addChild(\"canvas\", \"scene-canvas\", this.canvas.element);\n    }\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  attachNode(node, rootGroupName) {\n    if (!rootGroupName) {\n      this.root?.appendChild(node);\n      return () => this.removeChild(node);\n    }\n    const parentGroup = this.root?.children.find((g) => g instanceof Group && g.name === rootGroupName);\n    if (!parentGroup)\n      throw new Error(\"AG Charts - Unrecognized root group name: \" + rootGroupName);\n    parentGroup.appendChild(node);\n    return () => parentGroup.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width > 0 && height > 0 && (width !== this.width || height !== this.height)) {\n      this.pendingSize = [width, height];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  async render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};\n    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = void 0;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          redrawType: RedrawType[root.dirty],\n          tree: buildTree(root)\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      devicePixelRatio: this.canvas.pixelRatio ?? 1,\n      forceRender: true,\n      resized: Boolean(pendingSize),\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\n    }\n    let canvasCleared = false;\n    if (!root || root.dirty >= 1 /* TRIVIAL */) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      this.debug(\"Scene.render() - before\", {\n        redrawType: RedrawType[root.dirty],\n        canvasCleared,\n        tree: buildTree(root)\n      });\n      if (root.visible) {\n        root.preRender();\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    if (this.layersManager.size && canvasCleared) {\n      const layerRenderStart = performance.now();\n      ctx.save();\n      ctx.resetTransform();\n      this.layersManager.forEach((layer) => {\n        if (layer.canvas.enabled && layer.getVisibility()) {\n          ctx.globalAlpha = layer.getComputedOpacity();\n          layer.canvas.drawImage(ctx);\n        }\n      });\n      ctx.restore();\n      debugSplitTimes[\"\\u26D9\"] = performance.now() - layerRenderStart;\n    }\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        redrawType: RedrawType[root.dirty],\n        tree: buildTree(root),\n        canvasCleared\n      });\n    }\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      return this.invoke(fn, params, paramCache);\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return this.invoke(fn, params, paramCache, serialisedParams);\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invoke(fn, params, paramCache, serialisedParams) {\n    try {\n      const result = fn(...params);\n      if (paramCache && serialisedParams != null) {\n        paramCache.set(serialisedParams, result);\n      }\n      return result;\n    } catch (e) {\n      Logger.warnOnce(`User callback errored, ignoring`, e);\n      return;\n    }\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    const annotations2 = this.cleanData(memento).map((annotation) => {\n      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);\n      return mergeDefaults(annotation, annotationTheme);\n    });\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: annotations2\n    });\n  }\n  updateData(annotations2) {\n    this.annotations = this.cleanData(annotations2 ?? []);\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n  cleanData(annotations2) {\n    for (const annotation of annotations2) {\n      if (\"textAlign\" in annotation)\n        delete annotation.textAlign;\n    }\n    return annotations2;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Group({ name: \"Axes-Grids\", layer: true, zIndex: 1 /* AXIS_GRID_ZINDEX */ });\n    this.axisGroup = new Group({ name: \"Axes\", layer: true, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return [...this.axes.get(direction) ?? []];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle((params) => this.fetch(params), requestThrottle, {\n      leading: false,\n      trailing: true\n    });\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);\n    } catch (error) {\n      this.debug(`DataService - request failed | ${id}`);\n      Logger.errorOnce(`DataService - request failed | [${error}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/styles.css\nvar styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:focus,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:focus,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block}.ag-charts-canvas-proxy{position:absolute;top:0;left:0;opacity:0;pointer-events:none}.ag-charts-tab-guard{width:0;height:0;opacity:0}.ag-charts-canvas-overlay{pointer-events:none;position:absolute;inset:0}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-active-color: var(--ag-active-color, #2196f3);--ag-charts-background-color: var(--ag-background-color, #fff);--ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);--ag-charts-border-color: var(--ag-border-color, #dddddd);--ag-charts-font-family: \"Verdana\", sans-serif;--ag-charts-font-size: var(--ag-font-size, 14px);--ag-charts-size: var(--ag-grid-size, 8px);--ag-charts-border: var(--ag-charts-border-color) var(--ag-borders, solid 1px);--ag-charts-border-critical: var(--ag-borders-critical, solid 1px);--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1;--ag-charts-align: center;--ag-charts-justify: center;--ag-charts-axis-label-background-color: #474747;--ag-charts-axis-label-color: #ffffff;--ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color: var( --ag-header-background-color, color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%) );--ag-charts-toolbar-size: 34px;--ag-charts-toolbar-size-small: 24px;--ag-charts-toolbar-border: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12% );--ag-charts-toolbar-focus-color: var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color: var(--ag-charts-toolbar-hover-color);--ag-charts-toolbar-active-color: var(--ag-charts-active-color);--ag-charts-toolbar-disabled-foreground-color: var( --ag-disabled-foreground-color, color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%) );--ag-charts-toolbar-disabled-background-color: color-mix( in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6% );--ag-charts-toolbar-gap: var(--ag-charts-size);--ag-charts-toolbar-font-size: 13px;--ag-charts-toolbar-font-size-small: 12px;--ag-charts-toolbar-button-padding: 6px;--ag-charts-toolbar-button-padding-small: 1px;--ag-charts-popover-background-color: var(--ag-charts-toolbar-background-color);--ag-charts-popover-foreground-color: var(--ag-charts-toolbar-foreground-color);--ag-charts-popover-border: var(--ag-charts-toolbar-border);--ag-charts-popover-active-color: var(--ag-charts-toolbar-active-color);--ag-charts-popover-hover-color: var(--ag-charts-toolbar-hover-color);--ag-charts-popover-active-background-color: var(--ag-charts-toolbar-active-background-color);--ag-charts-popover-font-size-small: var(--ag-charts-toolbar-font-size-small);--ag-charts-button-radius: var(--ag-border-radius, 4px);--ag-charts-focus-border-color: var(--ag-input-focus-border-color, var(--ag-charts-active-color));--ag-charts-focus-border: solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-icon-font-family: \"agChartsDefault\";--ag-charts-icon-font-weight: normal;--ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);--ag-charts-icon-size: 20px;--ag-charts-text-annotations-placeholder: #888888}.ag-charts-theme-default-dark{--ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));--ag-charts-foreground-color: var(--ag-foreground-color, #fff);--ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, .16));--ag-charts-hover-color: var( --ag-row-hover-color, color-mix(in srgb, transparent, var(--ag-charts-active-color) 20%) );--ag-charts-axis-label-background-color: #9caebb;--ag-charts-axis-label-color: #000000;--ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18% );--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-text-annotations-placeholder: #aaaaaa}.ag-charts-icon{display:block;width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size);speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt,.ag-charts-icon-zoom-in-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt,.ag-charts-icon-zoom-out-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-focus.ag-charts-focus__indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus.ag-charts-focus__indicator>div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus.ag-charts-focus__indicator>svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-focus--hidden{visibility:hidden}.ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity .2s ease-in-out,transform .2s ease-in-out}.ag-charts-toolbar--hidden,.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity .4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size: var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size: var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding: var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px;overflow:hidden}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,.ag-charts-toolbar--left .ag-charts-toolbar__align--end,.ag-charts-toolbar--right .ag-charts-toolbar__align--center,.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform .4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{--transition: background-color .25s ease-in-out, border-color .25s ease-in-out, color .25s ease-in-out;align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font:var(--ag-charts-toolbar-font-size) var(--ag-charts-font-family);justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;position:relative;transition:var(--transition);white-space:nowrap}.ag-charts-toolbar__button[data-toolbar-group=ranges]{padding:var(--ag-charts-toolbar-button-padding) calc(var(--ag-charts-toolbar-button-padding) * 1.5)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom,.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{.ag-charts-toolbar__button:nth-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:nth-last-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-right-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar--left,.ag-charts-toolbar--right{.ag-charts-toolbar__button{border-radius:0;margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button:nth-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:nth-last-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar__button--hidden-value,.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover{background:var(--ag-charts-toolbar-hover-color);z-index:1}.ag-charts-toolbar__button:focus-visible{border-color:var(--ag-charts-toolbar-focus-color);box-shadow:var(--ag-charts-focus-border-shadow);z-index:3}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);border-color:var(--ag-charts-toolbar-active-color);color:var(--ag-charts-toolbar-active-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled=true]){cursor:pointer}.ag-charts-toolbar__button--fill-visible:after{content:\"\";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--fill)}.ag-charts-toolbar__button--fill-visible[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#fff}.ag-chart-overlay--loading{color:#8c8c8c}.ag-chart-overlay__loading-background{background:#fff;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}.ag-chart-tooltip{transition:transform .1s ease;width:max-content;z-index:99999;font:12px Verdana,sans-serif;color:#464646;box-shadow:0 4px 8px #00000014}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:#fff;background-color:#888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,.15);text-overflow:inherit}.ag-chart-tooltip-arrow:before{content:\"\";position:absolute;top:100%;left:50%;transform:translate(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow:after{content:\"\";position:absolute;top:calc(100% - 1px);left:50%;transform:translate(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\\n';\n\n// packages/ag-charts-community/src/util/guardedElement.ts\nvar GuardedElement = class {\n  constructor(element2, topTabGuard, bottomTabGuard) {\n    this.element = element2;\n    this.topTabGuard = topTabGuard;\n    this.bottomTabGuard = bottomTabGuard;\n    this.destroyFns = [];\n    this.guardTabIndex = 0;\n    this.element.tabIndex = -1;\n    this.initEventListener(this.element, \"blur\", () => this.onBlur());\n    this.initEventListener(this.element, \"focus\", () => this.onFocus());\n    this.initEventListener(this.topTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.topTabGuard));\n    this.initEventListener(this.bottomTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.bottomTabGuard));\n  }\n  set tabIndex(index) {\n    if (index >= 0) {\n      this.guardTabIndex = index;\n    }\n    if (index > 0) {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.style.display = \"none\";\n    } else {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.tabIndex = index;\n    }\n  }\n  destroy() {\n    for (const fn of this.destroyFns)\n      fn();\n    this.destroyFns.length = 0;\n  }\n  initEventListener(elem, type, handler) {\n    elem.addEventListener(type, handler);\n    this.destroyFns.push(() => elem.removeEventListener(type, handler));\n  }\n  onBlur() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = this.guardTabIndex;\n      this.guardTarget = void 0;\n      this.guessedDelta = void 0;\n    }\n  }\n  onFocus() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = -1;\n    }\n  }\n  onTabStart(event, target) {\n    if (target.tabIndex > 0) {\n      this.guessedDelta = 0;\n      if (event.relatedTarget != null && \"tabIndex\" in event.relatedTarget) {\n        const prevTabIndex = Number(event.relatedTarget[\"tabIndex\"]);\n        if (!isNaN(prevTabIndex) && prevTabIndex > 0) {\n          this.guessedDelta = prevTabIndex < target.tabIndex ? 1 : -1;\n        }\n      }\n    }\n    this.guardTarget = target;\n    this.element.focus();\n  }\n  getBrowserFocusDelta() {\n    const { guessedDelta, guardTarget, topTabGuard, bottomTabGuard: botTabGuard } = this;\n    if (guessedDelta !== void 0)\n      return guessedDelta;\n    if (guardTarget === topTabGuard)\n      return 1;\n    if (guardTarget === botTabGuard)\n      return -1;\n    return 0;\n  }\n};\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n    };\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const {\n        target,\n        contentRect: { width, height }\n      } of entries) {\n        const entry = this.elements.get(target);\n        this.checkSize(entry, target, width, height);\n      }\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (!this.documentReady) {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n  checkSize(entry, element2, width, height) {\n    if (!entry)\n      return;\n    if (width !== entry.size?.width || height !== entry.size?.height) {\n      entry.size = { width, height };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n    this.checkSize(entry, element2, element2.offsetWidth, element2.offsetHeight);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/domLayout.html\nvar domLayout_default = '<div role=\"presentation\" class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div role=\"presentation\" class=\"ag-charts-canvas-center\"><div role=\"figure\" class=\"ag-charts-canvas-container\"><div role=\"presentation\" class=\"ag-charts-tab-guard\"></div><div role=\"presentation\" class=\"ag-charts-canvas\"></div><div role=\"presentation\" class=\"ag-charts-canvas-proxy\"></div><div role=\"presentation\" class=\"ag-charts-tab-guard\"></div><div role=\"presentation\" class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/chart/dom/domManager.ts\nvar CANVAS_CENTER_CLASS = \"canvas-center\";\nvar DOM_ELEMENT_CLASSES = [\"styles\", CANVAS_CENTER_CLASS, \"canvas\", \"canvas-proxy\", \"canvas-overlay\"];\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\", eventTypes: [\"focus\", \"blur\"] }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [CANVAS_CENTER_CLASS, { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar NULL_DOMRECT = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  toJSON() {\n    return NULL_DOMRECT;\n  }\n};\nvar DOMManager = class extends BaseManager {\n  constructor(container) {\n    super();\n    this.styles = {};\n    this.container = void 0;\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.addStyles(\"ag-charts-community\", styles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.guardedElement?.destroy();\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[CANVAS_CENTER_CLASS].element;\n    centerStyle.width = `${this.containerSize?.width ?? 0}px`;\n    centerStyle.height = `${this.containerSize?.height ?? 0}px`;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    const isShadowDom = this.getDocumentRoot(newContainer) != null;\n    if (!isShadowDom) {\n      for (const id of this.rootElements[\"styles\"].children.keys()) {\n        this.removeChild(\"styles\", id);\n      }\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.container = newContainer;\n    for (const [id, styles] of Object.entries(this.styles)) {\n      this.addStyles(id, styles);\n    }\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  createTabGuards() {\n    const canvasElement = this.rootElements[\"canvas\"].element.querySelector(\"canvas\");\n    const tabGuards = this.element.querySelectorAll(\".ag-charts-tab-guard\");\n    if (canvasElement == null || tabGuards[0] == null || tabGuards[1] == null) {\n      throw new Error(\"AG Charts - error initialising canvas tab guards\");\n    }\n    return new GuardedElement(canvasElement, tabGuards[0], tabGuards[1]);\n  }\n  setTabIndex(tabIndex) {\n    this.guardedElement ?? (this.guardedElement = this.createTabGuards());\n    this.guardedElement.tabIndex = tabIndex;\n  }\n  getBrowserFocusDelta() {\n    return this.guardedElement?.getBrowserFocusDelta() ?? 0;\n  }\n  addEventListenerOnElement(elementType, type, listener, options) {\n    const { element: element2 } = this.rootElements[elementType];\n    element2.addEventListener(type, listener, options);\n    return () => {\n      element2.removeEventListener(type, listener, options);\n    };\n  }\n  addEventListener(type, listener, options) {\n    this.element.addEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners.push([type, listener, options]);\n      els.children.forEach((el) => {\n        el.addEventListener(type, listener);\n      });\n    });\n  }\n  removeEventListener(type, listener, options) {\n    this.element.removeEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners = els.listeners.filter(([t, l]) => t !== type && l !== listener);\n      els.children.forEach((el) => {\n        el.removeEventListener(type, listener, options);\n      });\n    });\n  }\n  /** Get the main chart area client bound rect. */\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  /**\n   * Get the client bounding rect for overlay elements that might float outside the bounds of the\n   * main chart area.\n   */\n  getOverlayClientRect() {\n    const window2 = getWindow();\n    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);\n    const container = this.getRawOverlayClientRect();\n    const containerBBox = BBox.fromDOMRect(container ?? this.getBoundingClientRect());\n    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;\n  }\n  getRawOverlayClientRect() {\n    let element2 = this.element;\n    while (element2 != null) {\n      const styleMap = element2.computedStyleMap?.();\n      const overflowX = styleMap?.get(\"overflow-x\")?.toString();\n      const overflowY = styleMap?.get(\"overflow-y\")?.toString();\n      if (overflowX != null && overflowX !== \"visible\" || overflowY && overflowY !== \"visible\") {\n        return element2.getBoundingClientRect();\n      }\n      element2 = element2.parentElement;\n    }\n    const docRoot = this.getDocumentRoot();\n    if (docRoot) {\n      return docRoot.getBoundingClientRect();\n    }\n  }\n  getDocumentRoot(current = this.container) {\n    const docRoot = current?.ownerDocument?.body ?? getDocument(\"body\");\n    while (current != null) {\n      if (current === docRoot) {\n        return void 0;\n      }\n      if (current.parentNode instanceof DocumentFragment) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return void 0;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  calculateCanvasPosition(el) {\n    let x = 0;\n    let y = 0;\n    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect(\"canvas\") ?? {};\n    const elRect = el.getBoundingClientRect();\n    x = elRect.x - cx;\n    y = elRect.y - cy;\n    return { x, y };\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && el.contains(search);\n  }\n  isEventOverElement(event) {\n    const element2 = event.target;\n    return element2 != null && this.element.contains(element2);\n  }\n  addStyles(id, styles) {\n    this.styles[id] = styles;\n    if (this.container == null)\n      return;\n    const dataAttribute = \"data-ag-charts\";\n    const documentRoot = this.getDocumentRoot();\n    let styleElement;\n    if (documentRoot != null) {\n      styleElement = this.addChild(\"styles\", id);\n    } else {\n      const head = getDocument(\"head\");\n      for (const child of head.children) {\n        if (child.getAttribute(dataAttribute) === id)\n          return;\n      }\n      styleElement = createElement(\"style\");\n      head.appendChild(styleElement);\n    }\n    if (styleElement.getAttribute(dataAttribute) === id) {\n      return;\n    }\n    styleElement.setAttribute(dataAttribute, id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(style) {\n    this.element.style.cursor = style;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    const existing = children.get(id);\n    if (existing != null)\n      return existing;\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    element2?.appendChild(newChild);\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n  getIconClassNames(icon) {\n    return `ag-charts-icon ag-charts-icon-${icon}`;\n  }\n};\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bzier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  }\n  roundRect(x, y, width, height, radii) {\n    radii = Math.min(radii, width / 2, height / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width - radii, y);\n    this.arc(x + width - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width, y + radii);\n    this.lineTo(x + width, y + height - radii);\n    this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width - radii, y + height);\n    this.lineTo(x + radii, y + height);\n    this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */:\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          Logger.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  getPoints() {\n    const { commands, params } = this;\n    const coords = [];\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n        case 1 /* Line */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 3 /* Curve */:\n          pi += 4;\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 2 /* Arc */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          pi += 4;\n          break;\n        case 4 /* ClosePath */:\n          break;\n      }\n    }\n    return coords;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  computeSVGDataPath(ox, oy) {\n    const buffer = [];\n    const { commands, params } = this;\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          buffer.push(\"M\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 1 /* Line */:\n          buffer.push(\"L\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 3 /* Curve */:\n          buffer.push(\n            \"C\",\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++]\n          );\n          break;\n        case 2 /* Arc */:\n          const [cx, cy, r, a0, a1, ccw] = [\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++]\n          ];\n          const x0 = ox + cx + Math.cos(a0) * r;\n          const y0 = oy + cy + Math.sin(a0) * r;\n          const x1 = ox + cx + Math.cos(a1) * r;\n          const y1 = oy + cy + Math.sin(a1) * r;\n          const largeArcFlag = angleDiff(a0, a1, !!ccw) > Math.PI ? 1 : 0;\n          const sweepFlag = (ccw + 1) % 2;\n          const move = buffer.length === 0 ? \"M\" : \"L\";\n          buffer.push(move, x0, y0, \"A\", r, r, 0, largeArcFlag, sweepFlag, x1, y1);\n          break;\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(this, 3 /* MAJOR */);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n  }\n  distanceSquared(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.distanceSquaredTransformedPoint(point.x, point.y);\n  }\n  computeSVGDataPath() {\n    const { x, y } = this.inverseTransformPoint(0, 0);\n    if (this.dirtyPath) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    return this.path.computeSVGDataPath(x, y);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    if (!isNaN(this._clipX) && !isNaN(this._clipY) && this.clipMode != null) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      if (this.clipMode === \"normal\") {\n        ctx.clip(this._clipPath?.getPath2D());\n      }\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      if (this.clipMode === \"punch-out\") {\n        ctx.clip(this._clipPath?.getPath2D());\n        const { x = -1e4, y = -1e4, width = 2e4, height = 2e4 } = this.getBBox() ?? {};\n        ctx.clearRect(x, y, width, height);\n      }\n      ctx.restore();\n    } else {\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipMode\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/chart/dom/focusStyles.ts\nvar focusStyles_exports = {};\n__export(focusStyles_exports, {\n  block: () => block,\n  elements: () => elements,\n  modifiers: () => modifiers\n});\nvar block = \"ag-charts-focus\";\nvar elements = { indicator: \"ag-charts-focus__indicator\", svg: \"ag-charts-focus__svg\" };\nvar modifiers = { hidden: \"ag-charts-focus--hidden\" };\n\n// packages/ag-charts-community/src/chart/dom/focusIndicator.ts\nvar FocusIndicator = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    const { block: block3, elements: elements3, modifiers: modifiers3 } = focusStyles_exports;\n    this.div = getDocument().createElement(\"div\");\n    this.svg = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.path = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    this.svg.append(this.path);\n    this.element = domManager.addChild(\"canvas-overlay\", block3);\n    this.element.classList.add(block3, elements3.indicator, modifiers3.hidden);\n    this.element.ariaHidden = \"true\";\n    this.element.append(this.svg);\n  }\n  destroy() {\n    this.domManager.removeStyles(block);\n    this.domManager.removeChild(\"canvas-overlay\", block);\n  }\n  updateBounds(bounds) {\n    if (bounds === void 0) {\n      this.element.classList.add(modifiers.hidden);\n    } else if (bounds instanceof Path) {\n      this.path.setAttribute(\"d\", bounds.computeSVGDataPath());\n      this.show(this.svg);\n    } else {\n      setElementBBox(this.div, bounds);\n      this.show(this.div);\n    }\n  }\n  show(child) {\n    this.element.classList.remove(modifiers.hidden);\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/boundedText.ts\nvar BoundedText = class {\n  set textContent(text) {\n    this.textElement.textContent = text;\n    const bboxCalculator = this.textElement;\n    const bbox = bboxCalculator.getBBox?.();\n    if (bbox) {\n      this.svgElement.setAttribute(\"viewBox\", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);\n    }\n  }\n  get textContent() {\n    return this.textElement.textContent;\n  }\n  constructor() {\n    this.textElement = createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    this.textElement.role = \"presentation\";\n    this.svgElement = createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.svgElement.appendChild(this.textElement);\n    this.svgElement.style.width = \"100%\";\n    this.svgElement.style.opacity = \"0\";\n    this.svgElement.role = \"presentation\";\n    this.boundedContainer = createElement(\"div\");\n    this.boundedContainer.appendChild(this.svgElement);\n    this.boundedContainer.role = \"presentation\";\n  }\n  remove() {\n    this.boundedContainer.remove();\n  }\n  getContainer() {\n    return this.boundedContainer;\n  }\n  updateBounds(bounds) {\n    setElementBBox(this.boundedContainer, bounds);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateResult(type) {\n  if (\"button\" === type) {\n    return createElement(\"button\");\n  } else if (\"slider\" === type) {\n    return createElement(\"input\");\n  } else if (\"toolbar\" === type || \"group\" === type) {\n    return createElement(\"div\");\n  } else if (\"text\" === type) {\n    return new BoundedText();\n  } else {\n    throw Error(\"AG Charts - error allocating meta\");\n  }\n}\nfunction allocateMeta(params) {\n  const meta = { params, result: void 0 };\n  meta.result = allocateResult(meta.params.type);\n  return meta;\n}\nvar ProxyInteractionService = class {\n  constructor(updateService, localeManager, domManager, focusIndicator) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.focusIndicator = focusIndicator;\n    // This debug option make the proxies button partially transparent instead of fully transparent.\n    // To enabled this option, set window.agChartsDebug = ['showDOMProxies'].\n    this.debugShowDOMProxies = Debug.check(\"showDOMProxies\");\n    this.destroyFns = [];\n    this.destroyFns.push(updateService.addListener(\"update-complete\", () => this.update()));\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  update() {\n    if (this.focusable) {\n      this.focusIndicator.updateBounds(this.focusable.computeTransformedBBox());\n    }\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result: div } = meta;\n    this.domManager.addChild(\"canvas-overlay\", params.id, div);\n    div.classList.add(...params.classList);\n    div.style.pointerEvents = \"none\";\n    div.role = params.type;\n    div.ariaOrientation = params.ariaOrientation;\n    if (typeof params.ariaHidden === \"boolean\") {\n      div.ariaHidden = params.ariaHidden.toString();\n    }\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return div;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result: button } = meta;\n      this.initInteract(params, button);\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result: slider } = meta;\n      this.initInteract(params, slider);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      slider.ariaOrientation = params.ariaOrientation;\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n    }\n    if (checkType(\"text\", meta)) {\n      const { params, result: text } = meta;\n      this.initElement(params, text.getContainer());\n    }\n    return meta.result;\n  }\n  initElement(params, element2) {\n    const { id, parent } = params;\n    element2.id = id;\n    element2.style.pointerEvents = \"none\";\n    element2.style.opacity = this.debugShowDOMProxies ? \"0.25\" : \"0\";\n    element2.style.position = \"absolute\";\n    element2.style.overflow = \"hidden\";\n    if (typeof parent === \"string\") {\n      this.domManager.addChild(parent, id, element2);\n    } else {\n      parent.appendChild(element2);\n    }\n  }\n  initInteract(params, element2) {\n    const { focusable, onclick, onchange, onfocus, onblur, tabIndex } = params;\n    this.initElement(params, element2);\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    element2.addEventListener(\"focus\", (_event) => {\n      this.focusable = focusable;\n      element2.style.setProperty(\"pointerEvents\", null);\n      this.focusIndicator.updateBounds(focusable.computeTransformedBBox());\n    });\n    element2.addEventListener(\"blur\", (_event) => {\n      this.focusable = void 0;\n      element2.style.pointerEvents = \"none\";\n      this.focusIndicator.updateBounds(void 0);\n    });\n    if (onclick) {\n      element2.addEventListener(\"click\", onclick);\n    }\n    if (onfocus) {\n      element2.addEventListener(\"focus\", onfocus);\n    }\n    if (onblur) {\n      element2.addEventListener(\"blur\", onblur);\n    }\n    if (onchange) {\n      element2.addEventListener(\"change\", onchange);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      Logger.warnOnce(\n        \"Animation batch exceeded max animation time, skipping.\",\n        new Map(this.controllers.entries())\n      );\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  pause() {\n    for (const controller of this.controllers.values()) {\n      controller.pause();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error) {\n        Logger.error(\"Error during animation stop\", error);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts\nfunction buildPreventable(obj) {\n  const self = {\n    ...obj,\n    preventDefault() {\n      self.sourceEvent?.preventDefault();\n    }\n  };\n  return self;\n}\nfunction dispatchTypedEvent(listeners, event) {\n  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));\n}\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar POINTER_INTERACTION_TYPES = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"hover\",\n  \"drag-start\",\n  \"drag\",\n  \"drag-end\",\n  \"leave\",\n  \"enter\",\n  \"page-left\",\n  \"wheel\"\n];\nvar FOCUS_INTERACTION_TYPES = [\"blur\", \"focus\"];\nvar KEY_INTERACTION_TYPES = [\"keydown\", \"keyup\"];\nvar SHADOW_DOM_HANDLERS = [\"mousemove\", \"mouseup\"];\nvar WINDOW_EVENT_HANDLERS = [\"pagehide\", \"mousemove\", \"mouseup\"];\nvar EVENT_HANDLERS = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"mousedown\",\n  \"mouseleave\",\n  \"mouseenter\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"wheel\",\n  \"blur\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\"\n];\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 16] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 8] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 4] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 2] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 1] = \"Animation\";\n  InteractionState2[InteractionState2[\"All\"] = 31] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar PointerCapture = /* @__PURE__ */ ((PointerCapture2) => {\n  PointerCapture2[\"Retain\"] = \"retain\";\n  PointerCapture2[\"Exclusive\"] = \"exclusive\";\n  return PointerCapture2;\n})(PointerCapture || {});\nvar pointerCaptures = new Set(Object.values(PointerCapture));\nfunction isPointerEvent(type) {\n  return POINTER_INTERACTION_TYPES.includes(type);\n}\nfunction isFocusEvent(type) {\n  return FOCUS_INTERACTION_TYPES.includes(type);\n}\nfunction isKeyEvent(type) {\n  return KEY_INTERACTION_TYPES.includes(type);\n}\nvar _InteractionManager = class _InteractionManager extends BaseManager {\n  constructor(keyboardOptions, domManager) {\n    super();\n    this.keyboardOptions = keyboardOptions;\n    this.domManager = domManager;\n    this.debug = Debug.create(true, \"interaction\");\n    this.eventHandler = (event) => this.processEvent(event);\n    this.overlayEventHandler = (event) => this.processCanvasOverlayEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.pointerCaptureCanvasElement = void 0;\n    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: \"mousedown\" }];\n    this.dblclickHistory = [\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mouseup\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" }\n    ];\n    this.stateQueue = 16 /* Default */ | 1 /* Animation */;\n    this.rootElement = this.domManager.getDocumentRoot();\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith(\"touch\") || type === \"wheel\") {\n        this.domManager.addEventListener(type, this.eventHandler, { passive: false });\n      } else {\n        this.domManager.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().addEventListener(type, this.eventHandler);\n    }\n    this.destroyFns.push(\n      this.domManager.addEventListenerOnElement(\"canvas-overlay\", \"mouseover\", this.overlayEventHandler),\n      this.domManager.addEventListenerOnElement(\"canvas-overlay\", \"mouseout\", this.overlayEventHandler)\n    );\n    this.containerChanged(true);\n    this.domManager.addListener(\"container-changed\", () => this.containerChanged());\n  }\n  containerChanged(force = false) {\n    const newRoot = this.domManager.getDocumentRoot();\n    if (!force && newRoot === this.rootElement)\n      return;\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    this.rootElement = newRoot;\n    this.debug(\"[InteractionManager] Switching rootElement to:\", this.rootElement);\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.addEventListener(type, this.eventHandler);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().removeEventListener(type, this.eventHandler);\n    }\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.domManager.removeEventListener(type, this.eventHandler);\n    }\n    this.domManager.removeStyles(\"interactionManager\");\n  }\n  // Wrapper to only broadcast events when the InteractionManager is a given state.\n  addListener(type, handler, triggeringStates = 16 /* Default */) {\n    return super.addListener(type, (e) => {\n      const currentState = this.getState();\n      if (currentState & triggeringStates) {\n        handler(e);\n      }\n    });\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  getState() {\n    return this.stateQueue & -this.stateQueue;\n  }\n  processCanvasOverlayEvent(event) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    let target = event.target;\n    let pointerCapture = null;\n    while (target != null) {\n      pointerCapture = target.getAttribute(\"data-pointer-capture\");\n      if (pointerCapture == null) {\n        target = target.parentElement;\n      } else {\n        break;\n      }\n    }\n    if (target == null || pointerCapture == null || !pointerCaptures.has(pointerCapture))\n      return;\n    const isOverCanvasOverlay = event.type === \"mouseover\";\n    const pointerCaptureCanvasElement = isOverCanvasOverlay ? target : void 0;\n    if (this.pointerCaptureCanvasElement === pointerCaptureCanvasElement)\n      return;\n    this.pointerCaptureCanvasElement = pointerCaptureCanvasElement;\n    if (pointerCapture === \"exclusive\" /* Exclusive */) {\n      dispatchTypedEvent(\n        this.listeners,\n        this.buildPointerEvent({ type: isOverCanvasOverlay ? \"leave\" : \"enter\", event, ...coords })\n      );\n    }\n  }\n  processEvent(event) {\n    const type = this.decideInteractionEventTypes(event);\n    const target = event.target;\n    if (event.type === \"click\" && target?.ariaDisabled === \"true\") {\n      event.preventDefault();\n      return;\n    }\n    if (type != null) {\n      this.dispatchEvent(event, type).catch((e) => Logger.errorOnce(e));\n    }\n  }\n  async dispatchEvent(event, type) {\n    if (isPointerEvent(type)) {\n      this.dispatchPointerEvent(event, type);\n      return;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    if (isFocusEvent(type)) {\n      const sourceEvent = event;\n      dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    } else if (isKeyEvent(type)) {\n      const sourceEvent = event;\n      dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    }\n  }\n  extractElements(event) {\n    let relatedElement;\n    let targetElement;\n    if (\"relatedTarget\" in event && event[\"relatedTarget\"] instanceof HTMLElement) {\n      relatedElement = event[\"relatedTarget\"];\n    }\n    if (\"target\" in event && event[\"target\"] instanceof HTMLElement) {\n      targetElement = event[\"target\"];\n    }\n    return { relatedElement, targetElement };\n  }\n  dispatchPointerEvent(event, type) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    dispatchTypedEvent(this.listeners, this.buildPointerEvent({ type, event, ...coords }));\n  }\n  getEventHTMLTarget(event) {\n    if (event.target instanceof HTMLElement) {\n      return event.target;\n    } else if (event.currentTarget instanceof HTMLElement) {\n      return event.currentTarget;\n    }\n    return void 0;\n  }\n  recordDown(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.clickHistory[0], event);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[2], this.dblclickHistory[0]);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[0], event);\n    }\n    this.dragStartElement = this.getEventHTMLTarget(event);\n  }\n  recordUp(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[1], event);\n    }\n    this.dragStartElement = void 0;\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = \"drag-start\";\n    if (this.pointerCaptureCanvasElement?.isConnected === false) {\n      this.pointerCaptureCanvasElement = void 0;\n    }\n    if (this.pointerCaptureCanvasElement != null) {\n      return;\n    }\n    switch (event.type) {\n      case \"blur\":\n      case \"focus\":\n      case \"keydown\":\n      case \"keyup\":\n        return this.keyboardOptions.enabled ? event.type : void 0;\n      case \"click\":\n      case \"dblclick\":\n      case \"contextmenu\":\n      case \"wheel\":\n        return event.type;\n      case \"mousedown\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = true;\n        this.recordDown(event);\n        return dragStart;\n      case \"touchstart\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = true;\n        this.recordDown(event);\n        return dragStart;\n      case \"touchmove\":\n      case \"mousemove\":\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        return this.mouseDown || this.touchDown ? \"drag\" : \"hover\";\n      case \"mouseup\":\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = false;\n        this.recordUp(event);\n        return \"drag-end\";\n      case \"touchend\":\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = false;\n        this.recordUp(event);\n        return \"drag-end\";\n      case \"mouseleave\":\n      case \"touchcancel\":\n        return \"leave\";\n      case \"mouseenter\":\n        return \"enter\";\n      case \"pagehide\":\n        return \"page-left\";\n    }\n  }\n  isEventOverElement(event) {\n    return this.domManager.isEventOverElement(event);\n  }\n  calculateCoordinates(event) {\n    if (event instanceof MouseEvent) {\n      return this.getMouseEventCoords(event);\n    } else if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n      const lastTouch = event.touches[0] ?? event.changedTouches[0];\n      const { clientX, clientY, pageX, pageY } = lastTouch;\n      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        return;\n      }\n      return _InteractionManager.NULL_COORDS;\n    }\n  }\n  getMouseEventCoords(event) {\n    const { clientX, clientY, pageX, pageY } = event;\n    let { offsetX, offsetY } = event;\n    const target = this.getEventHTMLTarget(event);\n    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);\n      offsetX -= offsetDragStart.x - x;\n      offsetY -= offsetDragStart.y - y;\n    } else {\n      offsetX += x;\n      offsetY += y;\n    }\n    return { clientX, clientY, pageX, pageY, offsetX, offsetY };\n  }\n  isWheelEvent(event) {\n    return event.type === \"wheel\";\n  }\n  buildPointerEvent(opts) {\n    const { type, event, clientX, clientY } = opts;\n    let { offsetX, offsetY, pageX, pageY } = opts;\n    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {\n      const rect = this.domManager.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {\n      const pageRect = this.rootElement?.getBoundingClientRect();\n      pageX = clientX - (pageRect?.left ?? 0);\n      pageY = clientY - (pageRect?.top ?? 0);\n    }\n    let [deltaX, deltaY] = [NaN, NaN];\n    if (this.isWheelEvent(event)) {\n      const factor = event.deltaMode === 0 ? 0.01 : 1;\n      deltaX = event.deltaX * factor;\n      deltaY = event.deltaY * factor;\n    }\n    let pointerHistory = [];\n    if (event.type === \"click\") {\n      pointerHistory = this.clickHistory;\n    } else if (event.type === \"dblclick\") {\n      pointerHistory = this.dblclickHistory;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    const button = \"button\" in event ? Number(event.button) : 0;\n    const builtEvent = {\n      type,\n      offsetX,\n      offsetY,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n      button,\n      pointerHistory,\n      sourceEvent: event,\n      relatedElement,\n      targetElement\n    };\n    this.debug(\"InteractionManager - builtEvent: \", builtEvent);\n    return builtEvent;\n  }\n};\n_InteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\nvar InteractionManager = _InteractionManager;\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class extends BaseManager {\n  constructor(interactionManager, chartUpdateMutex) {\n    super();\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = false;\n    this.requestId = null;\n    this.skipAnimations = false;\n    this.currentAnonymousAnimationId = 0;\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate({ ...opts }) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.pause()\");\n    try {\n      this.batch.pause();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = requestAnimationFrame(cb);\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = async () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(1 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error) {\n          this.failsafeOnError(error);\n        }\n        this.listeners.dispatch(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.listeners.dispatch(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.listeners.dispatch(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error(\"Error during animation, skipping animations\", error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.stop();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(1 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/ariaAnnouncementServices.ts\nvar AriaAnnouncementService = class _AriaAnnouncementService {\n  constructor(localeManager, domManager, layoutService) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.layoutService = layoutService;\n    this.debug = Debug.create(true, \"aria\");\n    this.destroyFns = [];\n    this.liveElem = _AriaAnnouncementService.createAnnouncer();\n    this.domManager.addChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\", this.liveElem);\n    this.destroyFns.push(\n      this.layoutService.addListener(\"layout-complete\", (ev) => this.onResize(ev)),\n      () => this.domManager.removeChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\")\n    );\n  }\n  static createAnnouncer() {\n    const e = getDocument().createElement(\"div\");\n    e.classList.add(\"ag-charts-aria-announcer\");\n    setAttribute(e, \"role\", \"status\");\n    setAttribute(e, \"aria-live\", \"assertive\");\n    return e;\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  onResize(event) {\n    this.liveElem.style.width = `${event.chart.width}px`;\n    this.liveElem.style.height = `${event.chart.height}px`;\n  }\n  announceValue(id, params) {\n    const { localeManager, liveElem } = this;\n    const value = localeManager.t(id, params);\n    this.debug(`AriaAnnouncementService - announceValue: ${value}`);\n    liveElem.textContent = \"\\xA0\";\n    setTimeout(() => liveElem.innerText = value, 16);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: \"axis-hover\",\n      axisId,\n      direction\n    };\n    this.listeners.dispatch(\"axis-hover\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class _ContextMenuRegistry {\n  constructor(regionManager) {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n    const { Default: Default2, ContextMenu } = InteractionState;\n    this.destroyFns = [regionManager.listenAll(\"contextmenu\", (e) => this.onContextMenu(e), Default2 | ContextMenu)];\n  }\n  destroy() {\n    this.destroyFns.forEach((d) => d());\n  }\n  onContextMenu(event) {\n    const type = _ContextMenuRegistry.toContextType(event.region);\n    if (type === \"all\") {\n      this.dispatchContext(\"all\", event, {});\n    }\n  }\n  static toContextType(region) {\n    if (region === \"legend\" || region === \"series\") {\n      return region;\n    }\n    return \"all\";\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context) {\n    const { offsetX: x, offsetY: y, sourceEvent } = pointerEvent;\n    this.listeners.dispatch(\"\", buildPreventable({ type, x, y, context, sourceEvent }));\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    if (action.id && this.defaultActions.find(({ id }) => id === action.id)) {\n      return;\n    }\n    this.defaultActions.push(action);\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  setActionVisiblity(actionId, visible) {\n    if (visible) {\n      this.hiddenActions.delete(actionId);\n    } else {\n      this.hiddenActions.add(actionId);\n    }\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/cursorManager.ts\nvar Cursor = /* @__PURE__ */ ((Cursor2) => {\n  Cursor2[\"Auto\"] = \"auto\";\n  Cursor2[\"Default\"] = \"default\";\n  Cursor2[\"Grab\"] = \"grab\";\n  Cursor2[\"Grabbing\"] = \"grabbing\";\n  Cursor2[\"Move\"] = \"move\";\n  Cursor2[\"NotAllowed\"] = \"not-allowed\";\n  Cursor2[\"Pointer\"] = \"pointer\";\n  Cursor2[\"EWResize\"] = \"ew-resize\";\n  Cursor2[\"NSResize\"] = \"ns-resize\";\n  Cursor2[\"ZoomIn\"] = \"zoom-in\";\n  Cursor2[\"ZoomOut\"] = \"zoom-out\";\n  return Cursor2;\n})(Cursor || {});\nvar CursorManager = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.stateTracker = new StateTracker(\"default\");\n  }\n  updateCursor(callerId, style) {\n    this.stateTracker.set(callerId, style);\n    this.domManager.updateCursor(this.stateTracker.stateValue());\n  }\n  getCursor() {\n    return this.domManager.getCursor();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts\nfunction distanceSquared(finger1, finger2) {\n  const dx = finger1.screenX - finger2.screenX;\n  const dy = finger1.screenY - finger2.screenY;\n  return dx * dx + dy * dy;\n}\nfunction distance(finger1, finger2) {\n  return Math.sqrt(distanceSquared(finger1, finger2));\n}\nvar MIN_DISTANCE_TO_START_PINCH = 1;\nvar GestureDetector = class extends BaseManager {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.touchstart = (event) => this.onTouchStart(event);\n    this.touchmove = (event) => this.onTouchMove(event);\n    this.touchend = (event) => this.onTouchEnd(event);\n    this.touchcancel = (event) => this.onTouchCancel(event);\n    this.pinch = {\n      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },\n      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },\n      origin: { x: NaN, y: NaN },\n      distance: NaN,\n      status: 0 /* Off */\n    };\n    this.domManager.addEventListener(\"touchstart\", this.touchstart, { passive: true });\n    this.domManager.addEventListener(\"touchmove\", this.touchmove, { passive: false });\n    this.domManager.addEventListener(\"touchend\", this.touchend);\n    this.domManager.addEventListener(\"touchcancel\", this.touchcancel);\n  }\n  destroy() {\n    this.domManager.removeEventListener(\"touchstart\", this.touchstart);\n    this.domManager.removeEventListener(\"touchmove\", this.touchmove);\n    this.domManager.removeEventListener(\"touchend\", this.touchend);\n    this.domManager.removeEventListener(\"touchcancel\", this.touchcancel);\n  }\n  findPinchTouches(moveEvent) {\n    const { touches } = moveEvent;\n    const { finger1, finger2 } = this.pinch;\n    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {\n      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {\n        return [touches[0], touches[1]];\n      }\n      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {\n        return [touches[1], touches[0]];\n      }\n    }\n  }\n  copyTouchData(event) {\n    const keys = [\"identifier\", \"screenX\", \"screenY\"];\n    partialAssign(keys, this.pinch.finger1, event.touches[0]);\n    partialAssign(keys, this.pinch.finger2, event.touches[1]);\n    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);\n  }\n  dispatchPinchEvent(type, deltaDistance, sourceEvent) {\n    const { finger1, finger2, origin } = this.pinch;\n    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin }));\n  }\n  onTouchStart(event) {\n    this.stopPinchTracking(event);\n    const { pinch } = this;\n    if (event.touches.length === 2) {\n      pinch.status = 1 /* Initialized */;\n      this.copyTouchData(event);\n      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n    }\n  }\n  onTouchMove(event) {\n    const pinchTouches = this.findPinchTouches(event);\n    if (pinchTouches !== void 0) {\n      const [touch1, touch2] = pinchTouches;\n      const { pinch } = this;\n      const newDistance = distance(touch1, touch2);\n      const deltaDistance = newDistance - pinch.distance;\n      if (pinch.status === 1 /* Initialized */) {\n        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {\n          pinch.status = 2 /* Running */;\n          this.copyTouchData(event);\n          this.dispatchPinchEvent(\"pinch-start\", 0, event);\n        }\n      } else if (pinch.status === 2 /* Running */) {\n        pinch.distance = newDistance;\n        this.copyTouchData(event);\n        this.dispatchPinchEvent(\"pinch-move\", deltaDistance, event);\n      } else {\n        Logger.error(`unexpected pinch.status: ${pinch.status}`);\n      }\n    }\n  }\n  onTouchEnd(event) {\n    this.stopPinchTracking(event);\n  }\n  onTouchCancel(event) {\n    this.stopPinchTracking(event);\n  }\n  stopPinchTracking(event) {\n    const { pinch } = this;\n    if (pinch.status === 2 /* Running */) {\n      this.dispatchPinchEvent(\"pinch-end\", 0, event);\n    }\n    this.pinch.status = 0 /* Off */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight,\n        callerId\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts\nvar KeyNavManager = class extends BaseManager {\n  constructor(interactionManager, domManager) {\n    super();\n    this.domManager = domManager;\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.isClicking = false;\n    this.destroyFns.push(\n      interactionManager.addListener(\"drag-start\", (e) => this.onClickStart(e), 31 /* All */),\n      interactionManager.addListener(\"click\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"drag-end\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"wheel\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"hover\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"drag\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"blur\", (e) => this.onBlur(e), 31 /* All */),\n      interactionManager.addListener(\"focus\", (e) => this.onFocus(e), 31 /* All */),\n      interactionManager.addListener(\"keydown\", (e) => this.onKeyDown(e), 31 /* All */)\n    );\n  }\n  destroy() {\n    super.destroy();\n  }\n  onClickStart(event) {\n    this.isClicking = true;\n    this.mouseBlur(event);\n  }\n  onClickStop(event) {\n    this.mouseBlur(event);\n    this.isClicking = false;\n  }\n  mouseBlur(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    if (!this.isMouseBlurred) {\n      this.dispatch(\"blur\", 0, event);\n      this.isMouseBlurred = true;\n    }\n  }\n  onBlur(event) {\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.dispatch(\"blur\", 0, event);\n  }\n  onFocus(event) {\n    const delta3 = this.domManager.getBrowserFocusDelta();\n    this.dispatch(\"browserfocus\", delta3, event);\n    this.hasBrowserFocus = true;\n    const tabFocusFromClick = event.relatedElement == null && event.targetElement?.tagName === \"CANVAS\";\n    if (this.isClicking || tabFocusFromClick) {\n      this.isMouseBlurred = true;\n      return;\n    }\n    this.dispatch(\"tab\", delta3, event);\n  }\n  onKeyDown(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    this.isMouseBlurred = false;\n    const { code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;\n    if (code === \"Tab\") {\n      if (shiftKey) {\n        return this.dispatch(\"tab\", -1, event);\n      } else {\n        return this.dispatch(\"tab\", 1, event);\n      }\n    }\n    if (altKey || shiftKey || metaKey || ctrlKey)\n      return;\n    switch (code) {\n      case \"ArrowDown\":\n        return this.dispatch(\"nav-vert\", 1, event);\n      case \"ArrowUp\":\n        return this.dispatch(\"nav-vert\", -1, event);\n      case \"ArrowLeft\":\n        return this.dispatch(\"nav-hori\", -1, event);\n      case \"ArrowRight\":\n        return this.dispatch(\"nav-hori\", 1, event);\n      case \"ZoomIn\":\n      case \"Add\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"ZoomOut\":\n      case \"Substract\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n      case \"Space\":\n      case \"Enter\":\n        return this.dispatch(\"submit\", 0, event);\n      case \"Escape\":\n        return this.dispatch(\"cancel\", 0, event);\n      case \"Backspace\":\n      case \"Delete\":\n        return this.dispatch(\"delete\", 0, event);\n    }\n    switch (event.sourceEvent.key) {\n      case \"+\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"-\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n    }\n  }\n  dispatch(type, delta3, sourceEvent) {\n    dispatchTypedEvent(this.listeners, { type, delta: delta3, sourceEvent });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regionManager.ts\nvar REGION_TAB_ORDERING = [\"series\"];\nvar RegionListeners = class extends Listeners {\n};\nfunction addHandler(listeners, interactionManager, type, handler, triggeringStates = 16 /* Default */) {\n  return listeners?.addListener(type, (e) => {\n    const currentState = interactionManager.getState();\n    if (currentState & triggeringStates) {\n      handler(e);\n    }\n  }) ?? (() => {\n  });\n}\nvar RegionManager = class {\n  constructor(interactionManager, keyNavManager, focusIndicator) {\n    this.interactionManager = interactionManager;\n    this.keyNavManager = keyNavManager;\n    this.focusIndicator = focusIndicator;\n    this.currentTabIndex = 0;\n    this.isDragging = false;\n    this.leftCanvas = false;\n    this.regions = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.allRegionsListeners = new RegionListeners();\n    this.destroyFns.push(\n      ...POINTER_INTERACTION_TYPES.map(\n        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 31 /* All */)\n      ),\n      this.keyNavManager.addListener(\"blur\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"browserfocus\", this.onBrowserFocus.bind(this)),\n      this.keyNavManager.addListener(\"tab\", this.onTab.bind(this)),\n      this.keyNavManager.addListener(\"nav-vert\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-hori\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-zoom\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"submit\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"cancel\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"delete\", this.onNav.bind(this))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.currentRegion = void 0;\n    for (const region of this.regions.values()) {\n      region.listeners.destroy();\n    }\n    this.focusIndicator.destroy();\n    this.regions.clear();\n  }\n  addRegion(name, ...bboxproviders) {\n    if (this.regions.has(name)) {\n      throw new Error(`AG Charts - Region: ${name} already exists`);\n    }\n    const region = {\n      properties: { name, bboxproviders: [...bboxproviders] },\n      listeners: new RegionListeners()\n    };\n    this.regions.set(name, region);\n    return this.makeObserver(region);\n  }\n  updateRegion(name, ...bboxprovider) {\n    const region = this.regions.get(name);\n    if (region) {\n      region.properties.bboxproviders = [...bboxprovider];\n    } else {\n      throw new Error(\"AG Charts - unknown region: \" + name);\n    }\n  }\n  getRegion(name) {\n    return this.makeObserver(this.regions.get(name));\n  }\n  listenAll(type, handler, triggeringStates = 16 /* Default */) {\n    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);\n  }\n  // This method return a wrapper object that matches the interface of InteractionManager.addListener.\n  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.\n  makeObserver(region) {\n    const { interactionManager } = this;\n    class ObservableRegionImplementation {\n      addListener(type, handler, triggeringStates = 16 /* Default */) {\n        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);\n      }\n    }\n    return new ObservableRegionImplementation();\n  }\n  checkPointerHistory(targetRegion, event) {\n    for (const historyEvent of event.pointerHistory) {\n      const { region: historyRegion } = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY);\n      if (targetRegion.properties.name !== historyRegion?.properties.name) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Create and dispatch a copy of the InteractionEvent.\n  dispatch(region, partialEvent, bboxProviderId) {\n    if (region == null)\n      return;\n    const event = buildPreventable({\n      ...partialEvent,\n      region: region.properties.name,\n      bboxProviderId\n    });\n    this.allRegionsListeners.dispatch(event.type, event);\n    region.listeners.dispatch(event.type, event);\n  }\n  // Process events during a drag action. Returns false if this event should follow the standard\n  // RegionManager.processEvent flow, or true if this event already processed by this function.\n  handleDragging(event) {\n    const { currentRegion } = this;\n    switch (event.type) {\n      case \"drag-start\":\n        this.isDragging = true;\n        this.leftCanvas = false;\n        break;\n      case \"leave\":\n        this.leftCanvas = true;\n        return this.isDragging;\n      case \"enter\":\n        this.leftCanvas = false;\n        return this.isDragging;\n      case \"drag\":\n        if (this.isDragging) {\n          this.dispatch(currentRegion, event);\n          return true;\n        }\n        break;\n      case \"drag-end\":\n        if (this.isDragging) {\n          this.isDragging = false;\n          this.dispatch(currentRegion, event);\n          if (this.leftCanvas) {\n            this.dispatch(currentRegion, { ...event, type: \"leave\" });\n          }\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n  processPointerEvent(event) {\n    if (this.handleDragging(event)) {\n      return;\n    }\n    const { currentRegion } = this;\n    if (event.type === \"leave\") {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" });\n      this.currentRegion = void 0;\n      return;\n    }\n    const { region: newRegion, bboxProviderId } = this.pickRegion(event.offsetX, event.offsetY);\n    if (currentRegion !== void 0 && newRegion?.properties.name !== currentRegion.properties.name) {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" }, this.currentBBoxProviderId);\n    }\n    if (newRegion !== void 0 && newRegion.properties.name !== currentRegion?.properties.name) {\n      this.dispatch(newRegion, { ...event, type: \"enter\" }, bboxProviderId);\n    }\n    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {\n      this.dispatch(newRegion, event, bboxProviderId);\n    }\n    this.currentRegion = newRegion;\n    this.currentBBoxProviderId = bboxProviderId;\n  }\n  pickRegion(x, y) {\n    let currentArea = Infinity;\n    let currentRegion;\n    let currentBBoxProviderId;\n    for (const region of this.regions.values()) {\n      for (const provider of region.properties.bboxproviders) {\n        if (provider.visible === false)\n          continue;\n        const bbox = provider.computeTransformedRegionBBox?.() ?? provider.computeTransformedBBox();\n        const area2 = bbox.width * bbox.height;\n        if (area2 < currentArea && bbox.containsPoint(x, y)) {\n          currentArea = area2;\n          currentRegion = region;\n          currentBBoxProviderId = provider.id;\n        }\n      }\n    }\n    return { region: currentRegion, bboxProviderId: currentBBoxProviderId };\n  }\n  getTabRegion(tabIndex) {\n    if (tabIndex !== void 0 && tabIndex >= 0 && tabIndex < REGION_TAB_ORDERING.length) {\n      return this.regions.get(REGION_TAB_ORDERING[tabIndex]);\n    }\n    return void 0;\n  }\n  getNextInteractableTabIndex(currentIndex, delta3) {\n    const direction = delta3 < 0 ? -1 : 1;\n    let i = currentIndex;\n    while (delta3 !== 0) {\n      const region = this.getTabRegion(i + direction);\n      if (region === void 0) {\n        return void 0;\n      } else {\n        delta3 = delta3 - direction;\n      }\n      i = i + direction;\n    }\n    return i;\n  }\n  validateCurrentTabIndex() {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (focusedRegion !== void 0) {\n      this.currentTabIndex = this.getNextInteractableTabIndex(-1, 1) ?? 0;\n    }\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.currentTabIndex = -1;\n    } else if (event.delta < 0) {\n      this.currentTabIndex = REGION_TAB_ORDERING.length;\n    }\n  }\n  onTab(event) {\n    this.validateCurrentTabIndex();\n    const newTabIndex = this.getNextInteractableTabIndex(this.currentTabIndex, event.delta);\n    const newRegion = this.getTabRegion(newTabIndex);\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (newTabIndex !== void 0) {\n      this.currentTabIndex = newTabIndex;\n    }\n    if (focusedRegion !== void 0 && newRegion?.properties.name !== focusedRegion.properties.name) {\n      const { delta: delta3, sourceEvent } = event;\n      const blurEvent = buildPreventable({ type: \"blur\", delta: delta3, sourceEvent });\n      this.dispatch(focusedRegion, blurEvent);\n    }\n    if (newRegion === void 0) {\n      this.focusIndicator.updateBounds(void 0);\n    } else {\n      this.dispatch(newRegion, event);\n    }\n  }\n  onNav(event) {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    this.dispatch(focusedRegion, event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts\nvar TOOLBAR_ALIGNMENTS = [\"start\", \"center\", \"end\"];\nvar TOOLBAR_GROUPS = [\"seriesType\", \"annotations\", \"annotationOptions\", \"ranges\", \"zoom\"];\nvar TOOLBAR_GROUP_ORDERING = {\n  seriesType: 0,\n  annotations: 1,\n  annotationOptions: 2,\n  ranges: 3,\n  zoom: 4\n};\nvar ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {\n  ToolbarPosition2[\"Top\"] = \"top\";\n  ToolbarPosition2[\"Right\"] = \"right\";\n  ToolbarPosition2[\"Bottom\"] = \"bottom\";\n  ToolbarPosition2[\"Left\"] = \"left\";\n  ToolbarPosition2[\"Floating\"] = \"floating\";\n  ToolbarPosition2[\"FloatingTop\"] = \"floating-top\";\n  ToolbarPosition2[\"FloatingBottom\"] = \"floating-bottom\";\n  return ToolbarPosition2;\n})(ToolbarPosition || {});\nvar TOOLBAR_POSITIONS = Object.values(ToolbarPosition);\nfunction isAnimatingFloatingPosition(position) {\n  return [\"floating-top\" /* FloatingTop */, \"floating-bottom\" /* FloatingBottom */].includes(position);\n}\n\n// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts\nvar ToolbarManager = class extends BaseManager {\n  static isGroup(group, event) {\n    return event.group === group;\n  }\n  static isChildElement(domManager, element2) {\n    for (const position of TOOLBAR_POSITIONS) {\n      if (domManager.isManagedChildDOMElement(element2, \"canvas-overlay\", `toolbar-${position}`)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pressButton(group, id, value, rect) {\n    this.listeners.dispatch(\"button-pressed\", { type: \"button-pressed\", group, id, value, rect });\n  }\n  cancel(group) {\n    this.listeners.dispatch(\"cancelled\", { type: \"cancelled\", group });\n  }\n  toggleButton(group, id, options) {\n    const { active = false, enabled = true, visible = true } = options;\n    this.listeners.dispatch(\"button-toggled\", { type: \"button-toggled\", group, id, active, enabled, visible });\n  }\n  updateButton(group, id, options) {\n    this.listeners.dispatch(\"button-updated\", { type: \"button-updated\", group, id, ...options });\n  }\n  toggleGroup(caller, group, options) {\n    const { active, visible } = options;\n    this.listeners.dispatch(\"group-toggled\", { type: \"group-toggled\", caller, group, active, visible });\n  }\n  changeFloatingAnchor(group, anchor) {\n    this.listeners.dispatch(\"floating-anchor-changed\", { type: \"floating-anchor-changed\", group, anchor });\n  }\n  buttonMoved(group, value, rect, groupRect) {\n    this.listeners.dispatch(\"button-moved\", { type: \"button-moved\", group, value, rect, groupRect });\n  }\n  proxyGroupOptions(caller, group, options) {\n    this.listeners.dispatch(\"proxy-group-options\", { type: \"proxy-group-options\", caller, group, options });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.toggle(false));\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  getTooltipMeta(callerId) {\n    return this.stateTracker.get(callerId)?.meta;\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.toggle(false);\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    const boundingRect = this.tooltip.bounds === \"extended\" ? this.domManager.getOverlayClientRect() : canvasRect;\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, datum) {\n    const { offsetX, offsetY } = event;\n    const { tooltip } = datum.series.properties;\n    const meta = {\n      offsetX,\n      offsetY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, offsetX, offsetY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);\n    if (tooltip.position.type === \"node\" && refPoint) {\n      const { x, y } = refPoint;\n      const point = datum.series.contentGroup.inverseTransformPoint(x, y);\n      return {\n        ...meta,\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      };\n    }\n    return meta;\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutService.ts\nvar LayoutService = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.layoutComplete = \"layout-complete\";\n    this.debug = Debug.create(true, \"layout\");\n  }\n  addListener(eventType, handler) {\n    if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\n      return super.addListener(eventType, handler);\n    }\n    throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\n  }\n  dispatchPerformLayout(stage, ctx) {\n    if (this.isLayoutStage(stage)) {\n      return this.getListenersByType(stage).reduce((result, listener) => {\n        try {\n          const newCtx = listener.handler(result);\n          this.debug(\"[LayoutService] Context updated to: \", { ...newCtx }, listener);\n          return newCtx;\n        } catch (e) {\n          Logger.errorOnce(e);\n          return result;\n        }\n      }, ctx);\n    }\n    return ctx;\n  }\n  dispatchLayoutComplete(event) {\n    this.dispatch(this.layoutComplete, event);\n  }\n  isLayoutStage(eventType) {\n    return eventType !== this.layoutComplete;\n  }\n  isLayoutComplete(eventType) {\n    return eventType === this.layoutComplete;\n  }\n};\n\n// packages/ag-charts-community/src/chart/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)}(?:\\[(\\w+)])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\" }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : void 0;\n    if (format != null && formatter == null) {\n      Logger.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return String(value);\n  });\n};\n\n// packages/ag-charts-community/src/chart/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({\n    id,\n    seriesGrouping,\n    visible,\n    type\n  }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][id] = { grouping: seriesGrouping, visible };\n  }\n  deregisterSeries({ id, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][id];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({\n    type,\n    seriesGrouping,\n    visible\n  }) {\n    if (!seriesGrouping)\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType3) => {\n  ChartUpdateType3[ChartUpdateType3[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType3[ChartUpdateType3[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType3[ChartUpdateType3[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType3[ChartUpdateType3[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType3[ChartUpdateType3[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType3[ChartUpdateType3[\"PRE_SCENE_RENDER\"] = 5] = \"PRE_SCENE_RENDER\";\n  ChartUpdateType3[ChartUpdateType3[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType3[ChartUpdateType3[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType3;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete(rects) {\n    this.dispatch(\"update-complete\", {\n      type: \"update-complete\",\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    });\n  }\n  dispatchPreSceneRender(rects) {\n    this.dispatch(\"pre-scene-render\", { type: \"pre-scene-render\", ...rects });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    const { scene, root, syncManager, container, updateCallback, updateMutex, overrideDevicePixelRatio } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.zoomManager = chart.zoomManager;\n    this.domManager = new DOMManager(container);\n    scene?.setContainer(this.domManager);\n    this.scene = scene ?? new Scene({ pixelRatio: overrideDevicePixelRatio, domManager: this.domManager });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.localeManager = new LocaleManager();\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.chartEventManager = new ChartEventManager();\n    this.cursorManager = new CursorManager(this.domManager);\n    this.highlightManager = new HighlightManager();\n    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);\n    this.keyNavManager = new KeyNavManager(this.interactionManager, this.domManager);\n    this.focusIndicator = new FocusIndicator(this.domManager);\n    this.regionManager = new RegionManager(this.interactionManager, this.keyNavManager, this.focusIndicator);\n    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);\n    this.toolbarManager = new ToolbarManager();\n    this.gestureDetector = new GestureDetector(this.domManager);\n    this.layoutService = new LayoutService();\n    this.ariaAnnouncementService = new AriaAnnouncementService(\n      this.localeManager,\n      this.domManager,\n      this.layoutService\n    );\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(\n      this.updateService,\n      this.localeManager,\n      this.domManager,\n      this.focusIndicator\n    );\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.callbackCache = new CallbackCache();\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.animationManager.skip();\n    this.animationManager.play();\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n  }\n  destroy() {\n    this.tooltipManager.destroy();\n    this.contextMenuRegistry.destroy();\n    this.regionManager.destroy();\n    this.proxyInteractionService.destroy();\n    this.focusIndicator.destroy();\n    this.keyNavManager.destroy();\n    this.interactionManager.destroy();\n    this.animationManager.stop();\n    this.animationManager.destroy();\n    this.ariaAnnouncementService.destroy();\n    this.chartEventManager.destroy();\n    this.highlightManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.animationManager.reset();\n    this.syncManager.destroy();\n    this.domManager.destroy();\n    this.axisManager.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round2(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtentInternal(extent2) {\n  if (extent2 == null) {\n    return [];\n  }\n  let [min, max] = extent2.map(Number);\n  if (min === 0 && max === 0) {\n    return [0, 1];\n  }\n  if (min === Infinity && max === -Infinity) {\n    return [];\n  } else if (min === Infinity) {\n    min = 0;\n  } else if (max === -Infinity) {\n    max = 0;\n  }\n  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];\n}\nfunction fixNumericExtent(extent2, axis) {\n  const fixedExtent = fixNumericExtentInternal(extent2);\n  if (fixedExtent.length === 0) {\n    return fixedExtent;\n  }\n  let [min, max] = fixedExtent;\n  if (min === max) {\n    const [paddingMin, paddingMax] = axis?.calculatePadding(min, max) ?? [1, 1];\n    min -= paddingMin;\n    max += paddingMax;\n  }\n  return [min, max];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|\\\\')*'|\"(?:[^\"]|\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\") {\n    this.opts = opts;\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    for (const def of opts.props) {\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);\n  }\n  resolveProcessedDataDefsValues(defs, { keys, values }) {\n    const result = {};\n    for (const [searchId, { index, def }] of defs) {\n      const processedData = def.type === \"key\" ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  getDomain(scope, searchId, type = \"value\", processedData) {\n    const domains = this.getDomainsByType(type, processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(data, sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(data, sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    if (data.length > 0) {\n      for (const def of iterate(this.keys, this.values)) {\n        for (const [scope, missCount] of def.missing) {\n          if (missCount >= data.length) {\n            const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n          }\n        }\n      }\n    }\n    const end = performance.now();\n    processedData.time = end - start;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.findIndex((def) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));\n    });\n    if (result === -1) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(data, sources) {\n    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const sourcesById = new Map(sources?.map((s) => [s.id, s]));\n    const { keys: keyDefs, values: valueDefs } = this;\n    const resultData = new Array(data.length);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const [datumIdx, datum] of data.entries()) {\n      const sourceDatums = {};\n      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;\n      const keys = new Array(keyDefs.length);\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE)\n          break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE)\n        continue;\n      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;\n      let value;\n      for (const [valueDefIdx, def] of valueDefs.entries()) {\n        for (const scope of def.scopes ?? scopes) {\n          const source = sourcesById.get(scope);\n          const valueDatum = source?.data[datumIdx] ?? datum;\n          value = processValue(def, valueDatum, value, scope);\n          if (value === INVALID_VALUE || !values)\n            continue;\n          if (source != null && def.includeProperty !== false) {\n            const property = def.includeProperty && def.id != null ? def.id : def.property;\n            sourceDatums[scope] ?? (sourceDatums[scope] = {});\n            sourceDatums[scope][property] = value;\n          }\n          values[valueDefIdx] = value;\n        }\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs)\n            break;\n          for (const scope of def.scopes ?? scopes) {\n            validScopes?.delete(scope);\n          }\n          if (validScopes?.size === 0)\n            break;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs)\n        continue;\n      if (validScopes?.size === 0)\n        continue;\n      const result = { datum: { ...datum, ...sourceDatums }, keys, values };\n      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n        partialValidDataCount++;\n        result.validScopes = new Set(validScopes);\n      }\n      resultData[resultDataIdx++] = result;\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: data.length },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    const processedData = /* @__PURE__ */ new Map();\n    for (const dataEntry of data.data) {\n      const { keys, values, datum, validScopes } = dataEntry;\n      const group = groupingFn?.(dataEntry) ?? keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null && existingData.validScopes != null) {\n          for (const scope of existingData.validScopes) {\n            if (!validScopes.has(scope)) {\n              existingData.validScopes.delete(scope);\n            }\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const { keys, values, datum, validScopes } of processedData.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      data: resultData,\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      }\n    };\n  }\n  aggregateData(processedData) {\n    const isUngrouped = processedData.type === \"ungrouped\";\n    processedData.domain.aggValues = [];\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      const domain = [Infinity, -Infinity];\n      for (const datum of processedData.data) {\n        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));\n        if (datum.validScopes)\n          continue;\n        const values = isUngrouped ? [datum.values] : datum.values;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\n          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));\n        datum.aggValues[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domain);\n      }\n      processedData.domain.aggValues.push(domain);\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const affectedIndices = /* @__PURE__ */ new Set();\n    const updatedDomains = /* @__PURE__ */ new Map();\n    const groupProcessorIndices = /* @__PURE__ */ new Map();\n    const groupProcessorInitFns = /* @__PURE__ */ new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        const isDiscrete = valueDef.valueType === \"category\";\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());\n      }\n    }\n    const updateDomains = (values) => {\n      for (const valueIndex of affectedIndices) {\n        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        if (group.validScopes)\n          continue;\n        const valueIndexes = groupProcessorIndices.get(processor) ?? [];\n        const adjustFn = groupProcessorInitFns.get(processor)?.();\n        if (!adjustFn)\n          continue;\n        if (processedData.type === \"grouped\") {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n        } else if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === \"grouped\") {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = dataDomain.getDomain();\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes, property));\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      for (const datum of processedData.data) {\n        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {\n          accValue = reducer(accValue, datum);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, previousDatum, scope) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch (error) {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        const missCount = def.missing.get(scope) ?? 0;\n        def.missing.set(scope, missCount + 1);\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && def.validation?.(value, datum) === false) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            Logger.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.mode === \"integrated\") {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        Logger.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n  if (processedData.type === \"grouped\") {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const keys = next.keys ?? [];\n      const aggValues = next.aggValues ?? [];\n      const skipKeys = next.keys.map(() => void 0);\n      const skipAggValues = aggValues?.map(() => void 0);\n      acc.push(\n        ...next.values.map((v, i) => [\n          ...i === 0 ? keys : skipKeys,\n          ...v ?? [],\n          ...i == 0 ? aggValues : skipAggValues\n        ])\n      );\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const aggValues = next.aggValues ?? [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  }\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute() {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const scopes = this.requested.map(({ id }) => id);\n    const needsValueExtraction = this.hasMultipleDataSources(valid);\n    for (const { opts, data, resolves, rejects, ids } of merged) {\n      try {\n        const dataModel = new DataModel(opts, this.mode);\n        const processedData = dataModel.processData(data, valid);\n        if (this.debug.check()) {\n          getWindow(\"processedData\").push(processedData);\n        }\n        if (processedData?.partialValidDataCount === 0) {\n          resolves.forEach(\n            (resolve, requestIdx) => resolve({\n              dataModel,\n              processedData: this.processScopedData(\n                ids[requestIdx],\n                processedData,\n                scopes,\n                needsValueExtraction\n              )\n            })\n          );\n        } else if (processedData) {\n          this.splitResult(dataModel, processedData, ids, resolves);\n        } else {\n          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n        }\n      } catch (error) {\n        rejects.forEach((cb) => cb(error));\n      }\n    }\n  }\n  hasMultipleDataSources(validRequests) {\n    if (validRequests.length) {\n      const [{ data }, ...restRequests] = validRequests;\n      return restRequests.some((v) => data !== v.data);\n    }\n    return false;\n  }\n  processScopedData(id, processedData, ids, needsValueExtraction) {\n    const extractDatum = (datum) => {\n      if (Array.isArray(datum)) {\n        return datum.map(extractDatum);\n      }\n      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;\n      for (const otherId of ids) {\n        delete extracted[otherId];\n      }\n      return extracted;\n    };\n    const extractValues = (values) => {\n      if (Array.isArray(values)) {\n        return values.map(extractValues);\n      }\n      return values?.[id] ?? values;\n    };\n    return {\n      ...processedData,\n      data: processedData.data.map((datum) => ({\n        ...datum,\n        datum: extractDatum(datum.datum),\n        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values\n      }))\n    };\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData: {\n          ...processedData,\n          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)\n        }\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props) {\n      return props.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);\n  }\n  static mergeRequests(requests) {\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone = { ...prop, scopes: [id] };\n          _DataController.createIdsMap(id, clone);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone.type && _DataController.deepEqual(existing, clone)\n          );\n          if (!match) {\n            result.opts.props.push(clone);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone.idsMap?.size) {\n            _DataController.mergeIdsMap(clone.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      const toMapValue = toMap.get(scope);\n      if (toMapValue != null) {\n        for (const id of ids) {\n          toMapValue.add(id);\n        }\n      } else {\n        toMap.set(scope, new Set(ids));\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.hidden = /* @__PURE__ */ new Set();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.moduleFactory);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n    if (module.hidden) {\n      this.hidden.add(axisType);\n    }\n  }\n  create(axisType, moduleContext) {\n    const axisFactory = this.axesMap.get(axisType);\n    if (axisFactory) {\n      return axisFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  publicKeys() {\n    return [...this.keys()].filter((k) => !this.hidden.has(k));\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"foreground\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"chartToolbar\",\n    chartTypes: [\"cartesian\"]\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"], optionsInnerKey: \"miniChart\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bullet\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, moduleFactory });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;\n    if (legendFactory) {\n      return legendFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType2) {\n    return super.get(seriesType2) ?? \"unknown\";\n  }\n  isCartesian(seriesType2) {\n    return this.get(seriesType2) === \"cartesian\";\n  }\n  isPolar(seriesType2) {\n    return this.get(seriesType2) === \"polar\";\n  }\n  isHierarchy(seriesType2) {\n    return this.get(seriesType2) === \"hierarchy\";\n  }\n  isTopology(seriesType2) {\n    return this.get(seriesType2) === \"topology\";\n  }\n  isFlowProportion(seriesType2) {\n    return this.get(seriesType2) === \"flow-proportion\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType2, defaults) {\n    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));\n  }\n};\nvar chartTypes = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType2, {\n    chartTypes: [chartType2],\n    moduleFactory,\n    tooltipDefaults,\n    defaultAxes,\n    themeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    swapDefaultAxesCondition,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType2, themeTemplate);\n    this.seriesMap.set(seriesType2, {\n      moduleFactory,\n      tooltipDefaults,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault,\n      swapDefaultAxesCondition\n    });\n    chartTypes.set(seriesType2, chartType2);\n    if (!hidden) {\n      publicChartTypes.set(seriesType2, chartType2);\n    }\n  }\n  create(seriesType2, moduleContext) {\n    const seriesFactory = this.seriesMap.get(seriesType2)?.moduleFactory;\n    if (seriesFactory) {\n      return seriesFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType2}`);\n  }\n  cloneDefaultAxes(seriesType2) {\n    const defaultAxes = this.seriesMap.get(seriesType2)?.defaultAxes;\n    return defaultAxes ? { axes: deepClone(defaultAxes) } : null;\n  }\n  setThemeTemplate(seriesType2, themeTemplate) {\n    const currentTemplate = this.themeTemplates.get(seriesType2);\n    this.themeTemplates.set(seriesType2, mergeDefaults(themeTemplate, currentTemplate));\n  }\n  getThemeTemplate(seriesType2) {\n    return this.themeTemplates.get(seriesType2);\n  }\n  getPaletteFactory(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.tooltipDefaults;\n  }\n  isSolo(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.solo ?? false;\n  }\n  isGroupable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.groupable ?? false;\n  }\n  isStackable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackedByDefault ?? false;\n  }\n  isDefaultAxisSwapNeeded(options) {\n    let result;\n    for (const series of options.series ?? []) {\n      const { type = \"line\" } = series;\n      const isDefaultAxisSwapped = this.seriesMap.get(type)?.swapDefaultAxesCondition?.(series);\n      if (isDefaultAxisSwapped != null) {\n        if (result != null && result != isDefaultAxisSwapped) {\n          throw new Error(\"AG Charts - The provided series have incompatible directions\");\n        }\n        result = isDefaultAxisSwapped;\n      }\n    }\n    return result;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar ZoomManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.rejectCallbacks = /* @__PURE__ */ new Map();\n  }\n  updateAxes(axes) {\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {\n    if (rejectCallback) {\n      this.rejectCallbacks.set(callerId, rejectCallback);\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId || canChangeInitial) {\n        this.state.set(callerId, newZoom);\n        if (stateId !== callerId) {\n          this.rejectCallbacks.get(stateId)?.(callerId);\n        }\n      } else {\n        rejectCallback?.(stateId);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyChanges(callerId) {\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  applyChanges() {\n    const prevZoom = this.currentZoom;\n    this.currentZoom = this.state.stateValue();\n    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\"direction\", \"xKey\", \"yKey\", \"sizeKey\", \"angleKey\", \"radiusKey\", \"normalizedTo\"];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i, opts) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    if (opts?.seriesGrouping) {\n      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push(o);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  let targetIdx = -1;\n  for (const [key, optArray] of optsMap.entries()) {\n    for (const opts of optArray) {\n      targetIdx++;\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, outputIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"series-grouping\" });\n      } else if (diff2) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"update\" });\n      } else {\n        changes.push({ opts, series: outputSeries, idx: outputIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, outputIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: outputIdx, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  return input.series?.[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return true;\n  }\n  if (specifiedType === \"cartesian\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"polar\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"hierarchy\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"topology\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"flow-proportion\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-chart-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-chart-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      if (htmlContent instanceof HTMLElement) {\n        this.content = htmlContent;\n      } else {\n        const tempDiv = createElement(\"div\");\n        tempDiv.innerHTML = htmlContent;\n        this.content = tempDiv.firstElementChild;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        font: \"12px Verdana, sans-serif\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-chart-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-chart-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-chart-no-visible-series\", \"overlayNoVisibleSeries\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\n  const normalise = (val, extent2) => {\n    const result = val * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valueExtent = typeof value === \"number\" ? value : Math.max(...value);\n      const valIdx = valueExtent < 0 ? 0 : 1;\n      if (mode === \"sum\") {\n        valuesExtent[valIdx] += valueExtent;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);\n      }\n    }\n    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      values[valueIdx] = typeof value === \"number\" ? normalise(value, extent2) : value.map((v) => normalise(v, extent2));\n    }\n  };\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo, mode = \"sum\") {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start, span) => {\n    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start, end] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start = rangeMin;\n    if (rangeMax != null)\n      end = rangeMax;\n    const span = end - start;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === \"ungrouped\") {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys, values } = result.defs;\n      const { input, data } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!valueKeyIds?.includes(values[k].id))\n          continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        if (def.valueType === \"category\") {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = data[0]?.[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], \"keys\");\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, \"values\");\n      }\n      return { uniqueKeys, orderedKeys };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (!isFiniteNumber(currentVal))\n        continue;\n      if (mode === \"normal\")\n        acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === \"trailing\")\n        acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (values, valueIndexes) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === \"normal\") {\n            acc += sumValue;\n          }\n          values[valueIdx] = acc;\n          if (mode === \"trailing\") {\n            acc += sumValue;\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction groupStackAccFn() {\n  return () => (values, valueIndexes) => {\n    const acc = new Float64Array(32);\n    let stackCount = 0;\n    for (const valueIdx of valueIndexes) {\n      const currentValue = values[valueIdx];\n      acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;\n      stackCount += 1;\n      values[valueIdx] = acc.subarray(0, stackCount);\n    }\n  };\n}\nfunction accumulateStack(matchGroupId) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust: groupStackAccFn\n  };\n}\nfunction diff(previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate: (processedData) => {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const length2 = Math.max(previousData.data.length, processedData.data.length);\n      for (let i = 0; i < length2; i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : \"\";\n        const datumId = datum ? createDatumId(datum.keys) : \"\";\n        if (datum && prev && prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          removed.set(prevId, prev);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      return { changed, added, updated, removed, moved };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || typeof result === \"boolean\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2 = \"current\", opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupStackValueProperty(propName, scaleType, opts) {\n  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];\n}\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({ name: \"seriesRoot\", isVirtual: true });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this._pickNodeCache = new LRUCache();\n    const {\n      moduleCtx,\n      pickModes = [1 /* NEAREST_BY_MAIN_AXIS_FIRST */],\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-content`,\n        isVirtual: contentGroupVirtual,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.highlightGroup = new Group({\n      name: `${this.internalId}-highlight`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"highlight\")\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */\n      })\n    );\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"annotation\")\n    });\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(value) {\n    this.properties.visible = value;\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries({ id: internalId, type });\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ id: internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case \"data\":\n      case \"paths\":\n        break;\n      case \"labels\":\n        mainAdjust += 2e4;\n        break;\n      case \"marker\":\n        mainAdjust += 1e4;\n        break;\n      case \"highlight\":\n        subIndex += 15e3;\n        break;\n      case \"annotation\":\n        mainAdjust += 15e3;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction));\n    return seriesDomain.concat(moduleDomains.flat());\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.registerSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, intent, exactMatchOnly = false) {\n    const { pickModes, visible, rootGroup } = this;\n    if (!visible || !rootGroup.visible)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight-tooltip\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    let maxDistance = Infinity;\n    if (intent === \"tooltip\" || intent === \"highlight-tooltip\") {\n      const { tooltip } = this.properties;\n      maxDistance = typeof tooltip.range === \"number\" ? tooltip.range : Infinity;\n      exactMatchOnly || (exactMatchOnly = tooltip.range === \"exact\");\n    } else if (intent === \"event\") {\n      const { nodeClickRange } = this.properties;\n      maxDistance = typeof nodeClickRange === \"number\" ? nodeClickRange : Infinity;\n      exactMatchOnly || (exactMatchOnly = nodeClickRange === \"exact\");\n    }\n    const selectedPickModes = pickModes.filter(\n      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */\n    );\n    const { x, y } = point;\n    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });\n    if (this._pickNodeCache.has(key)) {\n      return this._pickNodeCache.get(key);\n    }\n    for (const pickMode of selectedPickModes) {\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_BY_MAIN_AXIS_FIRST */:\n        case 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */:\n          match = this.pickNodeMainAxisFirst(\n            point,\n            pickMode === 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */\n          );\n          break;\n        case 3 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n      }\n      if (match && match.distance <= maxDistance) {\n        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });\n      }\n    }\n    return this._pickNodeCache.set(key, void 0);\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.dispatch(\"visibility-changed\", { itemId, enabled });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n    }\n  }\n  getMinRects(_width, _height) {\n    return;\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nSeries.highlightedZIndex = 1e12;\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction convertValuesToScaleByDefs({\n  defs,\n  values,\n  xAxis,\n  yAxis\n}) {\n  if (!(xAxis && yAxis)) {\n    throw new Error(\"Axes must be defined\");\n  }\n  const result = {};\n  for (const [searchId, { def }] of defs) {\n    if (Object.hasOwn(values, searchId)) {\n      const { scale: scale2 } = def.type === \"key\" ? xAxis : yAxis;\n      result[searchId] = Math.round(scale2.convert(values[searchId]));\n    }\n  }\n  return result;\n}\nfunction pickNode(inputSeries, point, intent, exactMatchOnly) {\n  const reverseSeries = [...inputSeries].reverse();\n  let result;\n  for (const series of reverseSeries) {\n    if (!series.visible || !series.rootGroup.visible) {\n      continue;\n    }\n    const { match, distance: distance3 } = series.pickNode(point, intent, exactMatchOnly) ?? {};\n    if (!match || distance3 == null) {\n      continue;\n    }\n    if (!result || result.distance > distance3) {\n      result = { series, distance: distance3, datum: match };\n    }\n    if (distance3 === 0) {\n      break;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaClickManager.ts\nvar SeriesAreaClickManager = class extends BaseManager {\n  constructor(id, chart, ctx) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.series = [];\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    this.destroyFns.push(\n      this.ctx.regionManager.listenAll(\"click\", (event) => this.onClick(event)),\n      this.ctx.regionManager.listenAll(\"dblclick\", (event) => this.onClick(event)),\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      seriesRegion.addListener(\"leave\", () => this.onLeave()),\n      horizontalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      verticalAxesRegion.addListener(\"leave\", () => this.onLeave())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.lastHover = void 0;\n  }\n  preSceneRender() {\n    if (this.lastHover) {\n      this.onHover(this.lastHover);\n    }\n  }\n  update(type, opts) {\n    this.ctx.updateService.update(type, opts);\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.paddedRect;\n  }\n  onLeave() {\n    this.lastHover = void 0;\n    this.ctx.cursorManager.updateCursor(this.id);\n  }\n  onHover({ offsetX, offsetY }) {\n    const found = pickNode(this.series, { x: offsetX, y: offsetY }, \"event\");\n    if (found?.series.hasEventListener(\"nodeClick\") || found?.series.hasEventListener(\"nodeDoubleClick\")) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    } else {\n      this.ctx.cursorManager.updateCursor(this.id);\n    }\n  }\n  onClick(event) {\n    if (this.seriesRect?.containsPoint(event.offsetX, event.offsetY) && this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    const newEvent = { type: event.type === \"click\" ? \"click\" : \"doubleClick\", event: event.sourceEvent };\n    this.chart.fireEvent(newEvent);\n  }\n  checkSeriesNodeClick(event) {\n    const result = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, \"event\");\n    if (result == null)\n      return false;\n    if (event.type === \"click\") {\n      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    if (event.type === \"dblclick\") {\n      event.preventZoomDblClick = result.distance === 0;\n      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    return false;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(bboxOrPath) {\n  if (bboxOrPath instanceof BBox) {\n    return bboxOrPath.computeCenter();\n  }\n  return bboxOrPath?.computeTransformedBBox()?.computeCenter();\n}\nfunction drawPickedFocus(focusIndicator, pick) {\n  const { bounds, showFocusBox } = pick;\n  if (showFocusBox) {\n    focusIndicator?.updateBounds(bounds);\n  }\n}\nfunction makeKeyboardPointerEvent(focusIndicator, pick) {\n  drawPickedFocus(focusIndicator, pick);\n  const { x: offsetX, y: offsetY } = computeCenter(pick.bounds) ?? {};\n  if (offsetX !== void 0 && offsetY !== void 0) {\n    return { type: \"keyboard\", offsetX, offsetY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaFocusManager.ts\nvar SeriesAreaFocusManager = class extends BaseManager {\n  constructor(id, chart, ctx, chartType2, overlays) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.chartType = chartType2;\n    this.overlays = overlays;\n    this.series = [];\n    this.focus = {\n      hasFocus: false,\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.onAnimationStart()),\n      seriesRegion.addListener(\"blur\", () => this.onBlur()),\n      seriesRegion.addListener(\"tab\", (event) => this.onTab(event)),\n      seriesRegion.addListener(\"nav-vert\", (event) => this.onNavVert(event)),\n      seriesRegion.addListener(\"nav-hori\", (event) => this.onNavHori(event)),\n      seriesRegion.addListener(\"submit\", (event) => this.onSubmit(event)),\n      this.ctx.keyNavManager.addListener(\"browserfocus\", (event) => this.onBrowserFocus(event)),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.ctx.focusIndicator.updateBounds(void 0);\n      })\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n    this.onBlur();\n  }\n  dataChanged() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n  }\n  preSceneRender() {\n    this.refreshFocus();\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.rect;\n  }\n  refreshFocus() {\n    if (this.focus.hasFocus) {\n      this.handleSeriesFocus(0, 0);\n    }\n  }\n  onTab(event) {\n    this.handleFocus(0, 0);\n    event.preventDefault();\n    this.focus.hasFocus = true;\n  }\n  onNavVert(event) {\n    this.focus.seriesIndex += event.delta;\n    this.handleFocus(event.delta, 0);\n    event.preventDefault();\n  }\n  onNavHori(event) {\n    this.focus.datumIndex += event.delta;\n    this.handleFocus(0, event.delta);\n    event.preventDefault();\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = 0;\n      this.focus.seriesIndex = 0;\n    } else if (event.delta < 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = Infinity;\n      this.focus.seriesIndex = Infinity;\n    }\n  }\n  onAnimationStart() {\n    if (this.focus.hasFocus) {\n      this.onBlur();\n    }\n  }\n  onBlur() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n    this.focus.hasFocus = false;\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    this.focus.hasFocus = true;\n    const overlayFocus = this.overlays.getFocusInfo(this.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.ctx.focusIndicator.updateBounds(overlayFocus.rect);\n      this.ctx.ariaAnnouncementService.announceValue(overlayFocus.text);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    if (this.chartType === \"hierarchy\") {\n      this.handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta);\n      return;\n    }\n    const { focus, seriesRect, series } = this;\n    const visibleSeries = series.filter((s) => s.visible);\n    if (visibleSeries.length === 0)\n      return;\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta) {\n    this.focus.series = this.series[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series === void 0)\n      return;\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  updatePickedFocus(pick) {\n    const { focus } = this;\n    if (pick === void 0 || focus.series === void 0)\n      return;\n    const { datum, datumIndex } = pick;\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    const keyboardEvent = makeKeyboardPointerEvent(this.ctx.focusIndicator, pick);\n    if (keyboardEvent !== void 0) {\n      const html = focus.series.getTooltipHtml(datum);\n      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, datum);\n      const aria = this.getDatumAriaText(datum, html);\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n      this.ctx.ariaAnnouncementService.announceValue(\"ariaAnnounceHoverDatum\", { datum: aria });\n    }\n  }\n  onSubmit(event) {\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.chart.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    event.preventDefault();\n  }\n  getDatumAriaText(datum, html) {\n    const description = html.ariaLabel;\n    return datum.series.getDatumAriaText?.(datum, description) ?? description;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaHighlightManager.ts\nvar SeriesAreaHighlightManager = class extends BaseManager {\n  constructor(id, chart, ctx, highlight) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.highlight = highlight;\n    this.series = [];\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.pendingHoverEvent)\n        return;\n      if (this.chart.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      this.handleHover(false);\n    });\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const mouseMoveStates = 16 /* Default */ | 4 /* Annotations */;\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      this.ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      seriesRegion.addListener(\"drag\", (event) => this.onHover(event), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      // Cases where highlight should be cleared.\n      this.ctx.domManager.addListener(\"resize\", () => this.clearHighlight()),\n      seriesRegion.addListener(\"leave\", () => this.clearHighlight(), mouseMoveStates),\n      seriesRegion.addListener(\"blur\", () => this.clearHighlight()),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.clearHighlight()),\n      this.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearHighlight()),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearHighlight())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.stashedHoverEvent ?? (this.stashedHoverEvent = this.appliedHoverEvent);\n    this.clearHighlight();\n  }\n  preSceneRender() {\n    if (this.stashedHoverEvent != null) {\n      this.pendingHoverEvent = this.stashedHoverEvent;\n      this.stashedHoverEvent = void 0;\n      this.handleHover(true);\n    }\n  }\n  update(type, opts) {\n    this.ctx.updateService.update(type, opts);\n  }\n  layoutComplete(event) {\n    this.hoverRect = event.series.paddedRect;\n  }\n  clearHighlight() {\n    this.pendingHoverEvent = void 0;\n    this.appliedHoverEvent = void 0;\n    this.ctx.highlightManager.updateHighlight(this.id);\n  }\n  onHover(event) {\n    this.pendingHoverEvent = event;\n    this.hoverScheduler.schedule();\n  }\n  handleHover(redisplay) {\n    this.appliedHoverEvent = this.pendingHoverEvent;\n    this.pendingHoverEvent = void 0;\n    const event = this.appliedHoverEvent;\n    if (!event)\n      return;\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */)\n      return;\n    const { offsetX, offsetY } = event;\n    if (redisplay ? this.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearHighlight();\n      return;\n    }\n    const { range: range3 } = this.highlight;\n    const intent = range3 === \"tooltip\" ? \"highlight-tooltip\" : \"highlight\";\n    const found = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, intent);\n    if (found) {\n      this.ctx.highlightManager.updateHighlight(this.id, found.datum);\n      return;\n    }\n    this.ctx.highlightManager.updateHighlight(this.id);\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.ctx.cursorManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== \"default\" && newDatum) {\n      this.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaTooltipManager.ts\nvar SeriesAreaTooltipManager = class extends BaseManager {\n  constructor(id, chart, ctx, tooltip) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.tooltip = tooltip;\n    this.series = [];\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.lastHover)\n        return;\n      if (this.chart.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      this.handleHover(this.lastHover, false);\n    });\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      seriesRegion.addListener(\n        \"hover\",\n        (event) => this.onHover(event),\n        16 /* Default */ | 4 /* Annotations */\n      ),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      // Events that clear tooltip.\n      seriesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      seriesRegion.addListener(\"blur\", () => this.clearTooltip()),\n      seriesRegion.addListener(\"contextmenu\", () => this.clearTooltip(), 31 /* All */),\n      horizontalAxesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      verticalAxesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.clearTooltip()),\n      this.ctx.domManager.addListener(\"resize\", () => this.clearTooltip()),\n      this.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearTooltip()),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearTooltip())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n  }\n  preSceneRender() {\n    if (this.lastHover != null) {\n      this.handleHover(this.lastHover, true);\n    }\n  }\n  layoutComplete(event) {\n    this.hoverRect = event.series.paddedRect;\n  }\n  onHover(event) {\n    this.lastHover = event;\n    this.hoverScheduler.schedule();\n  }\n  clearTooltip() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.lastHover = void 0;\n  }\n  handleHover(event, redisplay) {\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */)\n      return;\n    const { offsetX, offsetY, targetElement } = event;\n    if (redisplay ? this.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearTooltip();\n      return;\n    }\n    if (targetElement && this.tooltip.interactive && this.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    const pick = pickNode(this.series, { x: offsetX, y: offsetY }, \"tooltip\");\n    if (!pick) {\n      this.clearTooltip();\n      return;\n    }\n    const html = pick.series.getTooltipHtml(pick.datum);\n    const tooltipEnabled = this.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && html != null;\n    if (shouldUpdateTooltip) {\n      const meta = TooltipManager.makeTooltipMeta(event, pick.datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts\nvar SeriesAreaManager = class extends BaseManager {\n  constructor(chart, ctx, chartType2, tooltip, highlight, overlays) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.series = [];\n    this.subManagers = [\n      new SeriesAreaFocusManager(this.id, chart, ctx, chartType2, overlays),\n      new SeriesAreaHighlightManager(this.id, chart, ctx, highlight),\n      new SeriesAreaTooltipManager(this.id, chart, ctx, tooltip),\n      new SeriesAreaClickManager(this.id, chart, ctx)\n    ];\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    this.destroyFns.push(\n      () => this.subManagers.forEach((s) => s.destroy()),\n      seriesRegion.addListener(\"contextmenu\", (event) => this.onContextMenu(event), 31 /* All */),\n      this.ctx.updateService.addListener(\"pre-scene-render\", () => this.preSceneRender())\n    );\n  }\n  dataChanged() {\n    for (const manager of this.subManagers) {\n      manager.dataChanged?.();\n    }\n  }\n  preSceneRender() {\n    for (const manager of this.subManagers) {\n      manager.preSceneRender?.();\n    }\n  }\n  seriesChanged(series) {\n    this.series = series;\n    for (const manager of this.subManagers) {\n      manager.seriesChanged(series);\n    }\n  }\n  onContextMenu(event) {\n    const { Default: Default2, ContextMenu } = InteractionState;\n    let pickedNode;\n    if (this.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {\n      const match = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, \"context-menu\");\n      if (match) {\n        this.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = match.datum;\n      }\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"series\", event, { pickedNode });\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot, highlightRoot, annotationRoot) {\n    this.seriesRoot = seriesRoot;\n    this.highlightRoot = highlightRoot;\n    this.annotationRoot = annotationRoot;\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      internalId,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.series[internalId] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);\n    }\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    const lookupIndex = this.lookupIdx(groupIndex);\n    let groupInfo = this.groups[type][lookupIndex];\n    if (!groupInfo) {\n      groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {\n        type,\n        id: lookupIndex,\n        seriesIds: [],\n        group: this.seriesRoot.appendChild(\n          new Group({\n            name: `${type}-content`,\n            layer: true,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"data\")\n          })\n        ),\n        highlight: this.highlightRoot.appendChild(\n          new Group({\n            name: `${type}-highlight`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"highlight\")\n          })\n        ),\n        annotation: this.annotationRoot.appendChild(\n          new Group({\n            name: `${type}-annotation`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"annotation\")\n          })\n        )\n      });\n    }\n    this.series[internalId] = { layerState: groupInfo, seriesConfig };\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series[internalId] != null) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\n    if (this.series[internalId] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series[internalId]?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.highlightRoot.removeChild(groupInfo.highlight);\n      this.annotationRoot.removeChild(groupInfo.annotation);\n      delete this.groups[groupInfo.type][groupInfo.id];\n      delete this.groups[type][internalId];\n    } else if (groupInfo?.seriesIds.length > 0) {\n      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"data\");\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"highlight\");\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"annotation\");\n    }\n    delete this.series[internalId];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.seriesRoot.removeChild(groupInfo.group);\n        this.highlightRoot.removeChild(groupInfo.highlight);\n        this.annotationRoot.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts\nvar BaseLayoutProcessor = class {\n  constructor(chartLike, layoutService) {\n    this.chartLike = chartLike;\n    this.layoutService = layoutService;\n    this.destroyFns = [];\n    this.destroyFns.push(\n      // eslint-disable-next-line sonarjs/no-duplicate-string\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionPadding(e)),\n      this.layoutService.addListener(\"layout-complete\", (e) => this.alignCaptions(e)),\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionCaptions(e))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  positionPadding(ctx) {\n    const { shrinkRect } = ctx;\n    const { padding } = this.chartLike;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    return { ...ctx, shrinkRect };\n  }\n  positionCaptions(ctx) {\n    const { shrinkRect, positions, padding } = ctx;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    const paddedShrinkRect = shrinkRect.clone().shrink(titlePadding);\n    const newShrinkRect = shrinkRect.clone();\n    const updateCaption = (caption) => {\n      const defaultCaptionHeight = shrinkRect.height / 10;\n      const captionLineHeight = caption.lineHeight ?? caption.fontSize * Text.defaultLineHeightRatio;\n      const maxWidth = shrinkRect.width;\n      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\n      caption.computeTextWrap(maxWidth, maxHeight);\n    };\n    const computeX = (align) => {\n      if (align === \"left\") {\n        return paddedShrinkRect.x;\n      } else if (align === \"right\") {\n        return paddedShrinkRect.x + paddedShrinkRect.width;\n      } else if (align !== \"center\") {\n        Logger.error(`invalid textAlign value: ${align}`);\n      }\n      return paddedShrinkRect.x + paddedShrinkRect.width / 2;\n    };\n    const positionTopAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"top\";\n      updateCaption(caption);\n      const bbox = caption.node.getBBox();\n      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"top\");\n        paddedShrinkRect.shrink(bboxHeight, \"top\");\n      }\n      return bbox;\n    };\n    const positionBottomAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y + paddedShrinkRect.height;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"bottom\";\n      updateCaption(caption);\n      const bbox = caption.node.getBBox();\n      const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"bottom\");\n        paddedShrinkRect.shrink(bboxHeight, \"bottom\");\n      }\n      return bbox;\n    };\n    title.node.visible = title.enabled;\n    subtitle.node.visible = subtitle.enabled;\n    footnote.node.visible = footnote.enabled;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      positions.title = positionTopAndShrinkBBox(title, spacing);\n    }\n    if (subtitle.enabled) {\n      positions.subtitle = positionTopAndShrinkBBox(subtitle, subtitle.spacing ?? 0);\n    }\n    if (footnote.enabled) {\n      positions.footnote = positionBottomAndShrinkBBox(footnote, footnote.spacing ?? 0);\n    }\n    padding.title = titlePadding;\n    return { ...ctx, shrinkRect: newShrinkRect, positions };\n  }\n  alignCaptions(ctx) {\n    const { rect } = ctx.series;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    for (const caption of [title, subtitle, footnote]) {\n      if (caption.layoutStyle !== \"overlay\")\n        continue;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = rect.x + titlePadding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.getBBox();\n        caption.node.x = rect.x + rect.width - bbox.width - titlePadding;\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow().catch((e) => Logger.errorOnce(e));\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  async updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom2 = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom2);\n      shouldRefresh = this.shouldRefresh(axis, zoom2);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom2) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom2);\n    return true;\n  }\n  getAxisWindow(axis, zoom2) {\n    const domain = axis.scale.getDomain?.();\n    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutService, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutService = layoutService;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.destroyFns.push(this.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    this.toggleOverlay(this.overlays.loading, rect, isLoading);\n    this.toggleOverlay(this.overlays.noData, rect, !isLoading && !hasData);\n    this.toggleOverlay(this.overlays.noVisibleSeries, rect, hasData && !anySeriesVisible);\n  }\n  toggleOverlay(overlay, seriesRect, visible) {\n    this.overlayElem.ariaHidden = (!visible).toString();\n    if (visible) {\n      const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n      this.overlayElem.appendChild(element2);\n    } else {\n      overlay.removeElement(() => {\n        this.overlayElem.innerText = \"\\xA0\";\n      }, this.animationManager);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new Group({ name: `${this.id}-series-root` });\n    this.highlightRoot = new Group({\n      name: `${this.id}-highlight-root`,\n      layer: true,\n      zIndex: 5 /* SERIES_HIGHLIGHT_ZINDEX */,\n      nonEmptyChildDerivedZIndex: true\n    });\n    this.annotationRoot = new Group({\n      name: `${this.id}-annotation-root`,\n      layer: true,\n      zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.titlePadding = 0;\n    this.seriesArea = new SeriesArea();\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n    this.keyboard = new Keyboard();\n    this.mode = \"standalone\";\n    this.destroyed = false;\n    this._skipSync = false;\n    this._destroyFns = [];\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    // FIXME: zoomManager should be owned by ctx, but it can't because it is used by CartesianChart.onAxisChange before ctx is initialised\n    this.zoomManager = new ZoomManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this.performUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error) {\n          Logger.error(\"update error\", error);\n        }\n      }).catch((e) => Logger.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this.onSeriesNodeClick = (event) => {\n      const seriesNodeClickEvent = {\n        ...event,\n        type: \"seriesNodeClick\"\n      };\n      Object.defineProperty(seriesNodeClickEvent, \"series\", {\n        enumerable: false,\n        // Should display the deprecation warning\n        get: () => event.series\n      });\n      this.fireEvent(seriesNodeClickEvent);\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      const seriesNodeDoubleClick = {\n        ...event,\n        type: \"seriesNodeDoubleClick\"\n      };\n      this.fireEvent(seriesNodeDoubleClick);\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.rootGroup.parent == null)\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        rootGroup: series.rootGroup,\n        highlightGroup: series.highlightGroup,\n        annotationGroup: series.annotationGroup,\n        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.dataProcessListeners = /* @__PURE__ */ new Set();\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container;\n    const root = new Group({ name: \"root\" });\n    const titleGroup = new Group({ name: \"titles\", layer: true, zIndex: 8 /* SERIES_LABEL_ZINDEX */ });\n    root.visible = false;\n    root.append(titleGroup);\n    root.append(this.seriesRoot);\n    root.append(this.highlightRoot);\n    root.append(this.annotationRoot);\n    titleGroup.append(this.title.node);\n    titleGroup.append(this.subtitle.node);\n    titleGroup.append(this.footnote.node);\n    const { overrideDevicePixelRatio } = options.specialOverrides;\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);\n    const ctx = this.ctx = new ChartContext(this, {\n      scene,\n      root,\n      syncManager: new SyncManager(this),\n      container,\n      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex,\n      overrideDevicePixelRatio\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new BaseLayoutProcessor(this, ctx.layoutService),\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutService,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const moduleContext = this.getModuleContext();\n    ctx.regionManager.addRegion(\"series\" /* SERIES */, this.seriesRoot, this.ctx.axisManager.axisGridGroup);\n    ctx.regionManager.addRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    ctx.regionManager.addRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const thisChart = this;\n    this.seriesAreaManager = new SeriesAreaManager(\n      {\n        fireEvent: this.fireEvent.bind(thisChart),\n        get performUpdateType() {\n          return thisChart.performUpdateType;\n        }\n      },\n      ctx,\n      this.getChartType(),\n      this.tooltip,\n      this.highlight,\n      this.overlays\n    );\n    ctx.regionManager.addRegion(\"root\", root);\n    this._destroyFns.push(\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext),\n      this.subtitle.registerInteraction(moduleContext),\n      this.footnote.registerInteraction(moduleContext),\n      ctx.interactionManager.addListener(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.series.map((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", { seriesCount: this.series.length });\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.zoomManager.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      await cb(this);\n      if (this.destroyed)\n        return;\n      this._pendingFactoryUpdatesCount--;\n    }).catch((e) => Logger.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this._skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    let updateDeferred = false;\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        await this.processData();\n        this.seriesAreaManager.dataChanged();\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        if (!this.checkFirstAutoSize(seriesToUpdate)) {\n          updateDeferred = true;\n          break;\n        }\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */:\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        const { seriesRect } = this;\n        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n        updateSplits(\"\\u{1F914}\");\n      case 5 /* PRE_SCENE_RENDER */:\n        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))\n          break;\n        ctx.updateService.dispatchPreSceneRender(this.getMinRects());\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });\n        this.extraDebugStats = {};\n        for (const key in splits) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!updateDeferred) {\n      ctx.updateService.dispatchUpdateComplete(this.getMinRects());\n    }\n    const end = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const { theme } = this.chartOptions.processedOptions;\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    } else if (typeof theme?.baseTheme === \"string\") {\n      themeClassName = theme.baseTheme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.baseTheme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);\n    setAttribute(this.ctx.scene.canvas.element, \"role\", \"img\");\n    setAttribute(this.ctx.scene.canvas.element, \"aria-label\", this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count + 1) ** 2 * 40;\n      if (count < 8) {\n        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });\n        this.debug(\"Chart.checkFirstAutoSize() - backing off until first size update\", backOffMs);\n        return false;\n      }\n      this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.parent == null) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels() {\n          return chart.placeLabels();\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n    this.seriesAreaManager?.seriesChanged(newValue);\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  updateAllSeriesListeners() {\n    this.series.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      this.addSeriesListeners(series);\n    });\n  }\n  assignSeriesToAxes() {\n    this.axes.forEach((axis) => {\n      axis.boundSeries = this.series.filter((s) => {\n        const seriesAxis = s.axes[axis.direction];\n        return seriesAxis === axis;\n      });\n    });\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          Logger.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width, height } = size;\n    width = Math.floor(width);\n    height = Math.floor(height);\n    if (width === 0 && height === 0)\n      return;\n    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];\n    if (autoWidth === width && authHeight === height)\n      return;\n    this._lastAutoSize = [width, height];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });\n    if (width == null || height == null || !isFiniteNumber(width) || !isFiniteNumber(height))\n      return;\n    if (scene.resize(width, height)) {\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.({ data: this.data }));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      const syncModule = this.modulesManager.getModule(\"sync\");\n      if (syncModule?.enabled) {\n        syncModule.syncAxes(this._skipSync);\n      } else {\n        this.assignSeriesToAxes();\n      }\n    }\n    const dataController = new DataController(this.mode);\n    const seriesPromises = this.series.map((s) => s.processData(dataController));\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.({ dataController }));\n    dataController.execute();\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const { legendType, legend } of this.modulesManager.legends()) {\n      legend.data = this.getLegendData(legendType, this.mode !== \"integrated\");\n    }\n    this.dataProcessListeners.forEach((resolve) => resolve());\n    this.dataProcessListeners.clear();\n  }\n  placeLabels() {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible)\n        continue;\n      const labelData = series.getLabelData();\n      if (isPointLabelDatum(labelData?.[0])) {\n        data.push(labelData);\n        visibleSeries.push(series);\n      }\n    }\n    const { seriesRect } = this;\n    const { top, right, bottom, left } = this.seriesArea.padding;\n    const labels = seriesRect && data.length > 0 ? placeLabels(data, {\n      x: -left,\n      y: -top,\n      width: seriesRect.width + left + right,\n      height: seriesRect.height + top + bottom\n    }) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  getLegendData(legendType, warnConflicts) {\n    var _a;\n    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n    const isCategoryLegendData = (data) => data.every((d) => d.legendType === \"category\");\n    if (warnConflicts && isCategoryLegendData(legendData)) {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbols: [{ marker }],\n        label\n      } of legendData) {\n        if (marker.fill == null)\n          continue;\n        const seriesType2 = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType2] ?? (seriesMarkerFills[seriesType2] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          Logger.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    return legendData;\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    await this.performLayout();\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async performLayout() {\n    const { width, height } = this.ctx.scene;\n    let ctx = { shrinkRect: new BBox(0, 0, width, height), positions: {}, padding: {} };\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"start-layout\", ctx);\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"before-series\", ctx);\n    for (const m of this.modulesManager.modules()) {\n      if (m.performLayout != null) {\n        ctx = await m.performLayout(ctx);\n      }\n    }\n    return ctx.shrinkRect;\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start = performance.now();\n    if (this._pendingFactoryUpdatesCount > 0) {\n      await this.updateMutex.waitForClearAcquireQueue();\n    }\n    while (this.performUpdateType !== 7 /* NONE */) {\n      if (performance.now() - start > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          Logger.warnOnce(message);\n        }\n      }\n      await sleep(50);\n    }\n    await this.updateMutex.waitForClearAcquireQueue();\n  }\n  waitForDataProcess(timeout) {\n    return new Promise((resolve) => {\n      this.dataProcessListeners.add(resolve);\n      if (isNumber(timeout)) {\n        setTimeout(() => {\n          if (this.dataProcessListeners.has(resolve)) {\n            this.dataProcessListeners.delete(resolve);\n            resolve();\n          }\n        }, timeout);\n      }\n    });\n  }\n  getMinRects() {\n    const { width, height } = this.ctx.scene;\n    const minRects = this.series.map((series) => series.getMinRects(width, height)).filter(isDefined);\n    if (minRects.length === 0)\n      return;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {\n      maxWidth = Math.max(maxWidth, minRect2.width);\n      maxHeight = Math.max(maxHeight, minRect2.height);\n      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);\n      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    let minVisibleRect = minRect.clone();\n    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {\n      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    }\n    return { minRect, minVisibleRect };\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const isDifferentOpts = newChartOptions !== this.chartOptions;\n    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};\n    const newOpts = newChartOptions.processedOptions;\n    const deltaOptions = newChartOptions.diffOptions(oldOpts);\n    if (deltaOptions == null)\n      return;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"locale.localeText\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series != null) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.listeners) {\n      this.updateAllSeriesListeners();\n    }\n    if (deltaOptions.locale?.localeText) {\n      this.modulesManager.getModule(\"locale\").localeText = deltaOptions.locale?.localeText;\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n    if (deltaOptions.initialState) {\n      this.applyInitialState(newChartOptions.userOptions.initialState);\n    }\n  }\n  applyInitialState(initialState) {\n    const {\n      ctx: { annotationManager, stateManager }\n    } = this;\n    if (initialState?.annotations != null) {\n      const annotations2 = initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations2);\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType2 } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType2);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      chart.series = optSeries.map((opts) => this.createSeries(opts));\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    for (const change of matchResult.changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\":\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default:\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n      }\n    }\n    for (let idx = 0; idx < seriesInstances.length; idx++) {\n      seriesInstances[idx]._declarationOrder = idx;\n    }\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    const axisGroups = {\n      [\"x\" /* X */]: [],\n      [\"y\" /* Y */]: []\n    };\n    chart.axes.forEach((axis) => axisGroups[axis.direction].push(axis.getRegionBBoxProvider()));\n    if (registerRegions) {\n      this.ctx.regionManager.updateRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */, ...axisGroups[\"x\" /* X */]);\n      this.ctx.regionManager.updateRegion(\"vertical-axes\" /* VERTICAL_AXES */, ...axisGroups[\"y\" /* Y */]);\n    }\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], _Chart.prototype, \"titlePadding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width, height } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar Marker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  computeBBox() {\n    const { x, y, size } = this;\n    const { center } = this.constructor;\n    return new BBox(x - size * center.x, y - size * center.y, size, size);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  applyPath(s, moves) {\n    const { path } = this;\n    let { x, y } = this;\n    if (this.repeat != null) {\n      x = 0;\n      y = 0;\n    }\n    path.clear();\n    for (const { x: mx, y: my, t } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === \"move\") {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeFill(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.fill(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeStroke(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.stroke(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n};\nMarker.center = { x: 0.5, y: 0.5 };\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], Marker.prototype, \"size\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"repeat\", 2);\n\n// packages/ag-charts-community/src/chart/marker/circle.ts\nvar Circle = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n};\nCircle.className = \"Circle\";\n\n// packages/ag-charts-community/src/chart/marker/cross.ts\nvar _Cross = class _Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, _Cross.moves);\n  }\n};\n_Cross.className = \"Cross\";\n_Cross.moves = [\n  { x: -1, y: 0, t: \"move\" },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 }\n];\nvar Cross = _Cross;\n\n// packages/ag-charts-community/src/chart/marker/diamond.ts\nvar _Diamond = class _Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _Diamond.moves);\n  }\n};\n_Diamond.className = \"Diamond\";\n_Diamond.moves = [\n  { x: 0, y: -1, t: \"move\" },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 }\n];\nvar Diamond = _Diamond;\n\n// packages/ag-charts-community/src/chart/marker/heart.ts\nvar Heart = class extends Marker {\n  rad(degree2) {\n    return degree2 / 180 * Math.PI;\n  }\n  updatePath() {\n    const { x, path, size, rad } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n};\nHeart.className = \"Heart\";\n\n// packages/ag-charts-community/src/chart/marker/pin.ts\nvar Pin = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const s = this.size;\n    const cx = 0.5;\n    const cy = 1;\n    path.clear();\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  }\n};\nPin.className = \"MapPin\";\nPin.center = { x: 0.5, y: 1 };\n\n// packages/ag-charts-community/src/chart/marker/plus.ts\nvar _Plus = class _Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, _Plus.moves);\n  }\n};\n_Plus.className = \"Plus\";\n_Plus.moves = [\n  { x: -0.5, y: -0.5, t: \"move\" },\n  { x: 0, y: -1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 }\n];\nvar Plus = _Plus;\n\n// packages/ag-charts-community/src/chart/marker/square.ts\nvar Square = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n};\nSquare.className = \"Square\";\n\n// packages/ag-charts-community/src/chart/marker/star.ts\nvar Star = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const spikes = 5;\n    const innerRadius = size / 2;\n    const rotation = Math.PI / 2;\n    path.clear();\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? size : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  }\n};\nStar.className = \"Star\";\n\n// packages/ag-charts-community/src/chart/marker/triangle.ts\nvar _Triangle = class _Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, _Triangle.moves);\n  }\n};\n_Triangle.className = \"Triangle\";\n_Triangle.moves = [\n  { x: 0, y: -0.48, t: \"move\" },\n  { x: 0.5, y: 0.87 },\n  { x: -1, y: 0 }\n];\nvar Triangle = _Triangle;\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  pin: Pin,\n  plus: Plus,\n  square: Square,\n  star: Star,\n  triangle: Triangle\n};\nvar MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.includes(shape);\n}\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === \"function\") {\n    return shape;\n  }\n  return Square;\n}\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.showFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return void 0;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return void 0;\n    }\n    const { showFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, showFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];\n      return !missing && enabled && focusable;\n    };\n    const searchBackward = (datumIndex2) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2--;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2++;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex);\n    } else {\n      datumIndex ?? (datumIndex = searchForward(clampedIndex));\n      datumIndex ?? (datumIndex = searchBackward(clampedIndex));\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return void 0;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], HighlightProperties.prototype, \"enabled\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlight = new HighlightProperties();\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.pickOutsideVisibleMinorAxis = false;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianSeriesProperties.prototype, \"pickOutsideVisibleMinorAxis\", 2);\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = [\"path\"],\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-dataNodes`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-markers`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"labels\")\n      })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.minRectsCache = {\n      dirtyNodeData: true\n    };\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = [];\n    for (let index = 0; index < pathsPerSeries.length; index++) {\n      this.paths[index] = new Path({ name: `${this.id}-${pathsPerSeries[index]}` });\n      this.paths[index].zIndex = 4 /* SERIES_LAYER_ZINDEX */;\n      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder(\"paths\", index);\n      this.contentGroup.appendChild(this.paths[index]);\n    }\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      markerSelectionGarbageCollection\n    );\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  async update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);\n    await this.updateSelections(visible);\n    await this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  async updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = await this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      this.minRectsCache.dirtyNodeData = true;\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    await this.updateSeriesSelections();\n  }\n  async updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    if (this.opts.hasMarkers) {\n      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === \"paths\") {\n      const [superFn] = result;\n      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;\n      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;\n    }\n    return result;\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.rootGroup.visible = animationEnabled || visible;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      await this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      await this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER_ZINDEX */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    await this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    await this.updateLabelNodes({ labelSelection });\n    if (hasMarkers) {\n      await this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  async updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = await this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width, height } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width, height);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = rootGroup.transformPoint(x, y);\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance3 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    const { pickOutsideVisibleMinorAxis } = this.properties;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter((a) => a instanceof CategoryAxis).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0) {\n      return;\n    }\n    const [majorDirection = \"x\" /* X */] = directions2;\n    const hitPoint = rootGroup.transformPoint(x, y);\n    const hitPointCoords = [hitPoint.x, hitPoint.y];\n    if (majorDirection !== \"x\" /* X */)\n      hitPointCoords.reverse();\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true) {\n        continue;\n      }\n      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];\n      if (majorDirection !== \"x\" /* X */)\n        visible.reverse();\n      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1]) {\n        continue;\n      }\n      const datumPoint = [datumX, datumY];\n      if (majorDirection !== \"x\" /* X */)\n        datumPoint.reverse();\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        }\n        if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\n   * between any two adjacent nodes.\n   */\n  getMinRects(width, height) {\n    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;\n    const newSizeCache = JSON.stringify({ width, height });\n    const dirtySize = newSizeCache !== sizeCache;\n    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {\n      return { minRect, minVisibleRect };\n    }\n    const rects = this.computeMinRects(width, height);\n    this.minRectsCache = {\n      dirtyNodeData: false,\n      sizeCache: newSizeCache,\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    };\n    return rects;\n  }\n  computeMinRects(width, height) {\n    const context = this._contextNodeData;\n    if (!context?.nodeData.length) {\n      return;\n    }\n    const { nodeData } = context;\n    const minRectXs = Array(nodeData.length);\n    const minRectYs = Array(nodeData.length);\n    for (const [i, { midPoint }] of nodeData.entries()) {\n      minRectXs[i] = midPoint?.x ?? 0;\n      minRectYs[i] = midPoint?.y ?? 0;\n    }\n    minRectXs.sort((a, b) => a - b);\n    minRectYs.sort((a, b) => a - b);\n    let zeroX, widthX, zeroY, heightY;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let i = 1; i < nodeData.length; i++) {\n      if (minRectXs[i] >= 0)\n        zeroX ?? (zeroX = i);\n      if (minRectXs[i] > width)\n        widthX ?? (widthX = i);\n      if (minRectYs[i] >= 0)\n        zeroY ?? (zeroY = i);\n      if (minRectYs[i] > height)\n        heightY ?? (heightY = i);\n      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);\n      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);\n    }\n    widthX ?? (widthX = nodeData.length);\n    heightY ?? (heightY = nodeData.length);\n    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];\n    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {\n      const x1 = minVisibleRectXs[i];\n      const x2 = minVisibleRectXs[i - 1];\n      const y1 = minVisibleRectYs[i];\n      const y2 = minVisibleRectYs[i - 1];\n      if (x1 != null && x2 != null) {\n        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);\n      }\n      if (y1 != null && y2 != null) {\n        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);\n      }\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    return { minRect, minVisibleRect };\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  async updateDatumNodes(_opts) {\n  }\n  async updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  async updateMarkerNodes(_opts) {\n  }\n  async updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  async updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetPathAnimation(data) {\n    const { path } = this.opts?.animationResetFns ?? {};\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n  }\n  resetDatumAnimation(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n  }\n  resetLabelAnimation(data) {\n    const { label } = this.opts?.animationResetFns ?? {};\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n  }\n  resetMarkerAnimation(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n  }\n  resetAllAnimation(data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.resetPathAnimation(data);\n    this.resetDatumAnimation(data);\n    this.resetLabelAnimation(data);\n    this.resetMarkerAnimation(data);\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    const animationData = this.getAnimationData();\n    if (!animationData)\n      return;\n    this.animationState.transition(\"clear\", animationData);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      if (axis.scale instanceof LogScale) {\n        const { range: range3, domain } = axis.scale;\n        result[direction] = {\n          type: \"log\",\n          convert: (d) => axis.scale.convert(d),\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const { range: range3 } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: \"continuous\",\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale) {\n        const { domain } = axis.scale;\n        result[direction] = {\n          type: \"category\",\n          domain,\n          range: domain.map((d) => axis.scale.convert(d))\n        };\n      }\n    }\n    return result;\n  }\n};\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar CartesianChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.firstSeriesTranslation = true;\n    this._lastCrossLineIds = void 0;\n    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();\n    this._lastClipSeries = false;\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    this.zoomManager.updateAxes(newValue);\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.firstSeriesTranslation = true;\n  }\n  getChartType() {\n    return \"cartesian\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;\n    const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);\n    this.seriesRoot.visible = visibility.series;\n    this.seriesRect = seriesRect;\n    this.animationRect = animationRect;\n    const { x, y } = seriesRect;\n    if (firstSeriesTranslation) {\n      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n      this.firstSeriesTranslation = false;\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, highlightRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    seriesRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    highlightRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    annotationRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries,\n      series: {\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect,\n        visible: visibility.series,\n        shouldFlipXY: this.shouldFlipXY()\n      },\n      axes: this.axes.map((axis) => axis.getLayoutState())\n    });\n    const modulePromises = this.modulesManager.mapModules((m) => m.performCartesianLayout?.({ seriesRect }));\n    await Promise.all(modulePromises);\n    return shrinkRect;\n  }\n  updateAxes(inputShrinkRect) {\n    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);\n    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);\n    let axisAreaWidths;\n    let clipSeries;\n    let visibility;\n    if (axesValid) {\n      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());\n      clipSeries = this._lastClipSeries;\n      visibility = { ...this._lastVisibility };\n    } else {\n      axisAreaWidths = /* @__PURE__ */ new Map();\n      clipSeries = false;\n      visibility = { crossLines: true, series: true };\n      this._lastCrossLineIds = crossLineIds;\n    }\n    const liveAxisWidths = new Set(this.axes.map((a) => a.position));\n    for (const position of axisAreaWidths.keys()) {\n      if (!liveAxisWidths.has(position)) {\n        axisAreaWidths.delete(position);\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {\n      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {\n        return false;\n      }\n      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {\n        return false;\n      }\n      return [...axisAreaWidths.entries()].every(([p, w]) => {\n        const otherW = otherAxisWidths.get(p);\n        if (w != null || otherW != null) {\n          return w === otherW;\n        }\n        return true;\n      });\n    };\n    const ceilValues = (map) => {\n      for (const [key, value] of map.entries()) {\n        if (value && Math.abs(value) === Infinity) {\n          map.set(key, 0);\n          continue;\n        }\n        map.set(key, value != null ? Math.ceil(value) : value);\n      }\n      return map;\n    };\n    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();\n    let lastPassVisibility = {};\n    let lastPassClipSeries = false;\n    let seriesRect = this.seriesRect?.clone();\n    let count = 0;\n    let primaryTickCounts = {};\n    do {\n      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());\n      clipSeries = lastPassClipSeries;\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisAreaWidths, inputShrinkRect.clone(), seriesRect);\n      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);\n      lastPassVisibility = result.visibility;\n      lastPassClipSeries = result.clipSeries;\n      ({ seriesRect, primaryTickCounts } = result);\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable axis layout.\");\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));\n    this.axes.forEach((axis) => {\n      axis.update(primaryTickCounts[axis.direction]);\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach((axis) => {\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(\n        seriesRect.x,\n        seriesRect.y,\n        seriesRect.width + clipRectPadding,\n        seriesRect.height + clipRectPadding\n      );\n      switch (axis.position) {\n        case \"left\":\n        case \"right\":\n          axis.clipTickLines(\n            inputShrinkRect.x,\n            seriesRect.y,\n            inputShrinkRect.width + clipRectPadding,\n            seriesRect.height + clipRectPadding\n          );\n          break;\n        case \"top\":\n        case \"bottom\":\n          axis.clipTickLines(\n            seriesRect.x,\n            inputShrinkRect.y,\n            seriesRect.width + clipRectPadding,\n            inputShrinkRect.height + clipRectPadding\n          );\n          break;\n      }\n    });\n    this._lastAxisAreaWidths = axisAreaWidths;\n    this._lastVisibility = visibility;\n    this._lastClipSeries = clipSeries;\n    return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };\n  }\n  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const axisGroups = /* @__PURE__ */ new Map();\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};\n    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);\n    for (const axis of this.axes) {\n      const { position = \"left\" } = axis;\n      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        paddedBounds,\n        primaryTickCounts,\n        clipSeries\n      });\n      axisWidths.set(axis.id, axisThickness);\n      if (!axisGroups.has(position))\n        axisGroups.set(position, []);\n      axisGroups.get(position)?.push(axis);\n      clipSeries = clipSeries || newClipSeries;\n    }\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups.entries()) {\n      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets));\n    }\n    for (const [position, axes] of axisGroups.entries()) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility, primaryTickCounts };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = {};\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    const reversedAxes = this.axes.slice().reverse();\n    directions.forEach((dir) => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = reversedAxes.find((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {\n    const result = bounds.clone();\n    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0) + horizontalPadding;\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisAreaWidths) {\n    const result = axisBound.clone();\n    result.x += axisAreaWidths.get(\"left\") ?? 0;\n    result.y += axisAreaWidths.get(\"top\") ?? 0;\n    result.width -= (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    result.height -= (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const { x, y, width, height } = seriesRect;\n    const clampBounds = [x, y, x + width, y + height];\n    const compareTo = clampBounds[(dimension === \"x\" ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    const clampFn = direction === 1 ? Math.min : Math.max;\n    return clampFn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    const { axis, seriesRect, paddedBounds, primaryTickCounts } = opts;\n    let { clipSeries } = opts;\n    const { position = \"left\", direction } = axis;\n    this.sizeAxis(axis, seriesRect, position);\n    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : void 0;\n    const isVertical = direction === \"y\" /* Y */;\n    const paddedBoundsCoefficient = 0.3;\n    if (axis.thickness) {\n      axis.maxThickness = axis.thickness;\n    } else {\n      axis.maxThickness = (isVertical ? paddedBounds.width : paddedBounds.height) * paddedBoundsCoefficient;\n    }\n    const layout = axis.calculateLayout(primaryTickCount);\n    primaryTickCount = layout.primaryTickCount;\n    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);\n    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n    let axisThickness;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    return { clipSeries, axisThickness, primaryTickCount };\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width, height } = seriesRect;\n    const minStart = 0;\n    const maxEnd = isLeftRight ? height : width;\n    let start = minStart;\n    let end = maxEnd;\n    const { width: axisWidth, unit, align } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end = start + axisWidth;\n    } else {\n      end = end * axisWidth / 100;\n    }\n    if (align === \"end\") {\n      start = maxEnd - (end - start);\n      end = maxEnd;\n    }\n    if (isCategory && isLeftRight) {\n      [min, max] = [1 - max, 1 - min];\n    } else if (isLeftRight) {\n      [start, end] = [end, start];\n    }\n    axis.range = [start, end];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width : height;\n  }\n  calculateAxisArea(axes, axisWidths, axisOffsets) {\n    let totalAxisWidth = 0;\n    let currentOffset = 0;\n    for (const axis of axes) {\n      axisOffsets.set(axis.id, currentOffset);\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n      if (axis.layoutConstraints.stacked) {\n        currentOffset += axisThickness + 15;\n      }\n    }\n    return totalAxisWidth;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    let axisBoundMainOffset = 0;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n      axisBoundMainOffset += 1;\n    }\n    axisBoundMainOffset += axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.updatePosition();\n    }\n  }\n  shouldFlipXY() {\n    return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));\n  }\n};\nCartesianChart.className = \"CartesianChart\";\nCartesianChart.type = \"cartesian\";\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi, licenseManager) {\n    this.factoryApi = factoryApi;\n    this.licenseManager = licenseManager;\n    this.chart = chart;\n    chart.publicApi = this;\n  }\n  static isInstance(x) {\n    if (x instanceof _AgChartInstanceProxy) {\n      return true;\n    }\n    if (x.constructor?.name === \"AgChartInstanceProxy\" && x.chart != null) {\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    const chartProps = [\"getOptions\", \"destroy\"];\n    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});\n    return chartProps.every((prop) => signatureProps.includes(prop));\n  }\n  async update(options) {\n    this.factoryApi.createOrUpdate(options, this);\n    await this.chart.waitForUpdate();\n  }\n  async updateDelta(deltaOptions) {\n    this.factoryApi.updateUserDelta(this, deltaOptions);\n    await this.chart.waitForUpdate();\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key in options) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      clone.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      return clone.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  getState() {\n    return this.factoryApi.caretaker.save(this.chart.ctx.annotationManager);\n  }\n  async setState(state) {\n    this.factoryApi.caretaker.restore(state, this.chart.ctx.annotationManager);\n    await this.chart.waitForUpdate();\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    this.chart.publicApi = void 0;\n    this.chart.destroy();\n  }\n  async prepareResizedChart(proxy, opts = {}) {\n    const { chart } = proxy;\n    const width = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const state = proxy.getState();\n    const isEnterprise = moduleRegistry.hasEnterpriseModules();\n    const overrideOptions = {};\n    const processedOptions = chart.chartOptions.getOptions();\n    if (isEnterprise) {\n      overrideOptions.animation = { enabled: false };\n      if (isAgCartesianChartOptions(processedOptions)) {\n        overrideOptions.toolbar = { enabled: false };\n      }\n      if (this.licenseManager?.isDisplayWatermark()) {\n        overrideOptions.foreground = {\n          text: this.licenseManager.getWatermarkMessage(),\n          image: {\n            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,\n            width: 170,\n            height: 25,\n            right: 25,\n            bottom: 50,\n            opacity: 0.7\n          }\n        };\n      }\n    }\n    const options = mergeDefaults(\n      {\n        container: document.createElement(\"div\"),\n        width,\n        height\n      },\n      overrideOptions,\n      processedOptions\n    );\n    const cloneProxy = await this.factoryApi.createOrUpdate(options);\n    await cloneProxy.setState(state);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"agChartV2\", chart.ctx.zoomManager.getZoom());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    const count = this.tickCount ?? ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start, stop) {\n    return this.interval ?? tickStep(start, stop, this.tickCount, this.minTickCount, this.maxTickCount);\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   */\n  updateNiceDomain() {\n    const count = this.tickCount;\n    if (count < 1) {\n      this.niceDomain = [...this.domain];\n      return;\n    }\n    let [start, stop] = this.domain;\n    if (count === 1) {\n      [start, stop] = niceTicksDomain(start, stop);\n    } else {\n      const roundStart = start > stop ? Math.ceil : Math.floor;\n      const roundStop = stop < start ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start;\n        const prev1 = stop;\n        const step = this.getTickStep(start, stop);\n        const [d0, d1] = this.domain;\n        if (step >= 1) {\n          start = roundStart(d0 / step) * step;\n          stop = roundStop(d1 / step) * step;\n        } else {\n          const s = 1 / step;\n          start = roundStart(d0 * s) / s;\n          stop = roundStop(d1 * s) / s;\n        }\n        if (start === prev0 && stop === prev1) {\n          break;\n        }\n      }\n    }\n    this.niceDomain = [start, stop];\n  }\n  tickFormat({ ticks: specifiedTicks, specifier }) {\n    return tickFormat(specifiedTicks ?? this.ticks(), specifier);\n  }\n};\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start, stop] = findMinMax(domain);\n  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);\n  const step = getTickStep(start, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start + segments * step;\n  const d = reverse ? [stop, start] : [start, stop];\n  const ticks = getTicks(start, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error(\"AG Charts - dataDomain not calculated, cannot perform tick calculation.\");\n    }\n    if (this.dataDomain.domain.length === 0) {\n      return [];\n    }\n    const { domain, ticks } = calculateNiceSecondaryAxis(\n      this.dataDomain.domain,\n      primaryTickCount ?? 0,\n      this.reverse\n    );\n    this.scale.nice = false;\n    this.scale.domain = domain;\n    this.scale.update();\n    return ticks;\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent2[0] > extent2[1];\n    const crossesZero = extent2[0] < 0 && extent2[1] > 0;\n    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      if (crossesZero) {\n        Logger.warn(\n          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n        );\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent2[0] === 0) {\n      extent2[0] = 1;\n    }\n    if (extent2[1] === 0) {\n      extent2[1] = -1;\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = (extent(d) ?? [0, 1e3]).map((x) => new Date(x));\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });\n    }\n  }\n  calculatePadding() {\n    return [0, 0];\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/util/corner.ts\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width, height);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width, height, topLeftCornerRadius);\n    return;\n  }\n  if (width < 0) {\n    x += width;\n    width = Math.abs(width);\n  }\n  if (height < 0) {\n    y += height;\n    height = Math.abs(height);\n  }\n  if (width <= 0 || height <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width, height);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height, maxHorizontalCornerRadius / width, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width - bottomRightCornerRadius;\n    const cy = y + height - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath;\n    this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      this.hittester = (hitX, hitY) => {\n        const point = this.transformPoint(hitX, hitY);\n        return this.getBBox().containsPoint(point.x, point.y);\n      };\n      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width, height, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width, height);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke, effectiveStrokeWidth } = this;\n    if (stroke && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx, zIndex = 0 /* SERIES_BACKGROUND_ZINDEX */, layer = false) {\n    super();\n    this.zIndex = zIndex;\n    this.layer = layer;\n    this.rectNode = new Rect();\n    this.textNode = new Text();\n    this.fill = \"white\";\n    this.node = new Group({ name: \"background\", zIndex: this.zIndex, layer: this.layer });\n    this.node.append([this.rectNode, this.textNode]);\n    this.visible = true;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  onLayoutComplete(e) {\n    const { width, height } = e.chart;\n    this.rectNode.width = width;\n    this.rectNode.height = height;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"textNode\")\n], Background.prototype, \"text\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Background(ctx)\n};\n\n// packages/ag-charts-community/src/scene/spriteRenderer.ts\nvar SpriteRenderer = class {\n  constructor() {\n    this.offscreenCanvas = new OffscreenCanvas(1, 1);\n    const ctx = this.offscreenCanvas.getContext(\"2d\");\n    if (ctx == null)\n      throw new TypeError(`AG Charts - invalid 2d context`);\n    this.renderCtx = {\n      ctx,\n      devicePixelRatio: 1,\n      forceRender: true,\n      resized: false,\n      debugNodes: {}\n    };\n  }\n  resize({ spritePixelRatio, spriteWidth, spriteHeight }) {\n    this.offscreenCanvas.width = Math.max(spriteWidth, 0) * spritePixelRatio;\n    this.offscreenCanvas.height = Math.max(spriteHeight, 0) * spritePixelRatio;\n  }\n  renderSprite(nodes, opts) {\n    nodes = toIterable(nodes);\n    const {\n      renderCtx,\n      renderCtx: { ctx },\n      offscreenCanvas\n    } = this;\n    const { scale: scale2 = 1, translateX = 0, translateY = 0 } = opts ?? {};\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.save();\n    ctx.beginPath();\n    ctx.setTransform(scale2, 0, 0, scale2, translateX, translateY);\n    for (const node of nodes) {\n      node.render(renderCtx);\n    }\n    ctx.closePath();\n    ctx.restore();\n    return offscreenCanvas.transferToImageBitmap();\n  }\n};\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, button, type, listener) {\n  button.addEventListener(type, listener);\n  destroyFns.push(() => button.removeEventListener(type, listener));\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initToolbarKeyNav(opts) {\n  const { orientation, toolbar, buttons, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const ariaHidden = buttons.length === 0;\n  toolbar.role = \"toolbar\";\n  toolbar.ariaOrientation = orientation;\n  toolbar.ariaHidden = ariaHidden.toString();\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[i - 1];\n    const curr = buttons[i];\n    const next = buttons[i + 1];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nfunction initMenuKeyNav(opts) {\n  const { orientation, menu, buttons, onEscape } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(buttons.length + i - 1) % buttons.length];\n    const curr = buttons[i];\n    const next = buttons[(buttons.length + i + 1) % buttons.length];\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = -1;\n  }\n  menu.tabIndex = -1;\n  if (onEscape)\n    addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  return destroyFns;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio2 = n / bboxIndex;\n      if (ratio2 < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.sourceImage = sourceImage;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n  }\n  updateBitmap(newBitmap, bitmapPixelRatio, x, y) {\n    this.sourceImage = newBitmap;\n    this.width = newBitmap.width / bitmapPixelRatio;\n    this.height = newBitmap.height / bitmapPixelRatio;\n    this.x = x / bitmapPixelRatio;\n    this.y = y / bitmapPixelRatio;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped++;\n      return;\n    }\n    const image = this.sourceImage;\n    if (!image)\n      return;\n    this.transformRenderContext(renderCtx);\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/chart/legendMarkerLabel.ts\nvar LegendMarkerLabel = class extends Group {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.label = new Text();\n    this.symbolsGroup = new Group({\n      name: \"legend-markerLabel-symbols\"\n    });\n    this.bitmap = new Image();\n    this.bitmapDirty = true;\n    this.enabled = true;\n    this.pageIndex = NaN;\n    this._markers = [];\n    this._lines = [];\n    const { markers, label, lines } = this;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n    this.updateSymbols(markers, lines);\n    this.append(argsIterable(this.symbolsGroup, label));\n  }\n  destroy() {\n    super.destroy();\n    this.proxyButton?.remove();\n  }\n  get markers() {\n    return this._markers;\n  }\n  get lines() {\n    return this._lines;\n  }\n  updateSymbols(markers, lines) {\n    if (arraysEqual(this._markers, markers) && arraysEqual(this._lines, lines))\n      return;\n    this.bitmapDirty = true;\n    this._markers = markers;\n    this._lines = lines;\n    this.symbolsGroup.clear();\n    this.symbolsGroup.append([this.bitmap, ...markers, ...lines]);\n  }\n  setEnabled(enabled) {\n    this.enabled = enabled;\n    this.refreshVisibilities();\n  }\n  refreshVisibilities() {\n    const opacity = this.enabled ? 1 : 0.5;\n    this.label.opacity = opacity;\n    this.opacity = opacity;\n    this.bitmap.opacity = opacity;\n    this.setBitmapVisibility(!this.enabled);\n  }\n  setBitmapVisibility(visible) {\n    const { lines, markers } = this;\n    [lines, markers].forEach((shapes) => shapes.forEach((shape) => shape.visible = !visible));\n    this.bitmap.visible = visible;\n  }\n  // The BBox of this.bitmap is `spritePadding` pixels bigger in each direction than BBox of the markers and lines.\n  // This padding allows the SpriteRenderer to draw antialiasing pixels that can extend beyond the shapes' bounds.\n  update(spriteRenderer, { spriteAAPadding, spritePixelRatio: scale2 }, dimensionProps) {\n    const { markers, lines } = this;\n    let spriteX = 0;\n    let spriteY = 0;\n    let shift = 0;\n    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {\n      const { length: length2, spacing } = dimensionProps[i] ?? 0;\n      const marker = markers[i];\n      const line = lines[i];\n      const size = marker?.size ?? 0;\n      let lineTop = Infinity;\n      let markerTop = Infinity;\n      let markerLeft = Infinity;\n      if (marker) {\n        const center = marker.constructor.center;\n        const radius = (size + marker.strokeWidth) / 2;\n        marker.x = (center.x - 0.5) * size + length2 / 2 + shift;\n        marker.y = (center.y - 0.5) * size;\n        markerTop = marker.y - radius;\n        markerLeft = marker.x - radius;\n      }\n      if (line) {\n        line.x1 = shift;\n        line.x2 = shift + length2;\n        line.y1 = 0;\n        line.y2 = 0;\n        line.markDirtyTransform();\n        lineTop = -line.strokeWidth / 2;\n      }\n      shift += spacing + Math.max(length2, size);\n      spriteX = Math.min(spriteX, line.x1, line.x2, markerLeft);\n      spriteY = Math.min(spriteY, lineTop, markerTop);\n    }\n    const lastSymbolProps = dimensionProps.at(-1);\n    const lastLine = this.lines.at(-1);\n    const lastMarker = this.markers.at(-1);\n    const lineEnd = lastLine ? lastLine.x2 : -Infinity;\n    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;\n    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);\n    if (this.bitmapDirty) {\n      this.setBitmapVisibility(false);\n      const translateX = (spriteAAPadding + spriteX) * scale2;\n      const translateY = (spriteAAPadding - spriteY) * scale2;\n      const sprite = spriteRenderer.renderSprite(this.symbolsGroup, {\n        scale: scale2,\n        translateX: Math.floor(translateX),\n        translateY: Math.floor(translateY)\n      });\n      this.bitmap.updateBitmap(sprite, scale2, Math.ceil(-translateX), Math.ceil(-translateY));\n      this.bitmapDirty = false;\n      this.refreshVisibilities();\n    }\n    if (dimensionProps.length < 2) {\n      return;\n    }\n    const bbox = this.symbolsGroup.getBBox();\n    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);\n    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);\n    this.symbolsGroup.setClipRectInGroupCoordinateSpace(clipRect);\n  }\n  computeBBox() {\n    const { label, lines, markers } = this;\n    return Group.computeBBox(arraysIterable([label], lines, markers), { skipInvisible: false });\n  }\n};\nLegendMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], LegendMarkerLabel.prototype, \"color\", 2);\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback, regionManager, cursorManager) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.regionManager = regionManager;\n    this.cursorManager = cursorManager;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new Group({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.destroyFns = [];\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    const region = this.regionManager.addRegion(\"pagination\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"click\", (event) => this.onPaginationClick(event)),\n      region.addListener(\"hover\", (event) => this.onPaginationMouseMove(event))\n    );\n    this.update();\n    this.updateMarkers();\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.getBBox();\n    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { size } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  nextButtonContainsPoint(offsetX, offsetY) {\n    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\n  }\n  previousButtonContainsPoint(offsetX, offsetY) {\n    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\n  }\n  clickNext() {\n    this.incrementPage();\n    this.onPaginationChanged();\n  }\n  clickPrevious() {\n    this.decrementPage();\n    this.onPaginationChanged();\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, this.totalPages - 1);\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  onPaginationClick(event) {\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.clickNext();\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.clickPrevious();\n    }\n  }\n  onPaginationMouseMove(event) {\n    const { offsetX, offsetY } = event;\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"next\";\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"previous\";\n    } else {\n      this.cursorManager.updateCursor(this.id);\n      this.highlightActive = void 0;\n    }\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker2 = getMarker(this.marker.shape || Triangle);\n    this.previousButton = new Marker2();\n    this.nextButton = new Marker2();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  getBBox() {\n    return this.group.getBBox(true);\n  }\n  computeCSSBounds() {\n    const prev = this._previousButton.computeTransformedBBox();\n    const next = this._nextButton.computeTransformedBBox();\n    return { prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.parent?.onMarkerShapeChange())\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new Group({ name: \"legend\", layer: true, zIndex: 13 /* LEGEND_ZINDEX */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      LegendMarkerLabel\n    );\n    this.spriteRenderer = new SpriteRenderer();\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.destroyFns = [];\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page),\n      ctx.regionManager,\n      ctx.cursorManager\n    );\n    this.pagination.attachPagination(this.group);\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_VISIBILITY,\n      type: \"legend\",\n      label: \"contextMenuToggleSeriesVisibility\",\n      action: (params) => this.contextToggleVisibility(params)\n    });\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_OTHER_SERIES,\n      type: \"legend\",\n      label: \"contextMenuToggleOtherSeries\",\n      action: (params) => this.contextToggleOtherSeries(params)\n    });\n    const { Default: Default2, Animation: Animation2, ContextMenu } = InteractionState;\n    const animationState = Default2 | Animation2;\n    const contextMenuState = Default2 | Animation2 | ContextMenu;\n    const region = ctx.regionManager.addRegion(\"legend\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"contextmenu\", (e) => this.checkContextClick(e), contextMenuState),\n      region.addListener(\"click\", (e) => this.checkLegendClick(e), animationState),\n      region.addListener(\"dblclick\", (e) => this.checkLegendDoubleClick(e), animationState),\n      region.addListener(\"hover\", (e) => this.handleLegendMouseMove(e), animationState),\n      region.addListener(\"leave\", () => this.handleLegendMouseExit(), animationState),\n      region.addListener(\"enter\", (e) => this.handleLegendMouseEnter(e), animationState),\n      ctx.layoutService.addListener(\"start-layout\", (e) => this.positionLegend(e)),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged()),\n      () => this.group.parent?.removeChild(this.group)\n    );\n    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `${this.id}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      id: `${this.id}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n  }\n  set data(value) {\n    this._data = value;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.pagination.destroy();\n    this.itemSelection.clear();\n  }\n  initLegendItemToolbar() {\n    this.itemSelection.each((markerLabel, _, i) => {\n      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"button\",\n        id: `ag-charts-legend-item-${i}`,\n        textContent: this.getItemAriaText(i),\n        parent: this.proxyLegendToolbar,\n        focusable: markerLabel,\n        // Retrieve the datum from the node rather than from the method parameter.\n        // The method parameter `datum` gets destroyed when the data is refreshed\n        // using Series.getLegendData(). But the scene node will stay the same.\n        onclick: () => {\n          this.doClick(markerLabel.datum);\n          markerLabel.proxyButton.textContent = this.getItemAriaText(i, !markerLabel.datum.enabled);\n        },\n        onblur: () => this.handleLegendMouseExit(),\n        onfocus: () => {\n          const bounds = markerLabel?.computeTransformedBBox();\n          const event = makeKeyboardPointerEvent(this.ctx.focusIndicator, { bounds, showFocusBox: true });\n          this.doHover(event, markerLabel.datum);\n          this.pagination.setPage(markerLabel.pageIndex);\n        }\n      }));\n    });\n    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton).filter((button) => !!button);\n    initToolbarKeyNav({\n      orientation: this.getOrientation(),\n      buttons,\n      toolbar: this.proxyLegendToolbar\n    });\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(this.group, 2 /* MINOR */);\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width, height) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    const proxyToolbarNeedsUpdate = this.itemSelection.nodes().length === 0;\n    this.itemSelection.update(data);\n    if (proxyToolbarNeedsUpdate) {\n      this.initLegendItemToolbar();\n    }\n    const bboxes = [];\n    const font = TextUtils.toFontString(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width * itemMaxWidthPercentage;\n    const spriteDims = this.calculateSpriteDimensions();\n    this.spriteRenderer.resize(spriteDims);\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, spriteDims);\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);\n      bboxes.push(markerLabel.getBBox());\n    });\n    width = Math.max(1, width);\n    height = Math.max(1, height);\n    if (!isFinite(width)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width;\n    size[1] = height;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  calcSymbolsEnabled(symbol) {\n    const { showSeriesStroke, marker } = this.item;\n    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    return { markerEnabled, lineEnabled };\n  }\n  calcSymbolsLengths(symbol) {\n    const { marker, line } = this.item;\n    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);\n    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth };\n  }\n  calculateSpriteDimensions() {\n    let spriteAAPadding = 0;\n    let spriteWidth = 0;\n    let spriteHeight = 0;\n    let markerWidth = 0;\n    this.itemSelection.each((_, datum) => {\n      datum.symbols.forEach((symbol) => {\n        const { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth } = this.calcSymbolsLengths(symbol);\n        const markerTotalLength = markerLength + markerStrokeWidth;\n        markerWidth = Math.max(markerWidth, lineLength, markerLength);\n        spriteWidth = Math.max(spriteWidth, lineLength, markerTotalLength);\n        spriteHeight = Math.max(spriteHeight, lineStrokeWidth, markerTotalLength);\n        spriteAAPadding = Math.max(spriteAAPadding, markerStrokeWidth + 0.5);\n      });\n    });\n    spriteWidth += spriteAAPadding * 2;\n    spriteHeight += spriteAAPadding * 2;\n    const spritePixelRatio = getWindow().devicePixelRatio;\n    return { spritePixelRatio, spriteAAPadding, spriteWidth, spriteHeight, markerWidth };\n  }\n  updateMarkerLabel(markerLabel, datum, spriteDims) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const { markerWidth } = spriteDims;\n    const dimensionProps = [];\n    let paddedSymbolWidth = paddingX;\n    if (markerLabel.markers.length !== datum.symbols.length && markerLabel.lines.length !== datum.symbols.length) {\n      const markers = [];\n      const lines = [];\n      datum.symbols.forEach((symbol) => {\n        const { shape: markerShape = symbol.marker.shape } = itemMarker;\n        const MarkerCtr = getMarker(markerShape);\n        lines.push(new Line());\n        markers.push(new MarkerCtr());\n      });\n      markerLabel.updateSymbols(markers, lines);\n    }\n    datum.symbols.forEach((symbol, i) => {\n      const spacing = symbol.marker.padding ?? itemMarker.padding;\n      const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;\n      dimensionProps.push({ length: markerWidth, spacing });\n      if (markerEnabled || lineEnabled) {\n        paddedSymbolWidth += spacing + markerWidth;\n      }\n      const marker = markerLabel.markers[i];\n      const line = markerLabel.lines[i];\n      if (marker) {\n        const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);\n        marker.fill = fill;\n        marker.stroke = stroke;\n        marker.strokeWidth = strokeWidth;\n        marker.fillOpacity = fillOpacity;\n        marker.strokeOpacity = strokeOpacity;\n      }\n      if (line) {\n        const lineStyles = this.getLineStyles(symbol);\n        line.stroke = lineStyles.stroke;\n        line.strokeOpacity = lineStyles.strokeOpacity;\n        line.strokeWidth = lineStyles.strokeWidth;\n        line.lineDash = lineStyles.lineDash;\n      }\n    });\n    markerLabel.update(this.spriteRenderer, spriteDims, dimensionProps);\n    return paddedSymbolWidth;\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = text.substring(0, maxCharLength);\n      addEllipsis = true;\n    }\n    const measurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const result = TextWrapper.truncateLine(text, measurer, maxItemWidth - paddedMarkerWidth, addEllipsis);\n    if (result.endsWith(TextUtils.EllipsisChar)) {\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return result;\n  }\n  updatePagination(bboxes, width, height) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width,\n      height\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  updateItemProxyButtons() {\n    this.itemSelection.each((markerLabel) => {\n      const bbox = markerLabel.computeTransformedBBox()?.clone();\n      bbox.translate(this.group.translationX, this.group.translationY);\n      setElementBBox(markerLabel.proxyButton, bbox);\n    });\n  }\n  updatePaginationProxyButtons(oldPages) {\n    this.proxyLegendPagination.style.display = this.pagination.visible ? \"absolute\" : \"none\";\n    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;\n    const newNeedsButtons = this.pages.length > 1;\n    if (oldNeedsButtons !== newNeedsButtons) {\n      if (newNeedsButtons) {\n        this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-prev-page`,\n          textContent: { id: \"ariaLabelLegendPagePrevious\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          focusable: this.pagination.previousButton,\n          onclick: () => this.pagination.clickPrevious()\n        });\n        this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-next-page`,\n          textContent: { id: \"ariaLabelLegendPageNext\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          focusable: this.pagination.nextButton,\n          onclick: () => this.pagination.clickNext()\n        }));\n      } else {\n        this.proxyNextButton?.remove();\n        this.proxyPrevButton?.remove();\n        [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];\n      }\n    }\n    const { prev, next } = this.pagination.computeCSSBounds();\n    setElementBBox(this.proxyPrevButton, prev);\n    setElementBBox(this.proxyNextButton, next);\n  }\n  calculatePagination(bboxes, width, height) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.getBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      lastPassPaginationBBox = this.pagination.getBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex;\n      let rowIndex;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n    });\n  }\n  updatePageNumber(pageNumber) {\n    const { pages } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.setEnabled(datum.enabled);\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const { toggleSeries } = this;\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_VISIBILITY, toggleSeries);\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_OTHER_SERIES, toggleSeries);\n  }\n  getLineStyles(datum) {\n    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth\n    };\n  }\n  getDatumForPoint(x, y) {\n    const visibleChildBBoxes = [];\n    const closestLeftTop = { dist: Infinity, datum: void 0 };\n    for (const child of this.group.children) {\n      if (!child.visible)\n        continue;\n      if (!(child instanceof LegendMarkerLabel))\n        continue;\n      const childBBox = child.getBBox().clone();\n      childBBox.grow(this.item.paddingX / 2, \"horizontal\");\n      childBBox.grow(this.item.paddingY / 2, \"vertical\");\n      if (childBBox.containsPoint(x, y)) {\n        return child.datum;\n      }\n      const distX = x - childBBox.x - this.item.paddingX / 2;\n      const distY = y - childBBox.y - this.item.paddingY / 2;\n      const dist = distX ** 2 + distY ** 2;\n      const toTheLeftTop = distX >= 0 && distY >= 0;\n      if (toTheLeftTop && dist < closestLeftTop.dist) {\n        closestLeftTop.dist = dist;\n        closestLeftTop.datum = child.datum;\n      }\n      visibleChildBBoxes.push(childBBox);\n    }\n    const pageBBox = BBox.merge(visibleChildBBoxes);\n    if (!pageBBox.containsPoint(x, y)) {\n      return;\n    }\n    return closestLeftTop.datum;\n  }\n  computePagedBBox() {\n    let actualBBox = this.group.getBBox();\n    if (this.pages.length <= 1) {\n      return actualBBox;\n    }\n    const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n    actualBBox = actualBBox.clone();\n    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    return actualBBox;\n  }\n  contextToggleVisibility(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doClick(datum);\n  }\n  contextToggleOtherSeries(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doDoubleClick(datum);\n  }\n  checkContextClick(event) {\n    const legendItem = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", event, { legendItem });\n  }\n  checkLegendClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(datum) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      const status = newEnabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\";\n      this.ctx.ariaAnnouncementService.announceValue(status);\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemClick?.({ type: \"click\", enabled: newEnabled, itemId, seriesId: series.id });\n    return true;\n  }\n  checkLegendDoubleClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doDoubleClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemDoubleClick?.({ type: \"dblclick\", enabled: true, itemId, seriesId: series.id });\n    return true;\n  }\n  handleLegendMouseMove(event) {\n    if (!this.enabled) {\n      return;\n    }\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    this.doHover(event, datum);\n  }\n  doHover(event, datum) {\n    const { toggleSeries, listeners } = this;\n    if (event === void 0 || datum === void 0) {\n      this.ctx.cursorManager.updateCursor(this.id);\n      this.updateHighlight();\n      return;\n    }\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const { offsetX, offsetY } = event;\n      this.ctx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.getItemLabel(datum) })\n      );\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (toggleSeries || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n    if (datum?.enabled && series) {\n      this.updateHighlight({\n        series,\n        itemId: datum?.itemId,\n        datum: void 0\n      });\n    } else {\n      this.updateHighlight();\n    }\n  }\n  handleLegendMouseExit() {\n    this.ctx.cursorManager.updateCursor(this.id);\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.updateHighlight();\n  }\n  updateHighlight(datum) {\n    const state = this.ctx.interactionManager.getState();\n    if (state === 16 /* Default */) {\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n    } else if (state === 1 /* Animation */) {\n      this.pendingHighlightDatum = datum;\n      this.ctx.animationManager.onBatchStop(() => {\n        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);\n      });\n    }\n  }\n  handleLegendMouseEnter(event) {\n    const {\n      enabled,\n      toggleSeries,\n      listeners: { legendItemClick: clickListener, legendItemDoubleClick: dblclickListener }\n    } = this;\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (enabled && datum !== void 0 && (toggleSeries || clickListener != null || dblclickListener != null)) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n  }\n  onLocaleChanged() {\n    this.itemSelection.each(({ proxyButton }, _, i) => {\n      if (proxyButton != null) {\n        proxyButton.textContent = this.getItemAriaText(i);\n      }\n    });\n  }\n  getItemAriaText(nodeIndex, enabled) {\n    const datum = this.data[nodeIndex];\n    const label = datum && this.getItemLabel(datum);\n    enabled ?? (enabled = datum.enabled);\n    const lm = this.ctx.localeManager;\n    if (nodeIndex >= 0 && label) {\n      const index = nodeIndex + 1;\n      const count = this.data.length;\n      const part1 = lm.t(\"ariaLabelLegendItem\", { label, index, count });\n      const part2 = lm.t(enabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\");\n      return [part1, part2].join(\"\");\n    }\n    return lm.t(\"ariaLabelLegendItemUnknown\");\n  }\n  positionLegend(ctx) {\n    const { shrinkRect } = ctx;\n    const newShrinkRect = shrinkRect.clone();\n    if (!this.enabled || !this.data.length) {\n      return { ...ctx, shrinkRect: newShrinkRect };\n    }\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\n    this.group.translationX = 0;\n    this.group.translationY = 0;\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return shrinkRect.height - legendBBox.height;\n        case \"right\":\n        default:\n          return shrinkRect.width - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      const legendPadding = this.spacing;\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (shrinkRect.width - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          newShrinkRect.shrink(legendBBox.height + legendPadding, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (shrinkRect.height - legendBBox.height) / 2;\n          newShrinkRect.shrink(legendBBox.width + legendPadding, this.position);\n      }\n      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\n      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\n      this.proxyLegendToolbar.style.removeProperty(\"display\");\n      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();\n    } else {\n      this.proxyLegendToolbar.style.display = \"none\";\n    }\n    this.updateItemProxyButtons();\n    this.updatePaginationProxyButtons(oldPages);\n    return { ...ctx, shrinkRect: newShrinkRect };\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width, height } = shrinkRect;\n    const aspectRatio = width / height;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);\n        break;\n      case \"left\":\n      case \"right\":\n      default:\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.updateGroupVisibility()),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Legend(ctx),\n  packageType: \"community\"\n};\n\n// packages/ag-charts-community/src/chart/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/chart/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Locale(ctx)\n};\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts\nvar RangeHandle = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 3;\n    this.centerX = 0;\n    this.centerY = 0;\n    this.width = 8;\n    this.height = 16;\n    this.gripLineGap = 2;\n    this.gripLineLength = 8;\n  }\n  setCenter(x, y) {\n    this.dirtyPath = true;\n    this.centerX = x;\n    this.centerY = y;\n  }\n  static align(minHandle, maxHandle, x, y, width, height, min, max) {\n    const handlePixelAlign = minHandle.strokeWidth / 2;\n    const minHandleX = minHandle.align(x + width * min) + handlePixelAlign;\n    const maxHandleX = minHandleX + minHandle.align(x + width * min, width * (max - min)) - 2 * handlePixelAlign;\n    const handleY = minHandle.align(y + height / 2) + handlePixelAlign;\n    minHandle.setCenter(minHandleX, handleY);\n    maxHandle.setCenter(maxHandleX, handleY);\n  }\n  computeBBox() {\n    const { centerX, centerY, width, height } = this;\n    const x = centerX - width / 2;\n    const y = centerY - height / 2;\n    return new BBox(x, y, width, height);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return bbox.containsPoint(point.x, point.y);\n  }\n  updatePath() {\n    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    path.clear();\n    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;\n    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY + halfHeight);\n    path.lineTo(centerX - halfWidth, centerY + halfHeight);\n    path.closePath();\n    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;\n    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - dx, centerY - dy);\n    path.lineTo(centerX - dx, centerY + dy);\n    path.moveTo(centerX + dx, centerY - dy);\n    path.lineTo(centerX + dx, centerY + dy);\n  }\n};\nRangeHandle.className = \"RangeHandle\";\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineGap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineLength\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts\nvar RangeMask = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 2;\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.min = 0;\n    this.max = 1;\n  }\n  layout(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.dirtyPath = true;\n  }\n  update(min, max) {\n    this.min = isNaN(min) ? this.min : min;\n    this.max = isNaN(max) ? this.max : max;\n    this.dirtyPath = true;\n  }\n  computeBBox() {\n    const { x, y, width, height } = this;\n    return new BBox(x, y, width, height);\n  }\n  computeVisibleRangeBBox() {\n    const { x, y, width, height, min, max } = this;\n    const minX = x + width * min;\n    const maxX = x + width * max;\n    return new BBox(minX, y, maxX - minX, height);\n  }\n  updatePath() {\n    const { path, x, y, width, height, min, max, strokeWidth } = this;\n    const pixelAlign = strokeWidth / 2;\n    path.clear();\n    const ax = this.align(x) + pixelAlign;\n    const ay = this.align(y) + pixelAlign;\n    const axw = ax + this.align(x, width) - 2 * pixelAlign;\n    const ayh = ay + this.align(y, height) - 2 * pixelAlign;\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.closePath();\n    const minX = this.align(x + width * min) + pixelAlign;\n    const maxX = minX + this.align(x + width * min, width * (max - min)) - 2 * pixelAlign;\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.closePath();\n  }\n};\nRangeMask.className = \"RangeMask\";\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts\nvar RangeSelector = class extends Group {\n  constructor(children) {\n    super({ name: \"rangeSelectorGroup\", layer: true, zIndex: 14 /* NAVIGATOR_ZINDEX */ });\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.lOffset = 0;\n    this.rOffset = 0;\n    this.isContainerNode = true;\n    this.background = new Group({ name: \"navigator-background\" });\n    this.background.zIndex = 1;\n    this.appendChild(this.background);\n    this.append(children);\n  }\n  layout(x, y, width, height, lOffset, rOffset) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.lOffset = lOffset;\n    this.rOffset = rOffset;\n    this.background.translationX = x;\n    this.background.translationY = y;\n  }\n  updateBackground(oldGroup, newGroup) {\n    if (oldGroup != null) {\n      this.background.removeChild(oldGroup);\n    }\n    if (newGroup != null) {\n      this.background.appendChild(newGroup);\n    }\n  }\n  computeBBox() {\n    const { x, y, width, height, lOffset, rOffset } = this;\n    return new BBox(x - lOffset, y, width + (lOffset + rOffset), height);\n  }\n};\n\n// packages/ag-charts-community/src/chart/navigator/navigator.ts\nvar Navigator = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.miniChart = void 0;\n    this.enabled = false;\n    this.mask = new RangeMask();\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.maskVisibleRange = {\n      id: \"navigator-mask-visible-range\",\n      getBBox: () => this.mask.computeVisibleRangeBBox(),\n      computeTransformedBBox: () => this.mask.computeVisibleRangeBBox()\n    };\n    this.height = 30;\n    this.spacing = 10;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);\n    this._min = 0;\n    this._max = 1;\n    this.minRange = 1e-3;\n    const region = ctx.regionManager.addRegion(\"navigator\", this.rangeSelector);\n    const dragStates = 16 /* Default */ | 1 /* Animation */ | 8 /* ZoomDrag */;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.rangeSelector),\n      region.addListener(\"hover\", (event) => this.onHover(event), dragStates),\n      region.addListener(\"drag-start\", (event) => this.onDragStart(event), dragStates),\n      region.addListener(\"drag\", (event) => this.onDrag(event), dragStates),\n      region.addListener(\"drag-end\", () => this.onDragEnd(), dragStates),\n      region.addListener(\"leave\", (event) => this.onLeave(event), dragStates),\n      this.ctx.localeManager.addListener(\"locale-changed\", () => this.updateZoom()),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event))\n    );\n    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `navigator-toolbar`,\n      classList: [\"ag-charts-proxy-navigator-toolbar\"],\n      ariaOrientation: \"vertical\",\n      ariaLabel: { id: \"ariaLabelNavigator\" }\n    });\n    this.updateGroupVisibility();\n    this.proxyNavigatorElements = [\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-min\",\n        ariaLabel: { id: \"ariaLabelNavigatorMinimum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.minHandle,\n        onchange: (ev) => this.onMinSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-pan\",\n        ariaLabel: { id: \"ariaLabelNavigatorRange\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maskVisibleRange,\n        onchange: (ev) => this.onPanSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-max\",\n        ariaLabel: { id: \"ariaLabelNavigatorMaximum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maxHandle,\n        onchange: (ev) => this.onMaxSliderChange(ev)\n      })\n    ];\n    initToolbarKeyNav({\n      orientation: \"vertical\",\n      toolbar: this.proxyNavigatorToolbar,\n      buttons: this.proxyNavigatorElements\n    });\n    this.destroyFns.push(() => {\n      this.proxyNavigatorElements.forEach((e) => e.remove());\n      this.proxyNavigatorToolbar.remove();\n    });\n  }\n  updateBackground(oldGroup, newGroup) {\n    this.rangeSelector?.updateBackground(oldGroup, newGroup);\n  }\n  updateGroupVisibility() {\n    const { enabled } = this;\n    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)\n      return;\n    this.rangeSelector.visible = enabled;\n    this.proxyNavigatorToolbar.ariaHidden = (!enabled).toString();\n    if (enabled) {\n      this.updateZoom();\n    } else {\n      this.ctx.zoomManager.updateZoom(\"navigator\");\n    }\n  }\n  async performLayout(ctx) {\n    const { shrinkRect } = ctx;\n    if (this.enabled) {\n      const navigatorTotalHeight = this.height + this.spacing;\n      shrinkRect.shrink(navigatorTotalHeight, \"bottom\");\n      this.y = shrinkRect.y + shrinkRect.height + this.spacing;\n    } else {\n      this.y = 0;\n    }\n    return { ...ctx, shrinkRect };\n  }\n  async performCartesianLayout(opts) {\n    const { x, width } = opts.seriesRect;\n    if (this.enabled) {\n      const { y, height } = this;\n      this.layoutNodes(x, y, width, height);\n      setElementBBox(this.proxyNavigatorToolbar, { x, y, width, height });\n      this.proxyNavigatorToolbar.style.removeProperty(\"display\");\n    } else {\n      this.proxyNavigatorToolbar.style.display = \"none\";\n    }\n    this.x = x;\n    this.width = width;\n  }\n  onHover(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"ew-resize\");\n    } else if (mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"grab\");\n    } else {\n      this.ctx.cursorManager.updateCursor(\"navigator\");\n    }\n  }\n  onDragStart(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle, x, width, _min: min } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.zIndex < maxHandle.zIndex) {\n      if (maxHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"max\";\n      } else if (minHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"min\";\n      }\n    } else if (minHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"min\";\n    } else if (maxHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"max\";\n    }\n    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.dragging = \"pan\";\n      this.panStart = (offsetX - x) / width - min;\n    }\n    if (this.dragging != null) {\n      this.ctx.zoomManager.fireZoomPanStartEvent(\"navigator\");\n    }\n  }\n  onDrag(event) {\n    if (!this.enabled || this.dragging == null)\n      return;\n    const { dragging, minRange, panStart, x, width } = this;\n    let { _min: min, _max: max } = this;\n    const { offsetX } = event;\n    const ratio2 = (offsetX - x) / width;\n    if (dragging === \"min\") {\n      min = clamp(0, ratio2, max - minRange);\n    } else if (dragging === \"max\") {\n      max = clamp(min + minRange, ratio2, 1);\n    } else if (dragging === \"pan\" && panStart != null) {\n      const span = max - min;\n      min = clamp(0, ratio2 - panStart, 1 - span);\n      max = min + span;\n    }\n    this._min = min;\n    this._max = max;\n    this.updateZoom();\n  }\n  onDragEnd() {\n    this.dragging = void 0;\n  }\n  onLeave(_event) {\n    this.ctx.cursorManager.updateCursor(\"navigator\");\n  }\n  onZoomChange(event) {\n    const { x } = event;\n    if (!x)\n      return;\n    this._min = x.min;\n    this._max = x.max;\n    this.updateNodes(x.min, x.max);\n    this.setPanSliderValue(x.min, x.max);\n    this.setSliderRatio(this.proxyNavigatorElements[0], x.min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], x.max);\n  }\n  onPanSliderChange(_event) {\n    const ratio2 = this.getSliderRatio(this.proxyNavigatorElements[1]);\n    const span = this._max - this._min;\n    this._min = clamp(0, ratio2, 1 - span);\n    this._max = this._min + span;\n    this.updateZoom();\n  }\n  onMinSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[0];\n    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);\n    this.updateZoom();\n  }\n  onMaxSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[2];\n    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);\n    this.updateZoom();\n  }\n  setPanSliderValue(min, max) {\n    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;\n    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t(\"ariaValuePanRange\", { min, max });\n  }\n  setSliderRatioClamped(slider, clampMin, clampMax) {\n    const ratio2 = this.getSliderRatio(slider);\n    const clampedRatio = clamp(clampMin, ratio2, clampMax);\n    if (clampedRatio !== ratio2) {\n      this.setSliderRatio(slider, clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setSliderRatio(slider, ratio2) {\n    const value = Math.round(ratio2 * 100);\n    slider.value = `${value}`;\n    slider.ariaValueText = formatPercentage(value);\n  }\n  getSliderRatio(slider) {\n    return parseFloat(slider.value) / 100;\n  }\n  layoutNodes(x, y, width, height) {\n    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;\n    rangeSelector.layout(x, y, width, height, minHandle.width / 2, maxHandle.width / 2);\n    mask.layout(x, y, width, height);\n    RangeHandle.align(minHandle, maxHandle, x, y, width, height, min, max);\n    if (min + (max - min) / 2 < 0.5) {\n      minHandle.zIndex = 3;\n      maxHandle.zIndex = 4;\n    } else {\n      minHandle.zIndex = 4;\n      maxHandle.zIndex = 3;\n    }\n    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {\n      const bbox = node.getBBox();\n      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };\n      setElementBBox(this.proxyNavigatorElements[index], tbox);\n    });\n  }\n  updateNodes(min, max) {\n    this.mask.update(min, max);\n  }\n  updateZoom() {\n    if (!this.enabled)\n      return;\n    const { _min: min, _max: max } = this;\n    if (min == null || max == null)\n      return;\n    const warnOnConflict = (stateId) => {\n      if (this.min == null && this.max == null)\n        return;\n      Logger.warnOnce(\n        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`\n      );\n    };\n    return this.ctx.zoomManager.updateZoom(\"navigator\", { x: { min, max } }, false, warnOnConflict);\n  }\n};\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Navigator.prototype, \"miniChart\", 2);\n__decorateClass([\n  Validate(BOOLEAN),\n  ObserveChanges((target) => target.updateGroupVisibility())\n], Navigator.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"spacing\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(min) {\n      this._min = min;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, LESS_THAN(\"max\")), { optional: true })\n], Navigator.prototype, \"min\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(max) {\n      this._max = max;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, GREATER_THAN(\"min\")), { optional: true })\n], Navigator.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Navigator(ctx),\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: \"#999999\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/theme.ts\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return { fill, stroke };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 17] = \"LARGE\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_WEIGHT2 = /* @__PURE__ */ ((FONT_WEIGHT3) => {\n  FONT_WEIGHT3[\"NORMAL\"] = \"normal\";\n  FONT_WEIGHT3[\"BOLD\"] = \"bold\";\n  FONT_WEIGHT3[\"BOLDER\"] = \"bolder\";\n  FONT_WEIGHT3[\"LIGHTER\"] = \"lighter\";\n  return FONT_WEIGHT3;\n})(FONT_WEIGHT2 || {});\nvar POSITION2 = /* @__PURE__ */ ((POSITION3) => {\n  POSITION3[\"TOP\"] = \"top\";\n  POSITION3[\"RIGHT\"] = \"right\";\n  POSITION3[\"BOTTOM\"] = \"bottom\";\n  POSITION3[\"LEFT\"] = \"left\";\n  return POSITION3;\n})(POSITION2 || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar DEFAULT_FONT_FAMILY = Symbol(\"default-font\");\nvar DEFAULT_LABEL_COLOUR = Symbol(\"default-label-colour\");\nvar DEFAULT_INVERTED_LABEL_COLOUR = Symbol(\"default-inverted-label-colour\");\nvar DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol(\"default-inside-series-label-colour\");\nvar DEFAULT_MUTED_LABEL_COLOUR = Symbol(\"default-muted-label-colour\");\nvar DEFAULT_AXIS_GRID_COLOUR = Symbol(\"default-axis-grid-colour\");\nvar DEFAULT_AXIS_LINE_COLOUR = Symbol(\"default-axis-line-colour\");\nvar DEFAULT_CROSS_LINES_COLOUR = Symbol(\"default-cross-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_COLOURS = Symbol(\"default-colours\");\nvar DEFAULT_PADDING = Symbol(\"default-padding\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar PALETTE_ALT_UP_STROKE = Symbol(\"palette-alt-up-stroke\");\nvar PALETTE_ALT_DOWN_STROKE = Symbol(\"palette-alt-down-stroke\");\nvar PALETTE_ALT_UP_FILL = Symbol(\"palette-alt-up-fill\");\nvar PALETTE_ALT_DOWN_FILL = Symbol(\"palette-alt-down-fill\");\nvar PALETTE_ALT_NEUTRAL_FILL = Symbol(\"palette-gray-fill\");\nvar PALETTE_ALT_NEUTRAL_STROKE = Symbol(\"palette-gray-stroke\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_ANNOTATION_COLOR = Symbol(\"default-annotation-stroke\");\nvar DEFAULT_TEXT_ANNOTATION_COLOR = Symbol(\"default-text-annotation-color\");\nvar DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol(\"default-annotation-background-fill\");\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_TEXTBOX_FILL = Symbol(\"default-textbox-fill\");\nvar DEFAULT_TEXTBOX_STROKE = Symbol(\"default-textbox-stroke\");\nvar DEFAULT_TEXTBOX_COLOR = Symbol(\"default-textbox-color\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio2, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio2, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return;\n  } else if (text === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isMarkerShape(value) || typeof value === \"function\" && Object.create(value.prototype) instanceof Marker,\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\n    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n  }\n  toTooltipHtml(defaults, params) {\n    if (this.renderer) {\n      return toTooltipHtml(this.renderer(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/scene/util/bezier.ts\nfunction evaluateBezier(p0, p1, p2, p3, t) {\n  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) + t ** 2 * p2 + t ** 3 * p3;\n}\nfunction solveBezier(p0, p1, p2, p3, value) {\n  if (value <= Math.min(p0, p3)) {\n    return p0 < p3 ? 0 : 1;\n  } else if (value >= Math.max(p0, p3)) {\n    return p0 < p3 ? 1 : 0;\n  }\n  let t0 = 0;\n  let t1 = 1;\n  let t = NaN;\n  for (let i = 0; i < 8; i += 1) {\n    t = (t0 + t1) / 2;\n    const curveValue = (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n    if (curveValue < value) {\n      t0 = t;\n    } else {\n      t1 = t;\n    }\n  }\n  return t;\n}\nfunction splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {\n  const x01 = (1 - t) * p0x + t * p1x;\n  const y01 = (1 - t) * p0y + t * p1y;\n  const x12 = (1 - t) * p1x + t * p2x;\n  const y12 = (1 - t) * p1y + t * p2y;\n  const x23 = (1 - t) * p2x + t * p3x;\n  const y23 = (1 - t) * p2y + t * p3y;\n  const x012 = (1 - t) * x01 + t * x12;\n  const y012 = (1 - t) * y01 + t * y12;\n  const x123 = (1 - t) * x12 + t * x23;\n  const y123 = (1 - t) * y12 + t * y23;\n  const x0123 = (1 - t) * x012 + t * x123;\n  const y0123 = (1 - t) * y012 + t * y123;\n  return [\n    [\n      { x: p0x, y: p0y },\n      { x: x01, y: y01 },\n      { x: x012, y: y012 },\n      { x: x0123, y: y0123 }\n    ],\n    [\n      { x: x0123, y: y0123 },\n      { x: x123, y: y123 },\n      { x: x23, y: y23 },\n      { x: p3x, y: p3y }\n    ]\n  ];\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts\nfunction spanRange(span) {\n  switch (span.type) {\n    case \"linear\":\n    case \"step\":\n      return [\n        { x: span.x0, y: span.y0 },\n        { x: span.x1, y: span.y1 }\n      ];\n    case \"cubic\":\n      return [\n        { x: span.cp0x, y: span.cp0y },\n        { x: span.cp3x, y: span.cp3y }\n      ];\n  }\n}\nfunction reverseSpan(span) {\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: span.x1,\n        y0: span.y1,\n        x1: span.x0,\n        y1: span.y0\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: span.cp3x,\n        cp0y: span.cp3y,\n        cp1x: span.cp2x,\n        cp1y: span.cp2y,\n        cp2x: span.cp1x,\n        cp2y: span.cp1y,\n        cp3x: span.cp0x,\n        cp3y: span.cp0y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: span.x1,\n        y0: span.y1,\n        x1: span.x0,\n        y1: span.y0,\n        stepX: span.stepX\n      };\n  }\n}\nfunction collapseSpanToPoint(span, point) {\n  const { x, y } = point;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y,\n        stepX: x\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: x,\n        cp0y: y,\n        cp1x: x,\n        cp1y: y,\n        cp2x: x,\n        cp2y: y,\n        cp3x: x,\n        cp3y: y\n      };\n  }\n}\nfunction rescaleSpan(span, nextStart, nextEnd) {\n  const [prevStart, prevEnd] = spanRange(span);\n  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;\n  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: nextStart.x,\n        cp0y: nextStart.y,\n        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,\n        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,\n        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,\n        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,\n        cp3x: nextEnd.x,\n        cp3y: nextEnd.y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y,\n        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale\n      };\n  }\n}\nfunction setMoveTo(span, moveTo) {\n  return span.moveTo !== moveTo ? { ...span, moveTo } : span;\n}\nfunction splitSpanAtX(span, x) {\n  const [start, end] = spanRange(span);\n  let x0;\n  let y0;\n  let x1;\n  let y1;\n  if (start.x < end.x) {\n    x0 = start.x;\n    y0 = start.y;\n    x1 = end.x;\n    y1 = end.y;\n  } else {\n    x0 = end.x;\n    y0 = end.y;\n    x1 = start.x;\n    y1 = start.y;\n  }\n  if (x < x0) {\n    return [rescaleSpan(span, start, start), setMoveTo(span, false)];\n  } else if (x > x1) {\n    return [span, setMoveTo(rescaleSpan(span, end, end), false)];\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const midY = y0 === y1 ? y0 : (y1 - y0) / (x1 - x0) * (x - x0) + y0;\n      return [\n        { type: \"linear\", moveTo: span.moveTo, x0, y0, x1: x, y1: midY },\n        { type: \"linear\", moveTo: false, x0: x, y0: midY, x1, y1 }\n      ];\n    }\n    case \"step\":\n      if (x < span.stepX) {\n        return [\n          { type: \"step\", moveTo: span.moveTo, x0, y0, x1: x, y1: y0, stepX: x },\n          { type: \"step\", moveTo: false, x0: x, y0, x1, y1, stepX: span.stepX }\n        ];\n      } else {\n        return [\n          { type: \"step\", moveTo: span.moveTo, x0, y0, x1: x, y1, stepX: span.stepX },\n          { type: \"step\", moveTo: false, x0: x, y0: y1, x1, y1, stepX: x }\n        ];\n      }\n    case \"cubic\": {\n      const t = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x);\n      const [a, b] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t\n      );\n      return [\n        {\n          type: \"cubic\",\n          moveTo: span.moveTo,\n          cp0x: a[0].x,\n          cp0y: a[0].y,\n          cp1x: a[1].x,\n          cp1y: a[1].y,\n          cp2x: a[2].x,\n          cp2y: a[2].y,\n          cp3x: a[3].x,\n          cp3y: a[3].y\n        },\n        {\n          type: \"cubic\",\n          moveTo: false,\n          cp0x: b[0].x,\n          cp0y: b[0].y,\n          cp1x: b[1].x,\n          cp1y: b[1].y,\n          cp2x: b[2].x,\n          cp2y: b[2].y,\n          cp3x: b[3].x,\n          cp3y: b[3].y\n        }\n      ];\n    }\n  }\n}\nfunction clipSpanX(span, x0, x1) {\n  const { moveTo } = span;\n  const [start, end] = spanRange(span);\n  let spanX0;\n  let spanY0;\n  let spanX1;\n  let spanY1;\n  if (start.x < end.x) {\n    spanX0 = start.x;\n    spanY0 = start.y;\n    spanX1 = end.x;\n    spanY1 = end.y;\n  } else {\n    spanX0 = end.x;\n    spanY0 = end.y;\n    spanX1 = start.x;\n    spanY1 = start.y;\n  }\n  if (x1 < spanX0) {\n    return rescaleSpan(span, start, start);\n  } else if (x0 > spanX1) {\n    return rescaleSpan(span, end, end);\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);\n      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;\n      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;\n      return { type: \"linear\", moveTo, x0, y0, x1, y1 };\n    }\n    case \"step\":\n      if (x1 <= span.stepX) {\n        const y = span.y0;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };\n      } else if (x0 >= span.stepX) {\n        const y = span.y1;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };\n      } else {\n        const { y0, y1, stepX } = span;\n        return { type: \"step\", moveTo, x0, y0, x1, y1, stepX };\n      }\n    case \"cubic\": {\n      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);\n      let [_unused, bezier] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t0\n      );\n      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);\n      [bezier, _unused] = splitBezier(\n        bezier[0].x,\n        bezier[0].y,\n        bezier[1].x,\n        bezier[1].y,\n        bezier[2].x,\n        bezier[2].y,\n        bezier[3].x,\n        bezier[3].y,\n        t1\n      );\n      return {\n        type: \"cubic\",\n        moveTo,\n        cp0x: bezier[0].x,\n        cp0y: bezier[0].y,\n        cp1x: bezier[1].x,\n        cp1y: bezier[1].y,\n        cp2x: bezier[2].x,\n        cp2y: bezier[2].y,\n        cp3x: bezier[3].x,\n        cp3y: bezier[3].y\n      };\n    }\n  }\n}\nfunction interpolateSpans(a, b, ratio2) {\n  if (a.type === \"cubic\" && b.type === \"cubic\") {\n    return {\n      type: \"cubic\",\n      moveTo: a.moveTo,\n      cp0x: (b.cp0x - a.cp0x) * ratio2 + a.cp0x,\n      cp0y: (b.cp0y - a.cp0y) * ratio2 + a.cp0y,\n      cp1x: (b.cp1x - a.cp1x) * ratio2 + a.cp1x,\n      cp1y: (b.cp1y - a.cp1y) * ratio2 + a.cp1y,\n      cp2x: (b.cp2x - a.cp2x) * ratio2 + a.cp2x,\n      cp2y: (b.cp2y - a.cp2y) * ratio2 + a.cp2y,\n      cp3x: (b.cp3x - a.cp3x) * ratio2 + a.cp3x,\n      cp3y: (b.cp3y - a.cp3y) * ratio2 + a.cp3y\n    };\n  } else if (a.type === \"step\" && b.type === \"step\") {\n    return {\n      type: \"step\",\n      moveTo: a.moveTo,\n      x0: (b.x0 - a.x0) * ratio2 + a.x0,\n      y0: (b.y0 - a.y0) * ratio2 + a.y0,\n      x1: (b.x1 - a.x1) * ratio2 + a.x1,\n      y1: (b.y1 - a.y1) * ratio2 + a.y1,\n      stepX: (b.stepX - a.stepX) * ratio2 + a.stepX\n    };\n  }\n  const [aStart, aEnd] = spanRange(a);\n  const [bStart, bEnd] = spanRange(b);\n  return {\n    type: \"linear\",\n    moveTo: a.moveTo,\n    x0: (bStart.x - aStart.x) * ratio2 + aStart.x,\n    y0: (bStart.y - aStart.y) * ratio2 + aStart.y,\n    x1: (bEnd.x - aEnd.x) * ratio2 + aEnd.x,\n    y1: (bEnd.y - aEnd.y) * ratio2 + aEnd.y\n  };\n}\nfunction plotSpan(path, span, moveTo = span.moveTo ? 1 /* MoveTo */ : 0 /* None */) {\n  const [start] = spanRange(span);\n  switch (moveTo) {\n    case 1 /* MoveTo */:\n      path.moveTo(start.x, start.y);\n      break;\n    case 2 /* LineTo */:\n      path.lineTo(start.x, start.y);\n      break;\n  }\n  switch (span.type) {\n    case \"linear\":\n      path.lineTo(span.x1, span.y1);\n      break;\n    case \"cubic\":\n      path.cubicCurveTo(span.cp1x, span.cp1y, span.cp2x, span.cp2y, span.cp3x, span.cp3y);\n      break;\n    case \"step\":\n      path.lineTo(span.stepX, span.y0);\n      path.lineTo(span.stepX, span.y1);\n      path.lineTo(span.x1, span.y1);\n      break;\n  }\n}\nfunction linearPoints(points) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      spans.push({ type: \"linear\", moveTo, x0, y0, x1, y1 });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction stepPoints(points, position) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  const p0 = typeof position === \"number\" ? position : lineSteps[position];\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      const stepX = x0 + (x1 - x0) * p0;\n      spans.push({ type: \"step\", moveTo, x0, y0, x1, y1, stepX });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar flatnessRatio = 0.05;\nfunction smoothPoints(iPoints, tension) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length <= 1)\n    return [];\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  const spans = [];\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    spans.push({\n      type: \"cubic\",\n      moveTo: i === 1,\n      cp0x: prev.x,\n      cp0y: prev.y,\n      cp1x: prev.x + dcp1x,\n      cp1y: prev.y + dcp1y,\n      cp2x: cur.x - dcp2x,\n      cp2y: cur.y - dcp2y,\n      cp3x: cur.x,\n      cp3y: cur.y\n    });\n  }\n  return spans;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = (datum) => {\n    const { xValue } = datum;\n    if (pairMap.moved[xValue]) {\n      return { point: readFirstPair(xValue, \"moved\"), status: \"updated\" };\n    } else if (pairMap.removed[xValue]) {\n      return { point: readFirstPair(xValue, \"removed\"), status: \"removed\" };\n    } else if (pairMap.added[xValue]) {\n      return { point: readFirstPair(xValue, \"added\"), status: \"added\" };\n    }\n    return { status: \"unknown\" };\n  };\n  const fromFn = (marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: point?.from?.x ?? marker.translationX,\n      translationY: point?.from?.y ?? marker.translationY,\n      opacity: marker.opacity,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (parentStatus === \"added\") {\n      return {\n        ...defaults,\n        opacity: 0,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"added\"]\n      };\n    }\n    if (status === \"added\") {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (status === \"removed\" || parentStatus === \"removed\") {\n      return {\n        ...defaults,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        opacity: 0,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"removed\"]\n      };\n    }\n    return defaults;\n  };\n  return { fromFn, toFn };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  if (datum === void 0 || datum.point === void 0)\n    return void 0;\n  const size = series.getFormattedMarkerStyle(datum).size;\n  const radius = size / 2;\n  const { x, y } = series.contentGroup.inverseTransformPoint(datum.point.x - radius, datum.point.y - radius);\n  return new BBox(x, y, size, size);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts\nfunction plotLinearPoints(path, points, continuePath) {\n  let didMove = continuePath;\n  for (const { x, y } of points) {\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n      didMove = true;\n    }\n  }\n}\nvar flatnessRatio2 = 0.05;\nfunction plotSmoothPoints(path, iPoints, tension, continuePath) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length === 0)\n    return;\n  if (continuePath) {\n    path.lineTo(points[0].x, points[0].y);\n  } else {\n    path.moveTo(points[0].x, points[0].y);\n  }\n  if (points.length <= 1)\n    return;\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio2 || 1 - prevRatio <= flatnessRatio2 || nextRatio <= flatnessRatio2 || 1 - nextRatio <= flatnessRatio2) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);\n  }\n}\nfunction plotStepPoints(path, points, align, continuePath) {\n  let lastPoint;\n  for (const point of points) {\n    if (lastPoint != null) {\n      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;\n      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;\n      path.lineTo(x, lastPoint?.y ?? point.y);\n      path.lineTo(x, point.y);\n      path.lineTo(point.x, point.y);\n    } else if (continuePath) {\n      path.lineTo(point.x, point.y);\n    } else {\n      path.moveTo(point.x, point.y);\n    }\n    lastPoint = point;\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction minMax(nodeData) {\n  return nodeData.reduce(\n    ({ min, max }, node) => {\n      if (min == null || min.point.x > node.point.x) {\n        min = node;\n      }\n      if (max == null || max.point.x < node.point.x) {\n        max = node;\n      }\n      return { min, max };\n    },\n    {}\n  );\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  const y = (targetX - a.x) * m + a.y;\n  return { x: targetX, y };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1, nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, \"out\", \"in\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.to = result[sIdx].from);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.from && result[eIdx]?.from) {\n      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach((d) => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, \"in\", \"out\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.from = result[sIdx].to);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.to && result[eIdx]?.to) {\n      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach((d) => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from2, to, ratio2) {\n  const x1 = isNaN(from2.x) ? to.x : from2.x;\n  const y1 = isNaN(from2.y) ? to.y : from2.y;\n  const xd = to.x - from2.x;\n  const yd = to.y - from2.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio2;\n  const yr = isNaN(yd) ? 0 : yd * ratio2;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nvar lineSteps2 = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction plotPath(points, path, interpolation, continuePath = false) {\n  const { path: linePath } = path;\n  if (interpolation?.type === \"smooth\") {\n    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);\n  } else if (interpolation?.type === \"step\") {\n    plotStepPoints(linePath, points, lineSteps2[interpolation.position ?? \"end\"], continuePath);\n  } else {\n    plotLinearPoints(linePath, points, continuePath);\n  }\n}\nfunction splitPairData(pairData, ratios) {\n  let previousTo;\n  let points = void 0;\n  const out = [];\n  const flushCurrent = () => {\n    if (points != null) {\n      out.push(points);\n      points = void 0;\n    }\n  };\n  for (const data of pairData) {\n    const { from: from2, to } = data;\n    const ratio2 = ratios[data.change];\n    if (ratio2 == null || from2 == null || to == null)\n      continue;\n    const point = calculatePoint(from2, to, ratio2);\n    if (data.moveTo === false) {\n      points ?? (points = []);\n      points.push(point);\n    } else if (data.moveTo === true || !previousTo) {\n      flushCurrent();\n      points = [point];\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === \"in\" ? ratio2 : 1 - ratio2;\n      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);\n      points ?? (points = []);\n      points.push({ x: midPointX, y: midPointY });\n      flushCurrent();\n      points = [point];\n    }\n    previousTo = point;\n  }\n  flushCurrent();\n  return out;\n}\nfunction renderPartialPath(pairData, ratios, path, interpolation) {\n  splitPairData(pairData, ratios).forEach((points) => {\n    plotPath(points, path, interpolation);\n  });\n}\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width },\n    {\n      phase: \"initial\",\n      start: { clipMode: \"normal\", clipY: height, visible },\n      finish: { clipMode: void 0, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: \"remove\" });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => {\n    return { visible: opts.getVisible(), opacity: opts.getOpacity(), clipScalingX: 1, clipMode: void 0 };\n  };\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areEqual(a, b) {\n  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && areEqual(a, b);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return areEqual(a, b);\n  }\n  return false;\n}\nfunction isScaleValid(scale2) {\n  if (scale2 == null)\n    return false;\n  if (!scale2.range.every((v) => Number.isFinite(v)))\n    return false;\n  if (scale2.type === \"category\") {\n    return scale2.domain.every((v) => v != null);\n  }\n  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction* pathRanges(points) {\n  let start = -1;\n  let end = 0;\n  for (const { point } of points) {\n    if (point.moveTo) {\n      const range3 = start >= 0 ? { start, end } : void 0;\n      start = end;\n      end = start;\n      if (range3 !== void 0) {\n        yield range3;\n      }\n    }\n    end += 1;\n  }\n  if (start !== -1) {\n    yield { start, end };\n  }\n}\nfunction* pathRangePoints(points, { start, end }) {\n  for (let i = start; i < end; i += 1) {\n    yield points[i].point;\n  }\n}\nfunction* pathRangePointsReverse(points, { start, end }) {\n  for (let i = end - 1; i >= start; i -= 1) {\n    yield points[i].point;\n  }\n}\nfunction integratedCategoryMatch(a, b) {\n  if (a == null || b == null)\n    return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\")\n    return false;\n  if (\"id\" in a && \"id\" in b) {\n    return a.id === b.id;\n  }\n  return a.toString() === b.toString();\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));\n  if (matchingIntegratedIndex >= 0) {\n    return scaling.range[matchingIntegratedIndex];\n  }\n  return NaN;\n}\nfunction scalesChanged(newData, oldData) {\n  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from2 = false, to = false) {\n  if (from2 === to) {\n    return Boolean(from2);\n  }\n  return from2 ? \"in\" : \"out\";\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  const { backfillSplitMode = \"intersect\" } = opts;\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from2, to, xValue, change = \"move\") => {\n    if (from2 && (isNaN(from2.point.x) || isNaN(from2.point.y))) {\n      from2 = to;\n    }\n    const resultPoint = {\n      from: from2?.point,\n      to: to?.point,\n      moveTo: calculateMoveTo(from2?.point.moveTo, to?.point.moveTo),\n      change\n    };\n    if (change === \"move\") {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === \"in\") {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === \"out\") {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\n  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from2 = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from2 ? scale(from2.xValue ?? NaN, newData.scales.x) : void 0;\n    const toUnshifted = to ? scale(to.xValue ?? NaN, oldData.scales.x) : void 0;\n    const NA = void 0;\n    if (fromShifted != null && closeMatch(fromShifted, to?.point.x)) {\n      pairUp(from2, to, to.xValue, \"move\");\n    } else if (fromShifted != null && fromShifted < (minToNode?.point.x ?? -Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (fromShifted != null && fromShifted > (maxToNode?.point.x ?? Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < (minFromNode?.point.x ?? -Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (toUnshifted != null && toUnshifted > (maxFromNode?.point.x ?? Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (fromShifted != null && fromShifted < to?.point.x) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < from2?.point.x) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (from2) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (to) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else {\n      throw new Error(\"Unable to process points\");\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap };\n}\nfunction pairCategoryData(newData, oldData, diff2, opts = {}) {\n  const { backfillSplitMode = \"intersect\", multiDatum = false } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pointResultMapping = {\n    in: \"added\",\n    move: \"moved\",\n    out: \"removed\"\n  };\n  let previousResultPoint = void 0;\n  let previousXValue = void 0;\n  const addToResultMap = (xValue, newPoint) => {\n    var _a;\n    const type = pointResultMapping[newPoint.change];\n    if (multiDatum) {\n      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);\n      resultMapMulti[type][xValue].push(newPoint);\n    } else {\n      resultMapSingle[type][xValue] = newPoint;\n    }\n    previousResultPoint = newPoint;\n    previousXValue = transformIntegratedCategoryValue(xValue);\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    const bXValue = transformIntegratedCategoryValue(before?.xValue);\n    const aXValue = transformIntegratedCategoryValue(after?.xValue);\n    let resultPoint;\n    if (bXValue === aXValue) {\n      resultPoint = {\n        change: \"move\",\n        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff2?.removed.has(String(bXValue))) {\n      resultPoint = {\n        change: \"out\",\n        moveTo: before.point.moveTo ?? false,\n        from: before.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff2?.added.has(String(aXValue))) {\n      resultPoint = {\n        change: \"in\",\n        moveTo: after.point.moveTo ?? false,\n        to: after.point\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some((pathPoint) => {\n    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\n    if (marker === \"out\")\n      return;\n    const unordered = x < previousX;\n    previousX = x;\n    return unordered;\n  }));\n  if (isXUnordered) {\n    return { result: void 0, resultMap: void 0 };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };\n}\nfunction determinePathStatus(newData, oldData, pairData) {\n  let status = \"updated\";\n  const visible = (data) => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = \"added\";\n  } else if (visible(oldData) && !visible(newData)) {\n    status = \"removed\";\n  } else {\n    for (let i = 0; i < pairData.length; i++) {\n      if (pairData[i].change !== \"move\")\n        break;\n      if (pairData[i].from?.x !== pairData[i].to?.x)\n        break;\n      if (pairData[i].from?.y !== pairData[i].to?.y)\n        break;\n      if (i === pairData.length - 1)\n        return \"no-op\";\n    }\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {\n  const status = determinePathStatus(newData, oldData, pairData);\n  const removePhaseFn = (ratio2, path) => {\n    render(pairData, { move: 0, out: ratio2 }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio2, path) => {\n    render(pairData, { move: ratio2 }, path, interpolation);\n  };\n  const addPhaseFn = (ratio2, path) => {\n    render(pairData, { move: 1, in: ratio2 }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  if (pairData === void 0 || pairMap === void 0) {\n    return;\n  }\n  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== \"updated\";\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, \"fade\", interpolation, renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return { ...pathFns, marker, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts\nfunction closeCmp(a, b, delta3 = 1e-6) {\n  if (a === b || 1 - Math.min(a, b) / Math.max(a, b) < delta3) {\n    return 0;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\nfunction closeMatch2(a, b, delta3) {\n  if (a === b) {\n    return true;\n  }\n  const an = Number(a);\n  const bn = Number(b);\n  return Number.isFinite(an) && Number.isFinite(bn) && closeCmp(an, bn, delta3) === 0;\n}\nfunction transformSpans(spanData, { x: xScale, y: yScale }) {\n  let rangeSpanData;\n  const interpolatingInvalidSpans = [];\n  let shiftedXStart = Infinity;\n  let shiftedXEnd = -Infinity;\n  for (const spanDatum of spanData) {\n    const x0 = scale(spanDatum.xValue0, xScale);\n    const y0 = scale(spanDatum.yValue0, yScale);\n    const x1 = scale(spanDatum.xValue1, xScale);\n    const y1 = scale(spanDatum.yValue1, yScale);\n    const startIsFinite = Number.isFinite(x0);\n    const endIsFinite = Number.isFinite(x1);\n    if (startIsFinite && endIsFinite && rangeSpanData == null) {\n      const unshifted = spanDatum.span;\n      const shifted = rescaleSpan(unshifted, { x: x0, y: y0 }, { x: x1, y: y1 });\n      const spanTransform = { unshifted, shifted };\n      shiftedXStart = Math.min(shiftedXStart, x0);\n      shiftedXEnd = Math.max(shiftedXEnd, x1);\n      interpolatingInvalidSpans.push(spanTransform);\n    } else if (startIsFinite && !endIsFinite && rangeSpanData == null) {\n      rangeSpanData = [spanDatum];\n    } else if (!startIsFinite && !endIsFinite && rangeSpanData != null) {\n      if (rangeSpanData != null) {\n        rangeSpanData.push(spanDatum);\n      }\n    } else if (!startIsFinite && endIsFinite && rangeSpanData != null) {\n      rangeSpanData.push(spanDatum);\n      const startSpanDatum = rangeSpanData.at(0);\n      const endSpanDatum = rangeSpanData.at(-1);\n      const transformStart = {\n        x: scale(startSpanDatum.xValue0, xScale),\n        y: scale(startSpanDatum.yValue0, yScale)\n      };\n      const transformEnd = {\n        x: scale(endSpanDatum.xValue1, xScale),\n        y: scale(endSpanDatum.yValue1, yScale)\n      };\n      const step = (transformEnd.x - transformStart.x) / (rangeSpanData.length - 1);\n      for (let i = 0; i < rangeSpanData.length; i += 1) {\n        const { span: interpolatingUnshifted, yValue0, yValue1 } = rangeSpanData[i];\n        const interpolatingShifted = rescaleSpan(\n          interpolatingUnshifted,\n          { x: transformStart.x + step * (i + 0), y: scale(yValue0, yScale) },\n          { x: transformStart.x + step * (i + 1), y: scale(yValue1, yScale) }\n        );\n        interpolatingInvalidSpans.push({ unshifted: interpolatingUnshifted, shifted: interpolatingShifted });\n      }\n      shiftedXStart = Math.min(shiftedXStart, transformStart.x);\n      shiftedXEnd = Math.max(shiftedXEnd, transformEnd.x);\n      rangeSpanData = void 0;\n    } else if (!startIsFinite && endIsFinite && rangeSpanData == null) {\n      const unshifted = spanDatum.span;\n      const shifted = rescaleSpan(unshifted, { x: x1, y: y0 }, { x: x1, y: y1 });\n      interpolatingInvalidSpans.push({ unshifted, shifted });\n    } else {\n      rangeSpanData = void 0;\n    }\n  }\n  if (rangeSpanData != null) {\n    const startSpanDatum = rangeSpanData.at(0);\n    const x = scale(startSpanDatum.xValue0, xScale);\n    for (const { span: interpolatingUnshifted, yValue0, yValue1 } of rangeSpanData) {\n      const interpolatingShifted = rescaleSpan(\n        interpolatingUnshifted,\n        { x, y: scale(yValue0, yScale) },\n        { x, y: scale(yValue1, yScale) }\n      );\n      interpolatingInvalidSpans.push({ unshifted: interpolatingUnshifted, shifted: interpolatingShifted });\n    }\n  }\n  const shiftedXRange = [shiftedXStart, shiftedXEnd];\n  return { interpolatingInvalidSpans, shiftedXRange };\n}\nfunction pairUpSpans(newData, oldData, splitMode) {\n  const oldSpans = transformSpans(oldData.data, newData.scales);\n  const newSpans = transformSpans(newData.data, oldData.scales);\n  const [oldRangeStartNewScale, oldRangeEndNewScale] = oldSpans.shiftedXRange;\n  const [newRangeStartOldScale, newRangeEndOldScale] = newSpans.shiftedXRange;\n  const removed = [];\n  const moved = [];\n  for (const oldSpanDatum of oldSpans.interpolatingInvalidSpans) {\n    const oldSpanOldScale = oldSpanDatum.unshifted;\n    const oldSpanNewScale = oldSpanDatum.shifted;\n    const [{ x: fromStartOldScale, y: fromStartOldScaleY }, { x: fromEndOldScale, y: fromEndOldScaleY }] = spanRange(oldSpanOldScale);\n    let hasCorrespondingSpan = false;\n    for (const newSpanDatum of newSpans.interpolatingInvalidSpans) {\n      const newSpanOldScale = newSpanDatum.shifted;\n      const newSpanNewScale = newSpanDatum.unshifted;\n      const [{ x: toStartOldScale }, { x: toEndOldScale }] = spanRange(newSpanOldScale);\n      if (closeCmp(fromStartOldScale, toEndOldScale) !== -1 || closeCmp(fromEndOldScale, toStartOldScale) !== 1) {\n        continue;\n      }\n      if (closeMatch2(fromStartOldScale, toStartOldScale) && closeMatch2(fromEndOldScale, toEndOldScale)) {\n        removed.push({ from: oldSpanOldScale, to: oldSpanOldScale });\n        moved.push({ from: oldSpanOldScale, to: newSpanNewScale });\n      } else if (fromStartOldScale <= toStartOldScale && fromEndOldScale >= toEndOldScale) {\n        removed.push({ from: oldSpanOldScale, to: oldSpanOldScale });\n        moved.push({ from: oldSpanOldScale, to: oldSpanNewScale });\n      } else {\n        const [{ x: fromStartNewScale }, { x: fromEndNewScale }] = spanRange(oldSpanNewScale);\n        const [{ x: toStartNewScale }, { x: toEndNewScale }] = spanRange(newSpanNewScale);\n        const xRangeStartOldScale = Math.max(fromStartOldScale, toStartOldScale);\n        const xRangeEndOldScale = Math.min(fromEndOldScale, toEndOldScale);\n        const clippedOldSpanOldScale = clipSpanX(oldSpanOldScale, xRangeStartOldScale, xRangeEndOldScale);\n        const clippedNewSpanOldScale = clipSpanX(newSpanOldScale, xRangeStartOldScale, xRangeEndOldScale);\n        const xRangeStartNewScale = Math.max(fromStartNewScale, toStartNewScale);\n        const xRangeEndNewScale = Math.min(fromEndNewScale, toEndNewScale);\n        const clippedNewSpanNewScale = clipSpanX(newSpanNewScale, xRangeStartNewScale, xRangeEndNewScale);\n        removed.push({ from: clippedOldSpanOldScale, to: clippedNewSpanOldScale });\n        moved.push({ from: clippedNewSpanOldScale, to: clippedNewSpanNewScale });\n      }\n      hasCorrespondingSpan = true;\n    }\n    if (hasCorrespondingSpan)\n      continue;\n    if (closeCmp(fromEndOldScale, newRangeStartOldScale) !== 1) {\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(\n          oldSpanOldScale,\n          { x: newRangeStartOldScale, y: fromStartOldScaleY },\n          { x: newRangeStartOldScale, y: fromEndOldScaleY }\n        )\n      });\n    } else if (closeCmp(fromStartOldScale, newRangeEndOldScale) !== -1) {\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(\n          oldSpanOldScale,\n          { x: newRangeEndOldScale, y: fromStartOldScaleY },\n          { x: newRangeEndOldScale, y: fromEndOldScaleY }\n        )\n      });\n    } else if (splitMode === 0 /* Zero */) {\n      const y = scale(0, oldData.scales.y);\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(oldSpanOldScale, { x: fromStartOldScale, y }, { x: fromEndOldScale, y })\n      });\n    } else if (splitMode === 1 /* Divide */) {\n      const [left, right] = splitSpanAtX(oldSpanOldScale, (fromStartOldScale + fromEndOldScale) / 2);\n      removed.push(\n        { from: left, to: collapseSpanToPoint(left, { x: fromStartOldScale, y: fromStartOldScaleY }) },\n        { from: right, to: collapseSpanToPoint(right, { x: fromEndOldScale, y: fromEndOldScaleY }) }\n      );\n    }\n  }\n  const added = [];\n  for (const newSpanDatum of newData.data) {\n    const newSpanNewScale = newSpanDatum.span;\n    const [{ x: toStartNewScale, y: toStartNewScaleY }, { x: toEndNewScale, y: toEndNewScaleY }] = spanRange(newSpanNewScale);\n    let hasCorrespondingSpan = false;\n    for (const oldSpanDatum of oldSpans.interpolatingInvalidSpans) {\n      const oldSpanNewScale = oldSpanDatum.shifted;\n      const [{ x: fromStartNewScale }, { x: fromEndNewScale }] = spanRange(oldSpanNewScale);\n      if (closeCmp(fromStartNewScale, toEndNewScale) !== -1 || closeCmp(fromEndNewScale, toStartNewScale) !== 1) {\n        continue;\n      }\n      if (closeMatch2(fromStartNewScale, toStartNewScale) && closeMatch2(fromEndNewScale, toEndNewScale)) {\n        added.push({ from: newSpanNewScale, to: newSpanNewScale });\n      } else if (fromStartNewScale <= toStartNewScale && fromEndNewScale >= toEndNewScale) {\n        const clippedOldSpanNewScale = clipSpanX(oldSpanNewScale, toStartNewScale, toEndNewScale);\n        added.push({ from: clippedOldSpanNewScale, to: newSpanNewScale });\n      } else {\n        added.push({ from: newSpanNewScale, to: newSpanNewScale });\n      }\n      hasCorrespondingSpan = true;\n    }\n    if (hasCorrespondingSpan)\n      continue;\n    if (closeCmp(toEndNewScale, oldRangeStartNewScale) !== 1) {\n      added.push({\n        from: rescaleSpan(\n          newSpanNewScale,\n          { x: oldRangeStartNewScale, y: toStartNewScaleY },\n          { x: oldRangeStartNewScale, y: toEndNewScaleY }\n        ),\n        to: newSpanNewScale\n      });\n    } else if (closeCmp(toStartNewScale, oldRangeEndNewScale) !== -1) {\n      added.push({\n        from: rescaleSpan(\n          newSpanNewScale,\n          { x: oldRangeEndNewScale, y: toStartNewScaleY },\n          { x: oldRangeEndNewScale, y: toEndNewScaleY }\n        ),\n        to: newSpanNewScale\n      });\n    } else if (splitMode === 0 /* Zero */) {\n      const y = scale(0, newData.scales.y);\n      added.push({\n        from: rescaleSpan(newSpanNewScale, { x: toStartNewScale, y }, { x: toEndNewScale, y }),\n        to: newSpanNewScale\n      });\n    } else if (splitMode === 1 /* Divide */) {\n      const [left, right] = splitSpanAtX(newSpanNewScale, (toStartNewScale + toEndNewScale) / 2);\n      added.push(\n        { from: collapseSpanToPoint(left, { x: toStartNewScale, y: toStartNewScaleY }), to: newSpanNewScale },\n        { from: collapseSpanToPoint(right, { x: toEndNewScale, y: toEndNewScaleY }), to: newSpanNewScale }\n      );\n    }\n  }\n  return { added, moved, removed };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nvar AreaSeriesTag = /* @__PURE__ */ ((AreaSeriesTag2) => {\n  AreaSeriesTag2[AreaSeriesTag2[\"Fill\"] = 0] = \"Fill\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Stroke\"] = 1] = \"Stroke\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Marker\"] = 2] = \"Marker\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Label\"] = 3] = \"Label\";\n  return AreaSeriesTag2;\n})(AreaSeriesTag || {});\nfunction plotSpans(ratio2, path, spans, phantomSpans) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const span = spans[i];\n    const phantomSpan = phantomSpans[i];\n    plotSpan(path.path, interpolateSpans(span.from, span.to, ratio2), 1 /* MoveTo */);\n    plotSpan(path.path, reverseSpan(interpolateSpans(phantomSpan.from, phantomSpan.to, ratio2)), 2 /* LineTo */);\n    path.path.closePath();\n  }\n}\nfunction prepareAreaPathAnimationFns(status, spans, phantomSpans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.removed, phantomSpans.removed);\n  const updatePhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.moved, phantomSpans.moved);\n  const addPhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.added, phantomSpans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData, diff2) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const spans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.spans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.spans, visible: oldData.visible },\n    0 /* Zero */\n  );\n  const phantomSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.phantomSpans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.phantomSpans, visible: oldData.visible },\n    0 /* Zero */\n  );\n  const prepareMarkerPairs = () => {\n    if (isCategoryBased) {\n      return pairCategoryData(newData, oldData, diff2, { backfillSplitMode: \"static\", multiDatum: true });\n    }\n    return pairContinuousData(newData, oldData, { backfillSplitMode: \"static\" });\n  };\n  const { resultMap: markerPairMap } = prepareMarkerPairs();\n  if (markerPairMap === void 0)\n    return;\n  const stackVisible = true;\n  const fadeMode = stackVisible ? \"none\" : \"fade\";\n  const fill = prepareAreaPathAnimationFns(status, spans, phantomSpans, fadeMode);\n  const marker = prepareMarkerAnimation(markerPairMap, status);\n  return { status, fill, marker };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: [\"fill\", \"stroke\"],\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [1 /* NEAREST_BY_MAIN_AXIS_FIRST */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const currentIds = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      stack: `area-stack-${groupIndex}-yValue-stack`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(currentIds), normalizedTo, \"range\"));\n    }\n    if (!isContinuousX && animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...groupStackValueProperty(yKey, yScaleType, {\n          id: `yValueStack`,\n          ...common,\n          groupId: currentIds.stack\n        }),\n        valueProperty(yKey, yScaleType, {\n          id: `yValue`,\n          ...common,\n          groupId: currentIds.value\n        }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: currentIds.values\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: currentIds.marker\n          },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, \"value\", processedData);\n    if (direction === \"x\" /* X */) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys), xAxis);\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent, yAxis);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueEnd`, `yValueRaw`, `yValueCumulative`]);\n    const yValueStackIndex = dataModel.resolveProcessedDataIndexById(this, \"yValueStack\");\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const itemId = yKey;\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    let datumIdx = -1;\n    groupedData?.forEach((datumGroup) => {\n      const {\n        keys,\n        keys: [xDatum],\n        datum: datumArray,\n        values: valuesArray\n      } = datumGroup;\n      valuesArray.forEach((values, valueIdx) => {\n        datumIdx++;\n        const seriesDatum = datumArray[valueIdx];\n        const dataValues2 = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n        const { yValueRaw: yDatum, yValueCumulative, yValueEnd } = dataValues2;\n        const validPoint = Number.isFinite(yDatum);\n        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n        if (validPoint && marker) {\n          markerData.push({\n            index: datumIdx,\n            series: this,\n            itemId,\n            datum: seriesDatum,\n            midPoint: { x: point.x, y: point.y },\n            cumulativeValue: yValueEnd,\n            yValue: yDatum,\n            xValue: xDatum,\n            yKey,\n            xKey,\n            point,\n            fill: marker.fill ?? seriesFill,\n            stroke: marker.stroke ?? seriesStroke,\n            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth)\n          });\n        }\n        if (validPoint && label) {\n          const labelText = this.getLabelText(\n            label,\n            {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.properties.xName,\n              yName: this.properties.yName\n            },\n            (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n          );\n          labelData.push({\n            index: datumIdx,\n            series: this,\n            itemId: yKey,\n            datum: seriesDatum,\n            x: point.x,\n            y: point.y,\n            label: labelText ? {\n              text: labelText,\n              fontStyle: label.fontStyle,\n              fontWeight: label.fontWeight,\n              fontSize: label.fontSize,\n              fontFamily: label.fontFamily,\n              textAlign: \"center\",\n              textBaseline: \"bottom\",\n              fill: label.color\n            } : void 0\n          });\n        }\n      });\n    });\n    const { interpolation } = this.properties;\n    const interpolatePoints = (points) => {\n      let spans;\n      const pointsIter = points.map((point) => point.point);\n      switch (interpolation.type) {\n        case \"linear\":\n          spans = linearPoints(pointsIter);\n          break;\n        case \"smooth\":\n          spans = smoothPoints(pointsIter, interpolation.tension);\n          break;\n        case \"step\":\n          spans = stepPoints(pointsIter, interpolation.position);\n          break;\n      }\n      return spans.map((span, i) => ({\n        span,\n        xValue0: points[i].xDatum,\n        yValue0: points[i].yDatum,\n        xValue1: points[i + 1].xDatum,\n        yValue1: points[i + 1].yDatum\n      }));\n    };\n    const spansForPoints = (points) => {\n      return points.flatMap((p) => {\n        return Array.isArray(p) ? interpolatePoints(p) : new Array(p.skip).fill(null);\n      });\n    };\n    const dataValues = groupedData?.flatMap((datumGroup) => {\n      const {\n        keys: [xDatum],\n        values: valuesArray\n      } = datumGroup;\n      return valuesArray.map((values) => ({ xDatum, values }));\n    });\n    const createPoint = (xDatum, yDatum) => ({\n      point: {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(yDatum)\n      },\n      xDatum,\n      yDatum\n    });\n    const getSeriesSpans = (index) => {\n      const points = [];\n      if (dataValues == null)\n        return [];\n      for (let i = 0; i < dataValues.length; i += 1) {\n        const { xDatum, values } = dataValues[i];\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[index];\n        const yDatumIsFinite = Number.isFinite(yDatum);\n        if (connectMissingData && !yDatumIsFinite)\n          continue;\n        const lastYValueStack = dataValues[i - 1]?.values[yValueStackIndex];\n        const nextYValueStack = dataValues[i + 1]?.values[yValueStackIndex];\n        let yValueEndBackwards = 0;\n        let yValueEndForwards = 0;\n        for (let j = 0; j <= index; j += 1) {\n          const value = yValueStack[j];\n          if (Number.isFinite(value)) {\n            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);\n            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);\n            if (lastWasFinite) {\n              yValueEndBackwards += value;\n            }\n            if (nextWasFinite) {\n              yValueEndForwards += value;\n            }\n          }\n        }\n        const currentPoints = points[points.length - 1];\n        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {\n          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {\n            points[points.length - 1] = { skip: 1 };\n          } else {\n            const pointBackwards = createPoint(xDatum, yValueEndBackwards);\n            const pointForwards = createPoint(xDatum, yValueEndForwards);\n            if (Array.isArray(currentPoints)) {\n              currentPoints.push(pointBackwards);\n            } else if (currentPoints != null) {\n              currentPoints.skip += 1;\n            }\n            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });\n          }\n        } else {\n          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);\n          const point = createPoint(xDatum, yValueEnd);\n          if (Array.isArray(currentPoints)) {\n            currentPoints.push(point);\n          } else if (currentPoints != null) {\n            currentPoints.skip += 1;\n            points.push([point]);\n          } else {\n            points.push([point]);\n          }\n        }\n      }\n      return spansForPoints(points);\n    };\n    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;\n    const getAxisSpans = () => {\n      if (dataValues == null)\n        return [];\n      const yValueZeroPoints = dataValues.map(({ xDatum, values }) => {\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[stackIndex];\n        if (connectMissingData && !Number.isFinite(yDatum))\n          return;\n        return createPoint(xDatum, 0);\n      }).filter((x) => x != null);\n      return interpolatePoints(yValueZeroPoints);\n    };\n    const currentSeriesSpans = getSeriesSpans(stackIndex);\n    const phantomSpans = currentSeriesSpans.map(() => null);\n    for (let j = stackIndex - 1; j >= -1; j -= 1) {\n      let spans;\n      for (let i = 0; i < phantomSpans.length; i += 1) {\n        if (phantomSpans[i] != null)\n          continue;\n        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());\n        phantomSpans[i] = spans[i];\n      }\n    }\n    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);\n    const strokeSpans = currentSeriesSpans.filter((span) => span != null);\n    const context = {\n      itemId,\n      fillData: { itemId, spans: fillSpans, phantomSpans },\n      strokeData: { itemId, spans: strokeSpans },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0\n    };\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke] = opts.paths;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      tag: 1 /* Stroke */,\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible\n    });\n    fill.setProperties({\n      tag: 0 /* Fill */,\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      strokeOpacity: this.properties.strokeOpacity,\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled,\n      strokeWidth\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    this.updateFillPath(paths, contextData);\n    this.updateStrokePath(paths, contextData);\n  }\n  updateFillPath(paths, contextData) {\n    const { spans, phantomSpans } = contextData.fillData;\n    const [fill] = paths;\n    const { path } = fill;\n    path.clear(true);\n    for (let i = 0; i < spans.length; i += 1) {\n      const { span } = spans[i];\n      const phantomSpan = phantomSpans[i].span;\n      plotSpan(path, span, 1 /* MoveTo */);\n      plotSpan(path, reverseSpan(phantomSpan), 2 /* LineTo */);\n      path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { spans } = contextData.strokeData;\n    const [, stroke] = paths;\n    const { path } = stroke;\n    path.clear(true);\n    for (const { span } of spans) {\n      plotSpan(path, span);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 3 /* Label */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text, datum) => {\n      const { x, y, label } = datum;\n      if (label && labelEnabled && this.visible) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = x;\n        text.y = y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const { xKey, xName, yName, tooltip, marker } = this.properties;\n    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {\n      stroke: this.properties.stroke,\n      strokeWidth: this.properties.strokeWidth\n    });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        color,\n        title,\n        seriesId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yKey,\n      yName,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      marker,\n      visible,\n      legendItemName\n    } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return [\n      {\n        legendType,\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: useAreaFill ? fill : marker.fill,\n              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n              stroke: marker.stroke ?? stroke,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke] = paths;\n    if (fill == null && stroke == null)\n      return;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateAreaPaths(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    const fns = prepareAreaPathAnimation(contextData, previousContextData, this.processedData?.reduced?.diff);\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    this.updateStrokePath(paths, contextData);\n    pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  moduleFactory: (ctx) => new AreaSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { fill: marker.fill, stroke: marker.stroke, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction* childrenIter(parent) {\n  for (const node of parent.children) {\n    yield node;\n  }\n}\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      Logger.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = series.contentGroup.transformPoint(point.x, point.y);\n  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  updateGroupScale(xAxis) {\n    const {\n      groupScale,\n      smallestDataInterval,\n      ctx: { seriesStateManager }\n    } = this;\n    const xScale = xAxis.scale;\n    const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth;\n    const domain = [];\n    const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.padding = 0.1;\n    } else {\n      groupScale.padding = 0;\n    }\n    groupScale.round = groupScale.padding !== 0;\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside\";\n  }\n};\n__decorateClass([\n  Validate(PLACEMENT)\n], BarSeriesLabel.prototype, \"placement\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction updateRect(rect, config) {\n  rect.crisp = config.crisp ?? true;\n  rect.fill = config.fill;\n  rect.stroke = config.stroke;\n  rect.strokeWidth = config.strokeWidth;\n  rect.fillOpacity = config.fillOpacity;\n  rect.strokeOpacity = config.strokeOpacity;\n  rect.lineDash = config.lineDash;\n  rect.lineDashOffset = config.lineDashOffset;\n  rect.fillShadow = config.fillShadow;\n  rect.topLeftCornerRadius = config.topLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.topRightCornerRadius = config.topRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomRightCornerRadius = config.bottomRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomLeftCornerRadius = config.bottomLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.visible = config.visible ?? true;\n}\nfunction getRectConfig({\n  datum,\n  isHighlighted,\n  style,\n  highlightStyle,\n  itemStyler,\n  seriesId,\n  ctx: { callbackCache },\n  ...opts\n}) {\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    cornerRadius = 0\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  let format;\n  if (itemStyler) {\n    format = callbackCache.call(itemStyler, {\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      highlighted: isHighlighted,\n      seriesId,\n      ...opts\n    });\n  }\n  return {\n    fill: format?.fill ?? fill,\n    fillOpacity: format?.fillOpacity ?? fillOpacity,\n    stroke: format?.stroke ?? stroke,\n    strokeWidth: format?.strokeWidth ?? strokeWidth,\n    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n    lineDash: format?.lineDash ?? lineDash,\n    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n    cornerRadius: format?.cornerRadius ?? cornerRadius,\n    topLeftCornerRadius: style.topLeftCornerRadius,\n    topRightCornerRadius: style.topRightCornerRadius,\n    bottomRightCornerRadius: style.bottomRightCornerRadius,\n    bottomLeftCornerRadius: style.bottomLeftCornerRadius,\n    fillShadow: style.fillShadow\n  };\n}\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width = isVertical ? datum.width : 0;\n    let height = isVertical ? 0 : datum.height;\n    const { opacity } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width = isVertical ? prevDatum.width : 0;\n      height = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height, width, height) : new BBox(x - width, y, width, height);\n    } else {\n      clipBBox = new BBox(x, y, width, height);\n    }\n    return { x, y, width, height, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    let source;\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    }\n    return source;\n  };\n  return { toFn, fromFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(_node, { x, y, width, height, clipBBox, opacity }) {\n  return { x, y, width, height, clipBBox, opacity };\n}\nfunction computeBarFocusBounds(datum, barGroup, seriesRect) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width, height } = datum;\n  return barGroup.inverseTransformBBox(new BBox(x, y, width, height)).clip(seriesRect);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nfunction adjustLabelPlacement({\n  isPositive,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  switch (placement) {\n    case \"start\": {\n      if (isVertical) {\n        y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\n        textBaseline = isPositive ? \"top\" : \"bottom\";\n      } else {\n        x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n    case \"outside\":\n    case \"end\": {\n      if (isVertical) {\n        y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\n        textBaseline = isPositive ? \"bottom\" : \"top\";\n      } else {\n        x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      pathsPerSeries: [],\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n  }\n  crossFilteringEnabled() {\n    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\n    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const extraProps = [];\n    if (isFiniteNumber(normalizedTo)) {\n      extraProps.push(\n        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), \"range\")\n      );\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),\n        ...this.crossFilteringEnabled() ? [\n          valueProperty(yFilterKey, yScaleType, {\n            id: `yFilterValue`,\n            invalidValue: null,\n            ...visibleProps\n          })\n        ] : [],\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    let yExtent = dataModel.getDomain(this, `yValue-end`, \"value\", processedData);\n    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, \"value\", processedData) : void 0;\n    if (yFilterExtent != null) {\n      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];\n    }\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      const scalePadding = isFiniteNumber(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;\n      const keysExtent = extent(keys) ?? [NaN, NaN];\n      const d0 = keysExtent[0] + -scalePadding;\n      const d1 = keysExtent[1] + scalePadding;\n      return fixNumericExtent([d0, d1], categoryAxis);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent, valueAxis);\n    } else {\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent(fixedYExtent, valueAxis);\n    }\n  }\n  async createNodeData() {\n    const { dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);\n    const yFilterIndex = this.crossFilteringEnabled() ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);\n    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);\n    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const nodeDatum = ({\n      datum,\n      valueIndex,\n      xValue,\n      yValue,\n      cumulativeValue,\n      phantom,\n      currY,\n      prevY,\n      isPositive,\n      yRange,\n      labelText,\n      crossScale = 1\n    }) => {\n      const x = xScale.convert(xValue);\n      const isUpward = isPositive !== yReversed;\n      const barX = x + groupScale.convert(String(groupIndex)) + barOffset;\n      const y = yScale.convert(currY);\n      const bottomY = yScale.convert(prevY);\n      const barAlongX = this.getBarDirection() === \"x\" /* X */;\n      const bboxHeight = yScale.convert(yRange);\n      const bboxBottom = yScale.convert(0);\n      const xOffset = barWidth * 0.5 * (1 - crossScale);\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(y, bottomY),\n        width: barAlongX ? Math.abs(bottomY - y) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bottomY - y)\n      };\n      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n      const barRect = {\n        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(bboxBottom, bboxHeight),\n        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bboxBottom - bboxHeight)\n      };\n      const {\n        fontStyle: labelFontStyle,\n        fontWeight: labelFontWeight,\n        fontSize: labelFontSize,\n        fontFamily: labelFontFamily,\n        color: labelColor,\n        placement\n      } = label;\n      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n      return {\n        series: this,\n        itemId: phantom ? createDatumId(yKey, phantom) : yKey,\n        datum,\n        valueIndex,\n        cumulativeValue,\n        phantom,\n        xValue,\n        yValue,\n        yKey,\n        xKey,\n        capDefaults: {\n          lengthRatioMultiplier,\n          lengthMax: lengthRatioMultiplier\n        },\n        x: barRect.x,\n        y: barRect.y,\n        width: barRect.width,\n        height: barRect.height,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        fill,\n        stroke,\n        opacity: 1,\n        strokeWidth,\n        cornerRadius,\n        topLeftCornerRadius: barAlongX !== isUpward,\n        topRightCornerRadius: isUpward,\n        bottomRightCornerRadius: barAlongX === isUpward,\n        bottomLeftCornerRadius: !isUpward,\n        clipBBox,\n        label: labelText != null ? {\n          text: labelText,\n          fill: labelColor,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          ...adjustLabelPlacement({\n            isPositive,\n            isVertical: !barAlongX,\n            placement,\n            rect\n          })\n        } : void 0,\n        missing: yValue == null,\n        focusable: !phantom\n      };\n    };\n    const { groupScale, processedData } = this;\n    const phantomNodes = [];\n    const nodes = [];\n    const labels = [];\n    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {\n      values.forEach((value, valueIndex) => {\n        const xValue = keys[xIndex];\n        const yRawValue = value[yRawIndex];\n        const yStart = Number(value[yStartIndex]);\n        const yFilterValue = yFilterIndex != null ? Number(value[yFilterIndex]) : void 0;\n        const yEnd = Number(value[yEndIndex]);\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;\n        if (!Number.isFinite(yEnd))\n          return;\n        if (yFilterValue != null && !Number.isFinite(yFilterValue))\n          return;\n        const labelText = yRawValue != null ? this.getLabelText(\n          this.properties.label,\n          {\n            datum: seriesDatum[valueIndex],\n            value: yFilterValue ?? yRawValue,\n            xKey,\n            yKey,\n            xName,\n            yName,\n            legendItemName\n          },\n          (v) => isFiniteNumber(v) ? v.toFixed(2) : String(v)\n        ) : void 0;\n        const inset = yFilterValue != null && yFilterValue > yRawValue;\n        const nodeData = nodeDatum({\n          datum: seriesDatum[valueIndex],\n          valueIndex,\n          xValue,\n          yValue: yFilterValue ?? yRawValue,\n          cumulativeValue: yFilterValue ?? yEnd,\n          phantom: false,\n          currY: yFilterValue != null ? yStart + yFilterValue : yEnd,\n          prevY: yStart,\n          isPositive,\n          yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),\n          labelText,\n          crossScale: inset ? 0.6 : void 0\n        });\n        nodes.push(nodeData);\n        labels.push(nodeData);\n        if (yFilterValue != null) {\n          const phantomNodeData = nodeDatum({\n            datum: seriesDatum[valueIndex],\n            valueIndex,\n            xValue,\n            yValue: yFilterValue,\n            cumulativeValue: yFilterValue,\n            phantom: true,\n            currY: yEnd,\n            prevY: yStart,\n            isPositive,\n            yRange,\n            labelText: void 0,\n            crossScale: void 0\n          });\n          phantomNodes.push(phantomNodeData);\n        }\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,\n      labelData: labels,\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled\n    };\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItem = nodeData.find(\n      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom\n    );\n    return highlightItem != null ? [highlightItem] : void 0;\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom)\n    );\n  }\n  async updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      stackGroup,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      shadow,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[\"x\" /* X */];\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    const style = {\n      fill,\n      stroke,\n      lineDash,\n      lineDashOffset,\n      fillShadow: shadow,\n      strokeWidth: this.getStrokeWidth(strokeWidth),\n      fillOpacity: 0,\n      strokeOpacity: 0\n    };\n    const rectParams = {\n      datum: void 0,\n      ctx: this.ctx,\n      seriesId: this.id,\n      isHighlighted: opts.isHighlight,\n      highlightStyle: itemHighlightStyle,\n      yKey,\n      style,\n      itemStyler,\n      stackGroup\n    };\n    opts.datumSelection.each((rect, datum) => {\n      style.fillOpacity = fillOpacity * (datum.phantom ? 0.2 : 1);\n      style.strokeOpacity = strokeOpacity * (datum.phantom ? 0.2 : 1);\n      style.cornerRadius = datum.cornerRadius;\n      style.topLeftCornerRadius = datum.topLeftCornerRadius;\n      style.topRightCornerRadius = datum.topRightCornerRadius;\n      style.bottomRightCornerRadius = datum.bottomRightCornerRadius;\n      style.bottomLeftCornerRadius = datum.bottomLeftCornerRadius;\n      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      rectParams.datum = datum;\n      const config = getRectConfig(rectParams);\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect(rect, config);\n    });\n  }\n  async updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text) => {\n      text.pointerEvents = 1 /* None */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;\n    const { xValue, yValue, datum, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        stackGroup,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        cornerRadius: this.properties.cornerRadius,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        lineDash: this.properties.lineDash ?? [],\n        lineDashOffset: this.properties.lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        stackGroup,\n        title,\n        color,\n        legendItemName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.data?.length || !this.properties.isValid() || !showInLegend) {\n      return [];\n    }\n    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? yName ?? yKey },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  moduleFactory: (ctx) => new BarSeries(ctx),\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  swapDefaultAxesCondition: (series) => series?.direction === \"horizontal\",\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        placement: \"inside\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta = 1e-6;\nvar isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class {\n  constructor() {\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const { xKey, yKey, sizeKey, labelKey, colorDomain, colorRange, colorKey, marker } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale } = this;\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, label, colorKey, marker, visible } = this.properties;\n    const markerShape = getMarker(marker.shape);\n    const { placement } = label;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : -1;\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = textMeasurer.measureText(String(labelText));\n      const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue: values[sizeDataIdx],\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      marker.getStyle()\n    );\n    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }))\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;\n    const title = this.properties.title ?? yName;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },\n      baseStyle\n    );\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: { text: labelText },\n      itemId\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id\n      }\n    );\n  }\n  getLegendData() {\n    if (!this.data?.length || !this.properties.isValid()) {\n      return [];\n    }\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  moduleFactory: (ctx) => new BubbleSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start, stop, binSize, segments);\n  }\n  getBins(start, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start + i * step) * precision) / precision;\n      let b = Math.round((start + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start = Math.floor(a / magnitude) * magnitude;\n    return {\n      start,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (item) => {\n        const xValue = item.keys[0];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, { props, groupByFn });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      axes,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;\n    const {\n      formatter: labelFormatter = (params) => String(params.value),\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor\n    } = this.properties.label;\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || !processedData || processedData.type !== \"grouped\")\n      return context;\n    processedData.data.forEach((group) => {\n      const {\n        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n        datum,\n        datum: { length: frequency },\n        keys: domain,\n        keys: [xDomainMin, xDomainMax]\n      } = group;\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          text: callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName,\n            yName\n          }) ?? String(total),\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          fill: labelColor,\n          x: x + w / 2,\n          y: y + h / 2\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        cornerRadius,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        opacity: 1,\n        strokeWidth,\n        label: selectionDatumLabel\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(\n      nodeData,\n      (rect) => {\n        rect.tag = 0 /* Bin */;\n        rect.crisp = true;\n      },\n      (datum) => datum.domain.join(\"_\")\n    );\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      fillOpacity: seriesFillOpacity,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      shadow,\n      highlightStyle: {\n        item: {\n          fill: highlightedFill,\n          fillOpacity: highlightFillOpacity = seriesFillOpacity,\n          stroke: highlightedStroke,\n          strokeWidth: highlightedDatumStrokeWidth\n        }\n      }\n    } = this.properties;\n    opts.datumSelection.each((rect, datum, index) => {\n      const {\n        cornerRadius,\n        topLeftCornerRadius,\n        topRightCornerRadius,\n        bottomRightCornerRadius,\n        bottomLeftCornerRadius\n      } = datum;\n      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;\n      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;\n      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;\n      rect.fillOpacity = fillOpacity;\n      rect.strokeOpacity = strokeOpacity;\n      rect.strokeWidth = strokeWidth;\n      rect.lineDash = lineDash;\n      rect.lineDashOffset = lineDashOffset;\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.fillShadow = shadow;\n      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n      rect.visible = datum.height > 0;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      text.textAlign = \"center\";\n      text.textBaseline = \"middle\";\n    });\n  }\n  async updateLabelNodes(opts) {\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text, datum) => {\n      const label = datum.label;\n      if (label && labelEnabled) {\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fontStyle = label.fontStyle;\n        text.fontWeight = label.fontWeight;\n        text.fontSize = label.fontSize;\n        text.fontFamily = label.fontFamily;\n        text.fill = label.fill;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, childrenIter(this.contentGroup.children[0]));\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax],\n      itemId\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : \"\";\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      itemId,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId: this.id\n    });\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || legendType !== \"category\") {\n      return [];\n    }\n    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: xKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: yName ?? xKey ?? \"Frequency\"\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity,\n              strokeOpacity,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  moduleFactory: (ctx) => new HistogramSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return { fill, stroke };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new LineSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (stackCount > 1) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: ids[0]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          {\n            id: `yValueStart`,\n            ...common,\n            groupId: ids[1]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: ids[2]\n          },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, \"range\"));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.processedData));\n      }\n    }\n    await this.requestDataModel(dataController, data, { props });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === \"x\" /* X */) {\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain), xAxis);\n    } else {\n      const stackCount = this.seriesGrouping?.stackCount ?? 1;\n      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, \"value\", processedData) : dataModel.getDomain(this, `yValueRaw`, \"value\", processedData);\n      return fixNumericExtent(domain, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { processedData, dataModel, axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!processedData || !dataModel || !xAxis || !yAxis) {\n      return;\n    }\n    const { xKey, yKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;\n    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const size = marker.enabled ? marker.size : 0;\n    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);\n    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;\n    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;\n    let moveTo = true;\n    processedData.data?.forEach(({ datum, values }) => {\n      const xDatum = values[xIdx];\n      const yDatum = values[yIdx];\n      const yCumulativeDatum = values[yCumulativeIdx];\n      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;\n      if (yDatum == null) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const x = xScale.convert(xDatum) + xOffset;\n      if (isNaN(x)) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const y = yScale.convert(yCumulativeDatum) + yOffset;\n      const labelText = this.getLabelText(\n        label,\n        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },\n        (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n      );\n      nodeData.push({\n        series: this,\n        datum,\n        yKey,\n        xKey,\n        point: { x, y, moveTo, size },\n        midPoint: { x, y },\n        cumulativeValue: yEndDatum,\n        yValue: yDatum,\n        xValue: xDatum,\n        capDefaults: {\n          lengthRatioMultiplier: this.properties.marker.getDiameter(),\n          lengthMax: Infinity\n        },\n        label: labelText ? {\n          text: labelText,\n          fontStyle: label.fontStyle,\n          fontWeight: label.fontWeight,\n          fontSize: label.fontSize,\n          fontFamily: label.fontFamily,\n          textAlign: \"center\",\n          textBaseline: \"bottom\",\n          fill: label.color\n        } : void 0\n      });\n      moveTo = false;\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  async updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const { shape, enabled } = this.properties.marker;\n    nodeData = shape && enabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  async updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text, datum) => {\n      const { point, label } = datum;\n      if (datum && label && enabled) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = point.x;\n        text.y = point.y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(this.properties.title ?? yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!(this.data?.length && this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        legendItemName,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? color0,\n              stroke: marker.stroke ?? stroke ?? color0,\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled\n            },\n            line: {\n              stroke: stroke ?? color0,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  async updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  updateLinePaths(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { nodeData } = contextData;\n    const [lineNode] = paths;\n    lineNode.path.clear(true);\n    for (const range3 of pathRanges(nodeData)) {\n      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);\n    }\n    lineNode.checkPathDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    const fns = prepareLinePathAnimation(\n      contextData,\n      previousContextData,\n      this.processedData?.reduced?.diff,\n      this.properties.interpolation\n    );\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.pathProperties);\n    pathMotion(this.id, \"path_update\", animationManager, [path], fns.path);\n    if (fns.hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  moduleFactory: (ctx) => new LineSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale } = this;\n    const { xKey, yKey, labelKey, colorKey, xName, yName, labelName, marker, label, visible } = this.properties;\n    const { placement } = label;\n    const markerShape = getMarker(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = textMeasurer.measureText(labelText);\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map(({ datum, x, y }) => ({\n        ...datum,\n        point: { x, y, size: datum.point.size },\n        placement: \"top\"\n      })),\n      (text) => {\n        text.pointerEvents = 1 /* None */;\n      }\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, label, itemId } = nodeDatum;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },\n      baseStyle\n    );\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  moduleFactory: (ctx) => new ScatterSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start = 0;\n  let end = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start + end) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start = s;\n    } else {\n      end = s;\n    }\n  }\n  return start;\n}\nvar delta2 = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta2) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x = NaN;\n  let p0y = NaN;\n  let p1x = NaN;\n  let p1y = NaN;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    let { innerRadius, outerRadius } = this;\n    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;\n    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);\n    return { innerRadius, outerRadius };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta3 = 1e-6;\n      if (!start && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3))\n        return;\n      if (start && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3))\n        return;\n      if (inner && !(radius >= clipSector.innerRadius - delta3))\n        return;\n      if (!inner && !(radius <= clipSector.outerRadius + delta3))\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - innerAngleOffset)\n        );\n        arc.clipEnd(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + innerAngleOffset)\n        );\n      } else {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + outerAngleOffset)\n        );\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - outerAngleOffset));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta3 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta3;\n    path.clear();\n    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {\n      return;\n    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);\n      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = radialEdgeInset;\n      }\n      r = Math.max(r, innerRadius);\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(point.x - this.centerX, point.y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      Logger.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke = sect.stroke ?? stroke;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance3 = 0;\n      if (radius < sector.innerRadius) {\n        distance3 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance3 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance3 };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return this.itemGroup.children;\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text = new Text();\n    text.pointerEvents = 1 /* None */;\n    return text;\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return { seriesRect };\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      Circle\n    );\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        focusable: true,\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0),\n          focusable: false\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      if (datum.itemId === highlightedDatum?.itemId) {\n        node.visible = true;\n        updateSectorFn(node, datum, index, true);\n      } else {\n        node.visible = false;\n      }\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        text.x = datum.midCos * labelRadius;\n        text.y = datum.midSin * labelRadius;\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = \"center\";\n      text.textBaseline = \"alphabetic\";\n      textBBoxes.push(text.getBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      spacing: 2\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  moduleFactory: (ctx) => new DonutSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation } = this.properties;\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0)\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        strokeOpacity,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      if (datum.itemId === highlightedDatum?.itemId) {\n        node.visible = true;\n        updateSectorFn(node, datum, index, true);\n      } else {\n        node.visible = false;\n      }\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  moduleFactory: (ctx) => new PieSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts\nvar ToolbarGroupProperties = class extends BaseProperties {\n  constructor(onChange, onButtonsChange) {\n    super();\n    this.onChange = onChange;\n    this.onButtonsChange = onButtonsChange;\n    this.align = \"start\";\n    this.position = \"top\" /* Top */;\n    this.size = \"normal\";\n    this.buttonOverrides = /* @__PURE__ */ new Map();\n  }\n  buttonConfigurations() {\n    return this.buttons?.map((button) => {\n      const id = button.id ?? button.value;\n      const overrides = this.buttonOverrides.get(id);\n      return overrides != null ? { ...button, ...overrides } : button;\n    }) ?? [];\n  }\n  buttonsChanged(configurationOnly) {\n    this.onButtonsChange(this.buttonConfigurations(), configurationOnly);\n  }\n  overrideButtonConfiguration(id, options) {\n    let overrides = this.buttonOverrides.get(id);\n    if (overrides == null) {\n      overrides = /* @__PURE__ */ Object.create(null);\n      this.buttonOverrides.set(id, overrides);\n    }\n    for (const key in options) {\n      const value = options[key];\n      if (value == null) {\n        delete overrides[key];\n      } else {\n        overrides[key] = value;\n      }\n    }\n    this.buttonsChanged(true);\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })\n], ToolbarGroupProperties.prototype, \"align\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })\n], ToolbarGroupProperties.prototype, \"position\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([\"small\", \"normal\"]), { optional: true })\n], ToolbarGroupProperties.prototype, \"size\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    for (const button of target.buttons ?? []) {\n      if (button.icon != null && ICONS_LEGACY.includes(button.icon)) {\n        Logger.warnOnce(`Icon '${button.icon}' is deprecated, use another icon instead.`);\n      }\n      if (button.ariaLabel === \"toolbarAnnotationsColor\") {\n        Logger.warnOnce(\n          `Aria label '${button.ariaLabel}' is deprecated, use 'toolbarAnnotationsLineColor' instead.`\n        );\n      }\n    }\n    target.buttonsChanged(false);\n  }),\n  Validate(ARRAY, { optional: true })\n], ToolbarGroupProperties.prototype, \"buttons\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts\nvar block2 = \"ag-charts-toolbar\";\nvar elements2 = {\n  align: \"ag-charts-toolbar__align\",\n  section: \"ag-charts-toolbar__section\",\n  button: \"ag-charts-toolbar__button\",\n  icon: \"ag-charts-toolbar__icon\",\n  label: \"ag-charts-toolbar__label\"\n};\nvar modifiers2 = {\n  [\"top\" /* Top */]: \"ag-charts-toolbar--top\",\n  [\"right\" /* Right */]: \"ag-charts-toolbar--right\",\n  [\"bottom\" /* Bottom */]: \"ag-charts-toolbar--bottom\",\n  [\"left\" /* Left */]: \"ag-charts-toolbar--left\",\n  [\"floating\" /* Floating */]: \"ag-charts-toolbar--floating\",\n  [\"floating-top\" /* FloatingTop */]: \"ag-charts-toolbar--floating-top\",\n  [\"floating-bottom\" /* FloatingBottom */]: \"ag-charts-toolbar--floating-bottom\",\n  small: \"ag-charts-toolbar--small\",\n  normal: \"ag-charts-toolbar--normal\",\n  hidden: \"ag-charts-toolbar--hidden\",\n  preventFlash: \"ag-charts-toolbar--prevent-flash\",\n  floatingHidden: \"ag-charts-toolbar--floating-hidden\",\n  align: {\n    start: \"ag-charts-toolbar__align--start\",\n    center: \"ag-charts-toolbar__align--center\",\n    end: \"ag-charts-toolbar__align--end\"\n  },\n  button: {\n    active: `ag-charts-toolbar__button--active`,\n    hiddenValue: `ag-charts-toolbar__button--hidden-value`,\n    hiddenToggled: `ag-charts-toolbar__button--hidden-toggled`,\n    fillVisible: `ag-charts-toolbar__button--fill-visible`\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbar.ts\nvar Toolbar = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.seriesType = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"seriesType\"),\n      this.onGroupButtonsChanged.bind(this, \"seriesType\")\n    );\n    this.annotations = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotations\"),\n      this.onGroupButtonsChanged.bind(this, \"annotations\")\n    );\n    this.annotationOptions = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotationOptions\"),\n      this.onGroupButtonsChanged.bind(this, \"annotationOptions\")\n    );\n    this.ranges = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"ranges\"),\n      this.onGroupButtonsChanged.bind(this, \"ranges\")\n    );\n    this.zoom = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"zoom\"),\n      this.onGroupButtonsChanged.bind(this, \"zoom\")\n    );\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.floatingDetectionRange = 38;\n    this.positions = {\n      [\"top\" /* Top */]: /* @__PURE__ */ new Set(),\n      [\"right\" /* Right */]: /* @__PURE__ */ new Set(),\n      [\"bottom\" /* Bottom */]: /* @__PURE__ */ new Set(),\n      [\"left\" /* Left */]: /* @__PURE__ */ new Set(),\n      [\"floating\" /* Floating */]: /* @__PURE__ */ new Set(),\n      [\"floating-top\" /* FloatingTop */]: /* @__PURE__ */ new Set(),\n      [\"floating-bottom\" /* FloatingBottom */]: /* @__PURE__ */ new Set()\n    };\n    this.positionAlignments = {\n      [\"top\" /* Top */]: {},\n      [\"right\" /* Right */]: {},\n      [\"bottom\" /* Bottom */]: {},\n      [\"left\" /* Left */]: {},\n      [\"floating\" /* Floating */]: {},\n      [\"floating-top\" /* FloatingTop */]: {},\n      [\"floating-bottom\" /* FloatingBottom */]: {}\n    };\n    this.groupCallers = {\n      seriesType: /* @__PURE__ */ new Set(),\n      annotations: /* @__PURE__ */ new Set(),\n      annotationOptions: /* @__PURE__ */ new Set(),\n      ranges: /* @__PURE__ */ new Set(),\n      zoom: /* @__PURE__ */ new Set()\n    };\n    this.groupButtons = {\n      seriesType: [],\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.ariaToolbars = [\n      { groups: [\"seriesType\", \"annotations\"], destroyFns: [] },\n      { groups: [\"annotationOptions\"], destroyFns: [] },\n      { groups: [\"ranges\"], destroyFns: [] },\n      { groups: [\"zoom\"], destroyFns: [] }\n    ];\n    this.pendingButtonToggledEvents = [];\n    this.groupProxied = /* @__PURE__ */ new Map();\n    this.hasNewLocale = true;\n    this.elements = {};\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position] = ctx.domManager.addChild(\"canvas-overlay\", `toolbar-${position}`);\n      this.elements[position].role = \"presentation\";\n      this.renderToolbar(position);\n    }\n    this.toggleVisibilities();\n    this.destroyFns.push(\n      ctx.interactionManager.addListener(\"hover\", this.onHover.bind(this), 31 /* All */),\n      ctx.interactionManager.addListener(\"leave\", this.onLeave.bind(this), 31 /* All */),\n      ctx.toolbarManager.addListener(\"button-toggled\", this.onButtonToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"button-updated\", this.onButtonUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"group-toggled\", this.onGroupToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"floating-anchor-changed\", this.onFloatingAnchorChanged.bind(this)),\n      ctx.toolbarManager.addListener(\"proxy-group-options\", this.onProxyGroupOptions.bind(this)),\n      ctx.layoutService.addListener(\"layout-complete\", this.onLayoutComplete.bind(this)),\n      ctx.localeManager.addListener(\"locale-changed\", () => {\n        this.hasNewLocale = true;\n      }),\n      () => this.destroyElements()\n    );\n  }\n  destroyElements() {\n    this.ctx.domManager.removeStyles(block2);\n    for (const element2 of Object.keys(this.elements)) {\n      this.ctx.domManager.removeChild(\"canvas-overlay\", `toolbar-${element2}`);\n    }\n  }\n  onHover(event) {\n    const {\n      enabled,\n      elements: elements3,\n      floatingDetectionRange,\n      ctx: { scene }\n    } = this;\n    const {\n      offsetY,\n      sourceEvent: { target }\n    } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled)\n      return;\n    const bottom = elements3[FloatingBottom];\n    const top = elements3[FloatingTop];\n    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;\n    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;\n    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;\n    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;\n    this.translateFloatingElements(FloatingBottom, bottomVisible);\n    this.translateFloatingElements(FloatingTop, topVisible);\n  }\n  onLeave(event) {\n    const {\n      enabled,\n      ctx: { scene }\n    } = this;\n    const { relatedElement, targetElement } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled || targetElement !== scene.canvas.element)\n      return;\n    const isTargetButton = TOOLBAR_GROUPS.some(\n      (group) => this.groupButtons[group].some((button) => button === relatedElement)\n    );\n    if (isTargetButton)\n      return;\n    this.translateFloatingElements(FloatingBottom, false);\n    this.translateFloatingElements(FloatingTop, false);\n  }\n  onGroupChanged(group) {\n    if (this[group] == null || this.groupProxied.has(group))\n      return;\n    this.createGroup(group);\n    this.toggleVisibilities();\n  }\n  onGroupButtonsChanged(group, buttons, configurationOnly) {\n    if (!this.enabled || this.groupProxied.has(group))\n      return;\n    if (configurationOnly) {\n      for (const buttonOptions of this[group].buttonConfigurations()) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n    } else {\n      this.createGroupButtons(group, buttons);\n    }\n    this.toggleVisibilities();\n  }\n  onLayoutComplete() {\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position].classList.remove(modifiers2.preventFlash);\n    }\n  }\n  onButtonUpdated(event) {\n    const { type: _type, group, id, ...params } = event;\n    this[group].overrideButtonConfiguration(id, { ...params });\n  }\n  setButtonActive(button, active) {\n    button.classList.toggle(modifiers2.button.active, active);\n  }\n  onButtonToggled(event) {\n    const { group, id, active, enabled, visible } = event;\n    if (this.groupButtons[group].length === 0) {\n      this.pendingButtonToggledEvents.push(event);\n      return;\n    }\n    for (const button of this.groupButtons[group]) {\n      if (button.dataset.toolbarId !== `${id}`)\n        continue;\n      button.ariaDisabled = `${!enabled}`;\n      setVisibility(button, modifiers2.button.hiddenToggled, !visible);\n      this.setButtonActive(button, active);\n    }\n  }\n  onGroupToggled(event) {\n    const { caller, group, active, visible } = event;\n    this.toggleGroup(caller, group, active, visible);\n    this.toggleVisibilities();\n  }\n  onFloatingAnchorChanged(event) {\n    const {\n      elements: elements3,\n      groupButtons,\n      positions,\n      horizontalSpacing,\n      verticalSpacing,\n      ctx: { domManager, toolbarManager }\n    } = this;\n    const { group, anchor } = event;\n    if (!positions[\"floating\" /* Floating */].has(group))\n      return;\n    const element2 = elements3[\"floating\" /* Floating */];\n    if (element2.classList.contains(modifiers2.hidden))\n      return;\n    const position = anchor.position ?? \"above\";\n    const { offsetWidth: width, offsetHeight: height } = element2;\n    let top = anchor.y - height - verticalSpacing;\n    let left = anchor.x - width / 2;\n    if (position === \"right\") {\n      top = anchor.y - height / 2;\n      left = anchor.x + horizontalSpacing;\n    } else if (position === \"above-left\") {\n      left = anchor.x;\n    }\n    const canvasRect = domManager.getBoundingClientRect();\n    top = clamp(0, top, canvasRect.height - height);\n    left = clamp(0, left, canvasRect.width - width);\n    element2.style.top = `${top}px`;\n    element2.style.left = `${left}px`;\n    const groupBBox = new BBox(left, top, width, height);\n    for (const button of groupButtons[group]) {\n      if (button.classList.contains(modifiers2.button.hiddenToggled))\n        continue;\n      const parent = button.offsetParent;\n      toolbarManager.buttonMoved(\n        group,\n        button.dataset.toolbarId,\n        new BBox(\n          button.offsetLeft + (parent?.offsetLeft ?? 0),\n          button.offsetTop + (parent?.offsetTop ?? 0),\n          button.offsetWidth,\n          button.offsetHeight\n        ),\n        groupBBox\n      );\n    }\n  }\n  buttonRect(button, canvasRect = this.ctx.domManager.getBoundingClientRect()) {\n    const buttonRect = button.getBoundingClientRect();\n    return new BBox(\n      buttonRect.left - canvasRect.left,\n      buttonRect.top - canvasRect.top,\n      buttonRect.width,\n      buttonRect.height\n    );\n  }\n  onProxyGroupOptions(event) {\n    if (!this.enabled)\n      return;\n    const { caller, group, options } = event;\n    this.groupProxied.set(group, options);\n    this[group].set(options);\n    this.toggleGroup(caller, group, void 0, options.enabled);\n    this.createGroup(group, options.enabled, options.position);\n    if (options.enabled) {\n      this.createGroupButtons(group, options.buttons);\n    }\n  }\n  createGroup(group, enabled, position) {\n    enabled ?? (enabled = this[group].enabled);\n    position ?? (position = this[group].position);\n    for (const pos of TOOLBAR_POSITIONS) {\n      if (enabled && position === pos) {\n        this.positions[pos].add(group);\n      } else {\n        this.positions[pos].delete(group);\n      }\n    }\n  }\n  createGroupButtons(group, buttons = []) {\n    for (const button of this.groupButtons[group]) {\n      button.remove();\n    }\n    const ariaToolbar = this.getAriaToolbar(group);\n    this.groupButtons[group] = [];\n    ariaToolbar.destroyFns.forEach((d) => d());\n    ariaToolbar.destroyFns = [];\n    if (buttons.length === 0)\n      return;\n    const { align, position } = this[group];\n    const alignElement = this.positionAlignments[position][align];\n    if (!alignElement)\n      return;\n    const nextSection = (section2) => {\n      const alignElementChildren = Array.from(alignElement.children);\n      const dataGroup = \"data-group\";\n      const dataSection = \"data-section\";\n      let sectionElement = alignElementChildren.find((prevSection2) => {\n        return prevSection2.getAttribute(dataGroup) === group && prevSection2.getAttribute(dataSection) === (section2 ?? \"\");\n      });\n      if (!sectionElement) {\n        sectionElement = createElement(\"div\");\n        sectionElement.role = \"presentation\";\n        sectionElement.setAttribute(dataGroup, group);\n        sectionElement.setAttribute(dataSection, section2 ?? \"\");\n        const groupIndex = TOOLBAR_GROUP_ORDERING[group];\n        const insertBeforeElement = alignElementChildren.find((prevSection2) => {\n          const prevGroup = prevSection2.getAttribute(dataGroup);\n          const prevGroupIndex = TOOLBAR_GROUP_ORDERING[prevGroup];\n          return prevGroupIndex > groupIndex;\n        });\n        if (insertBeforeElement != null) {\n          alignElement.insertBefore(sectionElement, insertBeforeElement);\n        } else {\n          alignElement.appendChild(sectionElement);\n        }\n        this.destroyFns.push(() => sectionElement.remove());\n      }\n      sectionElement.classList.add(elements2.section, modifiers2[this[group].size]);\n      return sectionElement;\n    };\n    let prevSection = buttons.at(0)?.section;\n    let section = nextSection(prevSection);\n    for (const options of buttons) {\n      if (prevSection !== options.section) {\n        section = nextSection(options.section);\n      }\n      prevSection = options.section;\n      const button = this.createButtonElement(group, options);\n      section.appendChild(button);\n      this.groupButtons[group].push(button);\n    }\n    const onEscape = () => {\n      this.ctx.toolbarManager.cancel(group);\n    };\n    let onFocus;\n    let onBlur;\n    if (isAnimatingFloatingPosition(position)) {\n      onFocus = () => this.translateFloatingElements(position, true);\n      onBlur = () => this.translateFloatingElements(position, false);\n    }\n    const orientation = this.computeAriaOrientation(this[group].position);\n    const ariaToolbarButtons = ariaToolbar.groups.map((g) => this.groupButtons[g]).flat();\n    ariaToolbar.destroyFns = initToolbarKeyNav({\n      orientation,\n      toolbar: alignElement,\n      buttons: ariaToolbarButtons,\n      onEscape,\n      onFocus,\n      onBlur\n    });\n    this.updateToolbarAriaLabel(group, alignElement);\n  }\n  computeAriaOrientation(position) {\n    return {\n      top: \"horizontal\",\n      right: \"vertical\",\n      bottom: \"horizontal\",\n      left: \"vertical\",\n      floating: \"horizontal\",\n      \"floating-top\": \"horizontal\",\n      \"floating-bottom\": \"horizontal\"\n    }[position];\n  }\n  toggleGroup(caller, group, active, enabled) {\n    if (enabled === true) {\n      this.groupCallers[group].add(caller);\n    } else if (enabled === false) {\n      this.groupCallers[group].delete(caller);\n    }\n    if (active != null) {\n      for (const button of this.groupButtons[group]) {\n        this.setButtonActive(button, active);\n      }\n    }\n  }\n  processPendingEvents() {\n    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();\n    for (const event of pendingButtonToggledEvents) {\n      this.onButtonToggled(event);\n    }\n    this.pendingButtonToggledEvents = [];\n  }\n  async performLayout(ctx) {\n    if (!this.enabled)\n      return ctx;\n    this.refreshOuterLayout(ctx.shrinkRect);\n    this.refreshLocale();\n    return ctx;\n  }\n  async performCartesianLayout(opts) {\n    if (!this.enabled)\n      return;\n    this.refreshInnerLayout(opts.seriesRect);\n  }\n  refreshOuterLayout(shrinkRect) {\n    const { elements: elements3, horizontalSpacing, verticalSpacing } = this;\n    if (!elements3.top.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.top.offsetHeight + verticalSpacing, \"top\");\n    }\n    if (!elements3.right.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.right.offsetWidth + horizontalSpacing, \"right\");\n    }\n    if (!elements3.bottom.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.bottom.offsetHeight + verticalSpacing, \"bottom\");\n      elements3.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;\n    }\n    if (!elements3.left.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.left.offsetWidth + horizontalSpacing, \"left\");\n    }\n  }\n  refreshLocale() {\n    const { hasNewLocale } = this;\n    if (!hasNewLocale)\n      return;\n    for (const group of TOOLBAR_GROUPS) {\n      const buttons = this[group].buttonConfigurations();\n      for (const buttonOptions of buttons) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n      this.updateToolbarAriaLabel(group);\n    }\n    this.hasNewLocale = false;\n  }\n  refreshInnerLayout(rect) {\n    const { elements: elements3, verticalSpacing } = this;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    elements3.top.style.top = `${rect.y - elements3.top.offsetHeight - verticalSpacing}px`;\n    elements3.top.style.left = `${rect.x}px`;\n    elements3.top.style.width = `${rect.width}px`;\n    elements3.bottom.style.left = `${rect.x}px`;\n    elements3.bottom.style.width = `${rect.width}px`;\n    elements3.right.style.top = `${rect.y}px`;\n    elements3.right.style.right = `0px`;\n    elements3.right.style.height = `${rect.height}px`;\n    elements3.left.style.top = `${rect.y}px`;\n    elements3.left.style.left = `0px`;\n    elements3.left.style.height = `${rect.height}px`;\n    elements3[FloatingTop].style.top = `${rect.y}px`;\n    elements3[FloatingBottom].style.top = `${rect.y + rect.height - elements3[FloatingBottom].offsetHeight}px`;\n  }\n  refreshButtonContent(group, buttonOptions) {\n    const id = this.buttonId(buttonOptions);\n    const button = this.groupProxied.get(group)?.buttons?.find((b) => this.buttonId(b) === id) ?? buttonOptions;\n    const element2 = this.groupButtons[group].find((b) => b.getAttribute(\"data-toolbar-id\") === id);\n    if (element2 == null)\n      return;\n    this.updateButton(element2, button);\n  }\n  toggleVisibilities() {\n    if (this.elements == null)\n      return;\n    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;\n    const isButtonVisible = (element2) => (button) => {\n      const id = this.buttonId(button);\n      return id == null || id === element2.dataset.toolbarId;\n    };\n    for (const position of TOOLBAR_POSITIONS) {\n      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);\n      setVisibility(this.elements[position], modifiers2.hidden, !visible);\n    }\n    for (const group of TOOLBAR_GROUPS) {\n      if (this[group] == null)\n        continue;\n      const groupVisible = isGroupVisible(group);\n      for (const button of this.groupButtons[group]) {\n        const buttonVisible = groupVisible && this[group].buttonConfigurations().some(isButtonVisible(button));\n        setVisibility(button, modifiers2.button.hiddenValue, !buttonVisible);\n      }\n    }\n  }\n  translateFloatingElements(position, visible) {\n    const { elements: elements3, verticalSpacing: verticalMargin, positionAlignments } = this;\n    const element2 = elements3[position];\n    const alignments = Object.values(positionAlignments[position]);\n    setVisibility(element2, modifiers2.floatingHidden, !visible);\n    const dir = position === \"floating-bottom\" /* FloatingBottom */ ? 1 : -1;\n    for (const align of alignments) {\n      align.style.transform = visible && align.style.transform !== \"\" ? \"translateY(0)\" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;\n    }\n  }\n  renderToolbar(position = \"top\" /* Top */) {\n    const element2 = this.elements[position];\n    element2.classList.add(block2, modifiers2[position], modifiers2.preventFlash);\n    if (isAnimatingFloatingPosition(position)) {\n      element2.classList.add(modifiers2.floatingHidden);\n    }\n    for (const align of TOOLBAR_ALIGNMENTS) {\n      const alignmentElement = createElement(\"div\");\n      alignmentElement.role = \"presentation\";\n      alignmentElement.classList.add(elements2.align, modifiers2.align[align]);\n      alignmentElement.dataset.pointerCapture = \"exclusive\";\n      element2.appendChild(alignmentElement);\n      this.positionAlignments[position][align] = alignmentElement;\n    }\n  }\n  createButtonElement(group, options) {\n    const button = createElement(\"button\");\n    button.classList.add(elements2.button);\n    button.dataset.toolbarGroup = group;\n    button.tabIndex = -1;\n    button.dataset.toolbarId = this.buttonId(options);\n    button.onclick = makeAccessibleClickListener(\n      button,\n      this.onButtonPress.bind(this, button, group, options.id, options.value)\n    );\n    this.updateButton(button, options);\n    this.destroyFns.push(() => button.remove());\n    return button;\n  }\n  getAriaToolbar(group) {\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        return ariaToolbar;\n      }\n    }\n    throw new Error(`AG Charts - cannot find aria-toolbar of '${group}'`);\n  }\n  updateToolbarAriaLabel(group, alignElement) {\n    if (!alignElement) {\n      const { align, position } = this[group];\n      alignElement = this.positionAlignments[position][align];\n      if (!alignElement)\n        return;\n    }\n    const map = {\n      seriesType: \"ariaLabelFinancialCharts\",\n      annotations: \"ariaLabelFinancialCharts\",\n      annotationOptions: \"ariaLabelAnnotationOptionsToolbar\",\n      ranges: \"ariaLabelRangesToolbar\",\n      zoom: \"ariaLabelZoomToolbar\"\n    };\n    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);\n  }\n  updateButton(button, options) {\n    const {\n      ctx: { domManager, localeManager }\n    } = this;\n    if (options.tooltip) {\n      const tooltip = localeManager.t(options.tooltip);\n      button.title = tooltip;\n    }\n    let inner = \"\";\n    if (options.icon != null) {\n      inner = `<span class=\"${domManager.getIconClassNames(options.icon)} ${elements2.icon}\"></span>`;\n    }\n    if (options.label != null) {\n      const label = localeManager.t(options.label);\n      inner = `${inner}<span class=\"${elements2.label}\">${label}</span>`;\n    }\n    button.innerHTML = inner;\n    button.classList.toggle(modifiers2.button.fillVisible, options.fill != null);\n    button.style.setProperty(\"--fill\", options.fill ?? null);\n    const ariaLabel = options.ariaLabel ? this.ctx.localeManager.t(options.ariaLabel) : void 0;\n    setAttribute(button, \"aria-label\", ariaLabel);\n  }\n  onButtonPress(button, group, id, value) {\n    this.ctx.toolbarManager.pressButton(group, this.buttonId({ id, value }), value, this.buttonRect(button));\n  }\n  buttonId(button) {\n    const { id, value, label } = button;\n    if (id != null)\n      return id;\n    if (value != null && typeof value !== \"object\")\n      return String(value);\n    return label ?? \"\";\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.processPendingEvents();\n    target.toggleVisibilities();\n  }),\n  Validate(BOOLEAN)\n], Toolbar.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts\nvar DAY = 1e3 * 60 * 60 * 24;\nvar MONTH = DAY * 30;\nvar YEAR = DAY * 365;\nvar seriesType = {\n  enabled: false,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      tooltip: \"toolbarSeriesTypeDropdown\",\n      value: \"type\"\n    }\n  ]\n};\nvar annotations = {\n  enabled: true,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"trend-line-drawing\",\n      tooltip: \"toolbarAnnotationsLineAnnotations\",\n      value: \"line-menu\",\n      section: \"line-annotations\"\n    },\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextAnnotations\",\n      value: \"text-menu\",\n      section: \"text-annotations\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsClearAll\",\n      value: \"clear\",\n      section: \"tools\"\n    }\n  ]\n};\nvar annotationOptions = {\n  enabled: true,\n  position: \"floating\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextColor\",\n      value: \"text-color\"\n    },\n    {\n      icon: \"line-color\",\n      tooltip: \"toolbarAnnotationsLineColor\",\n      value: \"line-color\"\n    },\n    {\n      icon: \"fill-color\",\n      tooltip: \"toolbarAnnotationsFillColor\",\n      value: \"fill-color\"\n    },\n    {\n      tooltip: \"toolbarAnnotationsTextSize\",\n      value: \"text-size\"\n    },\n    {\n      icon: \"unlocked\",\n      tooltip: \"toolbarAnnotationsLock\",\n      value: \"lock\"\n    },\n    {\n      icon: \"locked\",\n      tooltip: \"toolbarAnnotationsUnlock\",\n      value: \"unlock\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsDelete\",\n      value: \"delete\"\n    }\n  ]\n};\nvar ranges = {\n  enabled: false,\n  position: DEFAULT_TOOLBAR_POSITION,\n  align: \"start\",\n  buttons: [\n    {\n      label: \"toolbarRange1Month\",\n      ariaLabel: \"toolbarRange1MonthAria\",\n      value: MONTH\n    },\n    {\n      label: \"toolbarRange3Months\",\n      ariaLabel: \"toolbarRange3MonthsAria\",\n      value: 3 * MONTH\n    },\n    {\n      label: \"toolbarRange6Months\",\n      ariaLabel: \"toolbarRange6MonthsAria\",\n      value: 6 * MONTH\n    },\n    {\n      label: \"toolbarRangeYearToDate\",\n      ariaLabel: \"toolbarRangeYearToDateAria\",\n      value: (_start, end) => [(/* @__PURE__ */ new Date(`${new Date(end).getFullYear()}-01-01`)).getTime(), end],\n      id: \"year-to-date\"\n    },\n    {\n      label: \"toolbarRange1Year\",\n      ariaLabel: \"toolbarRange1YearAria\",\n      value: YEAR\n    },\n    {\n      label: \"toolbarRangeAll\",\n      ariaLabel: \"toolbarRangeAllAria\",\n      value: (start, end) => [start, end],\n      id: \"all\"\n    }\n  ]\n};\nvar zoom = {\n  enabled: true,\n  position: \"top\",\n  align: \"end\",\n  buttons: [\n    {\n      icon: \"zoom-out\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\"\n    },\n    {\n      icon: \"zoom-in\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\"\n    },\n    {\n      icon: \"pan-start\",\n      tooltip: \"toolbarZoomPanStart\",\n      value: \"pan-start\"\n    },\n    {\n      icon: \"pan-end\",\n      tooltip: \"toolbarZoomPanEnd\",\n      value: \"pan-end\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\"\n    }\n  ]\n};\nvar ToolbarModule = {\n  type: \"root\",\n  optionsKey: \"toolbar\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Toolbar(ctx),\n  themeTemplate: {\n    toolbar: {\n      enabled: true,\n      seriesType,\n      annotations,\n      annotationOptions,\n      ranges,\n      zoom\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    NavigatorModule,\n    ToolbarModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      moduleFactory: (ctx) => new AxisConstructor(ctx),\n      hidden: AxisConstructor === GroupedCategoryAxis\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType2 of m.chartTypes) {\n        chartDefaults.set(chartType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType2 of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);\n        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/flowProportionChart.ts\nfunction isFlowProportion(series) {\n  return series.type === \"sankey\" || series.type === \"chord\";\n}\nvar FlowProportionChart = class extends Chart {\n  getChartType() {\n    return \"flow-proportion\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { nodes } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isFlowProportion(series)) {\n        series.setChartNodes(nodes);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(fullSeriesRect.x, fullSeriesRect.y, fullSeriesRect.width, fullSeriesRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nFlowProportionChart.className = \"FlowProportionChart\";\nFlowProportionChart.type = \"flow-proportion\";\n\n// packages/ag-charts-community/src/chart/hierarchyChart.ts\nvar HierarchyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"hierarchy\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n    }\n    await Promise.all(\n      this.series.map(async (series) => {\n        await series.update({ seriesRect: shrinkRect });\n      })\n    );\n    seriesRoot.visible = this.series[0].visible;\n    seriesRoot.setClipRectInGroupCoordinateSpace(\n      new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n    );\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  getAriaLabel() {\n    const captionText = this.getCaptionText();\n    return `hierarchical chart, ${captionText}`;\n  }\n};\nHierarchyChart.className = \"HierarchyChart\";\nHierarchyChart.type = \"hierarchy\";\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND_ZINDEX */;\n  }\n  getChartType() {\n    return \"polar\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const fullSeriesRect = shrinkRect.clone();\n    this.computeSeriesRect(shrinkRect);\n    await this.computeCircle(shrinkRect);\n    this.axes.forEach((axis) => axis.update());\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  updateAxes(cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\n      return;\n    }\n    const angleScale = angleAxis.scale;\n    const angles = angleScale.ticks?.().map((value) => angleScale.convert(value));\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange?.();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angles;\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  computeSeriesRect(shrinkRect) {\n    const {\n      seriesArea: { padding }\n    } = this;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter((series) => {\n      return series instanceof PolarSeries;\n    });\n    const polarAxes = this.axes.filter((axis) => {\n      return axis instanceof PolarAxis;\n    });\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.x + seriesBox.width / 2;\n    const centerY = seriesBox.y + seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of [...polarAxes, ...polarSeries]) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      if (refined.radius === radius) {\n        return;\n      }\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale {\n  constructor(domain, range3) {\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/topologyChart.ts\nfunction isTopologySeries(series) {\n  return series.type === \"map-shape\" || series.type === \"map-line\" || series.type === \"map-marker\" || series.type === \"map-shape-background\" || series.type === \"map-line-background\";\n}\nvar TopologyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.xAxis = new NumberAxis(this.getModuleContext());\n    this.xAxis.position = \"bottom\";\n    this.yAxis = new NumberAxis(this.getModuleContext());\n    this.yAxis.position = \"left\";\n    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);\n  }\n  getChartType() {\n    return \"topology\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { topology } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isTopologySeries(series)) {\n        series.setChartTopology(topology);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    const mapSeries = this.series.filter(isTopologySeries);\n    const combinedBbox = mapSeries.reduce((combined, series) => {\n      if (!series.visible)\n        return combined;\n      const bbox = series.topologyBounds;\n      if (bbox == null)\n        return combined;\n      if (combined == null)\n        return bbox;\n      combined.merge(bbox);\n      return combined;\n    }, void 0);\n    let scale2;\n    if (combinedBbox != null) {\n      const { lon0, lat0, lon1, lat1 } = combinedBbox;\n      const domain = [\n        [lon0, lat0],\n        [lon1, lat1]\n      ];\n      const bounds = MercatorScale.bounds(domain);\n      const { width, height } = shrinkRect;\n      const viewBoxScale = Math.min(width / bounds.width, height / bounds.height);\n      const viewBoxWidth = bounds.width * viewBoxScale;\n      const viewBoxHeight = bounds.height * viewBoxScale;\n      const viewBoxOriginX = (width - viewBoxWidth) / 2;\n      const viewBoxOriginY = (height - viewBoxHeight) / 2;\n      const x0 = viewBoxOriginX;\n      const y0 = viewBoxOriginY;\n      const x1 = viewBoxOriginX + viewBoxWidth;\n      const y1 = viewBoxOriginY + viewBoxHeight;\n      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);\n      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);\n      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);\n      const xStart = x0 - xSpan * xZoom.min;\n      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));\n      const yStart = y0 - ySpan * (1 - yZoom.max);\n      scale2 = new MercatorScale(domain, [\n        [xStart, yStart],\n        [xStart + xSpan, yStart + ySpan]\n      ]);\n    }\n    mapSeries.forEach((series) => {\n      series.scale = scale2;\n    });\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nTopologyChart.className = \"TopologyChart\";\nTopologyChart.type = \"topology\";\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nvar chartTypes2 = [\"ohlc\", \"line\", \"step-line\", \"hlc\", \"high-low\", \"candlestick\", \"hollow-candlestick\"];\nfunction priceVolume(opts, getTheme) {\n  const {\n    xKey,\n    dateKey = xKey ?? \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType: chartType2 = \"candlestick\",\n    navigator: navigator2 = false,\n    volume = true,\n    rangeToolbar,\n    rangeButtons = rangeToolbar ?? true,\n    statusBar = true,\n    annotations: annotations2,\n    toolbar = annotations2 ?? true,\n    zoom: zoom2 = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  if (xKey != null) {\n    Logger.warnOnce(\"Property [xKey] is deprecated, use [dateKey] instead.\");\n  }\n  if (rangeToolbar != null) {\n    Logger.warnOnce(\"Property [rangeToolbar] is deprecated, use [rangeButtons] instead.\");\n  }\n  if (annotations2 != null) {\n    Logger.warnOnce(\"Property [annotations] is deprecated, use [toolbar] instead.\");\n  }\n  const priceSeries = createPriceSeries(theme, chartType2, dateKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator2,\n      series: [\n        {\n          type: \"line\",\n          xKey: dateKey,\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator2,\n      ...miniChart\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom2,\n      // @ts-expect-error\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = {\n    chartToolbar: { enabled: true },\n    toolbar: {\n      seriesType: {\n        enabled: toolbar\n      },\n      annotationOptions: {\n        enabled: toolbar\n      },\n      annotations: {\n        enabled: toolbar\n      },\n      ranges: {\n        enabled: rangeButtons\n      }\n    }\n  };\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      }\n    }\n  ] : [];\n  return {\n    theme: typeof theme === \"string\" ? theme : {\n      baseTheme: \"ag-financial\",\n      ...theme ?? {}\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    padding: {\n      top: 6,\n      right: 8,\n      bottom: 5\n    },\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    annotations: {\n      enabled: toolbar\n    },\n    tooltip: { enabled: false },\n    data,\n    // @ts-expect-error\n    titlePadding: 4,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      tooltip: { enabled: false },\n      // @ts-expect-error\n      highlight: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {\n  if (chartType2 === RANGE_AREA_TYPE) {\n    Logger.warnOnce(`type '${chartType2}' is deprecated, use 'hlc' chart type instead`);\n    chartType2 = \"hlc\";\n  }\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  const common = {\n    pickOutsideVisibleMinorAxis: true\n  };\n  switch (chartType2 ?? \"candlestick\") {\n    case \"ohlc\":\n      return [\n        {\n          type: \"ohlc\",\n          ...common,\n          ...keys\n        }\n      ];\n    case \"line\":\n      return [\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"step-line\":\n      return [\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n            type: \"step\"\n          },\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"hlc\":\n      const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);\n      return [\n        {\n          type: RANGE_AREA_TYPE,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: closeKey,\n          fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: RANGE_AREA_TYPE,\n          ...common,\n          xKey,\n          yHighKey: closeKey,\n          yLowKey: lowKey,\n          fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"high-low\":\n      const rangeBarColors = getThemeColors(\"range-bar\", theme);\n      return [\n        {\n          type: \"range-bar\",\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: lowKey,\n          fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,\n          stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,\n          tooltip: {\n            range: \"nearest\"\n          }\n        }\n      ];\n    case \"candlestick\":\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys\n        }\n      ];\n    case \"hollow-candlestick\":\n      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys,\n          item: {\n            up: {\n              fill: item?.up?.fill ?? \"transparent\"\n            }\n          }\n        }\n      ];\n    default:\n      Logger.warnOnce(`unknown chart type: ${chartType2}; expected one of: ${chartTypes2.join(\", \")}`);\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys\n        }\n      ];\n  }\n}\nfunction getThemeColors(seriesType2, theme) {\n  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.fill);\n  const stroke = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.stroke);\n  return { fill, stroke };\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options, silent) {\n  const usedOptions = [];\n  const optionsChartType = chartTypes.get(optionsType(options));\n  for (const {\n    type,\n    chartTypes: moduleChartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !moduleChartTypes.includes(optionsChartType))\n      continue;\n    if (type === \"root\" || type === \"legend\") {\n      const optionValue = options[optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === identifier))\n        continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== identifier);\n    } else if (type === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[optionsKey]))\n        continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type === \"series\") {\n      if (!options.series?.some((series) => series.type === identifier))\n        continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter((series) => series.type !== identifier);\n    } else if (type === \"series-option\") {\n      if (!options.series?.some((series) => series[optionsKey]))\n        continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length && !silent) {\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://charts.ag-grid.com/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    Logger.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// packages/ag-charts-community/src/util/string.util.ts\nfunction stringifyValue(value, maxLength = Infinity) {\n  switch (typeof value) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"number\":\n      if (isNaN(value)) {\n        return \"NaN\";\n      } else if (value === Infinity) {\n        return \"Infinity\";\n      } else if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n    default:\n      value = JSON.stringify(value);\n      if (value.length > maxLength) {\n        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;\n      }\n      return value;\n  }\n}\n\n// packages/ag-charts-community/src/util/validate.ts\nvar descriptionSymbol = Symbol(\"description\");\nvar requiredSymbol = Symbol(\"required\");\nfunction isValid(options, optionsDefs, path) {\n  const { errors } = validate(options, optionsDefs, path);\n  for (const { message } of errors) {\n    Logger.warn(message);\n  }\n  return errors.length === 0;\n}\nfunction validateMessage(path, value, validatorOrDefs) {\n  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];\n  const expecting = description ? `; expecting ${description}` : \"\";\n  const prefix = path ? `Option \\`${path}\\`` : \"Value\";\n  return `${prefix} cannot be set to \\`${stringifyValue(value)}\\`${expecting}, ignoring.`;\n}\nfunction validate(options, optionsDefs, path = \"\") {\n  if (!isObject(options)) {\n    return {\n      valid: null,\n      errors: [{ path, value: options, message: validateMessage(path, options, \"an object\") }]\n    };\n  }\n  const optionsKeys = new Set(Object.keys(options));\n  const errors = [];\n  const valid = {};\n  function extendPath(key) {\n    if (isArray(optionsDefs)) {\n      return `${path}[${key}]`;\n    }\n    return path ? `${path}.${key}` : key;\n  }\n  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {\n    optionsKeys.delete(key);\n    const value = options[key];\n    if (!validatorOrDefs[requiredSymbol] && typeof value === \"undefined\")\n      continue;\n    if (isFunction(validatorOrDefs)) {\n      if (validatorOrDefs(value)) {\n        valid[key] = value;\n      } else {\n        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });\n      }\n    } else {\n      const nestedResult = validate(value, validatorOrDefs, extendPath(key));\n      valid[key] = nestedResult.valid;\n      errors.push(...nestedResult.errors);\n    }\n  }\n  for (const key of optionsKeys) {\n    errors.push({\n      key,\n      path,\n      unknown: true,\n      message: `Unknown option \\`${extendPath(key)}\\`, ignoring.`\n    });\n  }\n  return { valid, errors };\n}\nfunction attachDescription(validator, description) {\n  return Object.assign((value) => validator(value), { [descriptionSymbol]: description });\n}\nvar or = (...validators) => attachDescription(\n  (value) => validators.some((validator) => validator(value)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" or \")\n);\nvar array = attachDescription(isArray, \"an array\");\nvar boolean = attachDescription(isBoolean, \"a boolean\");\nvar callback = attachDescription(isFunction, \"a function\");\nvar number = attachDescription(isFiniteNumber, \"a number\");\nvar object = attachDescription(isObject, \"an object\");\nvar string = attachDescription(isString, \"a string\");\nvar numberMin = (min, inclusive = true) => attachDescription(\n  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),\n  `a number greater than ${inclusive ? \"or equal to \" : \"\"}${min}`\n);\nvar numberRange = (min, max) => attachDescription(\n  (value) => isFiniteNumber(value) && value >= min && value <= max,\n  `a number between ${min} and ${max} inclusive`\n);\nvar positiveNumber = numberMin(0);\nvar minOneNumber = numberMin(1);\nvar ratio = numberRange(0, 1);\nvar degree = numberRange(0, 360);\nvar arrayOf = (validator, description) => attachDescription(\n  (value) => isArray(value) && value.every(validator),\n  description ?? `${validator[descriptionSymbol]} array`\n);\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };\n  }\n};\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontSize: 12 /* SMALL */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        color: DEFAULT_LABEL_COLOUR,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: 12 /* SMALL */,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      },\n      crosshair: {\n        enabled: true\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },\n      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 17 /* LARGE */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: \"rgb(140, 140, 140)\",\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontSize: 12 /* SMALL */,\n            fontFamily: DEFAULT_FONT_FAMILY\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: DEFAULT_LABEL_COLOUR },\n          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },\n          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },\n          label: { color: DEFAULT_LABEL_COLOUR }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    if (overrides) {\n      this.mergeOverrides(defaults, overrides);\n    }\n    const { fills, strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = mergeDefaults(palette, {\n      fills: Object.values(fills),\n      strokes: Object.values(strokes),\n      ...otherColors\n    });\n    this.paletteType = paletteType(palette);\n    this.config = Object.freeze(this.templateTheme(defaults));\n  }\n  mergeOverrides(defaults, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType2 = s;\n        defaults[seriesType2] = mergeDefaults(cleanedCommon, defaults[seriesType2]);\n      }\n    }\n    chartTypes.seriesTypes.forEach((s) => {\n      const seriesType2 = s;\n      if (overrides[seriesType2]) {\n        defaults[seriesType2] = mergeDefaults(overrides[seriesType2], defaults[seriesType2]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType2 of seriesTypes) {\n        config[seriesType2] || (config[seriesType2] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType2, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType2)\n      };\n      for (const seriesType2 of seriesTypes) {\n        result[seriesType2] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType2),\n          result[seriesType2] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType2];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes.flowProportionTypes)\n    );\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = deepClone(themeTemplate);\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, (node) => {\n      if (isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (params.has(symbol)) {\n            node[i] = params.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (params.has(value)) {\n            node[name] = params.get(value);\n          }\n        }\n      }\n    });\n    return deepClone(themeInstance);\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },\n      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },\n      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(DEFAULT_FONT_FAMILY, \"Verdana, sans-serif\");\n    params.set(DEFAULT_LABEL_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INVERTED_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"rgb(140, 140, 140)\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"rgb(224,234,241)\");\n    params.set(DEFAULT_AXIS_LINE_COLOUR, \"rgb(195, 195, 195)\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"rgba(0, 0, 0, 0.5)\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_PADDING, 20);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#ffffff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#ffffff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_TEXTBOX_FILL, \"#fafafa\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#dddddd\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#000000\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);\n    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: { enabled: false }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  \"grouped-category\": _ChartTheme.getAxisDefaults({\n    tick: { enabled: true }\n  })\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },\n      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },\n      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"#7D91A0\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#545A6E\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"white\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, \"white\");\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_TEXTBOX_FILL, \"#28313e\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#4b525d\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#ffffff\");\n    return params;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#343A4E\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#F2F3F3\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },\n      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },\n      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\",\n  GRAY: \"#eeeeee\"\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\",\n  GRAY: \"#888888\"\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },\n      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },\n      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },\n      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },\n      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },\n      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },\n      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },\n      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },\n      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = () => new ChartTheme();\nvar darkTheme = () => new DarkTheme();\nvar themes = {\n  // darkThemes,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": () => new SheetsDark(),\n  \"ag-polychroma-dark\": () => new PolychromaDark(),\n  \"ag-vivid-dark\": () => new VividDark(),\n  \"ag-material-dark\": () => new MaterialDark(),\n  \"ag-financial-dark\": () => new FinancialDark(),\n  // lightThemes,\n  null: lightTheme,\n  undefined: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": () => new SheetsLight(),\n  \"ag-polychroma\": () => new PolychromaLight(),\n  \"ag-vivid\": () => new VividLight(),\n  \"ag-material\": () => new MaterialLight(),\n  \"ag-financial\": () => new FinancialLight()\n};\nfunction getChartTheme(value) {\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  if (isValid(value, themeOptionsDef, \"theme\")) {\n    const flattenedTheme = reduceThemeOptions(value);\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n    return new baseTheme.constructor(flattenedTheme);\n  }\n  return lightTheme();\n}\nfunction reduceThemeOptions(options) {\n  let maybeNested = options;\n  let palette;\n  const overrides = [];\n  while (typeof maybeNested === \"object\") {\n    palette ?? (palette = maybeNested.palette);\n    if (maybeNested.overrides) {\n      overrides.push(maybeNested.overrides);\n    }\n    maybeNested = maybeNested.baseTheme;\n  }\n  return {\n    baseTheme: maybeNested,\n    overrides: mergeDefaults(...overrides),\n    palette\n  };\n}\nvar themeOptionsDef = {\n  baseTheme: or(string, object),\n  overrides: object,\n  palette: {\n    fills: arrayOf(string),\n    strokes: arrayOf(string),\n    up: { fill: string, stroke: string },\n    down: { fill: string, stroke: string },\n    neutral: { fill: string, stroke: string }\n  }\n};\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar ChartOptions = class {\n  constructor(userOptions, specialOverrides) {\n    this.debug = Debug.create(true, \"opts\");\n    var _a;\n    const cloneOptions = { shallow: [\"data\"] };\n    userOptions = deepClone(userOptions, cloneOptions);\n    const chartType2 = this.optionsType(userOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(userOptions);\n    }\n    let options = deepClone(userOptions, cloneOptions);\n    this.type = specialOverrides?.type;\n    if (this.type != null) {\n      const presetOptions = PRESETS[this.type]?.(options, () => this.activeTheme) ?? options;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", options, presetOptions);\n      options = presetOptions;\n    }\n    this.activeTheme = getChartTheme(options.theme);\n    if (this.type) {\n      options = this.activeTheme.templateTheme(options);\n    }\n    this.sanityCheckAndCleanup(options);\n    this.defaultAxes = this.getDefaultAxes(options);\n    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    const {\n      axes: axesThemes = {},\n      annotations: { axesButtons = null, ...annotationsThemes } = {},\n      series: _,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(chartType2);\n    this.userOptions = userOptions;\n    this.processedOptions = deepClone(\n      mergeDefaults(\n        options,\n        axesButtons != null ? { annotations: { axesButtons } } : {},\n        themeDefaults,\n        this.defaultAxes\n      ),\n      cloneOptions\n    );\n    this.processAxesOptions(this.processedOptions, axesThemes);\n    this.processSeriesOptions(this.processedOptions);\n    this.processMiniChartSeriesOptions(this.processedOptions);\n    this.annotationThemes = annotationsThemes;\n    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {\n      (_a = this.processedOptions).legend ?? (_a.legend = {});\n      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(this.processedOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(this.processedOptions, true);\n    }\n  }\n  getOptions() {\n    return this.processedOptions ?? {};\n  }\n  diffOptions(options) {\n    return jsonDiff(options, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType2) {\n    const themeConfig = deepClone(this.activeTheme?.config[seriesType2] ?? {});\n    this.removeLeftoverSymbols(themeConfig);\n    return themeConfig;\n  }\n  getDefaultAxes(options) {\n    const optionsType2 = this.optionsType(options);\n    const axesDefaults = seriesRegistry.cloneDefaultAxes(optionsType2);\n    if (seriesRegistry.isDefaultAxisSwapNeeded(options)) {\n      this.swapAxesPosition(axesDefaults);\n    }\n    return axesDefaults;\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheckAndCleanup(options) {\n    this.deprecationWarnings(options);\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n    this.removeDisabledOptions(options);\n    this.removeLeftoverSymbols(options);\n    if (options.series?.some((s) => s.type === \"bullet\") && options.sync != null && options.sync.enabled !== false) {\n      Logger.warnOnce(\"bullet series cannot be synced, disabling synchronization.\");\n      delete options.sync;\n    }\n  }\n  swapAxesPosition(options) {\n    if (isAgCartesianChartOptions(options)) {\n      const [axis0, axis1] = options.axes ?? [];\n      options.axes = [\n        { ...axis0, position: axis1.position },\n        { ...axis1, position: axis0.position }\n      ];\n    }\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options) {\n    const defaultSeriesType = this.getDefaultSeriesType(options);\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = defaultSeriesType);\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions)\n      );\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getSeriesPalette(seriesType2, options) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType2);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = this.activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: this.activeTheme.getTemplateParameters(),\n      palette: this.activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */:\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType2 = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType: seriesType2, series: [series], groupId: \"__default__\" });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType: seriesType2, series: [], groupId };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return \"line\";\n    } else if (isAgPolarChartOptions(options)) {\n      return \"pie\";\n    } else if (isAgHierarchyChartOptions(options)) {\n      return \"treemap\";\n    } else if (isAgTopologyChartOptions(options)) {\n      return \"map-shape\";\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return \"sankey\";\n    }\n    throw new Error(\"Invalid chart options type detected.\");\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType2) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType2)?.range\n      }\n    };\n  }\n  deprecationWarnings(options) {\n    const deprecatedArrayProps = { yKeys: \"yKey\", yNames: \"yName\" };\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n      if (options.series?.some((s) => s[oldProp] != null)) {\n        Logger.warnOnce(\n          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`\n        );\n      }\n    });\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options) {\n      const axes = options.axes ?? [];\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = axisRegistry.publicKeys().join(\", \");\n          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      Logger.warnOnce(\n        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        Logger.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  enableConfiguredOptions(options) {\n    jsonWalk(\n      this.userOptions,\n      (visitingUserOpts, visitingMergedOpts) => {\n        if (visitingMergedOpts && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n          visitingMergedOpts.enabled = true;\n        }\n      },\n      { skip: [\"data\", \"theme\"] },\n      options\n    );\n    jsonWalk(\n      options,\n      (visitingMergedOpts) => {\n        if (visitingMergedOpts._enabledFromTheme != null) {\n          delete visitingMergedOpts._enabledFromTheme;\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n          Object.keys(optionsNode).forEach((key) => {\n            if (key === \"enabled\")\n              return;\n            delete optionsNode[key];\n          });\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (!optionsNode || !isObject(optionsNode))\n          return;\n        for (const [key, value] of Object.entries(optionsNode)) {\n          if (isSymbol(value)) {\n            delete optionsNode[key];\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n\n// packages/ag-charts-community/src/api/agCharts.ts\nvar debug2 = Debug.create(true, \"opts\");\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return \"cartesian\";\n  } else if (isAgPolarChartOptions(options)) {\n    return \"polar\";\n  } else if (isAgHierarchyChartOptions(options)) {\n    return \"hierarchy\";\n  } else if (isAgTopologyChartOptions(options)) {\n    return \"topology\";\n  } else if (isAgFlowProportionChartOptions(options)) {\n    return \"flow-proportion\";\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  static setGridContext(gridContext) {\n    this.gridContext = gridContext;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(options) {\n    this.licenseCheck(options);\n    const chart = AgChartsInternal.createOrUpdate(options, void 0, this.licenseManager);\n    if (enterpriseModule.styles != null) {\n      chart.chart.ctx.domManager.addStyles(\"ag-charts-enterprise\", enterpriseModule.styles);\n    }\n    if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {\n      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  static createFinancialChart(options) {\n    return this.create({\n      _type: \"price-volume\",\n      ...options\n    });\n  }\n};\nAgCharts.licenseChecked = false;\nAgCharts.gridContext = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(options, proxy, licenseManager) {\n    _AgChartsInternal.initialiseModules();\n    debug2(\">>> AgCharts.createOrUpdate() user options\", options);\n    const defaultType = proxy?.chart.chartOptions.type;\n    const { _type = defaultType, ...otherOptions } = options;\n    let mutableOptions = otherOptions;\n    if (AgCharts.optionsMutationFn) {\n      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, _type);\n      debug2(\">>> AgCharts.createOrUpdate() MUTATED user options\", options);\n    }\n    const { overrideDevicePixelRatio, document: document2, window: userWindow, ...userOptions } = mutableOptions;\n    const chartOptions = new ChartOptions(userOptions, {\n      overrideDevicePixelRatio,\n      document: document2,\n      window: userWindow,\n      type: _type\n    });\n    let chart = proxy?.chart;\n    if (chart == null || chartType(userOptions) !== chartType(chart?.chartOptions.processedOptions)) {\n      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);\n    } else {\n      proxy.chart = chart;\n    }\n    if (debug2.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(userOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      chartRef.applyOptions(chartOptions);\n      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;\n      chartRef.queuedUserOptions.splice(0, queueIdx);\n    });\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, { shallow: [\"data\"] });\n    jsonWalk(\n      deltaOptions,\n      (node) => {\n        if (typeof node !== \"object\")\n          return;\n        for (const [key, value] of Object.entries(node)) {\n          if (typeof value === \"undefined\") {\n            Object.assign(node, { [key]: Symbol(\"UNSET\") });\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n    const { chart } = proxy;\n    const lastUpdateOptions = chart.getOptions();\n    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);\n    debug2(\">>> AgCharts.updateUserDelta() user delta\", deltaOptions);\n    debug2(\"AgCharts.updateUserDelta() - base options\", lastUpdateOptions);\n    _AgChartsInternal.createOrUpdate(userOptions, proxy);\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);\n    return new ChartConstructor(options, transferableResource);\n  }\n  static getChartByOptions(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return CartesianChart;\n    } else if (isAgHierarchyChartOptions(options)) {\n      return HierarchyChart;\n    } else if (isAgPolarChartOptions(options)) {\n      return PolarChart;\n    } else if (isAgTopologyChartOptions(options)) {\n      return TopologyChart;\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return FlowProportionChart;\n    }\n    throw new Error(\n      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  createOrUpdate(opts, chart) {\n    return _AgChartsInternal.createOrUpdate(opts, chart);\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  BBox: () => BBox,\n  BandScale: () => BandScale,\n  Caption: () => Caption,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Circle: () => Circle,\n  ContinuousScale: () => ContinuousScale,\n  Diamond: () => Diamond,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  Group: () => Group,\n  HdpiCanvas: () => HdpiCanvas,\n  Image: () => Image,\n  Label: () => Label,\n  Line: () => Line,\n  LinearGradientFill: () => LinearGradientFill,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Node: () => Node,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  RedrawType: () => RedrawType,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Shape: () => Shape,\n  Square: () => Square,\n  SvgPath: () => SvgPath,\n  Text: () => Text,\n  Tooltip: () => Tooltip,\n  Triangle: () => Triangle,\n  drawCorner: () => drawCorner,\n  easing: () => easing_exports,\n  evaluateBezier: () => evaluateBezier,\n  getFont: () => getFont,\n  getMarker: () => getMarker,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  motion: () => motion,\n  sectorBox: () => sectorBox,\n  solveBezier: () => solveBezier,\n  splitBezier: () => splitBezier,\n  toRadians: () => toRadians,\n  toTooltipHtml: () => toTooltipHtml\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);\n  }\n};\nArc2.className = \"Arc\";\nArc2.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  lineWidth: 1,\n  fillStyle: null\n});\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/shape/linearGradientFill.ts\nvar LinearGradientFill = class extends Shape {\n  constructor() {\n    super(...arguments);\n    this.direction = \"to-right\";\n    this.stops = void 0;\n    this._mask = void 0;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(newMask) {\n    if (this._mask != null) {\n      this.removeChild(this._mask);\n    }\n    if (newMask != null) {\n      this.appendChild(newMask);\n    }\n    this._mask = newMask;\n  }\n  isPointInPath(x, y) {\n    return this.mask?.isPointInPath(x, y) ?? false;\n  }\n  computeBBox() {\n    return this.mask?.getBBox();\n  }\n  render(renderCtx) {\n    const { mask, stops } = this;\n    const { ctx, devicePixelRatio } = renderCtx;\n    const pixelLength = 1 / devicePixelRatio;\n    const maskBbox = mask?.computeTransformedBBox();\n    if (mask == null || stops == null || maskBbox == null)\n      return;\n    if (mask.dirtyPath) {\n      mask.updatePath();\n      mask.dirtyPath = false;\n    }\n    ctx.save();\n    ctx.clip(mask.path.getPath2D());\n    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    const x0 = Math.floor(maskBbox.x);\n    const x1 = Math.ceil(maskBbox.x + maskBbox.width);\n    const y0 = Math.floor(maskBbox.y);\n    const y1 = Math.ceil(maskBbox.y + maskBbox.height);\n    const horizontal = this.direction === \"to-right\" || this.direction === \"to-left\";\n    const reversed = this.direction === \"to-top\" || this.direction === \"to-left\";\n    const colorScale = new ColorScale();\n    const [i0, i1] = horizontal ? [x0, x1] : [y0, y1];\n    colorScale.domain = stops.map((_, index) => {\n      return i0 + (i1 - i0) * index / (stops.length - 1);\n    });\n    colorScale.range = reversed ? stops.slice().reverse() : stops;\n    colorScale.update();\n    const height = y1 - y0;\n    const width = x1 - x0;\n    switch (this.direction) {\n      case \"to-right\":\n      case \"to-left\":\n        for (let x = x0; x <= x1; x += pixelLength) {\n          ctx.fillStyle = colorScale.convert(x);\n          ctx.fillRect(x, y0, pixelLength, height);\n        }\n        break;\n      case \"to-bottom\":\n      case \"to-top\":\n        for (let y = y0; y <= y1; y += pixelLength) {\n          ctx.fillStyle = colorScale.convert(y);\n          ctx.fillRect(x0, y, width, pixelLength);\n        }\n        break;\n    }\n    ctx.restore();\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"direction\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"stops\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"_mask\", 2);\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty = isEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/scene/shape/svgPath.ts\nvar SvgPath = class extends Path {\n  constructor(d) {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.commands = [];\n    for (const [_, command, paramsString] of d.matchAll(/([A-Z])([0-9. ]+)/g)) {\n      const params = paramsString.split(\" \").map(Number);\n      this.commands.push([command, params]);\n    }\n  }\n  updatePath() {\n    const { path, x, y } = this;\n    path.clear();\n    let lastX = x;\n    let lastY = y;\n    for (const [command, params] of this.commands) {\n      switch (command) {\n        case \"M\":\n          path.moveTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          break;\n        case \"C\":\n          path.cubicCurveTo(\n            x + params[0],\n            y + params[1],\n            x + params[2],\n            y + params[3],\n            x + params[4],\n            y + params[5]\n          );\n          lastX = x + params[4];\n          lastY = y + params[5];\n          break;\n        case \"H\":\n          path.lineTo(x + params[0], lastY);\n          lastX = y + params[0];\n          break;\n        case \"L\":\n          path.lineTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          lastY = y + params[1];\n          break;\n        case \"V\":\n          path.lineTo(lastX, y + params[0]);\n          lastY = y + params[0];\n          break;\n        default:\n          throw new Error(`Could not translate command '${command}' with '${params.join(\" \")}'`);\n      }\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"y\", 2);\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\nvar getFont = TextUtils.toFontString;\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_ANNOTATION_COLOR: () => DEFAULT_ANNOTATION_COLOR,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOURS: () => DEFAULT_COLOURS,\n  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_PADDING: () => DEFAULT_PADDING,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_WEIGHT: () => FONT_WEIGHT2,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,\n  POSITION: () => POSITION2,\n  getChartTheme: () => getChartTheme,\n  markerPaletteFactory: () => markerPaletteFactory,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  themes: () => themes2\n});\nvar themes2 = mapValues(\n  themes,\n  (themeFactory) => themeFactory?.()\n);\n\n// packages/ag-charts-community/src/sparklines-scale.ts\nvar sparklines_scale_exports = {};\n__export(sparklines_scale_exports, {\n  BandScale: () => BandScale,\n  ColorScale: () => ColorScale,\n  ContinuousScale: () => ContinuousScale,\n  Invalidating: () => Invalidating,\n  LinearScale: () => LinearScale,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  TimeScale: () => TimeScale\n});\n\n// packages/ag-charts-community/src/sparklines-util.ts\nvar sparklines_util_exports = {};\n__export(sparklines_util_exports, {\n  Color: () => Color,\n  Debug: () => Debug,\n  Logger: () => Logger,\n  Padding: () => Padding,\n  TimeInterval: () => TimeInterval,\n  Vec2: () => Vec2,\n  angleBetween: () => angleBetween,\n  angleDiff: () => angleDiff,\n  areArrayNumbersEqual: () => areArrayNumbersEqual,\n  bifurcate: () => bifurcate,\n  checkDatum: () => checkDatum,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  countFractionDigits: () => countFractionDigits,\n  createId: () => createId,\n  day: () => day,\n  deepClone: () => deepClone,\n  displacePointFromVector: () => displacePointFromVector,\n  extent: () => extent,\n  findMinMax: () => findMinMax,\n  findRangeExtent: () => findRangeExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  friday: () => friday,\n  hour: () => hour,\n  interpolateColor: () => interpolateColor,\n  interpolateNumber: () => interpolateNumber,\n  isBetweenAngles: () => isBetweenAngles,\n  isContinuous: () => isContinuous,\n  isDate: () => isValidDate,\n  isDenseInterval: () => isDenseInterval,\n  isEqual: () => isEqual,\n  isNegative: () => isNegative,\n  isNumber: () => isFiniteNumber,\n  isNumberEqual: () => isEqual,\n  isNumberObject: () => isNumberObject,\n  isString: () => isString,\n  isStringObject: () => isStringObject,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  mod: () => mod,\n  monday: () => monday,\n  month: () => month,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  range: () => range,\n  resetIds: () => resetIds,\n  round: () => round,\n  sanitizeHtml: () => sanitizeHtml,\n  saturday: () => saturday,\n  second: () => second,\n  setAttribute: () => setAttribute,\n  setVisibility: () => setVisibility,\n  shallowClone: () => shallowClone,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tickFormat: () => tickFormat,\n  tickStep: () => tickStep,\n  ticks: () => createTicks,\n  toDegrees: () => toDegrees,\n  toFixed: () => toFixed,\n  toRadians: () => toRadians,\n  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  uuid: () => uuid,\n  wednesday: () => wednesday,\n  year: () => year,\n  zipObject: () => zipObject\n});\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance: distance2,\n  distanceSquared: distanceSquared2,\n  from,\n  fromOffset,\n  length,\n  lengthSquared,\n  required,\n  rotate,\n  sub\n};\nfunction add(a, b) {\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance2(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared2(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction angle(a, b) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = required()) {\n  const l = Vec2.length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from(x, y) {\n  return { x, y };\n}\nfunction fromOffset(a) {\n  return { x: a.offsetX, y: a.offsetY };\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\n\n// packages/ag-charts-community/src/util/zip.ts\nfunction zipObject(keys, values) {\n  const zipped = {};\n  if (Array.isArray(values)) {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values[i];\n    }\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values;\n    }\n  }\n  return zipped;\n}\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  AreaSeriesTag: () => AreaSeriesTag,\n  Axis: () => Axis,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  AxisTicks: () => AxisTicks,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CachedTextMeasurer: () => CachedTextMeasurer,\n  CachedTextMeasurerPool: () => CachedTextMeasurerPool,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  Cursor: () => Cursor,\n  CursorManager: () => CursorManager,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DEGREE: () => DEGREE,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  GREATER_THAN: () => GREATER_THAN,\n  GestureDetector: () => GestureDetector,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightProperties: () => HighlightProperties,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  KeyNavManager: () => KeyNavManager,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  Layers: () => Layers,\n  LayoutService: () => LayoutService,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  Navigator: () => Navigator,\n  NavigatorModule: () => NavigatorModule,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PropertiesArray: () => PropertiesArray,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REGIONS: () => REGIONS,\n  RegionManager: () => RegionManager,\n  RepeatType: () => RepeatType,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Series: () => Series,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  SimpleTextMeasurer: () => SimpleTextMeasurer,\n  StateMachine: () => StateMachine,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  TextUtils: () => TextUtils,\n  TextWrapper: () => TextWrapper,\n  ToolbarManager: () => ToolbarManager,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  ZoomManager: () => ZoomManager,\n  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,\n  accumulateGroup: () => accumulateGroup,\n  accumulateStack: () => accumulateStack,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  allInStringUnion: () => allInStringUnion,\n  animationValidation: () => animationValidation,\n  area: () => area,\n  arraysEqual: () => arraysEqual,\n  backfillPathPointData: () => backfillPathPointData,\n  basicContinuousCheckDatumValidation: () => basicContinuousCheckDatumValidation,\n  bifurcate: () => bifurcate,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  childrenIter: () => childrenIter,\n  circularSliceArray: () => circularSliceArray,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,\n  countFractionDigits: () => countFractionDigits,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  createElementNS: () => createElementNS,\n  dateToNumber: () => dateToNumber,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepMerge: () => deepMerge,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  determinePathStatus: () => determinePathStatus,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  enterpriseModule: () => enterpriseModule,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMaxValue: () => findMaxValue,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  fromToMotion: () => fromToMotion,\n  getDocument: () => getDocument,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRectConfig: () => getRectConfig,\n  getWindow: () => getWindow,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupBy: () => groupBy,\n  groupCount: () => groupCount,\n  groupStackValueProperty: () => groupStackValueProperty,\n  groupSum: () => groupSum,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initToolbarKeyNav: () => initToolbarKeyNav,\n  isArray: () => isArray,\n  isBoolean: () => isBoolean,\n  isDate: () => isDate,\n  isDecoratedObject: () => isDecoratedObject,\n  isDefined: () => isDefined,\n  isEnumKey: () => isEnumKey,\n  isEnumValue: () => isEnumValue,\n  isEqual: () => isEqual,\n  isFiniteNumber: () => isFiniteNumber,\n  isFunction: () => isFunction,\n  isHtmlElement: () => isHtmlElement,\n  isNegative: () => isNegative,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isObjectLike: () => isObjectLike,\n  isPlainObject: () => isPlainObject,\n  isProperties: () => isProperties,\n  isRegExp: () => isRegExp,\n  isString: () => isString,\n  isSymbol: () => isSymbol,\n  isValidDate: () => isValidDate,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapIterable: () => mapIterable,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  minMax: () => minMax,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  pairCategoryData: () => pairCategoryData,\n  pairContinuousData: () => pairContinuousData,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathFadeOutAnimation: () => pathFadeOutAnimation,\n  pathRangePoints: () => pathRangePoints,\n  pathRangePointsReverse: () => pathRangePointsReverse,\n  pathRanges: () => pathRanges,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  pickNode: () => pickNode,\n  plotPath: () => plotPath,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareMarkerAnimation: () => prepareMarkerAnimation,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range2,\n  rangedValueProperty: () => rangedValueProperty,\n  renderPartialPath: () => renderPartialPath,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  scale: () => scale,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  splitPairData: () => splitPairData,\n  staticFromToMotion: () => staticFromToMotion,\n  stringify: () => stringify,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  times: () => times,\n  toArray: () => toArray,\n  toFixed: () => toFixed,\n  toTooltipHtml: () => toTooltipHtml,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  unique: () => unique,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  updateRect: () => updateRect,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    Logger.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/util/search.util.ts\nfunction findMaxValue(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value == null) {\n      max = index - 1;\n    } else {\n      found = value;\n      min = index + 1;\n    }\n  }\n  return found;\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  contains(other) {\n    let current = other;\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback2(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback2, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback2(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      contentGroupVirtual: false\n    });\n    this.rootNode = new HierarchyNode(\n      this,\n      0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      []\n    );\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.focusPath = [];\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  async processData() {\n    const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;\n    let index = 0;\n    const getIndex = () => {\n      index += 1;\n      return index;\n    };\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const colors = new Array((this.data?.length ?? 0) + 1).fill(void 0);\n    const createNode = (datum, parent) => {\n      const nodeIndex = getIndex();\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let size = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(size)) {\n        size = Math.max(size, 0);\n      } else {\n        size = isLeaf ? 1 : 0;\n      }\n      const sumSize = size;\n      maxDepth = Math.max(maxDepth, depth);\n      const color = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof color === \"number\") {\n        colors[nodeIndex] = color;\n        minColor = Math.min(minColor, color);\n        maxColor = Math.max(maxColor, color);\n      }\n      return appendChildren(\n        new HierarchyNode(\n          this,\n          nodeIndex,\n          datum,\n          size,\n          color,\n          void 0,\n          void 0,\n          sumSize,\n          depth,\n          parent,\n          []\n        ),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      data?.forEach((datum) => {\n        const child = createNode(datum, node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new HierarchyNode(\n        this,\n        0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        []\n      ),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    let colorScale;\n    if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n      colorScale = new ColorScale();\n      colorScale.domain = colorDomain;\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    rootNode.children.forEach((child, childIndex) => {\n      child.walk((node) => {\n        let fill;\n        const color = colors[node.index];\n        if (color != null) {\n          fill = colorScale?.convert(color);\n        }\n        fill ?? (fill = fills?.[childIndex % fills.length]);\n        node.fill = fill;\n        node.stroke = colorScale == null ? strokes?.[childIndex % strokes.length] : \"rgba(0, 0, 0, 0.2)\";\n      });\n    });\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n    this.focusPath = [{ nodeDatum: this.rootNode, childIndex: 0 }];\n  }\n  async update({ seriesRect }) {\n    await this.updateSelections();\n    await this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(data) {\n    const datum = this.animationResetFns?.datum;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const datum = this.animationResetFns?.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange, visible } = this.properties;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  pickFocus(opts) {\n    if (this.rootNode.children.length === 0)\n      return void 0;\n    if (this.focusPath.length === 0) {\n      Logger.error(\"this.focusPath should not be empty\");\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const { focusPath: path } = this;\n    const depth = path.length - 2;\n    if (depthDelta !== 0 || path.length === 1) {\n      const targetDepth = Math.max(0, depth + depthDelta);\n      if (path[targetDepth + 1] !== void 0) {\n        path.length = targetDepth + 2;\n        return this.computeFocusOutputs(path[targetDepth + 1]);\n      } else {\n        let deepest = path[path.length - 1];\n        while (deepest.nodeDatum.children.length > 0 && (deepest.nodeDatum.depth ?? -1) < targetDepth) {\n          const nextDeepest = { nodeDatum: deepest.nodeDatum.children[0], childIndex: 0 };\n          path.push(nextDeepest);\n          deepest = nextDeepest;\n        }\n        return this.computeFocusOutputs(deepest);\n      }\n    } else if (childDelta !== 0) {\n      const targetChild = path[depth + 1].childIndex + childDelta;\n      const currentParent = path[depth].nodeDatum;\n      const childCount = currentParent?.children?.length;\n      if (childCount !== void 0) {\n        const newChild = clamp(0, targetChild, childCount - 1);\n        const newFocus = { nodeDatum: currentParent.children[newChild], childIndex: newChild };\n        path[depth + 1] = newFocus;\n        path.length = depth + 2;\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else {\n      return this.computeFocusOutputs(path[path.length - 1]);\n    }\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof HierarchyNode)) {\n      Logger.error(`datum is not HierarchyNode: ${datum}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n  computeFocusOutputs({ nodeDatum, childIndex }) {\n    const bounds = this.computeFocusBounds(nodeDatum);\n    if (bounds) {\n      return {\n        datum: nodeDatum,\n        datumIndex: childIndex,\n        otherIndex: nodeDatum.depth,\n        bounds,\n        showFocusBox: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/util/tempUtils.ts\nfunction createIdsGenerator() {\n  const idsCounter = /* @__PURE__ */ new Map();\n  return (name) => {\n    const counter = idsCounter.get(name);\n    if (counter) {\n      idsCounter.set(name, counter + 1);\n      return `${name}${counter}`;\n    }\n    idsCounter.set(name, 1);\n    return name;\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axisTicks.ts\nvar _AxisTicks = class _AxisTicks {\n  constructor() {\n    this.id = createId(this);\n    this.axisGroup = new Group({ name: `${this.id}-AxisTicks`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.labelSelection = Selection.select(this.axisGroup, Text, false);\n    this.interval = new AxisInterval();\n    this.label = new AxisLabel();\n    this.scale = new LinearScale();\n    this.position = \"bottom\";\n    this.translationX = 0;\n    this.translationY = 0;\n    this.padding = 0;\n  }\n  attachAxis(axisNode) {\n    axisNode.appendChild(this.axisGroup);\n  }\n  calculateLayout() {\n    this.scale.interval = this.interval.step;\n    const boxes = [];\n    const tickData = this.generateTicks();\n    const { translationX, translationY } = this;\n    this.labelSelection.update(\n      tickData.ticks.map((d) => this.createLabelDatum(d)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n    this.labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n      if (datum.visible) {\n        boxes.push(node.getBBox());\n      }\n    });\n    this.axisGroup.setProperties({ translationX, translationY });\n    return BBox.merge(boxes);\n  }\n  getLabelParams(datum) {\n    const { padding } = this;\n    const { translate } = datum;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        return {\n          x: translate,\n          y: padding,\n          textAlign: \"center\",\n          textBaseline: \"top\"\n        };\n      case \"left\":\n      case \"right\":\n        return {\n          x: padding,\n          y: translate,\n          textAlign: \"start\",\n          textBaseline: \"middle\"\n        };\n    }\n  }\n  inRange(x, tolerance = 1e-3) {\n    const [min, max] = findMinMax(this.scale.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  createLabelDatum(datum) {\n    const { x, y, textBaseline, textAlign } = this.getLabelParams(datum);\n    return {\n      visible: Boolean(datum.tickLabel),\n      tickId: datum.tickId,\n      fill: this.label.color,\n      fontFamily: this.label.fontFamily,\n      fontSize: this.label.fontSize,\n      fontStyle: this.label.fontStyle,\n      fontWeight: this.label.fontWeight,\n      rotation: 0,\n      rotationCenterX: 0,\n      text: datum.tickLabel,\n      textAlign,\n      textBaseline,\n      x,\n      y\n    };\n  }\n  generateTicks() {\n    const { minSpacing, maxSpacing } = this.interval;\n    const extentWithBleed = round(findRangeExtent(this.scale.range), 2);\n    const { maxTickCount, minTickCount, tickCount } = estimateTickCount(\n      extentWithBleed,\n      minSpacing,\n      maxSpacing,\n      _AxisTicks.DefaultTickCount,\n      _AxisTicks.DefaultMinSpacing\n    );\n    if (tickCount) {\n      this.scale.tickCount = tickCount;\n      this.scale.minTickCount = minTickCount;\n      this.scale.maxTickCount = maxTickCount;\n    }\n    const tickData = this.getTicksData();\n    if (this.position === \"bottom\" || this.position === \"top\") {\n      const measurer = CachedTextMeasurerPool.getMeasurer({ font: this.label });\n      let lastTickPosition = -Infinity;\n      tickData.ticks = tickData.ticks.filter((data) => {\n        if (lastTickPosition < data.translate) {\n          lastTickPosition = data.translate + measurer.textWidth(data.tickLabel, true);\n          return true;\n        }\n      });\n    }\n    return tickData;\n  }\n  getTicksData() {\n    const ticks = [];\n    const rawTicks = this.scale.ticks();\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const idGenerator = createIdsGenerator();\n    const labelFormatter = this.label.format ? this.scale.tickFormat({ ticks: rawTicks, specifier: this.label.format }) : (x) => isNumber(x) ? x.toFixed(fractionDigits) : String(x);\n    for (let index = 0; index < rawTicks.length; index++) {\n      const tick = rawTicks[index];\n      const translate = this.scale.convert(tick);\n      if (!this.inRange(translate))\n        continue;\n      const tickLabel = this.label.formatter?.({ value: tick, index, fractionDigits }) ?? labelFormatter(tick);\n      const tickId = idGenerator(tickLabel);\n      ticks.push({ tick, tickId, tickLabel, translate });\n    }\n    return { rawTicks, fractionDigits, ticks };\n  }\n};\n_AxisTicks.DefaultTickCount = 5;\n_AxisTicks.DefaultMinSpacing = 50;\nvar AxisTicks = _AxisTicks;\n\n// packages/ag-charts-community/src/chart/legendDatum.ts\nvar __FORCE_MODULE_DETECTION = 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtY29tbXVuaXR5L2Rpc3QvcGFja2FnZS9tYWluLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EsdUNBQXVDLE1BQU0sWUFBWSxNQUFNLHFCQUFxQixZQUFZO0FBQ2hHO0FBQ0EsMENBQTBDLE9BQU8sS0FBSyxNQUFNLFNBQVMsTUFBTSxLQUFLLEdBQUcsSUFBSSxVQUFVLEVBQUUsS0FBSztBQUN4RztBQUNBLDBDQUEwQyxPQUFPLEtBQUssTUFBTSxJQUFJLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sZ0JBQWdCLE1BQU0sY0FBYyxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLGVBQWUsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0VBQXNFLFFBQVE7QUFDOUUsR0FBRztBQUNIO0FBQ0Esd0VBQXdFLFFBQVE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXLGdCQUFnQixLQUFLO0FBQzNFO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0EsZ0JBQWdCLCtCQUErQixJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxxQ0FBcUMsWUFBWTtBQUNsRjtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0sOEJBQThCLGtCQUFrQjtBQUNqRjtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QixRQUFRLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRkFBa0Y7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQyxpQ0FBaUMsU0FBUyxFQUFFLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxJQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywyQ0FBMkMsSUFBSTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxFQUFFLElBQUksRUFBRTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRLEdBQUcsTUFBTSxHQUFHLFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGNBQWMsa0RBQWtEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxHQUFHLE1BQU0sYUFBYSxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXLFFBQVEsR0FBRyxNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssRUFBRSw2Q0FBNkMsRUFBRSw2Q0FBNkM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQyxFQUFFLE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixlQUFlLEVBQUUsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0EsOENBQThDLDZEQUE2RCxrQ0FBa0Msb0RBQW9EO0FBQ2pNLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFvRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsOENBQThDLHNEQUFzRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRDQUE0QztBQUNwRjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNEJBQTRCO0FBQzFFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUF5RDtBQUNyRSw0QkFBNEI7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpRUFBaUUsdUJBQXVCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FB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QUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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T0FBTyxrQkFBa0IsR0FBRztBQUN4RTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsa0JBQWtCLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxN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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLFVBQVU7QUFDcEMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVLDBEQUEwRDtBQUNwRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLDhGQUE4RixZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEUsVUFBVSxhQUFhO0FBQ3ZCLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlGQUFpRjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFD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Q2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLG1EQUFtRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBMkM7QUFDdEUsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLHdFQUF3RSxzQkFBc0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sd0JBQXdCLGlCQUFpQixJQUFJLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBNkQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDRCQUE0QjtBQUN4RztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLE1BQU07QUFDTixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLGlDQUFpQztBQUM3QyxZQUFZLCtCQUErQiwrQ0FBK0M7QUFDMUY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUErRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUVBQXlFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBZ0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvRUFBb0UsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwREFBMEQsNEJBQTRCO0FBQ3RGLHdCQUF3QixpRUFBaUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGFBQWEsY0FBYztBQUMzQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw0QkFBNEI7QUFDdEYsOEJBQThCLDhEQUE4RDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsVUFBVSw2REFBNkQ7QUFDdkUsd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixnQkFBZ0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFtRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0RUFBNEU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrREFBa0Q7QUFDOUQsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRCxVQUFVLHVCQUF1QjtBQUNqQyxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFLG1HQUFtRyxVQUFVO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFrRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQSwwREFBMEQsS0FBSyxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhDQUE4QyxnQkFBZ0I7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBLGFBQWEsUUFBUSxHQUFHLE1BQU0sR0FBRyxRQUFRLEdBQUcsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sWUFBWTtBQUNsQixNQUFNO0FBQ047QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEIsTUFBTSxZQUFZO0FBQ2xCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBcUU7QUFDakYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0MseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEIsUUFBUSxnQkFBZ0I7QUFDeEIsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLGtCQUFrQjtBQUMxQixRQUFRLGdCQUFnQjtBQUN4QixRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4REFBOEQ7QUFDeEUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9FQUFvRTtBQUNoRixZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1I7QUFDQSxZQUFZLHlFQUF5RTtBQUNyRixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDLG1CQUFtQjtBQUNuQiwwRUFBMEUsWUFBWSxJQUFJLFlBQVk7QUFDdEc7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQjtBQUNoQyxNQUFNLDBCQUEwQjtBQUNoQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFVBQVU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRSxVQUFVLG1EQUFtRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sY0FBYztBQUNwQjtBQUNBO0FBQ0EsZUFBZSw0Q0FBNEM7QUFDM0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DLCtEQUErRCxZQUFZLElBQUksWUFBWSxJQUFJLE9BQU87QUFDdEc7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQywrREFBK0QsWUFBWSxJQUFJLFlBQVksSUFBSSxpQkFBaUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZELHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0REFBNEQ7QUFDNUQsVUFBVSxzREFBc0Q7QUFDaEU7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25ELDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEMs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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdGQUF3RjtBQUNwRyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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NEJBQTRCLElBQUk7QUFDaEMsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw0QkFBNEI7QUFDeEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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MUQ7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzR0FBc0c7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRLFVBQVUsaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLElBQUk7QUFDSixvQkFBb0IsaUJBQWlCO0FBQ3JDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0JBQWtCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLCtDQUErQztBQUN0SCx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBZUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FnLWNoYXJ0cy1jb21tdW5pdHkvZGlzdC9wYWNrYWdlL21haW4uZXNtLm1qcz8zNzlkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19kZWNvcmF0ZUNsYXNzID0gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBraW5kKSA9PiB7XG4gIHZhciByZXN1bHQgPSBraW5kID4gMSA/IHZvaWQgMCA6IGtpbmQgPyBfX2dldE93blByb3BEZXNjKHRhcmdldCwga2V5KSA6IHRhcmdldDtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMSwgZGVjb3JhdG9yOyBpID49IDA7IGktLSlcbiAgICBpZiAoZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgIHJlc3VsdCA9IChraW5kID8gZGVjb3JhdG9yKHRhcmdldCwga2V5LCByZXN1bHQpIDogZGVjb3JhdG9yKHJlc3VsdCkpIHx8IHJlc3VsdDtcbiAgaWYgKGtpbmQgJiYgcmVzdWx0KVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1sb2NhbGUvc3JjL2VuLVVTLnRzXG52YXIgQUdfQ0hBUlRTX0xPQ0FMRV9FTl9VUyA9IHtcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiB0aGUgZm9jdXNlZCBpdGVtIGJlY29tZXMgdmlzaWJsZVxuICBhcmlhQW5ub3VuY2VWaXNpYmxlOiBcInZpc2libGVcIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiB0aGUgZm9jdXNlZCBpdGVtIGJlY29tZXMgaGlkZGVuXG4gIGFyaWFBbm5vdW5jZUhpZGRlbjogXCJoaWRkZW5cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhbiBpdGVtIGluIHRoZSBjaGFydFxuICBhcmlhQW5ub3VuY2VIb3ZlckRhdHVtOiBcIiR7ZGF0dW19XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBjaGFydFxuICBhcmlhQW5ub3VuY2VDaGFydDogXCJjaGFydCwgJHtzZXJpZXNDb3VudH1bbnVtYmVyXSBzZXJpZXNcIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhbiBpdGVtIGluIGEgdHJlZW1hcCBvciBzdW5idXJzdCBjaGFydFxuICBhcmlhQW5ub3VuY2VIaWVyYXJjaHlEYXR1bTogXCJsZXZlbCAke2xldmVsfVtudW1iZXJdLCAke2NvdW50fVtudW1iZXJdIGNoaWxkcmVuLCAke2Rlc2NyaXB0aW9ufVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgbGluayBpbiBhIFNhbmtleSBvciBjaG9yZCBjaGFydFxuICBhcmlhQW5ub3VuY2VGbG93UHJvcG9ydGlvbkxpbms6IFwibGluayAke2luZGV4fSBvZiAke2NvdW50fSwgZnJvbSAke2Zyb219IHRvICR7dG99LCAke3NpemVOYW1lfSAke3NpemV9XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBub2RlIGluIGEgU2Fua2V5IG9yIGNob3JkIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUZsb3dQcm9wb3J0aW9uTm9kZTogXCJub2RlICR7aW5kZXh9IG9mICR7Y291bnR9LCAke2Rlc2NyaXB0aW9ufVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFubm90YXRpb24tb3B0aW9ucyB0b29sYmFyXG4gIGFyaWFMYWJlbEFubm90YXRpb25PcHRpb25zVG9vbGJhcjogXCJBbm5vdGF0aW9uIE9wdGlvbnNcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgY29sb3IgcGlja2VyIGRpYWxvZ1xuICBhcmlhTGFiZWxDb2xvclBpY2tlcjogXCJDb2xvciBwaWNrZXJcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgZmluYW5jaWFsIGNoYXJ0cyB0b29sYmFyXG4gIGFyaWFMYWJlbEZpbmFuY2lhbENoYXJ0czogXCJGaW5hbmNpYWwgQ2hhcnRzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGxlZ2VuZCB0b29sYmFyXG4gIGFyaWFMYWJlbExlZ2VuZDogXCJMZWdlbmRcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbGVnZW5kIHBhZ2luYXRpb24gYnV0dG9uXG4gIGFyaWFMYWJlbExlZ2VuZFBhZ2luYXRpb246IFwiTGVnZW5kIFBhZ2luYXRpb25cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgcHJldmlvdXMgbGVnZW5kIHBhZ2UgYnV0dG9uXG4gIGFyaWFMYWJlbExlZ2VuZFBhZ2VQcmV2aW91czogXCJQcmV2aW91cyBMZWdlbmQgUGFnZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBuZXh0IGxlZ2VuZCBwYWdlIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdlTmV4dDogXCJOZXh0IExlZ2VuZCBQYWdlXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGFuIGl0ZW0gaW4gdGhlIGxlZ2VuZFxuICBhcmlhTGFiZWxMZWdlbmRJdGVtOiBcIiR7bGFiZWx9LCBMZWdlbmQgaXRlbSAke2luZGV4fVtudW1iZXJdIG9mICR7Y291bnR9W251bWJlcl0sIFwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBhbiB1bmtub3duIGl0ZW0gaW4gdGhlIGxlZ2VuZFxuICBhcmlhTGFiZWxMZWdlbmRJdGVtVW5rbm93bjogXCJVbmtub3duIGxlZ2VuZCBpdGVtXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIG5hdmlnYXRvciBlbGVtZW50XG4gIGFyaWFMYWJlbE5hdmlnYXRvcjogXCJOYXZpZ2F0b3JcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbiBhY2Nlc3NpYmlsaXR5IGNvbnRyb2wgdGhhdCBjaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmF2aWdhdG9yJ3MgcmFuZ2VcbiAgYXJpYUxhYmVsTmF2aWdhdG9yUmFuZ2U6IFwiUmFuZ2VcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbiBhY2Nlc3NpYmlsaXR5IGNvbnRyb2wgdGhhdCBjaGFuZ2VzIHRoZSBzdGFydCBvZiB0aGUgbmF2aWdhdG9yJ3MgcmFuZ2VcbiAgYXJpYUxhYmVsTmF2aWdhdG9yTWluaW11bTogXCJNaW5pbXVtXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW4gYWNjZXNzaWJpbGl0eSBjb250cm9sIHRoYXQgY2hhbmdlcyB0aGUgZW5kIG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JNYXhpbXVtOiBcIk1heGltdW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciByYW5nZXMgdG9vbGJhclxuICBhcmlhTGFiZWxSYW5nZXNUb29sYmFyOiBcIlJhbmdlc1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHpvb20gdG9vbGJhclxuICBhcmlhTGFiZWxab29tVG9vbGJhcjogXCJab29tXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIHZhbHVlIG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhVmFsdWVQYW5SYW5nZTogXCIke21pbn1bcGVyY2VudF0gdG8gJHttYXh9W3BlcmNlbnRdXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdsb2FkaW5nIGRhdGEnIG92ZXJsYXlcbiAgb3ZlcmxheUxvYWRpbmdEYXRhOiBcIkxvYWRpbmcgZGF0YS4uLlwiLFxuICAvLyBEZWZhdWx0IHRleHQgZm9yIHRoZSAnbm8gZGF0YScgb3ZlcmxheVxuICBvdmVybGF5Tm9EYXRhOiBcIk5vIGRhdGEgdG8gZGlzcGxheVwiLFxuICAvLyBEZWZhdWx0IHRleHQgZm9yIHRoZSAnbm8gdmlzaWJsZSBzZXJpZXMnIG92ZXJsYXlcbiAgb3ZlcmxheU5vVmlzaWJsZVNlcmllczogXCJObyB2aXNpYmxlIHNlcmllc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlRHJvcGRvd246IFwiQ2hhcnQgVHlwZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIE9ITEMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVPSExDOiBcIk9ITENcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBITEMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVITEM6IFwiSExDXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgaGlnaCBsb3cgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVIaWdoTG93OiBcIkhpZ2ggTG93XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgY2FuZGxlcyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUNhbmRsZXM6IFwiQ2FuZGxlc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGhvbGxvdyBjYW5kbGVzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlSG9sbG93Q2FuZGxlczogXCJIb2xsb3cgQ2FuZGxlc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGxpbmUgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVMaW5lOiBcIkxpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBsaW5lIHdpdGggbWFya2VycyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUxpbmVXaXRoTWFya2VyczogXCJMaW5lIHdpdGggTWFya2Vyc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGxpbmUgd2l0aCBzdGVwIGxpbmUgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVTdGVwTGluZTogXCJTdGVwIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRyZW5kIGxpbmUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RyZW5kTGluZTogXCJUcmVuZCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBob3Jpem9udGFsIGxpbmUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0hvcml6b250YWxMaW5lOiBcIkhvcml6b250YWwgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdmVydGljYWwgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVmVydGljYWxMaW5lOiBcIlZlcnRpY2FsIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHBhcmFsbGVsIGNoYW5uZWwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1BhcmFsbGVsQ2hhbm5lbDogXCJQYXJhbGxlbCBDaGFubmVsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkaXNqb2ludCBjaGFubmVsIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEaXNqb2ludENoYW5uZWw6IFwiRGlzam9pbnQgQ2hhbm5lbFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgY2xlYXIgYWxsIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNDbGVhckFsbDogXCJDbGVhciBBbGxcIixcbiAgLyoqXG4gICAqIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgICogQGRlcHJlY2F0ZWQgdjEwLjEuMCB1c2UgYHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvcmAgaW5zdGVhZC5cbiAgICovXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NvbG9yOiBcIkNvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBmaWxsIGNvbG9yIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNGaWxsQ29sb3I6IFwiRmlsbCBDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbGluZSBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTGluZUNvbG9yOiBcIkxpbmUgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHRDb2xvcjogXCJUZXh0IENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IHNpemUgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHRTaXplOiBcIlRleHQgU2l6ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbG9jayBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMb2NrOiBcIkxvY2tcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHVubG9jayBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNVbmxvY2s6IFwiVW5sb2NrXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkZWxldGUgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRGVsZXRlOiBcIkRlbGV0ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbGluZSBhbm5vdGF0aW9ucyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQW5ub3RhdGlvbnM6IFwiVHJlbmQgTGluZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgYW5ub3RhdGlvbnMgbWVudSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dEFubm90YXRpb25zOiBcIlRleHQgQW5ub3RhdGlvbnNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNhbGxvdXQgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NhbGxvdXQ6IFwiQ2FsbG91dFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgY29tbWVudCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zQ29tbWVudDogXCJDb21tZW50XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBub3RlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNOb3RlOiBcIk5vdGVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHQ6IFwiVGV4dFwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFNb250aDogXCIxTVwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFNb250aEFyaWE6IFwiMSBtb250aFwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDMgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTNNb250aHM6IFwiM01cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAzIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UzTW9udGhzQXJpYTogXCIzIG1vbnRoc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDYgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTZNb250aHM6IFwiNk1cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyA2IG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2U2TW9udGhzQXJpYTogXCI2IG1vbnRoc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIHllYXIgdG8gZGF0ZSBidXR0b25cbiAgdG9vbGJhclJhbmdlWWVhclRvRGF0ZTogXCJZVERcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyB5ZWFyIHRvIGRhdGUgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZVllYXJUb0RhdGVBcmlhOiBcIlllYXIgdG8gZGF0ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgeWVhciBidXR0b25cbiAgdG9vbGJhclJhbmdlMVllYXI6IFwiMVlcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIHllYXIgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFZZWFyQXJpYTogXCIxIHllYXJcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyBmdWxsIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VBbGw6IFwiQWxsXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgZnVsbCByYW5nZSBidXR0b25cbiAgdG9vbGJhclJhbmdlQWxsQXJpYTogXCJBbGxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHpvb20gb3V0IGJ1dHRvblxuICB0b29sYmFyWm9vbVpvb21PdXQ6IFwiWm9vbSBvdXRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHpvb20gaW4gYnV0dG9uXG4gIHRvb2xiYXJab29tWm9vbUluOiBcIlpvb20gaW5cIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiBsZWZ0IGJ1dHRvblxuICB0b29sYmFyWm9vbVBhbkxlZnQ6IFwiUGFuIGxlZnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiByaWdodCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5SaWdodDogXCJQYW4gcmlnaHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiB0byB0aGUgc3RhcnQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuU3RhcnQ6IFwiUGFuIHRvIHRoZSBzdGFydFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHRvIHRoZSBlbmQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuRW5kOiBcIlBhbiB0byB0aGUgZW5kXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gcmVzZXQgYnV0dG9uXG4gIHRvb2xiYXJab29tUmVzZXQ6IFwiUmVzZXQgdGhlIHpvb21cIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIGRvd25sb2FkIGJ1dHRvblxuICBjb250ZXh0TWVudURvd25sb2FkOiBcIkRvd25sb2FkXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyB0b2dnbGUgc2VyaWVzIHZpc2liaWxpdHkgYnV0dG9uXG4gIGNvbnRleHRNZW51VG9nZ2xlU2VyaWVzVmlzaWJpbGl0eTogXCJUb2dnbGUgVmlzaWJpbGl0eVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgdG9nZ2xlIG90aGVyIHNlcmllcyB2aXNpYmlsaXR5IGJ1dHRvblxuICBjb250ZXh0TWVudVRvZ2dsZU90aGVyU2VyaWVzOiBcIlRvZ2dsZSBPdGhlciBTZXJpZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHpvb20gdG8gcG9pbnQgYnV0dG9uXG4gIGNvbnRleHRNZW51Wm9vbVRvQ3Vyc29yOiBcIlpvb20gdG8gaGVyZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgcGFuIHRvIHBvaW50IGJ1dHRvblxuICBjb250ZXh0TWVudVBhblRvQ3Vyc29yOiBcIlBhbiB0byBoZXJlXCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvZXJyb3JCYXJPcHRpb25zLnRzXG52YXIgQWdFcnJvckJhclN1cHBvcnRlZFNlcmllc1R5cGVzID0gW1wiYmFyXCIsIFwibGluZVwiLCBcInNjYXR0ZXJcIl07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvbmF2aWdhdG9yT3B0aW9ucy50c1xudmFyIF9fTUlOSV9DSEFSVF9TRVJJRVNfT1BUSU9OUyA9IHt9O1xudmFyIF9fVkVSSUZZX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSB2b2lkIDA7XG5fX1ZFUklGWV9NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0gX19NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3Rvb2xiYXJPcHRpb25zLnRzXG52YXIgSUNPTlNfTEVHQUNZID0gW1xuICBcImRlbGV0ZS1sZWdhY3lcIixcbiAgXCJkaXNqb2ludC1jaGFubmVsXCIsXG4gIFwiZGlzam9pbnQtY2hhbm5lbC1sZWdhY3lcIixcbiAgXCJob3Jpem9udGFsLWxpbmUtbGVnYWN5XCIsXG4gIFwibGluZS1jb2xvci1sZWdhY3lcIixcbiAgXCJsb2NrXCIsXG4gIFwibG9jay1sZWdhY3lcIixcbiAgXCJwYW4tZW5kLWxlZ2FjeVwiLFxuICBcInBhbi1sZWZ0LWxlZ2FjeVwiLFxuICBcInBhbi1yaWdodC1sZWdhY3lcIixcbiAgXCJwYW4tc3RhcnQtbGVnYWN5XCIsXG4gIFwicGFyYWxsZWwtY2hhbm5lbFwiLFxuICBcInBhcmFsbGVsLWNoYW5uZWwtbGVnYWN5XCIsXG4gIFwicmVzZXQtbGVnYWN5XCIsXG4gIFwidHJlbmQtbGluZVwiLFxuICBcInRyZW5kLWxpbmUtbGVnYWN5XCIsXG4gIFwidW5sb2NrXCIsXG4gIFwidW5sb2NrLWxlZ2FjeVwiLFxuICBcInZlcnRpY2FsLWxpbmVcIixcbiAgXCJ2ZXJ0aWNhbC1saW5lLWxlZ2FjeVwiLFxuICBcInpvb20taW4tbGVnYWN5XCIsXG4gIFwiem9vbS1pbi1hbHRcIixcbiAgXCJ6b29tLWluLWFsdC1sZWdhY3lcIixcbiAgXCJ6b29tLW91dC1sZWdhY3lcIixcbiAgXCJ6b29tLW91dC1hbHRcIixcbiAgXCJ6b29tLW91dC1hbHQtbGVnYWN5XCJcbl07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvdG9vbHRpcE9wdGlvbnMudHNcbnZhciBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyKSA9PiB7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJQT0lOVEVSXCJdID0gXCJwb2ludGVyXCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJOT0RFXCJdID0gXCJub2RlXCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJUT1BcIl0gPSBcInRvcFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiUklHSFRcIl0gPSBcInJpZ2h0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJCT1RUT01cIl0gPSBcImJvdHRvbVwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QX0xFRlRcIl0gPSBcInRvcC1sZWZ0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJUT1BfUklHSFRcIl0gPSBcInRvcC1yaWdodFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiQk9UVE9NX1JJR0hUXCJdID0gXCJib3R0b20tcmlnaHRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkJPVFRPTV9MRUZUXCJdID0gXCJib3R0b20tbGVmdFwiO1xuICByZXR1cm4gQWdUb29sdGlwUG9zaXRpb25UeXBlMjtcbn0pKEFnVG9vbHRpcFBvc2l0aW9uVHlwZSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvdGhlbWVPcHRpb25zLnRzXG52YXIgX19USEVNRV9PVkVSUklERVMgPSB7fTtcbnZhciBfX1ZFUklGWV9USEVNRV9PVkVSUklERVMgPSB2b2lkIDA7XG5fX1ZFUklGWV9USEVNRV9PVkVSUklERVMgPSBfX1RIRU1FX09WRVJSSURFUztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2luZGV4LnRzXG52YXIgdGltZV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0aW1lX2V4cG9ydHMsIHtcbiAgVGltZUludGVydmFsOiAoKSA9PiBUaW1lSW50ZXJ2YWwsXG4gIGRheTogKCkgPT4gZGF5LFxuICBmcmlkYXk6ICgpID0+IGZyaWRheSxcbiAgaG91cjogKCkgPT4gaG91cixcbiAgbWlsbGlzZWNvbmQ6ICgpID0+IG1pbGxpc2Vjb25kLFxuICBtaW51dGU6ICgpID0+IG1pbnV0ZSxcbiAgbW9uZGF5OiAoKSA9PiBtb25kYXksXG4gIG1vbnRoOiAoKSA9PiBtb250aCxcbiAgc2F0dXJkYXk6ICgpID0+IHNhdHVyZGF5LFxuICBzZWNvbmQ6ICgpID0+IHNlY29uZCxcbiAgc3VuZGF5OiAoKSA9PiBzdW5kYXksXG4gIHRodXJzZGF5OiAoKSA9PiB0aHVyc2RheSxcbiAgdHVlc2RheTogKCkgPT4gdHVlc2RheSxcbiAgdXRjRGF5OiAoKSA9PiB1dGNEYXksXG4gIHV0Y0hvdXI6ICgpID0+IHV0Y0hvdXIsXG4gIHV0Y01pbnV0ZTogKCkgPT4gdXRjTWludXRlLFxuICB1dGNNb250aDogKCkgPT4gdXRjTW9udGgsXG4gIHV0Y1llYXI6ICgpID0+IHV0Y1llYXIsXG4gIHdlZG5lc2RheTogKCkgPT4gd2VkbmVzZGF5LFxuICB5ZWFyOiAoKSA9PiB5ZWFyXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9mdW5jdGlvbi50c1xudmFyIGRvT25jZVN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGRvT25jZShmdW5jLCBrZXkpIHtcbiAgaWYgKGRvT25jZVN0YXRlLmhhcyhrZXkpKVxuICAgIHJldHVybjtcbiAgZG9PbmNlU3RhdGUuc2V0KGtleSwgdHJ1ZSk7XG4gIGZ1bmMoKTtcbn1cbmRvT25jZS5jbGVhciA9ICgpID0+IGRvT25jZVN0YXRlLmNsZWFyKCk7XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24qIGl0ZXJhdGUoLi4uaXRlcmF0b3JzKSB7XG4gIGZvciAoY29uc3QgaXRlcmF0b3Igb2YgaXRlcmF0b3JzKSB7XG4gICAgeWllbGQqIGl0ZXJhdG9yO1xuICB9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjazIsIHdhaXRNcyA9IDAsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgdGltZXJJZDtcbiAgbGV0IGxhc3RBcmdzO1xuICBsZXQgc2hvdWxkV2FpdCA9IGZhbHNlO1xuICBmdW5jdGlvbiB0aW1lb3V0SGFuZGxlcigpIHtcbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVvdXRIYW5kbGVyLCB3YWl0TXMpO1xuICAgICAgY2FsbGJhY2syKC4uLmxhc3RBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkV2FpdCA9IGZhbHNlO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3R0bGVDYWxsYmFjayguLi5hcmdzKSB7XG4gICAgaWYgKHNob3VsZFdhaXQpIHtcbiAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkV2FpdCA9IHRydWU7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lb3V0SGFuZGxlciwgd2FpdE1zKTtcbiAgICAgIGlmIChsZWFkaW5nKSB7XG4gICAgICAgIGNhbGxiYWNrMiguLi5hcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhyb3R0bGVDYWxsYmFjaywge1xuICAgIGNhbmNlbCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgIHNob3VsZFdhaXQgPSBmYWxzZTtcbiAgICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gam9pbkZ1bmN0aW9ucyguLi5mbnMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbG9nZ2VyLnRzXG52YXIgTG9nZ2VyID0ge1xuICBsb2coLi4ubG9nQ29udGVudCkge1xuICAgIGNvbnNvbGUubG9nKC4uLmxvZ0NvbnRlbnQpO1xuICB9LFxuICB3YXJuKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBjb25zb2xlLndhcm4oYEFHIENoYXJ0cyAtICR7bWVzc2FnZX1gLCAuLi5sb2dDb250ZW50KTtcbiAgfSxcbiAgZXJyb3IobWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc29sZS5lcnJvcihgQUcgQ2hhcnRzIGVycm9yYCwgbWVzc2FnZSwgLi4ubG9nQ29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFHIENoYXJ0cyAtICR7bWVzc2FnZX1gLCAuLi5sb2dDb250ZW50KTtcbiAgICB9XG4gIH0sXG4gIHRhYmxlKC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBjb25zb2xlLnRhYmxlKC4uLmxvZ0NvbnRlbnQpO1xuICB9LFxuICB3YXJuT25jZShtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgZG9PbmNlKCgpID0+IExvZ2dlci53YXJuKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpLCBgTG9nZ2VyLndhcm46ICR7bWVzc2FnZX1gKTtcbiAgfSxcbiAgZXJyb3JPbmNlKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBkb09uY2UoKCkgPT4gTG9nZ2VyLmVycm9yKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpLCBgTG9nZ2VyLmVycm9yOiAke21lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9pbnRlcnZhbC50c1xudmFyIFRpbWVJbnRlcnZhbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2VuY29kZSwgX2RlY29kZSwgX3JhbmdlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9lbmNvZGUgPSBfZW5jb2RlO1xuICAgIHRoaXMuX2RlY29kZSA9IF9kZWNvZGU7XG4gICAgdGhpcy5fcmFuZ2VDYWxsYmFjayA9IF9yYW5nZUNhbGxiYWNrO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGRhdGUgcmVwcmVzZW50aW5nIHRoZSBsYXRlc3QgaW50ZXJ2YWwgYm91bmRhcnkgZGF0ZSBiZWZvcmUgb3IgZXF1YWwgdG8gZGF0ZS5cbiAgICogRm9yIGV4YW1wbGUsIGBkYXkuZmxvb3IoZGF0ZSlgIHR5cGljYWxseSByZXR1cm5zIDEyOjAwIEFNIGxvY2FsIHRpbWUgb24gdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqL1xuICBmbG9vcihkYXRlKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9lbmNvZGUoZCk7XG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZShlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBkYXRlIHJlcHJlc2VudGluZyB0aGUgZWFybGllc3QgaW50ZXJ2YWwgYm91bmRhcnkgZGF0ZSBhZnRlciBvciBlcXVhbCB0byBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKi9cbiAgY2VpbChkYXRlKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKE51bWJlcihkYXRlKSAtIDEpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9lbmNvZGUoZCk7XG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZShlICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZGF0ZXMgcmVwcmVzZW50aW5nIGV2ZXJ5IGludGVydmFsIGJvdW5kYXJ5IGFmdGVyIG9yIGVxdWFsIHRvIHN0YXJ0IChpbmNsdXNpdmUpIGFuZCBiZWZvcmUgc3RvcCAoZXhjbHVzaXZlKS5cbiAgICogQHBhcmFtIHN0YXJ0IFJhbmdlIHN0YXJ0LlxuICAgKiBAcGFyYW0gc3RvcCBSYW5nZSBlbmQuXG4gICAqIEBwYXJhbSBleHRlbmQgSWYgc3BlY2lmaWVkLCB0aGUgcmVxdWVzdGVkIHJhbmdlIHdpbGwgYmUgZXh0ZW5kZWQgdG8gdGhlIGNsb3Nlc3QgXCJuaWNlXCIgdmFsdWVzLlxuICAgKi9cbiAgcmFuZ2Uoc3RhcnQsIHN0b3AsIGV4dGVuZCkge1xuICAgIGNvbnN0IHJhbmdlQ2FsbGJhY2sgPSB0aGlzLl9yYW5nZUNhbGxiYWNrPy4oc3RhcnQsIHN0b3ApO1xuICAgIGNvbnN0IGUwID0gdGhpcy5fZW5jb2RlKGV4dGVuZCA/IHRoaXMuZmxvb3Ioc3RhcnQpIDogdGhpcy5jZWlsKHN0YXJ0KSk7XG4gICAgY29uc3QgZTEgPSB0aGlzLl9lbmNvZGUoZXh0ZW5kID8gdGhpcy5jZWlsKHN0b3ApIDogdGhpcy5mbG9vcihzdG9wKSk7XG4gICAgaWYgKGUxIDwgZTApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UzID0gW107XG4gICAgZm9yIChsZXQgZSA9IGUwOyBlIDw9IGUxOyBlKyspIHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLl9kZWNvZGUoZSk7XG4gICAgICByYW5nZTMucHVzaChkKTtcbiAgICB9XG4gICAgcmFuZ2VDYWxsYmFjaz8uKCk7XG4gICAgcmV0dXJuIHJhbmdlMztcbiAgfVxufTtcbnZhciBDb3VudGFibGVUaW1lSW50ZXJ2YWwgPSBjbGFzcyBleHRlbmRzIFRpbWVJbnRlcnZhbCB7XG4gIGdldE9mZnNldChzbmFwVG8sIHN0ZXApIHtcbiAgICBjb25zdCBzID0gdHlwZW9mIHNuYXBUbyA9PT0gXCJudW1iZXJcIiB8fCBzbmFwVG8gaW5zdGFuY2VvZiBEYXRlID8gdGhpcy5fZW5jb2RlKG5ldyBEYXRlKHNuYXBUbykpIDogMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihzKSAlIHN0ZXA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmaWx0ZXJlZCB2aWV3IG9mIHRoaXMgaW50ZXJ2YWwgcmVwcmVzZW50aW5nIGV2ZXJ5IHN0ZXAndGggZGF0ZS5cbiAgICogSXQgY2FuIGJlIGEgbnVtYmVyIG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzIGV0Yy5cbiAgICogTXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXG4gICAqIEBwYXJhbSBzdGVwXG4gICAqL1xuICBldmVyeShzdGVwLCBvcHRpb25zKSB7XG4gICAgbGV0IG9mZnNldDQgPSAwO1xuICAgIGxldCByYW5nZUNhbGxiYWNrO1xuICAgIGNvbnN0IHVuc2FmZVN0ZXAgPSBzdGVwO1xuICAgIHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHN0ZXApKTtcbiAgICBpZiAodW5zYWZlU3RlcCAhPT0gc3RlcCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBpbnRlcnZhbCBzdGVwIG9mIFske3Vuc2FmZVN0ZXB9XSByb3VuZGVkIHRvIFske3N0ZXB9XS5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBzbmFwVG8gPSBcInN0YXJ0XCIgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHR5cGVvZiBzbmFwVG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBvZmZzZXQ0O1xuICAgICAgcmFuZ2VDYWxsYmFjayA9IChzdGFydCwgc3RvcCkgPT4ge1xuICAgICAgICBjb25zdCBzID0gc25hcFRvID09PSBcInN0YXJ0XCIgPyBzdGFydCA6IHN0b3A7XG4gICAgICAgIG9mZnNldDQgPSB0aGlzLmdldE9mZnNldChzLCBzdGVwKTtcbiAgICAgICAgcmV0dXJuICgpID0+IG9mZnNldDQgPSBpbml0aWFsT2Zmc2V0O1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzbmFwVG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG9mZnNldDQgPSB0aGlzLmdldE9mZnNldChuZXcgRGF0ZShzbmFwVG8pLCBzdGVwKTtcbiAgICB9IGVsc2UgaWYgKHNuYXBUbyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIG9mZnNldDQgPSB0aGlzLmdldE9mZnNldChzbmFwVG8sIHN0ZXApO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGUxMyA9IChkYXRlKSA9PiB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fZW5jb2RlKGRhdGUpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGUgLSBvZmZzZXQ0KSAvIHN0ZXApO1xuICAgIH07XG4gICAgY29uc3QgZGVjb2RlMTMgPSAoZW5jb2RlZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZShlbmNvZGVkICogc3RlcCArIG9mZnNldDQpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUaW1lSW50ZXJ2YWwoZW5jb2RlMTMsIGRlY29kZTEzLCByYW5nZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL21pbGxpc2Vjb25kLnRzXG5mdW5jdGlvbiBlbmNvZGUoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCk7XG59XG52YXIgbWlsbGlzZWNvbmQgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZSwgZGVjb2RlKTtcbnZhciBtaWxsaXNlY29uZF9kZWZhdWx0ID0gbWlsbGlzZWNvbmQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9kdXJhdGlvbi50c1xudmFyIGVwb2NoWWVhciA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCkpLmdldEZ1bGxZZWFyKCk7XG52YXIgZHVyYXRpb25TZWNvbmQgPSAxZTM7XG52YXIgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwO1xudmFyIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjA7XG52YXIgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNDtcbnZhciBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDc7XG52YXIgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzA7XG52YXIgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9zZWNvbmQudHNcbnZhciBvZmZzZXQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbmZ1bmN0aW9uIGVuY29kZTIoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBvZmZzZXQpIC8gZHVyYXRpb25TZWNvbmQpO1xufVxuZnVuY3Rpb24gZGVjb2RlMihlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShvZmZzZXQgKyBlbmNvZGVkICogZHVyYXRpb25TZWNvbmQpO1xufVxudmFyIHNlY29uZCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMiwgZGVjb2RlMik7XG52YXIgc2Vjb25kX2RlZmF1bHQgPSBzZWNvbmQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9taW51dGUudHNcbnZhciBvZmZzZXQyID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGUzKGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gb2Zmc2V0MikgLyBkdXJhdGlvbk1pbnV0ZSk7XG59XG5mdW5jdGlvbiBkZWNvZGUzKGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldDIgKyBlbmNvZGVkICogZHVyYXRpb25NaW51dGUpO1xufVxudmFyIG1pbnV0ZSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMywgZGVjb2RlMyk7XG52YXIgbWludXRlX2RlZmF1bHQgPSBtaW51dGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9ob3VyLnRzXG52YXIgb2Zmc2V0MyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuZnVuY3Rpb24gZW5jb2RlNChkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldDMpIC8gZHVyYXRpb25Ib3VyKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTQoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUob2Zmc2V0MyArIGVuY29kZWQgKiBkdXJhdGlvbkhvdXIpO1xufVxudmFyIGhvdXIgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTQsIGRlY29kZTQpO1xudmFyIGhvdXJfZGVmYXVsdCA9IGhvdXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9kYXkudHNcbmZ1bmN0aW9uIGVuY29kZTUoZGF0ZSkge1xuICBjb25zdCB0ek9mZnNldE1zID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIHR6T2Zmc2V0TXMpIC8gZHVyYXRpb25EYXkpO1xufVxuZnVuY3Rpb24gZGVjb2RlNShlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgxOTcwLCAwLCAxKTtcbiAgZC5zZXREYXRlKGQuZ2V0RGF0ZSgpICsgZW5jb2RlZCk7XG4gIHJldHVybiBkO1xufVxudmFyIGRheSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlNSwgZGVjb2RlNSk7XG52YXIgZGF5X2RlZmF1bHQgPSBkYXk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS93ZWVrLnRzXG5mdW5jdGlvbiB3ZWVrZGF5KHdlZWtTdGFydCkge1xuICBjb25zdCB0aHVyc2RheTIgPSA0O1xuICBjb25zdCBkYXlTaGlmdCA9ICg3ICsgd2Vla1N0YXJ0IC0gdGh1cnNkYXkyKSAlIDc7XG4gIGZ1bmN0aW9uIGVuY29kZTEzKGRhdGUpIHtcbiAgICBjb25zdCB0ek9mZnNldE1zID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gdHpPZmZzZXRNcykgLyBkdXJhdGlvbldlZWsgLSBkYXlTaGlmdCAvIDcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZTEzKGVuY29kZWQpIHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoMTk3MCwgMCwgMSk7XG4gICAgZC5zZXREYXRlKGQuZ2V0RGF0ZSgpICsgZW5jb2RlZCAqIDcgKyBkYXlTaGlmdCk7XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTMsIGRlY29kZTEzKTtcbn1cbnZhciBzdW5kYXkgPSB3ZWVrZGF5KDApO1xudmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG52YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG52YXIgd2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcbnZhciB0aHVyc2RheSA9IHdlZWtkYXkoNCk7XG52YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbnZhciBzYXR1cmRheSA9IHdlZWtkYXkoNik7XG52YXIgd2Vla19kZWZhdWx0ID0gc3VuZGF5O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvbW9udGgudHNcbmZ1bmN0aW9uIGVuY29kZTYoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpICogMTIgKyBkYXRlLmdldE1vbnRoKCk7XG59XG5mdW5jdGlvbiBkZWNvZGU2KGVuY29kZWQpIHtcbiAgY29uc3QgeWVhcjIgPSBNYXRoLmZsb29yKGVuY29kZWQgLyAxMik7XG4gIGNvbnN0IG1vbnRoMiA9IGVuY29kZWQgLSB5ZWFyMiAqIDEyO1xuICByZXR1cm4gbmV3IERhdGUoeWVhcjIsIG1vbnRoMiwgMSk7XG59XG52YXIgbW9udGggPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTYsIGRlY29kZTYpO1xudmFyIG1vbnRoX2RlZmF1bHQgPSBtb250aDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3llYXIudHNcbmZ1bmN0aW9uIGVuY29kZTcoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufVxuZnVuY3Rpb24gZGVjb2RlNyhlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgZC5zZXRGdWxsWWVhcihlbmNvZGVkKTtcbiAgZC5zZXRNb250aCgwLCAxKTtcbiAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgeWVhciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlNywgZGVjb2RlNyk7XG52YXIgeWVhcl9kZWZhdWx0ID0geWVhcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y01pbnV0ZS50c1xuZnVuY3Rpb24gZW5jb2RlOChkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gZHVyYXRpb25NaW51dGUpO1xufVxuZnVuY3Rpb24gZGVjb2RlOChlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShlbmNvZGVkICogZHVyYXRpb25NaW51dGUpO1xufVxudmFyIHV0Y01pbnV0ZSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlOCwgZGVjb2RlOCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNIb3VyLnRzXG5mdW5jdGlvbiBlbmNvZGU5KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBkdXJhdGlvbkhvdXIpO1xufVxuZnVuY3Rpb24gZGVjb2RlOShlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShlbmNvZGVkICogZHVyYXRpb25Ib3VyKTtcbn1cbnZhciB1dGNIb3VyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU5LCBkZWNvZGU5KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y0RheS50c1xuZnVuY3Rpb24gZW5jb2RlMTAoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIGR1cmF0aW9uRGF5KTtcbn1cbmZ1bmN0aW9uIGRlY29kZTEwKGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKTtcbiAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgZW5jb2RlZCk7XG4gIGQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkO1xufVxudmFyIHV0Y0RheSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTAsIGRlY29kZTEwKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y01vbnRoLnRzXG5mdW5jdGlvbiBlbmNvZGUxMShkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKiAxMiArIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTExKGVuY29kZWQpIHtcbiAgY29uc3QgeWVhcjIgPSBNYXRoLmZsb29yKGVuY29kZWQgLyAxMik7XG4gIGNvbnN0IG1vbnRoMiA9IGVuY29kZWQgLSB5ZWFyMiAqIDEyO1xuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhcjIsIG1vbnRoMiwgMSkpO1xufVxudmFyIHV0Y01vbnRoID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMSwgZGVjb2RlMTEpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjWWVhci50c1xuZnVuY3Rpb24gZW5jb2RlMTIoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xufVxuZnVuY3Rpb24gZGVjb2RlMTIoZW5jb2RlZCkge1xuICBjb25zdCBkID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGQuc2V0VVRDRnVsbFllYXIoZW5jb2RlZCk7XG4gIGQuc2V0VVRDTW9udGgoMCwgMSk7XG4gIGQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkO1xufVxudmFyIHV0Y1llYXIgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTEyLCBkZWNvZGUxMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9mcm9tVG9Nb3Rpb24udHNcbnZhciBmcm9tVG9Nb3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZnJvbVRvTW90aW9uX2V4cG9ydHMsIHtcbiAgTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORzogKCkgPT4gTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORyxcbiAgZnJvbVRvTW90aW9uOiAoKSA9PiBmcm9tVG9Nb3Rpb24sXG4gIHN0YXRpY0Zyb21Ub01vdGlvbjogKCkgPT4gc3RhdGljRnJvbVRvTW90aW9uXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9pZC50c1xudmFyIElEX01BUCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZXNldElkcygpIHtcbiAgSURfTUFQLmNsZWFyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJZChpbnN0YW5jZSkge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICBjb25zdCBjbGFzc05hbWUgPSBPYmplY3QuaGFzT3duKGNvbnN0cnVjdG9yLCBcImNsYXNzTmFtZVwiKSA/IGNvbnN0cnVjdG9yLmNsYXNzTmFtZSA6IGNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJHtjb25zdHJ1Y3Rvcn0gaXMgbWlzc2luZyB0aGUgJ2NsYXNzTmFtZScgcHJvcGVydHkuYCk7XG4gIH1cbiAgY29uc3QgbmV4dElkID0gKElEX01BUC5nZXQoY2xhc3NOYW1lKSA/PyAwKSArIDE7XG4gIElEX01BUC5zZXQoY2xhc3NOYW1lLCBuZXh0SWQpO1xuICByZXR1cm4gYCR7Y2xhc3NOYW1lfS0ke25leHRJZH1gO1xufVxuZnVuY3Rpb24gdXVpZCgpIHtcbiAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgcmV0dXJuIHVybC5zcGxpdChcIi9cIikuYXQoLTEpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2l0ZXJhdG9yLnRzXG5mdW5jdGlvbiB0b0l0ZXJhYmxlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkpIHtcbiAgICByZXR1cm4gYXJnc0l0ZXJhYmxlKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiogYXJyYXlzSXRlcmFibGUoLi4uYXJyYXlzKSB7XG4gIGZvciAoY29uc3QgYXJyYXkyIG9mIGFycmF5cykge1xuICAgIGZvciAoY29uc3QgZSBvZiBhcnJheTIpIHtcbiAgICAgIHlpZWxkIGU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiogYXJnc0l0ZXJhYmxlKC4uLmFyZ3MpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIHlpZWxkIGFyZztcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2ludGVycG9sYXRpbmcudHNcbnZhciBpbnRlcnBvbGF0ZSA9IFwiJGludGVycG9sYXRlXCI7XG52YXIgaXNJbnRlcnBvbGF0aW5nID0gKHgpID0+IHhbaW50ZXJwb2xhdGVdICE9IG51bGw7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbmVhcmVzdC50c1xuZnVuY3Rpb24gbmVhcmVzdFNxdWFyZWQoeCwgeSwgb2JqZWN0cywgbWF4RGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHkpIHtcbiAgY29uc3QgcmVzdWx0ID0geyBuZWFyZXN0OiB2b2lkIDAsIGRpc3RhbmNlU3F1YXJlZDogbWF4RGlzdGFuY2VTcXVhcmVkIH07XG4gIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMpIHtcbiAgICBjb25zdCB0aGlzRGlzdGFuY2UgPSBvYmouZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICAgIGlmICh0aGlzRGlzdGFuY2UgPT09IDApIHtcbiAgICAgIHJldHVybiB7IG5lYXJlc3Q6IG9iaiwgZGlzdGFuY2VTcXVhcmVkOiAwIH07XG4gICAgfSBlbHNlIGlmICh0aGlzRGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICByZXN1bHQubmVhcmVzdCA9IG9iajtcbiAgICAgIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQgPSB0aGlzRGlzdGFuY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyKHgsIHksIGNvbnRhaW5lciwgbWF4RGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHkpIHtcbiAgY29uc3QgeyB4OiB0eCwgeTogdHkgfSA9IGNvbnRhaW5lci50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgY29uc3QgcmVzdWx0ID0geyBuZWFyZXN0OiB2b2lkIDAsIGRpc3RhbmNlU3F1YXJlZDogbWF4RGlzdGFuY2VTcXVhcmVkIH07XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgY29udGFpbmVyLmNoaWxkcmVuKSB7XG4gICAgY29uc3QgeyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQ6IGRpc3RhbmNlU3F1YXJlZDMgfSA9IGNoaWxkLm5lYXJlc3RTcXVhcmVkKHR4LCB0eSwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCk7XG4gICAgaWYgKGRpc3RhbmNlU3F1YXJlZDMgPT09IDApIHtcbiAgICAgIHJldHVybiB7IG5lYXJlc3QsIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMyB9O1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VTcXVhcmVkMyA8IHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgIHJlc3VsdC5uZWFyZXN0ID0gbmVhcmVzdDtcbiAgICAgIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVNxdWFyZWQzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL251bWJlci50c1xuZnVuY3Rpb24gY2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNsYW1wQXJyYXkodmFsdWUsIGFycmF5Mikge1xuICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heChhcnJheTIpO1xuICByZXR1cm4gY2xhbXAobWluLCB2YWx1ZSwgbWF4KTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5NYXgoYXJyYXkyKSB7XG4gIGlmIChhcnJheTIubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcmVzdWx0ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICBmb3IgKGNvbnN0IHZhbCBvZiBhcnJheTIpIHtcbiAgICBpZiAodmFsIDwgcmVzdWx0WzBdKVxuICAgICAgcmVzdWx0WzBdID0gdmFsO1xuICAgIGlmICh2YWwgPiByZXN1bHRbMV0pXG4gICAgICByZXN1bHRbMV0gPSB2YWw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZUV4dGVudChhcnJheTIpIHtcbiAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgoYXJyYXkyKTtcbiAgcmV0dXJuIG1heCAtIG1pbjtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgZXBzaWxvbjIgPSAxZS0xMCkge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjI7XG59XG5mdW5jdGlvbiBpc05lZ2F0aXZlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnNpZ24odmFsdWUpID09PSAtMSB8fCBPYmplY3QuaXModmFsdWUsIC0wKTtcbn1cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscyA9IDIpIHtcbiAgY29uc3QgYmFzZSA9IDEwICoqIGRlY2ltYWxzO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGJhc2UpIC8gYmFzZTtcbn1cbmZ1bmN0aW9uIHRvRml4ZWQodmFsdWUsIGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0cyA9IDIpIHtcbiAgY29uc3QgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHZhbHVlKSkgLyBNYXRoLkxOMTApO1xuICBpZiAocG93ZXIgPj0gMCB8fCAhaXNGaW5pdGUocG93ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzKTtcbiAgfVxuICByZXR1cm4gdmFsdWUudG9GaXhlZChNYXRoLmFicyhwb3dlcikgLSAxICsgZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzKTtcbn1cbmZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKG4gJSBtICsgKG4gPCAwID8gbSA6IDApKTtcbn1cbmZ1bmN0aW9uIGNvdW50RnJhY3Rpb25EaWdpdHModmFsdWUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSlcbiAgICByZXR1cm4gMDtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIuXCIpWzFdPy5sZW5ndGggPz8gMDtcbn1cbmZ1bmN0aW9uIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlKHJhdGlvMiwgbG9jYWxlKSB7XG4gIGxvY2FsZSA9IGxvY2FsZSA/PyBuYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7IHN0eWxlOiBcInBlcmNlbnRcIiB9KS5mb3JtYXQocmF0aW8yKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBlcmNlbnRhZ2UocGVyY2VudCwgbG9jYWxlKSB7XG4gIHJldHVybiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZShwZXJjZW50IC8gMTAwLCBsb2NhbGUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9iYm94LnRzXG52YXIgX0JCb3ggPSBjbGFzcyBfQkJveCB7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIHN0YXRpYyBmcm9tRE9NUmVjdCh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSkge1xuICAgIHJldHVybiBuZXcgX0JCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgdG9ET01SZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnksXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICB0b3A6IHRoaXMueSxcbiAgICAgIGxlZnQ6IHRoaXMueCxcbiAgICAgIHJpZ2h0OiB0aGlzLnggKyB0aGlzLndpZHRoLFxuICAgICAgYm90dG9tOiB0aGlzLnkgKyB0aGlzLmhlaWdodCxcbiAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgX0JCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnkgJiYgdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodDtcbiAgfVxuICBjb250YWluc1BvaW50KHgsIHkpIHtcbiAgICByZXR1cm4geCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmNvbGxpZGVzQkJveChvdGhlcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3WDEgPSBjbGFtcChvdGhlci54LCB0aGlzLngsIG90aGVyLnggKyBvdGhlci53aWR0aCk7XG4gICAgY29uc3QgbmV3WTEgPSBjbGFtcChvdGhlci55LCB0aGlzLnksIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuICAgIGNvbnN0IG5ld1gyID0gY2xhbXAob3RoZXIueCwgdGhpcy54ICsgdGhpcy53aWR0aCwgb3RoZXIueCArIG90aGVyLndpZHRoKTtcbiAgICBjb25zdCBuZXdZMiA9IGNsYW1wKG90aGVyLnksIHRoaXMueSArIHRoaXMuaGVpZ2h0LCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0KTtcbiAgICByZXR1cm4gbmV3IF9CQm94KG5ld1gxLCBuZXdZMSwgbmV3WDIgLSBuZXdYMSwgbmV3WTIgLSBuZXdZMSk7XG4gIH1cbiAgY29sbGlkZXNCQm94KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiB0aGlzLnggKyB0aGlzLndpZHRoID4gb3RoZXIueCAmJiB0aGlzLnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0ICYmIHRoaXMueSArIHRoaXMuaGVpZ2h0ID4gb3RoZXIueTtcbiAgfVxuICBjb21wdXRlQ2VudGVyKCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgfVxuICBpc0Zpbml0ZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRoaXMueCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMueSkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMud2lkdGgpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmhlaWdodCk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICBpZiAodGhpcy5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZHggPSB4IC0gY2xhbXAodGhpcy54LCB4LCB0aGlzLnggKyB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBkeSA9IHkgLSBjbGFtcCh0aGlzLnksIHksIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gIH1cbiAgc3RhdGljIG5lYXJlc3RCb3goeCwgeSwgYm94ZXMpIHtcbiAgICByZXR1cm4gbmVhcmVzdFNxdWFyZWQoeCwgeSwgYm94ZXMpO1xuICB9XG4gIGNsaXAoY2xpcFJlY3QpIHtcbiAgICBpZiAoY2xpcFJlY3QgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgodGhpcy54LCBjbGlwUmVjdC54KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KHRoaXMueSwgY2xpcFJlY3QueSk7XG4gICAgY29uc3QgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCBjbGlwUmVjdC54ICsgY2xpcFJlY3Qud2lkdGgpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIGNsaXBSZWN0LnkgKyBjbGlwUmVjdC5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHgxO1xuICAgIHRoaXMueSA9IHkxO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCgwLCB4MiAtIHgxKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KDAsIHkyIC0geTEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNocmluayhhbW91bnQsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkyID0gKHBvcywgYW10KSA9PiB7XG4gICAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgdGhpcy55ICs9IGFtdDtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICB0aGlzLnggKz0gYW10O1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICB0aGlzLndpZHRoIC09IGFtdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgdGhpcy55ICs9IGFtdDtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBhbXQgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgIHRoaXMueCArPSBhbXQ7XG4gICAgICAgICAgdGhpcy53aWR0aCAtPSBhbXQgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgICB0aGlzLnggKz0gYW10O1xuICAgICAgICAgIHRoaXMud2lkdGggLT0gYW10ICogMjtcbiAgICAgICAgICB0aGlzLnkgKz0gYW10O1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdCAqIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYXBwbHkyKHBvc2l0aW9uLCBhbW91bnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYW1vdW50KS5mb3JFYWNoKChbcG9zLCBhbXRdKSA9PiBhcHBseTIocG9zLCBhbXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3JvdyhhbW91bnQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMuc2hyaW5rKC1hbW91bnQsIHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFkZGluZ0NvcHkgPSB7IC4uLmFtb3VudCB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFkZGluZ0NvcHkpIHtcbiAgICAgICAgcGFkZGluZ0NvcHlba2V5XSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hyaW5rKHBhZGRpbmdDb3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnggKz0geDtcbiAgICB0aGlzLnkgKz0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb21iaW5lKG90aGVyKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIHRoaXMueCA9IE1hdGgubWluKHgsIG90aGVyLngpO1xuICAgIHRoaXMueSA9IE1hdGgubWluKHksIG90aGVyLnkpO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCh4ICsgd2lkdGgsIG90aGVyLnggKyBvdGhlci53aWR0aCkgLSB0aGlzLng7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5ICsgaGVpZ2h0LCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0KSAtIHRoaXMueTtcbiAgfVxuICBzdGF0aWMgbWVyZ2UoYm94ZXMpIHtcbiAgICBsZXQgbGVmdCA9IEluZmluaXR5O1xuICAgIGxldCB0b3AgPSBJbmZpbml0eTtcbiAgICBsZXQgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgbGV0IGJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGJveCBvZiBib3hlcykge1xuICAgICAgaWYgKGJveC54IDwgbGVmdCkge1xuICAgICAgICBsZWZ0ID0gYm94Lng7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnkgPCB0b3ApIHtcbiAgICAgICAgdG9wID0gYm94Lnk7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnggKyBib3gud2lkdGggPiByaWdodCkge1xuICAgICAgICByaWdodCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGJveC55ICsgYm94LmhlaWdodCA+IGJvdHRvbSkge1xuICAgICAgICBib3R0b20gPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0JCb3gobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIH1cbiAgW2ludGVycG9sYXRlXShvdGhlciwgZCkge1xuICAgIHJldHVybiBuZXcgX0JCb3goXG4gICAgICB0aGlzLnggKiAoMSAtIGQpICsgb3RoZXIueCAqIGQsXG4gICAgICB0aGlzLnkgKiAoMSAtIGQpICsgb3RoZXIueSAqIGQsXG4gICAgICB0aGlzLndpZHRoICogKDEgLSBkKSArIG90aGVyLndpZHRoICogZCxcbiAgICAgIHRoaXMuaGVpZ2h0ICogKDEgLSBkKSArIG90aGVyLmhlaWdodCAqIGRcbiAgICApO1xuICB9XG59O1xuX0JCb3guemVybyA9IE9iamVjdC5mcmVlemUobmV3IF9CQm94KDAsIDAsIDAsIDApKTtcbl9CQm94Lk5hTiA9IE9iamVjdC5mcmVlemUobmV3IF9CQm94KE5hTiwgTmFOLCBOYU4sIE5hTikpO1xudmFyIEJCb3ggPSBfQkJveDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvY2hhbmdlRGV0ZWN0YWJsZS50c1xudmFyIFJlZHJhd1R5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWRyYXdUeXBlMikgPT4ge1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIlRSSVZJQUxcIl0gPSAxXSA9IFwiVFJJVklBTFwiO1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIk1JTk9SXCJdID0gMl0gPSBcIk1JTk9SXCI7XG4gIFJlZHJhd1R5cGUyW1JlZHJhd1R5cGUyW1wiTUFKT1JcIl0gPSAzXSA9IFwiTUFKT1JcIjtcbiAgcmV0dXJuIFJlZHJhd1R5cGUyO1xufSkoUmVkcmF3VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBTY2VuZUNoYW5nZURldGVjdGlvbihvcHRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBgX18ke2tleX1gO1xuICAgIGlmICh0YXJnZXRba2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmVwYXJlR2V0U2V0KHRhcmdldCwga2V5LCBwcml2YXRlS2V5LCBvcHRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVHZXRTZXQodGFyZ2V0LCBrZXksIHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLyxcbiAgICB0eXBlID0gXCJub3JtYWxcIixcbiAgICBjaGFuZ2VDYixcbiAgICBjb252ZXJ0b3IsXG4gICAgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCA9IGZhbHNlXG4gIH0gPSBvcHRzID8/IHt9O1xuICBjb25zdCByZXF1aXJlZE9wdHMgPSB7IHJlZHJhdywgdHlwZSwgY2hhbmdlQ2IsIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQsIGNvbnZlcnRvciB9O1xuICBsZXQgc2V0dGVyO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZE5vcm1hbFNldHRlcihwcml2YXRlS2V5LCByZXF1aXJlZE9wdHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyYW5zZm9ybVwiOlxuICAgICAgc2V0dGVyID0gYnVpbGRUcmFuc2Zvcm1TZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZFBhdGhTZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmb250XCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZEZvbnRTZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHNldHRlciA9IGJ1aWxkQ2hlY2tEaXJ0eUNoYWluKFxuICAgIGJ1aWxkQ2hhbmdlQ2FsbGJhY2tDaGFpbihidWlsZENvbnZlcnRvckNoYWluKHNldHRlciwgcmVxdWlyZWRPcHRzKSwgcmVxdWlyZWRPcHRzKSxcbiAgICByZXF1aXJlZE9wdHNcbiAgKTtcbiAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbcHJpdmF0ZUtleV07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgIHNldDogc2V0dGVyLFxuICAgIGdldDogZ2V0dGVyLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRDb252ZXJ0b3JDaGFpbihzZXR0ZXJGbiwgb3B0cykge1xuICBjb25zdCB7IGNvbnZlcnRvciB9ID0gb3B0cztcbiAgaWYgKGNvbnZlcnRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgc2V0dGVyRm4uY2FsbCh0aGlzLCBjb252ZXJ0b3IodmFsdWUpKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXR0ZXJGbjtcbn1cbnZhciBOT19DSEFOR0UgPSBTeW1ib2woXCJuby1jaGFuZ2VcIik7XG5mdW5jdGlvbiBidWlsZENoYW5nZUNhbGxiYWNrQ2hhaW4oc2V0dGVyRm4sIG9wdHMpIHtcbiAgY29uc3QgeyBjaGFuZ2VDYiB9ID0gb3B0cztcbiAgaWYgKGNoYW5nZUNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBzZXR0ZXJGbi5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmIChjaGFuZ2UgIT09IE5PX0NIQU5HRSkge1xuICAgICAgICBjaGFuZ2VDYi5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXR0ZXJGbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hlY2tEaXJ0eUNoYWluKHNldHRlckZuLCBvcHRzKSB7XG4gIGNvbnN0IHsgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCB9ID0gb3B0cztcbiAgaWYgKGNoZWNrRGlydHlPbkFzc2lnbm1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnN0IGNoYW5nZSA9IHNldHRlckZuLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKGNoYW5nZSAhPT0gTk9fQ0hBTkdFICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX2RpcnR5ID4gMCAvKiBOT05FICovKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KHZhbHVlLCB2YWx1ZS5fZGlydHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXR0ZXJGbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9ybWFsU2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8sIGNoYW5nZUNiIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgcmVkcmF3KTtcbiAgICAgIGNoYW5nZUNiPy4odGhpcyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybVNldHRlcihwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5tYXJrRGlydHlUcmFuc2Zvcm0ocmVkcmF3KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGF0aFNldHRlcihwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9kaXJ0eVBhdGgpIHtcbiAgICAgICAgdGhpcy5fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgcmVkcmF3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRm9udFNldHRlcihwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9kaXJ0eUZvbnQpIHtcbiAgICAgICAgdGhpcy5fZGlydHlGb250ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgcmVkcmF3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cbnZhciBDaGFuZ2VEZXRlY3RhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IDMgLyogTUFKT1IgKi87XG4gIH1cbiAgbWFya0RpcnR5KF9zb3VyY2UsIHR5cGUgPSAxIC8qIFRSSVZJQUwgKi8pIHtcbiAgICBpZiAodGhpcy5fZGlydHkgPCB0eXBlKSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IHR5cGU7XG4gICAgfVxuICB9XG4gIG1hcmtDbGVhbihfb3B0cykge1xuICAgIHRoaXMuX2RpcnR5ID0gMCAvKiBOT05FICovO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5ID4gMCAvKiBOT05FICovO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9tYXRyaXgudHNcbnZhciBfTWF0cml4ID0gY2xhc3MgX01hdHJpeCB7XG4gIGdldCBlKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5lbGVtZW50c107XG4gIH1cbiAgY29uc3RydWN0b3IoZWxlbWVudHMzID0gWzEsIDAsIDAsIDEsIDAsIDBdKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzMztcbiAgfVxuICBzZXRFbGVtZW50cyhlbGVtZW50czMpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gZWxlbWVudHMzWzBdO1xuICAgIGVbMV0gPSBlbGVtZW50czNbMV07XG4gICAgZVsyXSA9IGVsZW1lbnRzM1syXTtcbiAgICBlWzNdID0gZWxlbWVudHMzWzNdO1xuICAgIGVbNF0gPSBlbGVtZW50czNbNF07XG4gICAgZVs1XSA9IGVsZW1lbnRzM1s1XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIGVbMF0gPT09IDEgJiYgZVsxXSA9PT0gMCAmJiBlWzJdID09PSAwICYmIGVbM10gPT09IDEgJiYgZVs0XSA9PT0gMCAmJiBlWzVdID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyB0aGUgQXhCIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBhbmQgc2F2ZXMgdGhlIHJlc3VsdFxuICAgKiB0byBgQ2AsIGlmIGdpdmVuLCBvciB0byBgQWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgQXhCKEEsIEIsIEMpIHtcbiAgICBjb25zdCBhID0gQVswXSAqIEJbMF0gKyBBWzJdICogQlsxXSwgYiA9IEFbMV0gKiBCWzBdICsgQVszXSAqIEJbMV0sIGMgPSBBWzBdICogQlsyXSArIEFbMl0gKiBCWzNdLCBkID0gQVsxXSAqIEJbMl0gKyBBWzNdICogQlszXSwgZSA9IEFbMF0gKiBCWzRdICsgQVsyXSAqIEJbNV0gKyBBWzRdLCBmID0gQVsxXSAqIEJbNF0gKyBBWzNdICogQls1XSArIEFbNV07XG4gICAgQyA9IEMgPz8gQTtcbiAgICBDWzBdID0gYTtcbiAgICBDWzFdID0gYjtcbiAgICBDWzJdID0gYztcbiAgICBDWzNdID0gZDtcbiAgICBDWzRdID0gZTtcbiAgICBDWzVdID0gZjtcbiAgfVxuICAvKipcbiAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYXRyaXguXG4gICAqIEBwYXJhbSBvdGhlclxuICAgKi9cbiAgbXVsdGlwbHlTZWxmKG90aGVyKSB7XG4gICAgdGhpcy5BeEIodGhpcy5lbGVtZW50cywgb3RoZXIuZWxlbWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYG90aGVyYCBtYXRyaXggZ2V0cyBwb3N0LW11bHRpcGxpZWQgdG8gdGhlIGN1cnJlbnQgbWF0cml4LlxuICAgKiBSZXR1cm5zIGEgbmV3IG1hdHJpeC5cbiAgICogQHBhcmFtIG90aGVyXG4gICAqL1xuICBtdWx0aXBseShvdGhlcikge1xuICAgIGNvbnN0IGVsZW1lbnRzMyA9IG5ldyBBcnJheSg2KTtcbiAgICB0aGlzLkF4Qih0aGlzLmVsZW1lbnRzLCBvdGhlci5lbGVtZW50cywgZWxlbWVudHMzKTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoZWxlbWVudHMzKTtcbiAgfVxuICBwcmVNdWx0aXBseVNlbGYob3RoZXIpIHtcbiAgICB0aGlzLkF4QihvdGhlci5lbGVtZW50cywgdGhpcy5lbGVtZW50cywgdGhpcy5lbGVtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggYXMgYSBuZXcgbWF0cml4LlxuICAgKi9cbiAgaW52ZXJzZSgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAqL1xuICBpbnZlcnNlVG8ob3RoZXIpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICBvdGhlci5zZXRFbGVtZW50cyhbZCwgLWIsIC1jLCBhLCBjICogZiAtIGQgKiBlLCBiICogZSAtIGEgKiBmXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW52ZXJ0U2VsZigpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICBlbFswXSA9IGQ7XG4gICAgZWxbMV0gPSAtYjtcbiAgICBlbFsyXSA9IC1jO1xuICAgIGVsWzNdID0gYTtcbiAgICBlbFs0XSA9IGMgKiBmIC0gZCAqIGU7XG4gICAgZWxbNV0gPSBiICogZSAtIGEgKiBmO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRyYW5zZm9ybVBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAqIGVbMF0gKyB5ICogZVsyXSArIGVbNF0sXG4gICAgICB5OiB4ICogZVsxXSArIHkgKiBlWzNdICsgZVs1XVxuICAgIH07XG4gIH1cbiAgdHJhbnNmb3JtQkJveChiYm94LCB0YXJnZXQpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgeHggPSBlbFswXTtcbiAgICBjb25zdCB4eSA9IGVsWzFdO1xuICAgIGNvbnN0IHl4ID0gZWxbMl07XG4gICAgY29uc3QgeXkgPSBlbFszXTtcbiAgICBjb25zdCBoX3cgPSBiYm94LndpZHRoICogMC41O1xuICAgIGNvbnN0IGhfaCA9IGJib3guaGVpZ2h0ICogMC41O1xuICAgIGNvbnN0IGN4ID0gYmJveC54ICsgaF93O1xuICAgIGNvbnN0IGN5ID0gYmJveC55ICsgaF9oO1xuICAgIGNvbnN0IHcgPSBNYXRoLmFicyhoX3cgKiB4eCkgKyBNYXRoLmFicyhoX2ggKiB5eCk7XG4gICAgY29uc3QgaCA9IE1hdGguYWJzKGhfdyAqIHh5KSArIE1hdGguYWJzKGhfaCAqIHl5KTtcbiAgICB0YXJnZXQgPz8gKHRhcmdldCA9IG5ldyBCQm94KDAsIDAsIDAsIDApKTtcbiAgICB0YXJnZXQueCA9IGN4ICogeHggKyBjeSAqIHl4ICsgZWxbNF0gLSB3O1xuICAgIHRhcmdldC55ID0gY3ggKiB4eSArIGN5ICogeXkgKyBlbFs1XSAtIGg7XG4gICAgdGFyZ2V0LndpZHRoID0gdyArIHc7XG4gICAgdGFyZ2V0LmhlaWdodCA9IGggKyBoO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgdG9Db250ZXh0KGN0eCkge1xuICAgIGlmICh0aGlzLmlkZW50aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGN0eC50cmFuc2Zvcm0oZVswXSwgZVsxXSwgZVsyXSwgZVszXSwgZVs0XSwgZVs1XSk7XG4gIH1cbiAgc3RhdGljIGZseXdlaWdodChzb3VyY2VNYXRyaXgpIHtcbiAgICByZXR1cm4gX01hdHJpeC5pbnN0YW5jZS5zZXRFbGVtZW50cyhzb3VyY2VNYXRyaXguZWxlbWVudHMpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBzY2FsaW5nWCwgc2NhbGluZ1ksIHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwgb3B0cykge1xuICAgIGNvbnN0IHN4ID0gc2NhbGluZ1g7XG4gICAgY29uc3Qgc3kgPSBzY2FsaW5nWTtcbiAgICBsZXQgc2N4O1xuICAgIGxldCBzY3k7XG4gICAgaWYgKHN4ID09PSAxICYmIHN5ID09PSAxKSB7XG4gICAgICBzY3ggPSAwO1xuICAgICAgc2N5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2N4ID0gb3B0cz8uc2NhbGluZ0NlbnRlclggPz8gMDtcbiAgICAgIHNjeSA9IG9wdHM/LnNjYWxpbmdDZW50ZXJZID8/IDA7XG4gICAgfVxuICAgIGNvbnN0IHIgPSByb3RhdGlvbjtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyKTtcbiAgICBsZXQgcmN4O1xuICAgIGxldCByY3k7XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIHJjeCA9IDA7XG4gICAgICByY3kgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByY3ggPSBvcHRzPy5yb3RhdGlvbkNlbnRlclggPz8gMDtcbiAgICAgIHJjeSA9IG9wdHM/LnJvdGF0aW9uQ2VudGVyWSA/PyAwO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHRyYW5zbGF0aW9uWDtcbiAgICBjb25zdCB0eSA9IHRyYW5zbGF0aW9uWTtcbiAgICBjb25zdCB0eDQgPSBzY3ggKiAoMSAtIHN4KSAtIHJjeDtcbiAgICBjb25zdCB0eTQgPSBzY3kgKiAoMSAtIHN5KSAtIHJjeTtcbiAgICBtYXRyaXguc2V0RWxlbWVudHMoW1xuICAgICAgY29zICogc3gsXG4gICAgICBzaW4gKiBzeCxcbiAgICAgIC1zaW4gKiBzeSxcbiAgICAgIGNvcyAqIHN5LFxuICAgICAgY29zICogdHg0IC0gc2luICogdHk0ICsgcmN4ICsgdHgsXG4gICAgICBzaW4gKiB0eDQgKyBjb3MgKiB0eTQgKyByY3kgKyB0eVxuICAgIF0pO1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbiAgc3RhdGljIGZyb21Db250ZXh0KGN0eCkge1xuICAgIGNvbnN0IGRvbU1hdHJpeCA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoW2RvbU1hdHJpeC5hLCBkb21NYXRyaXguYiwgZG9tTWF0cml4LmMsIGRvbU1hdHJpeC5kLCBkb21NYXRyaXguZSwgZG9tTWF0cml4LmZdKTtcbiAgfVxufTtcbl9NYXRyaXguaW5zdGFuY2UgPSBuZXcgX01hdHJpeCgpO1xudmFyIE1hdHJpeCA9IF9NYXRyaXg7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL25vZGUudHNcbnZhciBQb2ludGVyRXZlbnRzID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlckV2ZW50czIpID0+IHtcbiAgUG9pbnRlckV2ZW50czJbUG9pbnRlckV2ZW50czJbXCJBbGxcIl0gPSAwXSA9IFwiQWxsXCI7XG4gIFBvaW50ZXJFdmVudHMyW1BvaW50ZXJFdmVudHMyW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIHJldHVybiBQb2ludGVyRXZlbnRzMjtcbn0pKFBvaW50ZXJFdmVudHMgfHwge30pO1xudmFyIF9Ob2RlID0gY2xhc3MgX05vZGUgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlIHtcbiAgY29uc3RydWN0b3IoeyBpc1ZpcnR1YWwsIHRhZywgekluZGV4LCBuYW1lIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIFVuaXF1ZSBudW1iZXIgdG8gYWxsb3cgY3JlYXRpb24gb3JkZXIgdG8gYmUgZWFzaWx5IGRldGVybWluZWQuICovXG4gICAgdGhpcy5zZXJpYWxOdW1iZXIgPSBfTm9kZS5fbmV4dFNlcmlhbE51bWJlcisrO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBub2RlIElEIGluIHRoZSBmb3JtIGBDbGFzc05hbWUtTmF0dXJhbE51bWJlcmAuXG4gICAgICovXG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIFRvIHNpbXBsaWZ5IHRoZSB0eXBlIHN5c3RlbSAoZXNwZWNpYWxseSBpbiBTZWxlY3Rpb25zKSB3ZSBkb24ndCBoYXZlIHRoZSBgUGFyZW50YCBub2RlXG4gICAgICogKG9uZSB0aGF0IGhhcyBjaGlsZHJlbikuIEluc3RlYWQsIHdlIG1pbWljIEhUTUwgRE9NLCB3aGVyZSBhbnkgbm9kZSBjYW4gaGF2ZSBjaGlsZHJlbi5cbiAgICAgKiBCdXQgd2Ugc3RpbGwgbmVlZCB0byBkaXN0aW5ndWlzaCByZWd1bGFyIGxlYWYgbm9kZXMgZnJvbSBjb250YWluZXIgbGVhZnMgc29tZWhvdy5cbiAgICAgKi9cbiAgICB0aGlzLmlzQ29udGFpbmVyTm9kZSA9IGZhbHNlO1xuICAgIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgLy8gVXNlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlIG5vZGVzLlxuICAgIHRoaXMuY2hpbGRTZXQgPSB7fTtcbiAgICAvLyBUaGVzZSBtYXRyaWNlcyBtYXkgbmVlZCB0byBoYXZlIHBhY2thZ2UgbGV2ZWwgdmlzaWJpbGl0eVxuICAgIC8vIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gcHVycG9zZXMuXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5kaXJ0eVRyYW5zZm9ybSA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGluZ1ggPSAxO1xuICAgIHRoaXMuc2NhbGluZ1kgPSAxO1xuICAgIHRoaXMuc2NhbGluZ0NlbnRlclggPSBudWxsO1xuICAgIHRoaXMuc2NhbGluZ0NlbnRlclkgPSBudWxsO1xuICAgIHRoaXMucm90YXRpb25DZW50ZXJYID0gbnVsbDtcbiAgICB0aGlzLnJvdGF0aW9uQ2VudGVyWSA9IG51bGw7XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLl9jaGlsZE5vZGVDb3VudHMgPSB7XG4gICAgICBncm91cHM6IDAsXG4gICAgICBub25Hcm91cHM6IDBcbiAgICB9O1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5kaXJ0eVpJbmRleCA9IGZhbHNlO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAvKiogRGlzY3JpbWluYXRvcnMgZm9yIHJlbmRlciBvcmRlciB3aXRoaW4gYSB6SW5kZXguICovXG4gICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnBvaW50ZXJFdmVudHMgPSAwIC8qIEFsbCAqLztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaXNWaXJ0dWFsID0gaXNWaXJ0dWFsID8/IGZhbHNlO1xuICAgIHRoaXMudGFnID0gdGFnID8/IE5hTjtcbiAgICB0aGlzLnpJbmRleCA9IHpJbmRleCA/PyAwO1xuICB9XG4gIC8qKlxuICAgKiBTb21lIGFyYml0cmFyeSBkYXRhIGJvdW5kIHRvIHRoZSBub2RlLlxuICAgKi9cbiAgZ2V0IGRhdHVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXR1bSA/PyB0aGlzLl9wYXJlbnQ/LmRhdHVtO1xuICB9XG4gIGdldCBwcmV2aW91c0RhdHVtKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RhdHVtO1xuICB9XG4gIHNldCBkYXR1bShkYXR1bSkge1xuICAgIGlmICh0aGlzLl9kYXR1bSAhPT0gZGF0dW0pIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzRGF0dW0gPSB0aGlzLl9kYXR1bTtcbiAgICB9XG4gICAgdGhpcy5fZGF0dW0gPSBkYXR1bTtcbiAgfVxuICBfc2V0TGF5ZXJNYW5hZ2VyKHZhbHVlKSB7XG4gICAgdGhpcy5fbGF5ZXJNYW5hZ2VyID0gdmFsdWU7XG4gICAgdGhpcy5fZGVidWcgPSB2YWx1ZT8uZGVidWc7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl9jaGlsZHJlbikge1xuICAgICAgY2hpbGQuX3NldExheWVyTWFuYWdlcih2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fdmlydHVhbENoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxheWVyTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJNYW5hZ2VyO1xuICB9XG4gICphbmNlc3RvcnMoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlIChub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG4gICp0cmF2ZXJzZVVwKCkge1xuICAgIHlpZWxkIHRoaXM7XG4gICAgeWllbGQqIHRoaXMuYW5jZXN0b3JzKCk7XG4gIH1cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9XG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlydHVhbENoaWxkcmVuLmxlbmd0aCA/IHRoaXMuX2NoaWxkcmVuLmNvbmNhdCh0aGlzLl92aXJ0dWFsQ2hpbGRyZW4uZmxhdE1hcCgobmV4dCkgPT4gbmV4dC5jaGlsZHJlbikpIDogdGhpcy5fY2hpbGRyZW47XG4gIH1cbiAgZ2V0IHZpcnR1YWxDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlydHVhbENoaWxkcmVuO1xuICB9XG4gIGhhc1ZpcnR1YWxDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlydHVhbENoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIH1cbiAgLy8gbmV3IFNldDxOb2RlPigpXG4gIHNldFByb3BlcnRpZXMoc3R5bGVzLCBwaWNrS2V5cykge1xuICAgIGlmIChwaWNrS2V5cykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGlja0tleXMpIHtcbiAgICAgICAgdGhpc1trZXldID0gc3R5bGVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3R5bGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgb25lIG9yIG1vcmUgbmV3IG5vZGUgaW5zdGFuY2VzIHRvIHRoaXMgcGFyZW50LlxuICAgKiBJZiBvbmUgbmVlZHMgdG86XG4gICAqIC0gbW92ZSBhIGNoaWxkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICogLSBtb3ZlIGEgY2hpbGQgZnJvbSBvbmUgcGFyZW50IHRvIGFub3RoZXIgKGluY2x1ZGluZyBwYXJlbnRzIGluIG90aGVyIHNjZW5lcylcbiAgICogb25lIHNob3VsZCB1c2UgdGhlIHtAbGluayBpbnNlcnRCZWZvcmV9IG1ldGhvZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0gbm9kZXMgQSBub2RlIG9yIG5vZGVzIHRvIGFwcGVuZC5cbiAgICovXG4gIGFwcGVuZChub2Rlcykge1xuICAgIG5vZGVzID0gdG9JdGVyYWJsZShub2Rlcyk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25vZGV9IGFscmVhZHkgYmVsb25ncyB0byBhbm90aGVyIHBhcmVudDogJHtub2RlLnBhcmVudH0uYCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5sYXllck1hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25vZGV9IGFscmVhZHkgYmVsb25ncyB0byBhIHNjZW5lOiAke25vZGUubGF5ZXJNYW5hZ2VyfS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoaWxkU2V0W25vZGUuaWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBub2RlOiAke25vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pc1ZpcnR1YWwpIHtcbiAgICAgICAgdGhpcy5fdmlydHVhbENoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZFNldFtub2RlLmlkXSA9IHRydWU7XG4gICAgICBub2RlLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgbm9kZS5fc2V0TGF5ZXJNYW5hZ2VyKHRoaXMubGF5ZXJNYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy5kaXJ0eVpJbmRleCA9IHRydWU7XG4gICAgdGhpcy5tYXJrRGlydHkodGhpcywgMyAvKiBNQUpPUiAqLyk7XG4gIH1cbiAgYXBwZW5kQ2hpbGQobm9kZSkge1xuICAgIHRoaXMuYXBwZW5kKG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJlbW92ZUNoaWxkKG5vZGUpIHtcbiAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUuYCk7XG4gICAgfTtcbiAgICBpZiAobm9kZS5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgIGVycm9yKCk7XG4gICAgfVxuICAgIGlmIChub2RlLmlzVmlydHVhbCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgaWYgKGkgPCAwKVxuICAgICAgICBlcnJvcigpO1xuICAgICAgdGhpcy5fdmlydHVhbENoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaSA8IDApXG4gICAgICAgIGVycm9yKCk7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmNoaWxkU2V0W25vZGUuaWRdO1xuICAgIG5vZGUuX3BhcmVudCA9IHZvaWQgMDtcbiAgICBub2RlLl9zZXRMYXllck1hbmFnZXIoKTtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eShub2RlLCAzIC8qIE1BSk9SICovKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGFycmF5c0l0ZXJhYmxlKHRoaXMuX3ZpcnR1YWxDaGlsZHJlbiwgdGhpcy5fY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZC5fcGFyZW50ID0gdm9pZCAwO1xuICAgICAgY2hpbGQuX3NldExheWVyTWFuYWdlcigpO1xuICAgIH1cbiAgICB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2hpbGRTZXQgPSB7fTtcbiAgfVxuICBjYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCkge1xuICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgIGNvbnN0IG1hdHJpeCA9IE1hdHJpeC5mbHl3ZWlnaHQodGhpcy5tYXRyaXgpO1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHRoaXMuYW5jZXN0b3JzKCkpIHtcbiAgICAgIHBhcmVudC5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBtYXRyaXgucHJlTXVsdGlwbHlTZWxmKHBhcmVudC5tYXRyaXgpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIHRyYW5zZm9ybVBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKTtcbiAgICByZXR1cm4gbWF0cml4LmludmVydFNlbGYoKS50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgfVxuICBpbnZlcnNlVHJhbnNmb3JtUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlQ3VtdWxhdGl2ZU1hdHJpeCgpO1xuICAgIHJldHVybiBtYXRyaXgudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gIH1cbiAgdHJhbnNmb3JtQkJveChiYm94KSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCk7XG4gICAgcmV0dXJuIG1hdHJpeC5pbnZlcnRTZWxmKCkudHJhbnNmb3JtQkJveChiYm94KTtcbiAgfVxuICBpbnZlcnNlVHJhbnNmb3JtQkJveChiYm94KSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCk7XG4gICAgcmV0dXJuIG1hdHJpeC50cmFuc2Zvcm1CQm94KGJib3gpO1xuICB9XG4gIG1hcmtEaXJ0eVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLmRpcnR5VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCAzIC8qIE1BSk9SICovKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50Py5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuICBjb250YWluc1BvaW50KF94LCBfeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSGl0IHRlc3RpbmcgbWV0aG9kLlxuICAgKiBSZWN1cnNpdmVseSBjaGVja3MgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGlzIG5vZGUgb3IgYW55IG9mIGl0cyBjaGlsZHJlbi5cbiAgICogUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSBvciBgdW5kZWZpbmVkYC5cbiAgICogTm9kZXMgdGhhdCByZW5kZXIgbGF0ZXIgKHNob3cgb24gdG9wKSBhcmUgaGl0IHRlc3RlZCBmaXJzdC5cbiAgICovXG4gIHBpY2tOb2RlKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLnBvaW50ZXJFdmVudHMgPT09IDEgLyogTm9uZSAqLyB8fCAhdGhpcy5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXM7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDFlMykge1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zUG9pbnQgPSBjaGlsZC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk/LmNvbnRhaW5zUG9pbnQoeCwgeSk7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNvbnRhaW5zUG9pbnQgPyBjaGlsZC5waWNrTm9kZSh4LCB5KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgIHJldHVybiBoaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNoaWxkcmVuW2ldLnBpY2tOb2RlKHgsIHkpO1xuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNDb250YWluZXJOb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbiAgZ2V0QkJveChmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmNhY2hlZEJCb3ggPT0gbnVsbCB8fCBmb3JjZVJlY2FsY3VsYXRpb24pIHtcbiAgICAgIHRoaXMuY2FjaGVkQkJveCA9IE9iamVjdC5mcmVlemUodGhpcy5jb21wdXRlQkJveCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkQkJveDtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk/LmNsb25lKCk7XG4gICAgaWYgKCFiYm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgIGNvbnN0IG1hdHJpeCA9IE1hdHJpeC5mbHl3ZWlnaHQodGhpcy5tYXRyaXgpO1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHRoaXMuYW5jZXN0b3JzKCkpIHtcbiAgICAgIHBhcmVudC5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBtYXRyaXgucHJlTXVsdGlwbHlTZWxmKHBhcmVudC5tYXRyaXgpO1xuICAgIH1cbiAgICBtYXRyaXgudHJhbnNmb3JtQkJveChiYm94LCBiYm94KTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICBjb21wdXRlVHJhbnNmb3JtTWF0cml4KCkge1xuICAgIGlmICghdGhpcy5kaXJ0eVRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXRyaXgsXG4gICAgICBzY2FsaW5nWCxcbiAgICAgIHNjYWxpbmdZLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0cmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblksXG4gICAgICBzY2FsaW5nQ2VudGVyWCxcbiAgICAgIHNjYWxpbmdDZW50ZXJZLFxuICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZXG4gICAgfSA9IHRoaXM7XG4gICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIHNjYWxpbmdYLCBzY2FsaW5nWSwgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZLCB7XG4gICAgICBzY2FsaW5nQ2VudGVyWCxcbiAgICAgIHNjYWxpbmdDZW50ZXJZLFxuICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZXG4gICAgfSk7XG4gICAgdGhpcy5kaXJ0eVRyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG4gIHRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4LCBsYXllckN0eCkge1xuICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgIHRoaXMubWF0cml4LnRvQ29udGV4dChsYXllckN0eCA/PyByZW5kZXJDdHguY3R4KTtcbiAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gIH1cbiAgLyoqIFBlcmZvcm0gYW55IHByZS1yZW5kZXJpbmcgaW5pdGlhbGl6YXRpb24uICovXG4gIHByZVJlbmRlcigpIHtcbiAgICB0aGlzLl9jaGlsZE5vZGVDb3VudHMuZ3JvdXBzID0gMDtcbiAgICB0aGlzLl9jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzID0gMTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkQ291bnRzID0gY2hpbGQucHJlUmVuZGVyKCk7XG4gICAgICB0aGlzLl9jaGlsZE5vZGVDb3VudHMuZ3JvdXBzICs9IGNoaWxkQ291bnRzLmdyb3VwcztcbiAgICAgIHRoaXMuX2NoaWxkTm9kZUNvdW50cy5ub25Hcm91cHMgKz0gY2hpbGRDb3VudHMubm9uR3JvdXBzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hpbGROb2RlQ291bnRzO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gICAgdGhpcy5jYWNoZWRCQm94ID0gdGhpcy5jb21wdXRlQkJveCgpO1xuICAgIGlmIChzdGF0cykge1xuICAgICAgc3RhdHMubm9kZXNSZW5kZXJlZCsrO1xuICAgIH1cbiAgfVxuICBtYXJrRGlydHkoX3NvdXJjZSwgdHlwZSA9IDEgLyogVFJJVklBTCAqLywgcGFyZW50VHlwZSA9IHR5cGUpIHtcbiAgICB0aGlzLmNhY2hlZEJCb3ggPSB2b2lkIDA7XG4gICAgaWYgKHRoaXMuX2RpcnR5ID4gdHlwZSB8fCB0aGlzLl9kaXJ0eSA9PT0gdHlwZSAmJiB0eXBlID09PSBwYXJlbnRUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RpcnR5ID0gdHlwZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50Lm1hcmtEaXJ0eSh0aGlzLCBwYXJlbnRUeXBlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlci5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcbiAgfVxuICBtYXJrQ2xlYW4ob3B0cykge1xuICAgIGNvbnN0IHsgZm9yY2UgPSBmYWxzZSwgcmVjdXJzaXZlID0gdHJ1ZSB9ID0gb3B0cyA/PyB7fTtcbiAgICBpZiAodGhpcy5fZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gICAgaWYgKHJlY3Vyc2l2ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fdmlydHVhbENoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkLm1hcmtDbGVhbih7IGZvcmNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkLm1hcmtDbGVhbih7IGZvcmNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvblZpc2libGVDaGFuZ2UoKSB7XG4gIH1cbiAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICBsZXQgY291bnQgPSAxO1xuICAgIGxldCBkaXJ0eUNvdW50ID0gdGhpcy5fZGlydHkgPj0gMCAvKiBOT05FICovIHx8IHRoaXMuZGlydHlUcmFuc2Zvcm0gPyAxIDogMDtcbiAgICBsZXQgdmlzaWJsZUNvdW50ID0gdGhpcy52aXNpYmxlID8gMSA6IDA7XG4gICAgY29uc3QgY291bnRDaGlsZCA9IChjaGlsZCkgPT4ge1xuICAgICAgY29uc3QgeyBjb3VudDogY2hpbGRDb3VudCwgdmlzaWJsZUNvdW50OiBjaGlsZFZpc2libGVDb3VudCwgZGlydHlDb3VudDogY2hpbGREaXJ0eUNvdW50IH0gPSBjaGlsZC5ub2RlQ291bnQ7XG4gICAgICBjb3VudCArPSBjaGlsZENvdW50O1xuICAgICAgdmlzaWJsZUNvdW50ICs9IGNoaWxkVmlzaWJsZUNvdW50O1xuICAgICAgZGlydHlDb3VudCArPSBjaGlsZERpcnR5Q291bnQ7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICBjb3VudENoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgIGNvdW50Q2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4geyBjb3VudCwgdmlzaWJsZUNvdW50LCBkaXJ0eUNvdW50IH07XG4gIH1cbiAgb25aSW5kZXhDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5kaXJ0eVpJbmRleCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuX05vZGUuX25leHRTZXJpYWxOdW1iZXIgPSAwO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwic2NhbGluZ1hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJzY2FsaW5nWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInNjYWxpbmdDZW50ZXJYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwic2NhbGluZ0NlbnRlcllcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJyb3RhdGlvbkNlbnRlclhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJyb3RhdGlvbkNlbnRlcllcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInRyYW5zbGF0aW9uWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInRyYW5zbGF0aW9uWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDMgLyogTUFKT1IgKi8sXG4gICAgY2hhbmdlQ2I6ICh0YXJnZXQpID0+IHRhcmdldC5vblZpc2libGVDaGFuZ2UoKVxuICB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAxIC8qIFRSSVZJQUwgKi8sXG4gICAgY2hhbmdlQ2I6ICh0YXJnZXQpID0+IHRhcmdldC5vblpJbmRleENoYW5nZSgpXG4gIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwiekluZGV4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMSAvKiBUUklWSUFMICovLFxuICAgIGNoYW5nZUNiOiAodGFyZ2V0KSA9PiB0YXJnZXQub25aSW5kZXhDaGFuZ2UoKVxuICB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInpJbmRleFN1Yk9yZGVyXCIsIDIpO1xudmFyIE5vZGUgPSBfTm9kZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jb2xvci50c1xudmFyIGxlcnAgPSAoeCwgeSwgdCkgPT4geCAqICgxIC0gdCkgKyB5ICogdDtcbnZhciBzcmdiVG9MaW5lYXIgPSAodmFsdWUpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/IC0xIDogMTtcbiAgY29uc3QgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuICBpZiAoYWJzIDw9IDAuMDQwNDUpXG4gICAgcmV0dXJuIHZhbHVlIC8gMTIuOTI7XG4gIHJldHVybiBzaWduICogKChhYnMgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xufTtcbnZhciBzcmdiRnJvbUxpbmVhciA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxO1xuICBjb25zdCBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIGlmIChhYnMgPiAzMTMwOGUtNykge1xuICAgIHJldHVybiBzaWduICogKDEuMDU1ICogYWJzICoqICgxIC8gMi40KSAtIDAuMDU1KTtcbiAgfVxuICByZXR1cm4gMTIuOTIgKiB2YWx1ZTtcbn07XG52YXIgX0NvbG9yID0gY2xhc3MgX0NvbG9yIHtcbiAgLyoqXG4gICAqIEV2ZXJ5IGNvbG9yIGNvbXBvbmVudCBzaG91bGQgYmUgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAgICogU29tZSBlYXNpbmcgZnVuY3Rpb25zIChzdWNoIGFzIGVsYXN0aWMgZWFzaW5nKSBjYW4gb3ZlcnNob290IHRoZSB0YXJnZXQgdmFsdWUgYnkgc29tZSBhbW91bnQuXG4gICAqIFNvLCB3aGVuIGFuaW1hdGluZyBjb2xvcnMsIGlmIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IGNvbG9yIGNvbXBvbmVudHMgYXJlIGFscmVhZHkgbmVhclxuICAgKiBvciBhdCB0aGUgZWRnZSBvZiB0aGUgYWxsb3dlZCBbMCwgMV0gcmFuZ2UsIGl0IGlzIHBvc3NpYmxlIGZvciB0aGUgaW50ZXJtZWRpYXRlIGNvbG9yXG4gICAqIGNvbXBvbmVudCB2YWx1ZSB0byBlbmQgdXAgb3V0c2lkZSBvZiB0aGF0IHJhbmdlIG1pZC1hbmltYXRpb24uIEZvciB0aGlzIHJlYXNvbiB0aGUgY29uc3RydWN0b3JcbiAgICogcGVyZm9ybXMgcmFuZ2UgY2hlY2tpbmcvY29uc3RyYWluaW5nLlxuICAgKiBAcGFyYW0gciBSZWQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBiIEJsdWUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gYSBBbHBoYSAob3BhY2l0eSkgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEpIHtcbiAgICB0aGlzLnIgPSBjbGFtcCgwLCByIHx8IDAsIDEpO1xuICAgIHRoaXMuZyA9IGNsYW1wKDAsIGcgfHwgMCwgMSk7XG4gICAgdGhpcy5iID0gY2xhbXAoMCwgYiB8fCAwLCAxKTtcbiAgICB0aGlzLmEgPSBjbGFtcCgwLCBhIHx8IDAsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDpcbiAgICogLSAjcmdiXG4gICAqIC0gI3JyZ2diYlxuICAgKiAtIHJnYihyLCBnLCBiKVxuICAgKiAtIHJnYmEociwgZywgYiwgYSlcbiAgICogLSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Yy5cbiAgICovXG4gIHN0YXRpYyB2YWxpZENvbG9yU3RyaW5nKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihcIiNcIikgPj0gMCkge1xuICAgICAgcmV0dXJuICEhX0NvbG9yLnBhcnNlSGV4KHN0cik7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZihcInJnYlwiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gISFfQ29sb3Iuc3RyaW5nVG9SZ2JhKHN0cik7XG4gICAgfVxuICAgIHJldHVybiAhIV9Db2xvci5uYW1lVG9IZXhbc3RyLnRvTG93ZXJDYXNlKCldO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZ2l2ZW4gc3RyaW5nIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICAgKiAtICNyZ2JcbiAgICogLSAjcnJnZ2JiXG4gICAqIC0gcmdiKHIsIGcsIGIpXG4gICAqIC0gcmdiYShyLCBnLCBiLCBhKVxuICAgKiAtIENTUyBjb2xvciBuYW1lIHN1Y2ggYXMgJ3doaXRlJywgJ29yYW5nZScsICdjeWFuJywgZXRjLlxuICAgKiBAcGFyYW0gc3RyXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoXCIjXCIpID49IDApIHtcbiAgICAgIHJldHVybiBfQ29sb3IuZnJvbUhleFN0cmluZyhzdHIpO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBfQ29sb3IubmFtZVRvSGV4W3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoaGV4KSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21IZXhTdHJpbmcoaGV4KTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKFwicmdiXCIpID49IDApIHtcbiAgICAgIHJldHVybiBfQ29sb3IuZnJvbVJnYmFTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci8jaGV4LW5vdGF0aW9uXG4gIHN0YXRpYyBwYXJzZUhleChpbnB1dCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvIC9nLCBcIlwiKS5zbGljZSgxKTtcbiAgICBsZXQgcGFydHM7XG4gICAgc3dpdGNoIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHBhcnRzLnB1c2gocGFyc2VJbnQoYCR7aW5wdXRbaV19JHtpbnB1dFtpICsgMV19YCwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcGFydHMgPSBpbnB1dC5zcGxpdChcIlwiKS5tYXAoKHApID0+IHBhcnNlSW50KHAsIDE2KSkubWFwKChwKSA9PiBwICsgcCAqIDE2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwYXJ0cz8ubGVuZ3RoID49IDMgJiYgcGFydHMuZXZlcnkoKHApID0+IHAgPj0gMCkpIHtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcGFydHMucHVzaCgyNTUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbUhleFN0cmluZyhzdHIpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBfQ29sb3IucGFyc2VIZXgoc3RyKTtcbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICBjb25zdCBbciwgZywgYiwgYV0gPSB2YWx1ZXM7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhIC8gMjU1KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nOiAnJHtzdHJ9J2ApO1xuICB9XG4gIHN0YXRpYyBzdHJpbmdUb1JnYmEoc3RyKSB7XG4gICAgbGV0IHBvID0gLTE7XG4gICAgbGV0IHBjID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBzdHJbaV07XG4gICAgICBpZiAocG8gPT09IC0xICYmIGMgPT09IFwiKFwiKSB7XG4gICAgICAgIHBvID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgcGMgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvID09PSAtMSB8fCBwYyA9PT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29udGVudHMgPSBzdHIuc3Vic3RyaW5nKHBvICsgMSwgcGMpO1xuICAgIGNvbnN0IHBhcnRzID0gY29udGVudHMuc3BsaXQoXCIsXCIpO1xuICAgIGNvbnN0IHJnYmEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHBhcnQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LmluZGV4T2YoXCIlXCIpID49IDApIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMTAwKTtcbiAgICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMjU1KTtcbiAgICAgICAgdmFsdWUgLz0gMjU1O1xuICAgICAgfVxuICAgICAgcmdiYS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYmE7XG4gIH1cbiAgc3RhdGljIGZyb21SZ2JhU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IHJnYmEgPSBfQ29sb3Iuc3RyaW5nVG9SZ2JhKHN0cik7XG4gICAgaWYgKHJnYmEpIHtcbiAgICAgIGlmIChyZ2JhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAocmdiYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIHJnYi9yZ2JhIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICBzdGF0aWMgZnJvbUFycmF5KGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihhcnJbMF0sIGFyclsxXSwgYXJyWzJdLCBhcnJbM10pO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBnaXZlbiBhcnJheSBzaG91bGQgY29udGFpbiAzIG9yIDQgY29sb3IgY29tcG9uZW50cyAobnVtYmVycykuXCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFNCKGgsIHMsIGIsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5IU0J0b1JHQihoLCBzLCBiKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIGZyb21IU0woaCwgcywgbCwgYWxwaGEgPSAxKSB7XG4gICAgY29uc3QgcmdiID0gX0NvbG9yLkhTTHRvUkdCKGgsIHMsIGwpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgZnJvbU9LTENIKGwsIGMsIGgsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5PS0xDSHRvUkdCKGwsIGMsIGgpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgcGFkSGV4KHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAxID8gXCIwXCIgKyBzdHIgOiBzdHI7XG4gIH1cbiAgdG9IZXhTdHJpbmcoKSB7XG4gICAgbGV0IGhleCA9IFwiI1wiICsgX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkudG9TdHJpbmcoMTYpKSArIF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpLnRvU3RyaW5nKDE2KSkgKyBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5iICogMjU1KS50b1N0cmluZygxNikpO1xuICAgIGlmICh0aGlzLmEgPCAxKSB7XG4gICAgICBoZXggKz0gX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuYSAqIDI1NSkudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICB0b1JnYmFTdHJpbmcoZnJhY3Rpb25EaWdpdHMgPSAzKSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSksIE1hdGgucm91bmQodGhpcy5nICogMjU1KSwgTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpXTtcbiAgICBjb25zdCBrID0gTWF0aC5wb3coMTAsIGZyYWN0aW9uRGlnaXRzKTtcbiAgICBpZiAodGhpcy5hICE9PSAxKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goTWF0aC5yb3VuZCh0aGlzLmEgKiBrKSAvIGspO1xuICAgICAgcmV0dXJuIGByZ2JhKCR7Y29tcG9uZW50cy5qb2luKFwiLCBcIil9KWA7XG4gICAgfVxuICAgIHJldHVybiBgcmdiKCR7Y29tcG9uZW50cy5qb2luKFwiLCBcIil9KWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuYSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9SZ2JhU3RyaW5nKCk7XG4gIH1cbiAgdG9IU0IoKSB7XG4gICAgcmV0dXJuIF9Db2xvci5SR0J0b0hTQih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgfVxuICBzdGF0aWMgUkdCdG9PS0xDSChyLCBnLCBiKSB7XG4gICAgY29uc3QgTFNSR0IwID0gc3JnYlRvTGluZWFyKHIpO1xuICAgIGNvbnN0IExTUkdCMSA9IHNyZ2JUb0xpbmVhcihnKTtcbiAgICBjb25zdCBMU1JHQjIgPSBzcmdiVG9MaW5lYXIoYik7XG4gICAgY29uc3QgTE1TMCA9IE1hdGguY2JydCgwLjQxMjIyMTQ3MDggKiBMU1JHQjAgKyAwLjUzNjMzMjUzNjMgKiBMU1JHQjEgKyAwLjA1MTQ0NTk5MjkgKiBMU1JHQjIpO1xuICAgIGNvbnN0IExNUzEgPSBNYXRoLmNicnQoMC4yMTE5MDM0OTgyICogTFNSR0IwICsgMC42ODA2OTk1NDUxICogTFNSR0IxICsgMC4xMDczOTY5NTY2ICogTFNSR0IyKTtcbiAgICBjb25zdCBMTVMyID0gTWF0aC5jYnJ0KDAuMDg4MzAyNDYxOSAqIExTUkdCMCArIDAuMjgxNzE4ODM3NiAqIExTUkdCMSArIDAuNjI5OTc4NzAwNSAqIExTUkdCMik7XG4gICAgY29uc3QgT0tMQUIwID0gMC4yMTA0NTQyNTUzICogTE1TMCArIDAuNzkzNjE3Nzg1ICogTE1TMSAtIDAuMDA0MDcyMDQ2OCAqIExNUzI7XG4gICAgY29uc3QgT0tMQUIxID0gMS45Nzc5OTg0OTUxICogTE1TMCAtIDIuNDI4NTkyMjA1ICogTE1TMSArIDAuNDUwNTkzNzA5OSAqIExNUzI7XG4gICAgY29uc3QgT0tMQUIyID0gMC4wMjU5MDQwMzcxICogTE1TMCArIDAuNzgyNzcxNzY2MiAqIExNUzEgLSAwLjgwODY3NTc2NiAqIExNUzI7XG4gICAgY29uc3QgaHVlID0gTWF0aC5hdGFuMihPS0xBQjIsIE9LTEFCMSkgKiAxODAgLyBNYXRoLlBJO1xuICAgIGNvbnN0IE9LTENIMCA9IE9LTEFCMDtcbiAgICBjb25zdCBPS0xDSDEgPSBNYXRoLmh5cG90KE9LTEFCMSwgT0tMQUIyKTtcbiAgICBjb25zdCBPS0xDSDIgPSBodWUgPj0gMCA/IGh1ZSA6IGh1ZSArIDM2MDtcbiAgICByZXR1cm4gW09LTENIMCwgT0tMQ0gxLCBPS0xDSDJdO1xuICB9XG4gIHN0YXRpYyBPS0xDSHRvUkdCKGwsIGMsIGgpIHtcbiAgICBjb25zdCBPS0xBQjAgPSBsO1xuICAgIGNvbnN0IE9LTEFCMSA9IGMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29uc3QgT0tMQUIyID0gYyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICBjb25zdCBMTVMwID0gKE9LTEFCMCArIDAuMzk2MzM3Nzc3NCAqIE9LTEFCMSArIDAuMjE1ODAzNzU3MyAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMTVMxID0gKE9LTEFCMCAtIDAuMTA1NTYxMzQ1OCAqIE9LTEFCMSAtIDAuMDYzODU0MTcyOCAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMTVMyID0gKE9LTEFCMCAtIDAuMDg5NDg0MTc3NSAqIE9LTEFCMSAtIDEuMjkxNDg1NTQ4ICogT0tMQUIyKSAqKiAzO1xuICAgIGNvbnN0IExTUkdCMCA9IDQuMDc2NzQxNjYyMSAqIExNUzAgLSAzLjMwNzcxMTU5MTMgKiBMTVMxICsgMC4yMzA5Njk5MjkyICogTE1TMjtcbiAgICBjb25zdCBMU1JHQjEgPSAtMS4yNjg0MzgwMDQ2ICogTE1TMCArIDIuNjA5NzU3NDAxMSAqIExNUzEgLSAwLjM0MTMxOTM5NjUgKiBMTVMyO1xuICAgIGNvbnN0IExTUkdCMiA9IC0wLjAwNDE5NjA4NjMgKiBMTVMwIC0gMC43MDM0MTg2MTQ3ICogTE1TMSArIDEuNzA3NjE0NzAxICogTE1TMjtcbiAgICBjb25zdCBTUkdCMCA9IHNyZ2JGcm9tTGluZWFyKExTUkdCMCk7XG4gICAgY29uc3QgU1JHQjEgPSBzcmdiRnJvbUxpbmVhcihMU1JHQjEpO1xuICAgIGNvbnN0IFNSR0IyID0gc3JnYkZyb21MaW5lYXIoTFNSR0IyKTtcbiAgICByZXR1cm4gW1NSR0IwLCBTUkdCMSwgU1JHQjJdO1xuICB9XG4gIHN0YXRpYyBSR0J0b0hTTChyLCBnLCBiKSB7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBsZXQgaDtcbiAgICBsZXQgcztcbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSAwO1xuICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlbHRhMyA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZGVsdGEzIC8gKDIgLSBtYXggLSBtaW4pIDogZGVsdGEzIC8gKG1heCArIG1pbik7XG4gICAgICBpZiAobWF4ID09PSByKSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGEzICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgICAgaCA9IChiIC0gcikgLyBkZWx0YTMgKyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IChyIC0gZykgLyBkZWx0YTMgKyA0O1xuICAgICAgfVxuICAgICAgaCAqPSAzNjAgLyA2O1xuICAgIH1cbiAgICByZXR1cm4gW2gsIHMsIGxdO1xuICB9XG4gIHN0YXRpYyBIU0x0b1JHQihoLCBzLCBsKSB7XG4gICAgaCA9IChoICUgMzYwICsgMzYwKSAlIDM2MDtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtsLCBsLCBsXTtcbiAgICB9XG4gICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgICBmdW5jdGlvbiBodWVUb1JnYih0KSB7XG4gICAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSlcbiAgICAgICAgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNilcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBjb25zdCByID0gaHVlVG9SZ2IoaCAvIDM2MCArIDEgLyAzKTtcbiAgICBjb25zdCBnID0gaHVlVG9SZ2IoaCAvIDM2MCk7XG4gICAgY29uc3QgYiA9IGh1ZVRvUmdiKGggLyAzNjAgLSAxIC8gMyk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIFJHQiB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgSFNCIChIU1YpIGNvbXBvbmVudHMuXG4gICAqL1xuICBzdGF0aWMgUkdCdG9IU0IociwgZywgYikge1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IFMgPSBtYXggPT09IDAgPyAwIDogKG1heCAtIG1pbikgLyBtYXg7XG4gICAgbGV0IEggPSAwO1xuICAgIGlmIChtaW4gIT09IG1heCkge1xuICAgICAgY29uc3QgZGVsdGEzID0gbWF4IC0gbWluO1xuICAgICAgY29uc3QgcmMgPSAobWF4IC0gcikgLyBkZWx0YTM7XG4gICAgICBjb25zdCBnYyA9IChtYXggLSBnKSAvIGRlbHRhMztcbiAgICAgIGNvbnN0IGJjID0gKG1heCAtIGIpIC8gZGVsdGEzO1xuICAgICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBIID0gYmMgLSBnYztcbiAgICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICAgIEggPSAyICsgcmMgLSBiYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEggPSA0ICsgZ2MgLSByYztcbiAgICAgIH1cbiAgICAgIEggLz0gNjtcbiAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICBIID0gSCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbSCAqIDM2MCwgUywgbWF4XTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIEhTQiAoSFNWKSB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgUkdCIGNvbXBvbmVudHMuXG4gICAqL1xuICBzdGF0aWMgSFNCdG9SR0IoSCwgUywgQikge1xuICAgIEggPSAoSCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG4gICAgaWYgKFMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSAoSCAtIE1hdGguZmxvb3IoSCkpICogNjtcbiAgICAgIGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcbiAgICAgIGNvbnN0IHAgPSBCICogKDEgLSBTKTtcbiAgICAgIGNvbnN0IHEgPSBCICogKDEgLSBTICogZik7XG4gICAgICBjb25zdCB0ID0gQiAqICgxIC0gUyAqICgxIC0gZikpO1xuICAgICAgc3dpdGNoIChoID4+IDApIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSBCO1xuICAgICAgICAgIGcgPSB0O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IHE7XG4gICAgICAgICAgZyA9IEI7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gQjtcbiAgICAgICAgICBiID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSBxO1xuICAgICAgICAgIGIgPSBCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByID0gQjtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICBzdGF0aWMgbWl4KGMwLCBjMSwgdCkge1xuICAgIHJldHVybiBuZXcgX0NvbG9yKGxlcnAoYzAuciwgYzEuciwgdCksIGxlcnAoYzAuZywgYzEuZywgdCksIGxlcnAoYzAuYiwgYzEuYiwgdCksIGxlcnAoYzAuYSwgYzEuYSwgdCkpO1xuICB9XG59O1xuLyoqXG4gKiBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQ6XG4gKiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLyNuYW1lZC1jb2xvcnNcbiAqL1xuX0NvbG9yLm5hbWVUb0hleCA9IHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBfX3Byb3RvX186IG51bGwsXG4gIGFsaWNlYmx1ZTogXCIjRjBGOEZGXCIsXG4gIGFudGlxdWV3aGl0ZTogXCIjRkFFQkQ3XCIsXG4gIGFxdWE6IFwiIzAwRkZGRlwiLFxuICBhcXVhbWFyaW5lOiBcIiM3RkZGRDRcIixcbiAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICBiZWlnZTogXCIjRjVGNURDXCIsXG4gIGJpc3F1ZTogXCIjRkZFNEM0XCIsXG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgYmxhbmNoZWRhbG1vbmQ6IFwiI0ZGRUJDRFwiLFxuICBibHVlOiBcIiMwMDAwRkZcIixcbiAgYmx1ZXZpb2xldDogXCIjOEEyQkUyXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgYnVybHl3b29kOiBcIiNERUI4ODdcIixcbiAgY2FkZXRibHVlOiBcIiM1RjlFQTBcIixcbiAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIGNvcmFsOiBcIiNGRjdGNTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGNyaW1zb246IFwiI0RDMTQzQ1wiLFxuICBjeWFuOiBcIiMwMEZGRkZcIixcbiAgZGFya2JsdWU6IFwiIzAwMDA4QlwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRhcmtnb2xkZW5yb2Q6IFwiI0I4ODYwQlwiLFxuICBkYXJrZ3JheTogXCIjQTlBOUE5XCIsXG4gIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsXG4gIGRhcmtncmV5OiBcIiNBOUE5QTlcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgZGFya21hZ2VudGE6IFwiIzhCMDA4QlwiLFxuICBkYXJrb2xpdmVncmVlbjogXCIjNTU2QjJGXCIsXG4gIGRhcmtvcmFuZ2U6IFwiI0ZGOEMwMFwiLFxuICBkYXJrb3JjaGlkOiBcIiM5OTMyQ0NcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgZGFya3NsYXRlZ3JheTogXCIjMkY0RjRGXCIsXG4gIGRhcmtzbGF0ZWdyZXk6IFwiIzJGNEY0RlwiLFxuICBkYXJrdHVycXVvaXNlOiBcIiMwMENFRDFcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIGRlZXBwaW5rOiBcIiNGRjE0OTNcIixcbiAgZGVlcHNreWJsdWU6IFwiIzAwQkZGRlwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgZGltZ3JleTogXCIjNjk2OTY5XCIsXG4gIGRvZGdlcmJsdWU6IFwiIzFFOTBGRlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBmbG9yYWx3aGl0ZTogXCIjRkZGQUYwXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgZnVjaHNpYTogXCIjRkYwMEZGXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBnb2xkOiBcIiNGRkQ3MDBcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIGdyZWVuOiBcIiMwMDgwMDBcIixcbiAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICBncmV5OiBcIiM4MDgwODBcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiLFxuICBraGFraTogXCIjRjBFNjhDXCIsXG4gIGxhdmVuZGVyOiBcIiNFNkU2RkFcIixcbiAgbGF2ZW5kZXJibHVzaDogXCIjRkZGMEY1XCIsXG4gIGxhd25ncmVlbjogXCIjN0NGQzAwXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGxpZ2h0Ymx1ZTogXCIjQUREOEU2XCIsXG4gIGxpZ2h0Y29yYWw6IFwiI0YwODA4MFwiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjRkFGQUQyXCIsXG4gIGxpZ2h0Z3JheTogXCIjRDNEM0QzXCIsXG4gIGxpZ2h0Z3JlZW46IFwiIzkwRUU5MFwiLFxuICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBsaWdodHNhbG1vbjogXCIjRkZBMDdBXCIsXG4gIGxpZ2h0c2VhZ3JlZW46IFwiIzIwQjJBQVwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBsaWdodHNsYXRlZ3JheTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c2xhdGVncmV5OiBcIiM3Nzg4OTlcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiI0IwQzRERVwiLFxuICBsaWdodHllbGxvdzogXCIjRkZGRkUwXCIsXG4gIGxpbWU6IFwiIzAwRkYwMFwiLFxuICBsaW1lZ3JlZW46IFwiIzMyQ0QzMlwiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIG1hZ2VudGE6IFwiI0ZGMDBGRlwiLFxuICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIiM2NkNEQUFcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gIG1lZGl1bXB1cnBsZTogXCIjOTM3MERCXCIsXG4gIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIiM3QjY4RUVcIixcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiIzAwRkE5QVwiLFxuICBtZWRpdW10dXJxdW9pc2U6IFwiIzQ4RDFDQ1wiLFxuICBtZWRpdW12aW9sZXRyZWQ6IFwiI0M3MTU4NVwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBtaW50Y3JlYW06IFwiI0Y1RkZGQVwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBtb2NjYXNpbjogXCIjRkZFNEI1XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIG9sZGxhY2U6IFwiI0ZERjVFNlwiLFxuICBvbGl2ZTogXCIjODA4MDAwXCIsXG4gIG9saXZlZHJhYjogXCIjNkI4RTIzXCIsXG4gIG9yYW5nZTogXCIjRkZBNTAwXCIsXG4gIG9yYW5nZXJlZDogXCIjRkY0NTAwXCIsXG4gIG9yY2hpZDogXCIjREE3MEQ2XCIsXG4gIHBhbGVnb2xkZW5yb2Q6IFwiI0VFRThBQVwiLFxuICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICBwYWxldHVycXVvaXNlOiBcIiNBRkVFRUVcIixcbiAgcGFsZXZpb2xldHJlZDogXCIjREI3MDkzXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBwZWFjaHB1ZmY6IFwiI0ZGREFCOVwiLFxuICBwZXJ1OiBcIiNDRDg1M0ZcIixcbiAgcGluazogXCIjRkZDMENCXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgcmViZWNjYXB1cnBsZTogXCIjNjYzMzk5XCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIHJvc3licm93bjogXCIjQkM4RjhGXCIsXG4gIHJveWFsYmx1ZTogXCIjNDE2OUUxXCIsXG4gIHNhZGRsZWJyb3duOiBcIiM4QjQ1MTNcIixcbiAgc2FsbW9uOiBcIiNGQTgwNzJcIixcbiAgc2FuZHlicm93bjogXCIjRjRBNDYwXCIsXG4gIHNlYWdyZWVuOiBcIiMyRThCNTdcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICBzaWx2ZXI6IFwiI0MwQzBDMFwiLFxuICBza3libHVlOiBcIiM4N0NFRUJcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgc2xhdGVncmV5OiBcIiM3MDgwOTBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgdGFuOiBcIiNEMkI0OENcIixcbiAgdGVhbDogXCIjMDA4MDgwXCIsXG4gIHRoaXN0bGU6IFwiI0Q4QkZEOFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICB0cmFuc3BhcmVudDogXCIjMDAwMDAwMDBcIixcbiAgdHVycXVvaXNlOiBcIiM0MEUwRDBcIixcbiAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgd2hlYXQ6IFwiI0Y1REVCM1wiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCIsXG4gIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLFxuICB5ZWxsb3c6IFwiI0ZGRkYwMFwiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCJcbn07XG52YXIgQ29sb3IgPSBfQ29sb3I7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIChkKSA9PiBOdW1iZXIoYSkgKiAoMSAtIGQpICsgTnVtYmVyKGIpICogZDtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgYSA9IENvbG9yLmZyb21TdHJpbmcoYSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYSA9IENvbG9yLmZyb21BcnJheShbMCwgMCwgMF0pO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgYiA9IENvbG9yLmZyb21TdHJpbmcoYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYiA9IENvbG9yLmZyb21BcnJheShbMCwgMCwgMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGQpID0+IENvbG9yLm1peChhLCBiLCBkKS50b1JnYmFTdHJpbmcoKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWNvcmF0b3IudHNcbnZhciBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4gPSBTeW1ib2woXCJCUkVBS1wiKTtcbnZhciBDT05GSUdfS0VZID0gXCJfX2RlY29yYXRvcl9jb25maWdcIjtcbmZ1bmN0aW9uIGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSB7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgQ09ORklHX0tFWSkgPT0gbnVsbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIENPTkZJR19LRVksIHsgdmFsdWU6IHt9IH0pO1xuICB9XG4gIGNvbnN0IGNvbmZpZyA9IHRhcmdldFtDT05GSUdfS0VZXTtcbiAgY29uc3QgcHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleU9yU3ltYm9sLnRvU3RyaW5nKCk7XG4gIGlmICh0eXBlb2YgY29uZmlnW3Byb3BlcnR5S2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBjb25maWdbcHJvcGVydHlLZXldO1xuICB9XG4gIGNvbnN0IHZhbHVlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25maWdbcHJvcGVydHlLZXldID0geyBzZXR0ZXJzOiBbXSwgZ2V0dGVyczogW10sIG9ic2VydmVyczogW10sIHZhbHVlc01hcCB9O1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpO1xuICBjb25zdCBwcmV2U2V0ID0gZGVzY3JpcHRvcj8uc2V0O1xuICBjb25zdCBwcmV2R2V0ID0gZGVzY3JpcHRvcj8uZ2V0O1xuICBjb25zdCBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgdmFsdWUgPSBwcmV2R2V0ID8gcHJldkdldC5jYWxsKHRoaXMpIDogdmFsdWVzTWFwLmdldCh0aGlzKTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybUZuIG9mIGNvbmZpZ1twcm9wZXJ0eUtleV0uZ2V0dGVycykge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1Gbih0aGlzLCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IEJSRUFLX1RSQU5TRk9STV9DSEFJTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgY29uc3Qgc2V0dGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCB7IHNldHRlcnMsIG9ic2VydmVycyB9ID0gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgICBsZXQgb2xkVmFsdWU7XG4gICAgaWYgKHNldHRlcnMuc29tZSgoZikgPT4gZi5sZW5ndGggPiAyKSkge1xuICAgICAgb2xkVmFsdWUgPSBwcmV2R2V0ID8gcHJldkdldC5jYWxsKHRoaXMpIDogdmFsdWVzTWFwLmdldCh0aGlzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiBzZXR0ZXJzKSB7XG4gICAgICB2YWx1ZSA9IHRyYW5zZm9ybUZuKHRoaXMsIHByb3BlcnR5S2V5T3JTeW1ib2wsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IEJSRUFLX1RSQU5TRk9STV9DSEFJTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2U2V0KSB7XG4gICAgICBwcmV2U2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNNYXAuc2V0KHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvYnNlcnZlckZuIG9mIG9ic2VydmVycykge1xuICAgICAgb2JzZXJ2ZXJGbih0aGlzLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCwge1xuICAgIHNldDogc2V0dGVyLFxuICAgIGdldDogZ2V0dGVyLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XG59XG5mdW5jdGlvbiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoc2V0VHJhbnNmb3JtLCBnZXRUcmFuc2Zvcm0sIGNvbmZpZ01ldGFkYXRhKSB7XG4gIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gaW5pdGlhbGlzZUNvbmZpZyh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpO1xuICAgIGNvbmZpZy5zZXR0ZXJzLnB1c2goc2V0VHJhbnNmb3JtKTtcbiAgICBpZiAoZ2V0VHJhbnNmb3JtKSB7XG4gICAgICBjb25maWcuZ2V0dGVycy51bnNoaWZ0KGdldFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmIChjb25maWdNZXRhZGF0YSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGNvbmZpZ01ldGFkYXRhKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhZGRPYnNlcnZlclRvSW5zdGFuY2VQcm9wZXJ0eShzZXRPYnNlcnZlcikge1xuICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkgPT4ge1xuICAgIGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKS5vYnNlcnZlcnMucHVzaChzZXRPYnNlcnZlcik7XG4gIH07XG59XG5mdW5jdGlvbiBpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgQ09ORklHX0tFWSBpbiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpIHtcbiAgY29uc3QgdGFyZ2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHdoaWxlIChpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0cy5hZGQodGFyZ2V0Py5bQ09ORklHX0tFWV0pO1xuICAgIHRhcmdldCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHRhcmdldHMpLmZsYXRNYXAoKGNvbmZpZ01hcCkgPT4gT2JqZWN0LmtleXMoY29uZmlnTWFwKSk7XG59XG5mdW5jdGlvbiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpIHtcbiAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRhcmdldCkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgIHJlc3VsdFtrZXldID0gdGFyZ2V0W2tleV0gPz8gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydHlNZXRhZGF0YSh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpIHtcbiAgY29uc3QgcHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleU9yU3ltYm9sLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGFyZ2V0W0NPTkZJR19LRVldO1xuICAgIGlmIChPYmplY3QuaGFzT3duKGNvbmZpZywgcHJvcGVydHlLZXkpKSB7XG4gICAgICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90eXBlLWd1YXJkcy50c1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufVxuZnVuY3Rpb24gaXNWYWxpZERhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzRGF0ZSh2YWx1ZSkgJiYgIWlzTmFOKE51bWJlcih2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmICFpc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0VudW1LZXkoZW51bU9iamVjdCwgZW51bUtleSkge1xuICByZXR1cm4gaXNTdHJpbmcoZW51bUtleSkgJiYgT2JqZWN0LmtleXMoZW51bU9iamVjdCkuaW5jbHVkZXMoZW51bUtleSk7XG59XG5mdW5jdGlvbiBpc0VudW1WYWx1ZShlbnVtT2JqZWN0LCBlbnVtVmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZW51bU9iamVjdCkuaW5jbHVkZXMoZW51bVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvb2JqZWN0LnRzXG5mdW5jdGlvbiBkZWVwTWVyZ2UoLi4uc291cmNlcykge1xuICByZXR1cm4gbWVyZ2VEZWZhdWx0cyguLi5zb3VyY2VzLnJldmVyc2UoKSk7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKC4uLnNvdXJjZXMpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gaXNEZWNvcmF0ZWRPYmplY3Qoc291cmNlKSA/IGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHNvdXJjZSkgOiBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlRGVmYXVsdHModGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID8/ICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlQXJyYXlEZWZhdWx0cyhkYXRhQXJyYXksIC4uLml0ZW1EZWZhdWx0cykge1xuICBpZiAoaXRlbURlZmF1bHRzICYmIGlzQXJyYXkoZGF0YUFycmF5KSkge1xuICAgIHJldHVybiBkYXRhQXJyYXkubWFwKChpdGVtKSA9PiBtZXJnZURlZmF1bHRzKGl0ZW0sIC4uLml0ZW1EZWZhdWx0cykpO1xuICB9XG4gIHJldHVybiBkYXRhQXJyYXk7XG59XG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0MiwgbWFwcGVyKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmplY3QyKS5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IG1hcHBlcih2YWx1ZSwga2V5LCBvYmplY3QyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuZnVuY3Rpb24gd2l0aG91dChvYmplY3QyLCBrZXlzKSB7XG4gIGNvbnN0IGNsb25lID0geyAuLi5vYmplY3QyIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgY2xvbmVba2V5XTtcbiAgfVxuICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiBnZXRQYXRoKG9iamVjdDIsIHBhdGgpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIHBhdGhBcnJheS5yZWR1Y2UoKHZhbHVlLCBwYXRoS2V5KSA9PiB2YWx1ZVtwYXRoS2V5XSwgb2JqZWN0Mik7XG59XG52YXIgU0tJUF9KU19CVUlMVElOUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIl9fcHJvdG9fX1wiLCBcImNvbnN0cnVjdG9yXCIsIFwicHJvdG90eXBlXCJdKTtcbmZ1bmN0aW9uIHNldFBhdGgob2JqZWN0MiwgcGF0aCwgbmV3VmFsdWUpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwYXRoKSA/IHBhdGguc2xpY2UoKSA6IHBhdGguc3BsaXQoXCIuXCIpO1xuICBjb25zdCBsYXN0S2V5ID0gcGF0aEFycmF5LnBvcCgpO1xuICBpZiAocGF0aEFycmF5LnNvbWUoKHApID0+IFNLSVBfSlNfQlVJTFRJTlMuaGFzKHApKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGxhc3RPYmplY3QgPSBwYXRoQXJyYXkucmVkdWNlKCh2YWx1ZSwgcGF0aEtleSkgPT4gdmFsdWVbcGF0aEtleV0sIG9iamVjdDIpO1xuICBsYXN0T2JqZWN0W2xhc3RLZXldID0gbmV3VmFsdWU7XG4gIHJldHVybiBsYXN0T2JqZWN0W2xhc3RLZXldO1xufVxuZnVuY3Rpb24gcGFydGlhbEFzc2lnbihrZXlzVG9Db3B5LCB0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb0NvcHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Byb3BlcnRpZXMudHNcbnZhciBCYXNlUHJvcGVydGllcyA9IGNsYXNzIHtcbiAgc2V0KHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0ICR7Y2xhc3NOYW1lfSAtIGV4cGVjdGluZyBhIHByb3BlcnRpZXMgb2JqZWN0YCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocHJvcGVydGllcykpO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlLZXkgb2YgbGlzdERlY29yYXRlZFByb3BlcnRpZXModGhpcykpIHtcbiAgICAgIGlmIChrZXlzLmhhcyhwcm9wZXJ0eUtleSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChpc1Byb3BlcnRpZXMoc2VsZltwcm9wZXJ0eUtleV0pKSB7XG4gICAgICAgICAgc2VsZltwcm9wZXJ0eUtleV0gPSBzZWxmW3Byb3BlcnR5S2V5XSBpbnN0YW5jZW9mIFByb3BlcnRpZXNBcnJheSA/IHNlbGZbcHJvcGVydHlLZXldLnJlc2V0KHZhbHVlKSA6IHNlbGZbcHJvcGVydHlLZXldLnNldCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZltwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmRlbGV0ZShwcm9wZXJ0eUtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdW5rbm93bktleSBvZiBrZXlzKSB7XG4gICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCBbJHt1bmtub3duS2V5fV0gaW4gJHtjbGFzc05hbWV9IC0gcHJvcGVydHkgaXMgdW5rbm93bmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc1ZhbGlkKHdhcm5pbmdQcmVmaXgpIHtcbiAgICByZXR1cm4gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGhpcykuZXZlcnkoKHByb3BlcnR5S2V5KSA9PiB7XG4gICAgICBjb25zdCB7IG9wdGlvbmFsIH0gPSBleHRyYWN0RGVjb3JhdGVkUHJvcGVydHlNZXRhZGF0YSh0aGlzLCBwcm9wZXJ0eUtleSk7XG4gICAgICBjb25zdCB2YWxpZCA9IG9wdGlvbmFsID09PSB0cnVlIHx8IHR5cGVvZiB0aGlzW3Byb3BlcnR5S2V5XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGAke3dhcm5pbmdQcmVmaXggPz8gXCJcIn1bJHtwcm9wZXJ0eUtleX1dIGlzIHJlcXVpcmVkLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0pO1xuICB9XG4gIHRvSnNvbigpIHtcbiAgICByZXR1cm4gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGhpcykucmVkdWNlKChvYmplY3QyLCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHRoaXNbcHJvcGVydHlLZXldO1xuICAgICAgb2JqZWN0Mltwcm9wZXJ0eUtleV0gPSBpc1Byb3BlcnRpZXMocHJvcGVydHlWYWx1ZSkgPyBwcm9wZXJ0eVZhbHVlLnRvSnNvbigpIDogcHJvcGVydHlWYWx1ZTtcbiAgICAgIHJldHVybiBvYmplY3QyO1xuICAgIH0sIHt9KTtcbiAgfVxufTtcbnZhciBQcm9wZXJ0aWVzQXJyYXkgPSBjbGFzcyBfUHJvcGVydGllc0FycmF5IGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihpdGVtRmFjdG9yeSwgLi4ucHJvcGVydGllcykge1xuICAgIHN1cGVyKHByb3BlcnRpZXMubGVuZ3RoKTtcbiAgICBjb25zdCBpc0NvbnN0cnVjdG9yID0gKHZhbHVlMikgPT4gQm9vbGVhbih2YWx1ZTI/LnByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUpO1xuICAgIGNvbnN0IHZhbHVlID0gaXNDb25zdHJ1Y3RvcihpdGVtRmFjdG9yeSkgPyAocGFyYW1zKSA9PiBuZXcgaXRlbUZhY3RvcnkoKS5zZXQocGFyYW1zKSA6IGl0ZW1GYWN0b3J5O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1GYWN0b3J5XCIsIHsgdmFsdWUsIGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlIH0pO1xuICAgIHRoaXMuc2V0KHByb3BlcnRpZXMpO1xuICB9XG4gIHNldChwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKGlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXSA9IHRoaXMuaXRlbUZhY3RvcnkocHJvcGVydGllc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0KHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbmV3IF9Qcm9wZXJ0aWVzQXJyYXkodGhpcy5pdGVtRmFjdG9yeSwgLi4ucHJvcGVydGllcyk7XG4gIH1cbiAgdG9Kc29uKCkge1xuICAgIHJldHVybiB0aGlzLm1hcCgodmFsdWUpID0+IHZhbHVlPy50b0pzb24/LigpID8/IHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzUHJvcGVydGllcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCYXNlUHJvcGVydGllcyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFByb3BlcnRpZXNBcnJheTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9qc29uLnRzXG52YXIgQ0xBU1NfSU5TVEFOQ0VfVFlQRSA9IFwiY2xhc3MtaW5zdGFuY2VcIjtcbmZ1bmN0aW9uIGpzb25EaWZmKHNvdXJjZSwgdGFyZ2V0LCBza2lwKSB7XG4gIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICBpZiAoIWlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UubGVuZ3RoICE9PSB0YXJnZXQubGVuZ3RoIHx8IHRhcmdldC5zb21lKCh2LCBpKSA9PiBqc29uRGlmZihzb3VyY2VbaV0sIHYpICE9IG51bGwpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgYWxsS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIC4uLk9iamVjdC5rZXlzKHNvdXJjZSksXG4gICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpXG4gICAgXSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgaWYgKHNvdXJjZVtrZXldID09PSB0YXJnZXRba2V5XSB8fCBza2lwPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gdHlwZW9mIHRhcmdldFtrZXldKSB7XG4gICAgICAgIGNvbnN0IGRpZmYyID0ganNvbkRpZmYoc291cmNlW2tleV0sIHRhcmdldFtrZXldKTtcbiAgICAgICAgaWYgKGRpZmYyICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBkaWZmMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgfSBlbHNlIGlmIChzb3VyY2UgIT09IHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcCgoaXRlbSkgPT4gZGVlcENsb25lKGl0ZW0sIG9wdGlvbnMpKTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG1hcFZhbHVlcyhcbiAgICAgIHNvdXJjZSxcbiAgICAgICh2YWx1ZSwga2V5KSA9PiBvcHRpb25zPy5zaGFsbG93Py5pbmNsdWRlcyhrZXkpID8gc2hhbGxvd0Nsb25lKHZhbHVlKSA6IGRlZXBDbG9uZSh2YWx1ZSwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIHJldHVybiBzaGFsbG93Q2xvbmUoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBbLi4uc291cmNlXTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHsgLi4uc291cmNlIH07XG4gIH1cbiAgaWYgKGlzRGF0ZShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGlzUmVnRXhwKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2Uuc291cmNlLCBzb3VyY2UuZmxhZ3MpO1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBqc29uV2Fsayhqc29uLCB2aXNpdCwgb3B0cywgLi4uanNvbnMpIHtcbiAgaWYgKGlzQXJyYXkoanNvbikpIHtcbiAgICB2aXNpdChqc29uLCAuLi5qc29ucyk7XG4gICAganNvbi5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAganNvbldhbGsobm9kZSwgdmlzaXQsIG9wdHMsIC4uLmtleU1hcHBlcihqc29ucywgaW5kZXgpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGpzb24pKSB7XG4gICAgdmlzaXQoanNvbiwgLi4uanNvbnMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGpzb24pKSB7XG4gICAgICBpZiAob3B0cz8uc2tpcD8uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0ganNvbltrZXldO1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGpzb25XYWxrKHZhbHVlLCB2aXNpdCwgb3B0cywgLi4ua2V5TWFwcGVyKGpzb25zLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGpzb25BcHBseSh0YXJnZXQsIHNvdXJjZSwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgeyBwYXRoLCBtYXRjaGVyUGF0aCA9IHBhdGg/LnJlcGxhY2UoLyhcXFtbMC05K10rXSkvaSwgXCJbXVwiKSwgc2tpcCA9IFtdIH0gPSBwYXJhbXM7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdGFyZ2V0IGlzIHVuaW5pdGlhbGlzZWQ6ICR7cGF0aCA/PyBcIjxyb290PlwifWApO1xuICB9XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKGlzUHJvcGVydGllcyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5zZXQoc291cmNlKTtcbiAgfVxuICBjb25zdCB0YXJnZXRBbnkgPSB0YXJnZXQ7XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBjbGFzc2lmeSh0YXJnZXQpO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgIGlmIChTS0lQX0pTX0JVSUxUSU5TLmhhcyhwcm9wZXJ0eSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBwcm9wZXJ0eU1hdGNoZXJQYXRoID0gYCR7bWF0Y2hlclBhdGggPyBtYXRjaGVyUGF0aCArIFwiLlwiIDogXCJcIn0ke3Byb3BlcnR5fWA7XG4gICAgaWYgKHNraXAuaW5jbHVkZXMocHJvcGVydHlNYXRjaGVyUGF0aCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgY29uc3QgcHJvcGVydHlQYXRoID0gYCR7cGF0aCA/IHBhdGggKyBcIi5cIiA6IFwiXCJ9JHtwcm9wZXJ0eX1gO1xuICAgIGNvbnN0IHRhcmdldENsYXNzID0gdGFyZ2V0QW55LmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldEFueVtwcm9wZXJ0eV07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZVR5cGUgPSBjbGFzc2lmeShjdXJyZW50VmFsdWUpO1xuICAgICAgY29uc3QgbmV3VmFsdWVUeXBlID0gY2xhc3NpZnkobmV3VmFsdWUpO1xuICAgICAgaWYgKHRhcmdldFR5cGUgPT09IENMQVNTX0lOU1RBTkNFX1RZUEUgJiYgIShwcm9wZXJ0eSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluICR7dGFyZ2V0Q2xhc3M/Lm5hbWV9IC0gcHJvcGVydHkgaXMgdW5rbm93bmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VmFsdWVUeXBlICE9IG51bGwgJiYgbmV3VmFsdWVUeXBlICE9IG51bGwgJiYgbmV3VmFsdWVUeXBlICE9PSBjdXJyZW50VmFsdWVUeXBlICYmIChjdXJyZW50VmFsdWVUeXBlICE9PSBDTEFTU19JTlNUQU5DRV9UWVBFIHx8IG5ld1ZhbHVlVHlwZSAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgICAgYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gJHt0YXJnZXRDbGFzcz8ubmFtZX0gLSBjYW4ndCBhcHBseSB0eXBlIG9mIFske25ld1ZhbHVlVHlwZX1dLCBhbGxvd2VkIHR5cGVzIGFyZTogWyR7Y3VycmVudFZhbHVlVHlwZX1dYFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3BlcnRpZXMoY3VycmVudFZhbHVlKSkge1xuICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldLnNldChuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldID0ge307XG4gICAgICAgIH1cbiAgICAgICAganNvbkFwcGx5KGN1cnJlbnRWYWx1ZSA/PyB0YXJnZXRBbnlbcHJvcGVydHldLCBuZXdWYWx1ZSwge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBwYXRoOiBwcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgbWF0Y2hlclBhdGg6IHByb3BlcnR5TWF0Y2hlclBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluIFske3RhcmdldENsYXNzPy5uYW1lfV07IG5lc3RlZCBlcnJvciBpczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24ga2V5TWFwcGVyKGRhdGEsIGtleSkge1xuICByZXR1cm4gZGF0YS5tYXAoKGRhdGFPYmplY3QpID0+IGRhdGFPYmplY3Q/LltrZXldKTtcbn1cbmZ1bmN0aW9uIGNsYXNzaWZ5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzSHRtbEVsZW1lbnQodmFsdWUpIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJwcmltaXRpdmVcIjtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBcIm9iamVjdFwiIDogQ0xBU1NfSU5TVEFOQ0VfVFlQRTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICB9XG4gIHJldHVybiBcInByaW1pdGl2ZVwiO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vZWFzaW5nLnRzXG52YXIgZWFzaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVhc2luZ19leHBvcnRzLCB7XG4gIGVhc2VJbjogKCkgPT4gZWFzZUluLFxuICBlYXNlSW5PdXQ6ICgpID0+IGVhc2VJbk91dCxcbiAgZWFzZUluT3V0UXVhZDogKCkgPT4gZWFzZUluT3V0UXVhZCxcbiAgZWFzZUluUXVhZDogKCkgPT4gZWFzZUluUXVhZCxcbiAgZWFzZU91dDogKCkgPT4gZWFzZU91dCxcbiAgZWFzZU91dFF1YWQ6ICgpID0+IGVhc2VPdXRRdWFkLFxuICBpbnZlcnNlRWFzZU91dDogKCkgPT4gaW52ZXJzZUVhc2VPdXQsXG4gIGxpbmVhcjogKCkgPT4gbGluZWFyXG59KTtcbnZhciBsaW5lYXIgPSAobikgPT4gbjtcbnZhciBlYXNlSW4gPSAobikgPT4gMSAtIE1hdGguY29zKG4gKiBNYXRoLlBJIC8gMik7XG52YXIgZWFzZU91dCA9IChuKSA9PiBNYXRoLnNpbihuICogTWF0aC5QSSAvIDIpO1xudmFyIGVhc2VJbk91dCA9IChuKSA9PiAtKE1hdGguY29zKG4gKiBNYXRoLlBJKSAtIDEpIC8gMjtcbnZhciBlYXNlSW5RdWFkID0gKG4pID0+IG4gKiBuO1xudmFyIGVhc2VPdXRRdWFkID0gKG4pID0+IDEgLSAoMSAtIG4pICoqIDI7XG52YXIgZWFzZUluT3V0UXVhZCA9IChuKSA9PiBuIDwgMC41ID8gMiAqIG4gKiBuIDogMSAtICgtMiAqIG4gKyAyKSAqKiAyIC8gMjtcbnZhciBpbnZlcnNlRWFzZU91dCA9ICh4KSA9PiAyICogTWF0aC5hc2luKHgpIC8gTWF0aC5QSTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL2FuaW1hdGlvbi50c1xudmFyIFFVSUNLX1RSQU5TSVRJT04gPSAwLjI7XG52YXIgUEhBU0VfT1JERVIgPSBbXCJpbml0aWFsXCIsIFwicmVtb3ZlXCIsIFwidXBkYXRlXCIsIFwiYWRkXCIsIFwidHJhaWxpbmdcIiwgXCJlbmRcIiwgXCJub25lXCJdO1xudmFyIFBIQVNFX01FVEFEQVRBID0ge1xuICBpbml0aWFsOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDEsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDBcbiAgfSxcbiAgYWRkOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAuMjUsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDAuNzVcbiAgfSxcbiAgcmVtb3ZlOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAuMjUsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDBcbiAgfSxcbiAgdXBkYXRlOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAuNSxcbiAgICBhbmltYXRpb25EZWxheTogMC4yNVxuICB9LFxuICB0cmFpbGluZzoge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBRVUlDS19UUkFOU0lUSU9OLFxuICAgIGFuaW1hdGlvbkRlbGF5OiAxLFxuICAgIHNraXBJZk5vRWFybGllckFuaW1hdGlvbnM6IHRydWVcbiAgfSxcbiAgZW5kOiB7XG4gICAgYW5pbWF0aW9uRGVsYXk6IDEgKyBRVUlDS19UUkFOU0lUSU9OLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLFxuICAgIHNraXBJZk5vRWFybGllckFuaW1hdGlvbnM6IHRydWVcbiAgfSxcbiAgbm9uZToge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwXG4gIH1cbn07XG52YXIgUmVwZWF0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlcGVhdFR5cGUyKSA9PiB7XG4gIFJlcGVhdFR5cGUyW1wiTG9vcFwiXSA9IFwibG9vcFwiO1xuICBSZXBlYXRUeXBlMltcIlJldmVyc2VcIl0gPSBcInJldmVyc2VcIjtcbiAgcmV0dXJuIFJlcGVhdFR5cGUyO1xufSkoUmVwZWF0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc05vZGVBcnJheShhcnJheTIpIHtcbiAgcmV0dXJuIGFycmF5Mi5ldmVyeSgobikgPT4gbiBpbnN0YW5jZW9mIE5vZGUpO1xufVxuZnVuY3Rpb24gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyhzZWxlY3Rpb25zT3JOb2Rlcykge1xuICByZXR1cm4gaXNOb2RlQXJyYXkoc2VsZWN0aW9uc09yTm9kZXMpID8geyBub2Rlczogc2VsZWN0aW9uc09yTm9kZXMsIHNlbGVjdGlvbnM6IFtdIH0gOiB7IG5vZGVzOiBbXSwgc2VsZWN0aW9uczogc2VsZWN0aW9uc09yTm9kZXMgfTtcbn1cbnZhciBBbmltYXRpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB0aGlzLmVsYXBzZWQgPSAwO1xuICAgIHRoaXMuaXRlcmF0aW9uID0gMDtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSZXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy5pZCA9IG9wdHMuaWQ7XG4gICAgdGhpcy5ncm91cElkID0gb3B0cy5ncm91cElkO1xuICAgIHRoaXMuYXV0b3BsYXkgPSBvcHRzLmF1dG9wbGF5ID8/IHRydWU7XG4gICAgdGhpcy5lYXNlID0gb3B0cy5lYXNlID8/IGxpbmVhcjtcbiAgICB0aGlzLnBoYXNlID0gb3B0cy5waGFzZTtcbiAgICBjb25zdCBkdXJhdGlvblByb3BvcnRpb24gPSBvcHRzLmR1cmF0aW9uID8/IFBIQVNFX01FVEFEQVRBW3RoaXMucGhhc2VdLmFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvblByb3BvcnRpb24gKiBvcHRzLmRlZmF1bHREdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5ID0gKG9wdHMuZGVsYXkgPz8gMCkgKiBvcHRzLmRlZmF1bHREdXJhdGlvbjtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGU7XG4gICAgdGhpcy5vblBsYXkgPSBvcHRzLm9uUGxheTtcbiAgICB0aGlzLm9uU3RvcCA9IG9wdHMub25TdG9wO1xuICAgIHRoaXMub25VcGRhdGUgPSBvcHRzLm9uVXBkYXRlO1xuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLmNyZWF0ZUludGVycG9sYXRvcihvcHRzLmZyb20sIG9wdHMudG8pO1xuICAgIHRoaXMuZnJvbSA9IG9wdHMuZnJvbTtcbiAgICBpZiAob3B0cy5za2lwID09PSB0cnVlKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlPy4ob3B0cy50bywgZmFsc2UsIHRoaXMpO1xuICAgICAgdGhpcy5vblN0b3A/Lih0aGlzKTtcbiAgICAgIHRoaXMub25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29sbGFwc2FibGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmR1cmF0aW9uID0gdGhpcy5jaGVja0NvbGxhcHNlKG9wdHMsIHRoaXMuZHVyYXRpb24pO1xuICAgIH1cbiAgfVxuICBjaGVja0NvbGxhcHNlKG9wdHMsIGNhbGN1bGF0ZWREdXJhdGlvbikge1xuICAgIGlmIChvcHRzLmZyb20gPT09IG9wdHMudG8pXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCBkaWZmMiA9IHR5cGVvZiBvcHRzLmZyb20gPT09IFwib2JqZWN0XCIgPyBqc29uRGlmZihvcHRzLmZyb20sIG9wdHMudG8pIDogbnVsbDtcbiAgICBpZiAoZGlmZjIpIHtcbiAgICAgIHJldHVybiBjYWxjdWxhdGVkRHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHBsYXkoaW5pdGlhbFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nIHx8IHRoaXMuaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5vblBsYXk/Lih0aGlzKTtcbiAgICBpZiAoIXRoaXMuYXV0b3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGlmICghaW5pdGlhbFVwZGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLm9uVXBkYXRlPy4odGhpcy5mcm9tLCB0cnVlLCB0aGlzKTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMub25TdG9wPy4odGhpcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSh0aW1lMikge1xuICAgIGlmICh0aGlzLmlzQ29tcGxldGUpXG4gICAgICByZXR1cm4gdGltZTI7XG4gICAgaWYgKCF0aGlzLmlzUGxheWluZyAmJiB0aGlzLmF1dG9wbGF5KSB7XG4gICAgICB0aGlzLnBsYXkodHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzRWxhcHNlZCA9IHRoaXMuZWxhcHNlZDtcbiAgICB0aGlzLmVsYXBzZWQgKz0gdGltZTI7XG4gICAgaWYgKHRoaXMuZGVsYXkgPiB0aGlzLmVsYXBzZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdGUodGhpcy5pc1JldmVyc2UgPyAxIC0gdGhpcy5kZWx0YSA6IHRoaXMuZGVsdGEpO1xuICAgIHRoaXMub25VcGRhdGU/Lih2YWx1ZSwgZmFsc2UsIHRoaXMpO1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSB0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAodGhpcy5lbGFwc2VkID49IHRvdGFsRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMub25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgcmV0dXJuIHRpbWUyIC0gKHRvdGFsRHVyYXRpb24gLSBwcmV2aW91c0VsYXBzZWQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgZGVsdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFzZShjbGFtcCgwLCAodGhpcy5lbGFwc2VkIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uLCAxKSk7XG4gIH1cbiAgY3JlYXRlSW50ZXJwb2xhdG9yKGZyb20yLCB0bykge1xuICAgIGlmICh0eXBlb2YgdG8gIT09IFwib2JqZWN0XCIgfHwgaXNJbnRlcnBvbGF0aW5nKHRvKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZShmcm9tMiwgdG8pO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0b3JFbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG8pIHtcbiAgICAgIGNvbnN0IGludGVycG9sYXRvciA9IHRoaXMuaW50ZXJwb2xhdGVWYWx1ZShmcm9tMltrZXldLCB0b1trZXldKTtcbiAgICAgIGlmIChpbnRlcnBvbGF0b3IgIT0gbnVsbCkge1xuICAgICAgICBpbnRlcnBvbGF0b3JFbnRyaWVzLnB1c2goW2tleSwgaW50ZXJwb2xhdG9yXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoZCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGludGVycG9sYXRvcl0gb2YgaW50ZXJwb2xhdG9yRW50cmllcykge1xuICAgICAgICByZXN1bHRba2V5XSA9IGludGVycG9sYXRvcihkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBpbnRlcnBvbGF0ZVZhbHVlKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwIHx8IGIgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcnBvbGF0aW5nKGEpKSB7XG4gICAgICByZXR1cm4gKGQpID0+IGFbaW50ZXJwb2xhdGVdKGIsIGQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlTnVtYmVyKGEsIGIpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlQ29sb3IoYSwgYik7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgaWYgKGEgPT09IGIpXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGludGVycG9sYXRlIHZhbHVlczogJHthfSwgJHtifWApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vZnJvbVRvTW90aW9uLnRzXG52YXIgTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORyA9IHtcbiAgYWRkZWQ6IFwiYWRkXCIsXG4gIHVwZGF0ZWQ6IFwidXBkYXRlXCIsXG4gIHJlbW92ZWQ6IFwicmVtb3ZlXCIsXG4gIHVua25vd246IFwiaW5pdGlhbFwiLFxuICBcIm5vLW9wXCI6IFwibm9uZVwiXG59O1xuZnVuY3Rpb24gZnJvbVRvTW90aW9uKGdyb3VwSWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb25zT3JOb2RlcywgZm5zLCBnZXREYXR1bUlkLCBkaWZmMikge1xuICBjb25zdCB7IGZyb21GbiwgdG9GbiwgaW50ZXJtZWRpYXRlRm4gfSA9IGZucztcbiAgY29uc3QgeyBub2Rlcywgc2VsZWN0aW9ucyB9ID0gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyhzZWxlY3Rpb25zT3JOb2Rlcyk7XG4gIGNvbnN0IHByb2Nlc3NOb2RlcyA9IChsaXZlTm9kZXMsIHN1Yk5vZGVzKSA9PiB7XG4gICAgbGV0IHByZXZGcm9tUHJvcHM7XG4gICAgbGV0IGxpdmVOb2RlSW5kZXggPSAwO1xuICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdWJOb2Rlcykge1xuICAgICAgY29uc3QgaXNMaXZlID0gbGl2ZU5vZGVzW2xpdmVOb2RlSW5kZXhdID09PSBub2RlO1xuICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICBsYXN0OiBub2RlSW5kZXggPj0gc3ViTm9kZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgbGFzdExpdmU6IGxpdmVOb2RlSW5kZXggPj0gbGl2ZU5vZGVzLmxlbmd0aCAtIDEsXG4gICAgICAgIHByZXY6IHN1Yk5vZGVzW25vZGVJbmRleCAtIDFdLFxuICAgICAgICBwcmV2RnJvbVByb3BzLFxuICAgICAgICBwcmV2TGl2ZTogbGl2ZU5vZGVzW2xpdmVOb2RlSW5kZXggLSAxXSxcbiAgICAgICAgbmV4dDogc3ViTm9kZXNbbm9kZUluZGV4ICsgMV0sXG4gICAgICAgIG5leHRMaXZlOiBsaXZlTm9kZXNbbGl2ZU5vZGVJbmRleCArIChpc0xpdmUgPyAxIDogMCldXG4gICAgICB9O1xuICAgICAgY29uc3QgYW5pbWF0aW9uSWQgPSBgJHtncm91cElkfV8ke3N1YklkfV8ke25vZGUuaWR9YDtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uSWQoYW5pbWF0aW9uSWQpO1xuICAgICAgbGV0IHN0YXR1cyA9IFwidW5rbm93blwiO1xuICAgICAgaWYgKCFpc0xpdmUpIHtcbiAgICAgICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gICAgICB9IGVsc2UgaWYgKGdldERhdHVtSWQgJiYgZGlmZjIpIHtcbiAgICAgICAgc3RhdHVzID0gY2FsY3VsYXRlU3RhdHVzKG5vZGUsIG5vZGUuZGF0dW0sIGdldERhdHVtSWQsIGRpZmYyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcGhhc2UsIHN0YXJ0LCBmaW5pc2gsIGRlbGF5LCBkdXJhdGlvbiwgLi4uZnJvbTIgfSA9IGZyb21Gbihub2RlLCBub2RlLmRhdHVtLCBzdGF0dXMsIGN0eCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBoYXNlOiB0b1BoYXNlLFxuICAgICAgICBzdGFydDogdG9TdGFydCxcbiAgICAgICAgZmluaXNoOiB0b0ZpbmlzaCxcbiAgICAgICAgZGVsYXk6IHRvRGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiB0b0R1cmF0aW9uLFxuICAgICAgICAuLi50b1xuICAgICAgfSA9IHRvRm4obm9kZSwgbm9kZS5kYXR1bSwgc3RhdHVzLCBjdHgpO1xuICAgICAgY29uc3QgY29sbGFwc2FibGUgPSBmaW5pc2ggPT0gbnVsbCAmJiB0b0ZpbmlzaCA9PSBudWxsO1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgICAgaWQ6IGFuaW1hdGlvbklkLFxuICAgICAgICBncm91cElkLFxuICAgICAgICBwaGFzZTogcGhhc2UgPz8gdG9QaGFzZSA/PyBcInVwZGF0ZVwiLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gPz8gdG9EdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IGRlbGF5ID8/IHRvRGVsYXksXG4gICAgICAgIGZyb206IGZyb20yLFxuICAgICAgICB0byxcbiAgICAgICAgZWFzZTogZWFzZU91dCxcbiAgICAgICAgY29sbGFwc2FibGUsXG4gICAgICAgIG9uUGxheTogKCkgPT4ge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnN0YXJ0LCAuLi50b1N0YXJ0IH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVwZGF0ZShwcm9wcykge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgICAgaWYgKGludGVybWVkaWF0ZUZuKSB7XG4gICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoaW50ZXJtZWRpYXRlRm4obm9kZSwgbm9kZS5kYXR1bSwgc3RhdHVzLCBjdHgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvcDogKCkgPT4ge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgICAgICAuLi5zdGFydCxcbiAgICAgICAgICAgIC4uLnRvU3RhcnQsXG4gICAgICAgICAgICAuLi5mcm9tMixcbiAgICAgICAgICAgIC4uLnRvLFxuICAgICAgICAgICAgLi4uZmluaXNoLFxuICAgICAgICAgICAgLi4udG9GaW5pc2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaXNMaXZlKSB7XG4gICAgICAgIGxpdmVOb2RlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgcHJldkZyb21Qcm9wcyA9IGZyb20yO1xuICAgIH1cbiAgfTtcbiAgbGV0IHNlbGVjdGlvbkluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLm5vZGVzKCk7XG4gICAgY29uc3QgbGl2ZU5vZGVzID0gc2VsZWN0aW9uTm9kZXMuZmlsdGVyKChuKSA9PiAhc2VsZWN0aW9uLmlzR2FyYmFnZShuKSk7XG4gICAgcHJvY2Vzc05vZGVzKGxpdmVOb2Rlcywgc2VsZWN0aW9uTm9kZXMpO1xuICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1fc2VsZWN0aW9uXyR7c2VsZWN0aW9uSW5kZXh9YCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBwaGFzZTogXCJlbmRcIixcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMSxcbiAgICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgICBvblN0b3AoKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0aW9uSW5kZXgrKztcbiAgfVxuICBwcm9jZXNzTm9kZXMobm9kZXMsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIHN0YXRpY0Zyb21Ub01vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uc09yTm9kZXMsIGZyb20yLCB0bywgZXh0cmFPcHRzKSB7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBjb25zdCB7IHN0YXJ0LCBmaW5pc2gsIHBoYXNlIH0gPSBleHRyYU9wdHM7XG4gIGNvbnN0IGNvbGxhcHNhYmxlID0gZmluaXNoID09IG51bGw7XG4gIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgaWQ6IGAke2dyb3VwSWR9XyR7c3ViSWR9YCxcbiAgICBncm91cElkLFxuICAgIHBoYXNlOiBwaGFzZSA/PyBcInVwZGF0ZVwiLFxuICAgIGZyb206IGZyb20yLFxuICAgIHRvLFxuICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgY29sbGFwc2FibGUsXG4gICAgb25QbGF5OiAoKSA9PiB7XG4gICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25VcGRhdGUocHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBub2RlLnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcbiAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblN0b3A6ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoeyAuLi50bywgLi4uZmluaXNoIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcbiAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoeyAuLi50bywgLi4uZmluaXNoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0YXR1cyhub2RlLCBkYXR1bSwgZ2V0RGF0dW1JZCwgZGlmZjIpIHtcbiAgY29uc3QgaWQgPSBnZXREYXR1bUlkKG5vZGUsIGRhdHVtKTtcbiAgaWYgKGRpZmYyLmFkZGVkLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gXCJhZGRlZFwiO1xuICB9XG4gIGlmIChkaWZmMi5yZW1vdmVkLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gXCJyZW1vdmVkXCI7XG4gIH1cbiAgcmV0dXJuIFwidXBkYXRlZFwiO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWVGb3JtYXQudHNcbnZhciBDT05TVEFOVFMgPSB7XG4gIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgbW9udGhzOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIlxuICBdLFxuICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG59O1xuZnVuY3Rpb24gZGF5T2ZZZWFyKGRhdGUsIHN0YXJ0T2ZZZWFyID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSkge1xuICBjb25zdCBzdGFydE9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0T2ZZZWFyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGNvbnN0IHRpbWVEaWZmID0gZGF0ZS5nZXRUaW1lKCkgLSBzdGFydE9mWWVhci5nZXRUaW1lKCkgKyBzdGFydE9mZnNldCAqIDZlNDtcbiAgY29uc3QgdGltZU9uZURheSA9IDM2ZTUgKiAyNDtcbiAgcmV0dXJuIE1hdGguZmxvb3IodGltZURpZmYgLyB0aW1lT25lRGF5KTtcbn1cbmZ1bmN0aW9uIHdlZWtPZlllYXIoZGF0ZSwgc3RhcnREYXkpIHtcbiAgY29uc3Qgc3RhcnRPZlllYXIgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICBjb25zdCBzdGFydE9mWWVhckRheSA9IHN0YXJ0T2ZZZWFyLmdldERheSgpO1xuICBjb25zdCBmaXJzdFdlZWtTdGFydE9mZnNldCA9IChzdGFydERheSAtIHN0YXJ0T2ZZZWFyRGF5ICsgNykgJSA3O1xuICBjb25zdCBzdGFydE9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgZmlyc3RXZWVrU3RhcnRPZmZzZXQgKyAxKTtcbiAgaWYgKHN0YXJ0T2Zmc2V0IDw9IGRhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZmZzZXQpIC8gNykgKyAxO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIFNVTkRBWSA9IDA7XG52YXIgTU9OREFZID0gMTtcbnZhciBUSFVSU0RBWSA9IDQ7XG5mdW5jdGlvbiBpc29XZWVrT2ZZZWFyKGRhdGUsIHllYXIyID0gZGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gIGNvbnN0IGZpcnN0T2ZZZWFyID0gbmV3IERhdGUoeWVhcjIsIDAsIDEpO1xuICBjb25zdCBmaXJzdE9mWWVhckRheSA9IGZpcnN0T2ZZZWFyLmdldERheSgpO1xuICBjb25zdCBmaXJzdFRodXJzZGF5T2Zmc2V0ID0gKFRIVVJTREFZIC0gZmlyc3RPZlllYXJEYXkgKyA3KSAlIDc7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmV3IERhdGUoeWVhcjIsIDAsIGZpcnN0VGh1cnNkYXlPZmZzZXQgLSAoVEhVUlNEQVkgLSBNT05EQVkpICsgMSk7XG4gIGlmIChzdGFydE9mZnNldCA8PSBkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5T2ZZZWFyKGRhdGUsIHN0YXJ0T2Zmc2V0KSAvIDcpICsgMTtcbiAgfVxuICByZXR1cm4gaXNvV2Vla09mWWVhcihkYXRlLCB5ZWFyMiAtIDEpO1xufVxuZnVuY3Rpb24gdGltZXpvbmUoZGF0ZSkge1xuICBjb25zdCBvZmZzZXQ0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBjb25zdCB1bnNpZ25lZE9mZnNldCA9IE1hdGguYWJzKG9mZnNldDQpO1xuICBjb25zdCBzaWduID0gb2Zmc2V0NCA+IDAgPyBcIi1cIiA6IFwiK1wiO1xuICByZXR1cm4gYCR7c2lnbn0ke3BhZChNYXRoLmZsb29yKHVuc2lnbmVkT2Zmc2V0IC8gNjApLCAyLCBcIjBcIil9JHtwYWQoTWF0aC5mbG9vcih1bnNpZ25lZE9mZnNldCAlIDYwKSwgMiwgXCIwXCIpfWA7XG59XG52YXIgRk9STUFUVEVSUyA9IHtcbiAgYTogKGQpID0+IENPTlNUQU5UUy5zaG9ydERheXNbZC5nZXREYXkoKV0sXG4gIEE6IChkKSA9PiBDT05TVEFOVFMuZGF5c1tkLmdldERheSgpXSxcbiAgYjogKGQpID0+IENPTlNUQU5UUy5zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldLFxuICBCOiAoZCkgPT4gQ09OU1RBTlRTLm1vbnRoc1tkLmdldE1vbnRoKCldLFxuICBjOiBcIiV4LCAlWFwiLFxuICBkOiAoZCwgcCkgPT4gcGFkKGQuZ2V0RGF0ZSgpLCAyLCBwID8/IFwiMFwiKSxcbiAgZTogXCIlX2RcIixcbiAgZjogKGQsIHApID0+IHBhZChkLmdldE1pbGxpc2Vjb25kcygpICogMWUzLCA2LCBwID8/IFwiMFwiKSxcbiAgSDogKGQsIHApID0+IHBhZChkLmdldEhvdXJzKCksIDIsIHAgPz8gXCIwXCIpLFxuICBJOiAoZCwgcCkgPT4ge1xuICAgIGNvbnN0IGhvdXJzID0gZC5nZXRIb3VycygpICUgMTI7XG4gICAgcmV0dXJuIGhvdXJzID09PSAwID8gXCIxMlwiIDogcGFkKGhvdXJzLCAyLCBwID8/IFwiMFwiKTtcbiAgfSxcbiAgajogKGQsIHApID0+IHBhZChkYXlPZlllYXIoZCkgKyAxLCAzLCBwID8/IFwiMFwiKSxcbiAgbTogKGQsIHApID0+IHBhZChkLmdldE1vbnRoKCkgKyAxLCAyLCBwID8/IFwiMFwiKSxcbiAgTTogKGQsIHApID0+IHBhZChkLmdldE1pbnV0ZXMoKSwgMiwgcCA/PyBcIjBcIiksXG4gIEw6IChkLCBwKSA9PiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgMywgcCA/PyBcIjBcIiksXG4gIHA6IChkKSA9PiBkLmdldEhvdXJzKCkgPCAxMiA/IFwiQU1cIiA6IFwiUE1cIixcbiAgUTogKGQpID0+IFN0cmluZyhkLmdldFRpbWUoKSksXG4gIHM6IChkKSA9PiBTdHJpbmcoTWF0aC5mbG9vcihkLmdldFRpbWUoKSAvIDFlMykpLFxuICBTOiAoZCwgcCkgPT4gcGFkKGQuZ2V0U2Vjb25kcygpLCAyLCBwID8/IFwiMFwiKSxcbiAgdTogKGQpID0+IHtcbiAgICBsZXQgZGF5MiA9IGQuZ2V0RGF5KCk7XG4gICAgaWYgKGRheTIgPCAxKVxuICAgICAgZGF5MiArPSA3O1xuICAgIHJldHVybiBTdHJpbmcoZGF5MiAlIDcpO1xuICB9LFxuICBVOiAoZCwgcCkgPT4gcGFkKHdlZWtPZlllYXIoZCwgU1VOREFZKSwgMiwgcCA/PyBcIjBcIiksXG4gIFY6IChkLCBwKSA9PiBwYWQoaXNvV2Vla09mWWVhcihkKSwgMiwgcCA/PyBcIjBcIiksXG4gIHc6IChkLCBwKSA9PiBwYWQoZC5nZXREYXkoKSwgMiwgcCA/PyBcIjBcIiksXG4gIFc6IChkLCBwKSA9PiBwYWQod2Vla09mWWVhcihkLCBNT05EQVkpLCAyLCBwID8/IFwiMFwiKSxcbiAgeDogXCIlLW0vJS1kLyVZXCIsXG4gIFg6IFwiJS1JOiVNOiVTICVwXCIsXG4gIHk6IChkLCBwKSA9PiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCAyLCBwID8/IFwiMFwiKSxcbiAgWTogKGQsIHApID0+IHBhZChkLmdldEZ1bGxZZWFyKCksIDQsIHAgPz8gXCIwXCIpLFxuICBaOiAoZCkgPT4gdGltZXpvbmUoZCksXG4gIFwiJVwiOiAoKSA9PiBcIiVcIlxufTtcbnZhciBQQURTID0ge1xuICBfOiBcIiBcIixcbiAgXCIwXCI6IFwiMFwiLFxuICBcIi1cIjogXCJcIlxufTtcbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgc2l6ZSwgcGFkQ2hhcikge1xuICBjb25zdCBvdXRwdXQgPSBTdHJpbmcoTWF0aC5mbG9vcih2YWx1ZSkpO1xuICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzaXplKSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4gYCR7cGFkQ2hhci5yZXBlYXQoc2l6ZSAtIG91dHB1dC5sZW5ndGgpfSR7b3V0cHV0fWA7XG59XG5mdW5jdGlvbiBidWlsZEZvcm1hdHRlcihmb3JtYXRTdHJpbmcpIHtcbiAgY29uc3QgZm9ybWF0UGFydHMgPSBbXTtcbiAgd2hpbGUgKGZvcm1hdFN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IG5leHRFc2NhcGVJZHggPSBmb3JtYXRTdHJpbmcuaW5kZXhPZihcIiVcIik7XG4gICAgaWYgKG5leHRFc2NhcGVJZHggIT09IDApIHtcbiAgICAgIGNvbnN0IGxpdGVyYWxQYXJ0ID0gbmV4dEVzY2FwZUlkeCA+IDAgPyBmb3JtYXRTdHJpbmcuc3Vic3RyaW5nKDAsIG5leHRFc2NhcGVJZHgpIDogZm9ybWF0U3RyaW5nO1xuICAgICAgZm9ybWF0UGFydHMucHVzaChsaXRlcmFsUGFydCk7XG4gICAgfVxuICAgIGlmIChuZXh0RXNjYXBlSWR4IDwgMClcbiAgICAgIGJyZWFrO1xuICAgIGNvbnN0IG1heWJlUGFkU3BlY2lmaWVyID0gZm9ybWF0U3RyaW5nW25leHRFc2NhcGVJZHggKyAxXTtcbiAgICBjb25zdCBtYXliZVBhZCA9IFBBRFNbbWF5YmVQYWRTcGVjaWZpZXJdO1xuICAgIGlmIChtYXliZVBhZCAhPSBudWxsKSB7XG4gICAgICBuZXh0RXNjYXBlSWR4Kys7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlRm9ybWF0dGVyU3BlY2lmaWVyID0gZm9ybWF0U3RyaW5nW25leHRFc2NhcGVJZHggKyAxXTtcbiAgICBjb25zdCBtYXliZUZvcm1hdHRlciA9IEZPUk1BVFRFUlNbbWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXJdO1xuICAgIGlmICh0eXBlb2YgbWF5YmVGb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9ybWF0UGFydHMucHVzaChbbWF5YmVGb3JtYXR0ZXIsIG1heWJlUGFkXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF5YmVGb3JtYXR0ZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGJ1aWxkRm9ybWF0dGVyKG1heWJlRm9ybWF0dGVyKTtcbiAgICAgIGZvcm1hdFBhcnRzLnB1c2goW2Zvcm1hdHRlciwgbWF5YmVQYWRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0UGFydHMucHVzaChgJHttYXliZVBhZCA/PyBcIlwifSR7bWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXJ9YCk7XG4gICAgfVxuICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5zdWJzdHJpbmcobmV4dEVzY2FwZUlkeCArIDIpO1xuICB9XG4gIHJldHVybiAoZGF0ZVRpbWUpID0+IHtcbiAgICBjb25zdCBkYXRlVGltZUFzRGF0ZSA9IHR5cGVvZiBkYXRlVGltZSA9PT0gXCJudW1iZXJcIiA/IG5ldyBEYXRlKGRhdGVUaW1lKSA6IGRhdGVUaW1lO1xuICAgIHJldHVybiBmb3JtYXRQYXJ0cy5tYXAoKGMpID0+IHR5cGVvZiBjID09PSBcInN0cmluZ1wiID8gYyA6IGNbMF0oZGF0ZVRpbWVBc0RhdGUsIGNbMV0pKS5qb2luKFwiXCIpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWVGb3JtYXREZWZhdWx0cy50c1xuZnVuY3Rpb24gZGF0ZVRvTnVtYmVyKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBEYXRlID8geC5nZXRUaW1lKCkgOiB4O1xufVxuZnVuY3Rpb24gZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCkge1xuICBjb25zdCBmb3JtYXRTdHJpbmcgPSBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0KTtcbiAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyaW5nKTtcbiAgcmV0dXJuIChkYXRlKSA9PiBmb3JtYXR0ZXIoZGF0ZSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MgPSBbXSwgZG9tYWluID0gdGlja3MsIGZvcm1hdE9mZnNldCA9IDApIHtcbiAgbGV0IG1pbkludGVydmFsID0gSW5maW5pdHk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBtaW5JbnRlcnZhbCA9IE1hdGgubWluKG1pbkludGVydmFsLCBNYXRoLmFicyh0aWNrc1tpXSAtIHRpY2tzW2kgLSAxXSkpO1xuICB9XG4gIGNvbnN0IHN0YXJ0WWVhciA9IG5ldyBEYXRlKGRvbWFpblswXSkuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3Qgc3RvcFllYXIgPSBuZXcgRGF0ZShkb21haW4uYXQoLTEpKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCB5ZWFyQ2hhbmdlID0gc3RvcFllYXIgLSBzdGFydFllYXIgPiAwO1xuICBjb25zdCB0aW1lRm9ybWF0ID0gaXNGaW5pdGUobWluSW50ZXJ2YWwpID8gZ2V0SW50ZXJ2YWxMb3dlc3RHcmFudWxhcml0eUZvcm1hdChtaW5JbnRlcnZhbCwgdGlja3MpIDogZ2V0TG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodGlja3NbMF0pO1xuICByZXR1cm4gZm9ybWF0U3RyaW5nQnVpbGRlcihNYXRoLm1heCh0aW1lRm9ybWF0IC0gZm9ybWF0T2Zmc2V0LCAwKSwgeWVhckNoYW5nZSwgdGlja3MpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJ2YWxMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh2YWx1ZSwgdGlja3MpIHtcbiAgaWYgKHZhbHVlIDwgZHVyYXRpb25TZWNvbmQpIHtcbiAgICByZXR1cm4gMCAvKiBNSUxMSVNFQ09ORCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uTWludXRlKSB7XG4gICAgcmV0dXJuIDEgLyogU0VDT05EICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25Ib3VyKSB7XG4gICAgcmV0dXJuIDIgLyogTUlOVVRFICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25EYXkpIHtcbiAgICByZXR1cm4gMyAvKiBIT1VSICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25XZWVrKSB7XG4gICAgcmV0dXJuIDQgLyogV0VFS19EQVkgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbkRheSAqIDI4IHx8IHZhbHVlIDwgZHVyYXRpb25EYXkgKiAzMSAmJiBoYXNEdXBsaWNhdGVNb250aCh0aWNrcykpIHtcbiAgICByZXR1cm4gNSAvKiBTSE9SVF9NT05USCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uWWVhcikge1xuICAgIHJldHVybiA2IC8qIE1PTlRIICovO1xuICB9XG4gIHJldHVybiA3IC8qIFlFQVIgKi87XG59XG5mdW5jdGlvbiBnZXRMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh2YWx1ZSkge1xuICBpZiAoc2Vjb25kX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMCAvKiBNSUxMSVNFQ09ORCAqLztcbiAgfSBlbHNlIGlmIChtaW51dGVfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiAxIC8qIFNFQ09ORCAqLztcbiAgfSBlbHNlIGlmIChob3VyX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMiAvKiBNSU5VVEUgKi87XG4gIH0gZWxzZSBpZiAoZGF5X2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMyAvKiBIT1VSICovO1xuICB9IGVsc2UgaWYgKG1vbnRoX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICBpZiAod2Vla19kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgICByZXR1cm4gNCAvKiBXRUVLX0RBWSAqLztcbiAgICB9XG4gICAgcmV0dXJuIDUgLyogU0hPUlRfTU9OVEggKi87XG4gIH0gZWxzZSBpZiAoeWVhcl9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDYgLyogTU9OVEggKi87XG4gIH1cbiAgcmV0dXJuIDcgLyogWUVBUiAqLztcbn1cbmZ1bmN0aW9uIGhhc0R1cGxpY2F0ZU1vbnRoKHRpY2tzKSB7XG4gIGxldCBwcmV2TW9udGggPSBuZXcgRGF0ZSh0aWNrc1swXSkuZ2V0TW9udGgoKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRpY2tNb250aCA9IG5ldyBEYXRlKHRpY2tzW2ldKS5nZXRNb250aCgpO1xuICAgIGlmIChwcmV2TW9udGggPT09IHRpY2tNb250aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHByZXZNb250aCA9IHRpY2tNb250aDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdCdWlsZGVyKGRlZmF1bHRUaW1lRm9ybWF0LCB5ZWFyQ2hhbmdlLCB0aWNrcykge1xuICBjb25zdCBmaXJzdFRpY2sgPSBkYXRlVG9OdW1iZXIodGlja3NbMF0pO1xuICBjb25zdCBsYXN0VGljayA9IGRhdGVUb051bWJlcih0aWNrcy5hdCgtMSkpO1xuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMobGFzdFRpY2sgLSBmaXJzdFRpY2spO1xuICBjb25zdCBhY3RpdmVZZWFyID0geWVhckNoYW5nZSB8fCBkZWZhdWx0VGltZUZvcm1hdCA9PT0gNyAvKiBZRUFSICovO1xuICBjb25zdCBhY3RpdmVEYXRlID0gZXh0ZW50MiA9PT0gMDtcbiAgY29uc3QgcGFydHMgPSBbXG4gICAgW1wiaG91clwiLCA2ICogZHVyYXRpb25Ib3VyLCAxNCAqIGR1cmF0aW9uRGF5LCAzIC8qIEhPVVIgKi8sIFwiJUkgJXBcIl0sXG4gICAgW1wiaG91clwiLCBkdXJhdGlvbk1pbnV0ZSwgNiAqIGR1cmF0aW9uSG91ciwgMyAvKiBIT1VSICovLCBcIiVJOiVNXCJdLFxuICAgIFtcInNlY29uZFwiLCAxZTMsIDYgKiBkdXJhdGlvbkhvdXIsIDEgLyogU0VDT05EICovLCBcIjolU1wiXSxcbiAgICBbXCJtc1wiLCAwLCA2ICogZHVyYXRpb25Ib3VyLCAwIC8qIE1JTExJU0VDT05EICovLCBcIi4lTFwiXSxcbiAgICBbXCJhbS9wbVwiLCBkdXJhdGlvbk1pbnV0ZSwgNiAqIGR1cmF0aW9uSG91ciwgMyAvKiBIT1VSICovLCBcIiVwXCJdLFxuICAgIFwiIFwiLFxuICAgIFtcImRheVwiLCBkdXJhdGlvbkRheSwgZHVyYXRpb25XZWVrLCA0IC8qIFdFRUtfREFZICovLCBcIiVhXCJdLFxuICAgIFtcIm1vbnRoXCIsIGFjdGl2ZURhdGUgPyAwIDogZHVyYXRpb25XZWVrLCA1MiAqIGR1cmF0aW9uV2VlaywgNSAvKiBTSE9SVF9NT05USCAqLywgXCIlYiAlZFwiXSxcbiAgICBbXCJtb250aFwiLCA1ICogZHVyYXRpb25XZWVrLCAxMCAqIGR1cmF0aW9uWWVhciwgNiAvKiBNT05USCAqLywgXCIlQlwiXSxcbiAgICBcIiBcIixcbiAgICBbXCJ5ZWFyXCIsIGFjdGl2ZVllYXIgPyAwIDogZHVyYXRpb25ZZWFyLCBJbmZpbml0eSwgNyAvKiBZRUFSICovLCBcIiVZXCJdXG4gIF07XG4gIGNvbnN0IGZvcm1hdFBhcnRzID0gcGFydHMuZmlsdGVyKCh2KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgW18sIG1pbiwgbWF4LCBmb3JtYXRdID0gdjtcbiAgICByZXR1cm4gZm9ybWF0ID49IGRlZmF1bHRUaW1lRm9ybWF0ICYmIG1pbiA8PSBleHRlbnQyICYmIGV4dGVudDIgPCBtYXg7XG4gIH0pLnJlZHVjZShcbiAgICAociwgbmV4dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHIucmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFyLnVzZWQuaGFzKG5leHRbMF0pKSB7XG4gICAgICAgIHIucmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICAgIHIudXNlZC5hZGQobmV4dFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHsgcmVzdWx0OiBbXSwgdXNlZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSB9XG4gICkucmVzdWx0O1xuICBjb25zdCBmaXJzdEZvcm1hdCA9IGZvcm1hdFBhcnRzLmZpbmRJbmRleCgodikgPT4gdHlwZW9mIHYgIT09IFwic3RyaW5nXCIpO1xuICBjb25zdCBsYXN0Rm9ybWF0ID0gZm9ybWF0UGFydHMubGVuZ3RoIC0gWy4uLmZvcm1hdFBhcnRzXS5yZXZlcnNlKCkuZmluZEluZGV4KCh2KSA9PiB0eXBlb2YgdiAhPT0gXCJzdHJpbmdcIik7XG4gIHJldHVybiBmb3JtYXRQYXJ0cy5zbGljZShmaXJzdEZvcm1hdCwgbGFzdEZvcm1hdCkubWFwKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgOiB2WzRdKS5qb2luKFwiXCIpLnJlcGxhY2VBbGwoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvaW52YWxpZGF0aW5nLnRzXG52YXIgSW52YWxpZGF0aW5nID0gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcbiAgY29uc3QgbWFwcGVkUHJvcGVydHkgPSBTeW1ib2woU3RyaW5nKHByb3BlcnR5S2V5KSk7XG4gIHRhcmdldFttYXBwZWRQcm9wZXJ0eV0gPSB2b2lkIDA7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbbWFwcGVkUHJvcGVydHldO1xuICAgIH0sXG4gICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbbWFwcGVkUHJvcGVydHldO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzW21hcHBlZFByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pO1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvYmFuZFNjYWxlLnRzXG52YXIgX0JhbmRTY2FsZSA9IGNsYXNzIF9CYW5kU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnR5cGUgPSBcImJhbmRcIjtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMucmFuZ2UgPSBbMCwgMV07XG4gICAgdGhpcy5yb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogTWFwcyBkYXR1bSB0byBpdHMgaW5kZXggaW4gdGhlIHtAbGluayBkb21haW59IGFycmF5LlxuICAgICAqIFVzZWQgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZSBkYXRhIChub3QgYWxsb3dlZCkuXG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCByYW5nZSB2YWx1ZXMgZm9yIGRhdHVtIGF0IGVhY2ggaW5kZXguXG4gICAgICovXG4gICAgdGhpcy5vcmRpbmFsUmFuZ2UgPSBbXTtcbiAgICAvKipcbiAgICAgKiBDb250YWlucyB1bmlxdWUgZGF0YSBvbmx5LlxuICAgICAqL1xuICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgIHRoaXMuX2JhbmR3aWR0aCA9IDE7XG4gICAgdGhpcy5fc3RlcCA9IDE7XG4gICAgdGhpcy5faW5zZXQgPSAxO1xuICAgIHRoaXMuX3Jhd0JhbmR3aWR0aCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHJhdGlvIG9mIHRoZSByYW5nZSB0aGF0IGlzIHJlc2VydmVkIGZvciBzcGFjZSBiZXR3ZWVuIGJhbmRzLlxuICAgICAqL1xuICAgIHRoaXMuX3BhZGRpbmdJbm5lciA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIHJhdGlvIG9mIHRoZSByYW5nZSB0aGF0IGlzIHJlc2VydmVkIGZvciBzcGFjZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICogYW5kIGFmdGVyIHRoZSBsYXN0IGJhbmQuXG4gICAgICovXG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gMDtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQmFuZFNjYWxlO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKCF0aGlzLmludmFsaWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG4gIHNldCBkb21haW4odmFsdWVzKSB7XG4gICAgdGhpcy5pbmRleCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgY29uc3Qga2V5ID0gZGF0ZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh0aGlzLmdldEluZGV4KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmluZGV4LnNldChrZXksIHRoaXMuX2RvbWFpbi5wdXNoKHZhbHVlKSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgZG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICBjb252ZXJ0KGQpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRJbmRleChkKTtcbiAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmRpbmFsUmFuZ2VbaV0gPz8gTmFOO1xuICB9XG4gIGludmVydChwb3NpdGlvbikge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwKSA9PiBwID09PSBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluW2luZGV4XTtcbiAgfVxuICBpbnZlcnROZWFyZXN0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgbGV0IG5lYXJlc3QgPSAtMTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3JkaW5hbFJhbmdlLmZpbmRJbmRleCgocCwgaSkgPT4ge1xuICAgICAgaWYgKHAgPT09IHBvc2l0aW9uKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IE1hdGguYWJzKHBvc2l0aW9uIC0gcCk7XG4gICAgICBpZiAoZGlzdGFuY2UzIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTM7XG4gICAgICAgIG5lYXJlc3QgPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRvbWFpbltpbmRleF0gPz8gdGhpcy5kb21haW5bbmVhcmVzdF07XG4gIH1cbiAgZ2V0IGJhbmR3aWR0aCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fYmFuZHdpZHRoO1xuICB9XG4gIGdldCBzdGVwKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICB9XG4gIGdldCBpbnNldCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5faW5zZXQ7XG4gIH1cbiAgZ2V0IHJhd0JhbmR3aWR0aCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fcmF3QmFuZHdpZHRoO1xuICB9XG4gIHNldCBwYWRkaW5nKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gICAgdGhpcy5fcGFkZGluZ0lubmVyID0gdmFsdWU7XG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdJbm5lcjtcbiAgfVxuICBzZXQgcGFkZGluZ0lubmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fcGFkZGluZ0lubmVyID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICB9XG4gIGdldCBwYWRkaW5nSW5uZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdJbm5lcjtcbiAgfVxuICBzZXQgcGFkZGluZ091dGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICB9XG4gIGdldCBwYWRkaW5nT3V0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdPdXRlcjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kb21haW4ubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbcjAsIHIxXSA9IHRoaXMucmFuZ2U7XG4gICAgbGV0IHsgX3BhZGRpbmdJbm5lcjogcGFkZGluZ0lubmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgX3BhZGRpbmdPdXRlcjogcGFkZGluZ091dGVyLCByb3VuZDogcm91bmQzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhbmdlRGlzdGFuY2UgPSByMSAtIHIwO1xuICAgIGxldCByYXdTdGVwLCBzdGVwLCBpbnNldDtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgIHBhZGRpbmdJbm5lciA9IDA7XG4gICAgICByYXdTdGVwID0gcmFuZ2VEaXN0YW5jZSAqICgxIC0gcGFkZGluZ091dGVyICogMik7XG4gICAgICBzdGVwID0gcm91bmQzID8gTWF0aC5yb3VuZChyYXdTdGVwKSA6IHJhd1N0ZXA7XG4gICAgICBpbnNldCA9IHJhbmdlRGlzdGFuY2UgKiBwYWRkaW5nT3V0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhd1N0ZXAgPSByYW5nZURpc3RhbmNlIC8gTWF0aC5tYXgoMSwgY291bnQgLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICAgIHN0ZXAgPSByb3VuZDMgPyBNYXRoLmZsb29yKHJhd1N0ZXApIDogcmF3U3RlcDtcbiAgICAgIGluc2V0ID0gcjAgKyAocmFuZ2VEaXN0YW5jZSAtIHN0ZXAgKiAoY291bnQgLSBwYWRkaW5nSW5uZXIpKSAvIDI7XG4gICAgfVxuICAgIGxldCBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZDMpIHtcbiAgICAgIGluc2V0ID0gTWF0aC5yb3VuZChpbnNldCk7XG4gICAgICBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgfVxuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIHRoaXMuX2luc2V0ID0gaW5zZXQ7XG4gICAgdGhpcy5fYmFuZHdpZHRoID0gYmFuZHdpZHRoO1xuICAgIHRoaXMuX3Jhd0JhbmR3aWR0aCA9IHJhd1N0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgdGhpcy5vcmRpbmFsUmFuZ2UgPSB0aGlzLl9kb21haW4ubWFwKChfLCBpKSA9PiBpbnNldCArIHN0ZXAgKiBpKTtcbiAgfVxuICBnZXRJbmRleCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4LmdldCh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZS5nZXRUaW1lKCkgOiB2YWx1ZSk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9CYW5kU2NhbGUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQmFuZFNjYWxlLnByb3RvdHlwZSwgXCJyb3VuZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0JhbmRTY2FsZS5wcm90b3R5cGUsIFwiaW50ZXJ2YWxcIiwgMik7XG52YXIgQmFuZFNjYWxlID0gX0JhbmRTY2FsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92YWxpZGF0aW9uLnRzXG5mdW5jdGlvbiBWYWxpZGF0ZShwcmVkaWNhdGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IG9wdGlvbmFsID0gZmFsc2UsIHByb3BlcnR5OiBvdmVycmlkZVByb3BlcnR5IH0gPSBvcHRpb25zO1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHsgLi4ub3B0aW9ucywgdGFyZ2V0LCBwcm9wZXJ0eSB9O1xuICAgICAgaWYgKG9wdGlvbmFsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcmVkaWNhdGUodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgIGlmIChpc1Byb3BlcnRpZXModGFyZ2V0W3Byb3BlcnR5XSkgJiYgIWlzUHJvcGVydGllcyh2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcGVydHldLnNldCh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xlYW5LZXkgPSBvdmVycmlkZVByb3BlcnR5ID8/IFN0cmluZyhwcm9wZXJ0eSkucmVwbGFjZSgvXl8qLywgXCJcIik7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gdGFyZ2V0LmNvbnN0cnVjdG9yLmNsYXNzTmFtZSA/PyB0YXJnZXQuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKC9Qcm9wZXJ0aWVzJC8sIFwiXCIpO1xuICAgICAgbGV0IHZhbHVlU3RyaW5nID0gc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IDUwO1xuICAgICAgaWYgKHZhbHVlU3RyaW5nICE9IG51bGwgJiYgdmFsdWVTdHJpbmcubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGV4Y2Vzc0NoYXJhY3RlcnMgPSB2YWx1ZVN0cmluZy5sZW5ndGggLSBtYXhMZW5ndGg7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gdmFsdWVTdHJpbmcuc2xpY2UoMCwgbWF4TGVuZ3RoKSArIGAuLi4gKCske2V4Y2Vzc0NoYXJhY3RlcnN9IGNoYXJhY3RlcnMpYDtcbiAgICAgIH1cbiAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICBgUHJvcGVydHkgWyR7Y2xlYW5LZXl9XSBvZiBbJHt0YXJnZXROYW1lfV0gY2Fubm90IGJlIHNldCB0byBbJHt2YWx1ZVN0cmluZ31dJHtwcmVkaWNhdGUubWVzc2FnZSA/IGA7IGV4cGVjdGluZyAke2dldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjb250ZXh0KX1gIDogXCJcIn0sIGlnbm9yaW5nLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gQlJFQUtfVFJBTlNGT1JNX0NIQUlOO1xuICAgIH0sXG4gICAgdm9pZCAwLFxuICAgIHsgb3B0aW9uYWwgfVxuICApO1xufVxudmFyIEFORCA9ICguLi5wcmVkaWNhdGVzKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgbWVzc2FnZXMubGVuZ3RoID0gMDtcbiAgICAgIHJldHVybiBwcmVkaWNhdGVzLmV2ZXJ5KChwcmVkaWNhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaXNWYWxpZDIgPSBwcmVkaWNhdGUodmFsdWUsIGN0eCk7XG4gICAgICAgIGlmICghaXNWYWxpZDIpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDI7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICgpID0+IG1lc3NhZ2VzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIEFORCBcIilcbiAgKTtcbn07XG52YXIgT1IgPSAoLi4ucHJlZGljYXRlcykgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSwgY3R4KSA9PiBwcmVkaWNhdGVzLnNvbWUoKHByZWRpY2F0ZSkgPT4gcHJlZGljYXRlKHZhbHVlLCBjdHgpKSxcbiAgKGN0eCkgPT4gcHJlZGljYXRlcy5tYXAoZ2V0UHJlZGljYXRlTWVzc2FnZU1hcHBlcihjdHgpKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBPUiBcIilcbik7XG52YXIgT0JKRUNUID0gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKFxuICBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodmFsdWUsIGN0eCkgPT4gaXNQcm9wZXJ0aWVzKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgJiYgaXNQcm9wZXJ0aWVzKGN0eC50YXJnZXRbY3R4LnByb3BlcnR5XSksXG4gICAgXCJhIHByb3BlcnRpZXMgb2JqZWN0XCJcbiAgKVxuKTtcbnZhciBQTEFJTl9PQkpFQ1QgPSBhdHRhY2hPYmplY3RSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSksIFwiYW4gb2JqZWN0XCIpKTtcbnZhciBCT09MRUFOID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNCb29sZWFuLCBcImEgYm9vbGVhblwiKTtcbnZhciBGVU5DVElPTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzRnVuY3Rpb24sIFwiYSBmdW5jdGlvblwiKTtcbnZhciBTVFJJTkcgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc1N0cmluZywgXCJhIHN0cmluZ1wiKTtcbnZhciBOVU1CRVIgPSBhdHRhY2hOdW1iZXJSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNGaW5pdGVOdW1iZXIsIFwiYSBudW1iZXJcIikpO1xudmFyIE5BTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNOdW1iZXIodmFsdWUpICYmIGlzTmFOKHZhbHVlKSwgXCJOYU5cIik7XG52YXIgUE9TSVRJVkVfTlVNQkVSID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwIH0pO1xudmFyIFJBVElPID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwLCBtYXg6IDEgfSk7XG52YXIgREVHUkVFID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAtMzYwLCBtYXg6IDM2MCB9KTtcbnZhciBOVU1CRVJfT1JfTkFOID0gT1IoTlVNQkVSLCBOQU4pO1xudmFyIEFSUkFZID0gYXR0YWNoQXJyYXlSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNBcnJheSwgXCJhbiBhcnJheVwiKSk7XG52YXIgQVJSQVlfT0YgPSAocHJlZGljYXRlLCBtZXNzYWdlKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlLCBjdHgpID0+IGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KChpdGVtKSA9PiBwcmVkaWNhdGUoaXRlbSwgY3R4KSksXG4gIChjdHgpID0+IHtcbiAgICBjb25zdCBhcnJheU1lc3NhZ2UgPSBnZXRQcmVkaWNhdGVNZXNzYWdlKEFSUkFZLCBjdHgpID8/IFwiXCI7XG4gICAgcmV0dXJuIG1lc3NhZ2UgPyBgJHthcnJheU1lc3NhZ2V9IG9mICR7bWVzc2FnZX1gIDogYXJyYXlNZXNzYWdlO1xuICB9XG4pO1xudmFyIGlzQ29tcGFyYWJsZSA9ICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHx8IGlzVmFsaWREYXRlKHZhbHVlKTtcbnZhciBMRVNTX1RIQU4gPSAob3RoZXJGaWVsZCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2LCBjdHgpID0+ICFpc0NvbXBhcmFibGUodikgfHwgIWlzQ29tcGFyYWJsZShjdHgudGFyZ2V0W290aGVyRmllbGRdKSB8fCB2IDwgY3R4LnRhcmdldFtvdGhlckZpZWxkXSxcbiAgYHRvIGJlIGxlc3MgdGhhbiAke290aGVyRmllbGR9YFxuKTtcbnZhciBHUkVBVEVSX1RIQU4gPSAob3RoZXJGaWVsZCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2LCBjdHgpID0+ICFpc0NvbXBhcmFibGUodikgfHwgIWlzQ29tcGFyYWJsZShjdHgudGFyZ2V0W290aGVyRmllbGRdKSB8fCB2ID4gY3R4LnRhcmdldFtvdGhlckZpZWxkXSxcbiAgYHRvIGJlIGdyZWF0ZXIgdGhhbiAke290aGVyRmllbGR9YFxuKTtcbnZhciBEQVRFID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNWYWxpZERhdGUsIFwiRGF0ZSBvYmplY3RcIik7XG52YXIgREFURV9PUl9EQVRFVElNRV9NUyA9IE9SKERBVEUsIFBPU0lUSVZFX05VTUJFUik7XG52YXIgY29sb3JNZXNzYWdlID0gYEEgY29sb3Igc3RyaW5nIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzIHRvIGJlIHZhbGlkOiAjcmdiLCAjcnJnZ2JiLCByZ2IociwgZywgYiksIHJnYmEociwgZywgYiwgYSkgb3IgYSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Y2A7XG52YXIgQ09MT1JfU1RSSU5HID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2KSA9PiBpc1N0cmluZyh2KSAmJiBDb2xvci52YWxpZENvbG9yU3RyaW5nKHYpLFxuICBgY29sb3IgU3RyaW5nLiAke2NvbG9yTWVzc2FnZX1gXG4pO1xudmFyIENPTE9SX1NUUklOR19BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKENPTE9SX1NUUklORyksIGBjb2xvciBzdHJpbmdzLiAke2NvbG9yTWVzc2FnZX1gKTtcbnZhciBCT09MRUFOX0FSUkFZID0gQVJSQVlfT0YoQk9PTEVBTiwgXCJib29sZWFuIHZhbHVlc1wiKTtcbnZhciBOVU1CRVJfQVJSQVkgPSBBUlJBWV9PRihOVU1CRVIsIFwibnVtYmVyc1wiKTtcbnZhciBTVFJJTkdfQVJSQVkgPSBBUlJBWV9PRihTVFJJTkcsIFwic3RyaW5nc1wiKTtcbnZhciBEQVRFX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVlfT0YoREFURSksIFwiRGF0ZSBvYmplY3RzXCIpO1xudmFyIE9CSkVDVF9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKE9CSkVDVCksIFwib2JqZWN0c1wiKTtcbnZhciBMSU5FX0NBUCA9IFVOSU9OKFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXSwgXCJhIGxpbmUgY2FwXCIpO1xudmFyIExJTkVfSk9JTiA9IFVOSU9OKFtcInJvdW5kXCIsIFwiYmV2ZWxcIiwgXCJtaXRlclwiXSwgXCJhIGxpbmUgam9pblwiKTtcbnZhciBMSU5FX0RBU0ggPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgQVJSQVlfT0YoUE9TSVRJVkVfTlVNQkVSKSxcbiAgXCJudW1iZXJzIHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBpbiBwaXhlbHMgb2YgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzLCBmb3IgZXhhbXBsZSwgWzYsIDNdIG1lYW5zIGRhc2hlcyB3aXRoIGEgbGVuZ3RoIG9mIDYgcGl4ZWxzIHdpdGggZ2FwcyBiZXR3ZWVuIG9mIDMgcGl4ZWxzLlwiXG4pO1xudmFyIFBPU0lUSU9OID0gVU5JT04oW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLCBcImEgcG9zaXRpb25cIik7XG52YXIgRk9OVF9TVFlMRSA9IFVOSU9OKFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiLCBcIm9ibGlxdWVcIl0sIFwiYSBmb250IHN0eWxlXCIpO1xudmFyIEZPTlRfV0VJR0hUID0gT1IoXG4gIFVOSU9OKFtcIm5vcm1hbFwiLCBcImJvbGRcIiwgXCJib2xkZXJcIiwgXCJsaWdodGVyXCJdLCBcImEgZm9udCB3ZWlnaHRcIiksXG4gIE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSwgbWF4OiAxZTMgfSlcbik7XG52YXIgVEVYVF9XUkFQID0gVU5JT04oW1wibmV2ZXJcIiwgXCJhbHdheXNcIiwgXCJoeXBoZW5hdGVcIiwgXCJvbi1zcGFjZVwiXSwgXCJhIHRleHQgd3JhcCBzdHJhdGVneVwiKTtcbnZhciBURVhUX0FMSUdOID0gVU5JT04oW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdLCBcImEgdGV4dCBhbGlnblwiKTtcbnZhciBWRVJUSUNBTF9BTElHTiA9IFVOSU9OKFtcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXSwgXCJhIHZlcnRpY2FsIGFsaWduXCIpO1xudmFyIE9WRVJGTE9XX1NUUkFURUdZID0gVU5JT04oW1wiZWxsaXBzaXNcIiwgXCJoaWRlXCJdLCBcImFuIG92ZXJmbG93IHN0cmF0ZWd5XCIpO1xudmFyIERJUkVDVElPTiA9IFVOSU9OKFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSwgXCJhIGRpcmVjdGlvblwiKTtcbnZhciBQTEFDRU1FTlQgPSBVTklPTihbXCJpbnNpZGVcIiwgXCJvdXRzaWRlXCJdLCBcImEgcGxhY2VtZW50XCIpO1xudmFyIElOVEVSQUNUSU9OX1JBTkdFID0gT1IoVU5JT04oW1wiZXhhY3RcIiwgXCJuZWFyZXN0XCJdLCBcImludGVyYWN0aW9uIHJhbmdlXCIpLCBOVU1CRVIpO1xudmFyIExBQkVMX1BMQUNFTUVOVCA9IFVOSU9OKFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSk7XG5mdW5jdGlvbiBVTklPTihvcHRpb25zLCBtZXNzYWdlID0gXCJhXCIpIHtcbiAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICh2KSA9PiBvcHRpb25zLmluY2x1ZGVzKHYpLFxuICAgIGAke21lc3NhZ2V9IGtleXdvcmQgc3VjaCBhcyAke2pvaW5Vbmlvbk9wdGlvbnMob3B0aW9ucyl9YFxuICApO1xufVxudmFyIE1JTl9TUEFDSU5HID0gT1IoQU5EKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSwgTEVTU19USEFOKFwibWF4U3BhY2luZ1wiKSksIE5BTik7XG52YXIgTUFYX1NQQUNJTkcgPSBPUihBTkQoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxIH0pLCBHUkVBVEVSX1RIQU4oXCJtaW5TcGFjaW5nXCIpKSwgTkFOKTtcbmZ1bmN0aW9uIHByZWRpY2F0ZVdpdGhNZXNzYWdlKHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICBwcmVkaWNhdGUubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHJldHVybiBwcmVkaWNhdGU7XG59XG5mdW5jdGlvbiBqb2luVW5pb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgdmFsdWVzID0gb3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gYCcke29wdGlvbn0nYCk7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfVxuICBjb25zdCBsYXN0VmFsdWUgPSB2YWx1ZXMucG9wKCk7XG4gIHJldHVybiBgJHt2YWx1ZXMuam9pbihcIiwgXCIpfSBvciAke2xhc3RWYWx1ZX1gO1xufVxuZnVuY3Rpb24gZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCkge1xuICByZXR1cm4gaXNGdW5jdGlvbihwcmVkaWNhdGUubWVzc2FnZSkgPyBwcmVkaWNhdGUubWVzc2FnZShjdHgpIDogcHJlZGljYXRlLm1lc3NhZ2U7XG59XG5mdW5jdGlvbiBnZXRQcmVkaWNhdGVNZXNzYWdlTWFwcGVyKGN0eCkge1xuICByZXR1cm4gKHByZWRpY2F0ZSkgPT4gZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCk7XG59XG5mdW5jdGlvbiBhdHRhY2hBcnJheVJlc3RyaWN0aW9ucyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlZGljYXRlLCB7XG4gICAgcmVzdHJpY3QoeyBsZW5ndGg6IGxlbmd0aDIsIG1pbkxlbmd0aCB9ID0ge30pIHtcbiAgICAgIGxldCBtZXNzYWdlID0gXCJhbiBhcnJheVwiO1xuICAgICAgaWYgKGlzTnVtYmVyKG1pbkxlbmd0aCkgJiYgbWluTGVuZ3RoID4gMCkge1xuICAgICAgICBtZXNzYWdlID0gXCJhIG5vbi1lbXB0eSBhcnJheVwiO1xuICAgICAgfSBlbHNlIGlmIChpc051bWJlcihsZW5ndGgyKSkge1xuICAgICAgICBtZXNzYWdlID0gYGFuIGFycmF5IG9mIGxlbmd0aCAke2xlbmd0aDJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAgICAgKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSAmJiAoaXNOdW1iZXIobGVuZ3RoMikgPyB2YWx1ZS5sZW5ndGggPT09IGxlbmd0aDIgOiB0cnVlKSAmJiAoaXNOdW1iZXIobWluTGVuZ3RoKSA/IHZhbHVlLmxlbmd0aCA+PSBtaW5MZW5ndGggOiB0cnVlKSxcbiAgICAgICAgbWVzc2FnZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYXR0YWNoTnVtYmVyUmVzdHJpY3Rpb25zKHByZWRpY2F0ZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGUsIHtcbiAgICByZXN0cmljdCh7IG1pbiwgbWF4IH0gPSB7fSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFtcImEgbnVtYmVyXCJdO1xuICAgICAgY29uc3QgaGFzTWluID0gaXNOdW1iZXIobWluKTtcbiAgICAgIGNvbnN0IGhhc01heCA9IGlzTnVtYmVyKG1heCk7XG4gICAgICBpZiAoaGFzTWluICYmIGhhc01heCkge1xuICAgICAgICBtZXNzYWdlLnB1c2goYGJldHdlZW4gJHttaW59IGFuZCAke21heH0gaW5jbHVzaXZlYCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc01pbikge1xuICAgICAgICBtZXNzYWdlLnB1c2goYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn1gKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTWF4KSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICAgICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiAoaGFzTWluID8gdmFsdWUgPj0gbWluIDogdHJ1ZSkgJiYgKGhhc01heCA/IHZhbHVlIDw9IG1heCA6IHRydWUpLFxuICAgICAgICBtZXNzYWdlLmpvaW4oXCIgXCIpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRhY2hPYmplY3RSZXN0cmljdGlvbnMocHJlZGljYXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHByZWRpY2F0ZSwge1xuICAgIHJlc3RyaWN0KG9iamVjdFR5cGUpIHtcbiAgICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAgICAgKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIG9iamVjdFR5cGUsXG4gICAgICAgIChjdHgpID0+IGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpID8/IGBhbiBpbnN0YW5jZSBvZiAke29iamVjdFR5cGUubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpc05hTih2YWx1ZSkpXG4gICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KVxuICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICBpZiAodmFsdWUgPT09IC1JbmZpbml0eSlcbiAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0QXhpc0RpcmVjdGlvbi50c1xudmFyIENoYXJ0QXhpc0RpcmVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKENoYXJ0QXhpc0RpcmVjdGlvbjIpID0+IHtcbiAgQ2hhcnRBeGlzRGlyZWN0aW9uMltcIlhcIl0gPSBcInhcIjtcbiAgQ2hhcnRBeGlzRGlyZWN0aW9uMltcIllcIl0gPSBcInlcIjtcbiAgcmV0dXJuIENoYXJ0QXhpc0RpcmVjdGlvbjI7XG59KShDaGFydEF4aXNEaXJlY3Rpb24gfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvbW9kdWxlTWFwLnRzXG52YXIgTW9kdWxlTWFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1vZHVsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgKm1vZHVsZXMoKSB7XG4gICAgY29uc3Qgc2VxdWVuY2VkTW9kdWxlcyA9IFtcInRvb2xiYXJcIiwgXCJuYXZpZ2F0b3JcIl07XG4gICAgZm9yIChjb25zdCBtIG9mIHRoaXMubW9kdWxlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoc2VxdWVuY2VkTW9kdWxlcy5pbmNsdWRlcyhtLm1vZHVsZS5vcHRpb25zS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIG0ubW9kdWxlSW5zdGFuY2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIHNlcXVlbmNlZE1vZHVsZXMpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlTWFwLmdldChrZXkpO1xuICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICB5aWVsZCBtb2R1bGUubW9kdWxlSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFkZE1vZHVsZShtb2R1bGUsIG1vZHVsZUZhY3RvcnkpIHtcbiAgICBpZiAodGhpcy5tb2R1bGVNYXAuaGFzKG1vZHVsZS5vcHRpb25zS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBtb2R1bGUgYWxyZWFkeSBpbml0aWFsaXNlZDogJHttb2R1bGUub3B0aW9uc0tleX1gKTtcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVNYXAuc2V0KG1vZHVsZS5vcHRpb25zS2V5LCB7IG1vZHVsZSwgbW9kdWxlSW5zdGFuY2U6IG1vZHVsZUZhY3RvcnkobW9kdWxlKSB9KTtcbiAgfVxuICByZW1vdmVNb2R1bGUobW9kdWxlKSB7XG4gICAgY29uc3QgbW9kdWxlS2V5ID0gaXNTdHJpbmcobW9kdWxlKSA/IG1vZHVsZSA6IG1vZHVsZS5vcHRpb25zS2V5O1xuICAgIHRoaXMubW9kdWxlTWFwLmdldChtb2R1bGVLZXkpPy5tb2R1bGVJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgdGhpcy5tb2R1bGVNYXAuZGVsZXRlKG1vZHVsZUtleSk7XG4gIH1cbiAgZ2V0TW9kdWxlKG1vZHVsZSkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5nZXQoaXNTdHJpbmcobW9kdWxlKSA/IG1vZHVsZSA6IG1vZHVsZS5vcHRpb25zS2V5KT8ubW9kdWxlSW5zdGFuY2U7XG4gIH1cbiAgaXNFbmFibGVkKG1vZHVsZSkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5oYXMoaXNTdHJpbmcobW9kdWxlKSA/IG1vZHVsZSA6IG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgfVxuICBtYXBNb2R1bGVzKGNhbGxiYWNrMikge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubW9kdWxlTWFwLnZhbHVlcygpLCAobSwgaSkgPT4gY2FsbGJhY2syKG0ubW9kdWxlSW5zdGFuY2UsIGkpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgbW9kdWxlS2V5IG9mIHRoaXMubW9kdWxlTWFwLmtleXMoKSkge1xuICAgICAgdGhpcy5tb2R1bGVNYXAuZ2V0KG1vZHVsZUtleSk/Lm1vZHVsZUluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVNYXAuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL3Jlc2V0TW90aW9uLnRzXG52YXIgcmVzZXRNb3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVzZXRNb3Rpb25fZXhwb3J0cywge1xuICByZXNldE1vdGlvbjogKCkgPT4gcmVzZXRNb3Rpb25cbn0pO1xuZnVuY3Rpb24gcmVzZXRNb3Rpb24oc2VsZWN0aW9uc09yTm9kZXMsIHByb3BzRm4pIHtcbiAgY29uc3QgeyBub2Rlcywgc2VsZWN0aW9ucyB9ID0gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyhzZWxlY3Rpb25zT3JOb2Rlcyk7XG4gIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcbiAgICAgIGNvbnN0IGZyb20yID0gcHJvcHNGbihub2RlLCBub2RlLmRhdHVtKTtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhmcm9tMik7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgY29uc3QgZnJvbTIgPSBwcm9wc0ZuKG5vZGUsIG5vZGUuZGF0dW0pO1xuICAgIG5vZGUuc2V0UHJvcGVydGllcyhmcm9tMik7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvY29udGludW91c1NjYWxlLnRzXG52YXIgX0NvbnRpbnVvdXNTY2FsZSA9IGNsYXNzIF9Db250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihkb21haW4sIHJhbmdlMykge1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5uaWNlID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcnZhbCA9IHZvaWQgMDtcbiAgICB0aGlzLnRpY2tDb3VudCA9IF9Db250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcbiAgICB0aGlzLm1pblRpY2tDb3VudCA9IDA7XG4gICAgdGhpcy5tYXhUaWNrQ291bnQgPSBJbmZpbml0eTtcbiAgICAvLyBUT0RPKG9sZWdhdCkgc2hvdWxkIGJlIG9mIHR5cGUgRFtdXG4gICAgdGhpcy5uaWNlRG9tYWluID0gW107XG4gICAgdGhpcy5kZWZhdWx0Q2xhbXBNb2RlID0gXCJyYXdcIjtcbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2UzO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9Db250aW51b3VzU2NhbGU7XG4gIH1cbiAgdHJhbnNmb3JtKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICB0cmFuc2Zvcm1JbnZlcnQoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIGNhbGNCYW5kd2lkdGgoc21hbGxlc3RJbnRlcnZhbCA9IDEpIHtcbiAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xuICAgIGNvbnN0IHJhbmdlRGlzdGFuY2UgPSB0aGlzLmdldFBpeGVsUmFuZ2UoKTtcbiAgICBjb25zdCBpbnRlcnZhbHMgPSBNYXRoLmFicyhkb21haW5bMV0gLSBkb21haW5bMF0pIC8gc21hbGxlc3RJbnRlcnZhbCArIDE7XG4gICAgY29uc3QgbWF4QmFuZHMgPSBNYXRoLmZsb29yKHJhbmdlRGlzdGFuY2UpO1xuICAgIGNvbnN0IGJhbmRzID0gTWF0aC5taW4oaW50ZXJ2YWxzLCBtYXhCYW5kcyk7XG4gICAgcmV0dXJuIHJhbmdlRGlzdGFuY2UgLyBNYXRoLm1heCgxLCBiYW5kcyk7XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgaWYgKHRoaXMubmljZURvbWFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmljZURvbWFpbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluO1xuICB9XG4gIGNvbnZlcnQoeCwgb3B0cykge1xuICAgIGNvbnN0IGNsYW1wTW9kZSA9IG9wdHM/LmNsYW1wTW9kZSA/PyB0aGlzLmRlZmF1bHRDbGFtcE1vZGU7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpLm1hcCgoZCkgPT4gdGhpcy50cmFuc2Zvcm0oZCkpO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gZG9tYWluO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBbcjAsIHIxXSA9IHJhbmdlMztcbiAgICB4ID0gdGhpcy50cmFuc2Zvcm0oeCk7XG4gICAgaWYgKGNsYW1wTW9kZSA9PT0gXCJjbGFtcGVkXCIpIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgc3RvcF0gPSBmaW5kTWluTWF4KGRvbWFpbi5tYXAoTnVtYmVyKSk7XG4gICAgICBpZiAoTnVtYmVyKHgpIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHIwO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIoeCkgPiBzdG9wKSB7XG4gICAgICAgIHJldHVybiByMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGQwID09PSBkMSkge1xuICAgICAgcmV0dXJuIChyMCArIHIxKSAvIDI7XG4gICAgfSBlbHNlIGlmICh4ID09PSBkMCkge1xuICAgICAgcmV0dXJuIHIwO1xuICAgIH0gZWxzZSBpZiAoeCA9PT0gZDEpIHtcbiAgICAgIHJldHVybiByMTtcbiAgICB9XG4gICAgcmV0dXJuIHIwICsgKE51bWJlcih4KSAtIE51bWJlcihkMCkpIC8gKE51bWJlcihkMSkgLSBOdW1iZXIoZDApKSAqIChyMSAtIHIwKTtcbiAgfVxuICBpbnZlcnQoeCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCkubWFwKChkMikgPT4gdGhpcy50cmFuc2Zvcm0oZDIpKTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgW3IwLCByMV0gPSByYW5nZTM7XG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IHIwID4gcjE7XG4gICAgY29uc3Qgck1pbiA9IGlzUmV2ZXJzZWQgPyByMSA6IHIwO1xuICAgIGNvbnN0IHJNYXggPSBpc1JldmVyc2VkID8gcjAgOiByMTtcbiAgICBsZXQgZDtcbiAgICBpZiAoeCA8IHJNaW4pIHtcbiAgICAgIHJldHVybiBpc1JldmVyc2VkID8gZDEgOiBkMDtcbiAgICB9IGVsc2UgaWYgKHggPiByTWF4KSB7XG4gICAgICByZXR1cm4gaXNSZXZlcnNlZCA/IGQwIDogZDE7XG4gICAgfSBlbHNlIGlmIChyMCA9PT0gcjEpIHtcbiAgICAgIGQgPSB0aGlzLnRvRG9tYWluKChOdW1iZXIoZDApICsgTnVtYmVyKGQxKSkgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHRoaXMudG9Eb21haW4oTnVtYmVyKGQwKSArICh4IC0gcjApIC8gKHIxIC0gcjApICogKE51bWJlcihkMSkgLSBOdW1iZXIoZDApKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUludmVydChkKTtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5pbnZhbGlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiRXhwZWN0ZWQgdXBkYXRlIHRvIG5vdCBpbnZhbGlkYXRlIHNjYWxlXCIpO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbFJhbmdlKCkge1xuICAgIGNvbnN0IFthLCBiXSA9IHRoaXMucmFuZ2U7XG4gICAgcmV0dXJuIE1hdGguYWJzKGIgLSBhKTtcbiAgfVxufTtcbl9Db250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCA9IDU7XG5fQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQgPSA2O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJuaWNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwidGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJtaW5UaWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcIm1heFRpY2tDb3VudFwiLCAyKTtcbnZhciBDb250aW51b3VzU2NhbGUgPSBfQ29udGludW91c1NjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL251bWJlckZvcm1hdC50c1xuZnVuY3Rpb24gcGFyc2VGb3JtYXQoZm9ybWF0KSB7XG4gIGxldCBwcmVmaXg7XG4gIGxldCBzdWZmaXg7XG4gIGNvbnN0IHN1cnJvdW5kZWQgPSBzdXJyb3VuZGVkUmVnRXguZXhlYyhmb3JtYXQpO1xuICBpZiAoc3Vycm91bmRlZCkge1xuICAgIFssIHByZWZpeCwgZm9ybWF0LCBzdWZmaXhdID0gc3Vycm91bmRlZDtcbiAgfVxuICBjb25zdCBtYXRjaCA9IGZvcm1hdFJlZ0V4LmV4ZWMoZm9ybWF0KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG51bWJlciBmb3JtYXR0ZXIgaXMgaW52YWxpZDogJHtmb3JtYXR9YCk7XG4gIH1cbiAgY29uc3QgWywgZmlsbCwgYWxpZ24sIHNpZ24sIHN5bWJvbCwgemVybywgd2lkdGgsIGNvbW1hLCBwcmVjaXNpb24sIHRyaW0sIHR5cGVdID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgZmlsbCxcbiAgICBhbGlnbixcbiAgICBzaWduLFxuICAgIHN5bWJvbCxcbiAgICB6ZXJvLFxuICAgIHdpZHRoOiBwYXJzZUludCh3aWR0aCksXG4gICAgY29tbWEsXG4gICAgcHJlY2lzaW9uOiBwYXJzZUludChwcmVjaXNpb24pLFxuICAgIHRyaW06IEJvb2xlYW4odHJpbSksXG4gICAgdHlwZSxcbiAgICBwcmVmaXgsXG4gICAgc3VmZml4XG4gIH07XG59XG5mdW5jdGlvbiBudW1iZXJGb3JtYXQoZm9ybWF0KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiID8gcGFyc2VGb3JtYXQoZm9ybWF0KSA6IGZvcm1hdDtcbiAgY29uc3QgeyBmaWxsLCBhbGlnbiwgc2lnbiA9IFwiLVwiLCBzeW1ib2wsIHplcm8sIHdpZHRoLCBjb21tYSwgdHlwZSwgcHJlZml4ID0gXCJcIiwgc3VmZml4ID0gXCJcIiwgcHJlY2lzaW9uIH0gPSBvcHRpb25zO1xuICBsZXQgeyB0cmltIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVjaXNpb25Jc05hTiA9IHByZWNpc2lvbiA9PSBudWxsIHx8IGlzTmFOKHByZWNpc2lvbik7XG4gIGxldCBmb3JtYXRCb2R5O1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3JtYXRCb2R5ID0gZGVjaW1hbFR5cGVzW1wiZ1wiXTtcbiAgICB0cmltID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlIGluIGRlY2ltYWxUeXBlcyAmJiB0eXBlIGluIGludGVnZXJUeXBlcykge1xuICAgIGZvcm1hdEJvZHkgPSBwcmVjaXNpb25Jc05hTiA/IGludGVnZXJUeXBlc1t0eXBlXSA6IGRlY2ltYWxUeXBlc1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluIGRlY2ltYWxUeXBlcykge1xuICAgIGZvcm1hdEJvZHkgPSBkZWNpbWFsVHlwZXNbdHlwZV07XG4gIH0gZWxzZSBpZiAodHlwZSBpbiBpbnRlZ2VyVHlwZXMpIHtcbiAgICBmb3JtYXRCb2R5ID0gaW50ZWdlclR5cGVzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG51bWJlciBmb3JtYXR0ZXIgdHlwZSBpcyBpbnZhbGlkOiAke3R5cGV9YCk7XG4gIH1cbiAgbGV0IGZvcm1hdHRlclByZWNpc2lvbjtcbiAgaWYgKHByZWNpc2lvbiA9PSBudWxsIHx8IHByZWNpc2lvbklzTmFOKSB7XG4gICAgZm9ybWF0dGVyUHJlY2lzaW9uID0gdHlwZSA/IDYgOiAxMjtcbiAgfSBlbHNlIHtcbiAgICBmb3JtYXR0ZXJQcmVjaXNpb24gPSBwcmVjaXNpb247XG4gIH1cbiAgcmV0dXJuIChuKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGZvcm1hdEJvZHkobiwgZm9ybWF0dGVyUHJlY2lzaW9uKTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgcmVzdWx0ID0gcmVtb3ZlVHJhaWxpbmdaZXJvcyhyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoY29tbWEpIHtcbiAgICAgIHJlc3VsdCA9IGluc2VydFNlcGFyYXRvcihyZXN1bHQsIGNvbW1hKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gYWRkU2lnbihuLCByZXN1bHQsIHNpZ24pO1xuICAgIGlmIChzeW1ib2wgJiYgc3ltYm9sICE9PSBcIiNcIikge1xuICAgICAgcmVzdWx0ID0gYCR7c3ltYm9sfSR7cmVzdWx0fWA7XG4gICAgfVxuICAgIGlmIChzeW1ib2wgPT09IFwiI1wiICYmIHR5cGUgPT09IFwieFwiKSB7XG4gICAgICByZXN1bHQgPSBgMHgke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJzXCIpIHtcbiAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdH0ke2dldFNJUHJlZml4KG4pfWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIiVcIiB8fCB0eXBlID09PSBcInBcIikge1xuICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSVgO1xuICAgIH1cbiAgICBpZiAod2lkdGggIT0gbnVsbCAmJiAhaXNOYU4od2lkdGgpKSB7XG4gICAgICByZXN1bHQgPSBhZGRQYWRkaW5nKHJlc3VsdCwgd2lkdGgsIGZpbGwgPz8gemVybywgYWxpZ24pO1xuICAgIH1cbiAgICByZXN1bHQgPSBgJHtwcmVmaXh9JHtyZXN1bHR9JHtzdWZmaXh9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxudmFyIGZvcm1hdFJlZ0V4ID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLSggXSk/KFsk4oKswqPCpeKCo+KCuSNdKT8oMCk/KFxcZCspPygsKT8oPzpcXC4oXFxkKykpPyh+KT8oWyVhLXpdKT8kL2k7XG52YXIgc3Vycm91bmRlZFJlZ0V4ID0gL14oKD86W14jXXwjW157XSkqKSN7KFtefV0rKX0oLiopJC87XG52YXIgaW50ZWdlclR5cGVzID0ge1xuICBiOiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoMiksXG4gIGM6IChuKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pLFxuICBkOiAobikgPT4gTWF0aC5yb3VuZChNYXRoLmFicyhuKSkudG9GaXhlZCgwKSxcbiAgbzogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDgpLFxuICB4OiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoMTYpLFxuICBYOiAobikgPT4gaW50ZWdlclR5cGVzLngobikudG9VcHBlckNhc2UoKSxcbiAgbjogKG4pID0+IGludGVnZXJUeXBlcy5kKG4pLFxuICBcIiVcIjogKG4pID0+IGAke2Fic0Zsb29yKG4gKiAxMDApLnRvRml4ZWQoMCl9YFxufTtcbnZhciBkZWNpbWFsVHlwZXMgPSB7XG4gIGU6IChuLCBmKSA9PiBNYXRoLmFicyhuKS50b0V4cG9uZW50aWFsKGYpLFxuICBFOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmUobiwgZikudG9VcHBlckNhc2UoKSxcbiAgZjogKG4sIGYpID0+IE1hdGguYWJzKG4pLnRvRml4ZWQoZiksXG4gIEY6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuLCBmKS50b1VwcGVyQ2FzZSgpLFxuICBnOiAobiwgZikgPT4ge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcbiAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcbiAgICBpZiAocCA+PSAtNCAmJiBwIDwgZikge1xuICAgICAgcmV0dXJuIGEudG9GaXhlZChmIC0gMSAtIHApO1xuICAgIH1cbiAgICByZXR1cm4gYS50b0V4cG9uZW50aWFsKGYgLSAxKTtcbiAgfSxcbiAgRzogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5nKG4sIGYpLnRvVXBwZXJDYXNlKCksXG4gIG46IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZyhuLCBmKSxcbiAgcDogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5yKG4gKiAxMDAsIGYpLFxuICByOiAobiwgZikgPT4ge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcbiAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcbiAgICBjb25zdCBxID0gcCAtIChmIC0gMSk7XG4gICAgaWYgKHEgPD0gMCkge1xuICAgICAgcmV0dXJuIGEudG9GaXhlZCgtcSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSAxMCAqKiBxO1xuICAgIHJldHVybiAoTWF0aC5yb3VuZChhIC8geCkgKiB4KS50b0ZpeGVkKCk7XG4gIH0sXG4gIHM6IChuLCBmKSA9PiB7XG4gICAgY29uc3QgcCA9IGdldFNJUHJlZml4UG93ZXIobik7XG4gICAgcmV0dXJuIGRlY2ltYWxUeXBlcy5yKG4gLyAxMCAqKiBwLCBmKTtcbiAgfSxcbiAgXCIlXCI6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuICogMTAwLCBmKVxufTtcbnZhciBtaW5TSVByZWZpeCA9IC0yNDtcbnZhciBtYXhTSVByZWZpeCA9IDI0O1xudmFyIHNpUHJlZml4ZXMgPSB7XG4gIFttaW5TSVByZWZpeF06IFwieVwiLFxuICBbLTIxXTogXCJ6XCIsXG4gIFstMThdOiBcImFcIixcbiAgWy0xNV06IFwiZlwiLFxuICBbLTEyXTogXCJwXCIsXG4gIFstOV06IFwiblwiLFxuICBbLTZdOiBcIlxceEI1XCIsXG4gIFstM106IFwibVwiLFxuICBbMF06IFwiXCIsXG4gIFszXTogXCJrXCIsXG4gIFs2XTogXCJNXCIsXG4gIFs5XTogXCJHXCIsXG4gIFsxMl06IFwiVFwiLFxuICBbMTVdOiBcIlBcIixcbiAgWzE4XTogXCJFXCIsXG4gIFsyMV06IFwiWlwiLFxuICBbbWF4U0lQcmVmaXhdOiBcIllcIlxufTtcbnZhciBtaW51c1NpZ24gPSBcIlxcdTIyMTJcIjtcbmZ1bmN0aW9uIGFic0Zsb29yKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdaZXJvcyhudW1TdHJpbmcpIHtcbiAgcmV0dXJuIG51bVN0cmluZy5yZXBsYWNlKC9cXC4wKyQvLCBcIlwiKS5yZXBsYWNlKC8oXFwuWzEtOV0pMCskLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGluc2VydFNlcGFyYXRvcihudW1TdHJpbmcsIHNlcGFyYXRvcikge1xuICBsZXQgZG90SW5kZXggPSBudW1TdHJpbmcuaW5kZXhPZihcIi5cIik7XG4gIGlmIChkb3RJbmRleCA8IDApIHtcbiAgICBkb3RJbmRleCA9IG51bVN0cmluZy5sZW5ndGg7XG4gIH1cbiAgY29uc3QgaW50ZWdlckNoYXJzID0gbnVtU3RyaW5nLnN1YnN0cmluZygwLCBkb3RJbmRleCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGZyYWN0aW9uYWxQYXJ0ID0gbnVtU3RyaW5nLnN1YnN0cmluZyhkb3RJbmRleCk7XG4gIGZvciAobGV0IGkgPSBpbnRlZ2VyQ2hhcnMubGVuZ3RoIC0gMzsgaSA+IDA7IGkgLT0gMykge1xuICAgIGludGVnZXJDaGFycy5zcGxpY2UoaSwgMCwgc2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gYCR7aW50ZWdlckNoYXJzLmpvaW4oXCJcIil9JHtmcmFjdGlvbmFsUGFydH1gO1xufVxuZnVuY3Rpb24gZ2V0U0lQcmVmaXgobikge1xuICByZXR1cm4gc2lQcmVmaXhlc1tnZXRTSVByZWZpeFBvd2VyKG4pXTtcbn1cbmZ1bmN0aW9uIGdldFNJUHJlZml4UG93ZXIobikge1xuICByZXR1cm4gY2xhbXAobWluU0lQcmVmaXgsIG4gPyBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnMobikpIC8gMykgKiAzIDogMCwgbWF4U0lQcmVmaXgpO1xufVxuZnVuY3Rpb24gYWRkU2lnbihudW0sIG51bVN0cmluZywgc2lnblR5cGUgPSBcIlwiKSB7XG4gIGlmIChzaWduVHlwZSA9PT0gXCIoXCIpIHtcbiAgICByZXR1cm4gbnVtID49IDAgPyBudW1TdHJpbmcgOiBgKCR7bnVtU3RyaW5nfSlgO1xuICB9XG4gIGNvbnN0IHBsdXNTaWduID0gc2lnblR5cGUgPT09IFwiK1wiID8gXCIrXCIgOiBcIlwiO1xuICByZXR1cm4gYCR7bnVtID49IDAgPyBwbHVzU2lnbiA6IG1pbnVzU2lnbn0ke251bVN0cmluZ31gO1xufVxuZnVuY3Rpb24gYWRkUGFkZGluZyhudW1TdHJpbmcsIHdpZHRoLCBmaWxsID0gXCIgXCIsIGFsaWduID0gXCI+XCIpIHtcbiAgbGV0IHJlc3VsdCA9IG51bVN0cmluZztcbiAgaWYgKGFsaWduID09PSBcIj5cIiB8fCAhYWxpZ24pIHtcbiAgICByZXN1bHQgPSByZXN1bHQucGFkU3RhcnQod2lkdGgsIGZpbGwpO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIjxcIikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRFbmQod2lkdGgsIGZpbGwpO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIl5cIikge1xuICAgIGNvbnN0IHBhZFdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSByZXN1bHQubGVuZ3RoKTtcbiAgICBjb25zdCBwYWRMZWZ0ID0gTWF0aC5jZWlsKHBhZFdpZHRoIC8gMik7XG4gICAgY29uc3QgcGFkUmlnaHQgPSBNYXRoLmZsb29yKHBhZFdpZHRoIC8gMik7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZFN0YXJ0KHBhZExlZnQgKyByZXN1bHQubGVuZ3RoLCBmaWxsKTtcbiAgICByZXN1bHQgPSByZXN1bHQucGFkRW5kKHBhZFJpZ2h0ICsgcmVzdWx0Lmxlbmd0aCwgZmlsbCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hcnJheS50c1xuZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2syKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goY2FsbGJhY2syKGkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG1pbiA9IEluZmluaXR5O1xuICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICBmb3IgKGxldCBuIG9mIHZhbHVlcykge1xuICAgIGlmIChuIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgbiA9IG4uZ2V0VGltZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobiA8IG1pbikge1xuICAgICAgbWluID0gbjtcbiAgICB9XG4gICAgaWYgKG4gPiBtYXgpIHtcbiAgICAgIG1heCA9IG47XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFttaW4sIG1heF07XG4gIGlmIChyZXN1bHQuZXZlcnkoaXNGaW5pdGUpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXNlZEV4dGVudChkLCBtaW4sIG1heCkge1xuICByZXR1cm4gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCkuZXh0ZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCkge1xuICBsZXQgY2xpcHBlZCA9IGZhbHNlO1xuICBpZiAoZC5sZW5ndGggPiAyKSB7XG4gICAgZCA9IGV4dGVudChkKSA/PyBbTmFOLCBOYU5dO1xuICB9XG4gIGlmICghaXNOYU4obWluKSkge1xuICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtaW4gPiBkWzBdKTtcbiAgICBkID0gW21pbiwgZFsxXV07XG4gIH1cbiAgaWYgKCFpc05hTihtYXgpKSB7XG4gICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1heCA8IGRbMV0pO1xuICAgIGQgPSBbZFswXSwgbWF4XTtcbiAgfVxuICBpZiAoZFswXSA+IGRbMV0pIHtcbiAgICBkID0gW107XG4gIH1cbiAgcmV0dXJuIHsgZXh0ZW50OiBkLCBjbGlwcGVkIH07XG59XG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ldKSAmJiBBcnJheS5pc0FycmF5KGJbaV0pKSB7XG4gICAgICBpZiAoIWFycmF5c0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdW5pcXVlKGFycmF5Mikge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5MikpO1xufVxuZnVuY3Rpb24gZ3JvdXBCeShhcnJheTIsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBhcnJheTIucmVkdWNlKChyZXN1bHQsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBncm91cEtleSA9IGl0ZXJhdGVlKGl0ZW0pO1xuICAgIHJlc3VsdFtncm91cEtleV0gPz8gKHJlc3VsdFtncm91cEtleV0gPSBbXSk7XG4gICAgcmVzdWx0W2dyb3VwS2V5XS5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNpcmN1bGFyU2xpY2VBcnJheShkYXRhLCBzaXplLCBvZmZzZXQ0ID0gMCkge1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goZGF0YS5hdCgoaSArIG9mZnNldDQpICUgZGF0YS5sZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmlmdXJjYXRlKGlzTGVmdCwgYXJyYXkyKSB7XG4gIHJldHVybiBhcnJheTIucmVkdWNlKFxuICAgIChbbGVmdCwgcmlnaHRdLCB2YWx1ZSkgPT4gaXNMZWZ0KHZhbHVlKSA/IFtbLi4ubGVmdCwgdmFsdWVdLCByaWdodF0gOiBbbGVmdCwgWy4uLnJpZ2h0LCB2YWx1ZV1dLFxuICAgIFtbXSwgW11dXG4gICk7XG59XG5mdW5jdGlvbiogbWFwSXRlcmFibGUoc3JjLCBwcmVkaWNhdGUpIHtcbiAgZm9yIChjb25zdCBlIG9mIHNyYykge1xuICAgIHlpZWxkIHByZWRpY2F0ZShlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29uc3RTdHJpbmdzSW5jbHVkZXMoYXJyYXkyLCB2YWx1ZSkge1xuICBjb25zdCBjYXN0aW5nID0gYXJyYXkyO1xuICByZXR1cm4gY2FzdGluZy5pbmNsdWRlcyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0luU3RyaW5nVW5pb24odW5pb25WYWx1ZXMsIHZhbHVlKSB7XG4gIHJldHVybiBjb25zdFN0cmluZ3NJbmNsdWRlcyh1bmlvblZhbHVlcywgdmFsdWUpO1xufVxuZnVuY3Rpb24gYWxsSW5TdHJpbmdVbmlvbih1bmlvblZhbHVlcywgdmFsdWVzKSB7XG4gIHJldHVybiAhdmFsdWVzLnNvbWUoKHYpID0+ICFpc0luU3RyaW5nVW5pb24odW5pb25WYWx1ZXMsIHYpKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aWNrcy50c1xudmFyIHRJbnRlcnZhbCA9ICh0aW1lSW50ZXJ2YWwsIGJhc2VEdXJhdGlvbiwgc3RlcCkgPT4gKHtcbiAgZHVyYXRpb246IGJhc2VEdXJhdGlvbiAqIHN0ZXAsXG4gIHRpbWVJbnRlcnZhbCxcbiAgc3RlcFxufSk7XG52YXIgVGlja0ludGVydmFscyA9IFtcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgMSksXG4gIHRJbnRlcnZhbChzZWNvbmRfZGVmYXVsdCwgZHVyYXRpb25TZWNvbmQsIDUpLFxuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCAxNSksXG4gIHRJbnRlcnZhbChzZWNvbmRfZGVmYXVsdCwgZHVyYXRpb25TZWNvbmQsIDMwKSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgMSksXG4gIHRJbnRlcnZhbChtaW51dGVfZGVmYXVsdCwgZHVyYXRpb25NaW51dGUsIDUpLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCAxNSksXG4gIHRJbnRlcnZhbChtaW51dGVfZGVmYXVsdCwgZHVyYXRpb25NaW51dGUsIDMwKSxcbiAgdEludGVydmFsKGhvdXJfZGVmYXVsdCwgZHVyYXRpb25Ib3VyLCAxKSxcbiAgdEludGVydmFsKGhvdXJfZGVmYXVsdCwgZHVyYXRpb25Ib3VyLCAzKSxcbiAgdEludGVydmFsKGhvdXJfZGVmYXVsdCwgZHVyYXRpb25Ib3VyLCA2KSxcbiAgdEludGVydmFsKGhvdXJfZGVmYXVsdCwgZHVyYXRpb25Ib3VyLCAxMiksXG4gIHRJbnRlcnZhbChkYXlfZGVmYXVsdCwgZHVyYXRpb25EYXksIDEpLFxuICB0SW50ZXJ2YWwoZGF5X2RlZmF1bHQsIGR1cmF0aW9uRGF5LCAyKSxcbiAgdEludGVydmFsKHdlZWtfZGVmYXVsdCwgZHVyYXRpb25XZWVrLCAxKSxcbiAgdEludGVydmFsKHdlZWtfZGVmYXVsdCwgZHVyYXRpb25XZWVrLCAyKSxcbiAgdEludGVydmFsKHdlZWtfZGVmYXVsdCwgZHVyYXRpb25XZWVrLCAzKSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDEpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgMiksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCAzKSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDQpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgNiksXG4gIHRJbnRlcnZhbCh5ZWFyX2RlZmF1bHQsIGR1cmF0aW9uWWVhciwgMSlcbl07XG52YXIgVGlja011bHRpcGxpZXJzID0gWzEsIDIsIDUsIDEwXTtcbmZ1bmN0aW9uIGNyZWF0ZVRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSB7XG4gIGlmIChjb3VudCA8IDIpIHtcbiAgICByZXR1cm4gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0b3AgLSBzdGFydCk7XG4gIH1cbiAgY29uc3Qgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KTtcbiAgaWYgKGlzTmFOKHN0ZXApKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICByZXR1cm4gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApO1xufVxuZnVuY3Rpb24gZ2V0VGlja0ludGVydmFsKHN0YXJ0LCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50LCB0YXJnZXRJbnRlcnZhbCkge1xuICBjb25zdCB0YXJnZXQgPSB0YXJnZXRJbnRlcnZhbCA/PyBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoY291bnQsIDEpO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgdGlja0ludGVydmFsIG9mIFRpY2tJbnRlcnZhbHMpIHtcbiAgICBpZiAodGFyZ2V0IDw9IHRpY2tJbnRlcnZhbC5kdXJhdGlvbilcbiAgICAgIGJyZWFrO1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIGNvbnN0IHN0ZXAyID0gTWF0aC5tYXgodGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQpLCAxKTtcbiAgICByZXR1cm4gbWlsbGlzZWNvbmRfZGVmYXVsdC5ldmVyeShzdGVwMik7XG4gIH0gZWxzZSBpZiAoaSA9PT0gVGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICBjb25zdCBzdGVwMiA9IHRhcmdldEludGVydmFsID09IG51bGwgPyB0aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCkgOiAxO1xuICAgIHJldHVybiB5ZWFyX2RlZmF1bHQuZXZlcnkoc3RlcDIpO1xuICB9XG4gIGNvbnN0IGkwID0gVGlja0ludGVydmFsc1tpIC0gMV07XG4gIGNvbnN0IGkxID0gVGlja0ludGVydmFsc1tpXTtcbiAgY29uc3QgeyB0aW1lSW50ZXJ2YWwsIHN0ZXAgfSA9IHRhcmdldCAtIGkwLmR1cmF0aW9uIDwgaTEuZHVyYXRpb24gLSB0YXJnZXQgPyBpMCA6IGkxO1xuICByZXR1cm4gdGltZUludGVydmFsLmV2ZXJ5KHN0ZXApO1xufVxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIGVuZCwgY291bnQsIG1pbkNvdW50ID0gMCwgbWF4Q291bnQgPSBJbmZpbml0eSkge1xuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGNvbnN0IGV4dGVudDIgPSBNYXRoLmFicyhlbmQgLSBzdGFydCk7XG4gIGNvbnN0IHN0ZXAgPSAxMCAqKiBNYXRoLmZsb29yKE1hdGgubG9nMTAoZXh0ZW50MiAvIGNvdW50KSk7XG4gIGxldCBtID0gTmFOLCBtaW5EaWZmID0gSW5maW5pdHksIGlzSW5Cb3VuZHMgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBtdWx0aXBsaWVyIG9mIFRpY2tNdWx0aXBsaWVycykge1xuICAgIGNvbnN0IGMgPSBNYXRoLmNlaWwoZXh0ZW50MiAvIChtdWx0aXBsaWVyICogc3RlcCkpO1xuICAgIGNvbnN0IHZhbGlkQm91bmRzID0gYyA+PSBtaW5Db3VudCAmJiBjIDw9IG1heENvdW50O1xuICAgIGlmIChpc0luQm91bmRzICYmICF2YWxpZEJvdW5kcylcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGRpZmZDb3VudCA9IE1hdGguYWJzKGMgLSBjb3VudCk7XG4gICAgaWYgKG1pbkRpZmYgPiBkaWZmQ291bnQgfHwgaXNJbkJvdW5kcyAhPT0gdmFsaWRCb3VuZHMpIHtcbiAgICAgIGlzSW5Cb3VuZHMgfHwgKGlzSW5Cb3VuZHMgPSB2YWxpZEJvdW5kcyk7XG4gICAgICBtaW5EaWZmID0gZGlmZkNvdW50O1xuICAgICAgbSA9IG11bHRpcGxpZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiBtICogc3RlcDtcbn1cbmZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMoZGVjaW1hbCkge1xuICBmb3IgKGxldCBpID0gZGVjaW1hbC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgIGlmIChkZWNpbWFsW2ldICE9PSBcIjBcIikge1xuICAgICAgcmV0dXJuIGkgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHRpY2tGb3JtYXQodGlja3MsIGZvcm1hdCkge1xuICBjb25zdCBvcHRpb25zID0gcGFyc2VGb3JtYXQoZm9ybWF0ID8/IFwiLGZcIik7XG4gIGlmIChvcHRpb25zLnByZWNpc2lvbiA9PSBudWxsIHx8IGlzTmFOKG9wdGlvbnMucHJlY2lzaW9uKSkge1xuICAgIGlmICghb3B0aW9ucy50eXBlIHx8IFwiZUVGZ0ducHJzXCIuaW5jbHVkZXMob3B0aW9ucy50eXBlKSkge1xuICAgICAgb3B0aW9ucy5wcmVjaXNpb24gPSBNYXRoLm1heChcbiAgICAgICAgLi4udGlja3MubWFwKCh4KSA9PiB7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjb25zdCBbaW50ZWdlciwgZGVjaW1hbF0gPSB4LnRvRXhwb25lbnRpYWwoKG9wdGlvbnMudHlwZSA/IDYgOiAxMikgLSAxKS5zcGxpdCgvXFwufGUvZyk7XG4gICAgICAgICAgcmV0dXJuIChpbnRlZ2VyICE9PSBcIjFcIiAmJiBpbnRlZ2VyICE9PSBcIi0xXCIgPyAxIDogMCkgKyBkZWNpbWFsUGxhY2VzKGRlY2ltYWwpICsgMTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChcImYlXCIuaW5jbHVkZXMob3B0aW9ucy50eXBlKSkge1xuICAgICAgb3B0aW9ucy5wcmVjaXNpb24gPSBNYXRoLm1heChcbiAgICAgICAgLi4udGlja3MubWFwKCh4KSA9PiB7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgeCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNvbnN0IGwgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnMoeCkpKTtcbiAgICAgICAgICBjb25zdCBkaWdpdHMgPSBvcHRpb25zLnR5cGUgPyA2IDogMTI7XG4gICAgICAgICAgY29uc3QgW19pbnRlZ2VyLCBkZWNpbWFsXSA9IHgudG9FeHBvbmVudGlhbChkaWdpdHMgLSAxKS5zcGxpdCgvXFwufGUvZyk7XG4gICAgICAgICAgY29uc3QgZGVjaW1hbExlbmd0aCA9IGRlY2ltYWxQbGFjZXMoZGVjaW1hbCk7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGRlY2ltYWxMZW5ndGggLSBsKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcm1hdHRlciA9IG51bWJlckZvcm1hdChvcHRpb25zKTtcbiAgcmV0dXJuIChuKSA9PiBmb3JtYXR0ZXIoTnVtYmVyKG4pKTtcbn1cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgY29uc3QgbiA9IE1hdGguY2VpbChNYXRoLmFicyhlbmQgLSBzdGFydCkgLyBzdGVwKTtcbiAgY29uc3QgZiA9IDEwICoqIGNvdW50RnJhY3Rpb25EaWdpdHMoc3RlcCk7XG4gIGNvbnN0IGQwID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XG4gIHJldHVybiB0aW1lcyhuICsgMSwgKGkpID0+IE1hdGgucm91bmQoKGQwICsgc3RlcCAqIGkpICogZikgLyBmKTtcbn1cbmZ1bmN0aW9uIGlzRGVuc2VJbnRlcnZhbChjb3VudCwgYXZhaWxhYmxlUmFuZ2UpIHtcbiAgaWYgKGNvdW50ID49IGF2YWlsYWJsZVJhbmdlKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgYHRoZSBjb25maWd1cmVkIGludGVydmFsIHJlc3VsdHMgaW4gbW9yZSB0aGFuIDEgaXRlbSBwZXIgcGl4ZWwsIGlnbm9yaW5nLiBTdXBwbHkgYSBsYXJnZXIgaW50ZXJ2YWwgb3Igb21pdCB0aGlzIGNvbmZpZ3VyYXRpb25gXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBuaWNlVGlja3NEb21haW4oc3RhcnQsIGVuZCkge1xuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMoZW5kIC0gc3RhcnQpO1xuICBjb25zdCBzdGVwID0gMTAgKiogTWF0aC5mbG9vcihNYXRoLmxvZzEwKGV4dGVudDIpKTtcbiAgbGV0IG1pbkVycm9yID0gSW5maW5pdHksIHRpY2tzID0gW3N0YXJ0LCBlbmRdO1xuICBmb3IgKGNvbnN0IG11bHRpcGxpZXIgb2YgVGlja011bHRpcGxpZXJzKSB7XG4gICAgY29uc3QgbSA9IG11bHRpcGxpZXIgKiBzdGVwO1xuICAgIGNvbnN0IGQwID0gTWF0aC5mbG9vcihzdGFydCAvIG0pICogbTtcbiAgICBjb25zdCBkMSA9IE1hdGguY2VpbChlbmQgLyBtKSAqIG07XG4gICAgY29uc3QgZXJyb3IgPSAxIC0gZXh0ZW50MiAvIE1hdGguYWJzKGQxIC0gZDApO1xuICAgIGlmIChtaW5FcnJvciA+IGVycm9yKSB7XG4gICAgICBtaW5FcnJvciA9IGVycm9yO1xuICAgICAgdGlja3MgPSBbZDAsIGQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVUaWNrQ291bnQocmFuZ2VFeHRlbnQsIG1pblNwYWNpbmcsIG1heFNwYWNpbmcsIGRlZmF1bHRUaWNrQ291bnQsIGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gIGRlZmF1bHRNaW5TcGFjaW5nID0gTWF0aC5tYXgoZGVmYXVsdE1pblNwYWNpbmcsIHJhbmdlRXh0ZW50IC8gKGRlZmF1bHRUaWNrQ291bnQgKyAxKSk7XG4gIGlmIChpc05hTihtaW5TcGFjaW5nKSkge1xuICAgIG1pblNwYWNpbmcgPSBkZWZhdWx0TWluU3BhY2luZztcbiAgfVxuICBpZiAoaXNOYU4obWF4U3BhY2luZykpIHtcbiAgICBtYXhTcGFjaW5nID0gcmFuZ2VFeHRlbnQ7XG4gIH1cbiAgaWYgKG1pblNwYWNpbmcgPiBtYXhTcGFjaW5nKSB7XG4gICAgaWYgKG1pblNwYWNpbmcgPT09IGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gICAgICBtaW5TcGFjaW5nID0gbWF4U3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4U3BhY2luZyA9IG1pblNwYWNpbmc7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFRpY2tDb3VudCA9IGNsYW1wKDEsIE1hdGguZmxvb3IocmFuZ2VFeHRlbnQgLyBtaW5TcGFjaW5nKSwgTWF0aC5taW4oTWF0aC5mbG9vcihyYW5nZUV4dGVudCksIDEwMCkpO1xuICBjb25zdCBtaW5UaWNrQ291bnQgPSBNYXRoLm1pbihtYXhUaWNrQ291bnQsIE1hdGguY2VpbChyYW5nZUV4dGVudCAvIG1heFNwYWNpbmcpKTtcbiAgY29uc3QgdGlja0NvdW50ID0gY2xhbXAobWluVGlja0NvdW50LCBkZWZhdWx0VGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICByZXR1cm4geyBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCwgdGlja0NvdW50IH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2xvZ1NjYWxlLnRzXG52YXIgX0xvZ1NjYWxlID0gY2xhc3MgX0xvZ1NjYWxlIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoWzEsIDEwXSwgWzAsIDFdKTtcbiAgICB0aGlzLnR5cGUgPSBcImxvZ1wiO1xuICAgIHRoaXMuYmFzZSA9IDEwO1xuICAgIHRoaXMuYmFzZUxvZyA9IGlkZW50aXR5O1xuICAgIHRoaXMuYmFzZVBvdyA9IGlkZW50aXR5O1xuICAgIHRoaXMubG9nID0gKHgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgICAgcmV0dXJuIHN0YXJ0ID49IDAgPyB0aGlzLmJhc2VMb2coeCkgOiAtdGhpcy5iYXNlTG9nKC14KTtcbiAgICB9O1xuICAgIHRoaXMucG93ID0gKHgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgICAgcmV0dXJuIHN0YXJ0ID49IDAgPyB0aGlzLmJhc2VQb3coeCkgOiAtdGhpcy5iYXNlUG93KC14KTtcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdENsYW1wTW9kZSA9IFwiY2xhbXBlZFwiO1xuICB9XG4gIHRvRG9tYWluKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuICB0cmFuc2Zvcm0oeCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgIHJldHVybiBzdGFydCA+PSAwID8gTWF0aC5sb2coeCkgOiAtTWF0aC5sb2coLXgpO1xuICB9XG4gIHRyYW5zZm9ybUludmVydCh4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbiguLi50aGlzLmRvbWFpbik7XG4gICAgcmV0dXJuIHN0YXJ0ID49IDAgPyBNYXRoLmV4cCh4KSA6IC1NYXRoLmV4cCgteCk7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5iYXNlIDw9IDApIHtcbiAgICAgIHRoaXMuYmFzZSA9IDA7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJleHBlY3RpbmcgYSBmaW5pdGUgTnVtYmVyIGdyZWF0ZXIgdGhhbiB0byAwXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJhc2VMb2cgPSBfTG9nU2NhbGUuZ2V0QmFzZUxvZ01ldGhvZCh0aGlzLmJhc2UpO1xuICAgIHRoaXMuYmFzZVBvdyA9IF9Mb2dTY2FsZS5nZXRCYXNlUG93ZXJNZXRob2QodGhpcy5iYXNlKTtcbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW4oKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTmljZURvbWFpbigpIHtcbiAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xuICAgIGNvbnN0IHJvdW5kU3RhcnQgPSBkMCA+IGQxID8gTWF0aC5jZWlsIDogTWF0aC5mbG9vcjtcbiAgICBjb25zdCByb3VuZFN0b3AgPSBkMCA+IGQxID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbDtcbiAgICBjb25zdCBuMCA9IHRoaXMucG93KHJvdW5kU3RhcnQodGhpcy5sb2coZDApKSk7XG4gICAgY29uc3QgbjEgPSB0aGlzLnBvdyhyb3VuZFN0b3AodGhpcy5sb2coZDEpKSk7XG4gICAgdGhpcy5uaWNlRG9tYWluID0gW24wLCBuMV07XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRpY2tDb3VudCA/PyAxMDtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIgfHwgY291bnQgPCAxKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmdldERvbWFpbigpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oZDAsIGQxKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgoZDAsIGQxKTtcbiAgICBsZXQgcDAgPSB0aGlzLmxvZyhzdGFydCk7XG4gICAgbGV0IHAxID0gdGhpcy5sb2coc3RvcCk7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IGluQm91bmRzID0gKHRpY2spID0+IHRpY2sgPj0gc3RhcnQgJiYgdGljayA8PSBzdG9wO1xuICAgICAgY29uc3Qgc3RlcCA9IE1hdGgubWluKE1hdGguYWJzKHRoaXMuaW50ZXJ2YWwpLCBNYXRoLmFicyhwMSAtIHAwKSk7XG4gICAgICBjb25zdCB0aWNrczIgPSByYW5nZShwMCwgcDEsIHN0ZXApLm1hcCh0aGlzLnBvdykuZmlsdGVyKGluQm91bmRzKTtcbiAgICAgIGlmICghaXNEZW5zZUludGVydmFsKHRpY2tzMi5sZW5ndGgsIHRoaXMuZ2V0UGl4ZWxSYW5nZSgpKSkge1xuICAgICAgICByZXR1cm4gdGlja3MyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0Jhc2VJbnRlZ2VyID0gYmFzZSAlIDEgPT09IDA7XG4gICAgY29uc3QgaXNEaWZmTGFyZ2UgPSBwMSAtIHAwID49IGNvdW50O1xuICAgIGlmICghaXNCYXNlSW50ZWdlciB8fCBpc0RpZmZMYXJnZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpY2tzKHAwLCBwMSwgTWF0aC5taW4ocDEgLSBwMCwgY291bnQpKS5tYXAodGhpcy5wb3cpO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IGlzUG9zaXRpdmUgPSBzdGFydCA+IDA7XG4gICAgcDAgPSBNYXRoLmZsb29yKHAwKSAtIDE7XG4gICAgcDEgPSBNYXRoLnJvdW5kKHAxKSArIDE7XG4gICAgY29uc3QgYXZhaWxhYmxlU3BhY2luZyA9IGZpbmRSYW5nZUV4dGVudCh0aGlzLnJhbmdlKSAvIGNvdW50O1xuICAgIGxldCBsYXN0VGlja1Bvc2l0aW9uID0gSW5maW5pdHk7XG4gICAgZm9yIChsZXQgcCA9IHAwOyBwIDw9IHAxOyBwKyspIHtcbiAgICAgIGNvbnN0IG5leHRNYWduaXR1ZGVUaWNrUG9zaXRpb24gPSB0aGlzLmNvbnZlcnQodGhpcy5wb3cocCArIDEpKTtcbiAgICAgIGZvciAobGV0IGsgPSAxOyBrIDwgYmFzZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHEgPSBpc1Bvc2l0aXZlID8gayA6IGJhc2UgLSBrICsgMTtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMucG93KHApICogcTtcbiAgICAgICAgY29uc3QgdGlja1Bvc2l0aW9uID0gdGhpcy5jb252ZXJ0KHQpO1xuICAgICAgICBjb25zdCBwcmV2U3BhY2luZyA9IE1hdGguYWJzKGxhc3RUaWNrUG9zaXRpb24gLSB0aWNrUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBuZXh0U3BhY2luZyA9IE1hdGguYWJzKHRpY2tQb3NpdGlvbiAtIG5leHRNYWduaXR1ZGVUaWNrUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmaXRzID0gcHJldlNwYWNpbmcgPj0gYXZhaWxhYmxlU3BhY2luZyAmJiBuZXh0U3BhY2luZyA+PSBhdmFpbGFibGVTcGFjaW5nO1xuICAgICAgICBpZiAodCA+PSBzdGFydCAmJiB0IDw9IHN0b3AgJiYgKGsgPT09IDEgfHwgZml0cyB8fCB0aWNrcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgdGlja3MucHVzaCh0KTtcbiAgICAgICAgICBsYXN0VGlja1Bvc2l0aW9uID0gdGlja1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICB0aWNrRm9ybWF0KHtcbiAgICBjb3VudCxcbiAgICB0aWNrcyxcbiAgICBzcGVjaWZpZXJcbiAgfSkge1xuICAgIGlmIChjb3VudCAhPT0gSW5maW5pdHkgJiYgdGlja3MgPT0gbnVsbCkge1xuICAgICAgdGhpcy50aWNrcygpO1xuICAgIH1cbiAgICBzcGVjaWZpZXIgPz8gKHNwZWNpZmllciA9IHRoaXMuYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCIpO1xuICAgIHJldHVybiBpc1N0cmluZyhzcGVjaWZpZXIpID8gbnVtYmVyRm9ybWF0KHNwZWNpZmllcikgOiBzcGVjaWZpZXI7XG4gIH1cbiAgc3RhdGljIGdldEJhc2VMb2dNZXRob2QoYmFzZSkge1xuICAgIHN3aXRjaCAoYmFzZSkge1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMTA7XG4gICAgICBjYXNlIE1hdGguRTpcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gTWF0aC5sb2cyO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3QgbG9nQmFzZSA9IE1hdGgubG9nKGJhc2UpO1xuICAgICAgICByZXR1cm4gKHgpID0+IE1hdGgubG9nKHgpIC8gbG9nQmFzZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldEJhc2VQb3dlck1ldGhvZChiYXNlKSB7XG4gICAgc3dpdGNoIChiYXNlKSB7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gKHgpID0+IHggPj0gMCA/IDEwICoqIHggOiAxIC8gMTAgKiogLXg7XG4gICAgICBjYXNlIE1hdGguRTpcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICh4KSA9PiBiYXNlICoqIHg7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfTG9nU2NhbGUucHJvdG90eXBlLCBcImJhc2VcIiwgMik7XG52YXIgTG9nU2NhbGUgPSBfTG9nU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL3RpbWVTY2FsZS50c1xudmFyIFRpbWVTY2FsZSA9IGNsYXNzIF9UaW1lU2NhbGUgZXh0ZW5kcyBDb250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbXSwgWzAsIDFdKTtcbiAgICB0aGlzLnR5cGUgPSBcInRpbWVcIjtcbiAgfVxuICB0b0RvbWFpbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQpO1xuICB9XG4gIGNvbnZlcnQoeCwgb3B0cykge1xuICAgIHJldHVybiBzdXBlci5jb252ZXJ0KG5ldyBEYXRlKHgpLCBvcHRzKTtcbiAgfVxuICBpbnZlcnQoeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdXBlci5pbnZlcnQoeSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHVuaWZvcm1seS1zcGFjZWQgZGF0ZXMgdGhhdCByZXByZXNlbnQgdGhlIHNjYWxlJ3MgZG9tYWluLlxuICAgKi9cbiAgdGlja3MoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IHsgaW50ZXJ2YWwsIG5pY2UsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQgfSA9IHRoaXM7XG4gICAgY29uc3QgW3N0YXJ0LCBzdG9wXSA9IGZpbmRNaW5NYXgodGhpcy5nZXREb21haW4oKS5tYXAoZGF0ZVRvTnVtYmVyKSk7XG4gICAgaWYgKGludGVydmFsICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBfVGltZVNjYWxlLmdldFRpY2tzRm9ySW50ZXJ2YWwoeyBzdGFydCwgc3RvcCwgaW50ZXJ2YWwsIGF2YWlsYWJsZVJhbmdlOiB0aGlzLmdldFBpeGVsUmFuZ2UoKSB9KSA/PyBfVGltZVNjYWxlLmdldERlZmF1bHRUaWNrcyh7IHN0YXJ0LCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50IH0pO1xuICAgIH0gZWxzZSBpZiAobmljZSAmJiB0aWNrQ291bnQgPT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW47XG4gICAgfSBlbHNlIGlmIChuaWNlICYmIHRpY2tDb3VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMubmljZURvbWFpbi5zbGljZSgwLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIF9UaW1lU2NhbGUuZ2V0RGVmYXVsdFRpY2tzKHsgc3RhcnQsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQgfSk7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHRUaWNrcyh7XG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICB0aWNrQ291bnQsXG4gICAgbWluVGlja0NvdW50LFxuICAgIG1heFRpY2tDb3VudFxuICB9KSB7XG4gICAgY29uc3QgdCA9IGdldFRpY2tJbnRlcnZhbChzdGFydCwgc3RvcCwgdGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgcmV0dXJuIHQgPyB0LnJhbmdlKG5ldyBEYXRlKHN0YXJ0KSwgbmV3IERhdGUoc3RvcCkpIDogW107XG4gIH1cbiAgc3RhdGljIGdldFRpY2tzRm9ySW50ZXJ2YWwoe1xuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgaW50ZXJ2YWwsXG4gICAgYXZhaWxhYmxlUmFuZ2VcbiAgfSkge1xuICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGludGVydmFsIGluc3RhbmNlb2YgVGltZUludGVydmFsKSB7XG4gICAgICBjb25zdCB0aWNrczIgPSBpbnRlcnZhbC5yYW5nZShuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKHN0b3ApKTtcbiAgICAgIGlmIChpc0RlbnNlSW50ZXJ2YWwodGlja3MyLmxlbmd0aCwgYXZhaWxhYmxlUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrczI7XG4gICAgfVxuICAgIGNvbnN0IGFic0ludGVydmFsID0gTWF0aC5hYnMoaW50ZXJ2YWwpO1xuICAgIGlmIChpc0RlbnNlSW50ZXJ2YWwoKHN0b3AgLSBzdGFydCkgLyBhYnNJbnRlcnZhbCwgYXZhaWxhYmxlUmFuZ2UpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJldmVyc2VkSW50ZXJ2YWwgPSBbLi4uVGlja0ludGVydmFsc10ucmV2ZXJzZSgpO1xuICAgIGNvbnN0IHRpbWVJbnRlcnZhbCA9IHJldmVyc2VkSW50ZXJ2YWwuZmluZCgodGlja0ludGVydmFsKSA9PiBhYnNJbnRlcnZhbCAlIHRpY2tJbnRlcnZhbC5kdXJhdGlvbiA9PT0gMCk7XG4gICAgaWYgKHRpbWVJbnRlcnZhbCkge1xuICAgICAgY29uc3QgaSA9IHRpbWVJbnRlcnZhbC50aW1lSW50ZXJ2YWwuZXZlcnkoYWJzSW50ZXJ2YWwgLyAodGltZUludGVydmFsLmR1cmF0aW9uIC8gdGltZUludGVydmFsLnN0ZXApKTtcbiAgICAgIHJldHVybiBpLnJhbmdlKG5ldyBEYXRlKHN0YXJ0KSwgbmV3IERhdGUoc3RvcCkpO1xuICAgIH1cbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHN0YXJ0KTtcbiAgICBjb25zdCBzdG9wRGF0ZSA9IG5ldyBEYXRlKHN0b3ApO1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgd2hpbGUgKGRhdGUgPD0gc3RvcERhdGUpIHtcbiAgICAgIHRpY2tzLnB1c2goZGF0ZSk7XG4gICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpICsgYWJzSW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aW1lIGZvcm1hdCBmdW5jdGlvbiBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0aWNrIHZhbHVlcy5cbiAgICogQHBhcmFtIHNwZWNpZmllciBJZiB0aGUgc3BlY2lmaWVyIHN0cmluZyBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0b1xuICAgKiB0aGUge0BsaW5rIFRpbWVMb2NhbGVPYmplY3QuZm9ybWF0fSBtZXRob2QuXG4gICAqIElmIG5vIHNwZWNpZmllciBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZGVmYXVsdCB0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICovXG4gIHRpY2tGb3JtYXQoe1xuICAgIHRpY2tzLFxuICAgIGRvbWFpbixcbiAgICBzcGVjaWZpZXIsXG4gICAgZm9ybWF0T2Zmc2V0XG4gIH0pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyBkZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0KSA6IGJ1aWxkRm9ybWF0dGVyKHNwZWNpZmllcik7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW4oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIGRvbWFpbiBzbyB0aGF0IGl0IHN0YXJ0cyBhbmQgZW5kcyBvbiBuaWNlIHJvdW5kIHZhbHVlcy5cbiAgICogVGhpcyBtZXRob2QgdHlwaWNhbGx5IG1vZGlmaWVzIHRoZSBzY2FsZeKAmXMgZG9tYWluLCBhbmQgbWF5IG9ubHkgZXh0ZW5kIHRoZSBib3VuZHMgdG8gdGhlIG5lYXJlc3Qgcm91bmQgdmFsdWUuXG4gICAqL1xuICB1cGRhdGVOaWNlRG9tYWluKCkge1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNDtcbiAgICBsZXQgW2QwLCBkMV0gPSB0aGlzLmRvbWFpbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEF0dGVtcHRzOyBpKyspIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbkl0ZXJhdGlvbihkMCwgZDEpO1xuICAgICAgY29uc3QgW24wLCBuMV0gPSB0aGlzLm5pY2VEb21haW47XG4gICAgICBpZiAoZGF0ZVRvTnVtYmVyKGQwKSA9PT0gZGF0ZVRvTnVtYmVyKG4wKSAmJiBkYXRlVG9OdW1iZXIoZDEpID09PSBkYXRlVG9OdW1iZXIobjEpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZDAgPSBuMDtcbiAgICAgIGQxID0gbjE7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5pY2VEb21haW5JdGVyYXRpb24oZDAsIGQxKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihkYXRlVG9OdW1iZXIoZDApLCBkYXRlVG9OdW1iZXIoZDEpKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgoZGF0ZVRvTnVtYmVyKGQwKSwgZGF0ZVRvTnVtYmVyKGQxKSk7XG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IGQwID4gZDE7XG4gICAgY29uc3QgeyBpbnRlcnZhbCB9ID0gdGhpcztcbiAgICBsZXQgaTtcbiAgICBpZiAoaW50ZXJ2YWwgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGkgPSBpbnRlcnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGlja0NvdW50ID0gdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiID8gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heChpbnRlcnZhbCwgMSkgOiB0aGlzLnRpY2tDb3VudDtcbiAgICAgIGkgPSBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQsIHN0b3AsIHRpY2tDb3VudCwgdGhpcy5taW5UaWNrQ291bnQsIHRoaXMubWF4VGlja0NvdW50KTtcbiAgICB9XG4gICAgaWYgKGkpIHtcbiAgICAgIGNvbnN0IGludGVydmFsUmFuZ2UgPSBpLnJhbmdlKG5ldyBEYXRlKHN0YXJ0KSwgbmV3IERhdGUoc3RvcCksIHRydWUpO1xuICAgICAgY29uc3QgZG9tYWluID0gaXNSZXZlcnNlZCA/IFsuLi5pbnRlcnZhbFJhbmdlXS5yZXZlcnNlKCkgOiBpbnRlcnZhbFJhbmdlO1xuICAgICAgY29uc3QgbjAgPSBkb21haW5bMF07XG4gICAgICBjb25zdCBuMSA9IGRvbWFpbi5hdCgtMSk7XG4gICAgICB0aGlzLm5pY2VEb21haW4gPSBbbjAsIG4xXTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL29yZGluYWxUaW1lU2NhbGUudHNcbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxudmFyIF9PcmRpbmFsVGltZVNjYWxlID0gY2xhc3MgX09yZGluYWxUaW1lU2NhbGUgZXh0ZW5kcyBCYW5kU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwib3JkaW5hbC10aW1lXCI7XG4gICAgdGhpcy50aWNrQ291bnQgPSBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcbiAgICB0aGlzLm1pblRpY2tDb3VudCA9IDA7XG4gICAgdGhpcy5tYXhUaWNrQ291bnQgPSBJbmZpbml0eTtcbiAgICB0aGlzLmludGVydmFsID0gdm9pZCAwO1xuICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgIHRoaXMudGltZXN0YW1wcyA9IFtdO1xuICAgIHRoaXMuc29ydGVkVGltZXN0YW1wcyA9IFtdO1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gWzAsIDFdO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9PcmRpbmFsVGltZVNjYWxlO1xuICB9XG4gIHNldFZpc2libGVSYW5nZSh2aXNpYmxlUmFuZ2UpIHtcbiAgICB0aGlzLnZpc2libGVSYW5nZSA9IHZpc2libGVSYW5nZTtcbiAgfVxuICBzZXQgZG9tYWluKHZhbHVlcykge1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb21haW4gPSB2YWx1ZXM7XG4gICAgdGhpcy50aW1lc3RhbXBzID0gdW5pcXVlKHZhbHVlcy5tYXAoZGF0ZVRvTnVtYmVyKSk7XG4gICAgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzID0gdGhpcy50aW1lc3RhbXBzLnNsaWNlKCkuc29ydChjb21wYXJlTnVtYmVycyk7XG4gIH1cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIHRpY2tzKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IFt0MCwgdDFdID0gW3RoaXMudGltZXN0YW1wc1swXSwgdGhpcy50aW1lc3RhbXBzLmF0KC0xKV07XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbih0MCwgdDEpO1xuICAgIGNvbnN0IHN0b3AgPSBNYXRoLm1heCh0MCwgdDEpO1xuICAgIGNvbnN0IGlzUmV2ZXJzZWQgPSB0MCA+IHQxO1xuICAgIGxldCB0aWNrcztcbiAgICBpZiAodGhpcy5pbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICB0aWNrcyA9IHRoaXMuZ2V0RGVmYXVsdFRpY2tzKHRoaXMubWF4VGlja0NvdW50LCBpc1JldmVyc2VkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3IwLCByMV0gPSB0aGlzLnJhbmdlO1xuICAgICAgY29uc3QgYXZhaWxhYmxlUmFuZ2UgPSBNYXRoLmFicyhyMSAtIHIwKTtcbiAgICAgIHRpY2tzID0gVGltZVNjYWxlLmdldFRpY2tzRm9ySW50ZXJ2YWwoeyBzdGFydCwgc3RvcCwgaW50ZXJ2YWw6IHRoaXMuaW50ZXJ2YWwsIGF2YWlsYWJsZVJhbmdlIH0pID8/IFtdO1xuICAgIH1cbiAgICBjb25zdCB0aWNrUG9zaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gdGlja3MuZmlsdGVyKCh0aWNrKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY29udmVydCh0aWNrKTtcbiAgICAgIGlmIChpc05hTihwb3NpdGlvbikgfHwgdGlja1Bvc2l0aW9ucy5oYXMocG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRpY2tQb3NpdGlvbnMuYWRkKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGdldERlZmF1bHRUaWNrcyhtYXhUaWNrQ291bnQsIGlzUmV2ZXJzZWQpIHtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aW1lc3RhbXBzLmxlbmd0aDtcbiAgICBjb25zdCB0aWNrRXZlcnkgPSBNYXRoLmNlaWwoY291bnQgKiAodGhpcy52aXNpYmxlUmFuZ2VbMV0gLSB0aGlzLnZpc2libGVSYW5nZVswXSkgLyBtYXhUaWNrQ291bnQpO1xuICAgIGNvbnN0IHRpY2tPZmZzZXQgPSBNYXRoLmZsb29yKHRpY2tFdmVyeSAvIDIpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCB2YWx1ZV0gb2YgdGhpcy50aW1lc3RhbXBzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHRpY2tFdmVyeSA+IDAgJiYgKGluZGV4ICsgdGlja09mZnNldCkgJSB0aWNrRXZlcnkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgdGlja3MucHVzaChuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcHNbY291bnQgLSBpbmRleCAtIDFdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrcy5wdXNoKG5ldyBEYXRlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb252ZXJ0KGQpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBuID0gTnVtYmVyKGQpO1xuICAgIGlmIChuIDwgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzWzBdKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBsZXQgaSA9IHRoaXMuZmluZEludGVydmFsKG4pO1xuICAgIGlmICh0aGlzLnRpbWVzdGFtcHNbMF0gIT09IHRoaXMuc29ydGVkVGltZXN0YW1wc1swXSkge1xuICAgICAgaSA9IHRoaXMudGltZXN0YW1wcy5sZW5ndGggLSBpIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JkaW5hbFJhbmdlW2ldID8/IE5hTjtcbiAgfVxuICBmaW5kSW50ZXJ2YWwodGFyZ2V0KSB7XG4gICAgY29uc3QgeyBzb3J0ZWRUaW1lc3RhbXBzIH0gPSB0aGlzO1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gc29ydGVkVGltZXN0YW1wcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChzb3J0ZWRUaW1lc3RhbXBzW21pZF0gPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRUaW1lc3RhbXBzW21pZF0gPCB0YXJnZXQpIHtcbiAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGltZSBmb3JtYXQgZnVuY3Rpb24gc3VpdGFibGUgZm9yIGRpc3BsYXlpbmcgdGljayB2YWx1ZXMuXG4gICAqIEBwYXJhbSBzcGVjaWZpZXIgSWYgdGhlIHNwZWNpZmllciBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG9cbiAgICogdGhlIHtAbGluayBUaW1lTG9jYWxlT2JqZWN0LmZvcm1hdH0gbWV0aG9kLlxuICAgKiBJZiBubyBzcGVjaWZpZXIgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRlZmF1bHQgdGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAqL1xuICB0aWNrRm9ybWF0KHtcbiAgICB0aWNrcyxcbiAgICBkb21haW4sXG4gICAgc3BlY2lmaWVyXG4gIH0pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyBkZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbikgOiBidWlsZEZvcm1hdHRlcihzcGVjaWZpZXIpO1xuICB9XG4gIGludmVydChwb3NpdGlvbikge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwKSA9PiBwb3NpdGlvbiA8PSBwKTtcbiAgICByZXR1cm4gdGhpcy5kb21haW5baW5kZXhdO1xuICB9XG4gIGludmVydE5lYXJlc3QoeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdXBlci5pbnZlcnROZWFyZXN0KHkpKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcInRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcIm1pblRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcIm1heFRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xudmFyIE9yZGluYWxUaW1lU2NhbGUgPSBfT3JkaW5hbFRpbWVTY2FsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jb21wYXJlLnRzXG5mdW5jdGlvbiBhc2NlbmRpbmdTdHJpbmdOdW1iZXJVbmRlZmluZWQoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xuICB9IGVsc2UgaWYgKGEgPT0gbnVsbCAmJiBiID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG59XG5mdW5jdGlvbiB0b0xpdGVyYWwodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiA/IHYoKSA6IHY7XG59XG5mdW5jdGlvbiBjb21wb3VuZEFzY2VuZGluZyhhLCBiLCBjb21wYXJhdG9yKSB7XG4gIGZvciAoY29uc3QgaWR4IGluIGEpIHtcbiAgICBjb25zdCBkaWZmMiA9IGNvbXBhcmF0b3IodG9MaXRlcmFsKGFbaWR4XSksIHRvTGl0ZXJhbChiW2lkeF0pKTtcbiAgICBpZiAoZGlmZjIgIT09IDApIHtcbiAgICAgIHJldHVybiBkaWZmMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyb3VwLnRzXG52YXIgX0dyb3VwID0gY2xhc3MgX0dyb3VwIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcih7IGlzVmlydHVhbDogb3B0cz8uaXNWaXJ0dWFsLCBuYW1lOiBvcHRzPy5uYW1lIH0pO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxhc3RCQm94ID0gdm9pZCAwO1xuICAgIGNvbnN0IHsgekluZGV4LCB6SW5kZXhTdWJPcmRlciB9ID0gb3B0cyA/PyB7fTtcbiAgICB0aGlzLmlzQ29udGFpbmVyTm9kZSA9IHRydWU7XG4gICAgaWYgKHpJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcbiAgICB9XG4gICAgaWYgKHpJbmRleFN1Yk9yZGVyICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuekluZGV4U3ViT3JkZXIgPSB6SW5kZXhTdWJPcmRlcjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0dyb3VwO1xuICB9XG4gIG9uWkluZGV4Q2hhbmdlKCkge1xuICAgIHN1cGVyLm9uWkluZGV4Q2hhbmdlKCk7XG4gICAgaWYgKHRoaXMubGF5ZXIpIHtcbiAgICAgIHRoaXMuX2xheWVyTWFuYWdlcj8ubW92ZUxheWVyKHRoaXMubGF5ZXIsIHRoaXMuekluZGV4LCB0aGlzLnpJbmRleFN1Yk9yZGVyKTtcbiAgICB9XG4gIH1cbiAgaXNMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllciAhPSBudWxsO1xuICB9XG4gIF9zZXRMYXllck1hbmFnZXIobGF5ZXJzTWFuYWdlcikge1xuICAgIGlmICh0aGlzLl9sYXllck1hbmFnZXIgJiYgdGhpcy5sYXllcikge1xuICAgICAgdGhpcy5fbGF5ZXJNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMubGF5ZXIpO1xuICAgICAgdGhpcy5sYXllciA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVuYWJsZSB0byBkZXJlZ2lzdGVyIHNjZW5lIHJlbmRlcmluZyBsYXllciFcIik7XG4gICAgfVxuICAgIHN1cGVyLl9zZXRMYXllck1hbmFnZXIobGF5ZXJzTWFuYWdlcik7XG4gIH1cbiAgaW5pdGlhbGlzZUxheWVyKCkge1xuICAgIGlmICh0aGlzLmxheWVyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghdGhpcy5fbGF5ZXJNYW5hZ2VyIHx8IHRoaXMub3B0cz8ubGF5ZXIgIT09IHRydWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sYXllciA9IHRoaXMuX2xheWVyTWFuYWdlci5hZGRMYXllcih7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB6SW5kZXg6IHRoaXMuekluZGV4LFxuICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuekluZGV4U3ViT3JkZXIsXG4gICAgICBnZXRDb21wdXRlZE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0Q29tcHV0ZWRPcGFjaXR5KCksXG4gICAgICBnZXRWaXNpYmlsaXR5OiAoKSA9PiB0aGlzLmdldFZpc2liaWxpdHkoKVxuICAgIH0pO1xuICB9XG4gIGdldENvbXB1dGVkT3BhY2l0eSgpIHtcbiAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudHJhdmVyc2VVcCgpKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIF9Hcm91cCkge1xuICAgICAgICBvcGFjaXR5ICo9IG5vZGUub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wYWNpdHk7XG4gIH1cbiAgZ2V0VmlzaWJpbGl0eSgpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy50cmF2ZXJzZVVwKCkpIHtcbiAgICAgIGlmICghbm9kZS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25WaXNpYmxlQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmxheWVyKSB7XG4gICAgICB0aGlzLmxheWVyLmVuYWJsZWQgPSB0aGlzLnZpc2libGU7XG4gICAgfVxuICB9XG4gIG1hcmtEaXJ0eShzb3VyY2UsIHR5cGUgPSAxIC8qIFRSSVZJQUwgKi8pIHtcbiAgICBpZiAodGhpcy5pc1ZpcnR1YWwpIHtcbiAgICAgIHN1cGVyLm1hcmtEaXJ0eShzb3VyY2UsIHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGFyZW50VHlwZSA9IHR5cGU7XG4gICAgaWYgKHR5cGUgPCAyIC8qIE1JTk9SICovIHx8IHRoaXMubGF5ZXIgIT0gbnVsbCkge1xuICAgICAgcGFyZW50VHlwZSA9IDEgLyogVFJJVklBTCAqLztcbiAgICB9XG4gICAgc3VwZXIubWFya0RpcnR5KHNvdXJjZSwgdHlwZSwgcGFyZW50VHlwZSk7XG4gIH1cbiAgLy8gV2UgY29uc2lkZXIgYSBncm91cCB0byBiZSBib3VuZGxlc3MsIHRodXMgYW55IHBvaW50IGJlbG9uZ3MgdG8gaXQuXG4gIGNvbnRhaW5zUG9pbnQoX3gsIF95KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgcmV0dXJuIF9Hcm91cC5jb21wdXRlQkJveCh0aGlzLmNoaWxkcmVuKTtcbiAgfVxuICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLmdldEJCb3goKTtcbiAgfVxuICBjb21wdXRlVHJhbnNmb3JtZWRSZWdpb25CQm94KCkge1xuICAgIGlmICh0aGlzLmNsaXBSZWN0KSB7XG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIHJldHVybiB0aGlzLm1hdHJpeC50cmFuc2Zvcm1CQm94KHRoaXMuY2xpcFJlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gIH1cbiAgcHJlUmVuZGVyKCkge1xuICAgIGNvbnN0IGNvdW50cyA9IHN1cGVyLnByZVJlbmRlcigpO1xuICAgIGNvdW50cy5ncm91cHMgKz0gMTtcbiAgICBjb3VudHMubm9uR3JvdXBzIC09IDE7XG4gICAgaWYgKHRoaXMub3B0cz8ubGF5ZXIgIT09IHRydWUgfHwgdGhpcy5sYXllciAhPSBudWxsKVxuICAgICAgcmV0dXJuIGNvdW50cztcbiAgICBpZiAoY291bnRzLm5vbkdyb3VwcyA+IDApIHtcbiAgICAgIHRoaXMuaW5pdGlhbGlzZUxheWVyKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdHM/Lm5vbkVtcHR5Q2hpbGREZXJpdmVkWkluZGV4ICYmIGNvdW50cy5ub25Hcm91cHMgPiAwKSB7XG4gICAgICB0aGlzLmRlcml2ZVpJbmRleEZyb21DaGlsZHJlbigpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRzO1xuICB9XG4gIGRlcml2ZVpJbmRleEZyb21DaGlsZHJlbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKChjKSA9PiBjLl9jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzID4gMCk7XG4gICAgdGhpcy5zb3J0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IGNoaWxkcmVuLmF0KC0xKTtcbiAgICB0aGlzLnpJbmRleCA9IGxhc3RDaGlsZD8uekluZGV4ID8/IC1JbmZpbml0eTtcbiAgICB0aGlzLnpJbmRleFN1Yk9yZGVyID0gbGFzdENoaWxkPy56SW5kZXhTdWJPcmRlcjtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBvcHRzOiB7IG5hbWUgPSB2b2lkIDAgfSA9IHt9LCBfZGVidWc6IGRlYnVnMyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRpcnR5LCBkaXJ0eVpJbmRleCwgbGF5ZXIsIGNoaWxkcmVuLCBjbGlwUmVjdCwgZGlydHlUcmFuc2Zvcm0gfSA9IHRoaXM7XG4gICAgbGV0IHsgY3R4LCBmb3JjZVJlbmRlciwgY2xpcEJCb3ggfSA9IHJlbmRlckN0eDtcbiAgICBjb25zdCB7IHJlc2l6ZWQsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgY29uc3QgY2FudmFzQ3R4VHJhbnNmb3JtID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgIGNvbnN0IGlzRGlydHkgPSBkaXJ0eSA+PSAyIC8qIE1JTk9SICovIHx8IGRpcnR5WkluZGV4IHx8IHJlc2l6ZWQ7XG4gICAgbGV0IGlzQ2hpbGREaXJ0eSA9IGlzRGlydHk7XG4gICAgbGV0IGlzQ2hpbGRMYXllckRpcnR5ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaXNDaGlsZERpcnR5IHx8IChpc0NoaWxkRGlydHkgPSBjaGlsZC5sYXllck1hbmFnZXIgPT0gbnVsbCAmJiBjaGlsZC5kaXJ0eSA+PSAxIC8qIFRSSVZJQUwgKi8pO1xuICAgICAgaXNDaGlsZExheWVyRGlydHkgfHwgKGlzQ2hpbGRMYXllckRpcnR5ID0gY2hpbGQubGF5ZXJNYW5hZ2VyICE9IG51bGwgJiYgY2hpbGQuZGlydHkgPj0gMSAvKiBUUklWSUFMICovKTtcbiAgICAgIGlmIChpc0NoaWxkRGlydHkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lKSB7XG4gICAgICBkZWJ1ZzM/Lih7IG5hbWUsIGdyb3VwOiB0aGlzLCBpc0RpcnR5LCBpc0NoaWxkRGlydHksIGRpcnR5VHJhbnNmb3JtLCByZW5kZXJDdHgsIGZvcmNlUmVuZGVyIH0pO1xuICAgIH1cbiAgICBpZiAoZGlydHlUcmFuc2Zvcm0pIHtcbiAgICAgIGZvcmNlUmVuZGVyID0gXCJkaXJ0eVRyYW5zZm9ybVwiO1xuICAgIH0gZWxzZSBpZiAobGF5ZXIpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRCQm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICBpZiAodGhpcy5sYXN0QkJveCA9PT0gdm9pZCAwIHx8ICF0aGlzLmxhc3RCQm94LmVxdWFscyhjdXJyZW50QkJveCkpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIgPSBcImRpcnR5VHJhbnNmb3JtXCI7XG4gICAgICAgIHRoaXMubGFzdEJCb3ggPSBjdXJyZW50QkJveDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmICFpc0NoaWxkRGlydHkgJiYgIWlzQ2hpbGRMYXllckRpcnR5ICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKG5hbWUgJiYgc3RhdHMpIHtcbiAgICAgICAgZGVidWczPy4oeyBuYW1lLCByZXN1bHQ6IFwic2tpcHBpbmdcIiwgcmVuZGVyQ3R4LCBjb3VudHM6IHRoaXMubm9kZUNvdW50LCBncm91cDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXllciAmJiBzdGF0cykge1xuICAgICAgICBzdGF0cy5sYXllcnNTa2lwcGVkKys7XG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0NsZWFuKHsgcmVjdXJzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBWaXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgIGlmIChsYXllcikge1xuICAgICAgY3R4ID0gbGF5ZXIuY29udGV4dDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKGxheWVyLnBpeGVsUmF0aW8sIDAsIDAsIGxheWVyLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgaWYgKGZvcmNlUmVuZGVyICE9PSBcImRpcnR5VHJhbnNmb3JtXCIpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIgPSBpc0NoaWxkRGlydHkgfHwgZGlydHlaSW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAoZm9yY2VSZW5kZXIpXG4gICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICBpZiAoY2xpcEJCb3gpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBjbGlwQkJveDtcbiAgICAgICAgZGVidWczPy4oKCkgPT4gKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNsaXBCQm94LFxuICAgICAgICAgIGN0eFRyYW5zZm9ybTogY3R4LmdldFRyYW5zZm9ybSgpLFxuICAgICAgICAgIHJlbmRlckN0eCxcbiAgICAgICAgICBncm91cDogdGhpc1xuICAgICAgICB9KSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICB9XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKGNhbnZhc0N0eFRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMudHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgsIGN0eCk7XG4gICAgaWYgKGNsaXBSZWN0KSB7XG4gICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGNsaXBSZWN0O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGRlYnVnMz8uKCgpID0+ICh7IG5hbWUsIGNsaXBSZWN0LCBjdHhUcmFuc2Zvcm06IGN0eC5nZXRUcmFuc2Zvcm0oKSwgcmVuZGVyQ3R4LCBncm91cDogdGhpcyB9KSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBjbGlwQkJveCA9IG1hdHJpeC50cmFuc2Zvcm1CQm94KGNsaXBSZWN0KTtcbiAgICB9XG4gICAgY29uc3QgaGFzVmlydHVhbENoaWxkcmVuID0gdGhpcy5oYXNWaXJ0dWFsQ2hpbGRyZW4oKTtcbiAgICBpZiAoZGlydHlaSW5kZXgpIHtcbiAgICAgIHRoaXMuc29ydENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgIGlmIChmb3JjZVJlbmRlciAhPT0gXCJkaXJ0eVRyYW5zZm9ybVwiKVxuICAgICAgICBmb3JjZVJlbmRlciA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNWaXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuc29ydENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyQ29udGV4dENoYW5nZWQgPSBmb3JjZVJlbmRlciAhPT0gcmVuZGVyQ3R4LmZvcmNlUmVuZGVyIHx8IGNsaXBCQm94ICE9PSByZW5kZXJDdHguY2xpcEJCb3ggfHwgY3R4ICE9PSByZW5kZXJDdHguY3R4O1xuICAgIGNvbnN0IGNoaWxkUmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHRDaGFuZ2VkID8geyAuLi5yZW5kZXJDdHgsIGN0eCwgZm9yY2VSZW5kZXIsIGNsaXBCQm94IH0gOiByZW5kZXJDdHg7XG4gICAgbGV0IHNraXBwZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmICghY2hpbGQudmlzaWJsZSB8fCAhZ3JvdXBWaXNpYmxlKSB7XG4gICAgICAgIGNoaWxkLm1hcmtDbGVhbigpO1xuICAgICAgICBpZiAoc3RhdHMpXG4gICAgICAgICAgc2tpcHBlZCArPSBjaGlsZC5ub2RlQ291bnQuY291bnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3JjZVJlbmRlciAmJiBjaGlsZC5kaXJ0eSA9PT0gMCAvKiBOT05FICovKSB7XG4gICAgICAgIGlmIChzdGF0cylcbiAgICAgICAgICBza2lwcGVkICs9IGNoaWxkLm5vZGVDb3VudC5jb3VudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY2hpbGQucmVuZGVyKGNoaWxkUmVuZGVyQ29udGV4dCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoc3RhdHMpXG4gICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gc2tpcHBlZDtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICBpZiAoY2xpcFJlY3QpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChoYXNWaXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy52aXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGQubWFya0NsZWFuKHsgcmVjdXJzaXZlOiBcInZpcnR1YWxcIiB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLmxheWVyc1JlbmRlcmVkKys7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKGZvcmNlUmVuZGVyKVxuICAgICAgICBsYXllci5zbmFwc2hvdCgpO1xuICAgICAgbGF5ZXIuY29udGV4dC52ZXJpZnlEZXB0aFplcm8/LigpO1xuICAgIH1cbiAgICBpZiAobmFtZSAmJiBzdGF0cykge1xuICAgICAgZGVidWczPy4oeyBuYW1lLCByZXN1bHQ6IFwicmVuZGVyZWRcIiwgc2tpcHBlZCwgcmVuZGVyQ3R4LCBjb3VudHM6IHRoaXMubm9kZUNvdW50LCBncm91cDogdGhpcyB9KTtcbiAgICB9XG4gIH1cbiAgc29ydENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgdGhpcy5kaXJ0eVpJbmRleCA9IGZhbHNlO1xuICAgIGNoaWxkcmVuLnNvcnQoXG4gICAgICAoYSwgYikgPT4gY29tcG91bmRBc2NlbmRpbmcoXG4gICAgICAgIFthLnpJbmRleCwgLi4uYS56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBhLnNlcmlhbE51bWJlcl0sXG4gICAgICAgIFtiLnpJbmRleCwgLi4uYi56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBiLnNlcmlhbE51bWJlcl0sXG4gICAgICAgIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVCQm94KG5vZGVzLCBvcHRzKSB7XG4gICAgbGV0IGxlZnQgPSBJbmZpbml0eTtcbiAgICBsZXQgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgbGV0IHRvcCA9IEluZmluaXR5O1xuICAgIGxldCBib3R0b20gPSAtSW5maW5pdHk7XG4gICAgY29uc3Qgc2tpcEludmlzaWJsZSA9IG9wdHM/LnNraXBJbnZpc2libGUgPz8gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXMpIHtcbiAgICAgIGlmIChza2lwSW52aXNpYmxlICYmICFuLnZpc2libGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYmJveCA9IG4uY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgaWYgKCFiYm94KVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gYmJveDtcbiAgICAgIGlmICh4IDwgbGVmdCkge1xuICAgICAgICBsZWZ0ID0geDtcbiAgICAgIH1cbiAgICAgIGlmICh5IDwgdG9wKSB7XG4gICAgICAgIHRvcCA9IHk7XG4gICAgICB9XG4gICAgICBpZiAoeCArIHdpZHRoID4gcmlnaHQpIHtcbiAgICAgICAgcmlnaHQgPSB4ICsgd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoeSArIGhlaWdodCA+IGJvdHRvbSkge1xuICAgICAgICBib3R0b20gPSB5ICsgaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEJCb3gobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYmJveCBnaXZlbiBpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UgdG8gYmJveCBpbiB0aGlzIGdyb3VwJ3MgY29vcmRpbmF0ZSBzcGFjZSBhbmRcbiAgICogc2V0cyB0aGlzIGdyb3VwJ3MgY2xpcFJlY3QgdG8gdGhlIHRyYW5zZm9ybWVkIGJib3guXG4gICAqIEBwYXJhbSBiYm94IGNsaXBSZWN0IGJib3ggaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKi9cbiAgc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKGJib3gpIHtcbiAgICB0aGlzLmNsaXBSZWN0ID0gYmJveCA/IHRoaXMudHJhbnNmb3JtQkJveChiYm94KSA6IHZvaWQgMDtcbiAgfVxufTtcbl9Hcm91cC5jbGFzc05hbWUgPSBcIkdyb3VwXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAzIC8qIE1BSk9SICovLFxuICAgIGNvbnZlcnRvcjogKHYpID0+IGNsYW1wKDAsIHYsIDEpXG4gIH0pXG5dLCBfR3JvdXAucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgMik7XG52YXIgR3JvdXAgPSBfR3JvdXA7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZG9tLnRzXG52YXIgdmVyaWZpZWRHbG9iYWxzID0ge307XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMud2luZG93ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSBnbG9iYWwud2luZG93O1xufVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChwcm9wZXJ0eU5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnR5TmFtZSA/IHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudD8uW3Byb3BlcnR5TmFtZV0gOiB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cocHJvcGVydHlOYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0eU5hbWUgPyB2ZXJpZmllZEdsb2JhbHMud2luZG93Py5bcHJvcGVydHlOYW1lXSA6IHZlcmlmaWVkR2xvYmFscy53aW5kb3c7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgY29uc3QgZWxlbWVudDIgPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgc3R5bGUgPSBjbGFzc05hbWU7XG4gICAgY2xhc3NOYW1lID0gdm9pZCAwO1xuICB9XG4gIGlmIChjbGFzc05hbWUpIHtcbiAgICBlbGVtZW50Mi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50Mi5zdHlsZSwgc3R5bGUpO1xuICB9XG4gIHJldHVybiBlbGVtZW50Mjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpIHtcbiAgcmV0dXJuIGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSk7XG59XG5mdW5jdGlvbiBkb3dubG9hZFVybChkYXRhVXJsLCBmaWxlTmFtZSkge1xuICBjb25zdCB7IGJvZHkgfSA9IGdldERvY3VtZW50KCk7XG4gIGNvbnN0IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChcImFcIiwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KTtcbiAgZWxlbWVudDIuaHJlZiA9IGRhdGFVcmw7XG4gIGVsZW1lbnQyLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICBlbGVtZW50Mi5jbGljaygpO1xuICBzZXRUaW1lb3V0KCgpID0+IGJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudDIpKTtcbn1cbmZ1bmN0aW9uIHNldERvY3VtZW50KGRvY3VtZW50Mikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDI7XG59XG5mdW5jdGlvbiBzZXRXaW5kb3cod2luZG93Mikge1xuICB2ZXJpZmllZEdsb2JhbHMud2luZG93ID0gd2luZG93Mjtcbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRCQm94KGVsZW1lbnQyLCBiYm94KSB7XG4gIGlmIChlbGVtZW50Mikge1xuICAgIGVsZW1lbnQyLnN0eWxlLndpZHRoID0gYCR7YmJveC53aWR0aH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUuaGVpZ2h0ID0gYCR7YmJveC5oZWlnaHR9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLmxlZnQgPSBgJHtiYm94Lnh9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLnRvcCA9IGAke2Jib3gueX1weGA7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWJ1Zy50c1xudmFyIExPTkdfVElNRV9QRVJJT0RfVEhSRVNIT0xEID0gMmUzO1xudmFyIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xudmFyIGxvZ1RpbWVHYXAgPSAoKSA9PiB7XG4gIGNvbnN0IHRpbWVTaW5jZUxhc3RMb2cgPSBEYXRlLm5vdygpIC0gdGltZU9mTGFzdExvZztcbiAgaWYgKHRpbWVTaW5jZUxhc3RMb2cgPiBMT05HX1RJTUVfUEVSSU9EX1RIUkVTSE9MRCkge1xuICAgIGNvbnN0IHByZXR0eUR1cmF0aW9uID0gKE1hdGguZmxvb3IodGltZVNpbmNlTGFzdExvZyAvIDEwMCkgLyAxMCkudG9GaXhlZCgxKTtcbiAgICBMb2dnZXIubG9nKGAqKioqICR7cHJldHR5RHVyYXRpb259cyBzaW5jZSBsYXN0IGxvZyBtZXNzYWdlICoqKipgKTtcbiAgfVxuICB0aW1lT2ZMYXN0TG9nID0gRGF0ZS5ub3coKTtcbn07XG52YXIgRGVidWcgPSB7XG4gIGNyZWF0ZSguLi5kZWJ1Z1NlbGVjdG9ycykge1xuICAgIGNvbnN0IHJlc3VsdEZuID0gKC4uLmxvZ0NvbnRlbnQpID0+IHtcbiAgICAgIGlmIChEZWJ1Zy5jaGVjayguLi5kZWJ1Z1NlbGVjdG9ycykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dDb250ZW50WzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBsb2dDb250ZW50ID0gdG9BcnJheShsb2dDb250ZW50WzBdKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ1RpbWVHYXAoKTtcbiAgICAgICAgTG9nZ2VyLmxvZyguLi5sb2dDb250ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdEZuLCB7IGNoZWNrOiAoKSA9PiBEZWJ1Zy5jaGVjayguLi5kZWJ1Z1NlbGVjdG9ycykgfSk7XG4gIH0sXG4gIGNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSB7XG4gICAgaWYgKGRlYnVnU2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVidWdTZWxlY3RvcnMucHVzaCh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnREZWJ1ZyA9IHRvQXJyYXkoZ2V0V2luZG93KFwiYWdDaGFydHNEZWJ1Z1wiKSk7XG4gICAgcmV0dXJuIGNoYXJ0RGVidWcuc29tZSgoc2VsZWN0b3IpID0+IGRlYnVnU2VsZWN0b3JzLmluY2x1ZGVzKHNlbGVjdG9yKSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NlbGVjdGlvbi50c1xudmFyIFNlbGVjdGlvbiA9IGNsYXNzIF9TZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJlbnROb2RlLCBjbGFzc09yRmFjdG9yeSwgYXV0b0NsZWFudXAgPSB0cnVlKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB0aGlzLmF1dG9DbGVhbnVwID0gYXV0b0NsZWFudXA7XG4gICAgdGhpcy5nYXJiYWdlQmluID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9ub2Rlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwic2NlbmVcIiwgXCJzY2VuZTpzZWxlY3Rpb25zXCIpO1xuICAgIHRoaXMubm9kZUZhY3RvcnkgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChOb2RlLCBjbGFzc09yRmFjdG9yeSkgPyAoKSA9PiBuZXcgY2xhc3NPckZhY3RvcnkoKSA6IGNsYXNzT3JGYWN0b3J5O1xuICB9XG4gIHN0YXRpYyBzZWxlY3QocGFyZW50LCBjbGFzc09yRmFjdG9yeSwgZ2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VsZWN0aW9uKHBhcmVudCwgY2xhc3NPckZhY3RvcnksIGdhcmJhZ2VDb2xsZWN0aW9uKTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0QWxsKHBhcmVudCwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHRyYXZlcnNlID0gKG5vZGUpID0+IHtcbiAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHRyYXZlcnNlKTtcbiAgICB9O1xuICAgIHRyYXZlcnNlKHBhcmVudCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgc3RhdGljIHNlbGVjdEJ5Q2xhc3Mobm9kZSwgQ2xhc3MsIC4uLkV4dHJhQ2xhc3Nlcykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEFsbChub2RlLCAobikgPT4ge1xuICAgICAgcmV0dXJuIG4gaW5zdGFuY2VvZiBDbGFzcyB8fCBFeHRyYUNsYXNzZXMuc29tZSgoQykgPT4gbiBpbnN0YW5jZW9mIEMpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZWxlY3RCeVRhZyhub2RlLCB0YWcpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RBbGwobm9kZSwgKG4pID0+IG4udGFnID09PSB0YWcpO1xuICB9XG4gIGNyZWF0ZU5vZGUoZGF0dW0sIGluaXRpYWxpemVyLCBpZHgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlRmFjdG9yeShkYXR1bSk7XG4gICAgbm9kZS5kYXR1bSA9IGRhdHVtO1xuICAgIGluaXRpYWxpemVyPy4obm9kZSk7XG4gICAgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ub2Rlcy5zcGxpY2UoaWR4LCAwLCBub2RlKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRhdGEgaW4gYSBzZWxlY3Rpb24uIElmIGFuIGBnZXREYXR1bUlkKClgIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBtYWludGFpbiBhIGxpc3Qgb2YgaWRzIHJlbGF0ZWQgdG9cbiAgICogdGhlIG5vZGVzLiBPdGhlcndpc2UsIHRha2UgdGhlIG1vcmUgZWZmaWNpZW50IHJvdXRlIG9mIHNpbXBseSBjcmVhdGluZyBhbmQgZGVzdHJveWluZyBub2RlcyBhdCB0aGUgZW5kXG4gICAqIG9mIHRoZSBhcnJheS5cbiAgICovXG4gIHVwZGF0ZShkYXRhLCBpbml0aWFsaXplciwgZ2V0RGF0dW1JZCkge1xuICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuZGVidWcoYFNlbGVjdGlvbiAtIHVwZGF0ZSgpIGNhbGxlZCB3aXRoIHBlbmRpbmcgZ2FyYmFnZTogJHtkYXRhfWApO1xuICAgIH1cbiAgICBpZiAoZ2V0RGF0dW1JZCkge1xuICAgICAgY29uc3QgZGF0YU1hcCA9IG5ldyBNYXAoXG4gICAgICAgIGRhdGEubWFwKChkYXR1bSwgaWR4KSA9PiBbZ2V0RGF0dW1JZChkYXR1bSksIFtkYXR1bSwgaWR4XV0pXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBbbm9kZSwgZGF0dW1JZF0gb2YgdGhpcy5fbm9kZXNNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChkYXRhTWFwLmhhcyhkYXR1bUlkKSkge1xuICAgICAgICAgIGNvbnN0IFtuZXdEYXR1bV0gPSBkYXRhTWFwLmdldChkYXR1bUlkKTtcbiAgICAgICAgICBub2RlLmRhdHVtID0gbmV3RGF0dW07XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICBkYXRhTWFwLmRlbGV0ZShkYXR1bUlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtkYXR1bUlkLCBbZGF0dW0sIGlkeF1dIG9mIGRhdGFNYXAuZW50cmllcygpKSB7XG4gICAgICAgIHRoaXMuX25vZGVzTWFwLnNldCh0aGlzLmNyZWF0ZU5vZGUoZGF0dW0sIGluaXRpYWxpemVyLCBpZHgpLCBkYXR1bUlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5tYXgoZGF0YS5sZW5ndGgsIHRoaXMuZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5hZGQodGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPj0gdGhpcy5fbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVOb2RlKGRhdGFbaV0sIGluaXRpYWxpemVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ub2Rlc1tpXS5kYXR1bSA9IGRhdGFbaV07XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmRlbGV0ZSh0aGlzLl9ub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kYXRhID0gZGF0YS5zbGljZSgpO1xuICAgIGlmICh0aGlzLmF1dG9DbGVhbnVwKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5nYXJiYWdlQmluLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9ub2RlcyA9IHRoaXMuX25vZGVzLmZpbHRlcigobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZ2FyYmFnZUJpbi5oYXMobm9kZSkpIHtcbiAgICAgICAgdGhpcy5fbm9kZXNNYXAuZGVsZXRlKG5vZGUpO1xuICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKG5vZGUpO1xuICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy51cGRhdGUoW10pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlzR2FyYmFnZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2FyYmFnZUJpbi5oYXMobm9kZSk7XG4gIH1cbiAgaGFzR2FyYmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nYXJiYWdlQmluLnNpemUgPiAwO1xuICB9XG4gIGVhY2goaXRlcmF0ZTIpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuX25vZGVzLmVudHJpZXMoKSkge1xuICAgICAgaXRlcmF0ZTIoZW50cnlbMV0sIGVudHJ5WzFdLmRhdHVtLCBlbnRyeVswXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbaW5kZXhdO1xuICAgICAgY29uc3QgZGF0dW0gPSB0aGlzLl9ub2Rlc1tpbmRleF0uZGF0dW07XG4gICAgICB5aWVsZCB7IG5vZGUsIGRhdHVtLCBpbmRleCB9O1xuICAgIH1cbiAgfVxuICBzZWxlY3QocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKHRoaXMucGFyZW50Tm9kZSwgcHJlZGljYXRlKTtcbiAgfVxuICBzZWxlY3RCeUNsYXNzKENsYXNzKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QnlDbGFzcyh0aGlzLnBhcmVudE5vZGUsIENsYXNzKTtcbiAgfVxuICBzZWxlY3RCeVRhZyh0YWcpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RCeVRhZyh0aGlzLnBhcmVudE5vZGUsIHRhZyk7XG4gIH1cbiAgbm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzO1xuICB9XG4gIGF0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmF0KGluZGV4KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hbmdsZS50c1xudmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MChyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJhZGlhbnMgKz0gdHdvUGk7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmUocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICByYWRpYW5zICs9IHR3b1BpO1xuICBpZiAocmFkaWFucyAhPT0gdHdvUGkpIHtcbiAgICByYWRpYW5zICU9IHR3b1BpO1xuICB9XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUxODAocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICBpZiAocmFkaWFucyA8IC1NYXRoLlBJKSB7XG4gICAgcmFkaWFucyArPSB0d29QaTtcbiAgfSBlbHNlIGlmIChyYWRpYW5zID49IE1hdGguUEkpIHtcbiAgICByYWRpYW5zIC09IHR3b1BpO1xuICB9XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gaXNCZXR3ZWVuQW5nbGVzKHRhcmdldEFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICBjb25zdCB0ID0gbm9ybWFsaXplQW5nbGUzNjAodGFyZ2V0QW5nbGUpO1xuICBjb25zdCBhMCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBhMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGVuZEFuZ2xlKTtcbiAgaWYgKGEwIDwgYTEpIHtcbiAgICByZXR1cm4gYTAgPD0gdCAmJiB0IDw9IGExO1xuICB9IGVsc2UgaWYgKGEwID4gYTEpIHtcbiAgICByZXR1cm4gYTAgPD0gdCB8fCB0IDw9IGExO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAvIE1hdGguUEkgKiAxODA7XG59XG5mdW5jdGlvbiBhbmdsZURpZmYoYW5nbGUwLCBhbmdsZTEsIGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbYW5nbGUwLCBhbmdsZTFdID0gW2FuZ2xlMSwgYW5nbGUwXTtcbiAgfVxuICBjb25zdCBhMCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMCk7XG4gIGNvbnN0IGExID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUxKSArIHR3b1BpO1xuICByZXR1cm4gKGExIC0gYTApICUgdHdvUGk7XG59XG5mdW5jdGlvbiBhbmdsZUJldHdlZW4oYW5nbGUwLCBhbmdsZTEpIHtcbiAgYW5nbGUwID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUwKTtcbiAgYW5nbGUxID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUxKTtcbiAgcmV0dXJuIGFuZ2xlMSAtIGFuZ2xlMCArIChhbmdsZTAgPiBhbmdsZTEgPyAyICogTWF0aC5QSSA6IDApO1xufVxuZnVuY3Rpb24gZGlzcGxhY2VQb2ludEZyb21WZWN0b3IoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBhbmdsZTIpIHtcbiAgY29uc3QgeCA9IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZTIpO1xuICBjb25zdCB5ID0gY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlMik7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kaXN0YW5jZS50c1xuZnVuY3Rpb24gcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDEgLSB4MjtcbiAgY29uc3QgZHkgPSB5MSAtIHkyO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5mdW5jdGlvbiBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBiZXN0KSB7XG4gIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCB4MSwgeTEpKTtcbiAgfVxuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgY29uc3QgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpKSk7XG4gIGNvbnN0IGl4ID0geDEgKyB0ICogZHg7XG4gIGNvbnN0IGl5ID0geTEgKyB0ICogZHk7XG4gIHJldHVybiBNYXRoLm1pbihiZXN0LCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgaXgsIGl5KSk7XG59XG5mdW5jdGlvbiBhcmNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlLCBiZXN0KSB7XG4gIGlmIChjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgW2VuZEFuZ2xlLCBzdGFydEFuZ2xlXSA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gIH1cbiAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMih5IC0gY3ksIHggLSBjeCk7XG4gIGlmICghaXNCZXR3ZWVuQW5nbGVzKGFuZ2xlMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IGVuZFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IGVuZFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIHJldHVybiBNYXRoLm1pbihiZXN0LCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgc3RhcnRYLCBzdGFydFkpLCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgZW5kWCwgZW5kWSkpO1xuICB9XG4gIGNvbnN0IGRpc3RUb0FyYyA9IHJhZGl1cyAtIE1hdGguc3FydChwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgY3gsIGN5KSk7XG4gIHJldHVybiBNYXRoLm1pbihiZXN0LCBkaXN0VG9BcmMgKiBkaXN0VG9BcmMpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncmFkaWVudC9ncmFkaWVudC50c1xudmFyIEdyYWRpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdG9wcyA9IFtdKSB7XG4gICAgdGhpcy5zdG9wcyA9IHN0b3BzO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncmFkaWVudC9saW5lYXJHcmFkaWVudC50c1xudmFyIExpbmVhckdyYWRpZW50ID0gY2xhc3MgZXh0ZW5kcyBHcmFkaWVudCB7XG4gIGNvbnN0cnVjdG9yKHN0b3BzLCBhbmdsZTIgPSAwKSB7XG4gICAgc3VwZXIoc3RvcHMpO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTI7XG4gIH1cbiAgY3JlYXRlR3JhZGllbnQoY3R4LCBiYm94KSB7XG4gICAgY29uc3QgYW5nbGVPZmZzZXQgPSA5MDtcbiAgICBjb25zdCB7IHN0b3BzLCBhbmdsZTogYW5nbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhZGlhbnMgPSBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMoYW5nbGUyICsgYW5nbGVPZmZzZXQpKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcbiAgICBjb25zdCB3ID0gYmJveC53aWR0aDtcbiAgICBjb25zdCBoID0gYmJveC5oZWlnaHQ7XG4gICAgY29uc3QgY3ggPSBiYm94LnggKyB3ICogMC41O1xuICAgIGNvbnN0IGN5ID0gYmJveC55ICsgaCAqIDAuNTtcbiAgICBpZiAodyA+IDAgJiYgaCA+IDApIHtcbiAgICAgIGNvbnN0IGRpYWdvbmFsID0gTWF0aC5zcXJ0KGggKiBoICsgdyAqIHcpIC8gMjtcbiAgICAgIGNvbnN0IGRpYWdvbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGgsIHcpO1xuICAgICAgbGV0IHF1YXJ0ZXJlZEFuZ2xlO1xuICAgICAgaWYgKHJhZGlhbnMgPCBNYXRoLlBJIC8gMikge1xuICAgICAgICBxdWFydGVyZWRBbmdsZSA9IHJhZGlhbnM7XG4gICAgICB9IGVsc2UgaWYgKHJhZGlhbnMgPCBNYXRoLlBJKSB7XG4gICAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gTWF0aC5QSSAtIHJhZGlhbnM7XG4gICAgICB9IGVsc2UgaWYgKHJhZGlhbnMgPCAxLjUgKiBNYXRoLlBJKSB7XG4gICAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gcmFkaWFucyAtIE1hdGguUEk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWFydGVyZWRBbmdsZSA9IDIgKiBNYXRoLlBJIC0gcmFkaWFucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGwgPSBkaWFnb25hbCAqIE1hdGguYWJzKE1hdGguY29zKHF1YXJ0ZXJlZEFuZ2xlIC0gZGlhZ29uYWxBbmdsZSkpO1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoY3ggKyBjb3MgKiBsLCBjeSArIHNpbiAqIGwsIGN4IC0gY29zICogbCwgY3kgLSBzaW4gKiBsKTtcbiAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIHN0b3AuY29sb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgICByZXR1cm4gXCJibGFja1wiO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9zaGFwZS50c1xudmFyIExJTkVBUl9HUkFESUVOVF9SRUdFWFAgPSAvXmxpbmVhci1ncmFkaWVudFxcKCgtP1tcXGQuXSspZGVnLCguKj8pXFwpJC9pO1xudmFyIF9TaGFwZSA9IGNsYXNzIF9TaGFwZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5maWxsID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuZmlsbDtcbiAgICB0aGlzLnN0cm9rZSA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5saW5lRGFzaCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVEYXNoO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lRGFzaE9mZnNldDtcbiAgICB0aGlzLmxpbmVDYXAgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lQ2FwO1xuICAgIHRoaXMubGluZUpvaW4gPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lSm9pbjtcbiAgICB0aGlzLm1pdGVyTGltaXQgPSB2b2lkIDA7XG4gICAgdGhpcy5vcGFjaXR5ID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMub3BhY2l0eTtcbiAgICB0aGlzLmZpbGxTaGFkb3cgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5maWxsU2hhZG93O1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlcyB0aGUgZGVmYXVsdCBzdHlsZXMgaW50cm9kdWNlZCBieSB0aGlzIHN1YmNsYXNzLlxuICAgKi9cbiAgcmVzdG9yZU93blN0eWxlcygpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRTdHlsZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZWZhdWx0U3R5bGVzKTtcbiAgfVxuICBvbkZpbGxDaGFuZ2UoKSB7XG4gICAgY29uc3QgeyBmaWxsIH0gPSB0aGlzO1xuICAgIGxldCBsaW5lYXJHcmFkaWVudE1hdGNoO1xuICAgIGlmIChmaWxsPy5zdGFydHNXaXRoKFwibGluZWFyLWdyYWRpZW50XCIpICYmIChsaW5lYXJHcmFkaWVudE1hdGNoID0gTElORUFSX0dSQURJRU5UX1JFR0VYUC5leGVjKGZpbGwpKSkge1xuICAgICAgY29uc3QgYW5nbGUyID0gcGFyc2VGbG9hdChsaW5lYXJHcmFkaWVudE1hdGNoWzFdKTtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgICAgY29uc3QgY29sb3JzUGFydCA9IGxpbmVhckdyYWRpZW50TWF0Y2hbMl07XG4gICAgICBjb25zdCBjb2xvclJlZ2V4ID0gLygjWzAtOWEtZl0rKXwocmdiYT9cXCguKz9cXCkpfChbYS16XSspL2dpO1xuICAgICAgbGV0IGM7XG4gICAgICB3aGlsZSAoYyA9IGNvbG9yUmVnZXguZXhlYyhjb2xvcnNQYXJ0KSkge1xuICAgICAgICBjb2xvcnMucHVzaChjWzBdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JhZGllbnQgPSBuZXcgTGluZWFyR3JhZGllbnQoXG4gICAgICAgIGNvbG9ycy5tYXAoKGNvbG9yLCBpbmRleCkgPT4gKHsgY29sb3IsIG9mZnNldDogaW5kZXggLyAoY29sb3JzLmxlbmd0aCAtIDEpIH0pKSxcbiAgICAgICAgYW5nbGUyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdyYWRpZW50ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGRldmljZS1waXhlbCBhbGlnbmVkIGNvb3JkaW5hdGUgKG9yIGxlbmd0aCBpZiBsZW5ndGggaXMgc3VwcGxpZWQpLlxuICAgKlxuICAgKiBOT1RFOiBOb3Qgc3VpdGFibGUgZm9yIHN0cm9rZXMsIHNpbmNlIHRoZSBzdHJva2UgbmVlZHMgdG8gYmUgb2Zmc2V0IHRvIHRoZSBtaWRkbGVcbiAgICogb2YgYSBkZXZpY2UgcGl4ZWwuXG4gICAqL1xuICBhbGlnbihzdGFydCwgbGVuZ3RoMikge1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzPy5waXhlbFJhdGlvID8/IDE7XG4gICAgY29uc3QgYWxpZ25lZFN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBpZiAobGVuZ3RoMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWxpZ25lZFN0YXJ0O1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyIDwgMSkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGgyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgobGVuZ3RoMiArIHN0YXJ0KSAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbyAtIGFsaWduZWRTdGFydDtcbiAgfVxuICBmaWxsU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIHRoaXMucmVuZGVyRmlsbChjdHgsIHBhdGgpO1xuICAgIHRoaXMucmVuZGVyU3Ryb2tlKGN0eCwgcGF0aCk7XG4gIH1cbiAgcmVuZGVyRmlsbChjdHgsIHBhdGgpIHtcbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICB0aGlzLmFwcGx5RmlsbChjdHgpO1xuICAgICAgdGhpcy5hcHBseUZpbGxBbHBoYShjdHgpO1xuICAgICAgdGhpcy5hcHBseVNoYWRvdyhjdHgpO1xuICAgICAgdGhpcy5leGVjdXRlRmlsbChjdHgsIHBhdGgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgfVxuICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICB9XG4gIGV4ZWN1dGVGaWxsKGN0eCwgcGF0aCkge1xuICAgIHBhdGggPyBjdHguZmlsbChwYXRoKSA6IGN0eC5maWxsKCk7XG4gIH1cbiAgYXBwbHlGaWxsKGN0eCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmdyYWRpZW50Py5jcmVhdGVHcmFkaWVudChjdHgsIHRoaXMuZ2V0QkJveCgpKSA/PyB0aGlzLmZpbGw7XG4gIH1cbiAgYXBwbHlGaWxsQWxwaGEoY3R4KSB7XG4gICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuZmlsbE9wYWNpdHk7XG4gIH1cbiAgYXBwbHlTaGFkb3coY3R4KSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IGZpbGxTaGFkb3cgPSB0aGlzLmZpbGxTaGFkb3c7XG4gICAgaWYgKGZpbGxTaGFkb3c/LmVuYWJsZWQpIHtcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGZpbGxTaGFkb3cuY29sb3I7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IGZpbGxTaGFkb3cueE9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IGZpbGxTaGFkb3cueU9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IGZpbGxTaGFkb3cuYmx1ciAqIHBpeGVsUmF0aW87XG4gICAgfVxuICB9XG4gIHJlbmRlclN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICBpZiAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2VXaWR0aCkge1xuICAgICAgY29uc3QgeyBnbG9iYWxBbHBoYSB9ID0gY3R4O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAodGhpcy5saW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IHRoaXMubGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIH1cbiAgfVxuICBleGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIHBhdGggPyBjdHguc3Ryb2tlKHBhdGgpIDogY3R4LnN0cm9rZSgpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gIH1cbn07XG4vKipcbiAqIERlZmF1bHRzIGZvciBzdHlsZSBwcm9wZXJ0aWVzLiBOb3RlIHRoYXQgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGUgcG9zaXRpb25cbiAqIGFuZCBzaGFwZSBvZiB0aGUgbm9kZSBhcmUgbm90IGNvbnNpZGVyZWQgc3R5bGUgcHJvcGVydGllcywgZm9yIGV4YW1wbGU6XG4gKiBgeGAsIGB5YCwgYHdpZHRoYCwgYGhlaWdodGAsIGByYWRpdXNgLCBgcm90YXRpb25gLCBldGMuXG4gKiBDYW4gYmUgdXNlZCB0byByZXNldCB0byB0aGUgb3JpZ2luYWwgc3R5bGluZyBhZnRlciBzb21lIGN1c3RvbSBzdHlsaW5nXG4gKiBoYXMgYmVlbiBhcHBsaWVkICh1c2luZyB0aGUgYHJlc3RvcmVPd25TdHlsZXNgIG1ldGhvZCkuXG4gKiBUaGVzZSBzdGF0aWMgZGVmYXVsdHMgYXJlIG1lYW50IHRvIGJlIGluaGVyaXRlZCBieSBzdWJjbGFzc2VzLlxuICovXG5fU2hhcGUuZGVmYXVsdFN0eWxlcyA9IHtcbiAgZmlsbDogXCJibGFja1wiLFxuICBzdHJva2U6IHZvaWQgMCxcbiAgc3Ryb2tlV2lkdGg6IDAsXG4gIGxpbmVEYXNoOiB2b2lkIDAsXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICBsaW5lQ2FwOiB2b2lkIDAsXG4gIGxpbmVKb2luOiB2b2lkIDAsXG4gIG9wYWNpdHk6IDEsXG4gIGZpbGxTaGFkb3c6IHZvaWQgMFxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovLCBjaGFuZ2VDYjogKHMpID0+IHMub25GaWxsQ2hhbmdlKCkgfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVDYXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lSm9pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcIm1pdGVyTGltaXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAyIC8qIE1JTk9SICovLFxuICAgIGNvbnZlcnRvcjogKHYpID0+IGNsYW1wKDAsIHYsIDEpXG4gIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLywgY2hlY2tEaXJ0eU9uQXNzaWdubWVudDogdHJ1ZSB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJmaWxsU2hhZG93XCIsIDIpO1xudmFyIFNoYXBlID0gX1NoYXBlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9saW5lLnRzXG52YXIgTGluZSA9IGNsYXNzIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLngxID0gMDtcbiAgICB0aGlzLnkxID0gMDtcbiAgICB0aGlzLngyID0gMDtcbiAgICB0aGlzLnkyID0gMDtcbiAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcbiAgfVxuICBzZXQgeCh2YWx1ZSkge1xuICAgIHRoaXMueDEgPSB2YWx1ZTtcbiAgICB0aGlzLngyID0gdmFsdWU7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzLnkxID0gdmFsdWU7XG4gICAgdGhpcy55MiA9IHZhbHVlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBuZXcgQkJveChcbiAgICAgIE1hdGgubWluKHRoaXMueDEsIHRoaXMueDIpLFxuICAgICAgTWF0aC5taW4odGhpcy55MSwgdGhpcy55MiksXG4gICAgICBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSksXG4gICAgICBNYXRoLmFicyh0aGlzLnkyIC0gdGhpcy55MSlcbiAgICApO1xuICB9XG4gIGlzUG9pbnRJblBhdGgocHgsIHB5KSB7XG4gICAgaWYgKHRoaXMueDEgPT09IHRoaXMueDIgfHwgdGhpcy55MSA9PT0gdGhpcy55Mikge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRyYW5zZm9ybVBvaW50KHB4LCBweSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCQm94KCkuY2xvbmUoKS5ncm93KHRoaXMuc3Ryb2tlV2lkdGggLyAyKS5jb250YWluc1BvaW50KHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHB4LCBweSkge1xuICAgIGNvbnN0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGxpbmVEaXN0YW5jZVNxdWFyZWQocHgsIHB5LCB4MSwgeTEsIHgyLCB5MiwgSW5maW5pdHkpO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzLCBkZXZpY2VQaXhlbFJhdGlvIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4KTtcbiAgICBsZXQgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcbiAgICBpZiAoeDEgPT09IHgyKSB7XG4gICAgICBjb25zdCB7IHN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoeDEgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBNYXRoLnRydW5jKHN0cm9rZVdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbykgJSAyIC8gKGRldmljZVBpeGVsUmF0aW8gKiAyKTtcbiAgICAgIHgxID0geDtcbiAgICAgIHgyID0geDtcbiAgICB9IGVsc2UgaWYgKHkxID09PSB5Mikge1xuICAgICAgY29uc3QgeyBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHkxICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgTWF0aC50cnVuYyhzdHJva2VXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8pICUgMiAvIChkZXZpY2VQaXhlbFJhdGlvICogMik7XG4gICAgICB5MSA9IHk7XG4gICAgICB5MiA9IHk7XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIHRoaXMuZmlsbFN0cm9rZShjdHgpO1xuICAgIHRoaXMuZmlsbFNoYWRvdz8ubWFya0NsZWFuKCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbn07XG5MaW5lLmNsYXNzTmFtZSA9IFwiTGluZVwiO1xuTGluZS5kZWZhdWx0U3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2hhcGUuZGVmYXVsdFN0eWxlcywge1xuICBmaWxsOiB2b2lkIDAsXG4gIHN0cm9rZVdpZHRoOiAxXG59KTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ4MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ5MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ4MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ5MlwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jYW52YXMudXRpbC50c1xuZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dCh3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dChcIjJkXCIpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2xydUNhY2hlLnRzXG52YXIgTFJVQ2FjaGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1heENhY2hlU2l6ZSA9IDUpIHtcbiAgICB0aGlzLm1heENhY2hlU2l6ZSA9IG1heENhY2hlU2l6ZTtcbiAgICB0aGlzLnN0b3JlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgaWYgKCF0aGlzLnN0b3JlLmhhcyhrZXkpKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBoaXQgPSB0aGlzLnN0b3JlLmdldChrZXkpO1xuICAgIHRoaXMuc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5zdG9yZS5zZXQoa2V5LCBoaXQpO1xuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmhhcyhrZXkpO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdG9yZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgaWYgKHRoaXMuc3RvcmUuc2l6ZSA+IHRoaXMubWF4Q2FjaGVTaXplKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuc3RvcmUua2V5cygpO1xuICAgICAgbGV0IGV2aWN0Q291bnQgPSB0aGlzLnN0b3JlLnNpemUgLSB0aGlzLm1heENhY2hlU2l6ZTtcbiAgICAgIHdoaWxlIChldmljdENvdW50ID4gMCkge1xuICAgICAgICBjb25zdCBldmljdEtleUl0ZXJhdG9yID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoIWV2aWN0S2V5SXRlcmF0b3IuZG9uZSkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGVsZXRlKGV2aWN0S2V5SXRlcmF0b3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGV2aWN0Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc3RvcmUuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZXh0TWVhc3VyZXIudHNcbnZhciBDYWNoZWRUZXh0TWVhc3VyZXJQb29sID0gY2xhc3Mge1xuICAvLyBNZWFzdXJlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcHJvdmlkZWQgdGV4dCwgaGFuZGxpbmcgbXVsdGlsaW5lIGlmIG5lZWRlZC5cbiAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSB0aGlzLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQodGV4dCk7XG4gIH1cbiAgc3RhdGljIG1lYXN1cmVMaW5lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gdGhpcy5nZXRNZWFzdXJlcihvcHRpb25zKTtcbiAgICByZXR1cm4gdGV4dE1lYXN1cmVyLm1lYXN1cmVMaW5lcyh0ZXh0KTtcbiAgfVxuICAvLyBHZXRzIGEgVGV4dE1lYXN1cmVyIGluc3RhbmNlLCBjb25maWd1cmluZyB0ZXh0IGFsaWdubWVudCBhbmQgYmFzZWxpbmUgaWYgcHJvdmlkZWQuXG4gIHN0YXRpYyBnZXRNZWFzdXJlcihvcHRpb25zKSB7XG4gICAgY29uc3QgZm9udCA9IHR5cGVvZiBvcHRpb25zLmZvbnQgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmZvbnQgOiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKG9wdGlvbnMuZm9udCk7XG4gICAgY29uc3Qga2V5ID0gYCR7Zm9udH0tJHtvcHRpb25zLnRleHRBbGlnbiA/PyBcInN0YXJ0XCJ9LSR7b3B0aW9ucy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCJ9YDtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZU1hcC5nZXQoa2V5KSA/PyB0aGlzLmNyZWF0ZUZvbnRNZWFzdXJlcihmb250LCBvcHRpb25zLCBrZXkpO1xuICB9XG4gIC8vIENyZWF0ZXMgb3IgcmV0cmlldmVzIGEgVGV4dE1lYXN1cmVyIGluc3RhbmNlIGZvciBhIHNwZWNpZmljIGZvbnQuXG4gIHN0YXRpYyBjcmVhdGVGb250TWVhc3VyZXIoZm9udCwgb3B0aW9ucywga2V5KSB7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dCgpO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ24gPz8gXCJzdGFydFwiO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRpb25zLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIjtcbiAgICBjb25zdCBtZWFzdXJlciA9IG5ldyBDYWNoZWRUZXh0TWVhc3VyZXIoY3R4LCBvcHRpb25zKTtcbiAgICB0aGlzLmluc3RhbmNlTWFwLnNldChrZXksIG1lYXN1cmVyKTtcbiAgICByZXR1cm4gbWVhc3VyZXI7XG4gIH1cbn07XG5DYWNoZWRUZXh0TWVhc3VyZXJQb29sLmluc3RhbmNlTWFwID0gbmV3IExSVUNhY2hlKDEwKTtcbnZhciBDYWNoZWRUZXh0TWVhc3VyZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgb3B0aW9ucykge1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIC8vIGNhY2hlZCB0ZXh0IG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWVhc3VyZU1hcCA9IG5ldyBMUlVDYWNoZSgxMDApO1xuICAgIGlmIChvcHRpb25zLnRleHRBbGlnbikge1xuICAgICAgY3R4LnRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRpb25zLnRleHRCYXNlbGluZTtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSB0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5mb250IDogVGV4dFV0aWxzLnRvRm9udFN0cmluZyhvcHRpb25zLmZvbnQpO1xuICAgIHRoaXMudGV4dE1lYXN1cmVyID0gbmV3IFNpbXBsZVRleHRNZWFzdXJlcihcbiAgICAgICh0KSA9PiB0aGlzLmNhY2hlZEN0eE1lYXN1cmVUZXh0KHQpLFxuICAgICAgb3B0aW9ucy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCJcbiAgICApO1xuICB9XG4gIHRleHRXaWR0aCh0ZXh0LCBlc3RpbWF0ZSkge1xuICAgIHJldHVybiB0aGlzLnRleHRNZWFzdXJlci50ZXh0V2lkdGgodGV4dCwgZXN0aW1hdGUpO1xuICB9XG4gIG1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQodGV4dCk7XG4gIH1cbiAgbWVhc3VyZUxpbmVzKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRleHQpO1xuICB9XG4gIGNhY2hlZEN0eE1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICBpZiAoIXRoaXMubWVhc3VyZU1hcC5oYXModGV4dCkpIHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgdGhpcy5tZWFzdXJlTWFwLnNldCh0ZXh0LCB7XG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50OiByYXdSZXN1bHQuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICAgIGVtSGVpZ2h0QXNjZW50OiByYXdSZXN1bHQuZW1IZWlnaHRBc2NlbnQsXG4gICAgICAgIGVtSGVpZ2h0RGVzY2VudDogcmF3UmVzdWx0LmVtSGVpZ2h0RGVzY2VudCxcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50OiByYXdSZXN1bHQuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveExlZnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94UmlnaHQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LFxuICAgICAgICBhbHBoYWJldGljQmFzZWxpbmU6IHJhd1Jlc3VsdC5hbHBoYWJldGljQmFzZWxpbmUsXG4gICAgICAgIGZvbnRCb3VuZGluZ0JveEFzY2VudDogcmF3UmVzdWx0LmZvbnRCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudDogcmF3UmVzdWx0LmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIGhhbmdpbmdCYXNlbGluZTogcmF3UmVzdWx0LmhhbmdpbmdCYXNlbGluZSxcbiAgICAgICAgaWRlb2dyYXBoaWNCYXNlbGluZTogcmF3UmVzdWx0LmlkZW9ncmFwaGljQmFzZWxpbmUsXG4gICAgICAgIHdpZHRoOiByYXdSZXN1bHQud2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlTWFwLmdldCh0ZXh0KTtcbiAgfVxufTtcbnZhciBUZXh0VXRpbHMgPSBjbGFzcyB7XG4gIHN0YXRpYyB0b0ZvbnRTdHJpbmcoeyBmb250U2l6ZSA9IDEwLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIGxpbmVIZWlnaHQgfSkge1xuICAgIGxldCBmb250U3RyaW5nID0gXCJcIjtcbiAgICBpZiAoZm9udFN0eWxlKSB7XG4gICAgICBmb250U3RyaW5nICs9IGAke2ZvbnRTdHlsZX0gYDtcbiAgICB9XG4gICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYCR7Zm9udFdlaWdodH0gYDtcbiAgICB9XG4gICAgZm9udFN0cmluZyArPSBgJHtmb250U2l6ZX1weGA7XG4gICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYC8ke2xpbmVIZWlnaHR9cHhgO1xuICAgIH1cbiAgICBmb250U3RyaW5nICs9IGAgJHtmb250RmFtaWx5fWA7XG4gICAgcmV0dXJuIGZvbnRTdHJpbmcudHJpbSgpO1xuICB9XG4gIHN0YXRpYyBnZXRMaW5lSGVpZ2h0KGZvbnRTaXplKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChmb250U2l6ZSAqIHRoaXMuZGVmYXVsdExpbmVIZWlnaHQpO1xuICB9XG4gIC8vIERldGVybWluZXMgdmVydGljYWwgb2Zmc2V0IG1vZGlmaWVyIGJhc2VkIG9uIHRleHQgYmFzZWxpbmUuXG4gIHN0YXRpYyBnZXRWZXJ0aWNhbE1vZGlmaWVyKHRleHRCYXNlbGluZSkge1xuICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICBjYXNlIFwiaGFuZ2luZ1wiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgIGNhc2UgXCJhbHBoYWJldGljXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBjYXNlIFwiaWRlb2dyYXBoaWNcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxufTtcblRleHRVdGlscy5FbGxpcHNpc0NoYXIgPSBcIlxcdTIwMjZcIjtcbi8vIFJlcHJlc2VudGF0aW9uIGZvciB0ZXh0IGNsaXBwaW5nLlxuVGV4dFV0aWxzLmRlZmF1bHRMaW5lSGVpZ2h0ID0gMS4xNTtcbi8vIE5vcm1hbGx5IGJldHdlZW4gMS4xIGFuZCAxLjJcblRleHRVdGlscy5saW5lU3BsaXR0ZXIgPSAvXFxyP1xcbi9nO1xudmFyIFNpbXBsZVRleHRNZWFzdXJlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVhc3VyZVRleHRGbiwgdGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCIpIHtcbiAgICB0aGlzLm1lYXN1cmVUZXh0Rm4gPSBtZWFzdXJlVGV4dEZuO1xuICAgIHRoaXMudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgIC8vIGxvY2FsIGNoYXJzIHdpZHRoIGNhY2hlIHBlciBUZXh0TWVhc3VyZXJcbiAgICB0aGlzLmNoYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8vIE1lYXN1cmVzIG1ldHJpY3MgZm9yIGEgc2luZ2xlIGxpbmUgb2YgdGV4dC5cbiAgZ2V0TWV0cmljcyh0ZXh0KSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWVhc3VyZVRleHRGbih0ZXh0KTtcbiAgICBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPSBtLmVtSGVpZ2h0QXNjZW50KTtcbiAgICBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA9IG0uZW1IZWlnaHREZXNjZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICBoZWlnaHQ6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIGxpbmVIZWlnaHQ6IG0uZm9udEJvdW5kaW5nQm94QXNjZW50ICsgbS5mb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgb2Zmc2V0VG9wOiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgb2Zmc2V0TGVmdDogbS5hY3R1YWxCb3VuZGluZ0JveExlZnRcbiAgICB9O1xuICB9XG4gIC8vIENhbGN1bGF0ZXMgYWdncmVnYXRlZCBtZXRyaWNzIGZvciBtdWx0aWxpbmUgdGV4dC5cbiAgZ2V0TXVsdGlsaW5lTWV0cmljcyhsaW5lcykge1xuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGhlaWdodCA9IDA7XG4gICAgbGV0IG9mZnNldFRvcCA9IDA7XG4gICAgbGV0IG9mZnNldExlZnQgPSAwO1xuICAgIGxldCBiYXNlbGluZURpc3RhbmNlID0gMDtcbiAgICBjb25zdCB2ZXJ0aWNhbE1vZGlmaWVyID0gVGV4dFV0aWxzLmdldFZlcnRpY2FsTW9kaWZpZXIodGhpcy50ZXh0QmFzZWxpbmUpO1xuICAgIGNvbnN0IGxpbmVNZXRyaWNzID0gW107XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBsZW5ndGgyID0gbGluZXMubGVuZ3RoO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgbSA9IHRoaXMubWVhc3VyZVRleHRGbihsaW5lKTtcbiAgICAgIG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID8/IChtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA9IG0uZW1IZWlnaHRBc2NlbnQpO1xuICAgICAgbS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID8/IChtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQgPSBtLmVtSGVpZ2h0RGVzY2VudCk7XG4gICAgICBpZiAod2lkdGggPCBtLndpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gbS53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRMZWZ0IDwgbS5hY3R1YWxCb3VuZGluZ0JveExlZnQpIHtcbiAgICAgICAgb2Zmc2V0TGVmdCA9IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGhlaWdodCArPSBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgICBvZmZzZXRUb3AgKz0gbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VsaW5lRGlzdGFuY2UgKz0gbS5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IGxlbmd0aDIgLSAxKSB7XG4gICAgICAgIGhlaWdodCArPSBtLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VsaW5lRGlzdGFuY2UgKz0gbS5mb250Qm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgfVxuICAgICAgbGluZU1ldHJpY3MucHVzaCh7XG4gICAgICAgIHRleHQ6IGxpbmUsXG4gICAgICAgIHdpZHRoOiBtLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgbGluZUhlaWdodDogbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgKyBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIG9mZnNldFRvcDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgb2Zmc2V0TGVmdDogbS5hY3R1YWxCb3VuZGluZ0JveExlZnRcbiAgICAgIH0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgaGVpZ2h0ICs9IGJhc2VsaW5lRGlzdGFuY2U7XG4gICAgb2Zmc2V0VG9wICs9IGJhc2VsaW5lRGlzdGFuY2UgKiB2ZXJ0aWNhbE1vZGlmaWVyO1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0TGVmdCwgbGluZU1ldHJpY3MgfTtcbiAgfVxuICB0ZXh0V2lkdGgodGV4dCwgZXN0aW1hdGUpIHtcbiAgICBpZiAoZXN0aW1hdGUpIHtcbiAgICAgIGxldCBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXN0aW1hdGVkV2lkdGggKz0gdGhpcy50ZXh0V2lkdGgodGV4dC5jaGFyQXQoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVzdGltYXRlZFdpZHRoO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZWFzdXJlVGV4dEZuKHRleHQpLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGFyTWFwLmdldCh0ZXh0KSA/PyB0aGlzLmNoYXJXaWR0aCh0ZXh0KTtcbiAgfVxuICBtZWFzdXJlVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWV0cmljcyh0ZXh0KTtcbiAgfVxuICAvLyBNZWFzdXJlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcHJvdmlkZWQgdGV4dCwgaGFuZGxpbmcgbXVsdGlsaW5lIGlmIG5lZWRlZC5cbiAgbWVhc3VyZUxpbmVzKHRleHQpIHtcbiAgICBjb25zdCBsaW5lcyA9IHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiID8gdGV4dC5zcGxpdChUZXh0VXRpbHMubGluZVNwbGl0dGVyKSA6IHRleHQ7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlsaW5lTWV0cmljcyhsaW5lcyk7XG4gIH1cbiAgY2hhcldpZHRoKGNoYXIpIHtcbiAgICBjb25zdCB7IHdpZHRoIH0gPSB0aGlzLm1lYXN1cmVUZXh0Rm4oY2hhcik7XG4gICAgdGhpcy5jaGFyTWFwLnNldChjaGFyLCB3aWR0aCk7XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS90ZXh0LnRzXG5mdW5jdGlvbiBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDMgLyogTUFKT1IgKi8sIGNoYW5nZUNiIH0gPSBvcHRzID8/IHt9O1xuICByZXR1cm4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXcsIHR5cGU6IFwiZm9udFwiLCBjaGFuZ2VDYiB9KTtcbn1cbnZhciBfVGV4dCA9IGNsYXNzIF9UZXh0IGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLnRleHRBbGlnbiA9IF9UZXh0LmRlZmF1bHRTdHlsZXMudGV4dEFsaWduO1xuICAgIHRoaXMudGV4dEJhc2VsaW5lID0gX1RleHQuZGVmYXVsdFN0eWxlcy50ZXh0QmFzZWxpbmU7XG4gIH1cbiAgb25UZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMubGluZXMgPSB0aGlzLnRleHQ/LnNwbGl0KFwiXFxuXCIpLm1hcCgocykgPT4gcy50cmltKCkpID8/IFtdO1xuICB9XG4gIHN0YXRpYyBjb21wdXRlQkJveChsaW5lcywgeCwgeSwgb3B0cykge1xuICAgIGNvbnN0IHsgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLm1lYXN1cmVMaW5lcyhsaW5lcywgb3B0cyk7XG4gICAgcmV0dXJuIG5ldyBCQm94KHggLSBvZmZzZXRMZWZ0LCB5IC0gb2Zmc2V0VG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIGxpbmVzLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9ID0gdGhpcztcbiAgICByZXR1cm4gX1RleHQuY29tcHV0ZUJCb3gobGluZXMsIHgsIHksIHsgZm9udDogdGhpcywgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICByZXR1cm4gYmJveCA/IGJib3guY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KSA6IGZhbHNlO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoIHx8ICF0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgpO1xuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHBpeGVsUmF0aW8gfSA9IHRoaXMubGF5ZXJNYW5hZ2VyLmNhbnZhcztcbiAgICBjdHguZm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmcodGhpcyk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICBpZiAoZmlsbCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5maWxsT3BhY2l0eTtcbiAgICAgIGNvbnN0IHsgZmlsbFNoYWRvdyB9ID0gdGhpcztcbiAgICAgIGlmIChmaWxsU2hhZG93Py5lbmFibGVkKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGZpbGxTaGFkb3cuY29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gZmlsbFNoYWRvdy54T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBmaWxsU2hhZG93LnlPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGZpbGxTaGFkb3cuYmx1ciAqIHBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckxpbmVzKChsaW5lLCB4LCB5KSA9PiBjdHguZmlsbFRleHQobGluZSwgeCwgeSkpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlICYmIHN0cm9rZVdpZHRoKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgY29uc3QgeyBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGxpbmVDYXAsIGxpbmVKb2luIH0gPSB0aGlzO1xuICAgICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAobGluZUpvaW4pIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckxpbmVzKChsaW5lLCB4LCB5KSA9PiBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5KSk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG4gIHJlbmRlckxpbmVzKHJlbmRlckNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBsaW5lcywgeCwgeSB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0ID8/IFRleHRVdGlscy5nZXRMaW5lSGVpZ2h0KHRoaXMuZm9udFNpemUpO1xuICAgIGxldCBvZmZzZXRZID0gKGxpbmVIZWlnaHQgLSBsaW5lSGVpZ2h0ICogbGluZXMubGVuZ3RoKSAqIFRleHRVdGlscy5nZXRWZXJ0aWNhbE1vZGlmaWVyKHRoaXMudGV4dEJhc2VsaW5lKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIHJlbmRlckNhbGxiYWNrKGxpbmUsIHgsIHkgKyBvZmZzZXRZKTtcbiAgICAgIG9mZnNldFkgKz0gbGluZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgc2V0Rm9udChwcm9wcykge1xuICAgIHRoaXMuZm9udEZhbWlseSA9IHByb3BzLmZvbnRGYW1pbHk7XG4gICAgdGhpcy5mb250U2l6ZSA9IHByb3BzLmZvbnRTaXplO1xuICAgIHRoaXMuZm9udFN0eWxlID0gcHJvcHMuZm9udFN0eWxlO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHByb3BzLmZvbnRXZWlnaHQ7XG4gIH1cbiAgc2V0QWxpZ24ocHJvcHMpIHtcbiAgICB0aGlzLnRleHRBbGlnbiA9IHByb3BzLnRleHRBbGlnbjtcbiAgICB0aGlzLnRleHRCYXNlbGluZSA9IHByb3BzLnRleHRCYXNlbGluZTtcbiAgfVxufTtcbl9UZXh0LmNsYXNzTmFtZSA9IFwiVGV4dFwiO1xuLy8gVGhlIGRlZmF1bHQgbGluZSBzcGFjaW5nIGZvciBkb2N1bWVudCBlZGl0b3JzIGlzIHVzdWFsbHkgMS4xNVxuX1RleHQuZGVmYXVsdExpbmVIZWlnaHRSYXRpbyA9IDEuMTU7XG5fVGV4dC5kZWZhdWx0U3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2hhcGUuZGVmYXVsdFN0eWxlcywge1xuICB0ZXh0QWxpZ246IFwic3RhcnRcIixcbiAgZm9udFN0eWxlOiB2b2lkIDAsXG4gIGZvbnRXZWlnaHQ6IHZvaWQgMCxcbiAgZm9udFNpemU6IDEwLFxuICBmb250RmFtaWx5OiBcInNhbnMtc2VyaWZcIixcbiAgdGV4dEJhc2VsaW5lOiBcImFscGhhYmV0aWNcIlxufSk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgY2hhbmdlQ2I6IChvKSA9PiBvLm9uVGV4dENoYW5nZSgpIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lRm9udENoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lRm9udENoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ0ZXh0QmFzZWxpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcImxpbmVIZWlnaHRcIiwgMik7XG52YXIgVGV4dCA9IF9UZXh0O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2xhYmVsUGxhY2VtZW50LnRzXG5mdW5jdGlvbiBjaXJjbGVSZWN0T3ZlcmxhcChjLCB1bml0Q2VudGVyLCB4LCB5LCB3LCBoKSB7XG4gIGlmIChjLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN4ID0gYy54O1xuICBsZXQgY3kgPSBjLnk7XG4gIGlmICh1bml0Q2VudGVyICE9IG51bGwpIHtcbiAgICBjeCAtPSAodW5pdENlbnRlci54IC0gMC41KSAqIGMuc2l6ZTtcbiAgICBjeSAtPSAodW5pdENlbnRlci55IC0gMC41KSAqIGMuc2l6ZTtcbiAgfVxuICBsZXQgZWRnZVggPSBjeDtcbiAgaWYgKGN4IDwgeCkge1xuICAgIGVkZ2VYID0geDtcbiAgfSBlbHNlIGlmIChjeCA+IHggKyB3KSB7XG4gICAgZWRnZVggPSB4ICsgdztcbiAgfVxuICBsZXQgZWRnZVkgPSBjeTtcbiAgaWYgKGN5IDwgeSkge1xuICAgIGVkZ2VZID0geTtcbiAgfSBlbHNlIGlmIChjeSA+IHkgKyBoKSB7XG4gICAgZWRnZVkgPSB5ICsgaDtcbiAgfVxuICBjb25zdCBkeCA9IGN4IC0gZWRnZVg7XG4gIGNvbnN0IGR5ID0gY3kgLSBlZGdlWTtcbiAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHJldHVybiBkIDw9IGMuc2l6ZSAqIDAuNTtcbn1cbmZ1bmN0aW9uIHJlY3RSZWN0T3ZlcmxhcChyMSwgeDIsIHkyLCB3MiwgaDIpIHtcbiAgY29uc3QgeE92ZXJsYXAgPSByMS54ICsgcjEud2lkdGggPiB4MiAmJiByMS54IDwgeDIgKyB3MjtcbiAgY29uc3QgeU92ZXJsYXAgPSByMS55ICsgcjEuaGVpZ2h0ID4geTIgJiYgcjEueSA8IHkyICsgaDI7XG4gIHJldHVybiB4T3ZlcmxhcCAmJiB5T3ZlcmxhcDtcbn1cbmZ1bmN0aW9uIHJlY3RDb250YWluc1JlY3QocjEsIHIyeCwgcjJ5LCByMncsIHIyaCkge1xuICByZXR1cm4gcjJ4ICsgcjJ3IDwgcjEueCArIHIxLndpZHRoICYmIHIyeCA+IHIxLnggJiYgcjJ5ID4gcjEueSAmJiByMnkgKyByMmggPCByMS55ICsgcjEuaGVpZ2h0O1xufVxuZnVuY3Rpb24gaXNQb2ludExhYmVsRGF0dW0oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4LnBvaW50ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB4LmxhYmVsID09PSBcIm9iamVjdFwiO1xufVxudmFyIGxhYmVsUGxhY2VtZW50cyA9IHtcbiAgdG9wOiB7IHg6IDAsIHk6IC0xIH0sXG4gIGJvdHRvbTogeyB4OiAwLCB5OiAxIH0sXG4gIGxlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgcmlnaHQ6IHsgeDogMSwgeTogMCB9XG59O1xuZnVuY3Rpb24gcGxhY2VMYWJlbHMoZGF0YSwgYm91bmRzLCBwYWRkaW5nID0gNSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZGF0YSA9IGRhdGEubWFwKChkKSA9PiBkLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYi5wb2ludC5zaXplIC0gYS5wb2ludC5zaXplKSk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxhYmVscyA9IHJlc3VsdFtqXSA9IFtdO1xuICAgIGNvbnN0IGRhdHVtID0gZGF0YVtqXTtcbiAgICBpZiAoIShkYXR1bT8ubGVuZ3RoICYmIGRhdHVtWzBdLmxhYmVsKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbG4gPSBkYXR1bS5sZW5ndGg7IGluZGV4IDwgbG47IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGQgPSBkYXR1bVtpbmRleF07XG4gICAgICBjb25zdCB7IHBvaW50LCBsYWJlbCwgbWFya2VyIH0gPSBkO1xuICAgICAgY29uc3QgeyB0ZXh0LCB3aWR0aCwgaGVpZ2h0IH0gPSBsYWJlbDtcbiAgICAgIGNvbnN0IHIgPSBwb2ludC5zaXplICogMC41O1xuICAgICAgbGV0IGR4ID0gMDtcbiAgICAgIGxldCBkeSA9IDA7XG4gICAgICBpZiAociA+IDAgJiYgZC5wbGFjZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSBsYWJlbFBsYWNlbWVudHNbZC5wbGFjZW1lbnRdO1xuICAgICAgICBkeCA9ICh3aWR0aCAqIDAuNSArIHIgKyBwYWRkaW5nKSAqIHBsYWNlbWVudC54O1xuICAgICAgICBkeSA9IChoZWlnaHQgKiAwLjUgKyByICsgcGFkZGluZykgKiBwbGFjZW1lbnQueTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBwb2ludC54IC0gd2lkdGggKiAwLjUgKyBkeCAtICgobWFya2VyPy5jZW50ZXIueCA/PyAwLjUpIC0gMC41KSAqIHBvaW50LnNpemU7XG4gICAgICBjb25zdCB5ID0gcG9pbnQueSAtIGhlaWdodCAqIDAuNSArIGR5IC0gKChtYXJrZXI/LmNlbnRlci55ID8/IDAuNSkgLSAwLjUpICogcG9pbnQuc2l6ZTtcbiAgICAgIGNvbnN0IHdpdGhpbkJvdW5kcyA9ICFib3VuZHMgfHwgcmVjdENvbnRhaW5zUmVjdChib3VuZHMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgaWYgKCF3aXRoaW5Cb3VuZHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVybGFwUG9pbnRzID0gZGF0YS5zb21lKFxuICAgICAgICAoZGF0YURhdHVtcykgPT4gZGF0YURhdHVtcy5zb21lKFxuICAgICAgICAgIChkYXRhRGF0dW0pID0+IGNpcmNsZVJlY3RPdmVybGFwKGRhdGFEYXR1bS5wb2ludCwgZGF0YURhdHVtLm1hcmtlcj8uY2VudGVyLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgaWYgKG92ZXJsYXBQb2ludHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVybGFwTGFiZWxzID0gcmVzdWx0LnNvbWUoKGwyKSA9PiBsMi5zb21lKChsMykgPT4gcmVjdFJlY3RPdmVybGFwKGwzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSkpO1xuICAgICAgaWYgKG92ZXJsYXBMYWJlbHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsYWJlbHMucHVzaCh7IGluZGV4LCB0ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkYXR1bTogZCB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGF4aXNMYWJlbHNPdmVybGFwKGRhdGEsIHBhZGRpbmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGRhdHVtID0gZGF0YVtpbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgbGFiZWw6IHsgdGV4dCB9XG4gICAgfSA9IGRhdHVtO1xuICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRhdHVtLmxhYmVsO1xuICAgIHdpZHRoICs9IHBhZGRpbmcgPz8gMDtcbiAgICBoZWlnaHQgKz0gcGFkZGluZyA/PyAwO1xuICAgIGlmIChyZXN1bHQuc29tZSgobCkgPT4gcmVjdFJlY3RPdmVybGFwKGwsIHgsIHksIHdpZHRoLCBoZWlnaHQpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHsgaW5kZXgsIHRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRhdHVtIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9lcXVhbC50c1xuZnVuY3Rpb24gYXJlQXJyYXlOdW1iZXJzRXF1YWwoYXJyQSwgYXJyQikge1xuICByZXR1cm4gYXJyQS5sZW5ndGggPT09IGFyckIubGVuZ3RoICYmIGFyckEuZXZlcnkoKGl0ZW0sIGkpID0+IE51bWJlcihpdGVtKSA9PT0gTnVtYmVyKGFyckJbaV0pKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9wcm94eS50c1xuZnVuY3Rpb24gUHJveHlQcm9wZXJ0eShwcm94eVBhdGgsIGNvbmZpZ01ldGFkYXRhKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IGlzQXJyYXkocHJveHlQYXRoKSA/IHByb3h5UGF0aCA6IHByb3h5UGF0aC5zcGxpdChcIi5cIik7XG4gIGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgW3Byb3BlcnR5XSA9IHBhdGhBcnJheTtcbiAgICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICAgKHRhcmdldCwgXywgdmFsdWUpID0+IHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZSxcbiAgICAgICh0YXJnZXQpID0+IHRhcmdldFtwcm9wZXJ0eV0sXG4gICAgICBjb25maWdNZXRhZGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAodGFyZ2V0LCBfLCB2YWx1ZSkgPT4gc2V0UGF0aCh0YXJnZXQsIHBhdGhBcnJheSwgdmFsdWUpLFxuICAgICh0YXJnZXQpID0+IGdldFBhdGgodGFyZ2V0LCBwYXRoQXJyYXkpLFxuICAgIGNvbmZpZ01ldGFkYXRhXG4gICk7XG59XG5mdW5jdGlvbiBQcm94eU9uV3JpdGUocHJveHlQcm9wZXJ0eSkge1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIF8sIHZhbHVlKSA9PiB0YXJnZXRbcHJveHlQcm9wZXJ0eV0gPSB2YWx1ZSk7XG59XG5mdW5jdGlvbiBQcm94eVByb3BlcnR5T25Xcml0ZShjaGlsZE5hbWUsIGNoaWxkUHJvcGVydHkpIHtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB0YXJnZXRbY2hpbGROYW1lXVtjaGlsZFByb3BlcnR5ID8/IGtleV0gPSB2YWx1ZSk7XG59XG5mdW5jdGlvbiBBY3Rpb25PblNldChvcHRzKSB7XG4gIGNvbnN0IHsgbmV3VmFsdWU6IG5ld1ZhbHVlRm4sIG9sZFZhbHVlOiBvbGRWYWx1ZUZuLCBjaGFuZ2VWYWx1ZTogY2hhbmdlVmFsdWVGbiB9ID0gb3B0cztcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgodGFyZ2V0LCBfLCBuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBvbGRWYWx1ZUZuPy5jYWxsKHRhcmdldCwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgbmV3VmFsdWVGbj8uY2FsbCh0YXJnZXQsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNoYW5nZVZhbHVlRm4/LmNhbGwodGFyZ2V0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gT2JzZXJ2ZUNoYW5nZXMob2JzZXJ2ZXJGbikge1xuICByZXR1cm4gYWRkT2JzZXJ2ZXJUb0luc3RhbmNlUHJvcGVydHkob2JzZXJ2ZXJGbik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc3RhdGVNYWNoaW5lLnRzXG52YXIgZGVidWdDb2xvciA9IFwiY29sb3I6IGdyZWVuXCI7XG52YXIgZGVidWdRdWlldENvbG9yID0gXCJjb2xvcjogZ3JleVwiO1xudmFyIF9TdGF0ZU1hY2hpbmUgPSBjbGFzcyBfU3RhdGVNYWNoaW5lIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdFN0YXRlLCBzdGF0ZXMsIGVudGVyRWFjaCkge1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgIHRoaXMuZW50ZXJFYWNoID0gZW50ZXJFYWNoO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJhbmltYXRpb25cIik7XG4gICAgdGhpcy5zdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLmRlYnVnKGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8IGluaXQgLT4gJHtkZWZhdWx0U3RhdGV9YCwgZGVidWdDb2xvcik7XG4gIH1cbiAgdHJhbnNpdGlvbihldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHNob3VsZFRyYW5zaXRpb25TZWxmID0gdGhpcy50cmFuc2l0aW9uQ2hpbGQoZXZlbnQsIGRhdGEpO1xuICAgIGlmICghc2hvdWxkVHJhbnNpdGlvblNlbGYgfHwgdGhpcy5zdGF0ZSA9PT0gX1N0YXRlTWFjaGluZS5jaGlsZCB8fCB0aGlzLnN0YXRlID09PSBfU3RhdGVNYWNoaW5lLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZUNvbmZpZyA9IHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVdO1xuICAgIGxldCBkZXN0aW5hdGlvbiA9IGN1cnJlbnRTdGF0ZUNvbmZpZ1tldmVudF07XG4gICAgY29uc3QgZGVidWdQcmVmaXggPSBgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+ICR7ZXZlbnR9IC0+YDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXN0aW5hdGlvbikpIHtcbiAgICAgIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24uZmluZCgodHJhbnNpdGlvbikgPT4ge1xuICAgICAgICBpZiAoIXRyYW5zaXRpb24uZ3VhcmQpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdHJhbnNpdGlvbi5ndWFyZChkYXRhKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgIHRoaXMuZGVidWcoYCR7ZGVidWdQcmVmaXh9ICR7dHJhbnNpdGlvbi50YXJnZXR9IChndWFyZGVkKWAsIGRlYnVnUXVpZXRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIgJiYgIShkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpICYmIGRlc3RpbmF0aW9uLmd1YXJkICYmICFkZXN0aW5hdGlvbi5ndWFyZChkYXRhKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHtkZXN0aW5hdGlvbi50YXJnZXR9IChndWFyZGVkKWAsIGRlYnVnUXVpZXRDb2xvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGVzdGluYXRpb24pIHtcbiAgICAgIHRoaXMuZGVidWcoYCR7ZGVidWdQcmVmaXh9ICR7dGhpcy5zdGF0ZX1gLCBkZWJ1Z1F1aWV0Q29sb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvblN0YXRlID0gdGhpcy5nZXREZXN0aW5hdGlvblN0YXRlKGRlc3RpbmF0aW9uKTtcbiAgICBjb25zdCBleGl0Rm4gPSBkZXN0aW5hdGlvblN0YXRlID09PSB0aGlzLnN0YXRlID8gdm9pZCAwIDogY3VycmVudFN0YXRlQ29uZmlnLm9uRXhpdDtcbiAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke2Rlc3RpbmF0aW9uU3RhdGV9YCwgZGVidWdDb2xvcik7XG4gICAgdGhpcy5zdGF0ZSA9IGRlc3RpbmF0aW9uU3RhdGU7XG4gICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkZXN0aW5hdGlvbihkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJvYmplY3RcIiAmJiAhKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmFjdGlvbj8uKGRhdGEpO1xuICAgIH1cbiAgICBleGl0Rm4/LigpO1xuICAgIHRoaXMuZW50ZXJFYWNoPy4oY3VycmVudFN0YXRlLCBkZXN0aW5hdGlvblN0YXRlKTtcbiAgICBpZiAoZGVzdGluYXRpb25TdGF0ZSAhPT0gY3VycmVudFN0YXRlICYmIGRlc3RpbmF0aW9uU3RhdGUgIT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgJiYgZGVzdGluYXRpb25TdGF0ZSAhPT0gX1N0YXRlTWFjaGluZS5wYXJlbnQpIHtcbiAgICAgIHRoaXMuc3RhdGVzW2Rlc3RpbmF0aW9uU3RhdGVdLm9uRW50ZXI/LihjdXJyZW50U3RhdGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuICBpcyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBfU3RhdGVNYWNoaW5lLmNoaWxkICYmIHRoaXMuY2hpbGRTdGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdGF0ZS5pcyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSB2YWx1ZTtcbiAgfVxuICByZXNldEhpZXJhcmNoeSgpIHtcbiAgICB0aGlzLmRlYnVnKFxuICAgICAgYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiBbcmVzZXRIaWVyYXJjaHldIC0+ICR7dGhpcy5kZWZhdWx0U3RhdGV9YCxcbiAgICAgIFwiY29sb3I6IGdyZWVuXCJcbiAgICApO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgfVxuICB0cmFuc2l0aW9uQ2hpbGQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX1N0YXRlTWFjaGluZS5jaGlsZCB8fCAhdGhpcy5jaGlsZFN0YXRlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhpcy5jaGlsZFN0YXRlLnRyYW5zaXRpb24oZXZlbnQsIGRhdGEpO1xuICAgIGlmICghdGhpcy5jaGlsZFN0YXRlLmlzKF9TdGF0ZU1hY2hpbmUucGFyZW50KSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHRoaXMuZGVidWcoYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiAke2V2ZW50fSAtPiAke3RoaXMuZGVmYXVsdFN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlXS5vbkVudGVyPy4oKTtcbiAgICB0aGlzLmNoaWxkU3RhdGUucmVzZXRIaWVyYXJjaHkoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25TdGF0ZShkZXN0aW5hdGlvbikge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3RhdGUgPSBkZXN0aW5hdGlvbjtcbiAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkge1xuICAgICAgdGhpcy5jaGlsZFN0YXRlID0gZGVzdGluYXRpb247XG4gICAgICBzdGF0ZSA9IF9TdGF0ZU1hY2hpbmUuY2hpbGQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbi50YXJnZXQgaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSB7XG4gICAgICAgIHRoaXMuY2hpbGRTdGF0ZSA9IGRlc3RpbmF0aW9uLnRhcmdldDtcbiAgICAgICAgc3RhdGUgPSBfU3RhdGVNYWNoaW5lLmNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBkZXN0aW5hdGlvbi50YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcbl9TdGF0ZU1hY2hpbmUuY2hpbGQgPSBcIl9fY2hpbGRcIjtcbl9TdGF0ZU1hY2hpbmUucGFyZW50ID0gXCJfX3BhcmVudFwiO1xudmFyIFN0YXRlTWFjaGluZSA9IF9TdGF0ZU1hY2hpbmU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGV4dFdyYXBwZXIudHNcbnZhciBUZXh0V3JhcHBlciA9IGNsYXNzIHtcbiAgc3RhdGljIHdyYXBUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwTGluZXModGV4dCwgb3B0aW9ucykuam9pbihcIlxcblwiKTtcbiAgfVxuICBzdGF0aWMgd3JhcExpbmVzKHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbGlwcGVkUmVzdWx0ID0gdGhpcy50ZXh0V3JhcCh0ZXh0LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5vdmVyZmxvdyA9PT0gXCJoaWRlXCIgJiYgY2xpcHBlZFJlc3VsdC5zb21lKChsKSA9PiBsLmVuZHNXaXRoKFRleHRVdGlscy5FbGxpcHNpc0NoYXIpKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gY2xpcHBlZFJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXBwZW5kRWxsaXBzaXModGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1suLF17MSw1fSQvLCBcIlwiKSArIFRleHRVdGlscy5FbGxpcHNpc0NoYXI7XG4gIH1cbiAgc3RhdGljIHRydW5jYXRlTGluZSh0ZXh0LCBtZWFzdXJlciwgbWF4V2lkdGgsIGVsbGlwc2lzRm9yY2UpIHtcbiAgICBjb25zdCBlbGxpcHNpc1dpZHRoID0gbWVhc3VyZXIudGV4dFdpZHRoKFRleHRVdGlscy5FbGxpcHNpc0NoYXIpO1xuICAgIGxldCBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhcldpZHRoID0gbWVhc3VyZXIudGV4dFdpZHRoKHRleHQuY2hhckF0KGkpKTtcbiAgICAgIGlmIChlc3RpbWF0ZWRXaWR0aCArIGNoYXJXaWR0aCA+IG1heFdpZHRoKVxuICAgICAgICBicmVhaztcbiAgICAgIGVzdGltYXRlZFdpZHRoICs9IGNoYXJXaWR0aDtcbiAgICB9XG4gICAgaWYgKHRleHQubGVuZ3RoID09PSBpICYmICghZWxsaXBzaXNGb3JjZSB8fCBlc3RpbWF0ZWRXaWR0aCArIGVsbGlwc2lzV2lkdGggPD0gbWF4V2lkdGgpKSB7XG4gICAgICByZXR1cm4gZWxsaXBzaXNGb3JjZSA/IHRleHQgKyBUZXh0VXRpbHMuRWxsaXBzaXNDaGFyIDogdGV4dDtcbiAgICB9XG4gICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSkudHJpbUVuZCgpO1xuICAgIHdoaWxlICh0ZXh0Lmxlbmd0aCAmJiBtZWFzdXJlci50ZXh0V2lkdGgodGV4dCkgKyBlbGxpcHNpc1dpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKS50cmltRW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0ICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcjtcbiAgfVxuICBzdGF0aWMgdGV4dFdyYXAodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChUZXh0VXRpbHMubGluZVNwbGl0dGVyKTtcbiAgICBjb25zdCBtZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudGV4dFdyYXAgPT09IFwibmV2ZXJcIikge1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcCgobGluZSkgPT4gdGhpcy50cnVuY2F0ZUxpbmUobGluZS50cmltRW5kKCksIG1lYXN1cmVyLCBvcHRpb25zLm1heFdpZHRoKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHdyYXBIeXBoZW5hdGUgPSBvcHRpb25zLnRleHRXcmFwID09PSBcImh5cGhlbmF0ZVwiO1xuICAgIGNvbnN0IHdyYXBPblNwYWNlID0gb3B0aW9ucy50ZXh0V3JhcCA9PSBudWxsIHx8IG9wdGlvbnMudGV4dFdyYXAgPT09IFwib24tc3BhY2VcIjtcbiAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBsaW5lID0gbGluZS50cmltRW5kKCk7XG4gICAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgZXN0aW1hdGVkV2lkdGggPSAwLCBsYXN0U3BhY2VJbmRleCA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBsaW5lLmNoYXJBdChpKTtcbiAgICAgICAgZXN0aW1hdGVkV2lkdGggKz0gbWVhc3VyZXIudGV4dFdpZHRoKGNoYXIpO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCIgXCIpIHtcbiAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVzdGltYXRlZFdpZHRoID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgobGluZS5zbGljZSgwLCBpICsgMSkpO1xuICAgICAgICAgIGlmIChhY3R1YWxXaWR0aCA8PSBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWRXaWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0U3BhY2VJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB0aGlzLmdldFdvcmRBdChsaW5lLCBsYXN0U3BhY2VJbmRleCArIDEpO1xuICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gbWVhc3VyZXIudGV4dFdpZHRoKG5leHRXb3JkKTtcbiAgICAgICAgICAgIGlmICh0ZXh0V2lkdGggPD0gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIGxhc3RTcGFjZUluZGV4KS50cmltRW5kKCkpO1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShsYXN0U3BhY2VJbmRleCkudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgICAgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgICAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3cmFwT25TcGFjZSAmJiB0ZXh0V2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgIGxpbmUuc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpLnRyaW1FbmQoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnRydW5jYXRlTGluZShcbiAgICAgICAgICAgICAgICAgIGxpbmUuc2xpY2UobGFzdFNwYWNlSW5kZXgpLnRyaW1TdGFydCgpLFxuICAgICAgICAgICAgICAgICAgbWVhc3VyZXIsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLm1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBPblNwYWNlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnRydW5jYXRlTGluZShsaW5lLCBtZWFzdXJlciwgb3B0aW9ucy5tYXhXaWR0aCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod3JhcE9uU3BhY2UpIHtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvc3RmaXggPSB3cmFwSHlwaGVuYXRlID8gXCItXCIgOiBcIlwiO1xuICAgICAgICAgIGxldCBuZXdMaW5lID0gbGluZS5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgICAgd2hpbGUgKG5ld0xpbmUubGVuZ3RoICYmIG1lYXN1cmVyLnRleHRXaWR0aChuZXdMaW5lICsgcG9zdGZpeCkgPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICBuZXdMaW5lID0gbmV3TGluZS5zbGljZSgwLCAtMSkudHJpbUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaChuZXdMaW5lICsgcG9zdGZpeCk7XG4gICAgICAgICAgaWYgKCFuZXdMaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobmV3TGluZS5sZW5ndGgpLnRyaW1TdGFydCgpO1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hdm9pZE9ycGhhbnMocmVzdWx0LCBtZWFzdXJlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpcExpbmVzKHJlc3VsdCwgbWVhc3VyZXIsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBnZXRXb3JkQXQodGV4dCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBuZXh0U3BhY2VJbmRleCA9IHRleHQuaW5kZXhPZihcIiBcIiwgcG9zaXRpb24pO1xuICAgIHJldHVybiBuZXh0U3BhY2VJbmRleCA9PT0gLTEgPyB0ZXh0LnNsaWNlKHBvc2l0aW9uKSA6IHRleHQuc2xpY2UocG9zaXRpb24sIG5leHRTcGFjZUluZGV4KTtcbiAgfVxuICBzdGF0aWMgY2xpcExpbmVzKGxpbmVzLCBtZWFzdXJlciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgY29uc3QgeyBoZWlnaHQsIGxpbmVNZXRyaWNzIH0gPSBtZWFzdXJlci5tZWFzdXJlTGluZXMobGluZXMpO1xuICAgIGlmIChoZWlnaHQgPD0gb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGN1bXVsYXRpdmVIZWlnaHQgPSAwOyBpIDwgbGluZU1ldHJpY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgbGluZUhlaWdodCB9ID0gbGluZU1ldHJpY3NbaV07XG4gICAgICBjdW11bGF0aXZlSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICBpZiAoY3VtdWxhdGl2ZUhlaWdodCA+IG9wdGlvbnMubWF4SGVpZ2h0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJmbG93ID09PSBcImhpZGVcIikge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGlwcGVkUmVzdWx0cyA9IGxpbmVzLnNsaWNlKDAsIGkgfHwgMSk7XG4gICAgICAgIGNvbnN0IGxhc3RMaW5lID0gY2xpcHBlZFJlc3VsdHMucG9wKCk7XG4gICAgICAgIHJldHVybiBjbGlwcGVkUmVzdWx0cy5jb25jYXQodGhpcy50cnVuY2F0ZUxpbmUobGFzdExpbmUsIG1lYXN1cmVyLCBvcHRpb25zLm1heFdpZHRoLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBzdGF0aWMgYXZvaWRPcnBoYW5zKGxpbmVzLCBtZWFzdXJlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmF2b2lkT3JwaGFucyA9PT0gZmFsc2UgfHwgbGluZXMubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGxlbmd0aDogbGVuZ3RoMiB9ID0gbGluZXM7XG4gICAgY29uc3QgbGFzdExpbmUgPSBsaW5lc1tsZW5ndGgyIC0gMV07XG4gICAgY29uc3QgYmVmb3JlTGFzdCA9IGxpbmVzW2xlbmd0aDIgLSAyXTtcbiAgICBpZiAoYmVmb3JlTGFzdC5sZW5ndGggPCBsYXN0TGluZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGFzdFNwYWNlSW5kZXggPSBiZWZvcmVMYXN0Lmxhc3RJbmRleE9mKFwiIFwiKTtcbiAgICBpZiAobGFzdFNwYWNlSW5kZXggPT09IC0xIHx8IGxhc3RTcGFjZUluZGV4ID09PSBiZWZvcmVMYXN0LmluZGV4T2YoXCIgXCIpIHx8IGxhc3RMaW5lLmluY2x1ZGVzKFwiIFwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsYXN0V29yZCA9IGJlZm9yZUxhc3Quc2xpY2UobGFzdFNwYWNlSW5kZXggKyAxKTtcbiAgICBpZiAobWVhc3VyZXIudGV4dFdpZHRoKGxhc3RMaW5lICsgbGFzdFdvcmQpIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgIGxpbmVzW2xlbmd0aDIgLSAyXSA9IGJlZm9yZUxhc3Quc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpO1xuICAgICAgbGluZXNbbGVuZ3RoMiAtIDFdID0gbGFzdFdvcmQgKyBcIiBcIiArIGxhc3RMaW5lO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hdHRyaWJ1dGVVdGlsLnRzXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZSwgcXVhbGlmaWVkTmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICBlPy5yZW1vdmVBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZT8uc2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRWaXNpYmlsaXR5KGVsZW1lbnQyLCBoaWRkZW5Ub2tlbiwgaGlkZGVuKSB7XG4gIGVsZW1lbnQyLmFyaWFIaWRkZW4gPSBgJHtoaWRkZW59YDtcbiAgZWxlbWVudDIuY2xhc3NMaXN0LnRvZ2dsZShoaWRkZW5Ub2tlbiwgaGlkZGVuKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9wbGFjZW1lbnQudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBsYWNlbWVudChuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQsIGNvbnRhaW5lciwgYm91bmRzKSB7XG4gIGxldCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gYm91bmRzO1xuICBpZiAobGVmdCAhPSBudWxsKSB7XG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgIHJpZ2h0ID0gY29udGFpbmVyLndpZHRoIC0gbGVmdCArIHdpZHRoO1xuICAgIH0gZWxzZSBpZiAocmlnaHQgIT0gbnVsbCkge1xuICAgICAgd2lkdGggPSBjb250YWluZXIud2lkdGggLSBsZWZ0IC0gcmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpZ2h0ICE9IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgIGxlZnQgPSBjb250YWluZXIud2lkdGggLSByaWdodCAtIHdpZHRoO1xuICB9XG4gIGlmICh0b3AgIT0gbnVsbCkge1xuICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgYm90dG9tID0gY29udGFpbmVyLmhlaWdodCAtIHRvcCAtIGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGJvdHRvbSAhPSBudWxsKSB7XG4gICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0IC0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib3R0b20gIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgIHRvcCA9IGNvbnRhaW5lci5oZWlnaHQgLSBib3R0b20gLSBoZWlnaHQ7XG4gIH1cbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHdpZHRoID0gbmF0dXJhbFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gbmF0dXJhbEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBNYXRoLmNlaWwobmF0dXJhbFdpZHRoICogaGVpZ2h0IC8gbmF0dXJhbEhlaWdodCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gTWF0aC5jZWlsKG5hdHVyYWxIZWlnaHQgKiB3aWR0aCAvIG5hdHVyYWxXaWR0aCk7XG4gIH1cbiAgaWYgKGxlZnQgPT0gbnVsbCkge1xuICAgIGlmIChyaWdodCA9PSBudWxsKSB7XG4gICAgICBsZWZ0ID0gTWF0aC5mbG9vcigoY29udGFpbmVyLndpZHRoIC0gd2lkdGgpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBjb250YWluZXIud2lkdGggLSByaWdodCAtIHdpZHRoO1xuICAgIH1cbiAgfVxuICBpZiAodG9wID09IG51bGwpIHtcbiAgICBpZiAoYm90dG9tID09IG51bGwpIHtcbiAgICAgIHRvcCA9IE1hdGguZmxvb3IoKGNvbnRhaW5lci5oZWlnaHQgLSBoZWlnaHQpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IGNvbnRhaW5lci5oZWlnaHQgLSBoZWlnaHQgLSBib3R0b207XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHg6IGxlZnQsIHk6IHRvcCwgd2lkdGgsIGhlaWdodCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sdGlwL3Rvb2x0aXAudHNcbnZhciBERUZBVUxUX1RPT0xUSVBfQ0xBU1MgPSBcImFnLWNoYXJ0LXRvb2x0aXBcIjtcbnZhciBERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUyA9IFwiYWctY2hhcnQtZGFyay10b29sdGlwXCI7XG52YXIgRU1QVFlfVE9PTFRJUF9DT05URU5UID0geyBodG1sOiBcIlwiLCBhcmlhTGFiZWw6IFwiXCIgfTtcbmZ1bmN0aW9uIHRvQWNjZXNzaWJsZVRleHQoaW5wdXRIdG1sKSB7XG4gIGNvbnN0IGxpbmVDb252ZXJ0ZXIgPSAoX21hdGNoLCBvZmZzZXQ0LCBzdHIpID0+IHtcbiAgICBpZiAob2Zmc2V0NCA9PT0gMCB8fCBzdHJbb2Zmc2V0NCAtIDFdICE9PSBcIi5cIikge1xuICAgICAgcmV0dXJuIFwiLiBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiIFwiO1xuICB9O1xuICByZXR1cm4gaW5wdXRIdG1sLnJlcGxhY2UoLzxiclxccypcXC8/Pi9nLCBsaW5lQ29udmVydGVyKS5yZXBsYWNlKC88XFwvcFxccys+L2csIGxpbmVDb252ZXJ0ZXIpLnJlcGxhY2UoLzxcXC9saVxccyo+L2csIGxpbmVDb252ZXJ0ZXIpLnJlcGxhY2UoLzxbXjw+XSs+L2csIFwiXCIpLnJlcGxhY2UoL1xcbisvZywgXCIgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xufVxuZnVuY3Rpb24gdG9Ub29sdGlwSHRtbChpbnB1dCwgZGVmYXVsdHMpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7IGh0bWw6IGlucHV0LCBhcmlhTGFiZWw6IGlucHV0IH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGNvbnRlbnQgPSBkZWZhdWx0cz8uY29udGVudCA/PyBcIlwiLFxuICAgIHRpdGxlID0gZGVmYXVsdHM/LnRpdGxlLFxuICAgIGNvbG9yID0gZGVmYXVsdHM/LmNvbG9yID8/IFwid2hpdGVcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBkZWZhdWx0cz8uYmFja2dyb3VuZENvbG9yID8/IFwiIzg4OFwiXG4gIH0gPSBpbnB1dDtcbiAgY29uc3QgdGl0bGVIdG1sID0gdGl0bGUgPyBgPGRpdiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS10aXRsZVwiXG4gICAgICAgIHN0eWxlPVwiY29sb3I6ICR7Y29sb3J9OyBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tncm91bmRDb2xvcn1cIj4ke3RpdGxlfTwvZGl2PmAgOiBcIlwiO1xuICBjb25zdCB0aXRsZUFyaWEgPSB0aXRsZSA/IGAke3RpdGxlfTogYCA6IFwiXCI7XG4gIGNvbnN0IGNvbnRlbnRIdG1sID0gY29udGVudCA/IGA8ZGl2IGNsYXNzPVwiJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LWNvbnRlbnRcIj4ke2NvbnRlbnR9PC9kaXY+YCA6IFwiXCI7XG4gIHJldHVybiB7XG4gICAgaHRtbDogYCR7dGl0bGVIdG1sfSR7Y29udGVudEh0bWx9YCxcbiAgICBhcmlhTGFiZWw6IHRvQWNjZXNzaWJsZVRleHQoYCR7dGl0bGVBcmlhfSR7Y29udGVudH1gKVxuICB9O1xufVxudmFyIFRvb2x0aXBQb3NpdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBUaGUgdHlwZSBvZiBwb3NpdGlvbmluZyBmb3IgdGhlIHRvb2x0aXAuIEJ5IGRlZmF1bHQsIHRoZSB0b29sdGlwIGZvbGxvd3MgdGhlIHBvaW50ZXIuICovXG4gICAgdGhpcy50eXBlID0gXCJwb2ludGVyXCI7XG4gICAgLyoqIFRoZSBob3Jpem9udGFsIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC4gKi9cbiAgICB0aGlzLnhPZmZzZXQgPSAwO1xuICAgIC8qKiBUaGUgdmVydGljYWwgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwLiAqL1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShcbiAgICBVTklPTihcbiAgICAgIFtcbiAgICAgICAgXCJwb2ludGVyXCIsXG4gICAgICAgIFwibm9kZVwiLFxuICAgICAgICBcInRvcFwiLFxuICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInRvcC1sZWZ0XCIsXG4gICAgICAgIFwidG9wLXJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tLXJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tLWxlZnRcIlxuICAgICAgXSxcbiAgICAgIFwiYSBwb3NpdGlvbiB0eXBlXCJcbiAgICApXG4gIClcbl0sIFRvb2x0aXBQb3NpdGlvbi5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFRvb2x0aXBQb3NpdGlvbi5wcm90b3R5cGUsIFwieE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFRvb2x0aXBQb3NpdGlvbi5wcm90b3R5cGUsIFwieU9mZnNldFwiLCAyKTtcbnZhciBUb29sdGlwID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICB0aGlzLnJhbmdlID0gdm9pZCAwO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImh5cGhlbmF0ZVwiO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgdGhpcy5kYXJrVGhlbWUgPSBmYWxzZTtcbiAgICB0aGlzLmJvdW5kcyA9IFwiZXh0ZW5kZWRcIjtcbiAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0VmlzaWJpbGl0eUNoYW5nZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy53cmFwVHlwZXMgPSBbXCJhbHdheXNcIiwgXCJoeXBoZW5hdGVcIiwgXCJvbi1zcGFjZVwiLCBcIm5ldmVyXCJdO1xuICAgIHRoaXMuc2hvd1RpbWVvdXQgPSAwO1xuICAgIHRoaXMuX3Nob3dBcnJvdyA9IHRydWU7XG4gIH1cbiAgZ2V0IGludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUludGVyYWN0aW9uO1xuICB9XG4gIHNldHVwKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChERUZBVUxUX1RPT0xUSVBfQ0xBU1MpO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQsIFwiYXJpYS1oaWRkZW5cIiwgdHJ1ZSk7XG4gIH1cbiAgZGVzdHJveShkb21NYW5hZ2VyKSB7XG4gICAgZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIERFRkFVTFRfVE9PTFRJUF9DTEFTUyk7XG4gIH1cbiAgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiAhdGhpcy5lbGVtZW50Py5jbGFzc0xpc3QuY29udGFpbnMoREVGQVVMVF9UT09MVElQX0NMQVNTICsgXCItaGlkZGVuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0b29sdGlwIGF0IHRoZSBnaXZlbiBldmVudCdzIGNvb3JkaW5hdGVzLlxuICAgKiBJZiB0aGUgYGh0bWxgIHBhcmFtZXRlciBpcyBtaXNzaW5nLCBtb3ZlcyB0aGUgZXhpc3RpbmcgdG9vbHRpcCB0byB0aGUgbmV3IHBvc2l0aW9uLlxuICAgKi9cbiAgc2hvdyhib3VuZGluZ1JlY3QsIGNhbnZhc1JlY3QsIG1ldGEsIGNvbnRlbnQsIGluc3RhbnRseSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiB9ID0gdGhpcztcbiAgICBpZiAoY29udGVudCAhPSBudWxsICYmIGVsZW1lbnQyICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQyLmlubmVySFRNTCA9IGNvbnRlbnQuaHRtbDtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50Mj8uaW5uZXJIVE1MKSB7XG4gICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uVHlwZSA9IG1ldGEucG9zaXRpb24/LnR5cGUgPz8gdGhpcy5wb3NpdGlvbi50eXBlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSBtZXRhLnBvc2l0aW9uPy54T2Zmc2V0ID8/IDA7XG4gICAgY29uc3QgeU9mZnNldCA9IG1ldGEucG9zaXRpb24/LnlPZmZzZXQgPz8gMDtcbiAgICBjb25zdCB0b29sdGlwQm91bmRzID0gdGhpcy5nZXRUb29sdGlwQm91bmRzKHsgcG9zaXRpb25UeXBlLCBtZXRhLCB5T2Zmc2V0LCB4T2Zmc2V0LCBjYW52YXNSZWN0IH0pO1xuICAgIGNvbnN0IHJlbGF0aXZlUmVjdCA9IHtcbiAgICAgIHg6IGJvdW5kaW5nUmVjdC54IC0gY2FudmFzUmVjdC54LFxuICAgICAgeTogYm91bmRpbmdSZWN0LnkgLSBjYW52YXNSZWN0LnksXG4gICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVBsYWNlbWVudChlbGVtZW50Mi5jbGllbnRXaWR0aCwgZWxlbWVudDIuY2xpZW50SGVpZ2h0LCByZWxhdGl2ZVJlY3QsIHRvb2x0aXBCb3VuZHMpO1xuICAgIGNvbnN0IG1pblggPSByZWxhdGl2ZVJlY3QueDtcbiAgICBjb25zdCBtaW5ZID0gcmVsYXRpdmVSZWN0Lnk7XG4gICAgY29uc3QgbWF4WCA9IHJlbGF0aXZlUmVjdC53aWR0aCAtIGVsZW1lbnQyLmNsaWVudFdpZHRoIC0gMSArIG1pblg7XG4gICAgY29uc3QgbWF4WSA9IHJlbGF0aXZlUmVjdC5oZWlnaHQgLSBlbGVtZW50Mi5jbGllbnRIZWlnaHQgKyBtaW5ZO1xuICAgIGNvbnN0IGxlZnQgPSBjbGFtcChtaW5YLCBwb3NpdGlvbi54LCBtYXhYKTtcbiAgICBjb25zdCB0b3AgPSBjbGFtcChtaW5ZLCBwb3NpdGlvbi55LCBtYXhZKTtcbiAgICBjb25zdCBjb25zdHJhaW5lZCA9IGxlZnQgIT09IHBvc2l0aW9uLnggfHwgdG9wICE9PSBwb3NpdGlvbi55O1xuICAgIGNvbnN0IGRlZmF1bHRTaG93QXJyb3cgPSAocG9zaXRpb25UeXBlID09PSBcIm5vZGVcIiB8fCBwb3NpdGlvblR5cGUgPT09IFwicG9pbnRlclwiKSAmJiAhY29uc3RyYWluZWQgJiYgIXhPZmZzZXQgJiYgIXlPZmZzZXQ7XG4gICAgY29uc3Qgc2hvd0Fycm93ID0gbWV0YS5zaG93QXJyb3cgPz8gdGhpcy5zaG93QXJyb3cgPz8gZGVmYXVsdFNob3dBcnJvdztcbiAgICB0aGlzLnVwZGF0ZVNob3dBcnJvdyhzaG93QXJyb3cpO1xuICAgIGVsZW1lbnQyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtNYXRoLnJvdW5kKGxlZnQpfXB4LCAke01hdGgucm91bmQodG9wKX1weClgO1xuICAgIGVsZW1lbnQyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBtZXRhLmVuYWJsZUludGVyYWN0aW9uID8gXCJhdXRvXCIgOiBcIm5vbmVcIjtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBvaW50ZXItY2FwdHVyZVwiLCBcInJldGFpblwiKTtcbiAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gbWV0YS5lbmFibGVJbnRlcmFjdGlvbiA/PyBmYWxzZTtcbiAgICBpZiAodGhpcy5kZWxheSA+IDAgJiYgIWluc3RhbnRseSkge1xuICAgICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICAgICAgdGhpcy5zaG93VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZSh0cnVlKTtcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvZ2dsZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlKHZpc2libGUpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IHRvZ2dsZUNsYXNzID0gKG5hbWUsIGluY2x1ZGUpID0+IGNsYXNzTGlzdC50b2dnbGUoYCR7REVGQVVMVF9UT09MVElQX0NMQVNTfS0ke25hbWV9YCwgaW5jbHVkZSk7XG4gICAgY29uc3Qgd2FzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlKCk7XG4gICAgbGV0IHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPSBJbmZpbml0eTtcbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKHdhc1Zpc2libGUgIT09IHZpc2libGUpIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICB0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID0gbm93IC0gdGhpcy5sYXN0VmlzaWJpbGl0eUNoYW5nZTtcbiAgICAgIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2UgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkTW92ZVRocmVzaG9sZE1zID0gMTAwO1xuICAgIGNvbnN0IHRocmFzaGluZ1RocmVzaG9sZE1zID0gNTtcbiAgICBjb25zdCBub0FuaW1hdGlvbiA9ICF3YXNWaXNpYmxlICYmIHZpc2libGUgJiYgdGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA+IGFuaW1hdGVkTW92ZVRocmVzaG9sZE1zO1xuICAgIGlmICh0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID4gdGhyYXNoaW5nVGhyZXNob2xkTXMpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKFwibm8tYW5pbWF0aW9uXCIsIG5vQW5pbWF0aW9uKTtcbiAgICB9XG4gICAgdG9nZ2xlQ2xhc3MoXCJuby1pbnRlcmFjdGlvblwiLCAhdGhpcy5lbmFibGVJbnRlcmFjdGlvbik7XG4gICAgdG9nZ2xlQ2xhc3MoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICAgIHRvZ2dsZUNsYXNzKFwiYXJyb3dcIiwgdGhpcy5fc2hvd0Fycm93KTtcbiAgICBjbGFzc0xpc3QudG9nZ2xlKERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTLCB0aGlzLmRhcmtUaGVtZSk7XG4gICAgZm9yIChjb25zdCB3cmFwVHlwZSBvZiB0aGlzLndyYXBUeXBlcykge1xuICAgICAgY2xhc3NMaXN0LnRvZ2dsZShgJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LXdyYXAtJHt3cmFwVHlwZX1gLCB3cmFwVHlwZSA9PT0gdGhpcy53cmFwcGluZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNob3dBcnJvdyhzaG93KSB7XG4gICAgdGhpcy5fc2hvd0Fycm93ID0gc2hvdztcbiAgfVxuICBnZXRUb29sdGlwQm91bmRzKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudClcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IHBvc2l0aW9uVHlwZSwgbWV0YSwgeU9mZnNldCwgeE9mZnNldCwgY2FudmFzUmVjdCB9ID0gb3B0cztcbiAgICBjb25zdCB7IGNsaWVudFdpZHRoOiB0b29sdGlwV2lkdGgsIGNsaWVudEhlaWdodDogdG9vbHRpcEhlaWdodCB9ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IGJvdW5kcyA9IHsgd2lkdGg6IHRvb2x0aXBXaWR0aCwgaGVpZ2h0OiB0b29sdGlwSGVpZ2h0IH07XG4gICAgc3dpdGNoIChwb3NpdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICBjYXNlIFwicG9pbnRlclwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBtZXRhLm9mZnNldFkgKyB5T2Zmc2V0IC0gdG9vbHRpcEhlaWdodCAtIDg7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gbWV0YS5vZmZzZXRYICsgeE9mZnNldCAtIHRvb2x0aXBXaWR0aCAvIDI7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9wXCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAvIDIgLSB0b29sdGlwV2lkdGggLyAyICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyaWdodFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAvIDIgLSB0b29sdGlwSGVpZ2h0IC8gMiArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAtIHRvb2x0aXBXaWR0aCAvIDIgKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxlZnRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLyAyIC0gdG9vbHRpcEhlaWdodCAvIDIgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYm90dG9tXCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC0gdG9vbHRpcEhlaWdodCArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAvIDIgLSB0b29sdGlwV2lkdGggLyAyICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAtIHRvb2x0aXBXaWR0aCArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC0gdG9vbHRpcEhlaWdodCArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAtIHRvb2x0aXBXaWR0aCArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwic2hvd0Fycm93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCwgbmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICB0YXJnZXQuZWxlbWVudD8uY2xhc3NMaXN0LmFkZChuZXdWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgdGFyZ2V0LmVsZW1lbnQ/LmNsYXNzTGlzdC5yZW1vdmUob2xkVmFsdWUpO1xuICAgIH1cbiAgfSksXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiY2xhc3NcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJkZWxheVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSQUNUSU9OX1JBTkdFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfV1JBUClcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcIndyYXBwaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZGFya1RoZW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wiZXh0ZW5kZWRcIiwgXCJjYW52YXNcIl0pKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiYm91bmRzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jYXB0aW9uLnRzXG52YXIgQ2FwdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLm5vZGUgPSBuZXcgVGV4dCh7IHpJbmRleDogMSB9KS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqL1xuICAgIH0pO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICB0aGlzLmZvbnRTaXplID0gMTA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy53cmFwcGluZyA9IFwiYWx3YXlzXCI7XG4gICAgdGhpcy50cnVuY2F0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxheW91dFN0eWxlID0gXCJibG9ja1wiO1xuICB9XG4gIHJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ3R4KSB7XG4gICAgY29uc3QgeyByZWdpb25NYW5hZ2VyLCBwcm94eUludGVyYWN0aW9uU2VydmljZSwgbGF5b3V0U2VydmljZSB9ID0gbW9kdWxlQ3R4O1xuICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwicm9vdFwiKTtcbiAgICBjb25zdCBkZXN0cm95Rm5zID0gW1xuICAgICAgbGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoKSA9PiB0aGlzLnVwZGF0ZUExMXlUZXh0KHByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlKSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VNb3ZlKG1vZHVsZUN0eCwgZXZlbnQpKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsIChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZUxlYXZlKG1vZHVsZUN0eCwgZXZlbnQpKVxuICAgIF07XG4gICAgcmV0dXJuIGpvaW5GdW5jdGlvbnMoLi4uZGVzdHJveUZucyk7XG4gIH1cbiAgY29tcHV0ZVRleHRXcmFwKGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpIHtcbiAgICBjb25zdCB7IHRleHQsIHdyYXBwaW5nIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCA/PyBJbmZpbml0eSwgY29udGFpbmVyV2lkdGgpO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8/IGNvbnRhaW5lckhlaWdodDtcbiAgICBpZiAoIWlzRmluaXRlKG1heFdpZHRoKSAmJiAhaXNGaW5pdGUobWF4SGVpZ2h0KSkge1xuICAgICAgdGhpcy5ub2RlLnRleHQgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkVGV4dCA9IFRleHRXcmFwcGVyLndyYXBUZXh0KHRleHQgPz8gXCJcIiwgeyBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBmb250OiB0aGlzLCB0ZXh0V3JhcDogd3JhcHBpbmcgfSk7XG4gICAgdGhpcy5ub2RlLnRleHQgPSB3cmFwcGVkVGV4dDtcbiAgICB0aGlzLnRydW5jYXRlZCA9IHdyYXBwZWRUZXh0LmluY2x1ZGVzKFRleHRVdGlscy5FbGxpcHNpc0NoYXIpO1xuICB9XG4gIHVwZGF0ZUExMXlUZXh0KHByb3h5U2VydmljZSkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy50ZXh0KSB7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy5ub2RlLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJveHlUZXh0ID8/ICh0aGlzLnByb3h5VGV4dCA9IHByb3h5U2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoeyB0eXBlOiBcInRleHRcIiwgaWQsIHBhcmVudDogXCJjYW52YXMtcHJveHlcIiB9KSk7XG4gICAgICAgIHRoaXMucHJveHlUZXh0LnRleHRDb250ZW50ID0gdGhpcy50ZXh0O1xuICAgICAgICB0aGlzLnByb3h5VGV4dC51cGRhdGVCb3VuZHMoYmJveCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJveHlUZXh0Py5yZW1vdmUoKTtcbiAgICAgIHRoaXMucHJveHlUZXh0ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZU1vdmUobW9kdWxlQ3R4LCBldmVudCkge1xuICAgIGlmIChldmVudCAhPT0gdm9pZCAwICYmIHRoaXMuZW5hYmxlZCAmJiB0aGlzLm5vZGUudmlzaWJsZSAmJiB0aGlzLnRydW5jYXRlZCkge1xuICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgIG1vZHVsZUN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICB7IG9mZnNldFgsIG9mZnNldFksIGxhc3RQb2ludGVyRXZlbnQ6IGV2ZW50LCBzaG93QXJyb3c6IGZhbHNlIH0sXG4gICAgICAgIHRvVG9vbHRpcEh0bWwoeyBjb250ZW50OiB0aGlzLnRleHQgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhbmRsZU1vdXNlTGVhdmUobW9kdWxlQ3R4LCBfZXZlbnQpIHtcbiAgICBtb2R1bGVDdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgfVxufTtcbkNhcHRpb24uU01BTExfUEFERElORyA9IDEwO1xuQ2FwdGlvbi5MQVJHRV9QQURESU5HID0gMjA7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9BTElHTiwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ0ZXh0QWxpZ25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIiwgXCJmaWxsXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibGluZUhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIm1heEhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfV1JBUClcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIndyYXBwaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibGF5b3V0U3R5bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3JhbmdlLnRzXG52YXIgUmFuZ2UgPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG4gICAgdGhpcy5zdGFydExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmVuZExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3godGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiAtIHRoaXMueDEsIHRoaXMueTIgLSB0aGlzLnkxKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKF94LCBfeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCk7XG4gICAgbGV0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XG4gICAgeDEgPSB0aGlzLmFsaWduKHgxKTtcbiAgICB5MSA9IHRoaXMuYWxpZ24oeTEpO1xuICAgIHgyID0gdGhpcy5hbGlnbih4Mik7XG4gICAgeTIgPSB0aGlzLmFsaWduKHkyKTtcbiAgICBjb25zdCB7IGZpbGwsIG9wYWNpdHksIGlzUmFuZ2UgfSA9IHRoaXM7XG4gICAgY29uc3QgZmlsbEFjdGl2ZSA9ICEhKGlzUmFuZ2UgJiYgZmlsbCk7XG4gICAgaWYgKGZpbGxBY3RpdmUpIHtcbiAgICAgIGNvbnN0IHsgZmlsbE9wYWNpdHkgfSA9IHRoaXM7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHkgKiBmaWxsT3BhY2l0eTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHkxKTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGN0eC5saW5lVG8oeDEsIHkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3RhcnRMaW5lLCBlbmRMaW5lIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0cm9rZUFjdGl2ZSA9ICEhKChzdGFydExpbmUgfHwgZW5kTGluZSkgJiYgc3Ryb2tlICYmIHN0cm9rZVdpZHRoKTtcbiAgICBpZiAoc3Ryb2tlQWN0aXZlKSB7XG4gICAgICBjb25zdCB7IHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgbGluZUNhcCwgbGluZUpvaW4gfSA9IHRoaXM7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5ICogc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgfVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgaWYgKHN0YXJ0TGluZSkge1xuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkxKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRMaW5lKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeDIsIHkyKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4MSwgeTIpO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG59O1xuUmFuZ2UuY2xhc3NOYW1lID0gXCJSYW5nZVwiO1xuUmFuZ2UuZGVmYXVsdFN0eWxlcyA9IHtcbiAgLi4uU2hhcGUuZGVmYXVsdFN0eWxlcyxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcIngxXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieDJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcInkyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJzdGFydExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcImVuZExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcImlzUmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xhYmVsLnRzXG52YXIgTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxuICBnZXRGb250KCkge1xuICAgIHJldHVybiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHRoaXMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24ob3B0cykge1xuICBjb25zdCB7IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gMCwgcmVndWxhckZsaXBSb3RhdGlvbiA9IDAgfSA9IG9wdHM7XG4gIGNvbnN0IGNvbmZpZ3VyZWRSb3RhdGlvbiA9IG9wdHMucm90YXRpb24gPyBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMob3B0cy5yb3RhdGlvbikpIDogMDtcbiAgY29uc3QgcGFyYWxsZWxGbGlwRmxhZyA9ICFjb25maWd1cmVkUm90YXRpb24gJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPj0gMCAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA8PSBNYXRoLlBJID8gLTEgOiAxO1xuICBjb25zdCByZWd1bGFyRmxpcEZsYWcgPSAhY29uZmlndXJlZFJvdGF0aW9uICYmIHJlZ3VsYXJGbGlwUm90YXRpb24gPj0gMCAmJiByZWd1bGFyRmxpcFJvdGF0aW9uIDw9IE1hdGguUEkgPyAtMSA6IDE7XG4gIGxldCBkZWZhdWx0Um90YXRpb24gPSAwO1xuICBpZiAob3B0cy5wYXJhbGxlbCkge1xuICAgIGRlZmF1bHRSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcEZsYWcgKiBNYXRoLlBJIC8gMjtcbiAgfSBlbHNlIGlmIChyZWd1bGFyRmxpcEZsYWcgPT09IC0xKSB7XG4gICAgZGVmYXVsdFJvdGF0aW9uID0gTWF0aC5QSTtcbiAgfVxuICByZXR1cm4geyBjb25maWd1cmVkUm90YXRpb24sIGRlZmF1bHRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZywgcmVndWxhckZsaXBGbGFnIH07XG59XG5mdW5jdGlvbiBnZXRMYWJlbFNwYWNpbmcobWluU3BhY2luZywgcm90YXRlZCkge1xuICBpZiAoIWlzTmFOKG1pblNwYWNpbmcpKSB7XG4gICAgcmV0dXJuIG1pblNwYWNpbmc7XG4gIH1cbiAgcmV0dXJuIHJvdGF0ZWQgPyAwIDogMTA7XG59XG5mdW5jdGlvbiBnZXRUZXh0QmFzZWxpbmUocGFyYWxsZWwsIGxhYmVsUm90YXRpb24sIHNpZGVGbGFnLCBwYXJhbGxlbEZsaXBGbGFnKSB7XG4gIGlmIChwYXJhbGxlbCAmJiAhbGFiZWxSb3RhdGlvbikge1xuICAgIHJldHVybiBzaWRlRmxhZyAqIHBhcmFsbGVsRmxpcEZsYWcgPT09IC0xID8gXCJoYW5naW5nXCIgOiBcImJvdHRvbVwiO1xuICB9XG4gIHJldHVybiBcIm1pZGRsZVwiO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBsYWJlbFJvdGF0aW9uLCBsYWJlbEF1dG9Sb3RhdGlvbiwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZykge1xuICBjb25zdCBsYWJlbFJvdGF0ZWQgPSBsYWJlbFJvdGF0aW9uID4gMCAmJiBsYWJlbFJvdGF0aW9uIDw9IE1hdGguUEk7XG4gIGNvbnN0IGxhYmVsQXV0b1JvdGF0ZWQgPSBsYWJlbEF1dG9Sb3RhdGlvbiA+IDAgJiYgbGFiZWxBdXRvUm90YXRpb24gPD0gTWF0aC5QSTtcbiAgY29uc3QgYWxpZ25GbGFnID0gbGFiZWxSb3RhdGVkIHx8IGxhYmVsQXV0b1JvdGF0ZWQgPyAtMSA6IDE7XG4gIGlmIChwYXJhbGxlbCkge1xuICAgIGlmIChsYWJlbFJvdGF0aW9uIHx8IGxhYmVsQXV0b1JvdGF0aW9uKSB7XG4gICAgICBpZiAoc2lkZUZsYWcgKiBhbGlnbkZsYWcgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBcImVuZFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2lkZUZsYWcgKiByZWd1bGFyRmxpcEZsYWcgPT09IC0xKSB7XG4gICAgcmV0dXJuIFwiZW5kXCI7XG4gIH1cbiAgcmV0dXJuIFwic3RhcnRcIjtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsQkJveCh0ZXh0LCBiYm94LCBsYWJlbE1hdHJpeCkge1xuICBjb25zdCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCB3aWR0aCwgaGVpZ2h0IH0gPSBiYm94O1xuICBjb25zdCB0cmFuc2xhdGVkQkJveCA9IG5ldyBCQm94KGxhYmVsWCwgbGFiZWxZLCAwLCAwKTtcbiAgbGFiZWxNYXRyaXgudHJhbnNmb3JtQkJveCh0cmFuc2xhdGVkQkJveCwgYmJveCk7XG4gIGNvbnN0IHsgeCwgeSB9ID0gYmJveDtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogeyB4LCB5IH0sXG4gICAgbGFiZWw6IHsgdGV4dCwgd2lkdGgsIGhlaWdodCB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xheWVycy50c1xudmFyIExheWVycyA9IC8qIEBfX1BVUkVfXyAqLyAoKExheWVyczIpID0+IHtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0JBQ0tHUk9VTkRfWklOREVYXCJdID0gMF0gPSBcIlNFUklFU19CQUNLR1JPVU5EX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJBWElTX0dSSURfWklOREVYXCJdID0gMV0gPSBcIkFYSVNfR1JJRF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiQVhJU19aSU5ERVhcIl0gPSAyXSA9IFwiQVhJU19aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0NST1NTTElORV9SQU5HRV9aSU5ERVhcIl0gPSAzXSA9IFwiU0VSSUVTX0NST1NTTElORV9SQU5HRV9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0xBWUVSX1pJTkRFWFwiXSA9IDRdID0gXCJTRVJJRVNfTEFZRVJfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19ISUdITElHSFRfWklOREVYXCJdID0gNV0gPSBcIlNFUklFU19ISUdITElHSFRfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkFYSVNfRk9SRUdST1VORF9aSU5ERVhcIl0gPSA2XSA9IFwiQVhJU19GT1JFR1JPVU5EX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfQ1JPU1NIQUlSX1pJTkRFWFwiXSA9IDddID0gXCJTRVJJRVNfQ1JPU1NIQUlSX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfTEFCRUxfWklOREVYXCJdID0gOF0gPSBcIlNFUklFU19MQUJFTF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0NST1NTTElORV9MSU5FX1pJTkRFWFwiXSA9IDldID0gXCJTRVJJRVNfQ1JPU1NMSU5FX0xJTkVfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19BTk5PVEFUSU9OX1pJTkRFWFwiXSA9IDEwXSA9IFwiU0VSSUVTX0FOTk9UQVRJT05fWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkNIQVJUX0FOTk9UQVRJT05fWklOREVYXCJdID0gMTFdID0gXCJDSEFSVF9BTk5PVEFUSU9OX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJDSEFSVF9BTk5PVEFUSU9OX0ZPQ1VTRURfWklOREVYXCJdID0gMTJdID0gXCJDSEFSVF9BTk5PVEFUSU9OX0ZPQ1VTRURfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkxFR0VORF9aSU5ERVhcIl0gPSAxM10gPSBcIkxFR0VORF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiTkFWSUdBVE9SX1pJTkRFWFwiXSA9IDE0XSA9IFwiTkFWSUdBVE9SX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJGT1JFR1JPVU5EX1pJTkRFWFwiXSA9IDE1XSA9IFwiRk9SRUdST1VORF9aSU5ERVhcIjtcbiAgcmV0dXJuIExheWVyczI7XG59KShMYXllcnMgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZhbHVlLnRzXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duKHZhbHVlLCBcInRvU3RyaW5nXCIpICYmIGlzU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ2YWx1ZU9mXCIpICYmIGlzRmluaXRlTnVtYmVyKHZhbHVlLnZhbHVlT2YoKSk7XG59XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXModmFsdWUpIHtcbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB8fCBpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNOdW1iZXJPYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gY2hlY2tEYXR1bSh2YWx1ZSwgaXNDb250aW51b3VzU2NhbGUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKCFpc0NvbnRpbnVvdXNTY2FsZSB8fCBpc0NvbnRpbnVvdXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc1N0cmluZ09iamVjdCh2YWx1ZSkgJiYgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJpZFwiKSkge1xuICAgIHJldHVybiB2YWx1ZS5pZDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jcm9zc0xpbmUudHNcbnZhciBNQVRDSElOR19DUk9TU0xJTkVfVFlQRSA9IChwcm9wZXJ0eSkgPT4ge1xuICByZXR1cm4gcHJvcGVydHkgPT09IFwidmFsdWVcIiA/IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgIChfLCBjdHgpID0+IGN0eC50YXJnZXRbXCJ0eXBlXCJdID09PSBcImxpbmVcIixcbiAgICAoY3R4KSA9PiBjdHgudGFyZ2V0W1widHlwZVwiXSA9PT0gXCJyYW5nZVwiID8gYGNyb3NzTGluZSB0eXBlICdyYW5nZScgdG8gaGF2ZSBhICdyYW5nZScgcHJvcGVydHkgaW5zdGVhZCBvZiAndmFsdWUnYCA6IGBjcm9zc0xpbmUgcHJvcGVydHkgJ3R5cGUnIHRvIGJlICdsaW5lJ2BcbiAgKSA6IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgIChfLCBjdHgpID0+IGN0eC50YXJnZXRbXCJ0eXBlXCJdID09PSBcInJhbmdlXCIsXG4gICAgKGN0eCkgPT4gY3R4LnRhcmdldC50eXBlID09PSBcImxpbmVcIiA/IGBjcm9zc0xpbmUgdHlwZSAnbGluZScgdG8gaGF2ZSBhICd2YWx1ZScgcHJvcGVydHkgaW5zdGVhZCBvZiAncmFuZ2UnYCA6IGBjcm9zc0xpbmUgcHJvcGVydHkgJ3R5cGUnIHRvIGJlICdyYW5nZSdgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQ3Jvc3NMaW5lVmFsdWVzID0gKHR5cGUsIHZhbHVlLCByYW5nZTMsIHNjYWxlMikgPT4ge1xuICBjb25zdCBsaW5lQ3Jvc3NMaW5lID0gdHlwZSA9PT0gXCJsaW5lXCIgJiYgdmFsdWUgIT09IHZvaWQgMDtcbiAgY29uc3QgcmFuZ2VDcm9zc0xpbmUgPSB0eXBlID09PSBcInJhbmdlXCIgJiYgcmFuZ2UzICE9PSB2b2lkIDA7XG4gIGlmICghbGluZUNyb3NzTGluZSAmJiAhcmFuZ2VDcm9zc0xpbmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBbc3RhcnQsIGVuZF0gPSByYW5nZTMgPz8gW3ZhbHVlLCB2b2lkIDBdO1xuICBjb25zdCBpc0NvbnRpbnVvdXMyID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICBjb25zdCB2YWxpZFN0YXJ0ID0gY2hlY2tEYXR1bShzdGFydCwgaXNDb250aW51b3VzMikgJiYgIWlzTmFOKHNjYWxlMi5jb252ZXJ0KHN0YXJ0KSk7XG4gIGNvbnN0IHZhbGlkRW5kID0gY2hlY2tEYXR1bShlbmQsIGlzQ29udGludW91czIpICYmICFpc05hTihzY2FsZTIuY29udmVydChlbmQpKTtcbiAgaWYgKGxpbmVDcm9zc0xpbmUgJiYgdmFsaWRTdGFydCB8fCByYW5nZUNyb3NzTGluZSAmJiB2YWxpZFN0YXJ0ICYmIHZhbGlkRW5kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFtgRXhwZWN0aW5nIGNyb3NzTGluZWBdO1xuICBpZiAocmFuZ2VDcm9zc0xpbmUpIHtcbiAgICBpZiAoIXZhbGlkU3RhcnQpIHtcbiAgICAgIG1lc3NhZ2UucHVzaChgcmFuZ2Ugc3RhcnQgJHtzdHJpbmdpZnkoc3RhcnQpfWApO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkRW5kKSB7XG4gICAgICBtZXNzYWdlLnB1c2goYCR7dmFsaWRTdGFydCA/IFwiXCIgOiBcImFuZCBcIn1yYW5nZSBlbmQgJHtzdHJpbmdpZnkoZW5kKX1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZS5wdXNoKGB2YWx1ZSAke3N0cmluZ2lmeShzdGFydCl9YCk7XG4gIH1cbiAgbWVzc2FnZS5wdXNoKGB0byBtYXRjaCB0aGUgYXhpcyBzY2FsZSBkb21haW4uYCk7XG4gIExvZ2dlci53YXJuT25jZShtZXNzYWdlLmpvaW4oXCIgXCIpKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY3Jvc3NsaW5lL2Nyb3NzTGluZUxhYmVsUG9zaXRpb24udHNcbnZhciBob3Jpem9udGFsQ3Jvc3NsaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zID0ge1xuICB0b3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBsZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICByaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICB0b3BMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICB0b3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgYm90dG9tUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVUb3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBpbnNpZGVUb3BMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZUJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGluc2lkZVRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH1cbn07XG52YXIgdmVydGljYWxDcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB7XG4gIHRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBib3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIHJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIHRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICB0b3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgYm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgYm90dG9tUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGluc2lkZVRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlQm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZVRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZUJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlVG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBpbnNpZGVCb3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb24oe1xuICB5RGlyZWN0aW9uLFxuICBwYWRkaW5nID0gMCxcbiAgcG9zaXRpb24gPSBcInRvcFwiLFxuICBiYm94XG59KSB7XG4gIGNvbnN0IGNyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA9IHlEaXJlY3Rpb24gPyBob3Jpem9udGFsQ3Jvc3NsaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zIDogdmVydGljYWxDcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnM7XG4gIGNvbnN0IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uLCB5VHJhbnNsYXRpb25EaXJlY3Rpb24gfSA9IGNyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9uc1twb3NpdGlvbl07XG4gIGNvbnN0IHcgPSB5RGlyZWN0aW9uID8gYmJveC53aWR0aCA6IGJib3guaGVpZ2h0O1xuICBjb25zdCBoID0geURpcmVjdGlvbiA/IGJib3guaGVpZ2h0IDogYmJveC53aWR0aDtcbiAgY29uc3QgeFRyYW5zbGF0aW9uID0geFRyYW5zbGF0aW9uRGlyZWN0aW9uICogKHBhZGRpbmcgKyB3IC8gMik7XG4gIGNvbnN0IHlUcmFuc2xhdGlvbiA9IHlUcmFuc2xhdGlvbkRpcmVjdGlvbiAqIChwYWRkaW5nICsgaCAvIDIpO1xuICByZXR1cm4ge1xuICAgIHhUcmFuc2xhdGlvbixcbiAgICB5VHJhbnNsYXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nKHtcbiAgeURpcmVjdGlvbixcbiAgYmJveCxcbiAgcGFkZGluZyA9IDAsXG4gIHBvc2l0aW9uID0gXCJ0b3BcIlxufSkge1xuICBjb25zdCBjaGFydFBhZGRpbmcgPSB7fTtcbiAgaWYgKHBvc2l0aW9uLnN0YXJ0c1dpdGgoXCJpbnNpZGVcIikpXG4gICAgcmV0dXJuIGNoYXJ0UGFkZGluZztcbiAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiICYmICF5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLnRvcCA9IHBhZGRpbmcgKyBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJib3R0b21cIiAmJiAheURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5ib3R0b20gPSBwYWRkaW5nICsgYmJveC5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwibGVmdFwiICYmIHlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcubGVmdCA9IHBhZGRpbmcgKyBiYm94LndpZHRoO1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgJiYgeURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5yaWdodCA9IHBhZGRpbmcgKyBiYm94LndpZHRoO1xuICB9XG4gIHJldHVybiBjaGFydFBhZGRpbmc7XG59XG52YXIgUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kIC8gMiwgeTogeVN0YXJ0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fTEVGVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiB5U3RhcnQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kIC8gMiwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9JTlNJREVfQ09PUkRJTkFURVMgPSAoeyB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICByZXR1cm4geyB4OiB4RW5kIC8gMiwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG59O1xudmFyIFBPU0lUSU9OX1RPUF9MRUZUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCAvIDIsIHk6IHlTdGFydCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IHlTdGFydCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiB5U3RhcnQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IHlTdGFydCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0JPVFRPTV9SSUdIVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9XG59O1xudmFyIGxhYmVsRGlyZWN0aW9uSGFuZGxpbmcgPSB7XG4gIHRvcDogeyBjOiBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgfSxcbiAgYm90dG9tOiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyB9LFxuICBsZWZ0OiB7IGM6IFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgcmlnaHQ6IHsgYzogUE9TSVRJT05fUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgdG9wTGVmdDogeyBjOiBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyB9LFxuICB0b3BSaWdodDogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgYm90dG9tTGVmdDogeyBjOiBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyB9LFxuICBib3R0b21SaWdodDogeyBjOiBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlOiB7IGM6IFBPU0lUSU9OX0lOU0lERV9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVMZWZ0OiB7IGM6IFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlUmlnaHQ6IHsgYzogUE9TSVRJT05fUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlVG9wOiB7IGM6IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVCb3R0b206IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZVRvcExlZnQ6IHsgYzogUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlQm90dG9tTGVmdDogeyBjOiBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVUb3BSaWdodDogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlQm90dG9tUmlnaHQ6IHsgYzogUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jYXJ0ZXNpYW5Dcm9zc0xpbmUudHNcbnZhciBDUk9TU0xJTkVfTEFCRUxfUE9TSVRJT04gPSBVTklPTihcbiAgW1xuICAgIFwidG9wXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJ0b3BMZWZ0XCIsXG4gICAgXCJ0b3BSaWdodFwiLFxuICAgIFwiYm90dG9tTGVmdFwiLFxuICAgIFwiYm90dG9tUmlnaHRcIixcbiAgICBcImluc2lkZVwiLFxuICAgIFwiaW5zaWRlTGVmdFwiLFxuICAgIFwiaW5zaWRlUmlnaHRcIixcbiAgICBcImluc2lkZVRvcFwiLFxuICAgIFwiaW5zaWRlQm90dG9tXCIsXG4gICAgXCJpbnNpZGVUb3BMZWZ0XCIsXG4gICAgXCJpbnNpZGVCb3R0b21MZWZ0XCIsXG4gICAgXCJpbnNpZGVUb3BSaWdodFwiLFxuICAgIFwiaW5zaWRlQm90dG9tUmlnaHRcIlxuICBdLFxuICBcImNyb3NzTGluZSBsYWJlbCBwb3NpdGlvblwiXG4pO1xudmFyIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5mb250U2l6ZSA9IDE0O1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5jb2xvciA9IFwicmdiYSg4NywgODcsIDg3LCAxKVwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENST1NTTElORV9MQUJFTF9QT1NJVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicGFyYWxsZWxcIiwgMik7XG52YXIgX0NhcnRlc2lhbkNyb3NzTGluZSA9IGNsYXNzIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwoKTtcbiAgICB0aGlzLnNjYWxlID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpcHBlZFJhbmdlID0gWy1JbmZpbml0eSwgSW5maW5pdHldO1xuICAgIHRoaXMuZ3JpZExlbmd0aCA9IDA7XG4gICAgdGhpcy5zaWRlRmxhZyA9IC0xO1xuICAgIHRoaXMucGFyYWxsZWxGbGlwUm90YXRpb24gPSAwO1xuICAgIHRoaXMucmVndWxhckZsaXBSb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInhcIiAvKiBYICovO1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfWAsIGxheWVyOiB0cnVlLCB6SW5kZXg6IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTElORV9MQVlFUl9aSU5ERVggfSk7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH1gLCBsYXllcjogdHJ1ZSwgekluZGV4OiBfQ2FydGVzaWFuQ3Jvc3NMaW5lLkxBQkVMX0xBWUVSX1pJTkRFWCB9KTtcbiAgICB0aGlzLmNyb3NzTGluZVJhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVMYWJlbCA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5sYWJlbFBvaW50ID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5lbmRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pc1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5ncm91cC5hcHBlbmQodGhpcy5jcm9zc0xpbmVSYW5nZSk7XG4gICAgdGhpcy5sYWJlbEdyb3VwLmFwcGVuZCh0aGlzLmNyb3NzTGluZUxhYmVsKTtcbiAgICB0aGlzLmNyb3NzTGluZVJhbmdlLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gIH1cbiAgdXBkYXRlKHZpc2libGUpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGRhdGEsIHR5cGUsIHZhbHVlLCByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmICghdHlwZSB8fCAhc2NhbGUyIHx8ICFlbmFibGVkIHx8ICF2aXNpYmxlIHx8ICF2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyh0eXBlLCB2YWx1ZSwgcmFuZ2UzLCBzY2FsZTIpIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmdyb3VwLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuZ3JvdXAuekluZGV4ID0gdGhpcy5nZXRaSW5kZXgodGhpcy5pc1JhbmdlKTtcbiAgICB0aGlzLnVwZGF0ZU5vZGVzKCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KHZpc2libGUsIHJldmVyc2VkQXhpcykge1xuICAgIGlmICghdmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgZ3JpZExlbmd0aCxcbiAgICAgIHNpZGVGbGFnLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbGFiZWw6IHsgcG9zaXRpb24gPSBcInRvcFwiIH0sXG4gICAgICBjbGlwcGVkUmFuZ2UsXG4gICAgICBzdHJva2VXaWR0aCA9IDBcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICBpZiAoIXNjYWxlMilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBiYW5kd2lkdGggPSBzY2FsZTIuYmFuZHdpZHRoID8/IDA7XG4gICAgY29uc3Qgc3RlcCA9IHNjYWxlMi5zdGVwID8/IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IChyZXZlcnNlZEF4aXMgPyAtMSA6IDEpICogKHNjYWxlMiBpbnN0YW5jZW9mIEJhbmRTY2FsZSA/IChzdGVwIC0gYmFuZHdpZHRoKSAvIDIgOiAwKTtcbiAgICBjb25zdCBbeFN0YXJ0LCB4RW5kXSA9IFswLCBzaWRlRmxhZyAqIGdyaWRMZW5ndGhdO1xuICAgIGxldCBbeVN0YXJ0LCB5RW5kXSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICBjb25zdCBvcmRpbmFsVGltZVNjYWxlUGFkZGluZyA9IHlFbmQgPT09IHZvaWQgMCAmJiBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikgPyBiYW5kd2lkdGggLyAyICsgcGFkZGluZyA6IDA7XG4gICAgbGV0IFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF0gPSBbXG4gICAgICBOdW1iZXIoc2NhbGUyLmNvbnZlcnQoeVN0YXJ0LCB7IGNsYW1wTW9kZTogXCJjbGFtcGVkXCIgfSkpIC0gcGFkZGluZyArIG9yZGluYWxUaW1lU2NhbGVQYWRkaW5nLFxuICAgICAgc2NhbGUyLmNvbnZlcnQoeUVuZCwgeyBjbGFtcE1vZGU6IFwiY2xhbXBlZFwiIH0pICsgYmFuZHdpZHRoICsgcGFkZGluZ1xuICAgIF07XG4gICAgY2xhbXBlZFlTdGFydCA9IGNsYW1wQXJyYXkoY2xhbXBlZFlTdGFydCwgY2xpcHBlZFJhbmdlKTtcbiAgICBjbGFtcGVkWUVuZCA9IGNsYW1wQXJyYXkoY2xhbXBlZFlFbmQsIGNsaXBwZWRSYW5nZSk7XG4gICAgW3lTdGFydCwgeUVuZF0gPSBbTnVtYmVyKHNjYWxlMi5jb252ZXJ0KHlTdGFydCkpICsgb3JkaW5hbFRpbWVTY2FsZVBhZGRpbmcsIHNjYWxlMi5jb252ZXJ0KHlFbmQpICsgYmFuZHdpZHRoXTtcbiAgICBjb25zdCB2YWxpZFJhbmdlID0gKHlTdGFydCA9PT0gY2xhbXBlZFlTdGFydCB8fCB5RW5kID09PSBjbGFtcGVkWUVuZCB8fCBjbGFtcGVkWVN0YXJ0ICE9PSBjbGFtcGVkWUVuZCkgJiYgTWF0aC5hYnMoY2xhbXBlZFlFbmQgLSBjbGFtcGVkWVN0YXJ0KSA+IDA7XG4gICAgaWYgKHZhbGlkUmFuZ2UgJiYgY2xhbXBlZFlTdGFydCA+IGNsYW1wZWRZRW5kKSB7XG4gICAgICBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdID0gW2NsYW1wZWRZRW5kLCBjbGFtcGVkWVN0YXJ0XTtcbiAgICAgIFt5U3RhcnQsIHlFbmRdID0gW3lFbmQsIHlTdGFydF07XG4gICAgfVxuICAgIGlmICh5U3RhcnQgLSBwYWRkaW5nID49IGNsYW1wZWRZU3RhcnQpXG4gICAgICB5U3RhcnQgLT0gcGFkZGluZztcbiAgICBpZiAoeUVuZCArIHBhZGRpbmcgPD0gY2xhbXBlZFlFbmQpXG4gICAgICB5RW5kICs9IHBhZGRpbmc7XG4gICAgdGhpcy5pc1JhbmdlID0gdmFsaWRSYW5nZTtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IHN0cm9rZVdpZHRoID4gMCAmJiB5U3RhcnQgPj0gY2xhbXBlZFlTdGFydCAmJiB5U3RhcnQgPD0gY2xhbXBlZFlTdGFydCArIHBhZGRpbmc7XG4gICAgdGhpcy5lbmRMaW5lID0gc3Ryb2tlV2lkdGggPiAwICYmIHlFbmQgPj0gY2xhbXBlZFlFbmQgLSBiYW5kd2lkdGggLSBwYWRkaW5nICYmIHlFbmQgPD0gY2xhbXBlZFlFbmQ7XG4gICAgaWYgKCF2YWxpZFJhbmdlICYmICF0aGlzLnN0YXJ0TGluZSAmJiAhdGhpcy5lbmRMaW5lKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGF0YSA9IFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF07XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICAgIGNvbnN0IHsgYyA9IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9ID0gbGFiZWxEaXJlY3Rpb25IYW5kbGluZ1twb3NpdGlvbl0gPz8ge307XG4gICAgICBjb25zdCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZIH0gPSBjKHtcbiAgICAgICAgeURpcmVjdGlvbixcbiAgICAgICAgeFN0YXJ0LFxuICAgICAgICB4RW5kLFxuICAgICAgICB5U3RhcnQ6IGNsYW1wZWRZU3RhcnQsXG4gICAgICAgIHlFbmQ6IGNsYW1wZWRZRW5kXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGFiZWxQb2ludCA9IHtcbiAgICAgICAgeDogbGFiZWxYLFxuICAgICAgICB5OiBsYWJlbFlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5vZGVzKCkge1xuICAgIHRoaXMudXBkYXRlUmFuZ2VOb2RlKCk7XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuICAgICAgdGhpcy5wb3NpdGlvbkxhYmVsKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJhbmdlTm9kZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjcm9zc0xpbmVSYW5nZSxcbiAgICAgIHNpZGVGbGFnLFxuICAgICAgZ3JpZExlbmd0aCxcbiAgICAgIGRhdGEsXG4gICAgICBzdGFydExpbmUsXG4gICAgICBlbmRMaW5lLFxuICAgICAgaXNSYW5nZSxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2hcbiAgICB9ID0gdGhpcztcbiAgICBjcm9zc0xpbmVSYW5nZS54MSA9IDA7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueDIgPSBzaWRlRmxhZyAqIGdyaWRMZW5ndGg7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueTEgPSBkYXRhWzBdO1xuICAgIGNyb3NzTGluZVJhbmdlLnkyID0gZGF0YVsxXTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdGFydExpbmUgPSBzdGFydExpbmU7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZW5kTGluZSA9IGVuZExpbmU7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuaXNSYW5nZSA9IGlzUmFuZ2U7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZmlsbCA9IGZpbGw7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eSA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZSA9IHN0cm9rZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoID8/IDE7XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3Ryb2tlT3BhY2l0eSA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLmxpbmVEYXNoID0gbGluZURhc2g7XG4gIH1cbiAgdXBkYXRlTGFiZWwoKSB7XG4gICAgY29uc3QgeyBjcm9zc0xpbmVMYWJlbCwgbGFiZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFsYWJlbC50ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgIGNyb3NzTGluZUxhYmVsLmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICBjcm9zc0xpbmVMYWJlbC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgfVxuICBwb3NpdGlvbkxhYmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNyb3NzTGluZUxhYmVsLFxuICAgICAgbGFiZWxQb2ludDogeyB4ID0gdm9pZCAwLCB5ID0gdm9pZCAwIH0gPSB7fSxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsLCByb3RhdGlvbiwgcG9zaXRpb24gPSBcInRvcFwiLCBwYWRkaW5nID0gMCB9LFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHggPT09IHZvaWQgMCB8fCB5ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uXG4gICAgfSk7XG4gICAgY3Jvc3NMaW5lTGFiZWwucm90YXRpb24gPSBkZWZhdWx0Um90YXRpb24gKyBjb25maWd1cmVkUm90YXRpb247XG4gICAgY3Jvc3NMaW5lTGFiZWwudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICBjcm9zc0xpbmVMYWJlbC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIGNvbnN0IGJib3ggPSBjcm9zc0xpbmVMYWJlbC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgaWYgKCFiYm94KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHlEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi87XG4gICAgY29uc3QgeyB4VHJhbnNsYXRpb24sIHlUcmFuc2xhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbih7XG4gICAgICB5RGlyZWN0aW9uLFxuICAgICAgcGFkZGluZyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYmJveFxuICAgIH0pO1xuICAgIGNyb3NzTGluZUxhYmVsLnRyYW5zbGF0aW9uWCA9IHggKyB4VHJhbnNsYXRpb247XG4gICAgY3Jvc3NMaW5lTGFiZWwudHJhbnNsYXRpb25ZID0geSArIHlUcmFuc2xhdGlvbjtcbiAgfVxuICBnZXRaSW5kZXgoaXNSYW5nZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGlzUmFuZ2UgPyBfQ2FydGVzaWFuQ3Jvc3NMaW5lLlJBTkdFX0xBWUVSX1pJTkRFWCA6IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTElORV9MQVlFUl9aSU5ERVg7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgcmFuZ2U6IHJhbmdlMywgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBpc0NvbnRpbnVvdXMyID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UzPy5bMF0gPz8gdmFsdWU7XG4gICAgbGV0IGVuZCA9IHJhbmdlMz8uWzFdO1xuICAgIGlmICghaXNDb250aW51b3VzMiAmJiBlbmQgPT09IHZvaWQgMCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChpc0NvbnRpbnVvdXMyICYmIHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIGVuZCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgfVxuICBjb21wdXRlTGFiZWxCQm94KCkge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFsYWJlbC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRlbXBUZXh0ID0gbmV3IFRleHQoKTtcbiAgICB0ZW1wVGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICB0ZW1wVGV4dC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgIHRlbXBUZXh0LmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICB0ZW1wVGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICB0ZW1wVGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbFBvaW50OiB7IHggPSB2b2lkIDAsIHkgPSB2b2lkIDAgfSA9IHt9LFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBwb3NpdGlvbiA9IFwidG9wXCIsIHBhZGRpbmcgPSAwIH0sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoeCA9PT0gdm9pZCAwIHx8IHkgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNvbmZpZ3VyZWRSb3RhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGVtcFRleHQucm90YXRpb24gPSBjb25maWd1cmVkUm90YXRpb247XG4gICAgdGVtcFRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICB0ZW1wVGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIGNvbnN0IGJib3ggPSB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgaWYgKCFiYm94KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHlEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi87XG4gICAgY29uc3QgeyB4VHJhbnNsYXRpb24sIHlUcmFuc2xhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbih7XG4gICAgICB5RGlyZWN0aW9uLFxuICAgICAgcGFkZGluZyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYmJveFxuICAgIH0pO1xuICAgIHRlbXBUZXh0LnRyYW5zbGF0aW9uWCA9IHggKyB4VHJhbnNsYXRpb247XG4gICAgdGVtcFRleHQudHJhbnNsYXRpb25ZID0geSArIHlUcmFuc2xhdGlvbjtcbiAgICByZXR1cm4gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICB9XG4gIGNhbGN1bGF0ZVBhZGRpbmcocGFkZGluZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzUmFuZ2UsXG4gICAgICBzdGFydExpbmUsXG4gICAgICBlbmRMaW5lLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbGFiZWw6IHsgcGFkZGluZzogbGFiZWxQYWRkaW5nID0gMCwgcG9zaXRpb24gPSBcInRvcFwiIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlzUmFuZ2UgJiYgIXN0YXJ0TGluZSAmJiAhZW5kTGluZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjcm9zc0xpbmVMYWJlbEJCb3ggPSB0aGlzLmNvbXB1dGVMYWJlbEJCb3goKTtcbiAgICBpZiAoY3Jvc3NMaW5lTGFiZWxCQm94Py54ID09IG51bGwgfHwgY3Jvc3NMaW5lTGFiZWxCQm94Py55ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY2hhcnRQYWRkaW5nID0gY2FsY3VsYXRlTGFiZWxDaGFydFBhZGRpbmcoe1xuICAgICAgeURpcmVjdGlvbjogZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovLFxuICAgICAgcGFkZGluZzogbGFiZWxQYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94OiBjcm9zc0xpbmVMYWJlbEJCb3hcbiAgICB9KTtcbiAgICBwYWRkaW5nLmxlZnQgPSBNYXRoLm1heChwYWRkaW5nLmxlZnQgPz8gMCwgY2hhcnRQYWRkaW5nLmxlZnQgPz8gMCk7XG4gICAgcGFkZGluZy5yaWdodCA9IE1hdGgubWF4KHBhZGRpbmcucmlnaHQgPz8gMCwgY2hhcnRQYWRkaW5nLnJpZ2h0ID8/IDApO1xuICAgIHBhZGRpbmcudG9wID0gTWF0aC5tYXgocGFkZGluZy50b3AgPz8gMCwgY2hhcnRQYWRkaW5nLnRvcCA/PyAwKTtcbiAgICBwYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KHBhZGRpbmcuYm90dG9tID8/IDAsIGNoYXJ0UGFkZGluZy5ib3R0b20gPz8gMCk7XG4gIH1cbn07XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLkxJTkVfTEFZRVJfWklOREVYID0gOSAvKiBTRVJJRVNfQ1JPU1NMSU5FX0xJTkVfWklOREVYICovO1xuX0NhcnRlc2lhbkNyb3NzTGluZS5SQU5HRV9MQVlFUl9aSU5ERVggPSAzIC8qIFNFUklFU19DUk9TU0xJTkVfUkFOR0VfWklOREVYICovO1xuX0NhcnRlc2lhbkNyb3NzTGluZS5MQUJFTF9MQVlFUl9aSU5ERVggPSA4IC8qIFNFUklFU19MQUJFTF9aSU5ERVggKi87XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLmNsYXNzTmFtZSA9IFwiQ3Jvc3NMaW5lXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wicmFuZ2VcIiwgXCJsaW5lXCJdLCBcImEgY3Jvc3NMaW5lIHR5cGVcIiksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEUoXCJyYW5nZVwiKSwgQVJSQVkucmVzdHJpY3QoeyBsZW5ndGg6IDIgfSkpLCB7XG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEUoXCJ2YWx1ZVwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbnZhciBDYXJ0ZXNpYW5Dcm9zc0xpbmUgPSBfQ2FydGVzaWFuQ3Jvc3NMaW5lO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9yZWdpb25zLnRzXG52YXIgUkVHSU9OUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFJFR0lPTlMyKSA9PiB7XG4gIFJFR0lPTlMyW1wiVElUTEVcIl0gPSBcInRpdGxlXCI7XG4gIFJFR0lPTlMyW1wiU1VCVElUTEVcIl0gPSBcInN1YnRpdGxlXCI7XG4gIFJFR0lPTlMyW1wiRk9PVE5PVEVcIl0gPSBcImZvb3Rub3RlXCI7XG4gIFJFR0lPTlMyW1wiTEVHRU5EXCJdID0gXCJsZWdlbmRcIjtcbiAgUkVHSU9OUzJbXCJOQVZJR0FUT1JcIl0gPSBcIm5hdmlnYXRvclwiO1xuICBSRUdJT05TMltcIlBBR0lOQVRJT05cIl0gPSBcInBhZ2luYXRpb25cIjtcbiAgUkVHSU9OUzJbXCJST09UXCJdID0gXCJyb290XCI7XG4gIFJFR0lPTlMyW1wiU0VSSUVTXCJdID0gXCJzZXJpZXNcIjtcbiAgUkVHSU9OUzJbXCJIT1JJWk9OVEFMX0FYRVNcIl0gPSBcImhvcml6b250YWwtYXhlc1wiO1xuICBSRUdJT05TMltcIlZFUlRJQ0FMX0FYRVNcIl0gPSBcInZlcnRpY2FsLWF4ZXNcIjtcbiAgUkVHSU9OUzJbXCJUT09MQkFSXCJdID0gXCJ0b29sYmFyXCI7XG4gIHJldHVybiBSRUdJT05TMjtcbn0pKFJFR0lPTlMgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNHcmlkTGluZS50c1xudmFyIEdSSURfU1RZTEVfS0VZUyA9IFtcInN0cm9rZVwiLCBcImxpbmVEYXNoXCJdO1xudmFyIEdSSURfU1RZTEUgPSBBUlJBWV9PRihcbiAgKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgT2JqZWN0LmtleXModmFsdWUpLmV2ZXJ5KChrZXkpID0+IEdSSURfU1RZTEVfS0VZUy5pbmNsdWRlcyhrZXkpKSxcbiAgXCJvYmplY3RzIHdpdGggZ3JpZGxpbmUgc3R5bGUgcHJvcGVydGllcyBzdWNoIGFzICdzdHJva2UnIG9yICdsaW5lRGFzaCdcIlxuKTtcbnZhciBBeGlzR3JpZExpbmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDE7XG4gICAgdGhpcy5zdHlsZSA9IFtcbiAgICAgIHtcbiAgICAgICAgc3Ryb2tlOiB2b2lkIDAsXG4gICAgICAgIGxpbmVEYXNoOiBbXVxuICAgICAgfVxuICAgIF07XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEdSSURfU1RZTEUpXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcInN0eWxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlZmF1bHQudHNcbmZ1bmN0aW9uIERlZmF1bHQoZGVmYXVsdFZhbHVlLCByZXBsYWNlcyA9IFt2b2lkIDBdKSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKF8sIF9fLCB2KSA9PiB7XG4gICAgaWYgKHJlcGxhY2VzLmluY2x1ZGVzKHYpKSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlKHYpIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0ludGVydmFsLnRzXG52YXIgVElDS19JTlRFUlZBTCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+IDAgfHwgdmFsdWUgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwsXG4gIGBhIG5vbi16ZXJvIHBvc2l0aXZlIE51bWJlciB2YWx1ZSBvciwgZm9yIGEgdGltZSBheGlzLCBhIFRpbWUgSW50ZXJ2YWwgc3VjaCBhcyAnYWdDaGFydHMudGltZS5tb250aCdgXG4pO1xudmFyIEF4aXNJbnRlcnZhbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluU3BhY2luZyA9IE5hTjtcbiAgICB0aGlzLm1heFNwYWNpbmcgPSBOYU47XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShUSUNLX0lOVEVSVkFMLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcInN0ZXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJ2YWx1ZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNSU5fU1BBQ0lORyksXG4gIERlZmF1bHQoTmFOKVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFYX1NQQUNJTkcpLFxuICBEZWZhdWx0KE5hTilcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwibWF4U3BhY2luZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzTGFiZWwudHNcbnZhciBBeGlzTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgIHRoaXMubWluU3BhY2luZyA9IE5hTjtcbiAgICB0aGlzLmNvbG9yID0gXCIjNTc1NzU3XCI7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICAgIHRoaXMubWlycm9yZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmFsbGVsID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaWRlIG9mIHRoZSBheGlzIGxpbmUgdG8gcG9zaXRpb24gdGhlIGxhYmVscyBvbi5cbiAgICogLTEgPSBsZWZ0IChkZWZhdWx0KVxuICAgKiAxID0gcmlnaHRcbiAgICovXG4gIGdldFNpZGVGbGFnKCkge1xuICAgIHJldHVybiB0aGlzLm1pcnJvcmVkID8gMSA6IC0xO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfT1JfTkFOKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJhdm9pZENvbGxpc2lvbnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtaXJyb3JlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcInBhcmFsbGVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzTGluZS50c1xudmFyIEF4aXNMaW5lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMud2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlID0gdm9pZCAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaWNrLnRzXG52YXIgQXhpc1RpY2sgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMud2lkdGggPSAxO1xuICAgIHRoaXMuc2l6ZSA9IDY7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzVGljay5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzVGljay5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVGl0bGUudHNcbnZhciBBeGlzVGl0bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNwYWNpbmcgPSBDYXB0aW9uLlNNQUxMX1BBRERJTkc7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImFsd2F5c1wiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9XUkFQKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVXRpbC50c1xuZnVuY3Rpb24gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KGF4aXMpIHtcbiAgY29uc3QgW3JlcXVlc3RlZFJhbmdlTWluLCByZXF1ZXN0ZWRSYW5nZU1heF0gPSBmaW5kTWluTWF4KGF4aXMucmFuZ2UpO1xuICBjb25zdCBtaW4gPSBNYXRoLmZsb29yKHJlcXVlc3RlZFJhbmdlTWluKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5jZWlsKHJlcXVlc3RlZFJhbmdlTWF4KTtcbiAgcmV0dXJuIHsgbWluLCBtYXgsIHZpc2libGU6IG1pbiAhPT0gbWF4IH07XG59XG52YXIgZnVsbENpcmNsZSA9IE1hdGguUEkgKiAyO1xudmFyIGhhbGZDaXJjbGUgPSBmdWxsQ2lyY2xlIC8gMjtcbmZ1bmN0aW9uIG5vcm1hbGlzZUVuZFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgZGlyZWN0RGlzdGFuY2UgPSBNYXRoLmFicyhlbmQgLSBzdGFydCk7XG4gIGlmIChkaXJlY3REaXN0YW5jZSA8IGhhbGZDaXJjbGUpXG4gICAgcmV0dXJuIGVuZDtcbiAgaWYgKHN0YXJ0ID4gZW5kKVxuICAgIHJldHVybiBlbmQgKyBmdWxsQ2lyY2xlO1xuICByZXR1cm4gZW5kIC0gZnVsbENpcmNsZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zKGN0eCkge1xuICBjb25zdCBvdXRPZkJvdW5kcyA9ICh5LCByYW5nZTMpID0+IHtcbiAgICBjb25zdCBbbWluID0gY3R4Lm1pbiwgbWF4ID0gY3R4Lm1heF0gPSBmaW5kTWluTWF4KHJhbmdlMyA/PyBbXSk7XG4gICAgcmV0dXJuIHkgPCBtaW4gfHwgeSA+IG1heDtcbiAgfTtcbiAgY29uc3QgdGljayA9IHtcbiAgICBmcm9tRm4obm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgbGV0IHkgPSBub2RlLnkxICsgbm9kZS50cmFuc2xhdGlvblk7XG4gICAgICBsZXQgb3BhY2l0eSA9IG5vZGUub3BhY2l0eTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiB8fCBvdXRPZkJvdW5kcyhub2RlLmRhdHVtLnRyYW5zbGF0aW9uWSwgbm9kZS5kYXR1bS5yYW5nZSkpIHtcbiAgICAgICAgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB5OiAwLCB0cmFuc2xhdGlvblk6IHksIG9wYWNpdHksIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c10gfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtLCBzdGF0dXMpIHtcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogeSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgZmluaXNoOiB7XG4gICAgICAgICAgLy8gU2V0IGV4cGxpY2l0IHkgYWZ0ZXIgYW5pbWF0aW9uIHNvIGl0J3MgcGl4ZWwgYWxpZ25lZFxuICAgICAgICAgIHksXG4gICAgICAgICAgdHJhbnNsYXRpb25ZOiAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBpbnRlcm1lZGlhdGVGbihub2RlLCBfZGF0dW0sIF9zdGF0dXMpIHtcbiAgICAgIHJldHVybiB7IHZpc2libGU6ICFvdXRPZkJvdW5kcyhub2RlLnkpIH07XG4gICAgfVxuICB9O1xuICBjb25zdCBsYWJlbCA9IHtcbiAgICBmcm9tRm4obm9kZSwgbmV3RGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgZGF0dW0gPSBub2RlLnByZXZpb3VzRGF0dW0gPz8gbmV3RGF0dW07XG4gICAgICBjb25zdCB4ID0gZGF0dW0ueDtcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS55O1xuICAgICAgY29uc3Qgcm90YXRpb25DZW50ZXJYID0gZGF0dW0ucm90YXRpb25DZW50ZXJYO1xuICAgICAgbGV0IHRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQobm9kZS50cmFuc2xhdGlvblkpO1xuICAgICAgbGV0IHJvdGF0aW9uID0gZGF0dW0ucm90YXRpb247XG4gICAgICBsZXQgb3BhY2l0eSA9IG5vZGUub3BhY2l0eTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiIHx8IG91dE9mQm91bmRzKGRhdHVtLnksIGRhdHVtLnJhbmdlKSkge1xuICAgICAgICByb3RhdGlvbiA9IG5ld0RhdHVtLnJvdGF0aW9uO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiB8fCBvdXRPZkJvdW5kcyhub2RlLmRhdHVtLnksIG5vZGUuZGF0dW0ucmFuZ2UpKSB7XG4gICAgICAgIHRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKTtcbiAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICAgIHJvdGF0aW9uID0gbmV3RGF0dW0ucm90YXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICByb3RhdGlvbkNlbnRlclgsXG4gICAgICAgIHRyYW5zbGF0aW9uWSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c11cbiAgICAgIH07XG4gICAgfSxcbiAgICB0b0ZuKG5vZGUsIGRhdHVtLCBzdGF0dXMpIHtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS54O1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnk7XG4gICAgICBjb25zdCByb3RhdGlvbkNlbnRlclggPSBkYXR1bS5yb3RhdGlvbkNlbnRlclg7XG4gICAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKGRhdHVtLnRyYW5zbGF0aW9uWSk7XG4gICAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgICByb3RhdGlvbiA9IGRhdHVtLnJvdGF0aW9uO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgICByb3RhdGlvbiA9IGRhdHVtLnJvdGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBub3JtYWxpc2VFbmRSb3RhdGlvbihub2RlLnByZXZpb3VzRGF0dW0/LnJvdGF0aW9uID8/IGRhdHVtLnJvdGF0aW9uLCBkYXR1bS5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB4LCB5LCByb3RhdGlvbkNlbnRlclgsIHRyYW5zbGF0aW9uWSwgcm90YXRpb24sIG9wYWNpdHksIGZpbmlzaDogeyByb3RhdGlvbjogZGF0dW0ucm90YXRpb24gfSB9O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbGluZSA9IHtcbiAgICBmcm9tRm4obm9kZSwgZGF0dW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5vZGUucHJldmlvdXNEYXR1bSA/PyBkYXR1bSxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbXCJ1cGRhdGVkXCJdXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9Gbihfbm9kZSwgZGF0dW0pIHtcbiAgICAgIHJldHVybiB7IC4uLmRhdHVtIH07XG4gICAgfVxuICB9O1xuICBjb25zdCBncm91cCA9IHtcbiAgICBmcm9tRm4obm9kZSwgX2RhdHVtKSB7XG4gICAgICBjb25zdCB7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gbm9kZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICB0cmFuc2xhdGlvblgsXG4gICAgICAgIHRyYW5zbGF0aW9uWSxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbXCJ1cGRhdGVkXCJdXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9Gbihfbm9kZSwgZGF0dW0pIHtcbiAgICAgIGNvbnN0IHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBkYXR1bTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICB0cmFuc2xhdGlvblgsXG4gICAgICAgIHRyYW5zbGF0aW9uWVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7IHRpY2ssIGxpbmUsIGxhYmVsLCBncm91cCB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzR3JvdXBGbigpIHtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiBkYXR1bS5yb3RhdGlvbkNlbnRlclgsXG4gICAgICByb3RhdGlvbkNlbnRlclk6IGRhdHVtLnJvdGF0aW9uQ2VudGVyWSxcbiAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0udHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS50cmFuc2xhdGlvbllcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzU2VsZWN0aW9uRm4oY3R4KSB7XG4gIGNvbnN0IHsgdmlzaWJsZTogcmFuZ2VWaXNpYmxlLCBtaW4sIG1heCB9ID0gY3R4O1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHJhbmdlVmlzaWJsZSAmJiB5ID49IG1pbiAmJiB5IDw9IG1heDtcbiAgICByZXR1cm4ge1xuICAgICAgeSxcbiAgICAgIHRyYW5zbGF0aW9uWTogMCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB2aXNpYmxlXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm4oKSB7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGRhdHVtLngsXG4gICAgICB5OiBkYXR1bS55LFxuICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS50cmFuc2xhdGlvblksXG4gICAgICByb3RhdGlvbjogZGF0dW0ucm90YXRpb24sXG4gICAgICByb3RhdGlvbkNlbnRlclg6IGRhdHVtLnJvdGF0aW9uQ2VudGVyWFxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4oKSB7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgcmV0dXJuIHsgLi4uZGF0dW0gfTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzLnRzXG52YXIgX0F4aXMgPSBjbGFzcyBfQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCwgc2NhbGUyKSB7XG4gICAgdGhpcy5tb2R1bGVDdHggPSBtb2R1bGVDdHg7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlMjtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5uaWNlID0gdHJ1ZTtcbiAgICB0aGlzLnJldmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLmludGVydmFsID0gbmV3IEF4aXNJbnRlcnZhbCgpO1xuICAgIHRoaXMuZGF0YURvbWFpbiA9IHsgZG9tYWluOiBbXSwgY2xpcHBlZDogZmFsc2UgfTtcbiAgICB0aGlzLmxheW91dENvbnN0cmFpbnRzID0ge1xuICAgICAgc3RhY2tlZDogdHJ1ZSxcbiAgICAgIGFsaWduOiBcInN0YXJ0XCIsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgdW5pdDogXCJwZXJjZW50XCJcbiAgICB9O1xuICAgIHRoaXMuYm91bmRTZXJpZXMgPSBbXTtcbiAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuYXhpc0dyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tYXhpc2AsIHpJbmRleDogMiAvKiBBWElTX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLmxpbmVOb2RlID0gdGhpcy5heGlzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IExpbmUoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLWxpbmVgIH0pKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtdGljay1saW5lc2AsIHpJbmRleDogMiAvKiBBWElTX1pJTkRFWCAqLyB9KVxuICAgICk7XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cCA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy10aWNrLWxhYmVsc2AsIHpJbmRleDogMiAvKiBBWElTX1pJTkRFWCAqLyB9KVxuICAgICk7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUNyb3NzTGluZXNgIH0pO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUxhYmVsc2AsIHpJbmRleDogMTAgLyogU0VSSUVTX0FOTk9UQVRJT05fWklOREVYICovIH0pO1xuICAgIHRoaXMuZ3JpZEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy1ncmlkYCB9KTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXAgPSB0aGlzLmdyaWRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWdyaWRMaW5lc2AsXG4gICAgICAgIHpJbmRleDogMSAvKiBBWElTX0dSSURfWklOREVYICovXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLnRpY2tMaW5lR3JvdXAsIExpbmUsIGZhbHNlKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLnRpY2tMYWJlbEdyb3VwLCBUZXh0LCBmYWxzZSk7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmdyaWRMaW5lR3JvdXAsIExpbmUsIGZhbHNlKTtcbiAgICB0aGlzLl9jcm9zc0xpbmVzID0gW107XG4gICAgdGhpcy5saW5lID0gbmV3IEF4aXNMaW5lKCk7XG4gICAgdGhpcy50aWNrID0gbmV3IEF4aXNUaWNrKCk7XG4gICAgdGhpcy5ncmlkTGluZSA9IG5ldyBBeGlzR3JpZExpbmUoKTtcbiAgICB0aGlzLmxhYmVsID0gdGhpcy5jcmVhdGVMYWJlbCgpO1xuICAgIHRoaXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nID0gX0F4aXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nO1xuICAgIHRoaXMudHJhbnNsYXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAvLyBheGlzIHJvdGF0aW9uIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICB0aGlzLmxheW91dCA9IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGZyYWN0aW9uRGlnaXRzOiAwLFxuICAgICAgICBwYWRkaW5nOiB0aGlzLmxhYmVsLnBhZGRpbmcsXG4gICAgICAgIGZvcm1hdDogdGhpcy5sYWJlbC5mb3JtYXRcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMucmFuZ2UgPSBbMCwgMV07XG4gICAgdGhpcy52aXNpYmxlUmFuZ2UgPSBbMCwgMV07XG4gICAgdGhpcy50aXRsZSA9IG5ldyBBeGlzVGl0bGUoKTtcbiAgICB0aGlzLl90aXRsZUNhcHRpb24gPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuZ3JpZExlbmd0aCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdyaWQgdGlja3MgYW5kIHRoZSBheGlzIHRpY2tzLlxuICAgICAqL1xuICAgIHRoaXMuZ3JpZFBhZGRpbmcgPSAwO1xuICAgIC8qKlxuICAgICAqIElzIHVzZWQgdG8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGF4aXMgbGFiZWxzIGFuZCBzZXJpZXMuXG4gICAgICovXG4gICAgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyA9IDA7XG4gICAgdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFRoaWNrbmVzcyA9IEluZmluaXR5O1xuICAgIHRoaXMubW9kdWxlTWFwID0gbmV3IE1vZHVsZU1hcCgpO1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNjYWxlLnJhbmdlLnNsaWNlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHRoaXMuX3RpdGxlQ2FwdGlvbi5yZWdpc3RlckludGVyYWN0aW9uKHRoaXMubW9kdWxlQ3R4KSk7XG4gICAgdGhpcy5fdGl0bGVDYXB0aW9uLm5vZGUucm90YXRpb24gPSAtTWF0aC5QSSAvIDI7XG4gICAgdGhpcy5heGlzR3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5fdGl0bGVDYXB0aW9uLm5vZGUpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IG1vZHVsZUN0eC5hbmltYXRpb25NYW5hZ2VyO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFwiZW1wdHlcIiwge1xuICAgICAgZW1wdHk6IHtcbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgYWN0aW9uOiAoKSA9PiB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKVxuICAgICAgICB9LFxuICAgICAgICByZXNldDogXCJlbXB0eVwiXG4gICAgICB9LFxuICAgICAgcmVhZHk6IHtcbiAgICAgICAgdXBkYXRlOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlVcGRhdGUoZGF0YSksXG4gICAgICAgIHJlc2l6ZTogKCkgPT4gdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCksXG4gICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9jcm9zc0xpbmVzID0gW107XG4gICAgbGV0IHByZXZpb3VzU2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIG1vZHVsZUN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91c1NpemUgIT0gbnVsbCAmJiBqc29uRGlmZihlLmNoYXJ0LCBwcmV2aW91c1NpemUpICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNTaXplID0geyAuLi5lLmNoYXJ0IH07XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZSA/PyBcIlwiO1xuICB9XG4gIHNldCBjcm9zc0xpbmVzKHZhbHVlKSB7XG4gICAgY29uc3QgeyBDcm9zc0xpbmVDb25zdHJ1Y3RvciB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB0aGlzLl9jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5kZXRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcyA9IHZhbHVlLm1hcCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDcm9zc0xpbmVDb25zdHJ1Y3RvcigpO1xuICAgICAgaW5zdGFuY2Uuc2V0KGNyb3NzTGluZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSk7XG4gICAgICB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgY3Jvc3NMaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3Jvc3NMaW5lcztcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH1cbiAgfVxuICBhdHRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5hcHBlbmRDaGlsZChjcm9zc0xpbmUuZ3JvdXApO1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAuYXBwZW5kQ2hpbGQoY3Jvc3NMaW5lLmxhYmVsR3JvdXApO1xuICB9XG4gIGRldGFjaENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLnJlbW92ZUNoaWxkKGNyb3NzTGluZS5ncm91cCk7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5yZW1vdmVDaGlsZChjcm9zc0xpbmUubGFiZWxHcm91cCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1vZHVsZU1hcC5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gIH1cbiAgdXBkYXRlUmFuZ2UoKSB7XG4gICAgY29uc3QgeyByYW5nZTogcnIsIHZpc2libGVSYW5nZTogdnIsIHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3BhbiA9IChyclsxXSAtIHJyWzBdKSAvICh2clsxXSAtIHZyWzBdKTtcbiAgICBjb25zdCBzaGlmdCA9IHNwYW4gKiB2clswXTtcbiAgICBjb25zdCBzdGFydCA9IHJyWzBdIC0gc2hpZnQ7XG4gICAgc2NhbGUyLnNldFZpc2libGVSYW5nZT8uKHZyKTtcbiAgICBzY2FsZTIucmFuZ2UgPSBbc3RhcnQsIHN0YXJ0ICsgc3Bhbl07XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgY3Jvc3NMaW5lLmNsaXBwZWRSYW5nZSA9IFtyclswXSwgcnJbMV1dO1xuICAgIH0pO1xuICB9XG4gIHNldENyb3NzTGluZXNWaXNpYmxlKHZpc2libGUpIHtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIGF0dGFjaEF4aXMoYXhpc05vZGUsIGdyaWROb2RlKSB7XG4gICAgZ3JpZE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ncmlkR3JvdXApO1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyb3NzTGluZUdyb3VwKTtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsR3JvdXApO1xuICB9XG4gIGF0dGFjaExhYmVsKGF4aXNMYWJlbE5vZGUpIHtcbiAgICB0aGlzLmxhYmVsR3JvdXAuYXBwZW5kKGF4aXNMYWJlbE5vZGUpO1xuICB9XG4gIGRldGFjaEF4aXMoYXhpc05vZGUsIGdyaWROb2RlKSB7XG4gICAgZ3JpZE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ncmlkR3JvdXApO1xuICAgIGF4aXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICBheGlzTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNyb3NzTGluZUdyb3VwKTtcbiAgICBheGlzTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmxhYmVsR3JvdXApO1xuICB9XG4gIGdldEF4aXNHcm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzR3JvdXA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHBvaW50IG9yIGFuIG9iamVjdCBpcyBpbiByYW5nZS5cbiAgICogQHBhcmFtIHggQSBwb2ludCAob3Igb2JqZWN0J3Mgc3RhcnRpbmcgcG9pbnQpLlxuICAgKiBAcGFyYW0gdG9sZXJhbmNlIEV4cGFuZHMgdGhlIHJhbmdlIG9uIGJvdGggZW5kcyBieSB0aGlzIGFtb3VudC5cbiAgICovXG4gIGluUmFuZ2UoeCwgdG9sZXJhbmNlID0gMCkge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMucmFuZ2UpO1xuICAgIHJldHVybiB4ID49IG1pbiAtIHRvbGVyYW5jZSAmJiB4IDw9IG1heCArIHRvbGVyYW5jZTtcbiAgfVxuICBvbkZvcm1hdENoYW5nZSh0aWNrcywgZnJhY3Rpb25EaWdpdHMsIF9kb21haW4sIGZvcm1hdCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBsb2dTY2FsZSA9IHNjYWxlMiBpbnN0YW5jZW9mIExvZ1NjYWxlO1xuICAgIGNvbnN0IGRlZmF1bHRGb3JtYXR0ZXIgPSAoZm9ybWF0T2Zmc2V0KSA9PiBsb2dTY2FsZSA/IFN0cmluZyA6ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IHgudG9GaXhlZChmcmFjdGlvbkRpZ2l0cyArIGZvcm1hdE9mZnNldCkgOiBTdHJpbmcoeCk7XG4gICAgaWYgKGZvcm1hdCAmJiBzY2FsZTIgJiYgc2NhbGUyLnRpY2tGb3JtYXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IHNjYWxlMi50aWNrRm9ybWF0KHsgdGlja3MsIHNwZWNpZmllcjogZm9ybWF0IH0pO1xuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZGVmYXVsdEZvcm1hdHRlcigwKTtcbiAgICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMSk7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgdGhlIGF4aXMgbGFiZWwgZm9ybWF0IHN0cmluZyAke2Zvcm1hdH0gaXMgaW52YWxpZC4gTm8gZm9ybWF0dGluZyB3aWxsIGJlIGFwcGxpZWRgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMCk7XG4gICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gZGVmYXVsdEZvcm1hdHRlcigxKTtcbiAgICB9XG4gIH1cbiAgc2V0VGlja0ludGVydmFsKGludGVydmFsKSB7XG4gICAgdGhpcy5zY2FsZS5pbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWw/LnN0ZXAgPz8gaW50ZXJ2YWw7XG4gIH1cbiAgb25HcmlkTGVuZ3RoQ2hhbmdlKHZhbHVlLCBwcmV2VmFsdWUpIHtcbiAgICBpZiAocHJldlZhbHVlICYmICF2YWx1ZSB8fCAhcHJldlZhbHVlICYmIHZhbHVlKSB7XG4gICAgICB0aGlzLm9uR3JpZFZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICB9XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkpO1xuICB9XG4gIG9uR3JpZFZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLmNsZWFyKCk7XG4gIH1cbiAgY3JlYXRlTGFiZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBBeGlzTGFiZWwoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcy9yZW1vdmVzL3VwZGF0ZXMgdGhlIHNjZW5lIGdyYXBoIG5vZGVzIHRoYXQgY29uc3RpdHV0ZSB0aGUgYXhpcy5cbiAgICovXG4gIHVwZGF0ZShfcHJpbWFyeVRpY2tDb3VudCA9IDAsIGFuaW1hdGVkID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3QgbGluZURhdGEgPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCB7IHRpY2tEYXRhLCBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiwgcHJpbWFyeVRpY2tDb3VudCB9ID0gdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdDtcbiAgICBjb25zdCBwcmV2aW91c1RpY2tzID0gdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi5ub2RlcygpLm1hcCgobm9kZSkgPT4gbm9kZS5kYXR1bS50aWNrSWQpO1xuICAgIHRoaXMudXBkYXRlU2VsZWN0aW9ucyhsaW5lRGF0YSwgdGlja0RhdGEudGlja3MsIHtcbiAgICAgIGNvbWJpbmVkUm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICByYW5nZTogdGhpcy5zY2FsZS5yYW5nZVxuICAgIH0pO1xuICAgIGlmICghYW5pbWF0ZWQgfHwgdGhpcy5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlmZjIgPSB0aGlzLmNhbGN1bGF0ZVVwZGF0ZURpZmYocHJldmlvdXNUaWNrcywgdGlja0RhdGEpO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGRpZmYyKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBeGlzTGluZSgpO1xuICAgIHRoaXMudXBkYXRlTGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy51cGRhdGVHcmlkTGluZXMoc2lkZUZsYWcpO1xuICAgIHRoaXMudXBkYXRlVGlja0xpbmVzKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZSh7IGFueVRpY2tWaXNpYmxlOiB0aWNrRGF0YS50aWNrcy5sZW5ndGggPiAwIH0pO1xuICAgIHRoaXMudXBkYXRlQ3Jvc3NMaW5lcyh7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9KTtcbiAgICB0aGlzLnVwZGF0ZUxheW91dFN0YXRlKHRpY2tEYXRhLmZyYWN0aW9uRGlnaXRzKTtcbiAgICByZXR1cm4gcHJpbWFyeVRpY2tDb3VudDtcbiAgfVxuICBnZXRBeGlzTGluZUNvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMucmFuZ2UpO1xuICAgIHJldHVybiB7IHg6IDAsIHkxOiBtaW4sIHkyOiBtYXggfTtcbiAgfVxuICBnZXRUaWNrTGluZUNvb3JkaW5hdGVzKGRhdHVtKSB7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgeCA9IHNpZGVGbGFnICogdGhpcy5nZXRUaWNrU2l6ZSgpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oMCwgeCk7XG4gICAgY29uc3QgeDIgPSB4MSArIE1hdGguYWJzKHgpO1xuICAgIGNvbnN0IHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgcmV0dXJuIHsgeDEsIHgyLCB5IH07XG4gIH1cbiAgZ2V0VGlja0xhYmVsUHJvcHMoZGF0dW0sIHBhcmFtcykge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiwgcmFuZ2U6IHJhbmdlMyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRleHQgPSBkYXR1bS50aWNrTGFiZWw7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGxhYmVsWCA9IHNpZGVGbGFnICogKHRoaXMuZ2V0VGlja1NpemUoKSArIGxhYmVsLnBhZGRpbmcgKyB0aGlzLnNlcmllc0FyZWFQYWRkaW5nKTtcbiAgICBjb25zdCB2aXNpYmxlID0gdGV4dCAhPT0gXCJcIiAmJiB0ZXh0ICE9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpY2tJZDogZGF0dW0udGlja0lkLFxuICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS50cmFuc2xhdGlvblksXG4gICAgICBmaWxsOiBsYWJlbC5jb2xvcixcbiAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICByb3RhdGlvbjogY29tYmluZWRSb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogbGFiZWxYLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHZpc2libGUsXG4gICAgICB4OiBsYWJlbFgsXG4gICAgICB5OiAwLFxuICAgICAgcmFuZ2U6IHJhbmdlM1xuICAgIH07XG4gIH1cbiAgZ2V0VGlja1NpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGljay5lbmFibGVkID8gdGhpcy50aWNrLnNpemUgOiA2O1xuICB9XG4gIHNldFRpdGxlUHJvcHMoY2FwdGlvbiwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNhcHRpb24uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgY2FwdGlvbi5ub2RlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FwdGlvbi5jb2xvciA9IHRpdGxlLmNvbG9yO1xuICAgIGNhcHRpb24uZm9udEZhbWlseSA9IHRpdGxlLmZvbnRGYW1pbHk7XG4gICAgY2FwdGlvbi5mb250U2l6ZSA9IHRpdGxlLmZvbnRTaXplO1xuICAgIGNhcHRpb24uZm9udFN0eWxlID0gdGl0bGUuZm9udFN0eWxlO1xuICAgIGNhcHRpb24uZm9udFdlaWdodCA9IHRpdGxlLmZvbnRXZWlnaHQ7XG4gICAgY2FwdGlvbi5lbmFibGVkID0gdGl0bGUuZW5hYmxlZDtcbiAgICBjYXB0aW9uLndyYXBwaW5nID0gdGl0bGUud3JhcHBpbmc7XG4gICAgY29uc3QgdGl0bGVOb2RlID0gY2FwdGlvbi5ub2RlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSAodGl0bGUuc3BhY2luZyA/PyAwKSArIHBhcmFtcy5zcGFjaW5nO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdGl0bGVSb3RhdGlvbkZsYWcgPSBzaWRlRmxhZyA9PT0gLTEgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPiBNYXRoLlBJICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uIDwgTWF0aC5QSSAqIDIgPyAtMSA6IDE7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aXRsZVJvdGF0aW9uRmxhZyAqIHNpZGVGbGFnICogTWF0aC5QSSAvIDI7XG4gICAgY29uc3QgdGV4dEJhc2VsaW5lID0gdGl0bGVSb3RhdGlvbkZsYWcgPT09IDEgPyBcImJvdHRvbVwiIDogXCJ0b3BcIjtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgeCA9IE1hdGguZmxvb3IodGl0bGVSb3RhdGlvbkZsYWcgKiBzaWRlRmxhZyAqIChyYW5nZTNbMF0gKyByYW5nZTNbMV0pIC8gMik7XG4gICAgY29uc3QgeSA9IHNpZGVGbGFnID09PSAtMSA/IE1hdGguZmxvb3IodGl0bGVSb3RhdGlvbkZsYWcgKiAtcGFkZGluZykgOiBNYXRoLmZsb29yKC1wYWRkaW5nKTtcbiAgICBjb25zdCB7IGNhbGxiYWNrQ2FjaGUgfSA9IHRoaXMubW9kdWxlQ3R4O1xuICAgIGNvbnN0IHsgZm9ybWF0dGVyID0gKHApID0+IHAuZGVmYXVsdFZhbHVlIH0gPSB0aXRsZTtcbiAgICBjb25zdCB0ZXh0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwgdGhpcy5nZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpKTtcbiAgICB0aXRsZU5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHQsXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9KTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH0gPSB0aGlzLmNhbGN1bGF0ZVJvdGF0aW9ucygpO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGxhYmVsWCA9IHNpZGVGbGFnICogKHRoaXMuZ2V0VGlja1NpemUoKSArIHRoaXMubGFiZWwucGFkZGluZyArIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xuICAgIHRoaXMudXBkYXRlU2NhbGUoKTtcbiAgICB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0ID0gdGhpcy5nZW5lcmF0ZVRpY2tzKHtcbiAgICAgIHByaW1hcnlUaWNrQ291bnQsXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBsYWJlbFgsXG4gICAgICBzaWRlRmxhZ1xuICAgIH0pO1xuICAgIGNvbnN0IHsgdGlja0RhdGEsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduLCAuLi50aWNrc1Jlc3VsdCB9ID0gdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdDtcbiAgICB0aGlzLnVwZGF0ZUxheW91dFN0YXRlKHRpY2tEYXRhLmZyYWN0aW9uRGlnaXRzKTtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IHsgeCwgeTEsIHkyIH0gPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBsaW5lQm94ID0gbmV3IEJCb3goXG4gICAgICB4ICsgTWF0aC5taW4oc2lkZUZsYWcgKiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLCAwKSxcbiAgICAgIHkxLFxuICAgICAgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyxcbiAgICAgIHkyIC0geTFcbiAgICApO1xuICAgIGJveGVzLnB1c2gobGluZUJveCk7XG4gICAgaWYgKHRoaXMudGljay5lbmFibGVkKSB7XG4gICAgICB0aWNrRGF0YS50aWNrcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCB7IHgxLCB4MiwgeSB9ID0gdGhpcy5nZXRUaWNrTGluZUNvb3JkaW5hdGVzKGRhdHVtKTtcbiAgICAgICAgY29uc3QgdGlja0xpbmVCb3ggPSBuZXcgQkJveCh4MSwgeSwgeDIgLSB4MSwgMCk7XG4gICAgICAgIGJveGVzLnB1c2godGlja0xpbmVCb3gpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhYmVsLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBUZXh0ID0gbmV3IFRleHQoKTtcbiAgICAgIHRpY2tEYXRhLnRpY2tzLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB0aGlzLmdldFRpY2tMYWJlbFByb3BzKGRhdHVtLCB7XG4gICAgICAgICAgY29tYmluZWRSb3RhdGlvbixcbiAgICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHJhbmdlOiB0aGlzLnNjYWxlLnJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWxhYmVsUHJvcHMudmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAuLi5sYWJlbFByb3BzLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWTogTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBib3ggPSB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50aXRsZT8uZW5hYmxlZCkge1xuICAgICAgY29uc3QgY2FwdGlvbiA9IG5ldyBDYXB0aW9uKCk7XG4gICAgICBjb25zdCBzcGFjaW5nID0gQkJveC5tZXJnZShib3hlcykud2lkdGg7XG4gICAgICB0aGlzLnNldFRpdGxlUHJvcHMoY2FwdGlvbiwgeyBzcGFjaW5nIH0pO1xuICAgICAgY29uc3QgdGl0bGVOb2RlID0gY2FwdGlvbi5ub2RlO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZU5vZGUuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYm94ID0gQkJveC5tZXJnZShib3hlcyk7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCQm94ID0gdGhpcy5nZXRUcmFuc2Zvcm1Cb3goYmJveCk7XG4gICAgY29uc3QgYW55U2VyaWVzQWN0aXZlID0gdGhpcy5pc0FueVNlcmllc0FjdGl2ZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNyb3NzTGluZS5zaWRlRmxhZyA9IC1zaWRlRmxhZztcbiAgICAgIGNyb3NzTGluZS5kaXJlY3Rpb24gPSByb3RhdGlvbiA9PT0gLU1hdGguUEkgLyAyID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gICAgICBpZiAoY3Jvc3NMaW5lIGluc3RhbmNlb2YgQ2FydGVzaWFuQ3Jvc3NMaW5lKSB7XG4gICAgICAgIChfYSA9IGNyb3NzTGluZS5sYWJlbCkucGFyYWxsZWwgPz8gKF9hLnBhcmFsbGVsID0gdGhpcy5sYWJlbC5wYXJhbGxlbCk7XG4gICAgICB9XG4gICAgICBjcm9zc0xpbmUucGFyYWxsZWxGbGlwUm90YXRpb24gPSBwYXJhbGxlbEZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS5yZWd1bGFyRmxpcFJvdGF0aW9uID0gcmVndWxhckZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS5jYWxjdWxhdGVMYXlvdXQ/LihhbnlTZXJpZXNBY3RpdmUsIHRoaXMucmV2ZXJzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW1hcnlUaWNrQ291bnQ6IHRpY2tzUmVzdWx0LnByaW1hcnlUaWNrQ291bnQsXG4gICAgICBiYm94OiB0cmFuc2Zvcm1lZEJCb3hcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUxheW91dFN0YXRlKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdGhpcy5sYXlvdXQubGFiZWwgPSB7XG4gICAgICBmcmFjdGlvbkRpZ2l0cyxcbiAgICAgIHBhZGRpbmc6IHRoaXMubGFiZWwucGFkZGluZyxcbiAgICAgIGZvcm1hdDogdGhpcy5sYWJlbC5mb3JtYXRcbiAgICB9O1xuICB9XG4gIGdldFRyYW5zZm9ybUJveChiYm94KSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uOiBheGlzUm90YXRpb24sXG4gICAgICB0cmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblksXG4gICAgICByb3RhdGlvbkNlbnRlclgsXG4gICAgICByb3RhdGlvbkNlbnRlcllcbiAgICB9ID0gdGhpcy5nZXRBeGlzVHJhbnNmb3JtKCk7XG4gICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIDEsIDEsIGF4aXNSb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIHtcbiAgICAgIHNjYWxpbmdDZW50ZXJYOiAwLFxuICAgICAgc2NhbGluZ0NlbnRlclk6IDAsXG4gICAgICByb3RhdGlvbkNlbnRlclgsXG4gICAgICByb3RhdGlvbkNlbnRlcllcbiAgICB9KTtcbiAgICByZXR1cm4gbWF0cml4LnRyYW5zZm9ybUJCb3goYmJveCk7XG4gIH1cbiAgc2V0RG9tYWluKGRvbWFpbikge1xuICAgIHRoaXMuZGF0YURvbWFpbiA9IHRoaXMubm9ybWFsaXNlRGF0YURvbWFpbihkb21haW4pO1xuICAgIGlmICh0aGlzLnJldmVyc2UpIHtcbiAgICAgIHRoaXMuZGF0YURvbWFpbi5kb21haW4ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlLmRvbWFpbiA9IHRoaXMuZGF0YURvbWFpbi5kb21haW47XG4gIH1cbiAgdXBkYXRlU2NhbGUoKSB7XG4gICAgdGhpcy51cGRhdGVSYW5nZSgpO1xuICAgIHRoaXMuY2FsY3VsYXRlRG9tYWluKCk7XG4gICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwodGhpcy5pbnRlcnZhbC5zdGVwKTtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIsIG5pY2UgfSA9IHRoaXM7XG4gICAgaWYgKCFDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2FsZTIubmljZSA9IG5pY2U7XG4gICAgc2NhbGUyLnVwZGF0ZSgpO1xuICB9XG4gIGNhbGN1bGF0ZVJvdGF0aW9ucygpIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uKTtcbiAgICBjb25zdCByZWd1bGFyRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24gLSBNYXRoLlBJIC8gMik7XG4gICAgcmV0dXJuIHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH07XG4gIH1cbiAgZ2VuZXJhdGVUaWNrcyh7XG4gICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgIGxhYmVsWCxcbiAgICBzaWRlRmxhZ1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGludGVydmFsOiB7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsLCByb3RhdGlvbiwgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2Vjb25kYXJ5QXhpcyA9IHByaW1hcnlUaWNrQ291bnQgIT09IHZvaWQgMDtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uLCBwYXJhbGxlbEZsaXBGbGFnLCByZWd1bGFyRmxpcEZsYWcgfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxSb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbiArIGRlZmF1bHRSb3RhdGlvbjtcbiAgICBjb25zdCBsYWJlbE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCB9ID0gdGhpcy5lc3RpbWF0ZVRpY2tDb3VudCh7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSk7XG4gICAgY29uc3QgY29udGludW91cyA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gIWNvbnRpbnVvdXMgfHwgaXNOYU4obWF4VGlja0NvdW50KSA/IDEwIDogbWF4VGlja0NvdW50O1xuICAgIGxldCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ24ocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgMCwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZyk7XG4gICAgY29uc3QgdGV4dEJhc2VsaW5lID0gZ2V0VGV4dEJhc2VsaW5lKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIHNpZGVGbGFnLCBwYXJhbGxlbEZsaXBGbGFnKTtcbiAgICBjb25zdCBmb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZyh7IGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQgfSk7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgY29uc3QgdGV4dFByb3BzID0ge1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHRleHRBbGlnblxuICAgIH07XG4gICAgbGV0IHRpY2tEYXRhID0ge1xuICAgICAgcmF3VGlja3M6IFtdLFxuICAgICAgZnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICB0aWNrczogW10sXG4gICAgICBsYWJlbENvdW50OiAwXG4gICAgfTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBhdXRvUm90YXRpb24gPSAwO1xuICAgIGxldCBsYWJlbE92ZXJsYXAgPSB0cnVlO1xuICAgIGxldCB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB3aGlsZSAobGFiZWxPdmVybGFwICYmIGluZGV4IDw9IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhdXRvUm90YXRpb24gPSAwO1xuICAgICAgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIDAsIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xuICAgICAgY29uc3QgdGlja1N0cmF0ZWdpZXMgPSB0aGlzLmdldFRpY2tTdHJhdGVnaWVzKHsgc2Vjb25kYXJ5QXhpcywgaW5kZXggfSk7XG4gICAgICBmb3IgKGNvbnN0IHN0cmF0ZWd5IG9mIHRpY2tTdHJhdGVnaWVzKSB7XG4gICAgICAgICh7IHRpY2tEYXRhLCBpbmRleCwgYXV0b1JvdGF0aW9uLCB0ZXJtaW5hdGUgfSA9IHN0cmF0ZWd5KHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0aWNrRGF0YSxcbiAgICAgICAgICB0ZXh0UHJvcHMsXG4gICAgICAgICAgbGFiZWxPdmVybGFwLFxuICAgICAgICAgIHRlcm1pbmF0ZSxcbiAgICAgICAgICBwcmltYXJ5VGlja0NvdW50XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgcm90YXRlZCA9IGNvbmZpZ3VyZWRSb3RhdGlvbiAhPT0gMCB8fCBhdXRvUm90YXRpb24gIT09IDA7XG4gICAgICAgIGNvbnN0IGxhYmVsUm90YXRpb24gPSBpbml0aWFsUm90YXRpb24gKyBhdXRvUm90YXRpb247XG4gICAgICAgIHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCBhdXRvUm90YXRpb24sIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xuICAgICAgICBsYWJlbE92ZXJsYXAgPSB0aGlzLmxhYmVsLmF2b2lkQ29sbGlzaW9ucyA/IHRoaXMuY2hlY2tMYWJlbE92ZXJsYXAobGFiZWxSb3RhdGlvbiwgcm90YXRlZCwgbGFiZWxNYXRyaXgsIHRpY2tEYXRhLnRpY2tzLCBsYWJlbFgsIHRleHRNZWFzdXJlcikgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRSb3RhdGlvbiA9IGRlZmF1bHRSb3RhdGlvbiArIGNvbmZpZ3VyZWRSb3RhdGlvbiArIGF1dG9Sb3RhdGlvbjtcbiAgICBpZiAoIXNlY29uZGFyeUF4aXMgJiYgdGlja0RhdGEucmF3VGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJpbWFyeVRpY2tDb3VudCA9IHRpY2tEYXRhLnJhd1RpY2tzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH07XG4gIH1cbiAgZ2V0VGlja1N0cmF0ZWdpZXMoe1xuICAgIGluZGV4OiBpdGVyYXRpb24sXG4gICAgc2Vjb25kYXJ5QXhpc1xuICB9KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyLCBsYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1pblNwYWNpbmcgfSA9IHRoaXMuaW50ZXJ2YWw7XG4gICAgY29uc3QgY29udGludW91cyA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgICBjb25zdCBhdm9pZExhYmVsQ29sbGlzaW9ucyA9IGxhYmVsLmVuYWJsZWQgJiYgbGFiZWwuYXZvaWRDb2xsaXNpb25zO1xuICAgIGNvbnN0IGZpbHRlclRpY2tzID0gIWNvbnRpbnVvdXMgJiYgaXRlcmF0aW9uICE9PSAwICYmIGF2b2lkTGFiZWxDb2xsaXNpb25zO1xuICAgIGNvbnN0IGF1dG9Sb3RhdGUgPSBsYWJlbC5hdXRvUm90YXRlID09PSB0cnVlICYmIGxhYmVsLnJvdGF0aW9uID09PSB2b2lkIDA7XG4gICAgY29uc3Qgc3RyYXRlZ2llcyA9IFtdO1xuICAgIGxldCB0aWNrR2VuZXJhdGlvblR5cGU7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwudmFsdWVzKSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAzIC8qIFZBTFVFUyAqLztcbiAgICB9IGVsc2UgaWYgKHNlY29uZGFyeUF4aXMpIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDEgLyogQ1JFQVRFX1NFQ09OREFSWSAqLztcbiAgICB9IGVsc2UgaWYgKGZpbHRlclRpY2tzKSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAyIC8qIEZJTFRFUiAqLztcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMCAvKiBDUkVBVEUgKi87XG4gICAgfVxuICAgIGNvbnN0IHRpY2tHZW5lcmF0aW9uU3RyYXRlZ3kgPSAoeyBpbmRleCwgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIHRlcm1pbmF0ZSB9KSA9PiB0aGlzLmNyZWF0ZVRpY2tEYXRhKHRpY2tHZW5lcmF0aW9uVHlwZSwgaW5kZXgsIHRpY2tEYXRhLCB0ZXJtaW5hdGUsIHByaW1hcnlUaWNrQ291bnQpO1xuICAgIHN0cmF0ZWdpZXMucHVzaCh0aWNrR2VuZXJhdGlvblN0cmF0ZWd5KTtcbiAgICBpZiAoIWNvbnRpbnVvdXMgJiYgIWlzTmFOKG1pblNwYWNpbmcpKSB7XG4gICAgICBjb25zdCB0aWNrRmlsdGVyU3RyYXRlZ3kgPSAoeyBpbmRleCwgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIHRlcm1pbmF0ZSB9KSA9PiB0aGlzLmNyZWF0ZVRpY2tEYXRhKDIgLyogRklMVEVSICovLCBpbmRleCwgdGlja0RhdGEsIHRlcm1pbmF0ZSwgcHJpbWFyeVRpY2tDb3VudCk7XG4gICAgICBzdHJhdGVnaWVzLnB1c2godGlja0ZpbHRlclN0cmF0ZWd5KTtcbiAgICB9XG4gICAgaWYgKCFhdm9pZExhYmVsQ29sbGlzaW9ucykge1xuICAgICAgcmV0dXJuIHN0cmF0ZWdpZXM7XG4gICAgfVxuICAgIGlmIChhdXRvUm90YXRlKSB7XG4gICAgICBjb25zdCBhdXRvUm90YXRlU3RyYXRlZ3kgPSAoeyBpbmRleCwgdGlja0RhdGEsIGxhYmVsT3ZlcmxhcCwgdGVybWluYXRlIH0pID0+ICh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICB0aWNrRGF0YSxcbiAgICAgICAgYXV0b1JvdGF0aW9uOiB0aGlzLmdldEF1dG9Sb3RhdGlvbihsYWJlbE92ZXJsYXApLFxuICAgICAgICB0ZXJtaW5hdGVcbiAgICAgIH0pO1xuICAgICAgc3RyYXRlZ2llcy5wdXNoKGF1dG9Sb3RhdGVTdHJhdGVneSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJhdGVnaWVzO1xuICB9XG4gIGNyZWF0ZVRpY2tEYXRhKHRpY2tHZW5lcmF0aW9uVHlwZSwgaW5kZXgsIHRpY2tEYXRhLCB0ZXJtaW5hdGUsIHByaW1hcnlUaWNrQ291bnQpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdGVwLCB2YWx1ZXMsIG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSA9IHRoaXMuaW50ZXJ2YWw7XG4gICAgY29uc3QgeyBtYXhUaWNrQ291bnQsIG1pblRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCB9ID0gdGhpcy5lc3RpbWF0ZVRpY2tDb3VudCh7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSk7XG4gICAgY29uc3QgY29udGludW91cyA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gIWNvbnRpbnVvdXMgfHwgaXNOYU4obWF4VGlja0NvdW50KSA/IDEwIDogbWF4VGlja0NvdW50O1xuICAgIGxldCB0aWNrQ291bnQgPSBjb250aW51b3VzID8gTWF0aC5tYXgoZGVmYXVsdFRpY2tDb3VudCAtIGluZGV4LCBtaW5UaWNrQ291bnQpIDogbWF4VGlja0NvdW50O1xuICAgIGNvbnN0IHJlZ2VuZXJhdGVUaWNrcyA9IHN0ZXAgPT09IHZvaWQgMCAmJiB2YWx1ZXMgPT09IHZvaWQgMCAmJiB0aWNrQ291bnQgPiBtaW5UaWNrQ291bnQgJiYgKGNvbnRpbnVvdXMgfHwgdGlja0dlbmVyYXRpb25UeXBlID09PSAyIC8qIEZJTFRFUiAqLyk7XG4gICAgbGV0IHVuY2hhbmdlZCA9IHRydWU7XG4gICAgd2hpbGUgKHVuY2hhbmdlZCAmJiBpbmRleCA8PSBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBwcmV2VGlja3MgPSB0aWNrRGF0YS5yYXdUaWNrcztcbiAgICAgIHRpY2tDb3VudCA9IGNvbnRpbnVvdXMgPyBNYXRoLm1heChkZWZhdWx0VGlja0NvdW50IC0gaW5kZXgsIG1pblRpY2tDb3VudCkgOiBtYXhUaWNrQ291bnQ7XG4gICAgICBjb25zdCB7IHJhd1RpY2tzLCBmcmFjdGlvbkRpZ2l0cywgdGlja3MsIGxhYmVsQ291bnQgfSA9IHRoaXMuZ2V0VGlja3Moe1xuICAgICAgICB0aWNrR2VuZXJhdGlvblR5cGUsXG4gICAgICAgIHByZXZpb3VzVGlja3M6IHByZXZUaWNrcyxcbiAgICAgICAgdGlja0NvdW50LFxuICAgICAgICBtaW5UaWNrQ291bnQsXG4gICAgICAgIG1heFRpY2tDb3VudCxcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudFxuICAgICAgfSk7XG4gICAgICB0aWNrRGF0YS5yYXdUaWNrcyA9IHJhd1RpY2tzO1xuICAgICAgdGlja0RhdGEuZnJhY3Rpb25EaWdpdHMgPSBmcmFjdGlvbkRpZ2l0cztcbiAgICAgIHRpY2tEYXRhLnRpY2tzID0gdGlja3M7XG4gICAgICB0aWNrRGF0YS5sYWJlbENvdW50ID0gbGFiZWxDb3VudDtcbiAgICAgIHVuY2hhbmdlZCA9IHJlZ2VuZXJhdGVUaWNrcyA/IGFyZUFycmF5TnVtYmVyc0VxdWFsKHJhd1RpY2tzLCBwcmV2VGlja3MpIDogZmFsc2U7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRUZXJtaW5hdGUgPSBzdGVwICE9PSB2b2lkIDAgfHwgdmFsdWVzICE9PSB2b2lkIDA7XG4gICAgdGVybWluYXRlIHx8ICh0ZXJtaW5hdGUgPSBzaG91bGRUZXJtaW5hdGUpO1xuICAgIHJldHVybiB7IHRpY2tEYXRhLCBpbmRleCwgYXV0b1JvdGF0aW9uOiAwLCB0ZXJtaW5hdGUgfTtcbiAgfVxuICBjaGVja0xhYmVsT3ZlcmxhcChyb3RhdGlvbiwgcm90YXRlZCwgbGFiZWxNYXRyaXgsIHRpY2tEYXRhLCBsYWJlbFgsIHRleHRNZWFzdXJlcikge1xuICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgobGFiZWxNYXRyaXgsIDEsIDEsIHJvdGF0aW9uLCAwLCAwKTtcbiAgICBjb25zdCBsYWJlbERhdGEgPSB0aGlzLmNyZWF0ZUxhYmVsRGF0YSh0aWNrRGF0YSwgbGFiZWxYLCBsYWJlbE1hdHJpeCwgdGV4dE1lYXN1cmVyKTtcbiAgICBjb25zdCBsYWJlbFNwYWNpbmcgPSBnZXRMYWJlbFNwYWNpbmcodGhpcy5sYWJlbC5taW5TcGFjaW5nLCByb3RhdGVkKTtcbiAgICByZXR1cm4gYXhpc0xhYmVsc092ZXJsYXAobGFiZWxEYXRhLCBsYWJlbFNwYWNpbmcpO1xuICB9XG4gIGNyZWF0ZUxhYmVsRGF0YSh0aWNrRGF0YSwgbGFiZWxYLCBsYWJlbE1hdHJpeCwgdGV4dE1lYXN1cmVyKSB7XG4gICAgY29uc3QgbGFiZWxEYXRhID0gW107XG4gICAgZm9yIChjb25zdCB7IHRpY2tMYWJlbCwgdHJhbnNsYXRpb25ZIH0gb2YgdGlja0RhdGEpIHtcbiAgICAgIGlmICghdGlja0xhYmVsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dE1lYXN1cmVyLm1lYXN1cmVMaW5lcyh0aWNrTGFiZWwpO1xuICAgICAgY29uc3QgYmJveCA9IG5ldyBCQm94KGxhYmVsWCwgdHJhbnNsYXRpb25ZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGxhYmVsRGF0dW0gPSBjYWxjdWxhdGVMYWJlbEJCb3godGlja0xhYmVsLCBiYm94LCBsYWJlbE1hdHJpeCk7XG4gICAgICBsYWJlbERhdGEucHVzaChsYWJlbERhdHVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsRGF0YTtcbiAgfVxuICBnZXRBdXRvUm90YXRpb24obGFiZWxPdmVybGFwKSB7XG4gICAgcmV0dXJuIGxhYmVsT3ZlcmxhcCA/IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyh0aGlzLmxhYmVsLmF1dG9Sb3RhdGVBbmdsZSA/PyAwKSkgOiAwO1xuICB9XG4gIGdldFRpY2tzKHtcbiAgICB0aWNrR2VuZXJhdGlvblR5cGUsXG4gICAgcHJldmlvdXNUaWNrcyxcbiAgICB0aWNrQ291bnQsXG4gICAgbWluVGlja0NvdW50LFxuICAgIG1heFRpY2tDb3VudCxcbiAgICBwcmltYXJ5VGlja0NvdW50XG4gIH0pIHtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMsIHNjYWxlOiBzY2FsZTIsIHZpc2libGVSYW5nZSB9ID0gdGhpcztcbiAgICBsZXQgcmF3VGlja3M7XG4gICAgc3dpdGNoICh0aWNrR2VuZXJhdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgMyAvKiBWQUxVRVMgKi86XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5pbnRlcnZhbC52YWx1ZXM7XG4gICAgICAgIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgICAgICAgIGNvbnN0IFtkMCwgZDFdID0gZmluZE1pbk1heChzY2FsZTIuZ2V0RG9tYWluKCkubWFwKE51bWJlcikpO1xuICAgICAgICAgIHJhd1RpY2tzID0gcmF3VGlja3MuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPj0gZDAgJiYgdmFsdWUgPD0gZDEpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBDUkVBVEVfU0VDT05EQVJZICovOlxuICAgICAgICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICAgICAgICByYXdUaWNrcyA9IHRoaXMudXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKHByaW1hcnlUaWNrQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhd1RpY2tzID0gdGhpcy5jcmVhdGVUaWNrcyh0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMiAvKiBGSUxURVIgKi86XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5maWx0ZXJUaWNrcyhwcmV2aW91c1RpY2tzLCB0aWNrQ291bnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5jcmVhdGVUaWNrcyh0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gcmF3VGlja3MucmVkdWNlKChtYXgsIHRpY2spID0+IE1hdGgubWF4KG1heCwgY291bnRGcmFjdGlvbkRpZ2l0cyh0aWNrKSksIDApO1xuICAgIGNvbnN0IGhhbGZCYW5kd2lkdGggPSAoc2NhbGUyLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxDb3VudCA9IDA7XG4gICAgY29uc3QgdGlja0lkQ291bnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IodmlzaWJsZVJhbmdlWzBdICogcmF3VGlja3MubGVuZ3RoKSk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4ocmF3VGlja3MubGVuZ3RoLCBNYXRoLmNlaWwodmlzaWJsZVJhbmdlWzFdICogcmF3VGlja3MubGVuZ3RoKSk7XG4gICAgY29uc3QgZmlsdGVyZWRUaWNrcyA9IHJhd1RpY2tzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMub25Gb3JtYXRDaGFuZ2UoZmlsdGVyZWRUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHJhd1RpY2tzLCB0aGlzLmxhYmVsLmZvcm1hdCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJlZFRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0aWNrID0gZmlsdGVyZWRUaWNrc1tpXTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IHNjYWxlMi5jb252ZXJ0KHRpY2spICsgaGFsZkJhbmR3aWR0aDtcbiAgICAgIGlmIChyYW5nZTMubGVuZ3RoID4gMCAmJiAhdGhpcy5pblJhbmdlKHRyYW5zbGF0aW9uWSwgMWUtMykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGlja0xhYmVsID0gdGhpcy5mb3JtYXRUaWNrKHRpY2ssIGZyYWN0aW9uRGlnaXRzLCBzdGFydCArIGkpO1xuICAgICAgbGV0IHRpY2tJZCA9IHRpY2tMYWJlbDtcbiAgICAgIGlmICh0aWNrSWRDb3VudHMuaGFzKHRpY2tJZCkpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aWNrSWRDb3VudHMuZ2V0KHRpY2tJZCk7XG4gICAgICAgIHRpY2tJZENvdW50cy5zZXQodGlja0lkLCBjb3VudCArIDEpO1xuICAgICAgICB0aWNrSWQgPSBgJHt0aWNrSWR9XyR7Y291bnR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tJZENvdW50cy5zZXQodGlja0lkLCAxKTtcbiAgICAgIH1cbiAgICAgIHRpY2tzLnB1c2goeyB0aWNrLCB0aWNrSWQsIHRpY2tMYWJlbCwgdHJhbnNsYXRpb25ZOiBNYXRoLmZsb29yKHRyYW5zbGF0aW9uWSkgfSk7XG4gICAgICBpZiAodGlja0xhYmVsID09PSBcIlwiIHx8IHRpY2tMYWJlbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGFiZWxDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4geyByYXdUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHRpY2tzLCBsYWJlbENvdW50IH07XG4gIH1cbiAgZmlsdGVyVGlja3ModGlja3MsIHRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCB0aWNrU3BhY2luZyA9ICFpc05hTihtaW5TcGFjaW5nKSB8fCAhaXNOYU4obWF4U3BhY2luZyk7XG4gICAgY29uc3Qga2VlcEV2ZXJ5ID0gdGlja1NwYWNpbmcgPyBNYXRoLmNlaWwodGlja3MubGVuZ3RoIC8gdGlja0NvdW50KSA6IDI7XG4gICAgcmV0dXJuIHRpY2tzLmZpbHRlcigoXywgaSkgPT4gaSAlIGtlZXBFdmVyeSA9PT0gMCk7XG4gIH1cbiAgY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBpZiAodGlja0NvdW50ICYmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikpKSB7XG4gICAgICBpZiAodHlwZW9mIHRpY2tDb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzY2FsZTIudGlja0NvdW50ID0gdGlja0NvdW50O1xuICAgICAgICBzY2FsZTIubWluVGlja0NvdW50ID0gbWluVGlja0NvdW50ID8/IDA7XG4gICAgICAgIHNjYWxlMi5tYXhUaWNrQ291bnQgPSBtYXhUaWNrQ291bnQgPz8gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKHNjYWxlMiBpbnN0YW5jZW9mIFRpbWVTY2FsZSkge1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbCh0aWNrQ291bnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NhbGUyLnRpY2tzPy4oKSA/PyBbXTtcbiAgfVxuICBlc3RpbWF0ZVRpY2tDb3VudCh7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSkge1xuICAgIGlmICghdGhpcy5sYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblRpY2tDb3VudDogQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQsXG4gICAgICAgIG1heFRpY2tDb3VudDogQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQsXG4gICAgICAgIGRlZmF1bHRUaWNrQ291bnQ6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByYW5nZVdpdGhCbGVlZCA9IHRoaXMuY2FsY3VsYXRlUmFuZ2VXaXRoQmxlZWQoKTtcbiAgICBjb25zdCBkZWZhdWx0TWluU3BhY2luZyA9IE1hdGgubWF4KFxuICAgICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcsXG4gICAgICByYW5nZVdpdGhCbGVlZCAvIENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50XG4gICAgKTtcbiAgICBsZXQgY2xhbXBNYXhUaWNrQ291bnQgPSAhaXNOYU4obWF4U3BhY2luZyk7XG4gICAgaWYgKGlzTmFOKG1pblNwYWNpbmcpKSB7XG4gICAgICBtaW5TcGFjaW5nID0gZGVmYXVsdE1pblNwYWNpbmc7XG4gICAgfVxuICAgIGlmIChpc05hTihtYXhTcGFjaW5nKSkge1xuICAgICAgbWF4U3BhY2luZyA9IHJhbmdlV2l0aEJsZWVkO1xuICAgIH1cbiAgICBpZiAobWluU3BhY2luZyA+IG1heFNwYWNpbmcpIHtcbiAgICAgIGlmIChtaW5TcGFjaW5nID09PSBkZWZhdWx0TWluU3BhY2luZykge1xuICAgICAgICBtaW5TcGFjaW5nID0gbWF4U3BhY2luZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heFNwYWNpbmcgPSBtaW5TcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtaW5SZWN0RGlzdGFuY2UgPSAyO1xuICAgIGNsYW1wTWF4VGlja0NvdW50ICYmIChjbGFtcE1heFRpY2tDb3VudCA9IG1pblJlY3REaXN0YW5jZSA8IGRlZmF1bHRNaW5TcGFjaW5nKTtcbiAgICBjb25zdCBtYXhUaWNrQ291bnQgPSBjbGFtcChcbiAgICAgIDEsXG4gICAgICBNYXRoLmZsb29yKHJhbmdlV2l0aEJsZWVkIC8gbWluU3BhY2luZyksXG4gICAgICBjbGFtcE1heFRpY2tDb3VudCA/IE1hdGgubWluKE1hdGguZmxvb3IocmFuZ2VXaXRoQmxlZWQgLyBtaW5SZWN0RGlzdGFuY2UpLCAxMDApIDogMTAwXG4gICAgKTtcbiAgICBjb25zdCBtaW5UaWNrQ291bnQgPSBNYXRoLm1pbihtYXhUaWNrQ291bnQsIE1hdGguY2VpbChyYW5nZVdpdGhCbGVlZCAvIG1heFNwYWNpbmcpKTtcbiAgICBjb25zdCBkZWZhdWx0VGlja0NvdW50ID0gY2xhbXAobWluVGlja0NvdW50LCBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICByZXR1cm4geyBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCB9O1xuICB9XG4gIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgaWYgKHRoaXMubW9kdWxlQ3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpO1xuICAgIH1cbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAudmlzaWJsZSA9IHRoaXMudGljay5lbmFibGVkO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cC52aXNpYmxlID0gdGhpcy5ncmlkTGluZS5lbmFibGVkO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXAudmlzaWJsZSA9IHRoaXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICB1cGRhdGVDcm9zc0xpbmVzKHtcbiAgICByb3RhdGlvbixcbiAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICByZWd1bGFyRmxpcFJvdGF0aW9uXG4gIH0pIHtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBhbnlTZXJpZXNBY3RpdmUgPSB0aGlzLmlzQW55U2VyaWVzQWN0aXZlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgY3Jvc3NMaW5lLnNpZGVGbGFnID0gLXNpZGVGbGFnO1xuICAgICAgY3Jvc3NMaW5lLmRpcmVjdGlvbiA9IHJvdGF0aW9uID09PSAtTWF0aC5QSSAvIDIgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgICAgIGlmIChjcm9zc0xpbmUgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5Dcm9zc0xpbmUpIHtcbiAgICAgICAgY3Jvc3NMaW5lLmxhYmVsLnBhcmFsbGVsID0gY3Jvc3NMaW5lLmxhYmVsLnBhcmFsbGVsID8/IHRoaXMubGFiZWwucGFyYWxsZWw7XG4gICAgICB9XG4gICAgICBjcm9zc0xpbmUucGFyYWxsZWxGbGlwUm90YXRpb24gPSBwYXJhbGxlbEZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS5yZWd1bGFyRmxpcFJvdGF0aW9uID0gcmVndWxhckZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS51cGRhdGUoYW55U2VyaWVzQWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaWNrTGluZXMoKSB7XG4gICAgY29uc3QgeyB0aWNrLCBsYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uLmVhY2goKGxpbmUpID0+IHtcbiAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB0aWNrLndpZHRoO1xuICAgICAgbGluZS5zdHJva2UgPSB0aWNrLnN0cm9rZTtcbiAgICAgIGxpbmUueDEgPSBzaWRlRmxhZyAqIHRoaXMuZ2V0VGlja1NpemUoKTtcbiAgICAgIGxpbmUueDIgPSAwO1xuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0ZUF2YWlsYWJsZVJhbmdlKCkge1xuICAgIHJldHVybiBmaW5kUmFuZ2VFeHRlbnQodGhpcy5yYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGF2YWlsYWJsZSByYW5nZSB3aXRoIGFuIGFkZGl0aW9uYWwgXCJibGVlZFwiIGJleW9uZCB0aGUgY2FudmFzIHRoYXQgZW5jb21wYXNzZXMgdGhlIGZ1bGwgYXhpcyB3aGVuXG4gICAqIHRoZSB2aXNpYmxlIHJhbmdlIGlzIG9ubHkgYSBwb3J0aW9uIG9mIHRoZSBheGlzLlxuICAgKi9cbiAgY2FsY3VsYXRlUmFuZ2VXaXRoQmxlZWQoKSB7XG4gICAgY29uc3QgdmlzaWJsZVNjYWxlID0gMSAvIGZpbmRSYW5nZUV4dGVudCh0aGlzLnZpc2libGVSYW5nZSk7XG4gICAgcmV0dXJuIHJvdW5kKHRoaXMuY2FsY3VsYXRlQXZhaWxhYmxlUmFuZ2UoKSAqIHZpc2libGVTY2FsZSwgMik7XG4gIH1cbiAgY2FsY3VsYXRlRG9tYWluKCkge1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSB0aGlzLmJvdW5kU2VyaWVzLmZpbHRlcigocykgPT4gdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyB8fCBzLmlzRW5hYmxlZCgpKTtcbiAgICBjb25zdCBkb21haW5zID0gdmlzaWJsZVNlcmllcy5mbGF0TWFwKChzZXJpZXMpID0+IHNlcmllcy5nZXREb21haW4odGhpcy5kaXJlY3Rpb24pKTtcbiAgICB0aGlzLnNldERvbWFpbihkb21haW5zKTtcbiAgfVxuICBnZXRBeGlzVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogdG9SYWRpYW5zKHRoaXMucm90YXRpb24pLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiAwLFxuICAgICAgcm90YXRpb25DZW50ZXJZOiAwLFxuICAgICAgdHJhbnNsYXRpb25YOiBNYXRoLmZsb29yKHRoaXMudHJhbnNsYXRpb24ueCksXG4gICAgICB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IodGhpcy50cmFuc2xhdGlvbi55KVxuICAgIH07XG4gIH1cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBjcm9zc0xpbmVHcm91cCwgYXhpc0dyb3VwLCBncmlkR3JvdXAsIHRyYW5zbGF0aW9uLCBncmlkTGluZUdyb3VwU2VsZWN0aW9uLCBncmlkUGFkZGluZywgZ3JpZExlbmd0aCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzLmNhbGN1bGF0ZVJvdGF0aW9ucygpO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IodHJhbnNsYXRpb24ueCk7XG4gICAgY29uc3QgdHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcih0cmFuc2xhdGlvbi55KTtcbiAgICBjcm9zc0xpbmVHcm91cC5zZXRQcm9wZXJ0aWVzKHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0pO1xuICAgIGdyaWRHcm91cC5zZXRQcm9wZXJ0aWVzKHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0pO1xuICAgIGF4aXNHcm91cC5kYXR1bSA9IHRoaXMuZ2V0QXhpc1RyYW5zZm9ybSgpO1xuICAgIGdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaCgobGluZSkgPT4ge1xuICAgICAgbGluZS54MSA9IGdyaWRQYWRkaW5nO1xuICAgICAgbGluZS54MiA9IC1zaWRlRmxhZyAqIGdyaWRMZW5ndGggKyBncmlkUGFkZGluZztcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MoX3ByaW1hcnlUaWNrQ291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmV4cGVjdGVkIGNhbGwgdG8gdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKCkgLSBjaGVjayBheGVzIGNvbmZpZ3VyYXRpb24uXCIpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGlvbnMobGluZURhdGEsIGRhdGEsIHBhcmFtcykge1xuICAgIHRoaXMubGluZU5vZGUuZGF0dW0gPSBsaW5lRGF0YTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgdGhpcy5ncmlkTGVuZ3RoID8gZGF0YSA6IFtdLFxuICAgICAgKGdyb3VwKSA9PiBncm91cC5hcHBlbmQobmV3IExpbmUoKSksXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZFxuICAgICk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIGRhdGEsXG4gICAgICAoZ3JvdXApID0+IGdyb3VwLmFwcGVuZENoaWxkKG5ldyBMaW5lKCkpLFxuICAgICAgKGRhdHVtKSA9PiBkYXR1bS50aWNrSWRcbiAgICApO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgZGF0YS5tYXAoKGQpID0+IHRoaXMuZ2V0VGlja0xhYmVsUHJvcHMoZCwgcGFyYW1zKSksXG4gICAgICAoZ3JvdXApID0+IGdyb3VwLmFwcGVuZENoaWxkKG5ldyBUZXh0KCkpLFxuICAgICAgKGRhdHVtKSA9PiBkYXR1bS50aWNrSWRcbiAgICApO1xuICB9XG4gIHVwZGF0ZUF4aXNMaW5lKCkge1xuICAgIGNvbnN0IHsgbGluZSB9ID0gdGhpcztcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IGxpbmUuZW5hYmxlZCA/IGxpbmUud2lkdGggOiAwO1xuICAgIHRoaXMubGluZU5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICBzdHJva2U6IGxpbmUuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGhcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVHcmlkTGluZXMoc2lkZUZsYWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBncmlkTGluZTogeyBzdHlsZSwgd2lkdGggfSxcbiAgICAgIGdyaWRQYWRkaW5nLFxuICAgICAgZ3JpZExlbmd0aFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChncmlkTGVuZ3RoID09PSAwIHx8IHN0eWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaCgobGluZSwgXywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlLCBsaW5lRGFzaCB9ID0gc3R5bGVbaW5kZXggJSBzdHlsZS5sZW5ndGhdO1xuICAgICAgbGluZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgeDE6IGdyaWRQYWRkaW5nLFxuICAgICAgICB4MjogLXNpZGVGbGFnICogZ3JpZExlbmd0aCArIGdyaWRQYWRkaW5nLFxuICAgICAgICBmaWxsOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHdpZHRoLFxuICAgICAgICBsaW5lRGFzaFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTGFiZWxzKCkge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFsYWJlbC5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhkYXR1bSwgW1xuICAgICAgICBcImZpbGxcIixcbiAgICAgICAgXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udFNpemVcIixcbiAgICAgICAgXCJmb250U3R5bGVcIixcbiAgICAgICAgXCJmb250V2VpZ2h0XCIsXG4gICAgICAgIFwidGV4dFwiLFxuICAgICAgICBcInRleHRBbGlnblwiLFxuICAgICAgICBcInRleHRCYXNlbGluZVwiXG4gICAgICBdKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaXRsZShwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvdGF0aW9uLCB0aXRsZSwgX3RpdGxlQ2FwdGlvbiwgbGluZU5vZGUsIHRpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwIH0gPSB0aGlzO1xuICAgIGxldCBzcGFjaW5nID0gMDtcbiAgICBpZiAodGl0bGUuZW5hYmxlZCAmJiBwYXJhbXMuYW55VGlja1Zpc2libGUpIHtcbiAgICAgIGNvbnN0IHRpY2tCQm94ID0gR3JvdXAuY29tcHV0ZUJCb3goW3RpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwLCBsaW5lTm9kZV0pO1xuICAgICAgY29uc3QgdGlja1dpZHRoID0gcm90YXRpb24gPT09IDAgPyB0aWNrQkJveC53aWR0aCA6IHRpY2tCQm94LmhlaWdodDtcbiAgICAgIHNwYWNpbmcgKz0gdGlja1dpZHRoICsgKHRoaXMudGlja0xhYmVsR3JvdXAudmlzaWJsZSA/IDAgOiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nKTtcbiAgICB9XG4gICAgdGhpcy5zZXRUaXRsZVByb3BzKF90aXRsZUNhcHRpb24sIHsgc3BhY2luZyB9KTtcbiAgfVxuICAvLyBGb3IgZm9ybWF0dGluZyAobmljZSByb3VuZGVkKSB0aWNrIHZhbHVlcy5cbiAgZm9ybWF0VGljayhkYXR1bSwgZnJhY3Rpb25EaWdpdHMsIGluZGV4KSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldEZvcm1hdHRlcihpbmRleCwgdHJ1ZSkoZGF0dW0sIGZyYWN0aW9uRGlnaXRzKSk7XG4gIH1cbiAgLy8gRm9yIGZvcm1hdHRpbmcgYXJiaXRyYXJ5IHZhbHVlcyBiZXR3ZWVuIHRoZSB0aWNrcy5cbiAgZm9ybWF0RGF0dW0oZGF0dW0pIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0Rm9ybWF0dGVyKCkoZGF0dW0pKTtcbiAgfVxuICBnZXRGb3JtYXR0ZXIoaW5kZXggPSAwLCBpc1RpY2tMYWJlbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxGb3JtYXR0ZXIsXG4gICAgICBkYXR1bUZvcm1hdHRlcixcbiAgICAgIG1vZHVsZUN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAobGFiZWwuZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cykgPT4gY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsLmZvcm1hdHRlciwgeyB2YWx1ZTogZGF0dW0sIGluZGV4LCBmcmFjdGlvbkRpZ2l0cyB9KSA/PyBkYXR1bTtcbiAgICB9IGVsc2UgaWYgKCFpc1RpY2tMYWJlbCAmJiBkYXR1bUZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIChkYXR1bSkgPT4gY2FsbGJhY2tDYWNoZS5jYWxsKGRhdHVtRm9ybWF0dGVyLCBkYXR1bSkgPz8gU3RyaW5nKGRhdHVtKTtcbiAgICB9IGVsc2UgaWYgKGxhYmVsRm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gKGRhdHVtKSA9PiBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWxGb3JtYXR0ZXIsIGRhdHVtKSA/PyBTdHJpbmcoZGF0dW0pO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdHVtKSA9PiBTdHJpbmcoZGF0dW0pO1xuICB9XG4gIGdldEJCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc0dyb3VwLmdldEJCb3goKTtcbiAgfVxuICBnZXRSZWdpb25CQm94UHJvdmlkZXIoKSB7XG4gICAgY29uc3QgeyBheGlzR3JvdXAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNHcm91cC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZVRyYW5zZm9ybWVkUmVnaW9uQkJveCgpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNHcm91cC5jb21wdXRlVHJhbnNmb3JtZWRSZWdpb25CQm94KCk7XG4gICAgICB9LFxuICAgICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiBheGlzR3JvdXAudmlzaWJsZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XG4gICAgY3Jvc3NMaW5lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICBjcm9zc0xpbmUuZ3JpZExlbmd0aCA9IHRoaXMuZ3JpZExlbmd0aDtcbiAgfVxuICBpc0FueVNlcmllc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZFNlcmllcy5zb21lKChzKSA9PiB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zIHx8IHMuaXNFbmFibGVkKCkpO1xuICB9XG4gIGNsaXBUaWNrTGluZXMoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudGlja0xpbmVHcm91cC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UobmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIGNsaXBHcmlkKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmdyaWRHcm91cC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UobmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIGNhbGN1bGF0ZVBhZGRpbmcobWluLCBtYXgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gTWF0aC5hYnModGhpcy5yZXZlcnNlID8gbWF4IDogbWluKSAqIDAuMDE7XG4gICAgcmV0dXJuIFtwYWRkaW5nLCBwYWRkaW5nXTtcbiAgfVxuICBnZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpIHtcbiAgICBjb25zdCBib3VuZFNlcmllcyA9IHRoaXMuYm91bmRTZXJpZXMucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXh0LmdldEtleXModGhpcy5kaXJlY3Rpb24pO1xuICAgICAgY29uc3QgbmFtZXMgPSBuZXh0LmdldE5hbWVzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBhY2MucHVzaCh7IGtleToga2V5c1tpZHhdLCBuYW1lOiBuYW1lc1tpZHhdIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgICBib3VuZFNlcmllcyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy50aXRsZT8udGV4dFxuICAgIH07XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgcmV0dXJuIHsgZG9tYWluOiBbLi4uZF0sIGNsaXBwZWQ6IGZhbHNlIH07XG4gIH1cbiAgZ2V0TGF5b3V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgcmVjdDogdGhpcy5nZXRCQm94KCksXG4gICAgICBncmlkUGFkZGluZzogdGhpcy5ncmlkUGFkZGluZyxcbiAgICAgIHNlcmllc0FyZWFQYWRkaW5nOiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLFxuICAgICAgdGlja1NpemU6IHRoaXMuZ2V0VGlja1NpemUoKSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgICBkb21haW46IHRoaXMuZGF0YURvbWFpbi5kb21haW4sXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgIC4uLnRoaXMubGF5b3V0XG4gICAgfTtcbiAgfVxuICBnZXRNb2R1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwO1xuICB9XG4gIGNyZWF0ZU1vZHVsZUNvbnRleHQoKSB7XG4gICAgdGhpcy5heGlzQ29udGV4dCA/PyAodGhpcy5heGlzQ29udGV4dCA9IHRoaXMuY3JlYXRlQXhpc0NvbnRleHQoKSk7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb2R1bGVDdHgsIHBhcmVudDogdGhpcy5heGlzQ29udGV4dCB9O1xuICB9XG4gIGNyZWF0ZUF4aXNDb250ZXh0KCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgYXhpc0lkOiB0aGlzLmlkLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbixcbiAgICAgIGNvbnRpbnVvdXM6IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKSxcbiAgICAgIGtleXM6ICgpID0+IHRoaXMuYm91bmRTZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRLZXlzKHRoaXMuZGlyZWN0aW9uKSksXG4gICAgICBzZXJpZXNLZXlQcm9wZXJ0aWVzOiAoKSA9PiB0aGlzLmJvdW5kU2VyaWVzLnJlZHVjZSgoa2V5cywgc2VyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlcmllc0tleXMgPSBzZXJpZXMuZ2V0S2V5UHJvcGVydGllcyh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIHNlcmllc0tleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LCBbXSksXG4gICAgICBzY2FsZVZhbHVlRm9ybWF0dGVyOiAoc3BlY2lmaWVyKSA9PiB0aGlzLmdldFNjYWxlVmFsdWVGb3JtYXR0ZXIoc3BlY2lmaWVyKSxcbiAgICAgIHNjYWxlQmFuZHdpZHRoOiAoKSA9PiBzY2FsZTIuYmFuZHdpZHRoID8/IDAsXG4gICAgICBzY2FsZURvbWFpbjogKCkgPT4gc2NhbGUyLmdldERvbWFpbj8uKCksXG4gICAgICBzY2FsZUNvbnZlcnQ6ICh2YWwpID0+IHNjYWxlMi5jb252ZXJ0KHZhbCksXG4gICAgICBzY2FsZUludmVydDogT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpID8gKHZhbCkgPT4gc2NhbGUyLmludmVydE5lYXJlc3Q/Lih2YWwpIDogKHZhbCkgPT4gc2NhbGUyLmludmVydD8uKHZhbCksXG4gICAgICBzY2FsZUludmVydE5lYXJlc3Q6ICh2YWwpID0+IHNjYWxlMi5pbnZlcnROZWFyZXN0Py4odmFsKSxcbiAgICAgIGF0dGFjaExhYmVsOiAobm9kZSkgPT4gdGhpcy5hdHRhY2hMYWJlbChub2RlKSxcbiAgICAgIGluUmFuZ2U6ICh4LCB0b2xlcmFuY2UpID0+IHRoaXMuaW5SYW5nZSh4LCB0b2xlcmFuY2UpXG4gICAgfTtcbiAgfVxuICBnZXRTY2FsZVZhbHVlRm9ybWF0dGVyKGZvcm1hdCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBpZiAoZm9ybWF0ICYmIHNjYWxlMiAmJiBzY2FsZTIudGlja0Zvcm1hdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNjYWxlMi50aWNrRm9ybWF0KHsgc3BlY2lmaWVyOiBmb3JtYXQgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgdGhlIGZvcm1hdCBzdHJpbmcgJHtmb3JtYXR9IGlzIGludmFsaWQsIGlnbm9yaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGb3JtYXR0ZXIoKTtcbiAgfVxuICBhbmltYXRlUmVhZHlVcGRhdGUoZGlmZjIpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMubW9kdWxlQ3R4O1xuICAgIGNvbnN0IHNlbGVjdGlvbkN0eCA9IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCh0aGlzKTtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyhzZWxlY3Rpb25DdHgpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImF4aXMtZ3JvdXBcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuYXhpc0dyb3VwXSwgZm5zLmdyb3VwKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJsaW5lXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmxpbmVOb2RlXSwgZm5zLmxpbmUpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcImxpbmUtcGF0aHNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb25dLFxuICAgICAgZm5zLnRpY2ssXG4gICAgICAoXywgZCkgPT4gZC50aWNrSWQsXG4gICAgICBkaWZmMlxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwidGljay1sYWJlbHNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbl0sXG4gICAgICBmbnMubGFiZWwsXG4gICAgICAoXywgZCkgPT4gZC50aWNrSWQsXG4gICAgICBkaWZmMlxuICAgICk7XG4gIH1cbiAgcmVzZXRTZWxlY3Rpb25Ob2RlcygpIHtcbiAgICBjb25zdCB7IGdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRpY2tMaW5lR3JvdXBTZWxlY3Rpb24sIHRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLCBsaW5lTm9kZSB9ID0gdGhpcztcbiAgICBjb25zdCBzZWxlY3Rpb25DdHggPSBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQodGhpcyk7XG4gICAgcmVzZXRNb3Rpb24oW3RoaXMuYXhpc0dyb3VwXSwgcmVzZXRBeGlzR3JvdXBGbigpKTtcbiAgICByZXNldE1vdGlvbihbZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xpbmVHcm91cFNlbGVjdGlvbl0sIHJlc2V0QXhpc1NlbGVjdGlvbkZuKHNlbGVjdGlvbkN0eCkpO1xuICAgIHJlc2V0TW90aW9uKFt0aWNrTGFiZWxHcm91cFNlbGVjdGlvbl0sIHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm4oKSk7XG4gICAgcmVzZXRNb3Rpb24oW2xpbmVOb2RlXSwgcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuKCkpO1xuICB9XG4gIGNhbGN1bGF0ZVVwZGF0ZURpZmYocHJldmlvdXMsIHRpY2tEYXRhKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHRpY2tNYXAgPSB7fTtcbiAgICBjb25zdCB0aWNrQ291bnQgPSBNYXRoLm1heChwcmV2aW91cy5sZW5ndGgsIHRpY2tEYXRhLnRpY2tzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGlja0RhdHVtID0gdGlja0RhdGEudGlja3NbaV07XG4gICAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNbaV07XG4gICAgICBjb25zdCB0aWNrID0gdGlja0RhdHVtPy50aWNrSWQ7XG4gICAgICB0aWNrTWFwW3RpY2sgPz8gcHJldl0gPSB0aWNrRGF0dW07XG4gICAgICBpZiAocHJldiA9PT0gdGljaykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVkLmhhcyh0aWNrKSkge1xuICAgICAgICByZW1vdmVkLmRlbGV0ZSh0aWNrKTtcbiAgICAgIH0gZWxzZSBpZiAodGljaykge1xuICAgICAgICBhZGRlZC5hZGQodGljayk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkZWQuaGFzKHByZXYpKSB7XG4gICAgICAgIGFkZGVkLmRlbGV0ZShwcmV2KTtcbiAgICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgICByZW1vdmVkLmFkZChwcmV2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlZDogYWRkZWQuc2l6ZSA+IDAgfHwgcmVtb3ZlZC5zaXplID4gMCwgYWRkZWQsIHJlbW92ZWQgfTtcbiAgfVxuICBpc1JldmVyc2VkKCkge1xuICAgIHJldHVybiB0aGlzLnJldmVyc2U7XG4gIH1cbn07XG5fQXhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSA1MDtcbl9BeGlzLkNyb3NzTGluZUNvbnN0cnVjdG9yID0gQ2FydGVzaWFuQ3Jvc3NMaW5lO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJuaWNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HX0FSUkFZKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcImtleXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwiaW50ZXJ2YWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQsIHZhbHVlLCBvbGRWYWx1ZSkgPT4gdGFyZ2V0Lm9uR3JpZExlbmd0aENoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcImdyaWRMZW5ndGhcIiwgMik7XG52YXIgQXhpcyA9IF9BeGlzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhcnRlc2lhbkF4aXNMYWJlbC50c1xudmFyIENhcnRlc2lhbkF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQXhpc0xhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmF1dG9Sb3RhdGVBbmdsZSA9IDMzNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZUFuZ2xlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhcnRlc2lhbkF4aXMudHNcbnZhciBfQ2FydGVzaWFuQXhpcyA9IGNsYXNzIF9DYXJ0ZXNpYW5BeGlzIGV4dGVuZHMgQXhpcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50aGlja25lc3MgPSAwO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9DYXJ0ZXNpYW5BeGlzO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcInRvcFwiLCBcImJvdHRvbVwiXS5pbmNsdWRlcyh0aGlzLnBvc2l0aW9uKSA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICB9XG4gIHVwZGF0ZURpcmVjdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IC05MDtcbiAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpc0NvbnRleHQpIHtcbiAgICAgIHRoaXMuYXhpc0NvbnRleHQucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5heGlzQ29udGV4dC5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHByaW1hcnlUaWNrQ291bnQsIGFuaW1hdGVkKSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlKHByaW1hcnlUaWNrQ291bnQsIGFuaW1hdGVkKTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCkge1xuICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHN1cGVyLmNhbGN1bGF0ZUxheW91dChwcmltYXJ5VGlja0NvdW50KTtcbiAgfVxuICBjcmVhdGVBeGlzQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuY3JlYXRlQXhpc0NvbnRleHQoKSxcbiAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgfTtcbiAgfVxuICBjcmVhdGVMYWJlbCgpIHtcbiAgICByZXR1cm4gbmV3IENhcnRlc2lhbkF4aXNMYWJlbCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgX0NhcnRlc2lhbkF4aXMucHJvdG90eXBlLCBcInRoaWNrbmVzc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSU9OKVxuXSwgX0NhcnRlc2lhbkF4aXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xudmFyIENhcnRlc2lhbkF4aXMgPSBfQ2FydGVzaWFuQXhpcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXRlZ29yeUF4aXMudHNcbnZhciBDYXRlZ29yeUF4aXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMiA9IG5ldyBCYW5kU2NhbGUoKSkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgc2NhbGUyKTtcbiAgICB0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5ncm91cFBhZGRpbmdJbm5lciA9IDAuMTtcbiAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcbiAgfVxuICBzZXQgcGFkZGluZ0lubmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fcGFkZGluZ092ZXJyaWRlRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zY2FsZS5wYWRkaW5nSW5uZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcGFkZGluZ0lubmVyKCkge1xuICAgIHRoaXMuX3BhZGRpbmdPdmVycmlkZUVuYWJsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgfVxuICBzZXQgcGFkZGluZ091dGVyKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZS5wYWRkaW5nT3V0ZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcGFkZGluZ091dGVyKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnBhZGRpbmdPdXRlcjtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBjb25zdCBkb21haW4gPSBbXTtcbiAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdiBvZiBkKSB7XG4gICAgICBjb25zdCBrZXkgPSB2IGluc3RhbmNlb2YgRGF0ZSA/IHYuZ2V0VGltZSgpIDogdjtcbiAgICAgIGlmICghdW5pcXVlVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgIHVuaXF1ZVZhbHVlcy5hZGQoa2V5KTtcbiAgICAgICAgZG9tYWluLnB1c2godik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRvbWFpbiwgY2xpcHBlZDogZmFsc2UgfTtcbiAgfVxuICBjYWxjdWxhdGVEb21haW4oKSB7XG4gICAgaWYgKCF0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkKSB7XG4gICAgICBsZXQgcGFkZGluZ0lubmVyID0gSW5maW5pdHk7XG4gICAgICBsZXQgcGFkZGluZ091dGVyID0gLUluZmluaXR5O1xuICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuYm91bmRTZXJpZXMpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHMuZ2V0QmFuZFNjYWxlUGFkZGluZz8uKCk7XG4gICAgICAgIGlmIChwYWRkaW5nID09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHBhZGRpbmdJbm5lciA9IE1hdGgubWluKHBhZGRpbmdJbm5lciwgcGFkZGluZy5pbm5lcik7XG4gICAgICAgIHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KHBhZGRpbmdPdXRlciwgcGFkZGluZy5vdXRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLnNjYWxlLnBhZGRpbmdJbm5lciA9IE51bWJlci5pc0Zpbml0ZShwYWRkaW5nSW5uZXIpID8gcGFkZGluZ0lubmVyIDogMDtcbiAgICAgIHRoaXMuc2NhbGUucGFkZGluZ091dGVyID0gTnVtYmVyLmlzRmluaXRlKHBhZGRpbmdPdXRlcikgPyBwYWRkaW5nT3V0ZXIgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2FsY3VsYXRlRG9tYWluKCk7XG4gIH1cbn07XG5DYXRlZ29yeUF4aXMuY2xhc3NOYW1lID0gXCJDYXRlZ29yeUF4aXNcIjtcbkNhdGVnb3J5QXhpcy50eXBlID0gXCJjYXRlZ29yeVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBDYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImdyb3VwUGFkZGluZ0lubmVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL3RyZWUudHNcbnZhciBUcmVlTm9kZSA9IGNsYXNzIHtcbiAgLy8gY3VycmVudCBudW1iZXIgaW4gc2libGluZyBncm91cCAoaW5kZXgpXG4gIGNvbnN0cnVjdG9yKGxhYmVsID0gXCJcIiwgcGFyZW50LCBudW1iZXIyID0gMCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnN1YnRyZWVMZWZ0ID0gTmFOO1xuICAgIHRoaXMuc3VidHJlZVJpZ2h0ID0gTmFOO1xuICAgIHRoaXMuc2NyZWVuWCA9IDA7XG4gICAgdGhpcy5zY3JlZW5ZID0gMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5sZWFmQ291bnQgPSAwO1xuICAgIHRoaXMucHJlbGltID0gMDtcbiAgICB0aGlzLm1vZCA9IDA7XG4gICAgdGhpcy5hbmNlc3RvciA9IHRoaXM7XG4gICAgdGhpcy5jaGFuZ2UgPSAwO1xuICAgIHRoaXMuc2hpZnQgPSAwO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgdGhpcy5udW1iZXIgPSBudW1iZXIyO1xuICB9XG4gIGdldExlZnRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm51bWJlciA+IDAgJiYgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlblt0aGlzLm51bWJlciAtIDFdIDogdm9pZCAwO1xuICB9XG4gIGdldExlZnRtb3N0U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5udW1iZXIgPiAwICYmIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY2hpbGRyZW5bMF0gOiB2b2lkIDA7XG4gIH1cbiAgLy8gdHJhdmVyc2UgdGhlIGxlZnQgY29udG91ciBvZiBhIHN1YnRyZWUsIHJldHVybiB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyXG4gIG5leHRMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlblswXSA6IHRoaXMudGhyZWFkO1xuICB9XG4gIC8vIHRyYXZlcnNlIHRoZSByaWdodCBjb250b3VyIG9mIGEgc3VidHJlZSwgcmV0dXJuIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXJcbiAgbmV4dFJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdIDogdGhpcy50aHJlYWQ7XG4gIH1cbiAgZ2V0U2libGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY2hpbGRyZW4uZmlsdGVyKChfLCBpKSA9PiBpICE9PSB0aGlzLm51bWJlcikgOiBbXTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRpY2tzVG9UcmVlKHRpY2tzLCBwYWQyID0gdHJ1ZSkge1xuICBjb25zdCByb290ID0gbmV3IFRyZWVOb2RlKCk7XG4gIGxldCBkZXB0aCA9IDA7XG4gIGlmIChwYWQyKSB7XG4gICAgdGlja3MuZm9yRWFjaCgodGljaykgPT4gZGVwdGggPSBNYXRoLm1heChkZXB0aCwgdGljay5sYWJlbHMubGVuZ3RoKSk7XG4gIH1cbiAgdGlja3MuZm9yRWFjaCgodGljaykgPT4ge1xuICAgIGlmIChwYWQyKSB7XG4gICAgICB3aGlsZSAodGljay5sYWJlbHMubGVuZ3RoIDwgZGVwdGgpIHtcbiAgICAgICAgdGljay5sYWJlbHMudW5zaGlmdChcIlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0VGljayhyb290LCB0aWNrKTtcbiAgfSk7XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gaW5zZXJ0VGljayhyb290LCB0aWNrKSB7XG4gIGNvbnN0IHBhdGhQYXJ0cyA9IHRpY2subGFiZWxzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBjb25zdCBsYXN0UGFydEluZGV4ID0gcGF0aFBhcnRzLmxlbmd0aCAtIDE7XG4gIHBhdGhQYXJ0cy5mb3JFYWNoKChwYXRoUGFydCwgcGFydEluZGV4KSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290LmNoaWxkcmVuO1xuICAgIGNvbnN0IGV4aXN0aW5nTm9kZSA9IGNoaWxkcmVuLmZpbmQoKGNoaWxkKSA9PiBjaGlsZC5sYWJlbCA9PT0gcGF0aFBhcnQpO1xuICAgIGNvbnN0IGlzTm90TGVhZiA9IHBhcnRJbmRleCAhPT0gbGFzdFBhcnRJbmRleDtcbiAgICBpZiAoZXhpc3RpbmdOb2RlICYmIGlzTm90TGVhZikge1xuICAgICAgcm9vdCA9IGV4aXN0aW5nTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcmVlTm9kZShwYXRoUGFydCwgcm9vdCk7XG4gICAgICBub2RlLm51bWJlciA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICBpZiAoaXNOb3RMZWFmKSB7XG4gICAgICAgIHJvb3QgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XG4gIGNvbnN0IHN1YnRyZWVzID0gd3AubnVtYmVyIC0gd20ubnVtYmVyO1xuICBjb25zdCByYXRpbzIgPSBzaGlmdCAvIHN1YnRyZWVzO1xuICB3cC5jaGFuZ2UgLT0gcmF0aW8yO1xuICB3cC5zaGlmdCArPSBzaGlmdDtcbiAgd20uY2hhbmdlICs9IHJhdGlvMjtcbiAgd3AucHJlbGltICs9IHNoaWZ0O1xuICB3cC5tb2QgKz0gc2hpZnQ7XG59XG5mdW5jdGlvbiBhbmNlc3Rvcih2aW0sIHYsIGRlZmF1bHRBbmNlc3Rvcikge1xuICByZXR1cm4gdi5nZXRTaWJsaW5ncygpLmluZGV4T2YodmltLmFuY2VzdG9yKSA+PSAwID8gdmltLmFuY2VzdG9yIDogZGVmYXVsdEFuY2VzdG9yO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVNoaWZ0cyh2KSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgbGV0IHNoaWZ0ID0gMDtcbiAgICBsZXQgY2hhbmdlID0gMDtcbiAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHcgPSBjaGlsZHJlbltpXTtcbiAgICAgIHcucHJlbGltICs9IHNoaWZ0O1xuICAgICAgdy5tb2QgKz0gc2hpZnQ7XG4gICAgICBjaGFuZ2UgKz0gdy5jaGFuZ2U7XG4gICAgICBzaGlmdCArPSB3LnNoaWZ0ICsgY2hhbmdlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwb3J0aW9uKHYsIGRlZmF1bHRBbmNlc3RvciwgZGlzdGFuY2UzKSB7XG4gIGNvbnN0IHcgPSB2LmdldExlZnRTaWJsaW5nKCk7XG4gIGlmICh3KSB7XG4gICAgbGV0IHZvcCA9IHY7XG4gICAgbGV0IHZpcCA9IHY7XG4gICAgbGV0IHZpbSA9IHc7XG4gICAgbGV0IHZvbSA9IHZpcC5nZXRMZWZ0bW9zdFNpYmxpbmcoKTtcbiAgICBsZXQgc2lwID0gdmlwLm1vZDtcbiAgICBsZXQgc29wID0gdm9wLm1vZDtcbiAgICBsZXQgc2ltID0gdmltLm1vZDtcbiAgICBsZXQgc29tID0gdm9tLm1vZDtcbiAgICB3aGlsZSAodmltLm5leHRSaWdodCgpICYmIHZpcC5uZXh0TGVmdCgpKSB7XG4gICAgICB2aW0gPSB2aW0ubmV4dFJpZ2h0KCk7XG4gICAgICB2aXAgPSB2aXAubmV4dExlZnQoKTtcbiAgICAgIHZvbSA9IHZvbS5uZXh0TGVmdCgpO1xuICAgICAgdm9wID0gdm9wLm5leHRSaWdodCgpO1xuICAgICAgdm9wLmFuY2VzdG9yID0gdjtcbiAgICAgIGNvbnN0IHNoaWZ0ID0gdmltLnByZWxpbSArIHNpbSAtICh2aXAucHJlbGltICsgc2lwKSArIGRpc3RhbmNlMztcbiAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgbW92ZVN1YnRyZWUoYW5jZXN0b3IodmltLCB2LCBkZWZhdWx0QW5jZXN0b3IpLCB2LCBzaGlmdCk7XG4gICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgfVxuICAgICAgc2ltICs9IHZpbS5tb2Q7XG4gICAgICBzaXAgKz0gdmlwLm1vZDtcbiAgICAgIHNvbSArPSB2b20ubW9kO1xuICAgICAgc29wICs9IHZvcC5tb2Q7XG4gICAgfVxuICAgIGlmICh2aW0ubmV4dFJpZ2h0KCkgJiYgIXZvcC5uZXh0UmlnaHQoKSkge1xuICAgICAgdm9wLnRocmVhZCA9IHZpbS5uZXh0UmlnaHQoKTtcbiAgICAgIHZvcC5tb2QgKz0gc2ltIC0gc29wO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmlwLm5leHRMZWZ0KCkgJiYgIXZvbS5uZXh0TGVmdCgpKSB7XG4gICAgICAgIHZvbS50aHJlYWQgPSB2aXAubmV4dExlZnQoKTtcbiAgICAgICAgdm9tLm1vZCArPSBzaXAgLSBzb207XG4gICAgICB9XG4gICAgICBkZWZhdWx0QW5jZXN0b3IgPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdEFuY2VzdG9yO1xufVxuZnVuY3Rpb24gZmlyc3RXYWxrKG5vZGUsIGRpc3RhbmNlMykge1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBsZXQgZGVmYXVsdEFuY2VzdG9yID0gY2hpbGRyZW5bMF07XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGZpcnN0V2FsayhjaGlsZCwgZGlzdGFuY2UzKTtcbiAgICAgIGRlZmF1bHRBbmNlc3RvciA9IGFwcG9ydGlvbihjaGlsZCwgZGVmYXVsdEFuY2VzdG9yLCBkaXN0YW5jZTMpO1xuICAgIH0pO1xuICAgIGV4ZWN1dGVTaGlmdHMobm9kZSk7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ucHJlbGltICsgY2hpbGRyZW4uYXQoLTEpLnByZWxpbSkgLyAyO1xuICAgIGNvbnN0IGxlZnRTaWJsaW5nID0gbm9kZS5nZXRMZWZ0U2libGluZygpO1xuICAgIGlmIChsZWZ0U2libGluZykge1xuICAgICAgbm9kZS5wcmVsaW0gPSBsZWZ0U2libGluZy5wcmVsaW0gKyBkaXN0YW5jZTM7XG4gICAgICBub2RlLm1vZCA9IG5vZGUucHJlbGltIC0gbWlkcG9pbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJlbGltID0gbWlkcG9pbnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlZnRTaWJsaW5nID0gbm9kZS5nZXRMZWZ0U2libGluZygpO1xuICAgIG5vZGUucHJlbGltID0gbGVmdFNpYmxpbmcgPyBsZWZ0U2libGluZy5wcmVsaW0gKyBkaXN0YW5jZTMgOiAwO1xuICB9XG59XG52YXIgRGltZW5zaW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50b3AgPSBJbmZpbml0eTtcbiAgICB0aGlzLnJpZ2h0ID0gLUluZmluaXR5O1xuICAgIHRoaXMuYm90dG9tID0gLUluZmluaXR5O1xuICAgIHRoaXMubGVmdCA9IEluZmluaXR5O1xuICB9XG4gIHVwZGF0ZShub2RlLCB4eSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0geHkobm9kZSk7XG4gICAgaWYgKHggPiB0aGlzLnJpZ2h0KSB7XG4gICAgICB0aGlzLnJpZ2h0ID0geDtcbiAgICB9XG4gICAgaWYgKHggPCB0aGlzLmxlZnQpIHtcbiAgICAgIHRoaXMubGVmdCA9IHg7XG4gICAgfVxuICAgIGlmICh5ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgIHRoaXMuYm90dG9tID0geTtcbiAgICB9XG4gICAgaWYgKHkgPCB0aGlzLnRvcCkge1xuICAgICAgdGhpcy50b3AgPSB5O1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlY29uZFdhbGsodiwgbSwgbGF5b3V0KSB7XG4gIHYueCA9IHYucHJlbGltICsgbTtcbiAgdi55ID0gdi5kZXB0aDtcbiAgbGF5b3V0LnVwZGF0ZSh2KTtcbiAgdi5jaGlsZHJlbi5mb3JFYWNoKCh3KSA9PiBzZWNvbmRXYWxrKHcsIG0gKyB2Lm1vZCwgbGF5b3V0KSk7XG59XG5mdW5jdGlvbiB0aGlyZFdhbGsodikge1xuICBjb25zdCBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIGxldCBsZWFmQ291bnQgPSAwO1xuICBjaGlsZHJlbi5mb3JFYWNoKCh3KSA9PiB7XG4gICAgdGhpcmRXYWxrKHcpO1xuICAgIGlmICh3LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgbGVhZkNvdW50ICs9IHcubGVhZkNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWFmQ291bnQrKztcbiAgICB9XG4gIH0pO1xuICB2LmxlYWZDb3VudCA9IGxlYWZDb3VudDtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHYuc3VidHJlZUxlZnQgPSBjaGlsZHJlblswXS5zdWJ0cmVlTGVmdDtcbiAgICB2LnN1YnRyZWVSaWdodCA9IGNoaWxkcmVuW3YuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3VidHJlZVJpZ2h0O1xuICAgIHYueCA9ICh2LnN1YnRyZWVMZWZ0ICsgdi5zdWJ0cmVlUmlnaHQpIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB2LnN1YnRyZWVMZWZ0ID0gdi54O1xuICAgIHYuc3VidHJlZVJpZ2h0ID0gdi54O1xuICB9XG59XG5mdW5jdGlvbiB0cmVlTGF5b3V0KHJvb3QpIHtcbiAgY29uc3QgbGF5b3V0ID0gbmV3IFRyZWVMYXlvdXQoKTtcbiAgZmlyc3RXYWxrKHJvb3QsIDEpO1xuICBzZWNvbmRXYWxrKHJvb3QsIC1yb290LnByZWxpbSwgbGF5b3V0KTtcbiAgdGhpcmRXYWxrKHJvb3QpO1xuICByZXR1cm4gbGF5b3V0O1xufVxudmFyIFRyZWVMYXlvdXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5sZWFmQ291bnQgPSAwO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAvLyBPbmUgbWlnaHQgd2FudCB0byBwcm9jZXNzIGxlYWYgbm9kZXMgc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuICAgIC8vIEZvciBleGFtcGxlLCBwb3NpdGlvbiBsYWJlbHMgY29ycmVzcG9uZGluZyB0byBsZWFmcyB2ZXJ0aWNhbGx5LCByYXRoZXIgdGhhbiBob3Jpem9udGFsbHkuXG4gICAgdGhpcy5sZWFmTm9kZXMgPSBbXTtcbiAgICB0aGlzLm5vbkxlYWZOb2RlcyA9IFtdO1xuICAgIHRoaXMuZGVwdGggPSAwO1xuICB9XG4gIHVwZGF0ZShub2RlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zLnVwZGF0ZShub2RlLCAobikgPT4gKHsgeDogbi54LCB5OiBuLnkgfSkpO1xuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhpcy5ub25MZWFmTm9kZXMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWFmQ291bnQrKztcbiAgICAgIHRoaXMubGVhZk5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlLmRlcHRoID4gdGhpcy5kZXB0aCkge1xuICAgICAgdGhpcy5kZXB0aCA9IG5vZGUuZGVwdGg7XG4gICAgfVxuICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCwgc2hpZnRYID0gMCwgc2hpZnRZID0gMCwgZmxpcFggPSBmYWxzZSkge1xuICAgIGNvbnN0IHhTdGVwcyA9IHRoaXMubGVhZkNvdW50IC0gMTtcbiAgICBjb25zdCB5U3RlcHMgPSB0aGlzLmRlcHRoO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgbGV0IHNjYWxpbmdYID0gMTtcbiAgICBsZXQgc2NhbGluZ1kgPSAxO1xuICAgIGlmICh3aWR0aCA+IDAgJiYgeFN0ZXBzKSB7XG4gICAgICBjb25zdCBleGlzdGluZ1NwYWNpbmdYID0gKGRpbWVuc2lvbnMucmlnaHQgLSBkaW1lbnNpb25zLmxlZnQpIC8geFN0ZXBzO1xuICAgICAgY29uc3QgZGVzaXJlZFNwYWNpbmdYID0gd2lkdGggLyB4U3RlcHM7XG4gICAgICBzY2FsaW5nWCA9IGRlc2lyZWRTcGFjaW5nWCAvIGV4aXN0aW5nU3BhY2luZ1g7XG4gICAgICBpZiAoZmxpcFgpIHtcbiAgICAgICAgc2NhbGluZ1ggPSAtc2NhbGluZ1g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPiAwICYmIHlTdGVwcykge1xuICAgICAgY29uc3QgZXhpc3RpbmdTcGFjaW5nWSA9IChkaW1lbnNpb25zLmJvdHRvbSAtIGRpbWVuc2lvbnMudG9wKSAvIHlTdGVwcztcbiAgICAgIGNvbnN0IGRlc2lyZWRTcGFjaW5nWSA9IGhlaWdodCAvIHlTdGVwcztcbiAgICAgIHNjYWxpbmdZID0gZGVzaXJlZFNwYWNpbmdZIC8gZXhpc3RpbmdTcGFjaW5nWTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuRGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLnNjcmVlblggPSBub2RlLnggKiBzY2FsaW5nWDtcbiAgICAgIG5vZGUuc2NyZWVuWSA9IG5vZGUueSAqIHNjYWxpbmdZO1xuICAgICAgc2NyZWVuRGltZW5zaW9ucy51cGRhdGUobm9kZSwgKG4pID0+ICh7IHg6IG4uc2NyZWVuWCwgeTogbi5zY3JlZW5ZIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBvZmZzZXRYID0gLXNjcmVlbkRpbWVuc2lvbnMubGVmdDtcbiAgICBjb25zdCBvZmZzZXRZID0gLXNjcmVlbkRpbWVuc2lvbnMudG9wO1xuICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5zY3JlZW5YICs9IG9mZnNldFggKyBzaGlmdFg7XG4gICAgICBub2RlLnNjcmVlblkgKz0gb2Zmc2V0WSArIHNoaWZ0WTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9ncm91cGVkQ2F0ZWdvcnlBeGlzLnRzXG52YXIgR3JvdXBlZENhdGVnb3J5QXhpc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBBeGlzTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZ3JpZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEdyb3VwZWRDYXRlZ29yeUF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZ3JpZFwiLCAyKTtcbnZhciBHcm91cGVkQ2F0ZWdvcnlBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgY29uc3Qgc2NhbGUyID0gbmV3IEJhbmRTY2FsZSgpO1xuICAgIHNjYWxlMi5wYWRkaW5nT3V0ZXIgPSAwLjE7XG4gICAgc2NhbGUyLnBhZGRpbmdJbm5lciA9IHNjYWxlMi5wYWRkaW5nT3V0ZXIgKiAyO1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgc2NhbGUyKTtcbiAgICAvLyBMYWJlbCBzY2FsZSAobGFiZWxzIGFyZSBwb3NpdGlvbmVkIGJldHdlZW4gdGlja3MsIHRpY2sgY291bnQgPSBsYWJlbCBjb3VudCArIDEpLlxuICAgIC8vIFdlIGRvbid0IGNhbGwgaXMgYGxhYmVsU2NhbGVgIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGF4ZXMuXG4gICAgdGhpcy50aWNrU2NhbGUgPSBuZXcgQmFuZFNjYWxlKCk7XG4gICAgdGhpcy5saW5lID0gbmV3IEF4aXNMaW5lKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBHcm91cGVkQ2F0ZWdvcnlBeGlzTGFiZWwoKTtcbiAgICB0aGlzLmxhYmVsQ29sb3IgPSBcInJnYmEoODcsIDg3LCA4NywgMSlcIjtcbiAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcbiAgICBjb25zdCB7IHRpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwLCBncmlkTGluZUdyb3VwLCB0aWNrU2NhbGUgfSA9IHRoaXM7XG4gICAgdGlja1NjYWxlLnBhZGRpbmdJbm5lciA9IDE7XG4gICAgdGlja1NjYWxlLnBhZGRpbmdPdXRlciA9IDA7XG4gICAgdGhpcy5ncmlkTGluZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoZ3JpZExpbmVHcm91cCwgTGluZSk7XG4gICAgdGhpcy5heGlzTGluZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGlja0xpbmVHcm91cCwgTGluZSk7XG4gICAgdGhpcy5zZXBhcmF0b3JTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRpY2tMaW5lR3JvdXAsIExpbmUpO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRpY2tMYWJlbEdyb3VwLCBUZXh0KTtcbiAgICB0aGlzLmxpbmVOb2RlLnZpc2libGUgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGVSYW5nZSgpIHtcbiAgICBjb25zdCB7IHJhbmdlOiByciwgdmlzaWJsZVJhbmdlOiB2ciwgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBzcGFuID0gKHJyWzFdIC0gcnJbMF0pIC8gKHZyWzFdIC0gdnJbMF0pO1xuICAgIGNvbnN0IHNoaWZ0ID0gc3BhbiAqIHZyWzBdO1xuICAgIGNvbnN0IHN0YXJ0ID0gcnJbMF0gLSBzaGlmdDtcbiAgICB0aGlzLnRpY2tTY2FsZS5yYW5nZSA9IHNjYWxlMi5yYW5nZSA9IFtzdGFydCwgc3RhcnQgKyBzcGFuXTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tUcmVlKCk7XG4gIH1cbiAgcmVzaXplVGlja1RyZWUoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2NhbGU7XG4gICAgY29uc3QgcmFuZ2UzID0gcy5kb21haW4ubGVuZ3RoID8gW3MuY29udmVydChzLmRvbWFpblswXSksIHMuY29udmVydChzLmRvbWFpbltzLmRvbWFpbi5sZW5ndGggLSAxXSldIDogcy5yYW5nZTtcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLnRpY2tUcmVlTGF5b3V0O1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgbGF5b3V0LnJlc2l6ZShcbiAgICAgICAgTWF0aC5hYnMocmFuZ2UzWzFdIC0gcmFuZ2UzWzBdKSxcbiAgICAgICAgbGF5b3V0LmRlcHRoICogbGluZUhlaWdodCxcbiAgICAgICAgKE1hdGgubWluKHJhbmdlM1swXSwgcmFuZ2UzWzFdKSB8fCAwKSArIChzLmJhbmR3aWR0aCA/PyAwKSAvIDIsXG4gICAgICAgIC1sYXlvdXQuZGVwdGggKiBsaW5lSGVpZ2h0LFxuICAgICAgICByYW5nZTNbMV0gLSByYW5nZTNbMF0gPCAwXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbC5mb250U2l6ZSAqIDEuNTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgZ3JpZC4gVGhlIGdyaWQgaXMgb25seSB2aXNpYmxlIGluIGNhc2Ugb2YgYSBub24temVybyB2YWx1ZS5cbiAgICovXG4gIG9uR3JpZFZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5ncmlkTGluZVNlbGVjdGlvbi5jbGVhcigpO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuICBjYWxjdWxhdGVEb21haW4oKSB7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHRoaXM7XG4gICAgbGV0IGlzTnVtZXJpY1ggPSBudWxsO1xuICAgIGNvbnN0IGZsYXREb21haW5zID0gdGhpcy5ib3VuZFNlcmllcy5maWx0ZXIoKHMpID0+IHMudmlzaWJsZSkuZmxhdE1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovIHx8IGlzTnVtZXJpY1gpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllcy5nZXREb21haW4oZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWVyaWNYID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbjIgPSBzZXJpZXMuZ2V0RG9tYWluKGRpcmVjdGlvbik7XG4gICAgICAgIGlzTnVtZXJpY1ggPSBpc051bWJlcihkb21haW4yWzBdKTtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjI7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG4gICAgdGhpcy5zZXREb21haW4oZXh0ZW50KGZsYXREb21haW5zKSA/PyB1bmlxdWUoZmxhdERvbWFpbnMpKTtcbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gdGhpcy5kYXRhRG9tYWluO1xuICAgIHRoaXMudGlja1RyZWVMYXlvdXQgPSB0cmVlTGF5b3V0KHRpY2tzVG9UcmVlKGRvbWFpbikpO1xuICAgIHRoaXMudGlja1NjYWxlLmRvbWFpbiA9IGRvbWFpbi5jb25jYXQoXCJcIik7XG4gICAgdGhpcy5yZXNpemVUaWNrVHJlZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzL3JlbW92ZXMvdXBkYXRlcyB0aGUgc2NlbmUgZ3JhcGggbm9kZXMgdGhhdCBjb25zdGl0dXRlIHRoZSBheGlzLlxuICAgKiBTdXBwb3NlZCB0byBiZSBjYWxsZWQgX21hbnVhbGx5XyBhZnRlciBjaGFuZ2luZyBfYW55XyBvZiB0aGUgYXhpcyBwcm9wZXJ0aWVzLlxuICAgKiBUaGlzIGFsbG93cyB0byBidWxrIHNldCBheGlzIHByb3BlcnRpZXMgYmVmb3JlIHVwZGF0aW5nIHRoZSBub2Rlcy5cbiAgICogVGhlIG5vZGUgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgbWV0aG9kIGFyZSByZW5kZXJlZCBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAqIFdlIGNvdWxkIHNjaGVkdWxlIHRoaXMgbWV0aG9kIGNhbGwgYXV0b21hdGljYWxseSBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICogd2hlbiBhbnkgb2YgdGhlIGF4aXMgcHJvcGVydGllcyBjaGFuZ2UgKHRoZSB3YXkgd2UgZG8gd2hlbiBwcm9wZXJ0aWVzIG9mIHNjZW5lIGdyYXBoJ3NcbiAgICogbm9kZXMgY2hhbmdlKSwgYnV0IHRoaXMgd2lsbCBtZWFuIHRoYXQgd2UgZmlyc3Qgd2FpdCBmb3IgdGhlIG5leHQgYW5pbWF0aW9uXG4gICAqIGZyYW1lIHRvIG1ha2UgY2hhbmdlcyB0byB0aGUgbm9kZXMgb2YgdGhlIGF4aXMsIHRoZW4gd2FpdCBmb3IgYW5vdGhlciBhbmltYXRpb25cbiAgICogZnJhbWUgdG8gcmVuZGVyIHRob3NlIGNoYW5nZXMuIEl0J3MgbmljZSB0byBoYXZlIGV2ZXJ5dGhpbmcgdXBkYXRlIGF1dG9tYXRpY2FsbHksXG4gICAqIGJ1dCB0aGlzIGV4dHJhIGxldmVsIG9mIGFzeW5jIGluZGlyZWN0aW9uIHdpbGwgbm90IGp1c3QgaW50cm9kdWNlIGFuIHVud2FudGVkIGRlbGF5LFxuICAgKiBpdCB3aWxsIGFsc28gbWFrZSBpdCBoYXJkZXIgdG8gcmVhc29uIGFib3V0IHRoZSBwcm9ncmFtLlxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZUNhcHRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5TGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVTZXBhcmF0b3JzKCk7XG4gICAgdGhpcy51cGRhdGVBeGlzTGluZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5R3JpZExpbmVzKCk7XG4gICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gIH1cbiAgdXBkYXRlVGl0bGVDYXB0aW9uKCkge1xuICAgIGNvbnN0IHsgX3RpdGxlQ2FwdGlvbiB9ID0gdGhpcztcbiAgICBfdGl0bGVDYXB0aW9uLm5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIHVwZGF0ZUNhdGVnb3J5TGFiZWxzKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRpY2tMYWJlbExheW91dCB9ID0gdGhpcy5jb21wdXRlZExheW91dDtcbiAgICBjb25zdCBsYWJlbFNlbGVjdGlvbiA9IHRoaXMubGFiZWxTZWxlY3Rpb24udXBkYXRlKHRpY2tMYWJlbExheW91dCk7XG4gICAgbGFiZWxTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhkYXR1bSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU2VwYXJhdG9ycygpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzZXBhcmF0b3JMYXlvdXQgfSA9IHRoaXMuY29tcHV0ZWRMYXlvdXQ7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVwc2lsb24yID0gMWUtNztcbiAgICBjb25zdCBzZXBhcmF0b3JTZWxlY3Rpb24gPSB0aGlzLnNlcGFyYXRvclNlbGVjdGlvbi51cGRhdGUoc2VwYXJhdG9yTGF5b3V0KTtcbiAgICBzZXBhcmF0b3JTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0pID0+IHtcbiAgICAgIGxpbmUueDEgPSBkYXR1bS54MTtcbiAgICAgIGxpbmUueDIgPSBkYXR1bS54MjtcbiAgICAgIGxpbmUueTEgPSBkYXR1bS55O1xuICAgICAgbGluZS55MiA9IGRhdHVtLnk7XG4gICAgICBsaW5lLnZpc2libGUgPSB0aGlzLnRpY2suZW5hYmxlZCAmJiBkYXR1bS55ID49IHJhbmdlM1swXSAtIGVwc2lsb24yICYmIGRhdHVtLnkgPD0gcmFuZ2UzWzFdICsgZXBzaWxvbjI7XG4gICAgICBsaW5lLnN0cm9rZSA9IHRoaXMudGljay5zdHJva2U7XG4gICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICBsaW5lLnN0cm9rZVdpZHRoID0gMTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBeGlzTGluZXMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYXhpc0xpbmVMYXlvdXQgfSA9IHRoaXMuY29tcHV0ZWRMYXlvdXQ7XG4gICAgY29uc3QgYXhpc0xpbmVTZWxlY3Rpb24gPSB0aGlzLmF4aXNMaW5lU2VsZWN0aW9uLnVwZGF0ZShheGlzTGluZUxheW91dCk7XG4gICAgYXhpc0xpbmVTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0pID0+IHtcbiAgICAgIGxpbmUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIC4uLmRhdHVtLFxuICAgICAgICBzdHJva2U6IHRoaXMubGluZS5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmxpbmUud2lkdGhcbiAgICAgIH0pO1xuICAgICAgbGluZS54MSA9IGRhdHVtLng7XG4gICAgICBsaW5lLngyID0gZGF0dW0ueDtcbiAgICAgIGxpbmUueTEgPSBkYXR1bS55MTtcbiAgICAgIGxpbmUueTIgPSBkYXR1bS55MjtcbiAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB0aGlzLmxpbmUud2lkdGg7XG4gICAgICBsaW5lLnN0cm9rZSA9IHRoaXMubGluZS5zdHJva2U7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQ2F0ZWdvcnlHcmlkTGluZXMoKSB7XG4gICAgY29uc3QgeyBncmlkTGVuZ3RoLCBncmlkTGluZSwgbGFiZWwsIHJhbmdlOiByYW5nZTMsIHRpY2tTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IHRpY2tTY2FsZS50aWNrcygpO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBncmlkU2VsZWN0aW9uID0gdGhpcy5ncmlkTGluZVNlbGVjdGlvbi51cGRhdGUoZ3JpZExlbmd0aCA/IHRpY2tzIDogW10pO1xuICAgIGlmIChncmlkTGVuZ3RoKSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBzdHlsZSB9ID0gZ3JpZExpbmU7XG4gICAgICBjb25zdCBzdHlsZUNvdW50ID0gc3R5bGUubGVuZ3RoO1xuICAgICAgZ3JpZFNlbGVjdGlvbi5lYWNoKChsaW5lLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodGlja1NjYWxlLmNvbnZlcnQoZGF0dW0pKTtcbiAgICAgICAgbGluZS54MSA9IDA7XG4gICAgICAgIGxpbmUueDIgPSAtc2lkZUZsYWcgKiBncmlkTGVuZ3RoO1xuICAgICAgICBsaW5lLnkxID0geTtcbiAgICAgICAgbGluZS55MiA9IHk7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IGdyaWRMaW5lLmVuYWJsZWQgJiYgeSA+PSByYW5nZTNbMF0gJiYgeSA8PSByYW5nZTNbMV07XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlLCBsaW5lRGFzaCB9ID0gc3R5bGVbaW5kZXggJSBzdHlsZUNvdW50XTtcbiAgICAgICAgbGluZS5zdHJva2UgPSBzdHJva2U7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB3aWR0aDtcbiAgICAgICAgbGluZS5saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUxheW91dCgpIHtcbiAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlRG9tYWluKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjYWxlOiBzY2FsZTIsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsIH0sXG4gICAgICBtb2R1bGVDdHg6IHsgY2FsbGJhY2tDYWNoZSB9LFxuICAgICAgcmFuZ2U6IHJhbmdlMyxcbiAgICAgIHRpdGxlLFxuICAgICAgdGl0bGU6IHsgZm9ybWF0dGVyID0gKHApID0+IHAuZGVmYXVsdFZhbHVlIH0gPSB7fVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBzY2FsZTIucmFuZ2VbMF07XG4gICAgY29uc3QgcmFuZ2VFbmQgPSBzY2FsZTIucmFuZ2VbMV07XG4gICAgY29uc3QgcmFuZ2VMZW5ndGggPSBNYXRoLmFicyhyYW5nZUVuZCAtIHJhbmdlU3RhcnQpO1xuICAgIGNvbnN0IGJhbmR3aWR0aCA9IHJhbmdlTGVuZ3RoIC8gc2NhbGUyLmRvbWFpbi5sZW5ndGggfHwgMDtcbiAgICBjb25zdCBrZWVwRXZlcnkgPSBNYXRoLmNlaWwobGFiZWwuZm9udFNpemUgLyBiYW5kd2lkdGgpO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IE1hdGguYWJzKE1hdGguY29zKHJvdGF0aW9uKSkgPCAxZS04O1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IHRpY2tUcmVlTGF5b3V0ID0gdGhpcy50aWNrVHJlZUxheW91dDtcbiAgICBjb25zdCBsYWJlbHMgPSBzY2FsZTIudGlja3MoKTtcbiAgICBjb25zdCB0cmVlTGFiZWxzID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5ub2RlcyA6IFtdO1xuICAgIGNvbnN0IGlzTGFiZWxUcmVlID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5kZXB0aCA+IDEgOiBmYWxzZTtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uLCBwYXJhbGxlbEZsaXBGbGFnIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uOiBsYWJlbC5yb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbjogbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24gLSBNYXRoLlBJIC8gMiksXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbjogbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24pXG4gICAgfSk7XG4gICAgY29uc3QgdGlja0xhYmVsTGF5b3V0ID0gW107XG4gICAgY29uc3QgY29weUxhYmVsUHJvcHMgPSAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsbDogbm9kZS5maWxsLFxuICAgICAgICBmb250RmFtaWx5OiBub2RlLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplOiBub2RlLmZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGU6IG5vZGUuZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0OiBub2RlLmZvbnRXZWlnaHQsXG4gICAgICAgIHJvdGF0aW9uOiBub2RlLnJvdGF0aW9uLFxuICAgICAgICByb3RhdGlvbkNlbnRlclg6IG5vZGUucm90YXRpb25DZW50ZXJYLFxuICAgICAgICByb3RhdGlvbkNlbnRlclk6IG5vZGUucm90YXRpb25DZW50ZXJZLFxuICAgICAgICB0ZXh0OiBub2RlLnRleHQsXG4gICAgICAgIHRleHRBbGlnbjogbm9kZS50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbm9kZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogbm9kZS50cmFuc2xhdGlvblgsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogbm9kZS50cmFuc2xhdGlvblksXG4gICAgICAgIHZpc2libGU6IG5vZGUudmlzaWJsZSxcbiAgICAgICAgeDogbm9kZS54LFxuICAgICAgICB5OiBub2RlLnlcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBsYWJlbEJCb3hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IG1heExlYWZMYWJlbFdpZHRoID0gMDtcbiAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgY29uc3Qgc2V0TGFiZWxQcm9wcyA9IChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIHRlbXBUZXh0LnNldFByb3BlcnRpZXMoe1xuICAgICAgICBmaWxsOiBsYWJlbC5jb2xvcixcbiAgICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcbiAgICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcbiAgICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IHBhcmFsbGVsRmxpcEZsYWcgPT09IC0xID8gXCJib3R0b21cIiA6IFwiaGFuZ2luZ1wiLFxuICAgICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnNjcmVlblkgLSBsYWJlbC5mb250U2l6ZSAqIDAuMjUsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0uc2NyZWVuWFxuICAgICAgfSk7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgY29uc3QgaXNDYXB0aW9uRW5hYmxlZCA9IHRpdGxlPy5lbmFibGVkICYmIGxhYmVscy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoIWlzQ2FwdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHRoaXMuZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSk7XG4gICAgICAgIHRlbXBUZXh0LnNldFByb3BlcnRpZXMoe1xuICAgICAgICAgIGZpbGw6IHRpdGxlLmNvbG9yLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHRpdGxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemU6IHRpdGxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRTdHlsZTogdGl0bGUuZm9udFN0eWxlLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IHRpdGxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiaGFuZ2luZ1wiLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0uc2NyZWVuWSAtIGxhYmVsLmZvbnRTaXplICogMC4yNSxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnNjcmVlblhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ICUga2VlcEV2ZXJ5ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGlzSW5SYW5nZSA9IGRhdHVtLnNjcmVlblggPj0gcmFuZ2UzWzBdICYmIGRhdHVtLnNjcmVlblggPD0gcmFuZ2UzWzFdO1xuICAgICAgICBpZiAoIWlzSW5SYW5nZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwuZm9ybWF0dGVyKSB7XG4gICAgICAgICAgdGVtcFRleHQudGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcoZGF0dW0ubGFiZWwpLFxuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9KSA/PyBTdHJpbmcoZGF0dW0ubGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBUZXh0LnRleHQgPSBTdHJpbmcoZGF0dW0ubGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHRyZWVMYWJlbHMuZm9yRWFjaCgoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBzZXRMYWJlbFByb3BzKGRhdHVtLCBpbmRleCk7XG4gICAgICBpZiAoIWlzVmlzaWJsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYmJveDIgPSB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICBpZiAoIWJib3gyKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbEJCb3hlcy5zZXQoaW5kZXgsIGJib3gyKTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9ICFkYXR1bS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBpZiAoaXNMZWFmICYmIGJib3gyLndpZHRoID4gbWF4TGVhZkxhYmVsV2lkdGgpIHtcbiAgICAgICAgbWF4TGVhZkxhYmVsV2lkdGggPSBiYm94Mi53aWR0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqIGxhYmVsLnBhZGRpbmc7XG4gICAgY29uc3QgbGFiZWxHcmlkID0gdGhpcy5sYWJlbC5ncmlkO1xuICAgIGNvbnN0IHNlcGFyYXRvckRhdGEgPSBbXTtcbiAgICB0cmVlTGFiZWxzLmZvckVhY2goKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IHZpc2libGUgPSBzZXRMYWJlbFByb3BzKGRhdHVtLCBpbmRleCk7XG4gICAgICBjb25zdCBpZCA9IGluZGV4O1xuICAgICAgdGVtcFRleHQueCA9IGxhYmVsWDtcbiAgICAgIHRlbXBUZXh0LnJvdGF0aW9uQ2VudGVyWCA9IGxhYmVsWDtcbiAgICAgIGNvbnN0IGlzTGVhZiA9ICFkYXR1bS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gY29uZmlndXJlZFJvdGF0aW9uO1xuICAgICAgICB0ZW1wVGV4dC50ZXh0QWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcFRleHQudHJhbnNsYXRpb25YIC09IG1heExlYWZMYWJlbFdpZHRoIC0gbGluZUhlaWdodCArIHRoaXMubGFiZWwucGFkZGluZztcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUmFuZ2UgPSBkYXR1bS5sZWFmQ291bnQgKiBiYW5kd2lkdGg7XG4gICAgICAgIGNvbnN0IGJib3gyID0gbGFiZWxCQm94ZXMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGJib3gyICYmIGJib3gyLndpZHRoID4gYXZhaWxhYmxlUmFuZ2UpIHtcbiAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgbGFiZWxCQm94ZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGRlZmF1bHRSb3RhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdHVtLnBhcmVudCAmJiBpc0xhYmVsVHJlZSkge1xuICAgICAgICBjb25zdCB5ID0gaXNMZWFmID8gZGF0dW0uc2NyZWVuWCAtIGJhbmR3aWR0aCAvIDIgOiBkYXR1bS5zY3JlZW5YIC0gZGF0dW0ubGVhZkNvdW50ICogYmFuZHdpZHRoIC8gMjtcbiAgICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICAgIGlmIChkYXR1bS5udW1iZXIgIT09IGRhdHVtLmNoaWxkcmVuLmxlbmd0aCAtIDEgfHwgbGFiZWxHcmlkKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgICAgeDI6IC1tYXhMZWFmTGFiZWxXaWR0aCAtIHRoaXMubGFiZWwucGFkZGluZyAqIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB4ID0gLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMiArIGRhdHVtLnNjcmVlblk7XG4gICAgICAgICAgc2VwYXJhdG9yRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB4MTogeCArIGxpbmVIZWlnaHQsXG4gICAgICAgICAgICB4MjogeFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJvcHM7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICBjb25zdCBiYm94MiA9IHRlbXBUZXh0LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgICAgaWYgKGJib3gyKSB7XG4gICAgICAgICAgbGFiZWxCQm94ZXMuc2V0KGluZGV4LCBiYm94Mik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMgPSB7IC4uLmNvcHlMYWJlbFByb3BzKHRlbXBUZXh0KSwgdmlzaWJsZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxCQm94ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgcHJvcHMgPSB7IHZpc2libGUgfTtcbiAgICAgIH1cbiAgICAgIHRpY2tMYWJlbExheW91dC5wdXNoKHByb3BzKTtcbiAgICB9KTtcbiAgICBsZXQgbWluWCA9IDA7XG4gICAgc2VwYXJhdG9yRGF0YS5mb3JFYWNoKChkKSA9PiBtaW5YID0gTWF0aC5taW4obWluWCwgZC54MikpO1xuICAgIHNlcGFyYXRvckRhdGEucHVzaCh7XG4gICAgICB5OiBNYXRoLm1heChyYW5nZVN0YXJ0LCByYW5nZUVuZCksXG4gICAgICB4MTogMCxcbiAgICAgIHgyOiBtaW5YXG4gICAgfSk7XG4gICAgY29uc3Qgc2VwYXJhdG9yTGF5b3V0ID0gW107XG4gICAgY29uc3Qgc2VwYXJhdG9yQm94ZXMgPSBbXTtcbiAgICBjb25zdCBlcHNpbG9uMiA9IDFlLTc7XG4gICAgc2VwYXJhdG9yRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgaWYgKGRhdHVtLnkgPj0gcmFuZ2UzWzBdIC0gZXBzaWxvbjIgJiYgZGF0dW0ueSA8PSByYW5nZTNbMV0gKyBlcHNpbG9uMikge1xuICAgICAgICBjb25zdCB7IHgxLCB4MiwgeSB9ID0gZGF0dW07XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvckJveCA9IG5ldyBCQm94KE1hdGgubWluKHgxLCB4MiksIHksIE1hdGguYWJzKHgxIC0geDIpLCAwKTtcbiAgICAgICAgc2VwYXJhdG9yQm94ZXMucHVzaChzZXBhcmF0b3JCb3gpO1xuICAgICAgICBzZXBhcmF0b3JMYXlvdXQucHVzaCh7IHgxLCB4MiwgeSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBheGlzTGluZUxheW91dCA9IFtdO1xuICAgIGNvbnN0IGF4aXNMaW5lQm94ZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lQ291bnQgPSB0aWNrVHJlZUxheW91dCA/IHRpY2tUcmVlTGF5b3V0LmRlcHRoICsgMSA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdmlzaWJsZSA9IGxhYmVscy5sZW5ndGggPiAwICYmIChpID09PSAwIHx8IGxhYmVsR3JpZCAmJiBpc0xhYmVsVHJlZSk7XG4gICAgICBjb25zdCB4ID0gaSA+IDAgPyAtbWF4TGVhZkxhYmVsV2lkdGggLSB0aGlzLmxhYmVsLnBhZGRpbmcgKiAyIC0gKGkgLSAxKSAqIGxpbmVIZWlnaHQgOiAwO1xuICAgICAgY29uc3QgbGluZUJveCA9IG5ldyBCQm94KHgsIE1hdGgubWluKC4uLnJhbmdlMyksIDAsIE1hdGguYWJzKHJhbmdlM1sxXSAtIHJhbmdlM1swXSkpO1xuICAgICAgYXhpc0xpbmVCb3hlcy5wdXNoKGxpbmVCb3gpO1xuICAgICAgYXhpc0xpbmVMYXlvdXQucHVzaCh7IHgsIHkxOiByYW5nZTNbMF0sIHkyOiByYW5nZTNbMV0sIHZpc2libGUgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSBCQm94Lm1lcmdlKFsuLi5sYWJlbEJCb3hlcy52YWx1ZXMoKSwgLi4uc2VwYXJhdG9yQm94ZXMsIC4uLmF4aXNMaW5lQm94ZXNdKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJCb3ggPSB0aGlzLmdldFRyYW5zZm9ybUJveChiYm94KTtcbiAgICByZXR1cm4ge1xuICAgICAgYmJveDogdHJhbnNmb3JtZWRCQm94LFxuICAgICAgdGlja0xhYmVsTGF5b3V0LFxuICAgICAgc2VwYXJhdG9yTGF5b3V0LFxuICAgICAgYXhpc0xpbmVMYXlvdXRcbiAgICB9O1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dCgpIHtcbiAgICBjb25zdCB7IGF4aXNMaW5lTGF5b3V0LCBzZXBhcmF0b3JMYXlvdXQsIHRpY2tMYWJlbExheW91dCwgYmJveCB9ID0gdGhpcy5jb21wdXRlTGF5b3V0KCk7XG4gICAgdGhpcy5jb21wdXRlZExheW91dCA9IHsgYXhpc0xpbmVMYXlvdXQsIHNlcGFyYXRvckxheW91dCwgdGlja0xhYmVsTGF5b3V0IH07XG4gICAgcmV0dXJuIHsgYmJveCwgcHJpbWFyeVRpY2tDb3VudDogdm9pZCAwIH07XG4gIH1cbn07XG5Hcm91cGVkQ2F0ZWdvcnlBeGlzLmNsYXNzTmFtZSA9IFwiR3JvdXBlZENhdGVnb3J5QXhpc1wiO1xuR3JvdXBlZENhdGVnb3J5QXhpcy50eXBlID0gXCJncm91cGVkLWNhdGVnb3J5XCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEdyb3VwZWRDYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImxhYmVsQ29sb3JcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9tb2R1bGUudHNcbnZhciBCYXNlTW9kdWxlSW5zdGFuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBkZXN0cm95Rm4gb2YgdGhpcy5kZXN0cm95Rm5zKSB7XG4gICAgICBkZXN0cm95Rm4oKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTW9kdWxlUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlcGVuZGVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKC4uLm1vZHVsZXMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyRGVwZW5kZW5jaWVzKG1vZHVsZSk7XG4gICAgICBjb25zdCBvdGhlck1vZHVsZSA9IHRoaXMubW9kdWxlcy5maW5kKFxuICAgICAgICAob3RoZXIpID0+IG1vZHVsZS50eXBlID09PSBvdGhlci50eXBlICYmIG1vZHVsZS5vcHRpb25zS2V5ID09PSBvdGhlci5vcHRpb25zS2V5ICYmIG1vZHVsZS5pZGVudGlmaWVyID09PSBvdGhlci5pZGVudGlmaWVyXG4gICAgICApO1xuICAgICAgaWYgKG90aGVyTW9kdWxlKSB7XG4gICAgICAgIGlmIChtb2R1bGUucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiICYmIG90aGVyTW9kdWxlLnBhY2thZ2VUeXBlID09PSBcImNvbW11bml0eVwiKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihvdGhlck1vZHVsZSk7XG4gICAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSwgbW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzRW50ZXJwcmlzZU1vZHVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlcy5zb21lKChtKSA9PiBtLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIik7XG4gIH1cbiAgKmJ5VHlwZSguLi50eXBlcykge1xuICAgIGNvbnN0IHsgZGVwZW5kZW50cyB9ID0gdGhpcztcbiAgICBjb25zdCB5aWVsZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IG1heENvdW50ID0gMztcbiAgICBjb25zdCBtb2R1bGVzQnlUeXBlID0gdGhpcy5tb2R1bGVzLmZpbHRlcigobW9kdWxlKSA9PiB0eXBlcy5pbmNsdWRlcyhtb2R1bGUudHlwZSkpO1xuICAgIGRvIHtcbiAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXNCeVR5cGUpIHtcbiAgICAgICAgaWYgKHlpZWxkZWQuaGFzKG1vZHVsZS5vcHRpb25zS2V5KSB8fCBkZXBlbmRlbnRzLmhhcyhtb2R1bGUub3B0aW9uc0tleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBtb2R1bGU7XG4gICAgICAgIHlpZWxkZWQuYWRkKG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBkZXBlbmRlbmNpZXNdIG9mIGRlcGVuZGVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzLmRlbGV0ZShtb2R1bGUub3B0aW9uc0tleSk7XG4gICAgICAgICAgaWYgKGRlcGVuZGVuY2llcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBkZXBlbmRlbnRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICB9IHdoaWxlICh5aWVsZGVkLnNpemUgPCBtb2R1bGVzQnlUeXBlLmxlbmd0aCAmJiBjb3VudCA8IG1heENvdW50KTtcbiAgICBpZiAoZGVwZW5kZW50cy5zaXplID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBtb2R1bGUgZGVwZW5kZW5jaWVzOiBbJHtbLi4uZGVwZW5kZW50cy5rZXlzKCldfV1gKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJEZXBlbmRlbmNpZXMobW9kdWxlKSB7XG4gICAgaWYgKG1vZHVsZS5kZXBlbmRlbmNpZXMgPT0gbnVsbCB8fCBtb2R1bGUuZGVwZW5kZW5jaWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBtb2R1bGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQoa2V5KSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZGVwZW5kZW5jaWVzLmFkZChtb2R1bGUub3B0aW9uc0tleSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5zZXQoa2V5LCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVudHMuc2V0KG1vZHVsZS5vcHRpb25zS2V5LCBuZXcgU2V0KG1vZHVsZS5kZXBlbmRlbmNpZXMpKTtcbiAgfVxufTtcbnZhciBtb2R1bGVSZWdpc3RyeSA9IG5ldyBNb2R1bGVSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2FzeW5jLnRzXG5mdW5jdGlvbiBzbGVlcChzbGVlcFRpbWVvdXRNcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUodm9pZCAwKSwgc2xlZXBUaW1lb3V0TXMpO1xuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9tdXRleC50c1xudmFyIE11dGV4ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG4gICAgdGhpcy5hY3F1aXJlUXVldWUgPSBbXTtcbiAgfVxuICBhY3F1aXJlKGNiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmFjcXVpcmVRdWV1ZS5wdXNoKFtjYiwgcmVzb2x2ZV0pO1xuICAgICAgaWYgKHRoaXMuYXZhaWxhYmxlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXh0KCkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFjcXVpcmVJbW1lZGlhdGVseShjYikge1xuICAgIGlmICghdGhpcy5hdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hY3F1aXJlKGNiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNxdWlyZShhc3luYyAoKSA9PiB2b2lkIDApO1xuICB9XG4gIGFzeW5jIGRpc3BhdGNoTmV4dCgpIHtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIGxldCBbbmV4dCwgZG9uZV0gPSB0aGlzLmFjcXVpcmVRdWV1ZS5zaGlmdCgpID8/IFtdO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIGRvbmU/LigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKFwibXV0ZXggY2FsbGJhY2sgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICBkb25lPy4oKTtcbiAgICAgIH1cbiAgICAgIFtuZXh0LCBkb25lXSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkgPz8gW107XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9vYnNlcnZhYmxlLnRzXG52YXIgT2JzZXJ2YWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBsaXN0ZW5lciBtdXN0IGJlIGEgRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50VHlwZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKGV2ZW50VHlwZUxpc3RlbmVycykge1xuICAgICAgZXZlbnRUeXBlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2xpc3RlbmVyXSkpO1xuICAgIH1cbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQodHlwZSk/LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUodHlwZSk7XG4gICAgfVxuICB9XG4gIGhhc0V2ZW50TGlzdGVuZXIodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyh0eXBlKTtcbiAgfVxuICBjbGVhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBmaXJlRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudC50eXBlKT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGV2ZW50KSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGFkZGluZy50c1xudmFyIFBhZGRpbmcgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IodG9wID0gMCwgcmlnaHQgPSB0b3AsIGJvdHRvbSA9IHRvcCwgbGVmdCA9IHJpZ2h0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnRvcCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IHRoaXMubGVmdCA9IDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJ0b3BcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJyaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcImJvdHRvbVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcImxlZnRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcmVuZGVyLnRzXG5mdW5jdGlvbiBkZWJvdW5jZWRBbmltYXRpb25GcmFtZShjYikge1xuICByZXR1cm4gYnVpbGRTY2hlZHVsZXIoKGlubmVyQ2IsIF9kZWxheU1zKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaW5uZXJDYiksIGNiKTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlZENhbGxiYWNrKGNiKSB7XG4gIHJldHVybiBidWlsZFNjaGVkdWxlcigoaW5uZXJDYiwgZGVsYXlNcyA9IDApID0+IHNldFRpbWVvdXQoaW5uZXJDYiwgZGVsYXlNcyksIGNiKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2NoZWR1bGVyKHNjaGVkdWxlRm4sIGNiKSB7XG4gIGxldCBzY2hlZHVsZUNvdW50ID0gMDtcbiAgbGV0IHByb21pc2VSdW5uaW5nID0gZmFsc2U7XG4gIGxldCBhd2FpdGluZ1Byb21pc2U7XG4gIGxldCBhd2FpdGluZ0RvbmU7XG4gIGNvbnN0IGJ1c3kgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2VSdW5uaW5nO1xuICB9O1xuICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgIHByb21pc2VSdW5uaW5nID0gZmFsc2U7XG4gICAgYXdhaXRpbmdEb25lPy4oKTtcbiAgICBhd2FpdGluZ0RvbmUgPSB2b2lkIDA7XG4gICAgYXdhaXRpbmdQcm9taXNlID0gdm9pZCAwO1xuICAgIGlmIChzY2hlZHVsZUNvdW50ID4gMCkge1xuICAgICAgc2NoZWR1bGVGbihzY2hlZHVsZUNiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNjaGVkdWxlQ2IgPSAoKSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBzY2hlZHVsZUNvdW50O1xuICAgIHNjaGVkdWxlQ291bnQgPSAwO1xuICAgIHByb21pc2VSdW5uaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBtYXliZVByb21pc2UgPSBjYih7IGNvdW50IH0pO1xuICAgIGlmICghbWF5YmVQcm9taXNlKSB7XG4gICAgICBkb25lKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1heWJlUHJvbWlzZS50aGVuKGRvbmUsIGRvbmUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHNjaGVkdWxlKGRlbGF5TXMpIHtcbiAgICAgIGlmIChzY2hlZHVsZUNvdW50ID09PSAwICYmICFidXN5KCkpIHtcbiAgICAgICAgc2NoZWR1bGVGbihzY2hlZHVsZUNiLCBkZWxheU1zKTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlQ291bnQrKztcbiAgICB9LFxuICAgIGFzeW5jIGF3YWl0KCkge1xuICAgICAgaWYgKCFidXN5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGF3YWl0aW5nUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgYXdhaXRpbmdEb25lID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYnVzeSgpKSB7XG4gICAgICAgIGF3YWl0IGF3YWl0aW5nUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gXCIxMC4xLjBcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3N0YXRlL21lbWVudG8udHNcbnZhciBNZW1lbnRvQ2FyZXRha2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbi5zcGxpdChcIi1cIilbMF07XG4gIH1cbiAgc2F2ZSguLi5vcmlnaW5hdG9ycykge1xuICAgIGNvbnN0IHBhY2tldCA9IHsgdmVyc2lvbjogdGhpcy52ZXJzaW9uIH07XG4gICAgZm9yIChjb25zdCBvcmlnaW5hdG9yIG9mIE9iamVjdC52YWx1ZXMob3JpZ2luYXRvcnMpKSB7XG4gICAgICBwYWNrZXRbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV0gPSB0aGlzLmVuY29kZShvcmlnaW5hdG9yLCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmVzdG9yZShibG9iLCAuLi5vcmlnaW5hdG9ycykge1xuICAgIGlmICh0eXBlb2YgYmxvYiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBDb3VsZCBub3QgcmVzdG9yZSBkYXRhIG9mIHR5cGUgWyR7dHlwZW9mIGJsb2J9XSwgZXhwZWN0aW5nIGFuIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChibG9iID09IG51bGwpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgQ291bGQgbm90IHJlc3RvcmUgZGF0YSBvZiB0eXBlIFtudWxsXSwgZXhwZWN0aW5nIGFuIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKFwidmVyc2lvblwiIGluIGJsb2IpIHx8IHR5cGVvZiBibG9iLnZlcnNpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgQ291bGQgbm90IHJlc3RvcmUgZGF0YSwgbWlzc2luZyBbdmVyc2lvbl0gc3RyaW5nIGluIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3JpZ2luYXRvciBvZiBvcmlnaW5hdG9ycykge1xuICAgICAgaWYgKCEob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSBpbiBibG9iKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lbWVudG8gPSB0aGlzLmRlY29kZShvcmlnaW5hdG9yLCBibG9iW29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXldKTtcbiAgICAgIGlmICghb3JpZ2luYXRvci5ndWFyZE1lbWVudG8obWVtZW50bykpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBDb3VsZCBub3QgcmVzdG9yZSBbJHtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5fV0gZGF0YSwgdmFsdWUgd2FzIGludmFsaWQsIGlnbm9yaW5nLmAsXG4gICAgICAgICAgbWVtZW50b1xuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcmlnaW5hdG9yLnJlc3RvcmVNZW1lbnRvKHRoaXMudmVyc2lvbiwgYmxvYi52ZXJzaW9uLCBtZW1lbnRvKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZSBhIG1lbWVudG8gYXMgYSBzZXJpYWxpemFibGUgb2JqZWN0LCBlbmNvZGluZyBhbnkgbm9uLXNlcmlhbGl6YmxlIHR5cGVzLlxuICAgKi9cbiAgZW5jb2RlKG9yaWdpbmF0b3IsIG1lbWVudG8pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWVtZW50bywgdGhpcy5lbmNvZGVUeXBlcykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmNvZGUgWyR7b3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleX1dIHZhbHVlIFske2Vycm9yfV0uYCwge1xuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVjb2RlIGFuIGVuY29kZWQgbWVtZW50bywgZGVjb2RpbmcgYW55IG5vbi1zZXJpYWxpemFibGUgdHlwZXMuXG4gICAqL1xuICBkZWNvZGUob3JpZ2luYXRvciwgZW5jb2RlZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNvZGVkKSwgdGhpcy5kZWNvZGVUeXBlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlY29kZSBbJHtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5fV0gdmFsdWUgWyR7ZXJyb3J9XS5gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuY29kZVR5cGVzKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoaXNEYXRlKHRoaXNba2V5XSkpIHtcbiAgICAgIHJldHVybiB7IF9fdHlwZTogXCJkYXRlXCIsIHZhbHVlOiBTdHJpbmcodGhpc1trZXldKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZGVjb2RlVHlwZXMoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc09iamVjdCh0aGlzW2tleV0pICYmIFwiX190eXBlXCIgaW4gdGhpc1trZXldICYmIHRoaXNba2V5XS5fX3R5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpc1trZXldLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvc3RhdGUvc3RhdGVNYW5hZ2VyLnRzXG52YXIgU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhcmV0YWtlciA9IG5ldyBNZW1lbnRvQ2FyZXRha2VyKFZFUlNJT04pO1xuICAgIHRoaXMuc3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHNldFN0YXRlKG9yaWdpbmF0b3IsIHZhbHVlKSB7XG4gICAgaWYgKGpzb25EaWZmKHRoaXMuc3RhdGUuZ2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkpLCB2YWx1ZSkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5yZXN0b3JlU3RhdGUob3JpZ2luYXRvcik7XG4gIH1cbiAgcmVzdG9yZVN0YXRlKG9yaWdpbmF0b3IpIHtcbiAgICBjb25zdCB7IGNhcmV0YWtlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGF0ZS5oYXMob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5nZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgY2FyZXRha2VyLnJlc3RvcmUoeyB2ZXJzaW9uOiBjYXJldGFrZXIudmVyc2lvbiwgW29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXldOiB2YWx1ZSB9LCBvcmlnaW5hdG9yKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC91c2VyQWdlbnQudHNcbmZ1bmN0aW9uIGhhc0NvbnN0cmFpbmVkQ2FudmFzTWVtb3J5KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpUGhvbmVPU01hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvXFwoaVBob25lOyBDUFUgaVBob25lIE9TIChcXGQrX1xcZCtfXFxkKykgbGlrZSBNYWMgT1MgWFxcKS8pO1xuICBpZiAoaVBob25lT1NNYXRjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFttYWpvciwgbWlub3JdID0gaVBob25lT1NNYXRjaFsxXS5zcGxpdChcIl9cIikubWFwKE51bWJlcik7XG4gIHJldHVybiBtYWpvciA8IDE2IHx8IG1ham9yID09PSAxNiAmJiBtaW5vciA8IDY7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2NhbnZhcy9oZHBpQ2FudmFzLnRzXG52YXIgX0hkcGlDYW52YXMgPSBjbGFzcyBfSGRwaUNhbnZhcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMud2lkdGggPSA2MDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDA7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvLCBjYW52YXNDb25zdHJ1Y3Rvciwgd2lsbFJlYWRGcmVxdWVudGx5ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gaGFzQ29uc3RyYWluZWRDYW52YXNNZW1vcnkoKSA/IDEgOiBwaXhlbFJhdGlvID8/IGdldFdpbmRvdyhcImRldmljZVBpeGVsUmF0aW9cIik7XG4gICAgdGhpcy5lbGVtZW50ID0gY2FudmFzQ29uc3RydWN0b3I/LigpID8/IGNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKHdpZHRoID8/IHRoaXMud2lkdGgpICsgXCJweFwiO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID8/IHRoaXMuaGVpZ2h0KSArIFwicHhcIjtcbiAgICB0aGlzLmVsZW1lbnQud2lkdGggPSBNYXRoLnJvdW5kKCh3aWR0aCA/PyB0aGlzLndpZHRoKSAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5lbGVtZW50LmhlaWdodCA9IE1hdGgucm91bmQoKGhlaWdodCA/PyB0aGlzLmhlaWdodCkgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuZWxlbWVudC5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHkgfSk7XG4gICAgdGhpcy5vbkVuYWJsZWRDaGFuZ2UoKTtcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCA/PyAwLCBoZWlnaHQgPz8gMCk7XG4gICAgX0hkcGlDYW52YXMuZGVidWdDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0hkcGlDYW52YXM7XG4gIH1cbiAgZHJhd0ltYWdlKGNvbnRleHQsIGR4ID0gMCwgZHkgPSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuY29udGV4dC5jYW52YXMsIGR4LCBkeSk7XG4gIH1cbiAgdG9EYXRhVVJMKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnRvRGF0YVVSTCh0eXBlKTtcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyLCBjb250ZXh0LCBwaXhlbFJhdGlvIH0gPSB0aGlzO1xuICAgIGVsZW1lbnQyLndpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAqIHBpeGVsUmF0aW8pO1xuICAgIGVsZW1lbnQyLmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgZWxlbWVudDIuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBlbGVtZW50Mi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIHNuYXBzaG90KCkge1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB0aGlzLmVsZW1lbnQud2lkdGggPSAwO1xuICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgMCwgMCk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICBvbkVuYWJsZWRDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB0aGlzLmVuYWJsZWQgPyBcIlwiIDogXCJub25lXCI7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gIHN0YXRpYyBkZWJ1Z0NvbnRleHQoY3R4KSB7XG4gICAgaWYgKERlYnVnLmNoZWNrKFwiY2FudmFzXCIpKSB7XG4gICAgICBjb25zdCBzYXZlID0gY3R4LnNhdmUuYmluZChjdHgpO1xuICAgICAgY29uc3QgcmVzdG9yZSA9IGN0eC5yZXN0b3JlLmJpbmQoY3R4KTtcbiAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICBPYmplY3QuYXNzaWduKGN0eCwge1xuICAgICAgICBzYXZlKCkge1xuICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlKCkge1xuICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gVW5hYmxlIHRvIHJlc3RvcmUoKSBwYXN0IGRlcHRoIDBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9LFxuICAgICAgICB2ZXJpZnlEZXB0aFplcm8oKSB7XG4gICAgICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIFNhdmUvcmVzdG9yZSBkZXB0aCBpcyBub24temVybzogJHtkZXB0aH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC5vbkVuYWJsZWRDaGFuZ2UoKSlcbl0sIF9IZHBpQ2FudmFzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIEhkcGlDYW52YXMgPSBfSGRwaUNhbnZhcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbGF5ZXJzTWFuYWdlci50c1xudmFyIExheWVyc01hbmFnZXIgPSBjbGFzcyBfTGF5ZXJzTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhcywgbWFya0RpcnR5KSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5tYXJrRGlydHkgPSBtYXJrRGlydHk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInNjZW5lXCIpO1xuICAgIHRoaXMubGF5ZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm5leHRaSW5kZXggPSAwO1xuICAgIHRoaXMubmV4dExheWVySWQgPSAwO1xuICB9XG4gIHN0YXRpYyBzb3J0TGF5ZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcG91bmRBc2NlbmRpbmcoXG4gICAgICBbYS56SW5kZXgsIC4uLmEuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYS5pZF0sXG4gICAgICBbYi56SW5kZXgsIC4uLmIuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYi5pZF0sXG4gICAgICBhc2NlbmRpbmdTdHJpbmdOdW1iZXJVbmRlZmluZWRcbiAgICApO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyc01hcC5zaXplO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2syKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmxheWVyc01hcC52YWx1ZXMoKSkuc29ydChfTGF5ZXJzTWFuYWdlci5zb3J0TGF5ZXJzKS5mb3JFYWNoKGNhbGxiYWNrMik7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmNhbnZhcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5sYXllcnNNYXAuZm9yRWFjaCgoeyBjYW52YXMgfSkgPT4gY2FudmFzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgYWRkTGF5ZXIob3B0cykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyB9ID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgeyB6SW5kZXggPSB0aGlzLm5leHRaSW5kZXgrKywgbmFtZSwgekluZGV4U3ViT3JkZXIsIGdldENvbXB1dGVkT3BhY2l0eSwgZ2V0VmlzaWJpbGl0eSB9ID0gb3B0cztcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgSGRwaUNhbnZhcyh7IHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gfSk7XG4gICAgY29uc3QgbmV3TGF5ZXIgPSB7XG4gICAgICBpZDogdGhpcy5uZXh0TGF5ZXJJZCsrLFxuICAgICAgbmFtZSxcbiAgICAgIGNhbnZhcyxcbiAgICAgIHpJbmRleCxcbiAgICAgIHpJbmRleFN1Yk9yZGVyLFxuICAgICAgZ2V0Q29tcHV0ZWRPcGFjaXR5LFxuICAgICAgZ2V0VmlzaWJpbGl0eVxuICAgIH07XG4gICAgaWYgKHpJbmRleCA+PSB0aGlzLm5leHRaSW5kZXgpIHtcbiAgICAgIHRoaXMubmV4dFpJbmRleCA9IHpJbmRleCArIDE7XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzTWFwLnNldChjYW52YXMsIG5ld0xheWVyKTtcbiAgICB0aGlzLmRlYnVnKFwiU2NlbmUuYWRkTGF5ZXIoKSAtIGxheWVyc1wiLCB0aGlzLmxheWVyc01hcCk7XG4gICAgcmV0dXJuIG5ld0xheWVyLmNhbnZhcztcbiAgfVxuICByZW1vdmVMYXllcihjYW52YXMpIHtcbiAgICBpZiAodGhpcy5sYXllcnNNYXAuaGFzKGNhbnZhcykpIHtcbiAgICAgIHRoaXMubGF5ZXJzTWFwLmRlbGV0ZShjYW52YXMpO1xuICAgICAgY2FudmFzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVtb3ZlTGF5ZXIoKSAtICBsYXllcnNcIiwgdGhpcy5sYXllcnNNYXApO1xuICAgIH1cbiAgfVxuICBtb3ZlTGF5ZXIoY2FudmFzLCBuZXdaSW5kZXgsIG5ld1pJbmRleFN1Yk9yZGVyKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc01hcC5nZXQoY2FudmFzKTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLnpJbmRleCA9IG5ld1pJbmRleDtcbiAgICAgIGxheWVyLnpJbmRleFN1Yk9yZGVyID0gbmV3WkluZGV4U3ViT3JkZXI7XG4gICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLm1vdmVMYXllcigpIC0gIGxheWVyc1wiLCB0aGlzLmxheWVyc01hcCk7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMubGF5ZXJzTWFwLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NjZW5lRGVidWcudHNcbmZ1bmN0aW9uIGRlYnVnU3RhdHMobGF5ZXJzTWFuYWdlciwgZGVidWdTcGxpdFRpbWVzLCBjdHgsIHJlbmRlckN0eFN0YXRzLCBleHRyYURlYnVnU3RhdHMgPSB7fSwgc2VyaWVzUmVjdCA9IEJCb3guemVybykge1xuICBpZiAoIURlYnVnLmNoZWNrKFwic2NlbmU6c3RhdHNcIiAvKiBTQ0VORV9TVEFUUyAqLywgXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLykpXG4gICAgcmV0dXJuO1xuICBjb25zdCB7IGxheWVyc1JlbmRlcmVkID0gMCwgbGF5ZXJzU2tpcHBlZCA9IDAsIG5vZGVzUmVuZGVyZWQgPSAwLCBub2Rlc1NraXBwZWQgPSAwIH0gPSByZW5kZXJDdHhTdGF0cyA/PyB7fTtcbiAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IHsgc3RhcnQsIC4uLmR1cmF0aW9ucyB9ID0gZGVidWdTcGxpdFRpbWVzO1xuICBjb25zdCBzcGxpdHMgPSBPYmplY3QuZW50cmllcyhkdXJhdGlvbnMpLm1hcCgoW24sIHRdKSA9PiB7XG4gICAgcmV0dXJuIHRpbWUobiwgdCk7XG4gIH0pLmZpbHRlcigodikgPT4gdiAhPSBudWxsKS5qb2luKFwiICsgXCIpO1xuICBjb25zdCBleHRyYXMgPSBPYmplY3QuZW50cmllcyhleHRyYURlYnVnU3RhdHMpLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTogJHt2fWApLmpvaW4oXCIgOyBcIik7XG4gIGNvbnN0IGRldGFpbGVkU3RhdHMgPSBEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKTtcbiAgY29uc3Qgc3RhdHMgPSBbXG4gICAgYCR7dGltZShcIlxcdTIzRjFcXHVGRTBGXCIsIHN0YXJ0LCBlbmQpfSAoJHtzcGxpdHN9KWAsXG4gICAgYCR7ZXh0cmFzfWAsXG4gICAgYExheWVyczogJHtkZXRhaWxlZFN0YXRzID8gcGN0KGxheWVyc1JlbmRlcmVkLCBsYXllcnNTa2lwcGVkKSA6IGxheWVyc01hbmFnZXIuc2l6ZX1gLFxuICAgIGRldGFpbGVkU3RhdHMgPyBgTm9kZXM6ICR7cGN0KG5vZGVzUmVuZGVyZWQsIG5vZGVzU2tpcHBlZCl9YCA6IG51bGxcbiAgXS5maWx0ZXIoaXNTdHJpbmcpO1xuICBjb25zdCBtZWFzdXJlciA9IG5ldyBTaW1wbGVUZXh0TWVhc3VyZXIoKHQpID0+IGN0eC5tZWFzdXJlVGV4dCh0KSk7XG4gIGNvbnN0IHN0YXRzU2l6ZSA9IG5ldyBNYXAoc3RhdHMubWFwKCh0KSA9PiBbdCwgbWVhc3VyZXIubWVhc3VyZUxpbmVzKHQpXSkpO1xuICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KC4uLkFycmF5LmZyb20oc3RhdHNTaXplLnZhbHVlcygpLCAocykgPT4gcy53aWR0aCkpO1xuICBjb25zdCBoZWlnaHQgPSBhY2N1bXVsYXRlKHN0YXRzU2l6ZS52YWx1ZXMoKSwgKHMpID0+IHMuaGVpZ2h0KTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICBsZXQgeSA9IDA7XG4gIGZvciAoY29uc3QgW3N0YXQsIHNpemVdIG9mIHN0YXRzU2l6ZS5lbnRyaWVzKCkpIHtcbiAgICB5ICs9IHNpemUuaGVpZ2h0O1xuICAgIGN0eC5maWxsVGV4dChzdGF0LCAyICsgc2VyaWVzUmVjdC54LCB5KTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZGVidWdTY2VuZU5vZGVIaWdobGlnaHQoY3R4LCBkZWJ1Z05vZGVzKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGRlYnVnTm9kZXMpKSB7XG4gICAgY29uc3QgYmJveCA9IG5vZGUuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgIGlmICghYmJveCkge1xuICAgICAgTG9nZ2VyLmxvZyhgU2NlbmUucmVuZGVyKCkgLSBubyBiYm94IGZvciBkZWJ1Z2dlZCBub2RlIFske25hbWV9XS5gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguc3Ryb2tlUmVjdChiYm94LngsIGJib3gueSwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICBjdHguZm9udCA9IFwiMTZweCBzYW5zLXNlcmlmXCI7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2VUZXh0KG5hbWUsIGJib3gueCwgYmJveC55LCBiYm94LndpZHRoKTtcbiAgICBjdHguZmlsbFRleHQobmFtZSwgYmJveC54LCBiYm94LnksIGJib3gud2lkdGgpO1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUobm9kZSkge1xuICBpZiAoIURlYnVnLmNoZWNrKHRydWUsIFwic2NlbmVcIiAvKiBTQ0VORSAqLykpXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4ge1xuICAgIG5vZGUsXG4gICAgbmFtZTogbm9kZS5uYW1lID8/IG5vZGUuaWQsXG4gICAgZGlydHk6IFJlZHJhd1R5cGVbbm9kZS5kaXJ0eV0sXG4gICAgLi4ubm9kZS5wYXJlbnQ/LmlzVmlydHVhbCA/IHtcbiAgICAgIHZpcnR1YWxQYXJlbnREaXJ0eTogUmVkcmF3VHlwZVtub2RlLnBhcmVudC5kaXJ0eV0sXG4gICAgICB2aXJ0dWFsUGFyZW50OiBub2RlLnBhcmVudFxuICAgIH0gOiB7fSxcbiAgICAuLi5ub2RlLmNoaWxkcmVuLm1hcCgoYykgPT4gYnVpbGRUcmVlKGMpKS5yZWR1Y2UoKHJlc3VsdCwgY2hpbGRUcmVlKSA9PiB7XG4gICAgICBsZXQgeyBuYW1lOiB0cmVlTm9kZU5hbWUgfSA9IGNoaWxkVHJlZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZToge1xuICAgICAgICAgIHZpc2libGUsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgekluZGV4U3ViT3JkZXIsXG4gICAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWSxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBzY2FsaW5nWCxcbiAgICAgICAgICBzY2FsaW5nWVxuICAgICAgICB9LFxuICAgICAgICBub2RlOiBjaGlsZE5vZGUsXG4gICAgICAgIHZpcnR1YWxQYXJlbnRcbiAgICAgIH0gPSBjaGlsZFRyZWU7XG4gICAgICBpZiAoIXZpc2libGUgfHwgb3BhY2l0eSA8PSAwKSB7XG4gICAgICAgIHRyZWVOb2RlTmFtZSA9IGAoJHt0cmVlTm9kZU5hbWV9KWA7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgR3JvdXAgJiYgY2hpbGROb2RlLmlzTGF5ZXIoKSkge1xuICAgICAgICB0cmVlTm9kZU5hbWUgPSBgKiR7dHJlZU5vZGVOYW1lfSpgO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gW1xuICAgICAgICBgJHt0cmVlTm9kZU5hbWUgPz8gXCI8dW5rbm93bj5cIn1gLFxuICAgICAgICBgejogJHt6SW5kZXh9YCxcbiAgICAgICAgekluZGV4U3ViT3JkZXIgJiYgYHpvOiAke3pJbmRleFN1Yk9yZGVyLm1hcCgodikgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiA/IGAke3YoKX0gKGZuKWAgOiB2KS5qb2luKFwiIC8gXCIpfWAsXG4gICAgICAgIHZpcnR1YWxQYXJlbnQgJiYgYCh2aXJ0dWFsIHBhcmVudClgLFxuICAgICAgICB0cmFuc2xhdGlvblggJiYgYHg6ICR7dHJhbnNsYXRpb25YfWAsXG4gICAgICAgIHRyYW5zbGF0aW9uWSAmJiBgeTogJHt0cmFuc2xhdGlvbll9YCxcbiAgICAgICAgcm90YXRpb24gJiYgYHI6ICR7cm90YXRpb259YCxcbiAgICAgICAgc2NhbGluZ1ggIT09IDEgJiYgYHN4OiAke3NjYWxpbmdYfWAsXG4gICAgICAgIHNjYWxpbmdZICE9PSAxICYmIGBzeTogJHtzY2FsaW5nWX1gXG4gICAgICBdLmZpbHRlcigodikgPT4gISF2KS5qb2luKFwiIFwiKTtcbiAgICAgIGxldCBzZWxlY3RlZEtleSA9IGtleTtcbiAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICB3aGlsZSAocmVzdWx0W3NlbGVjdGVkS2V5XSAhPSBudWxsICYmIGluZGV4IDwgMTAwKSB7XG4gICAgICAgIHNlbGVjdGVkS2V5ID0gYCR7a2V5fSAoJHtpbmRleCsrfSlgO1xuICAgICAgfVxuICAgICAgcmVzdWx0W3NlbGVjdGVkS2V5XSA9IGNoaWxkVHJlZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pXG4gIH07XG59XG5mdW5jdGlvbiBidWlsZERpcnR5VHJlZShub2RlKSB7XG4gIGlmIChub2RlLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8pIHtcbiAgICByZXR1cm4geyBkaXJ0eVRyZWU6IHt9LCBwYXRoczogW10gfTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbkRpcnR5VHJlZSA9IG5vZGUuY2hpbGRyZW4ubWFwKChjKSA9PiBidWlsZERpcnR5VHJlZShjKSkuZmlsdGVyKChjKSA9PiBjLnBhdGhzLmxlbmd0aCA+IDApO1xuICBjb25zdCBuYW1lID0gR3JvdXAuaXMobm9kZSkgPyBub2RlLm5hbWUgPz8gbm9kZS5pZCA6IG5vZGUuaWQ7XG4gIGNvbnN0IHBhdGhzID0gY2hpbGRyZW5EaXJ0eVRyZWUubGVuZ3RoID8gY2hpbGRyZW5EaXJ0eVRyZWUuZmxhdE1hcCgoYykgPT4gYy5wYXRocykubWFwKChwKSA9PiBgJHtuYW1lfS4ke3B9YCkgOiBbbmFtZV07XG4gIHJldHVybiB7XG4gICAgZGlydHlUcmVlOiB7XG4gICAgICBuYW1lLFxuICAgICAgbm9kZSxcbiAgICAgIGRpcnR5OiBSZWRyYXdUeXBlW25vZGUuZGlydHldLFxuICAgICAgLi4uY2hpbGRyZW5EaXJ0eVRyZWUubWFwKChjKSA9PiBjLmRpcnR5VHJlZSkuZmlsdGVyKCh0KSA9PiB0LmRpcnR5ICE9IG51bGwpLnJlZHVjZSgocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgICAgcmVzdWx0W2NoaWxkVHJlZS5uYW1lID8/IFwiPHVua25vd24+XCJdID0gY2hpbGRUcmVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pXG4gICAgfSxcbiAgICBwYXRoc1xuICB9O1xufVxuZnVuY3Rpb24gcGN0KHJlbmRlcmVkLCBza2lwcGVkKSB7XG4gIGNvbnN0IHRvdGFsID0gcmVuZGVyZWQgKyBza2lwcGVkO1xuICByZXR1cm4gYCR7cmVuZGVyZWR9IC8gJHt0b3RhbH0gKCR7TWF0aC5yb3VuZCgxMDAgKiByZW5kZXJlZCAvIHRvdGFsKX0lKWA7XG59XG5mdW5jdGlvbiB0aW1lKG5hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgZHVyYXRpb24gPSBlbmQgIT0gbnVsbCA/IGVuZCAtIHN0YXJ0IDogc3RhcnQ7XG4gIHJldHVybiBgJHtuYW1lfTogJHtNYXRoLnJvdW5kKGR1cmF0aW9uICogMTAwKSAvIDEwMH1tc2A7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlKGl0ZXJhdG9yLCBtYXBwZXIpIHtcbiAgbGV0IHN1bTIgPSAwO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmF0b3IpIHtcbiAgICBzdW0yICs9IG1hcHBlcihpdGVtKTtcbiAgfVxuICByZXR1cm4gc3VtMjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2NlbmUudHNcbnZhciBTY2VuZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvLCBkb21NYW5hZ2VyIH0pIHtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwic2NlbmVcIiAvKiBTQ0VORSAqLyk7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICBjb25zdCBjYW52YXNPcHRzID0ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXhlbFJhdGlvXG4gICAgfTtcbiAgICBpZiAoZG9tTWFuYWdlcikge1xuICAgICAgY2FudmFzT3B0cy5jYW52YXNDb25zdHJ1Y3RvciA9ICgpID0+IGRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXNcIiwgXCJzY2VuZS1jYW52YXNcIik7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzID0gbmV3IEhkcGlDYW52YXMoY2FudmFzT3B0cyk7XG4gICAgdGhpcy5sYXllcnNNYW5hZ2VyID0gbmV3IExheWVyc01hbmFnZXIodGhpcy5jYW52YXMsICgpID0+IHtcbiAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdTaXplPy5bMF0gPz8gdGhpcy5jYW52YXMud2lkdGg7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nU2l6ZT8uWzFdID8/IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgfVxuICBzZXRDb250YWluZXIodmFsdWUpIHtcbiAgICBjb25zdCBpc0VsZW1lbnQgPSAodikgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2LnRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfTtcbiAgICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiB9ID0gdGhpcy5jYW52YXM7XG4gICAgICBlbGVtZW50Mi5wYXJlbnRFbGVtZW50Py5yZW1vdmVDaGlsZChlbGVtZW50Mik7XG4gICAgICB2YWx1ZS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9tTWFuYWdlciA9IHZhbHVlO1xuICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzXCIsIFwic2NlbmUtY2FudmFzXCIsIHRoaXMuY2FudmFzLmVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRSb290KG5vZGUpIHtcbiAgICBpZiAodGhpcy5yb290ID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnJvb3Q/Ll9zZXRMYXllck1hbmFnZXIoKTtcbiAgICB0aGlzLnJvb3QgPSBub2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLnZpc2libGUgPSB0cnVlO1xuICAgICAgbm9kZS5fc2V0TGF5ZXJNYW5hZ2VyKHRoaXMubGF5ZXJzTWFuYWdlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGF0dGFjaE5vZGUobm9kZSwgcm9vdEdyb3VwTmFtZSkge1xuICAgIGlmICghcm9vdEdyb3VwTmFtZSkge1xuICAgICAgdGhpcy5yb290Py5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRHcm91cCA9IHRoaXMucm9vdD8uY2hpbGRyZW4uZmluZCgoZykgPT4gZyBpbnN0YW5jZW9mIEdyb3VwICYmIGcubmFtZSA9PT0gcm9vdEdyb3VwTmFtZSk7XG4gICAgaWYgKCFwYXJlbnRHcm91cClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIFVucmVjb2duaXplZCByb290IGdyb3VwIG5hbWU6IFwiICsgcm9vdEdyb3VwTmFtZSk7XG4gICAgcGFyZW50R3JvdXAuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHBhcmVudEdyb3VwLnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9XG4gIGFwcGVuZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLnJvb3Q/LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUNoaWxkKG5vZGUpIHtcbiAgICB0aGlzLnJvb3Q/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KSB7XG4gICAgZG93bmxvYWRVcmwodGhpcy5jYW52YXMudG9EYXRhVVJMKGZpbGVGb3JtYXQpLCBmaWxlTmFtZT8udHJpbSgpID8/IFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqIE5PVEU6IEludGVncmF0ZWQgQ2hhcnRzIHVuZG9jdW1lbnRlZCBpbWFnZSBkb3dubG9hZCBtZXRob2QuICovXG4gIGdldERhdGFVUkwoZmlsZUZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoZmlsZUZvcm1hdCk7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDAgJiYgKHdpZHRoICE9PSB0aGlzLndpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5oZWlnaHQpKSB7XG4gICAgICB0aGlzLnBlbmRpbmdTaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKG9wdHMpIHtcbiAgICBjb25zdCB7IGRlYnVnU3BsaXRUaW1lcyA9IHsgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpIH0sIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCB9ID0gb3B0cyA/PyB7fTtcbiAgICBjb25zdCB7IGNhbnZhcywgY2FudmFzOiB7IGNvbnRleHQ6IGN0eCB9ID0ge30sIHJvb3QsIHBlbmRpbmdTaXplIH0gPSB0aGlzO1xuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChwZW5kaW5nU2l6ZSkge1xuICAgICAgdGhpcy5sYXllcnNNYW5hZ2VyLnJlc2l6ZSguLi5wZW5kaW5nU2l6ZSk7XG4gICAgICB0aGlzLnBlbmRpbmdTaXplID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiAhcm9vdC52aXNpYmxlKSB7XG4gICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgIXRoaXMuaXNEaXJ0eSkge1xuICAgICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVuZGVyKCkgLSBuby1vcFwiLCB7XG4gICAgICAgICAgcmVkcmF3VHlwZTogUmVkcmF3VHlwZVtyb290LmRpcnR5XSxcbiAgICAgICAgICB0cmVlOiBidWlsZFRyZWUocm9vdClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWJ1Z1N0YXRzKHRoaXMubGF5ZXJzTWFuYWdlciwgZGVidWdTcGxpdFRpbWVzLCBjdHgsIHZvaWQgMCwgZXh0cmFEZWJ1Z1N0YXRzLCBzZXJpZXNSZWN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgY3R4LFxuICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogdGhpcy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxLFxuICAgICAgZm9yY2VSZW5kZXI6IHRydWUsXG4gICAgICByZXNpemVkOiBCb29sZWFuKHBlbmRpbmdTaXplKSxcbiAgICAgIGRlYnVnTm9kZXM6IHt9XG4gICAgfTtcbiAgICBpZiAoRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLykpIHtcbiAgICAgIHJlbmRlckN0eC5zdGF0cyA9IHsgbGF5ZXJzUmVuZGVyZWQ6IDAsIGxheWVyc1NraXBwZWQ6IDAsIG5vZGVzUmVuZGVyZWQ6IDAsIG5vZGVzU2tpcHBlZDogMCB9O1xuICAgIH1cbiAgICBsZXQgY2FudmFzQ2xlYXJlZCA9IGZhbHNlO1xuICAgIGlmICghcm9vdCB8fCByb290LmRpcnR5ID49IDEgLyogVFJJVklBTCAqLykge1xuICAgICAgY2FudmFzQ2xlYXJlZCA9IHRydWU7XG4gICAgICBjYW52YXMuY2xlYXIoKTtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgRGVidWcuY2hlY2soXCJzY2VuZTpkaXJ0eVRyZWVcIiAvKiBTQ0VORV9ESVJUWV9UUkVFICovKSkge1xuICAgICAgY29uc3QgeyBkaXJ0eVRyZWUsIHBhdGhzIH0gPSBidWlsZERpcnR5VHJlZShyb290KTtcbiAgICAgIERlYnVnLmNyZWF0ZShcInNjZW5lOmRpcnR5VHJlZVwiIC8qIFNDRU5FX0RJUlRZX1RSRUUgKi8pKFwiU2NlbmUucmVuZGVyKCkgLSBkaXJ0eVRyZWVcIiwgeyBkaXJ0eVRyZWUsIHBhdGhzIH0pO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiBjYW52YXNDbGVhcmVkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVuZGVyKCkgLSBiZWZvcmVcIiwge1xuICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxuICAgICAgICBjYW52YXNDbGVhcmVkLFxuICAgICAgICB0cmVlOiBidWlsZFRyZWUocm9vdClcbiAgICAgIH0pO1xuICAgICAgaWYgKHJvb3QudmlzaWJsZSkge1xuICAgICAgICByb290LnByZVJlbmRlcigpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICByb290LnJlbmRlcihyZW5kZXJDdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1Z1NwbGl0VGltZXNbXCJcXHUyNzBEXFx1RkUwRlwiXSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcmVuZGVyU3RhcnRUaW1lO1xuICAgIGlmICh0aGlzLmxheWVyc01hbmFnZXIuc2l6ZSAmJiBjYW52YXNDbGVhcmVkKSB7XG4gICAgICBjb25zdCBsYXllclJlbmRlclN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLmxheWVyc01hbmFnZXIuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgaWYgKGxheWVyLmNhbnZhcy5lbmFibGVkICYmIGxheWVyLmdldFZpc2liaWxpdHkoKSkge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxheWVyLmdldENvbXB1dGVkT3BhY2l0eSgpO1xuICAgICAgICAgIGxheWVyLmNhbnZhcy5kcmF3SW1hZ2UoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgZGVidWdTcGxpdFRpbWVzW1wiXFx1MjZEOVwiXSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbGF5ZXJSZW5kZXJTdGFydDtcbiAgICB9XG4gICAgY3R4LnZlcmlmeURlcHRoWmVybz8uKCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgZGVidWdTdGF0cyh0aGlzLmxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCByZW5kZXJDdHguc3RhdHMsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCk7XG4gICAgZGVidWdTY2VuZU5vZGVIaWdobGlnaHQoY3R4LCByZW5kZXJDdHguZGVidWdOb2Rlcyk7XG4gICAgaWYgKHJvb3QgJiYgdGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVuZGVyKCkgLSBhZnRlclwiLCB7XG4gICAgICAgIHJlZHJhd1R5cGU6IFJlZHJhd1R5cGVbcm9vdC5kaXJ0eV0sXG4gICAgICAgIHRyZWU6IGJ1aWxkVHJlZShyb290KSxcbiAgICAgICAgY2FudmFzQ2xlYXJlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKiBBbHRlcm5hdGl2ZSB0byBkZXN0cm95KCkgdGhhdCBwcmVzZXJ2ZXMgcmUtdXNhYmxlIHJlc291cmNlcy4gKi9cbiAgc3RyaXAoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBwaXhlbFJhdGlvIH0gPSB0aGlzLmNhbnZhcztcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICB0aGlzLmxheWVyc01hbmFnZXIuY2xlYXIoKTtcbiAgICB0aGlzLnNldFJvb3QobnVsbCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdGhpcy5jYW52YXMuZGVzdHJveSgpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBjYW52YXM6IHZvaWQgMCB9KTtcbiAgfVxufTtcblNjZW5lLmNsYXNzTmFtZSA9IFwiU2NlbmVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jYWxsYmFja0NhY2hlLnRzXG52YXIgQ2FsbGJhY2tDYWNoZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNhbGwoZm4sIC4uLnBhcmFtcykge1xuICAgIGxldCBzZXJpYWxpc2VkUGFyYW1zO1xuICAgIGxldCBwYXJhbUNhY2hlID0gdGhpcy5jYWNoZS5nZXQoZm4pO1xuICAgIHRyeSB7XG4gICAgICBzZXJpYWxpc2VkUGFyYW1zID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZva2UoZm4sIHBhcmFtcywgcGFyYW1DYWNoZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbUNhY2hlID09IG51bGwpIHtcbiAgICAgIHBhcmFtQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5jYWNoZS5zZXQoZm4sIHBhcmFtQ2FjaGUpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtQ2FjaGUuaGFzKHNlcmlhbGlzZWRQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZva2UoZm4sIHBhcmFtcywgcGFyYW1DYWNoZSwgc2VyaWFsaXNlZFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbUNhY2hlLmdldChzZXJpYWxpc2VkUGFyYW1zKTtcbiAgfVxuICBpbnZva2UoZm4sIHBhcmFtcywgcGFyYW1DYWNoZSwgc2VyaWFsaXNlZFBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmbiguLi5wYXJhbXMpO1xuICAgICAgaWYgKHBhcmFtQ2FjaGUgJiYgc2VyaWFsaXNlZFBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtQ2FjaGUuc2V0KHNlcmlhbGlzZWRQYXJhbXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgVXNlciBjYWxsYmFjayBlcnJvcmVkLCBpZ25vcmluZ2AsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlQ2FjaGUoKSB7XG4gICAgdGhpcy5jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2xpc3RlbmVycy50c1xudmFyIExpc3RlbmVycyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCByZWNvcmQgPSB7IHN5bWJvbDogU3ltYm9sKGV2ZW50VHlwZSksIGhhbmRsZXIgfTtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSkucHVzaChyZWNvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgW3JlY29yZF0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihyZWNvcmQuc3ltYm9sKTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihldmVudFN5bWJvbCkge1xuICAgIGZvciAoY29uc3QgW3R5cGUsIGxpc3RlbmVyc10gb2YgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGxpc3RlbmVyKSA9PiBsaXN0ZW5lci5zeW1ib2wgPT09IGV2ZW50U3ltYm9sKTtcbiAgICAgIGlmIChtYXRjaEluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShtYXRjaEluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaChldmVudFR5cGUsIC4uLnBhcmFtcykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5nZXRMaXN0ZW5lcnNCeVR5cGUoZXZlbnRUeXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuaGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaFdyYXBIYW5kbGVycyhldmVudFR5cGUsIHdyYXBGbiwgLi4ucGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cmFwRm4obGlzdGVuZXIuaGFuZGxlciwgLi4ucGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yT25jZShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSkgPz8gW107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYmFzZU1hbmFnZXIudHNcbnZhciBCYXNlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9hbm5vdGF0aW9uL2Fubm90YXRpb25NYW5hZ2VyLnRzXG52YXIgQW5ub3RhdGlvbk1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoYW5ub3RhdGlvblJvb3QpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBhbm5vdGF0aW9uUm9vdDtcbiAgICB0aGlzLm1lbWVudG9PcmlnaW5hdG9yS2V5ID0gXCJhbm5vdGF0aW9uc1wiO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgfVxuICBjcmVhdGVNZW1lbnRvKCkge1xuICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zO1xuICB9XG4gIGd1YXJkTWVtZW50byhibG9iKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoYmxvYik7XG4gIH1cbiAgcmVzdG9yZU1lbWVudG8oX3ZlcnNpb24sIF9tZW1lbnRvVmVyc2lvbiwgbWVtZW50bykge1xuICAgIGNvbnN0IGFubm90YXRpb25zMiA9IHRoaXMuY2xlYW5EYXRhKG1lbWVudG8pLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgY29uc3QgYW5ub3RhdGlvblRoZW1lID0gdGhpcy5nZXRBbm5vdGF0aW9uVHlwZVN0eWxlcyhhbm5vdGF0aW9uLnR5cGUpO1xuICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoYW5ub3RhdGlvbiwgYW5ub3RhdGlvblRoZW1lKTtcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInJlc3RvcmUtYW5ub3RhdGlvbnNcIiwge1xuICAgICAgdHlwZTogXCJyZXN0b3JlLWFubm90YXRpb25zXCIsXG4gICAgICBhbm5vdGF0aW9uczogYW5ub3RhdGlvbnMyXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlRGF0YShhbm5vdGF0aW9uczIpIHtcbiAgICB0aGlzLmFubm90YXRpb25zID0gdGhpcy5jbGVhbkRhdGEoYW5ub3RhdGlvbnMyID8/IFtdKTtcbiAgfVxuICBhdHRhY2hOb2RlKG5vZGUpIHtcbiAgICB0aGlzLmFubm90YXRpb25Sb290LmFwcGVuZChub2RlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uUm9vdD8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIHNldEFubm90YXRpb25TdHlsZXMoc3R5bGVzKSB7XG4gICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvblR5cGVTdHlsZXModHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlcz8uW3R5cGVdO1xuICB9XG4gIGNsZWFuRGF0YShhbm5vdGF0aW9uczIpIHtcbiAgICBmb3IgKGNvbnN0IGFubm90YXRpb24gb2YgYW5ub3RhdGlvbnMyKSB7XG4gICAgICBpZiAoXCJ0ZXh0QWxpZ25cIiBpbiBhbm5vdGF0aW9uKVxuICAgICAgICBkZWxldGUgYW5ub3RhdGlvbi50ZXh0QWxpZ247XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uczI7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc01hbmFnZXIudHNcbnZhciBBeGlzTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NlbmVSb290KSB7XG4gICAgdGhpcy5zY2VuZVJvb3QgPSBzY2VuZVJvb3Q7XG4gICAgdGhpcy5heGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmF4aXNHcmlkR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcIkF4ZXMtR3JpZHNcIiwgbGF5ZXI6IHRydWUsIHpJbmRleDogMSAvKiBBWElTX0dSSURfWklOREVYICovIH0pO1xuICAgIHRoaXMuYXhpc0dyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJBeGVzXCIsIGxheWVyOiB0cnVlLCB6SW5kZXg6IDIgLyogQVhJU19aSU5ERVggKi8gfSk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIHRoaXMuc2NlbmVSb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gIH1cbiAgdXBkYXRlQXhlcyhvbGRBeGVzLCBuZXdBeGVzKSB7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG9sZEF4ZXMpIHtcbiAgICAgIGlmIChuZXdBeGVzLmluY2x1ZGVzKGF4aXMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGF4aXMuZGV0YWNoQXhpcyh0aGlzLmF4aXNHcm91cCwgdGhpcy5heGlzR3JpZEdyb3VwKTtcbiAgICAgIGF4aXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgbmV3QXhlcykge1xuICAgICAgaWYgKG9sZEF4ZXM/LmluY2x1ZGVzKGF4aXMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGF4aXMuYXR0YWNoQXhpcyh0aGlzLmF4aXNHcm91cCwgdGhpcy5heGlzR3JpZEdyb3VwKTtcbiAgICB9XG4gICAgdGhpcy5heGVzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG5ld0F4ZXMpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGF4aXMuY3JlYXRlQXhpc0NvbnRleHQoKTtcbiAgICAgIGlmICh0aGlzLmF4ZXMuaGFzKGN0eC5kaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMuYXhlcy5nZXQoY3R4LmRpcmVjdGlvbik/LnB1c2goY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXhlcy5zZXQoY3R4LmRpcmVjdGlvbiwgW2N0eF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBeGlzQ29udGV4dChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuYXhlcy5nZXQoZGlyZWN0aW9uKSA/PyBbXV07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmF4ZXMuY2xlYXIoKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5yZW1vdmVDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gICAgdGhpcy5zY2VuZVJvb3QucmVtb3ZlQ2hpbGQodGhpcy5heGlzR3JpZEdyb3VwKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9kYXRhU2VydmljZS50c1xudmFyIERhdGFTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3RvcihhbmltYXRpb25NYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBhbmltYXRpb25NYW5hZ2VyO1xuICAgIHRoaXMuZGlzcGF0Y2hPbmx5TGF0ZXN0ID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoVGhyb3R0bGUgPSAwO1xuICAgIHRoaXMucmVxdWVzdFRocm90dGxlID0gMzAwO1xuICAgIHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgPSBmYWxzZTtcbiAgICB0aGlzLmlzTG9hZGluZ0RhdGEgPSBmYWxzZTtcbiAgICB0aGlzLmZyZXNoUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLnJlcXVlc3RDb3VudGVyID0gMDtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiZGF0YS1tb2RlbFwiLCBcImRhdGEtc291cmNlXCIpO1xuICAgIHRoaXMudGhyb3R0bGVkRmV0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZEZldGNoKHRoaXMucmVxdWVzdFRocm90dGxlKTtcbiAgICB0aGlzLnRocm90dGxlZERpc3BhdGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWREaXNwYXRjaCh0aGlzLmRpc3BhdGNoVGhyb3R0bGUpO1xuICB9XG4gIHVwZGF0ZUNhbGxiYWNrKGRhdGFTb3VyY2VDYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgZGF0YVNvdXJjZUNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFTZXJ2aWNlIC0gdXBkYXRlZCBkYXRhIHNvdXJjZSBjYWxsYmFja1wiKTtcbiAgICB0aGlzLmRhdGFTb3VyY2VDYWxsYmFjayA9IGRhdGFTb3VyY2VDYWxsYmFjaztcbiAgICB0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2tpcCgpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLXNvdXJjZS1jaGFuZ2VcIik7XG4gIH1cbiAgY2xlYXJDYWxsYmFjaygpIHtcbiAgICB0aGlzLmRhdGFTb3VyY2VDYWxsYmFjayA9IHZvaWQgMDtcbiAgfVxuICBsb2FkKHBhcmFtcykge1xuICAgIHRoaXMuaXNMb2FkaW5nRGF0YSA9IHRydWU7XG4gICAgdGhpcy50aHJvdHRsZWRGZXRjaChwYXJhbXMpO1xuICB9XG4gIGlzTGF6eSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlQ2FsbGJhY2sgIT0gbnVsbDtcbiAgfVxuICBpc0xvYWRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMYXp5KCkgJiYgKHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgfHwgdGhpcy5pc0xvYWRpbmdEYXRhKTtcbiAgfVxuICBjcmVhdGVUaHJvdHRsZWRGZXRjaChyZXF1ZXN0VGhyb3R0bGUpIHtcbiAgICByZXR1cm4gdGhyb3R0bGUoKHBhcmFtcykgPT4gdGhpcy5mZXRjaChwYXJhbXMpLCByZXF1ZXN0VGhyb3R0bGUsIHtcbiAgICAgIGxlYWRpbmc6IGZhbHNlLFxuICAgICAgdHJhaWxpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUaHJvdHRsZWREaXNwYXRjaChkaXNwYXRjaFRocm90dGxlKSB7XG4gICAgcmV0dXJuIHRocm90dGxlKFxuICAgICAgKGlkLCBkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gZGlzcGF0Y2hpbmcgJ2RhdGEtbG9hZCcgfCAke2lkfWApO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS1sb2FkXCIsIHsgdHlwZTogXCJkYXRhLWxvYWRcIiwgZGF0YSB9KTtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaFRocm90dGxlLFxuICAgICAge1xuICAgICAgICBsZWFkaW5nOiB0cnVlLFxuICAgICAgICB0cmFpbGluZzogdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZmV0Y2gocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmRhdGFTb3VyY2VDYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YVNlcnZpY2UgLSBbZGF0YVNvdXJjZS5nZXREYXRhXSBjYWxsYmFjayBub3QgaW5pdGlhbGlzZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLnJlcXVlc3RDb3VudGVyKys7XG4gICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSByZXF1ZXN0aW5nIHwgJHtpZH1gKTtcbiAgICB0aGlzLmZyZXNoUmVxdWVzdHMucHVzaChpZCk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrKHBhcmFtcyk7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlc3BvbnNlIHwgJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zIHwgJHtpZH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSByZXF1ZXN0IGZhaWxlZCB8ICR7aWR9YCk7XG4gICAgICBMb2dnZXIuZXJyb3JPbmNlKGBEYXRhU2VydmljZSAtIHJlcXVlc3QgZmFpbGVkIHwgWyR7ZXJyb3J9XWApO1xuICAgIH1cbiAgICB0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhID0gZmFsc2U7XG4gICAgY29uc3QgcmVxdWVzdEluZGV4ID0gdGhpcy5mcmVzaFJlcXVlc3RzLmZpbmRJbmRleCgocmlkKSA9PiByaWQgPT09IGlkKTtcbiAgICBpZiAocmVxdWVzdEluZGV4ID09PSAtMSB8fCB0aGlzLmRpc3BhdGNoT25seUxhdGVzdCAmJiByZXF1ZXN0SW5kZXggIT09IHRoaXMuZnJlc2hSZXF1ZXN0cy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIGRpc2NhcmRpbmcgc3RhbGUgcmVxdWVzdCB8ICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cyA9IHRoaXMuZnJlc2hSZXF1ZXN0cy5zbGljZShyZXF1ZXN0SW5kZXggKyAxKTtcbiAgICBpZiAodGhpcy5mcmVzaFJlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgdGhpcy50aHJvdHRsZWREaXNwYXRjaChpZCwgcmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS1lcnJvclwiKTtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUoZGlzcGF0Y2hUaHJvdHRsZSkge1xuICAgICAgdGhpcy50aHJvdHRsZWREaXNwYXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRGlzcGF0Y2goZGlzcGF0Y2hUaHJvdHRsZSk7XG4gICAgfVxuICB9KVxuXSwgRGF0YVNlcnZpY2UucHJvdG90eXBlLCBcImRpc3BhdGNoVGhyb3R0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUocmVxdWVzdFRocm90dGxlKSB7XG4gICAgICB0aGlzLnRocm90dGxlZEZldGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWRGZXRjaChyZXF1ZXN0VGhyb3R0bGUpO1xuICAgIH1cbiAgfSlcbl0sIERhdGFTZXJ2aWNlLnByb3RvdHlwZSwgXCJyZXF1ZXN0VGhyb3R0bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3N0eWxlcy5jc3NcbnZhciBzdHlsZXNfZGVmYXVsdCA9ICcuYWctY2hhcnRzLXdyYXBwZXIsLmFnLWNoYXJ0cy13cmFwcGVyOmZvY3VzLC5hZy1jaGFydHMtd3JhcHBlcjphZnRlciwuYWctY2hhcnRzLXdyYXBwZXI6YmVmb3JlLC5hZy1jaGFydHMtd3JhcHBlciAqLC5hZy1jaGFydHMtd3JhcHBlciAqOmZvY3VzLC5hZy1jaGFydHMtd3JhcHBlciAqOmFmdGVyLC5hZy1jaGFydHMtd3JhcHBlciAqOmJlZm9yZXtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3V0bGluZTpub25lfS5hZy1jaGFydHMtd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZX0uYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3VjaC1hY3Rpb246YXV0bztkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6dmFyKC0tYWctY2hhcnRzLWFsaWduKTtqdXN0aWZ5LWNvbnRlbnQ6dmFyKC0tYWctY2hhcnRzLWp1c3RpZnkpfS5hZy1jaGFydHMtY2FudmFzLWNvbnRhaW5lciwuYWctY2hhcnRzLWNhbnZhc3twb3NpdGlvbjpyZWxhdGl2ZX0uYWctY2hhcnRzLWNhbnZhcy1jb250YWluZXI+KiwuYWctY2hhcnRzLWNhbnZhcz4qe2Rpc3BsYXk6YmxvY2t9LmFnLWNoYXJ0cy1jYW52YXMtcHJveHl7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydHMtdGFiLWd1YXJke3dpZHRoOjA7aGVpZ2h0OjA7b3BhY2l0eTowfS5hZy1jaGFydHMtY2FudmFzLW92ZXJsYXl7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtpbnNldDowfS5hZy1jaGFydHMtY2FudmFzLW92ZXJsYXk+Kntwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czphdXRvfS5hZy1jaGFydHMtdGhlbWUtZGVmYXVsdCwuYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQtZGFya3stLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3I6IHZhcigtLWFnLWFjdGl2ZS1jb2xvciwgIzIxOTZmMyk7LS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZik7LS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctZm9yZWdyb3VuZC1jb2xvciwgIzE4MWQxZik7LS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNkZGRkZGQpOy0tYWctY2hhcnRzLWZvbnQtZmFtaWx5OiBcIlZlcmRhbmFcIiwgc2Fucy1zZXJpZjstLWFnLWNoYXJ0cy1mb250LXNpemU6IHZhcigtLWFnLWZvbnQtc2l6ZSwgMTRweCk7LS1hZy1jaGFydHMtc2l6ZTogdmFyKC0tYWctZ3JpZC1zaXplLCA4cHgpOy0tYWctY2hhcnRzLWJvcmRlcjogdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jb2xvcikgdmFyKC0tYWctYm9yZGVycywgc29saWQgMXB4KTstLWFnLWNoYXJ0cy1ib3JkZXItY3JpdGljYWw6IHZhcigtLWFnLWJvcmRlcnMtY3JpdGljYWwsIHNvbGlkIDFweCk7LS1hZy1jaGFydHMtbGF5ZXItdWktb3ZlcmxheTogNTstLWFnLWNoYXJ0cy1sYXllci10b29sdGlwOiA0Oy0tYWctY2hhcnRzLWxheWVyLXRvb2xiYXI6IDM7LS1hZy1jaGFydHMtbGF5ZXItY3Jvc3NoYWlyOiAyOy0tYWctY2hhcnRzLWxheWVyLWFubm90YXRpb25zOiAxOy0tYWctY2hhcnRzLWFsaWduOiBjZW50ZXI7LS1hZy1jaGFydHMtanVzdGlmeTogY2VudGVyOy0tYWctY2hhcnRzLWF4aXMtbGFiZWwtYmFja2dyb3VuZC1jb2xvcjogIzQ3NDc0NzstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWNvbG9yOiAjZmZmZmZmOy0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctaGVhZGVyLWZvcmVncm91bmQtY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSk7LS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoIC0tYWctaGVhZGVyLWJhY2tncm91bmQtY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSAyJSkgKTstLWFnLWNoYXJ0cy10b29sYmFyLXNpemU6IDM0cHg7LS1hZy1jaGFydHMtdG9vbGJhci1zaXplLXNtYWxsOiAyNHB4Oy0tYWctY2hhcnRzLXRvb2xiYXItYm9yZGVyOiB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNyaXRpY2FsLCBzb2xpZCAxcHgpIHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSAxMiUgKTstLWFnLWNoYXJ0cy10b29sYmFyLWZvY3VzLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcik7LS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtZm9yZWdyb3VuZC1jb2xvcjogdmFyKCAtLWFnLWRpc2FibGVkLWZvcmVncm91bmQtY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcikgNTAlKSApOy0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcikgNiUgKTstLWFnLWNoYXJ0cy10b29sYmFyLWdhcDogdmFyKC0tYWctY2hhcnRzLXNpemUpOy0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplOiAxM3B4Oy0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplLXNtYWxsOiAxMnB4Oy0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmc6IDZweDstLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nLXNtYWxsOiAxcHg7LS1hZy1jaGFydHMtcG9wb3Zlci1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItYm9yZGVyOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ib3JkZXIpOy0tYWctY2hhcnRzLXBvcG92ZXItYWN0aXZlLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItaG92ZXItY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1mb250LXNpemUtc21hbGw6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZS1zbWFsbCk7LS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1czogdmFyKC0tYWctYm9yZGVyLXJhZGl1cywgNHB4KTstLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcjogc29saWQgMXB4IHZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3c6IHZhciggLS1hZy1pbnB1dC1mb2N1cy1ib3gtc2hhZG93LCAwIDAgMCAzcHggY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpKSAyMCUpICk7LS1hZy1jaGFydHMtaWNvbi1mb250LWZhbWlseTogXCJhZ0NoYXJ0c0RlZmF1bHRcIjstLWFnLWNoYXJ0cy1pY29uLWZvbnQtd2VpZ2h0OiBub3JtYWw7LS1hZy1jaGFydHMtaWNvbi1mb250LWNvbG9yOiBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSwgOTAlKTstLWFnLWNoYXJ0cy1pY29uLXNpemU6IDIwcHg7LS1hZy1jaGFydHMtdGV4dC1hbm5vdGF0aW9ucy1wbGFjZWhvbGRlcjogIzg4ODg4OH0uYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQtZGFya3stLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgI2ZmZiwgIzE4MjIzMCA5NyUpKTstLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1mb3JlZ3JvdW5kLWNvbG9yLCAjZmZmKTstLWFnLWNoYXJ0cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWJvcmRlci1jb2xvciwgcmdiYSgyNTUsIDI1NSwgMjU1LCAuMTYpKTstLWFnLWNoYXJ0cy1ob3Zlci1jb2xvcjogdmFyKCAtLWFnLXJvdy1ob3Zlci1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSAyMCUpICk7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1iYWNrZ3JvdW5kLWNvbG9yOiAjOWNhZWJiOy0tYWctY2hhcnRzLWF4aXMtbGFiZWwtY29sb3I6ICMwMDAwMDA7LS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1oZWFkZXItYmFja2dyb3VuZC1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsICNmZmYsICMxODIyMzAgOTMlKSk7LS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpIDE4JSApOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3c6IHZhciggLS1hZy1pbnB1dC1mb2N1cy1ib3gtc2hhZG93LCAwIDAgMCAzcHggY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpKSAyMCUpICk7LS1hZy1jaGFydHMtdGV4dC1hbm5vdGF0aW9ucy1wbGFjZWhvbGRlcjogI2FhYWFhYX0uYWctY2hhcnRzLWljb257ZGlzcGxheTpibG9jazt3aWR0aDp2YXIoLS1hZy1jaGFydHMtaWNvbi1zaXplKTtoZWlnaHQ6dmFyKC0tYWctY2hhcnRzLWljb24tc2l6ZSk7c3BlYWs6bm9uZTtzcGVhazpuZXZlcjttYXNrOnZhcigtLWljb24pIGNlbnRlciAvIGNvbnRhaW4gbm8tcmVwZWF0O2JhY2tncm91bmQtY29sb3I6Y3VycmVudENvbG9yO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMjVzIGVhc2UtaW4tb3V0fS5hZy1jaGFydHMtaWNvbi1jYWxsb3V0LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NeUEwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0EwTGpVZ00yZ3hNVUV4TGpVZ01TNDFJREFnTUNBeElERTNJRFF1TlhZNFlURXVOU0F4TGpVZ01DQXdJREV0TVM0MUlERXVOV2d0TkM0MU1UUmhNallnTWpZZ01DQXdJREF0TWk0d01UY2dNUzQxTkd3dExqTXhOQzR5Tm1NdExqVTFMalExTnkweExqRXhOUzQ1TWpZdE1TNDNOaUF4TGpRdExqWTJPUzQwT1RFdE1TNDFOakl0TGpBeE1pMHhMalUyTWkwdU9GWXhORWcwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0F6SURFeUxqVjZUVFF1TlNBMFlTNDFMalVnTUNBd0lEQXRMalV1TlhZNFlTNDFMalVnTUNBd0lEQWdMalV1TldneExqZ3pNM1l6TGpNM01tRXpOaUF6TmlBd0lEQWdNQ0F4TGpZM09DMHhMak16T0d3dU16SXRMakkyTldFeU5pQXlOaUF3SURBZ01TQXlMakl5TlMweExqWTROV3d1TVRJMkxTNHdPRFJJTVRVdU5XRXVOUzQxSURBZ01DQXdJQzQxTFM0MWRpMDRZUzQxTGpVZ01DQXdJREF0TGpVdExqVjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tY2FuZGxlc3RpY2stc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55QXhkak5vTW5ZeE1rZzNkak5JTm5ZdE0wZzBWalJvTWxZeGVrMDFJRFZvTTNZeE1FZzFlazB4TVNBeE5GWTJhREpXTXk0eU5XZ3hWalpvTW5ZNGFDMHlkakl1TnpWb0xURldNVFI2YlRFdE4yZ3pkalpvTFRONklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1jb21tZW50LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeTQxTVRNZ015NDVPVFZoTmk0MUlEWXVOU0F3SURBZ01TQTJMakE1T0NBeE1TNDBNV010TGpVNE9DNHpPVE10TVM0eU1UY3VOVE0yTFRFdU9ESTVMalU0TldFeE15QXhNeUF3SURBZ01TMHhMakkzTGpBeE4wRXlOeUF5TnlBd0lEQWdNQ0F4TUNBeE5rZzBMalZoTGpVdU5TQXdJREFnTVMwdU5TMHVOVll4TUhFd0xTNHlORGN0TGpBd055MHVOVEV6WXkwdU1EQTRMUzQwTVRZdExqQXhOaTB1T0RVM0xqQXhOeTB4TGpJMk9TNHdOUzB1TmpFeUxqRTVNaTB4TGpJMExqVTROUzB4TGpnellUWXVOU0EyTGpVZ01DQXdJREVnTWk0NU1UZ3RNaTR6T1ROdE15NDFOaTQyTVdFMUxqVWdOUzQxSURBZ01DQXdMVFV1TmpRMklESXVNelJqTFM0eU5qWXVNemszTFM0ek56a3VPRFF5TFM0ME1pQXhMak0xTkMwdU1ETXVNell0TGpBeU1pNDNNVGd0TGpBeE5TQXhMakV3T0ZFMUlEa3VOamc1SURVZ01UQjJOV2cxY1M0ek1URXVNREF4TGpVNU15NHdNRGhqTGpNNUxqQXdOeTQzTkRjdU1ERTFJREV1TVRBNExTNHdNVFV1TlRFeUxTNHdOREV1T1RVM0xTNHhOVFFnTVM0ek5UVXRMalF5WVRVdU5TQTFMalVnTUNBd0lEQXRNUzQ1T0RNdE9TNDVOamNpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWNyb3NzaGFpci1hZGQtbGluZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRFd0lEVXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxqVjJNeTQxYURNdU9EYzFZUzQxTGpVZ01DQXdJREVnTUNBeFNERXdMalYyTkM0eU5XRXVOUzQxSURBZ01TQXhMVEVnTUZZeE1DNDFTRFV1TmpJMVlTNDFMalVnTUNBeElERWdNQzB4U0RrdU5WWTJZUzQxTGpVZ01DQXdJREVnTGpVdExqVWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1kZWxldGV7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1pEMGlUVGd1TkRrMklEZ3VPVGsyUVM0MUxqVWdNQ0F3SURFZ09TQTVMalE1TW5ZMFlTNDFMalVnTUNBeElERXRNU0F1TURBNGRpMDBZUzQxTGpVZ01DQXdJREVnTGpRNU5pMHVOVEEwVFRFeUlEa3VOV0V1TlM0MUlEQWdNQ0F3TFRFZ01IWTBZUzQxTGpVZ01DQXdJREFnTVNBd2VpSXZQanh3WVhSb0lHWnBiR3c5SWlNeE16RTNNaklpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVFlnTlZZekxqVkJNaTQxSURJdU5TQXdJREFnTVNBNExqVWdNV2d6UVRJdU5TQXlMalVnTUNBd0lERWdNVFFnTXk0MVZqVm9NaTQ0TXpOaExqVXVOU0F3SURBZ01TQXdJREZJTVRWMk1UQXVNalZqTUNBdU5ERTFMUzR3TmpZdU9EWXpMUzR6SURFdU1qSXhMUzR5TlRjdU16azBMUzQyTnpJdU5qRXlMVEV1TWk0Mk1USm9MVGRqTFM0MU1qZ2dNQzB1T1RRekxTNHlNVGd0TVM0eUxTNDJNVEl0TGpJek5DMHVNelU0TFM0ekxTNDRNRFl0TGpNdE1TNHlNakZXTmtnekxqTXpNMkV1TlM0MUlEQWdNQ0F4SURBdE1YcHRNUzB4TGpWQk1TNDFJREV1TlNBd0lEQWdNU0E0TGpVZ01tZ3pRVEV1TlNBeExqVWdNQ0F3SURFZ01UTWdNeTQxVmpWSU4zcE5OaUF4Tmk0eU5WWTJhRGgyTVRBdU1qVmpNQ0F1TXpNMUxTNHdOVGt1TlRVMExTNHhNemd1TmpjMUxTNHdOVFV1TURnMUxTNHhOQzR4TlRndExqTTJNaTR4TlRob0xUZGpMUzR5TWpJZ01DMHVNekEzTFM0d056TXRMak0yTWkwdU1UVTRMUzR3T0MwdU1USXhMUzR4TXpndExqTTBMUzR4TXpndExqWTNOU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tZGlzam9pbnQtY2hhbm5lbCwuYWctY2hhcnRzLWljb24tZGlzam9pbnQtY2hhbm5lbC1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1Ua3VNREk0SURFM0xqUTJZVEl1TWpVZ01pNHlOU0F3SURBZ01DMDBMakE1TWkweExqZzFiQzA1TGpVeE1TMHlMak0zT0dFeUxqSTFJREl1TWpVZ01DQXhJREF0TGpJeU5TNDVOelJzT1M0ME56VWdNaTR6TmpsaE1pNHlOVEVnTWk0eU5URWdNQ0F3SURBZ05DNHpOVE11T0RnMmJTMHhMalkyTWkweExqazJOV0V4TGpJMUlERXVNalVnTUNBeElERXRMamc0TlNBeUxqTXpPQ0F4TGpJMUlERXVNalVnTUNBd0lERWdMamc0TlMweUxqTXpPRTAwTGpNME15QXhNeTQyTmpsaE1TNHlOU0F4TGpJMUlEQWdNU0F3TFRJdU16TTRMUzQ0T0RVZ01TNHlOU0F4TGpJMUlEQWdNQ0F3SURJdU16TTRMamc0TlUwekxqazNJRGd1TnpZNVlUSXVNalVnTWk0eU5TQXdJREFnTUNBeExqUTFOUzB5TGpFeGJEa3VOVEV4TFRJdU16YzRZVEl1TWpVZ01pNHlOU0F3SURFZ01DMHVNall0TGprMk5VdzFMaklnTlM0Mk9EVmhNaTR5TlNBeUxqSTFJREFnTVNBd0xURXVNak1nTXk0d09EUnRMak0zTXkweUxqVTBOMkV4TGpJMUlERXVNalVnTUNBeElERXRNaTR6TXpndU9EZzFJREV1TWpVZ01TNHlOU0F3SURBZ01TQXlMak16T0MwdU9EZzFiVEV6TGpjMUxUTXVORE00WVRFdU1qVWdNUzR5TlNBd0lERWdNUzB5TGpNek9DNDRPRFVnTVM0eU5TQXhMakkxSURBZ01DQXhJREl1TXpNNExTNDRPRFVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWhvbGxvdy1jYW5kbGVzdGljay1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF2Y0dGamFYUjVQU0l1TVRVaUlHUTlJazAxSURWb00zWXhNRWcxZWlJdlBqeHdZWFJvSUdacGJHdzlJaU14TXpFM01qSWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUY2dNWFl6YURKMk1USklOM1l6U0RaMkxUTklORlkwYURKV01YcE5OU0ExYUROMk1UQklOWHB0TnlBeWFETjJObWd0TTNwdExURWdOMVkyYURKV015NHlOV2d4Vmpab01uWTRhQzB5ZGpJdU56Vm9MVEZXTVRSNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1ob3Jpem9udGFsLWxpbmUsLmFnLWNoYXJ0cy1pY29uLWhvcml6b250YWwtbGluZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTkxqVWdPUzQxYURjdU16QTJZVEl1TWpVZ01pNHlOU0F3SURBZ01TQTBMak00T0NBd1NERTVMalYyTVdndE55NHpNRFpoTWk0eU5TQXlMakkxSURBZ01DQXhMVFF1TXpnNElEQklMalY2YlRrdU5TQXhMamMxWVRFdU1qVWdNUzR5TlNBd0lERWdNQ0F3TFRJdU5TQXhMakkxSURFdU1qVWdNQ0F3SURBZ01DQXlMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtY29sb3J7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVFF1TWpReUlESXVOekl5WXkwdU5qRXlJREF0TVM0eUxqSTBNeTB4TGpZek1pNDJOelZzTFRFdU16UXpJREV1TXpRMFlTNDFMalVnTUNBd0lEQXRMakV4TWk0eE1USk1OQzR3TlNBeE1TNDVOVGxqTFM0eU1EY3VNakEzTFM0ek5pNDBOaTB1TkRRMkxqYzBkaTR3TURGc0xTNDJPU0F5TGpjMk4zWXVNREF5WVM0NE1pNDRNaUF3SURBZ01DQXhMakF5TWlBeExqQXlNV2d1TURBeWJESXVOak0wTFM0NE1qSmpMakk0TFM0d09EVXVOVE0wTFM0eU16Y3VOelF0TGpRME0ydzNMakV3TnkwM0xqRXdPR0V1TlM0MUlEQWdNQ0F3SUM0eE1USXRMakV4TW13eExqTTBNeTB4TGpNME0yRXlMak13T0NBeUxqTXdPQ0F3SURBZ01DMHhMall6TWkwekxqazBUVEUwTGpFeU1pQTNiREV1TURRMExURXVNRFExWVRFdU16QTRJREV1TXpBNElEQWdNU0F3TFRFdU9EUTVMVEV1T0RWTU1USXVNamN4SURVdU1UVjZiUzB5TGpVMU9DMHhMakUwTWkwMkxqZ3dOeUEyTGpnd09XRXVPQzQ0SURBZ01DQXdMUzR4T1RZdU16STFiQzB1TnpVZ01pNDBOamdnTWk0ME55MHVOelE1WVM0NExqZ2dNQ0F3SURBZ0xqTXlOUzB1TVRrMGJEWXVPREE0TFRZdU9ERjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbGluZS1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0TVRjdU16WXlJRFF1T0RjekxUUXVOVGswSURZdU5qVTBMVFF1T0RVdE15NHpNVGN0TkM0eU5URWdOaTQ1TnpjdExqZzFOQzB1TlRKTU55NDJNVElnTmk0M09XdzBMamc1T1NBekxqTTFJRFF1TURJNExUVXVPRE0yZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtd2l0aC1tYXJrZXJzLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRNVGd1TVRrNElEUXVPRGc0TFRNdU5UVTJJRFF1T1RFNFlUSXVNalVnTWk0eU5TQXdJREVnTVMwekxqZzJOaTQzTld3dE1TNDBNekl0TGpsaE1pNHlOQ0F5TGpJMElEQWdNQ0F4TFRJdU1EQTVMalF6Tld3dE15NDRNamdnTmk0ME1qZ3RMamcyTFM0MU1USk1OaTQwTlNBNUxqWXlNMkV5TGpJMUlESXVNalVnTUNBeElERWdNeTQxTVMwdU56WXhiREV1TXpJNUxqZ3pOV0V5TGpJMElESXVNalFnTUNBd0lERWdNaTQxTlRjdExqUTVOMnd6TGpVME1pMDBMamc1T0hwdExUUXVPVFlnTlM0eE5UTmhNUzR5TlNBeExqSTFJREFnTVNBd0xTNDJOQ0F5TGpReE9TQXhMakkxSURFdU1qVWdNQ0F3SURBZ0xqWTBMVEl1TkRFNVRUa3VNU0E0TGpNeU1YRXVNRFkyTFM0eE9USXVNRFkzTFM0ME1EUmhNUzR5TlNBeExqSTFJREFnTVNBd0xTNHdOamN1TkRBMElpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1sb2NrLC5hZy1jaGFydHMtaWNvbi1sb2NrZWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEF1TWpBM0lETXVOelkwWVRJdU9EazBJREl1T0RrMElEQWdNQ0F3TFRJdU9EazFJREl1T0RrMFZqbG9OUzQzT0RsV05pNDJOVGhoTWk0NE9UUWdNaTQ0T1RRZ01DQXdJREF0TWk0NE9UVXRNaTQ0T1RSTk1UUXVNU0E1VmpZdU5qVTRZVE11T0RrMElETXVPRGswSURBZ01TQXdMVGN1TnpnNUlEQjJNaTR6TkRsQk1pNDFJREl1TlNBd0lEQWdNQ0EwSURFeExqVjJNMEV5TGpVZ01pNDFJREFnTUNBd0lEWXVOU0F4TjJnNFlUSXVOU0F5TGpVZ01DQXdJREFnTWk0MUxUSXVOWFl0TTBFeUxqVWdNaTQxSURBZ01DQXdJREUwTGpVZ09YcE5OaTQxSURFd1FURXVOU0F4TGpVZ01DQXdJREFnTlNBeE1TNDFkak5CTVM0MUlERXVOU0F3SURBZ01DQTJMalVnTVRab09HRXhMalVnTVM0MUlEQWdNQ0F3SURFdU5TMHhMalYyTFROaE1TNDFJREV1TlNBd0lEQWdNQzB4TGpVdE1TNDFlaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tbm90ZS1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTXlBMExqVkJNUzQxSURFdU5TQXdJREFnTVNBMExqVWdNMmd4TVVFeExqVWdNUzQxSURBZ01DQXhJREUzSURRdU5YWTRZVEV1TlNBeExqVWdNQ0F3SURFdE1TNDFJREV1TldndE15NHlNV3d0TVM0ME5qa2dNaTQxTjJFeElERWdNQ0F3SURFdE1TNDJPREl1TURnMVREY3VNalF6SURFMFNEUXVOVUV4TGpVZ01TNDFJREFnTUNBeElETWdNVEl1TlhwTk5DNDFJRFJoTGpVdU5TQXdJREFnTUMwdU5TNDFkamhoTGpVdU5TQXdJREFnTUNBdU5TNDFhRE11TWpVM2JESXVNVGsySURNdU1EYzBUREV4TGpjeElERXphRE11TnpsaExqVXVOU0F3SURBZ01DQXVOUzB1TlhZdE9HRXVOUzQxSURBZ01DQXdMUzQxTFM0MWVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OaTQxSURZdU5VRXVOUzQxSURBZ01DQXhJRGNnTm1nMllTNDFMalVnTUNBd0lERWdNQ0F4U0RkaExqVXVOU0F3SURBZ01TMHVOUzB1TlUwMkxqVWdPUzQxUVM0MUxqVWdNQ0F3SURFZ055QTVhRFpoTGpVdU5TQXdJREFnTVNBd0lERklOMkV1TlM0MUlEQWdNQ0F4TFM0MUxTNDFJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tb2hsYy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1pEMGlUVEV6SURFeGFDMHpkaTB4YUROV00yZ3hkakpvTkhZeGFDMDBkakV4YUMweGVrMDJJREUzZGkweWFETjJMVEZJTmxZMFNEVjJNVWd5ZGpGb00zWXhNWG9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tZmlsbC1jb2xvcnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE9DNHdOekVnTkM0d05pMHVPVEkwTFM0NU1qUXVOekEzTFM0M01EY2dOeTR5T0RnZ055NHlPRGd0TkM0NU5TQTBMamsxWVRNdU5TQXpMalVnTUNBd0lERXROQzQ1TlNBd2JDMHhMalF4TkMweExqUXhOR0V6TGpVZ015NDFJREFnTUNBeElEQXROQzQ1TlhwdExqY3dOeTQzTURoTU5DNDFNellnT1M0d01XRXlMalVnTWk0MUlEQWdNQ0F3SURBZ015NDFNelpNTlM0NU5TQXhNeTQ1Tm1FeUxqVWdNaTQxSURBZ01DQXdJRE11TlRNMUlEQnNOQzR5TkRNdE5DNHlORE42YlRZdU9TQTNMakl3TWkwdU16UTFMak0yTXkwdU16UTBMUzR6TmpOaExqVXVOU0F3SURBZ01TQXVOamc0SURCdExTNHpORFVnTVM0d09HRTRJRGdnTUNBd0lEQXRMakk0TGpNeU15QTBMak1nTkM0eklEQWdNQ0F3TFM0ME1Ea3VOVGd5WXkwdU1URXpMakl3TVMwdU1UUTBMak15TmkwdU1UUTBMak0zT0dFdU9ETXpMamd6TXlBd0lEQWdNQ0F4TGpZMk55QXdZekF0TGpBMU1pMHVNRE14TFM0eE56Y3RMakUwTkMwdU16YzRZVFF1TXlBMExqTWdNQ0F3SURBdExqUXhMUzQxT0RJZ09DQTRJREFnTUNBd0xTNHlPQzB1TXpJeWJTMHVNelEwTFRFdU1EZ3VNelEwTGpNMk15NHpORFF0TGpNMk15NHdNREl1TURBeUxqQXdOQzR3TURRdU1ERXpMakF4TW1FMklEWWdNQ0F3SURFZ0xqSXdOaTR5TURoakxqRXpNUzR4TXpZdU16QTRMak15Tnk0ME9EVXVOVFExTGpFM05pNHlNVFV1TXpZekxqUTJOeTQxTURjdU56STBMakV6Tnk0eU5ETXVNamN6TGpVMU15NHlOek11T0RZNFlURXVPRE16SURFdU9ETXpJREFnTVNBeExUTXVOalkzSURCak1DMHVNekUxTGpFek5pMHVOakkxTGpJM015MHVPRFk0TGpFME5DMHVNalUzTGpNekxTNDFNRGt1TlRBM0xTNDNNalJoT1NBNUlEQWdNQ0F4SUM0Mk5EVXRMamN3T0d3dU1EUTJMUzR3TkRVdU1ERXpMUzR3TVRJdU1EQTBMUzR3TURSNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1wYW4tZW5key0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGliVFl1TmpRMklERXpMamd4TXkwdU16VXpMak0xTkM0M01EY3VOekEzTGpNMU5DMHVNelUwZWsweE1TNHhOallnTVRCc0xqTTFOQzR6TlRRdU16VTBMUzR6TlRRdExqTTFOQzB1TXpVMGVrMDNMak0xTlNBMUxqUTRJRGNnTlM0eE1qWnNMUzQzTURjdU56QTNMak0xTXk0ek5UUjZiVEFnT1M0d05DQTBMakUyTmkwMExqRTJOaTB1TnpBM0xTNDNNRGd0TkM0eE5qY2dOQzR4TmpkNmJUUXVNVFkyTFRRdU9EYzBURGN1TXpVMElEVXVORGhzTFM0M01EZ3VOekEzSURRdU1UWTNJRFF1TVRZM2VrMHhNeTR3T0RNZ05YWXhNR2d4VmpWNklpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXBhbi1sZWZ0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRJdU56a2dOUzQ0TXpNZ09DNDJNalVnTVRCc05DNHhOallnTkM0eE5qY3RMamN3Tnk0M01EZE1OeTR5TVNBeE1HdzBMamczTXkwMExqZzNOSG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1yaWdodHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55NHlNU0F4TkM0eE5qY2dNVEV1TXpjMklERXdJRGN1TWpFZ05TNDRNek5zTGpjd055MHVOekEzVERFeUxqYzVJREV3YkMwMExqZzNNeUEwTGpnM05Ib2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFuLXN0YXJ0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVFlnTlhZeE1HZ3hWalY2VFRrdU5qSTBJREV3YkRRdU1UWTJMVFF1TVRZM0xTNDNNRGN0TGpjd04wdzRMakl4SURFd2JEUXVPRGMwSURRdU9EYzBMamN3TnkwdU56QTNlaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFyYWxsZWwtY2hhbm5lbCwuYWctY2hhcnRzLWljb24tcGFyYWxsZWwtY2hhbm5lbC1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UY3VOeklnTlM0ek16RkJNaTR5TlNBeUxqSTFJREFnTVNBd0lERTBMamN3TlNBekxqWnNMVGt1TkRrZ05DNDFOakpoTWk0eU5TQXlMakkxSURBZ01TQXdJQzR5TURrZ01TNHdNV3c1TGpZMk1pMDBMalkwTm1FeUxqSTFJREl1TWpVZ01DQXdJREFnTWk0Mk16UXVPREExYlM0ek56TXRNaTQxTkRkaE1TNHlOU0F4TGpJMUlEQWdNU0F4TFRJdU16TTRMamc0TlNBeExqSTFJREV1TWpVZ01DQXdJREVnTWk0ek16Z3RMamc0TlUwMExqTTBNeUE0TGpZM1lURXVNalVnTVM0eU5TQXdJREVnTVMweUxqTXpPQzQ0T0RVZ01TNHlOU0F4TGpJMUlEQWdNQ0F4SURJdU16TTRMUzQ0T0RWTk5TNHpNRGNnTVRZdU56STRZVEl1TWpVZ01pNHlOU0F3SURFZ01TMHVOVEkxTFM0NE5UaHNPUzQ1TWpNdE5DNDNOMkV5TGpJMUlESXVNalVnTUNBeElERWdMak00TVM0NU1qWjZiUzB1T1RZMExqSTNOR0V4TGpJMUlERXVNalVnTUNBeElERXRNaTR6TXpndU9EZzFJREV1TWpVZ01TNHlOU0F3SURBZ01TQXlMak16T0MwdU9EZzFiVEV6TGpBeU15MDFMakV3Tm1FeExqSTFJREV1TWpVZ01DQXhJREF0TGpnNE5TMHlMak16T1NBeExqSTFJREV1TWpVZ01DQXdJREFnTGpnNE5TQXlMak16T1NJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXByaWNlLWxhYmVsLWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OQzQxSUROQk1TNDFJREV1TlNBd0lEQWdNQ0F6SURRdU5WWXhNMkV4TGpVZ01TNDFJREFnTUNBd0lERXVOU0F4TGpWb0xqZ3pNM1l1TURVM1l5NHlOREl0TGpJNU9TNDFPVGN0TGpVd015QXhMUzQxTkRoV01UTXVOVWcwTGpWQkxqVXVOU0F3SURBZ01TQTBJREV6VmpRdU5XRXVOUzQxSURBZ01DQXhJQzQxTFM0MWFERXhZUzQxTGpVZ01DQXdJREVnTGpVdU5YWTRZUzQxTGpVZ01DQXdJREV0TGpVdU5XZ3ROQzQ0TVRoc0xTNHhNall1TURnMFlUSTJJREkySURBZ01DQXdMVEl1TWpJMUlERXVOamcxYkMwdU16SXVNalkxTFM0d05qZ3VNRFUyWVRFdU5TQXhMalVnTUNBd0lERXRNaTQyTURrZ01TNHpOVFJqTGpBek15NDNOak11T1RBMUlERXVNak00SURFdU5UWXVOelUyTGpZME5pMHVORGMwSURFdU1qRXRMamswTXlBeExqYzJNUzB4TGpSc0xqTXhNeTB1TWpaQk1qWWdNallnTUNBd0lERWdNVEF1T1RnMklERTBTREUxTGpWaE1TNDFJREV1TlNBd0lEQWdNQ0F4TGpVdE1TNDFkaTA0UVRFdU5TQXhMalVnTUNBd0lEQWdNVFV1TlNBemVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOT0M0M01UWWdNVFF1T0RFMVlUSXVNalVnTWk0eU5TQXdJREVnTVMwMExqSXhJREV1TlRreklESXVNalVnTWk0eU5TQXdJREFnTVNBMExqSXhMVEV1TlRremJTMHhMalkyTWlBeExqazJObUV4TGpJMUlERXVNalVnTUNBeElEQXRMamc0TlMweUxqTXpPU0F4TGpJMUlERXVNalVnTUNBd0lEQWdMamc0TlNBeUxqTXpPU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcmVzZXR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEl1TURRZ05DNDBORFZoTlM0NE1TQTFMamd4SURBZ01DQXdMVGN1TWpVM0lESXVORFV6TGpVdU5TQXdJREFnTVMwdU9EWTFMUzQxTURKQk5pNDRNU0EyTGpneElEQWdNU0F4SURNZ09TNDRNVE5oTGpVdU5TQXdJREFnTVNBeElEQWdOUzQ0TVNBMUxqZ3hJREFnTVNBd0lEZ3VNRFF0TlM0ek5qZ2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp4d1lYUm9JR1pwYkd3OUlpTXdNREFpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVFF1TWpnNUlETXVNREF5WVM0MUxqVWdNQ0F3SURFZ0xqVXVOWFl5TGpZMU5XZ3lMalkxTldFdU5TNDFJREFnTUNBeElEQWdNVWcwTGpJNVlTNDFMalVnTUNBd0lERXRMalV0TGpWV015NDFNREpoTGpVdU5TQXdJREFnTVNBdU5TMHVOU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tc3RlcC1saW5lLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFNE1VUXhSaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OaUEwYURWMk9HZ3pWamhvTlhZeGFDMDBkalJvTFRWV05VZzNkakV3U0RKMkxURm9OSG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXRleHQtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDBJRFJJTVRaV04wZ3hOVlkxU0RFd0xqVldNVFZJTVRSV01UWklObFl4TlVnNUxqVldOVWcxVmpkSU5GWTBXaUlnWm1sc2JEMGlZbXhoWTJzaUx6NEtQQzl6ZG1jK0NnPT0pfS5hZy1jaGFydHMtaWNvbi10cmVuZC1saW5lLC5hZy1jaGFydHMtaWNvbi10cmVuZC1saW5lLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTlM0ek1UUWdNVEF1T1RNNFlUSXVNalVnTWk0eU5TQXdJREVnTVNBdU1ERXRNV2c1TGpNMU1tRXlMakkxSURJdU1qVWdNQ0F4SURFZ0xqQXhJREY2YlMweUxqRTRPUzQzTWpsaE1TNHlOU0F4TGpJMUlEQWdNU0F3SURBdE1pNDFJREV1TWpVZ01TNHlOU0F3SURBZ01DQXdJREl1TlcweE15NDNOU0F3WVRFdU1qVWdNUzR5TlNBd0lERWdNQ0F3TFRJdU5TQXhMakkxSURFdU1qVWdNQ0F3SURBZ01DQXlMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXVubG9jaywuYWctY2hhcnRzLWljb24tdW5sb2NrZWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEF1TmpVeElETXVOV0V5TGpnNU5DQXlMamc1TkNBd0lEQWdNQzB5TGpnNU5DQXlMamc1TkZZNVNERTBMalZoTWk0MUlESXVOU0F3SURBZ01TQXlMalVnTWk0MWRqTmhNaTQxSURJdU5TQXdJREFnTVMweUxqVWdNaTQxYUMwNFFUSXVOU0F5TGpVZ01DQXdJREVnTkNBeE5DNDFkaTB6UVRJdU5TQXlMalVnTUNBd0lERWdOaTQxSURsb0xqSTFOMVkyTGpNNU5HRXpMamc1TkNBekxqZzVOQ0F3SURFZ01TQTNMamM0T1NBd0lDNDFMalVnTUNBd0lERXRNU0F3UVRJdU9EazBJREl1T0RrMElEQWdNQ0F3SURFd0xqWTFJRE11TlUwMkxqVWdNVEJCTVM0MUlERXVOU0F3SURBZ01DQTFJREV4TGpWMk0wRXhMalVnTVM0MUlEQWdNQ0F3SURZdU5TQXhObWc0WVRFdU5TQXhMalVnTUNBd0lEQWdNUzQxTFRFdU5YWXRNMkV4TGpVZ01TNDFJREFnTUNBd0xURXVOUzB4TGpWNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi12ZXJ0aWNhbC1saW5lLC5hZy1jaGFydHMtaWNvbi12ZXJ0aWNhbC1saW5lLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRBdU5TQTNMamd3Tm1FeUxqSTFJREl1TWpVZ01DQXdJREVnTUNBMExqTTRPRll4T1M0MWFDMHhkaTAzTGpNd05tRXlMakkxSURJdU1qVWdNQ0F3SURFZ01DMDBMak00T0ZZdU5XZ3hlbTB0TGpVdU9UUTBZVEV1TWpVZ01TNHlOU0F3SURFZ01TQXdJREl1TlNBeExqSTFJREV1TWpVZ01DQXdJREVnTUMweUxqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tem9vbS1pbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRFd0lEVXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxqVjJNeTQxYURNdU9EYzFZUzQxTGpVZ01DQXdJREVnTUNBeFNERXdMalYyTkM0eU5XRXVOUzQxSURBZ01TQXhMVEVnTUZZeE1DNDFTRFV1TmpJMVlTNDFMalVnTUNBeElERWdNQzB4U0RrdU5WWTJZUzQxTGpVZ01DQXdJREVnTGpVdExqVWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLW91dHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5TNDFJREV3WVM0MUxqVWdNQ0F3SURFZ0xqVXRMalZvT0dFdU5TNDFJREFnTUNBeElEQWdNVWcyWVM0MUxqVWdNQ0F3SURFdExqVXRMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWhpZ2gtbG93LXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeUEwYURKMk1USklORlkwYUROTk5TQTFhRE4yTVRCSU5YcE5NVEVnTVRSV05tZzFkamhvTFRWdE1TMDNhRE4yTm1ndE0zb2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24taGxjLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRNVGd1TVRZeklERXVPRE0zTFRVdU16TTBJREV4TGpZeU1VdzJMamsxTnlBNExqRXliQzAwTGpFNU9TQTVMall5TWkwdU9URTJMUzQwSURRdU56VTJMVEV3TGpsTU1USXVORGtnTVRFdU9DQXhOeTR5TlRRZ01TNDBNbm9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqeHdZWFJvSUdacGJHdzlJaU13TURBaUlHWnBiR3d0YjNCaFkybDBlVDBpTGpRaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRVdU9ESTFJREl1TnpBMExqVTFJREV6TGpjNE5Xd3VPVEF5TGpReklEUXVOekkwTFRrdU9URTVJRFl1TURNMElEVXVNREk1SURNdU1qVTFMVGd1TVRRdExqa3lPQzB1TXpjdE1pNDNORFVnTmk0NE5ucHROeTQ0TlRJZ01UUXVOak0ySURVdU56Z3RNVE11TVRNNUxTNDVNVFV0TGpRd01pMDFMakl4T1NBeE1TNDROaTAyTGpBd05TMDFMalV3TkMwekxqSTNPQ0EzTGpZME9DNDVNaTR6T1RRZ01pNDNNakl0Tmk0ek5USjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1pbi1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDRMamMxSURRdU5XRXVOelV1TnpVZ01DQXdJREF0TVM0MUlEQjJNaTQzTlVnMExqVmhMamMxTGpjMUlEQWdNQ0F3SURBZ01TNDFhREl1TnpWMk1pNDNOV0V1TnpVdU56VWdNQ0F3SURBZ01TNDFJREJXT0M0M05XZ3lMamMxWVM0M05TNDNOU0F3SURBZ01DQXdMVEV1TlVnNExqYzFWalF1TlZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLW91dC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHpMamMxSURoaExqYzFMamMxSURBZ01DQXhJQzQzTlMwdU56Vm9OMkV1TnpVdU56VWdNQ0F3SURFZ01DQXhMalZvTFRkQkxqYzFMamMxSURBZ01DQXhJRE11TnpVZ09Gb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1pbi1hbHQsLmFnLWNoYXJ0cy1pY29uLXpvb20taW4tYWx0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMWHB2YjIwdGFXNGlQanhqYVhKamJHVWdZM2c5SWpFeElpQmplVDBpTVRFaUlISTlJamdpTHo0OGJHbHVaU0I0TVQwaU1qRWlJSGd5UFNJeE5pNDJOU0lnZVRFOUlqSXhJaUI1TWowaU1UWXVOalVpTHo0OGJHbHVaU0I0TVQwaU1URWlJSGd5UFNJeE1TSWdlVEU5SWpnaUlIa3lQU0l4TkNJdlBqeHNhVzVsSUhneFBTSTRJaUI0TWowaU1UUWlJSGt4UFNJeE1TSWdlVEk5SWpFeElpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0LWFsdCwuYWctY2hhcnRzLWljb24tem9vbS1vdXQtYWx0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMWHB2YjIwdGIzVjBJajQ4WTJseVkyeGxJR040UFNJeE1TSWdZM2s5SWpFeElpQnlQU0k0SWk4K1BHeHBibVVnZURFOUlqSXhJaUI0TWowaU1UWXVOalVpSUhreFBTSXlNU0lnZVRJOUlqRTJMalkxSWk4K1BHeHBibVVnZURFOUlqZ2lJSGd5UFNJeE5DSWdlVEU5SWpFeElpQjVNajBpTVRFaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXJlc2V0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMExqUXhNaUEwTGpBMU9DQXlMamMxSURJdU16azJWall1TnpWb0xqYzBOR0V1TnpZdU56WWdNQ0F3SURBZ0xqQXhNaUF3YURNdU5UazRURFV1TkRjNElEVXVNVEkxWVRRdU1USTFJRFF1TVRJMUlEQWdNQ0F4SURJdU5USXpMUzQ0TnpVZ015NDNOU0F6TGpjMUlEQWdNU0F4TFRNdU1URTVJRFV1T0RNekxqYzFMamMxSURBZ01DQXdMVEV1TWpRM0xqZ3pORUUxTGpJMUlEVXVNalVnTUNBeElEQWdPQ0F5TGpjMWFDMHVNREF6WVRVdU5qSTFJRFV1TmpJMUlEQWdNQ0F3TFRNdU5UZzFJREV1TXpBNFdpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFuLWxlZnQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TUM0d015QTBMalEzWVM0M05TNDNOU0F3SURBZ01TQXdJREV1TURaTU55NDFOaUE0YkRJdU5EY2dNaTQwTjJFdU56VXVOelVnTUNBeElERXRNUzR3TmlBeExqQTJiQzB6TFROaExqYzFMamMxSURBZ01DQXhJREF0TVM0d05td3pMVE5oTGpjMUxqYzFJREFnTUNBeElERXVNRFlnTUZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1wYW4tcmlnaHQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAxTGprM0lERXhMalV6WVM0M05TNDNOU0F3SURBZ01TQXdMVEV1TURaTU9DNDBOQ0E0SURVdU9UY2dOUzQxTTJFdU56VXVOelVnTUNBd0lERWdNUzR3TmkweExqQTJiRE1nTTJFdU56VXVOelVnTUNBd0lERWdNQ0F4TGpBMmJDMHpJRE5oTGpjMUxqYzFJREFnTUNBeExURXVNRFlnTUZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1wYW4tc3RhcnQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExXTm9aWFp5YjI0dFptbHljM1FpUGp4d1lYUm9JR1E5SW0weE55QXhPQzAyTFRZZ05pMDJJaTgrUEhCaGRHZ2daRDBpVFRjZ05uWXhNaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFuLWVuZC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFdOb1pYWnliMjR0YkdGemRDSStQSEJoZEdnZ1pEMGliVGNnTVRnZ05pMDJMVFl0TmlJdlBqeHdZWFJvSUdROUlrMHhOeUEyZGpFeUlpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXRyZW5kLWxpbmUtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHTnBjbU5zWlNCamVEMGlNaTQxSWlCamVUMGlPQ0lnY2owaU1TNDNOU0lnYzNSeWIydGxQU0lqTURBd0lpQnpkSEp2YTJVdGQybGtkR2c5SWpFdU5TSXZQanhqYVhKamJHVWdZM2c5SWpFekxqVWlJR041UFNJNElpQnlQU0l4TGpjMUlpQnpkSEp2YTJVOUlpTXdNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNUzQxSWk4K1BIQmhkR2dnYzNSeWIydGxQU0lqTURBd0lpQnpkSEp2YTJVdGQybGtkR2c5SWpFdU5TSWdaRDBpVFRRZ09HZzRJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1ob3Jpem9udGFsLWxpbmUtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TUM0ek9EWWdPQzQzTldFeUxqVXdNU0F5TGpVd01TQXdJREFnTVMwMExqYzNNaUF3U0M0M05XRXVOelV1TnpVZ01DQXdJREVnTUMweExqVm9OQzQ0TmpSaE1pNDFNREVnTWk0MU1ERWdNQ0F3SURFZ05DNDNOeklnTUdnMExqZzJOR0V1TnpVdU56VWdNQ0F3SURFZ01DQXhMalZvTFRRdU9EWTBXazA1SURoaE1TQXhJREFnTVNBeExUSWdNQ0F4SURFZ01DQXdJREVnTWlBd1dpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdmVydGljYWwtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDRMamMxSURVdU5qRTBZVEl1TlRBeElESXVOVEF4SURBZ01DQXhJREFnTkM0M056SjJOQzQ0TmpSaExqYzFMamMxSURBZ01DQXhMVEV1TlNBd2RpMDBMamcyTkdFeUxqVXdNU0F5TGpVd01TQXdJREFnTVNBd0xUUXVOemN5Vmk0M05XRXVOelV1TnpVZ01DQXdJREVnTVM0MUlEQjJOQzQ0TmpSYVRUZ2dOMkV4SURFZ01DQXhJREVnTUNBeUlERWdNU0F3SURBZ01TQXdMVEphSWlCbWFXeHNQU0lqTURBd0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXBhcmFsbGVsLWNoYW5uZWwtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UY2lJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TkM0ME1qUWdOQzQ1TW1FeUxqVWdNaTQxSURBZ01TQXdMVE11TXpjM0xUSXVNVFJzTFRZdU5qTWdNaTQ1WVRJdU5UQXhJREl1TlRBeElEQWdNU0F3SUM0Mk1EY2dNUzR6TnpKc05pNDFPRFV0TWk0NE9HRXlMalV3TVNBeUxqVXdNU0F3SURBZ01DQXlMamd4TlM0M05EaGFiUzR3TlMweUxqWTVNMkV4SURFZ01DQXhJREV0TVM0NE55NDNNRGdnTVNBeElEQWdNQ0F4SURFdU9EY3RMamN3T0ZwdExURXhJRFF1TnpWaE1TQXhJREFnTVNBeExURXVPRGN1TnpBNElERWdNU0F3SURBZ01TQXhMamczTFM0M01EaGFiVEV1TlRVZ05pNHdOelZoTWk0MU1ERWdNaTQxTURFZ01DQXhJREV0TGpZd055MHhMak0zTW13MkxqWXpMVEl1T1dFeUxqVXdNU0F5TGpVd01TQXdJREVnTVNBdU5UWXlJREV1TXpreGJDMDJMalU0TlNBeUxqZzRXbTB0TVM0MU5TMHVNRGMxWVRFZ01TQXdJREVnTVMweExqZzNMamN3T0NBeElERWdNQ0F3SURFZ01TNDROeTB1TnpBNFdtMHhNQzQwTWkwekxqUTJZVEVnTVNBd0lERWdNQzB1TnpBNUxURXVPRGNnTVNBeElEQWdNQ0F3SUM0M01EZ2dNUzQ0TjFvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGNpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE5DNDBNalFnTkM0NU1tRXlMalVnTWk0MUlEQWdNU0F3TFRNdU16Z3pMVEl1TkRVelREUXVOamtnTkM0d05UVmhNaTQxSURJdU5TQXdJREVnTUNBdU16UTBJREV1TkRac05pNHpPVEl0TVM0MU9UaGhNaTQxTURFZ01pNDFNREVnTUNBd0lEQWdNeUF4TGpBd00xcHRMakExTFRJdU5qa3pZVEVnTVNBd0lERWdNUzB4TGpnM0xqY3dPQ0F4SURFZ01DQXdJREVnTVM0NE55MHVOekE0V20wdE1URWdNaTQzTldFeElERWdNQ0F4SURFdE1TNDROeTQzTURnZ01TQXhJREFnTUNBeElERXVPRGN0TGpjd09GcHRNUzQxTmlBMUxqUXlZVEl1TlNBeUxqVWdNQ0F4SURBdExqTTBOU0F4TGpRMk1XdzJMak0xTWlBeExqVTRPR0V5TGpVZ01pNDFJREFnTVNBd0lDNHpPRFF0TVM0ME5Xd3ROaTR6T1RJdE1TNDFPVGhhYlMweExqVTJMalV6T0dFeElERWdNQ0F4SURBdE1TNDROeTB1TnpBNElERWdNU0F3SURBZ01DQXhMamczTGpjd09GcHRNVEF1TkRJZ01TNDBOakZoTVNBeElEQWdNU0F4TFM0M01Ea2dNUzQ0TnlBeElERWdNQ0F3SURFZ0xqY3dPQzB4TGpnM1dpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tbGluZS1jb2xvci1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEdjZ1kyeHBjQzF3WVhSb1BTSjFjbXdvSTJFcElqNDhjR0YwYUNCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRFeUxqYzRPQzQxT0ROaE1pNDJNeUF5TGpZeklEQWdNQ0F3TFRFdU9EWXVOemRNT1M0MU5EUWdNaTQzTXpoaExqYzFOeTQzTlRjZ01DQXdJREF0TGpFMExqRTBUREl1TURNeUlERXdMakkxZGk0d01ERmpMUzR5TkRJdU1qUXhMUzQwTWk0MU16Z3RMalV5TGpnMk5Hd3RMakF3TWk0d01ESXRMamc0SURJdU9UQXlMUzR3TURFdU1EQXpZVEV1TURneklERXVNRGd6SURBZ01DQXdJREV1TXpVZ01TNHpORGRvTGpBd01Xd3lMamt3TWkwdU9EaG9MakF3TVdNdU16STJMUzR4TGpZeU15MHVNamMzTGpnMk5TMHVOVEU0ZGkwdU1EQXhiRGN1TXpjMUxUY3VNemMyWVM0M05qTXVOell6SURBZ01DQXdJQzR4TXprdExqRXpPV3d4TGpNNE5DMHhMak00TkVFeUxqWXpJREl1TmpNZ01DQXdJREFnTVRJdU56ZzRMalU0TTFwdExTNHhNallnTkM0ek5USXVPVEkwTFM0NU1qUmhNUzR4TXlBeExqRXpJREFnTUNBd0xURXVOVGszTFRFdU5UazNiQzB1T1RJMExqa3lOQ0F4TGpVNU55QXhMalU1TjFwdExUSXVOalUzTFM0MU16WXROaTQ1TVRNZ05pNDVNVFJJTXk0d09XRXVOVGd6TGpVNE15QXdJREFnTUMwdU1UUTJMakkwTW13dExqWTFNeUF5TGpFMU15QXlMakUxTlMwdU5qVTBZUzQxT0RNdU5UZ3pJREFnTUNBd0lDNHlOREV0TGpFME5HdzJMamt4TkMwMkxqa3hOQzB4TGpVNU55MHhMalU1TjFvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDJjK1BHUmxabk0rUEdOc2FYQlFZWFJvSUdsa1BTSmhJajQ4Y0dGMGFDQm1hV3hzUFNJalptWm1JaUJrUFNKTk1DQXdhREUyZGpFMlNEQjZJaTgrUEM5amJHbHdVR0YwYUQ0OEwyUmxabk0rUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1kZWxldGUtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAyTGpBNE15QXlMalkyTjJNd0xTNHdPUzR3TlRNdExqSTBNaTR4T1RjdExqTTROeTR4TkRVdExqRTBOQzR5T1RjdExqRTVOeTR6T0RjdExqRTVOMmd5TGpZMk4yTXVNRGc1SURBZ0xqSTBNUzR3TlRNdU16ZzJMakU1Tnk0eE5EVXVNVFExTGpFNU55NHlPVGN1TVRrM0xqTTROM1l1TlRnelNEWXVNRGcwZGkwdU5UZ3pXazAxTGpNeklEUXVOelZJTVRFdU9URTNkamd1TlRnell6QWdMakE1TFM0d05USXVNalF5TFM0eE9UY3VNemczTFM0eE5EVXVNVFEwTFM0eU9UY3VNVGszTFM0ek9EWXVNVGszU0RRdU5qWTNZeTB1TURrZ01DMHVNalF5TFM0d05UTXRMak00TnkwdU1UazNMUzR4TkRRdExqRTBOUzB1TVRrM0xTNHlPVGN0TGpFNU55MHVNemczVmpRdU56VklOUzR6TTFwdExTNDNORFV0TVM0MWRpMHVOVGd6WXpBdExqVTNPQzR5T0MweExqQTVNaTQyTXpZdE1TNDBORGN1TXpVMUxTNHpOVFl1T0RjdExqWXpOeUF4TGpRME55MHVOak0zYURJdU5qWTNZeTQxTnpjZ01DQXhMakE1TVM0eU9ERWdNUzQwTkRjdU5qTTNMak0xTlM0ek5UVXVOak0yTGpnM0xqWXpOaUF4TGpRME4zWXVOVGd6U0RFMFlTNDNOUzQzTlNBd0lEQWdNU0F3SURFdU5XZ3RMalU0TTNZNExqVTRNMk13SUM0MU56Z3RMakk0TVNBeExqQTVNaTB1TmpNMklERXVORFEzTFM0ek5UWXVNelUyTFM0NE55NDJNemN0TVM0ME5EY3VOak0zU0RRdU5qWTNZeTB1TlRjM0lEQXRNUzR3T1RJdExqSTRNUzB4TGpRME55MHVOak0zTFM0ek5UVXRMak0xTlMwdU5qTTNMUzQ0TnkwdU5qTTNMVEV1TkRRM1ZqUXVOelZJTW1FdU56VXVOelVnTUNBd0lERWdNQzB4TGpWb01pNDFPRE5hYlRJdU1EZ3pJRE11TXpNellTNDNOUzQzTlNBd0lEQWdNU0F1TnpVdU56VjJOR0V1TnpVdU56VWdNQ0F4SURFdE1TNDFJREIyTFRSaExqYzFMamMxSURBZ01DQXhJQzQzTlMwdU56VmFiVE11TkRFM0xqYzFZUzQzTlM0M05TQXdJREFnTUMweExqVWdNSFkwWVM0M05TNDNOU0F3SURFZ01DQXhMalVnTUhZdE5Gb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbG9jay1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDJMakUzTXlBeUxqZzBZVEl1TlRneklESXVOVGd6SURBZ01DQXhJRFF1TkRFZ01TNDRNamQyTVM0NU1UWklOUzQwTVRaV05DNDJOamRqTUMwdU5qZzFMakkzTXkweExqTTBNeTQzTlRjdE1TNDRNamRhVFRNdU9URTNJRFl1TlRnelZqUXVOalkzWVRRdU1EZ3pJRFF1TURneklEQWdNQ0F4SURndU1UWTJJREIyTVM0NU1UWm9MalU0TkdNeExqRTFJREFnTWk0d09ETXVPVE16SURJdU1EZ3pJREl1TURnMGRqUXVOalkyWXpBZ01TNHhOUzB1T1RNeklESXVNRGcwTFRJdU1EZ3pJREl1TURnMFNETXVNek16WVRJdU1EZ3pJREl1TURneklEQWdNQ0F4TFRJdU1EZ3pMVEl1TURnMFZqZ3VOalkzWXpBdE1TNHhOVEV1T1RNekxUSXVNRGcwSURJdU1EZ3pMVEl1TURnMGFDNDFPRE5hYlRjdU5ERTJJREV1TldndE9HRXVOVGd6TGpVNE15QXdJREFnTUMwdU5UZ3pMalU0TkhZMExqWTJObU13SUM0ek1qSXVNall4TGpVNE5DNDFPRE11TlRnMGFEa3VNek0wWVM0MU9ETXVOVGd6SURBZ01DQXdJQzQxT0RNdExqVTRORlk0TGpZMk4yRXVOVGd6TGpVNE15QXdJREFnTUMwdU5UZ3pMUzQxT0RSb0xURXVNek0wV2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi11bmxvY2stbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UY2lJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAyTGpreU15QXlMamcwWVRJdU5UZ3pJREl1TlRneklEQWdNQ0F4SURNdU5qVXpJREFnTXlBeklEQWdNQ0F4SUM0MU55NDNPVGhqTGpFek5DNHlOemd1TVRjdU5EYzBMakUzTGpVME5XRXVOelV1TnpVZ01DQXdJREFnTVM0MUlEQmpNQzB1TXpneExTNHhNekl0TGpnd09TMHVNekl0TVM0eE9UaGhOQzQxTURFZ05DNDFNREVnTUNBd0lEQXRMamcxT1MweExqSXdOaUEwTGpBNE15QTBMakE0TXlBd0lEQWdNQzAyTGprM0lESXVPRGc0ZGpFdU9URTJhQzB1TlRnMFF6SXVPVE16SURZdU5UZ3pJRElnTnk0MU1UWWdNaUE0TGpZMk4zWTBMalkyTm1Nd0lERXVNVFV1T1RNeklESXVNRGcwSURJdU1EZ3pJREl1TURnMGFEa3VNek0wWXpFdU1UVWdNQ0F5TGpBNE15MHVPVE16SURJdU1EZ3pMVEl1TURnMFZqZ3VOalkzWXpBdE1TNHhOVEV0TGprek15MHlMakE0TkMweUxqQTRNeTB5TGpBNE5HZ3ROeTR5TlZZMExqWTJOMk13TFM0Mk9EVXVNamN5TFRFdU16UXpMamMxTmkweExqZ3lOMXBOTlM0ME1UY2dPQzR3T0ROSU5DNHdPREpoTGpVNE15NDFPRE1nTUNBd0lEQXRMalU0TXk0MU9EUjJOQzQyTmpaak1DQXVNekl5TGpJMk1TNDFPRFF1TlRnekxqVTROR2c1TGpNek5HRXVOVGd6TGpVNE15QXdJREFnTUNBdU5UZ3pMUzQxT0RSV09DNDJOamRoTGpVNE15NDFPRE1nTUNBd0lEQXRMalU0TXkwdU5UZzBhQzA0V2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wbHVzLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMWEJzZFhNaVBqeHdZWFJvSUdROUlrMDFJREV5YURFMElpOCtQSEJoZEdnZ1pEMGlUVEV5SURWMk1UUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1jcm9zc2xpbmUtYWRkLWxpbmUtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeE5pSWdhR1ZwWjJoMFBTSXhOaUlnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOT0M0M05TQTBMalZoTGpjMUxqYzFJREFnTUNBd0xURXVOU0F3ZGpJdU56VklOQzQxWVM0M05TNDNOU0F3SURBZ01DQXdJREV1TldneUxqYzFkakl1TnpWaExqYzFMamMxSURBZ01DQXdJREV1TlNBd1ZqZ3VOelZvTWk0M05XRXVOelV1TnpVZ01DQXdJREFnTUMweExqVklPQzQzTlhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtZm9jdXMuYWctY2hhcnRzLWZvY3VzX19pbmRpY2F0b3J7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lO3VzZXItc2VsZWN0Om5vbmU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uYWctY2hhcnRzLWZvY3VzLmFnLWNoYXJ0cy1mb2N1c19faW5kaWNhdG9yPmRpdntwb3NpdGlvbjphYnNvbHV0ZTtvdXRsaW5lOnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXIpO291dGxpbmUtd2lkdGg6MnB4O2JveC1zaGFkb3c6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3cpfS5hZy1jaGFydHMtZm9jdXMuYWctY2hhcnRzLWZvY3VzX19pbmRpY2F0b3I+c3Zne3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZmlsbDpub25lO3N0cm9rZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLWNvbG9yKTtzdHJva2Utd2lkdGg6MnB4fS5hZy1jaGFydHMtZm9jdXMtLWhpZGRlbnt2aXNpYmlsaXR5OmhpZGRlbn0uYWctY2hhcnRzLXRvb2xiYXJ7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZTtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOm5vd3JhcDtvcGFjaXR5OjE7cG9zaXRpb246YWJzb2x1dGU7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNpdGlvbjpvcGFjaXR5IC4ycyBlYXNlLWluLW91dCx0cmFuc2Zvcm0gLjJzIGVhc2UtaW4tb3V0fS5hZy1jaGFydHMtdG9vbGJhci0taGlkZGVuLC5hZy1jaGFydHMtdG9vbGJhci0tcHJldmVudC1mbGFzaHt2aXNpYmlsaXR5OmhpZGRlbn0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWhpZGRlbntvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBlYXNlLWluLW91dH0uYWctY2hhcnRzLXRvb2xiYXItLXNtYWxsey0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZTogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZS1zbWFsbCk7LS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemU6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZS1zbWFsbCk7LS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZzogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmctc21hbGwpfS5hZy1jaGFydHMtdG9vbGJhci0tdG9wLC5hZy1jaGFydHMtdG9vbGJhci0tYm90dG9te2ZsZXgtZGlyZWN0aW9uOnJvdzt3aWR0aDoxMDAlfS5hZy1jaGFydHMtdG9vbGJhci0tbGVmdCwuYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0e2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9wLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9te2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZTtmbGV4LWRpcmVjdGlvbjpyb3c7cG9pbnRlci1ldmVudHM6bm9uZTt3aWR0aDoxMDAlfS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmd7cGFkZGluZzowO3dpZHRoOmF1dG87ei1pbmRleDp2YXIoLS1hZy1jaGFydHMtbGF5ZXItdG9vbGJhcil9LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3B7aGVpZ2h0OmNhbGModmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSkgKyAxMHB4KTtwYWRkaW5nLXRvcDoxMHB4fS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9te2hlaWdodDpjYWxjKHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUpICsgMTBweCk7cGFkZGluZy1ib3R0b206MTBweDtvdmVyZmxvdzpoaWRkZW59LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LXdyYXA6aW5oZXJpdDtnYXA6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZ2FwKTttYXgtd2lkdGg6MTAwJTt3aWR0aDoxMDAlfS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLXN0YXJ0e2p1c3RpZnktY29udGVudDpzdGFydH0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXJ7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmR7anVzdGlmeS1jb250ZW50OmVuZH0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXIsLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5ke21hcmdpbi1sZWZ0OmF1dG99LmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlciwuYWctY2hhcnRzLXRvb2xiYXItLWxlZnQgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5kLC5hZy1jaGFydHMtdG9vbGJhci0tcmlnaHQgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyLC5hZy1jaGFydHMtdG9vbGJhci0tcmlnaHQgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5ke21hcmdpbi1sZWZ0OjA7bWFyZ2luLXRvcDphdXRvfS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9wIC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24sLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b20gLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbnt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgZWFzZS1pbi1vdXQ7d2lkdGg6YXV0b30uYWctY2hhcnRzLXRvb2xiYXJfX3NlY3Rpb257ZGlzcGxheTppbmhlcml0O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC13cmFwOmluaGVyaXQ7anVzdGlmeS1jb250ZW50OmluaGVyaXQ7bWF4LXdpZHRoOmluaGVyaXQ7d2lkdGg6aW5oZXJpdH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbnstLXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLWluLW91dCwgYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQsIGNvbG9yIC4yNXMgZWFzZS1pbi1vdXQ7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJvcmRlcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcik7ZGlzcGxheTpmbGV4O2ZvbnQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplKSB2YXIoLS1hZy1jaGFydHMtZm9udC1mYW1pbHkpO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjAgMCAwIC0xcHg7bWluLWhlaWdodDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKTttaW4td2lkdGg6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSk7cGFkZGluZzp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZyk7cG9pbnRlci1ldmVudHM6YWxsO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zaXRpb246dmFyKC0tdHJhbnNpdGlvbik7d2hpdGUtc3BhY2U6bm93cmFwfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uW2RhdGEtdG9vbGJhci1ncm91cD1yYW5nZXNde3BhZGRpbmc6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpIGNhbGModmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpICogMS41KX0uYWctY2hhcnRzLXRvb2xiYXItLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWJvdHRvbSwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9wLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9tey5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOm50aC1jaGlsZCgxIG9mOm5vdCguYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWQpKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTtib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTttYXJnaW46MH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpudGgtbGFzdC1jaGlsZCgxIG9mOm5vdCguYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWQpKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpfX0uYWctY2hhcnRzLXRvb2xiYXItLWxlZnQsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodHsuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbntib3JkZXItcmFkaXVzOjA7bWFyZ2luOi0xcHggMCAwO21heC13aWR0aDoxMDAlfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOm50aC1jaGlsZCgxIG9mOm5vdCguYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWQpKXtib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7bWFyZ2luOjB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246bnRoLWxhc3QtY2hpbGQoMSBvZjpub3QoLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVkKSl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpfX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXZhbHVlLC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZHtkaXNwbGF5Om5vbmV9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcik7ei1pbmRleDoxfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOmZvY3VzLXZpc2libGV7Ym9yZGVyLWNvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvY3VzLWNvbG9yKTtib3gtc2hhZG93OnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KTt6LWluZGV4OjN9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tYWN0aXZle2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWJhY2tncm91bmQtY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3IpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1jb2xvcik7ei1pbmRleDoyfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uW2FyaWEtZGlzYWJsZWQ9dHJ1ZV17YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yKTtjb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1kaXNhYmxlZC1mb3JlZ3JvdW5kLWNvbG9yKX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpub3QoW2FyaWEtZGlzYWJsZWQ9dHJ1ZV0pe2N1cnNvcjpwb2ludGVyfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maWxsLXZpc2libGU6YWZ0ZXJ7Y29udGVudDpcIlwiO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjNweDtsZWZ0OjVweDtyaWdodDo1cHg7aGVpZ2h0OjRweDtib3JkZXItcmFkaXVzOjk5cHg7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggY29sb3ItbWl4KGluIHNyZ2IsdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpIDEwJSx0cmFuc3BhcmVudCk7YmFja2dyb3VuZDp2YXIoLS1maWxsKX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlsbC12aXNpYmxlW2FyaWEtZGlzYWJsZWQ9dHJ1ZV06YWZ0ZXJ7ZmlsdGVyOmdyYXlzY2FsZSgxKTtvcGFjaXR5Oi41fS5hZy1jaGFydHMtdG9vbGJhcl9faWNvbisuYWctY2hhcnRzLXRvb2xiYXJfX2xhYmVse21hcmdpbi1sZWZ0OnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWdhcCl9LmFnLWNoYXJ0cy10b29sYmFyX19pY29uLC5hZy1jaGFydHMtdG9vbGJhcl9fbGFiZWx7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnQtb3ZlcmxheXtjb2xvcjojMTgxZDFmO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0LW92ZXJsYXkuYWctY2hhcnQtZGFyay1vdmVybGF5e2NvbG9yOiNmZmZ9LmFnLWNoYXJ0LW92ZXJsYXktLWxvYWRpbmd7Y29sb3I6IzhjOGM4Y30uYWctY2hhcnQtb3ZlcmxheV9fbG9hZGluZy1iYWNrZ3JvdW5ke2JhY2tncm91bmQ6I2ZmZjtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydC1vdmVybGF5LmFnLWNoYXJ0LWRhcmstb3ZlcmxheSAuYWctY2hhcnQtb3ZlcmxheV9fbG9hZGluZy1iYWNrZ3JvdW5ke2JhY2tncm91bmQ6IzE5MjIzMn0uYWctY2hhcnQtdG9vbHRpcHt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMXMgZWFzZTt3aWR0aDptYXgtY29udGVudDt6LWluZGV4Ojk5OTk5O2ZvbnQ6MTJweCBWZXJkYW5hLHNhbnMtc2VyaWY7Y29sb3I6IzQ2NDY0Njtib3gtc2hhZG93OjAgNHB4IDhweCAjMDAwMDAwMTR9LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1hbHdheXN7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZDtoeXBoZW5zOm5vbmV9LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1oeXBoZW5hdGV7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZDtoeXBoZW5zOmF1dG99LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1vbi1zcGFjZXtvdmVyZmxvdy13cmFwOm5vcm1hbDt3b3JkLWJyZWFrOm5vcm1hbH0uYWctY2hhcnQtdG9vbHRpcC13cmFwLW5ldmVye3doaXRlLXNwYWNlOnByZTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5hZy1jaGFydC10b29sdGlwLW5vLWludGVyYWN0aW9ue3BvaW50ZXItZXZlbnRzOm5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uYWctY2hhcnQtdG9vbHRpcC1uby1hbmltYXRpb257dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH0uYWctY2hhcnQtdG9vbHRpcC1oaWRkZW57dmlzaWJpbGl0eTpoaWRkZW59LmFnLWNoYXJ0LXRvb2x0aXAtdGl0bGV7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6OHB4IDE0cHg7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czoycHg7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MnB4O2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojODg4O3otaW5kZXg6MTt0ZXh0LW92ZXJmbG93OmluaGVyaXR9LmFnLWNoYXJ0LXRvb2x0aXAtdGl0bGU6b25seS1jaGlsZHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjJweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czoycHh9LmFnLWNoYXJ0LXRvb2x0aXAtY29udGVudHtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzo2cHggMTRweDtsaW5lLWhlaWdodDoxLjdlbTtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czoycHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MnB4O2JvcmRlcjoxcHggc29saWQgcmdiYSgwLDAsMCwuMTUpO3RleHQtb3ZlcmZsb3c6aW5oZXJpdH0uYWctY2hhcnQtdG9vbHRpcC1hcnJvdzpiZWZvcmV7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSk7Ym9yZGVyOjVweCBzb2xpZCAjZDlkOWQ5O2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O3dpZHRoOjA7aGVpZ2h0OjA7bWFyZ2luOjAgYXV0b30uYWctY2hhcnQtdG9vbHRpcC1hcnJvdzphZnRlcntjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOmNhbGMoMTAwJSAtIDFweCk7bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKTtib3JkZXI6NXB4IHNvbGlkIHdoaXRlO2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O3dpZHRoOjA7aGVpZ2h0OjA7bWFyZ2luOjAgYXV0b31cXG4nO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2d1YXJkZWRFbGVtZW50LnRzXG52YXIgR3VhcmRlZEVsZW1lbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQyLCB0b3BUYWJHdWFyZCwgYm90dG9tVGFiR3VhcmQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50MjtcbiAgICB0aGlzLnRvcFRhYkd1YXJkID0gdG9wVGFiR3VhcmQ7XG4gICAgdGhpcy5ib3R0b21UYWJHdWFyZCA9IGJvdHRvbVRhYkd1YXJkO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuZ3VhcmRUYWJJbmRleCA9IDA7XG4gICAgdGhpcy5lbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwiYmx1clwiLCAoKSA9PiB0aGlzLm9uQmx1cigpKTtcbiAgICB0aGlzLmluaXRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXCJmb2N1c1wiLCAoKSA9PiB0aGlzLm9uRm9jdXMoKSk7XG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5lcih0aGlzLnRvcFRhYkd1YXJkLCBcImZvY3VzXCIsIChldikgPT4gdGhpcy5vblRhYlN0YXJ0KGV2LCB0aGlzLnRvcFRhYkd1YXJkKSk7XG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5lcih0aGlzLmJvdHRvbVRhYkd1YXJkLCBcImZvY3VzXCIsIChldikgPT4gdGhpcy5vblRhYlN0YXJ0KGV2LCB0aGlzLmJvdHRvbVRhYkd1YXJkKSk7XG4gIH1cbiAgc2V0IHRhYkluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuZ3VhcmRUYWJJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICB0aGlzLnRvcFRhYkd1YXJkLnRhYkluZGV4ID0gaW5kZXg7XG4gICAgICB0aGlzLmJvdHRvbVRhYkd1YXJkLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b3BUYWJHdWFyZC50YWJJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5ib3R0b21UYWJHdWFyZC50YWJJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5kZXN0cm95Rm5zKVxuICAgICAgZm4oKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMubGVuZ3RoID0gMDtcbiAgfVxuICBpbml0RXZlbnRMaXN0ZW5lcihlbGVtLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSk7XG4gIH1cbiAgb25CbHVyKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLnRhYkluZGV4ID0gdGhpcy5ndWFyZFRhYkluZGV4O1xuICAgICAgdGhpcy5ndWFyZFRhcmdldCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZ3Vlc3NlZERlbHRhID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICB9XG4gIG9uVGFiU3RhcnQoZXZlbnQsIHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQudGFiSW5kZXggPiAwKSB7XG4gICAgICB0aGlzLmd1ZXNzZWREZWx0YSA9IDA7XG4gICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAhPSBudWxsICYmIFwidGFiSW5kZXhcIiBpbiBldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByZXZUYWJJbmRleCA9IE51bWJlcihldmVudC5yZWxhdGVkVGFyZ2V0W1widGFiSW5kZXhcIl0pO1xuICAgICAgICBpZiAoIWlzTmFOKHByZXZUYWJJbmRleCkgJiYgcHJldlRhYkluZGV4ID4gMCkge1xuICAgICAgICAgIHRoaXMuZ3Vlc3NlZERlbHRhID0gcHJldlRhYkluZGV4IDwgdGFyZ2V0LnRhYkluZGV4ID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3VhcmRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gIH1cbiAgZ2V0QnJvd3NlckZvY3VzRGVsdGEoKSB7XG4gICAgY29uc3QgeyBndWVzc2VkRGVsdGEsIGd1YXJkVGFyZ2V0LCB0b3BUYWJHdWFyZCwgYm90dG9tVGFiR3VhcmQ6IGJvdFRhYkd1YXJkIH0gPSB0aGlzO1xuICAgIGlmIChndWVzc2VkRGVsdGEgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBndWVzc2VkRGVsdGE7XG4gICAgaWYgKGd1YXJkVGFyZ2V0ID09PSB0b3BUYWJHdWFyZClcbiAgICAgIHJldHVybiAxO1xuICAgIGlmIChndWFyZFRhcmdldCA9PT0gYm90VGFiR3VhcmQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2l6ZU1vbml0b3IudHNcbnZhciBTaXplTW9uaXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLm9uTG9hZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRSZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5mb3JFYWNoKChbZWwsIGNiXSkgPT4gdGhpcy5vYnNlcnZlKGVsLCBjYikpO1xuICAgICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMgPSBbXTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY29udGVudFJlY3Q6IHsgd2lkdGgsIGhlaWdodCB9XG4gICAgICB9IG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmVsZW1lbnRzLmdldCh0YXJnZXQpO1xuICAgICAgICB0aGlzLmNoZWNrU2l6ZShlbnRyeSwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSBnZXREb2N1bWVudChcInJlYWR5U3RhdGVcIikgPT09IFwiY29tcGxldGVcIjtcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRSZWFkeSkge1xuICAgICAgZ2V0V2luZG93KCk/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25Mb2FkKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBnZXRXaW5kb3coKT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgfVxuICBjaGVja1NpemUoZW50cnksIGVsZW1lbnQyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFlbnRyeSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAod2lkdGggIT09IGVudHJ5LnNpemU/LndpZHRoIHx8IGhlaWdodCAhPT0gZW50cnkuc2l6ZT8uaGVpZ2h0KSB7XG4gICAgICBlbnRyeS5zaXplID0geyB3aWR0aCwgaGVpZ2h0IH07XG4gICAgICBlbnRyeS5jYihlbnRyeS5zaXplLCBlbGVtZW50Mik7XG4gICAgfVxuICB9XG4gIC8vIE9ubHkgYSBzaW5nbGUgY2FsbGJhY2sgaXMgc3VwcG9ydGVkLlxuICBvYnNlcnZlKGVsZW1lbnQyLCBjYikge1xuICAgIGlmICghdGhpcy5kb2N1bWVudFJlYWR5KSB7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5wdXNoKFtlbGVtZW50MiwgY2JdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQyKSkge1xuICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGVsZW1lbnQyKTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSB7IGNiIH07XG4gICAgdGhpcy5lbGVtZW50cy5zZXQoZWxlbWVudDIsIGVudHJ5KTtcbiAgICB0aGlzLmNoZWNrU2l6ZShlbnRyeSwgZWxlbWVudDIsIGVsZW1lbnQyLm9mZnNldFdpZHRoLCBlbGVtZW50Mi5vZmZzZXRIZWlnaHQpO1xuICB9XG4gIHVub2JzZXJ2ZShlbGVtZW50Mikge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShlbGVtZW50Mik7XG4gICAgdGhpcy5lbGVtZW50cy5kZWxldGUoZWxlbWVudDIpO1xuICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGVsZW1lbnQyKTtcbiAgICBpZiAoIXRoaXMuZWxlbWVudHMuc2l6ZSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUZyb21RdWV1ZShlbGVtZW50Mikge1xuICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzID0gdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMuZmlsdGVyKChbZWxdKSA9PiBlbCAhPT0gZWxlbWVudDIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kb20vZG9tTGF5b3V0Lmh0bWxcbnZhciBkb21MYXlvdXRfZGVmYXVsdCA9ICc8ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy13cmFwcGVyIGFnLWNoYXJ0cy1zdHlsZXNcIiBkYXRhLWFnLWNoYXJ0cz48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtY2VudGVyXCI+PGRpdiByb2xlPVwiZmlndXJlXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLWNvbnRhaW5lclwiPjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLXRhYi1ndWFyZFwiPjwvZGl2PjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhc1wiPjwvZGl2PjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1wcm94eVwiPjwvZGl2PjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLXRhYi1ndWFyZFwiPjwvZGl2PjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1vdmVybGF5XCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+JztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZG9tL2RvbU1hbmFnZXIudHNcbnZhciBDQU5WQVNfQ0VOVEVSX0NMQVNTID0gXCJjYW52YXMtY2VudGVyXCI7XG52YXIgRE9NX0VMRU1FTlRfQ0xBU1NFUyA9IFtcInN0eWxlc1wiLCBDQU5WQVNfQ0VOVEVSX0NMQVNTLCBcImNhbnZhc1wiLCBcImNhbnZhcy1wcm94eVwiLCBcImNhbnZhcy1vdmVybGF5XCJdO1xudmFyIGRvbUVsZW1lbnRDb25maWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcInN0eWxlc1wiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwic3R5bGVcIiB9XSxcbiAgW1wiY2FudmFzXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJjYW52YXNcIiwgZXZlbnRUeXBlczogW1wiZm9jdXNcIiwgXCJibHVyXCJdIH1dLFxuICBbXCJjYW52YXMtcHJveHlcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dLFxuICBbXCJjYW52YXMtb3ZlcmxheVwiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiZGl2XCIgfV0sXG4gIFtDQU5WQVNfQ0VOVEVSX0NMQVNTLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiZGl2XCIgfV1cbl0pO1xuZnVuY3Rpb24gc2V0dXBPYnNlcnZlcihlbGVtZW50MiwgY2IpIHtcbiAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgIChlbnRyaWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJ5LnRhcmdldCA9PT0gZWxlbWVudDIpIHtcbiAgICAgICAgICBjYihlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHsgcm9vdDogZWxlbWVudDIgfVxuICApO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQyKTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxudmFyIE5VTExfRE9NUkVDVCA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgdG9wOiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwLFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE5VTExfRE9NUkVDVDtcbiAgfVxufTtcbnZhciBET01NYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRhaW5lclNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplTW9uaXRvciA9IG5ldyBTaXplTW9uaXRvcigpO1xuICAgIGNvbnN0IHRlbXBsYXRlRWwgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRlbXBsYXRlRWwuaW5uZXJIVE1MID0gZG9tTGF5b3V0X2RlZmF1bHQ7XG4gICAgdGhpcy5lbGVtZW50ID0gdGVtcGxhdGVFbC5jaGlsZHJlbi5pdGVtKDApO1xuICAgIHRoaXMucm9vdEVsZW1lbnRzID0gRE9NX0VMRU1FTlRfQ0xBU1NFUy5yZWR1Y2UoXG4gICAgICAociwgYykgPT4ge1xuICAgICAgICBjb25zdCBjc3NDbGFzcyA9IGBhZy1jaGFydHMtJHtjfWA7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzcykgPyB0aGlzLmVsZW1lbnQgOiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Y3NzQ2xhc3N9YCk7XG4gICAgICAgIGlmICghZWwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmFibGUgdG8gZmluZCBET00gZWxlbWVudCAke2Nzc0NsYXNzfWApO1xuICAgICAgICByW2NdID0geyBlbGVtZW50OiBlbCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGxpc3RlbmVyczogW10gfTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9LFxuICAgICAge31cbiAgICApO1xuICAgIGxldCBoaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyID0gc2V0dXBPYnNlcnZlcih0aGlzLmVsZW1lbnQsIChpbnRlcnNlY3Rpb25SYXRpbykgPT4ge1xuICAgICAgaWYgKGludGVyc2VjdGlvblJhdGlvID09PSAwICYmICFoaWRkZW4pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJoaWRkZW5cIiwgeyB0eXBlOiBcImhpZGRlblwiIH0pO1xuICAgICAgfVxuICAgICAgaGlkZGVuID0gaW50ZXJzZWN0aW9uUmF0aW8gPT09IDA7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRTaXplT3B0aW9ucygpO1xuICAgIHRoaXMuYWRkU3R5bGVzKFwiYWctY2hhcnRzLWNvbW11bml0eVwiLCBzdHlsZXNfZGVmYXVsdCk7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5zZXRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vYnNlcnZlcj8udW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLnNpemVNb25pdG9yLnVub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIE9iamVjdC52YWx1ZXModGhpcy5yb290RWxlbWVudHMpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBjLnJlbW92ZSgpKTtcbiAgICAgIGVsLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ndWFyZGVkRWxlbWVudD8uZGVzdHJveSgpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuICBzZXRTaXplT3B0aW9ucyhtaW5XaWR0aCA9IDMwMCwgbWluSGVpZ2h0ID0gMzAwLCBvcHRpb25zV2lkdGgsIG9wdGlvbnNIZWlnaHQpIHtcbiAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgc3R5bGUud2lkdGggPSBgJHtvcHRpb25zV2lkdGggPz8gbWluV2lkdGh9cHhgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAke29wdGlvbnNIZWlnaHQgPz8gbWluSGVpZ2h0fXB4YDtcbiAgfVxuICB1cGRhdGVDb250YWluZXJTaXplKCkge1xuICAgIGNvbnN0IHsgc3R5bGU6IGNlbnRlclN0eWxlIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tDQU5WQVNfQ0VOVEVSX0NMQVNTXS5lbGVtZW50O1xuICAgIGNlbnRlclN0eWxlLndpZHRoID0gYCR7dGhpcy5jb250YWluZXJTaXplPy53aWR0aCA/PyAwfXB4YDtcbiAgICBjZW50ZXJTdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmNvbnRhaW5lclNpemU/LmhlaWdodCA/PyAwfXB4YDtcbiAgfVxuICBzZXRDb250YWluZXIobmV3Q29udGFpbmVyKSB7XG4gICAgaWYgKG5ld0NvbnRhaW5lciA9PT0gdGhpcy5jb250YWluZXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgdGhpcy5zaXplTW9uaXRvci51bm9ic2VydmUodGhpcy5jb250YWluZXIpO1xuICAgIH1cbiAgICBjb25zdCBpc1NoYWRvd0RvbSA9IHRoaXMuZ2V0RG9jdW1lbnRSb290KG5ld0NvbnRhaW5lcikgIT0gbnVsbDtcbiAgICBpZiAoIWlzU2hhZG93RG9tKSB7XG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMucm9vdEVsZW1lbnRzW1wic3R5bGVzXCJdLmNoaWxkcmVuLmtleXMoKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKFwic3R5bGVzXCIsIGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5zaXplTW9uaXRvci5vYnNlcnZlKG5ld0NvbnRhaW5lciwgKHNpemUpID0+IHtcbiAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNpemUoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicmVzaXplXCIsIHsgdHlwZTogXCJyZXNpemVcIiB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG5ld0NvbnRhaW5lcjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgc3R5bGVzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnN0eWxlcykpIHtcbiAgICAgIHRoaXMuYWRkU3R5bGVzKGlkLCBzdHlsZXMpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImNvbnRhaW5lci1jaGFuZ2VkXCIsIHsgdHlwZTogXCJjb250YWluZXItY2hhbmdlZFwiIH0pO1xuICB9XG4gIHNldFRoZW1lQ2xhc3ModGhlbWVDbGFzc05hbWUpIHtcbiAgICBjb25zdCB0aGVtZUNsYXNzTmFtZVByZWZpeCA9IFwiYWctY2hhcnRzLXRoZW1lLVwiO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICBpZiAoY2xhc3NOYW1lLnN0YXJ0c1dpdGgodGhlbWVDbGFzc05hbWVQcmVmaXgpICYmIGNsYXNzTmFtZSAhPT0gdGhlbWVDbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGVtZUNsYXNzTmFtZSk7XG4gIH1cbiAgY3JlYXRlVGFiR3VhcmRzKCkge1xuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSB0aGlzLnJvb3RFbGVtZW50c1tcImNhbnZhc1wiXS5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIik7XG4gICAgY29uc3QgdGFiR3VhcmRzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWctY2hhcnRzLXRhYi1ndWFyZFwiKTtcbiAgICBpZiAoY2FudmFzRWxlbWVudCA9PSBudWxsIHx8IHRhYkd1YXJkc1swXSA9PSBudWxsIHx8IHRhYkd1YXJkc1sxXSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBlcnJvciBpbml0aWFsaXNpbmcgY2FudmFzIHRhYiBndWFyZHNcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR3VhcmRlZEVsZW1lbnQoY2FudmFzRWxlbWVudCwgdGFiR3VhcmRzWzBdLCB0YWJHdWFyZHNbMV0pO1xuICB9XG4gIHNldFRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgdGhpcy5ndWFyZGVkRWxlbWVudCA/PyAodGhpcy5ndWFyZGVkRWxlbWVudCA9IHRoaXMuY3JlYXRlVGFiR3VhcmRzKCkpO1xuICAgIHRoaXMuZ3VhcmRlZEVsZW1lbnQudGFiSW5kZXggPSB0YWJJbmRleDtcbiAgfVxuICBnZXRCcm93c2VyRm9jdXNEZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5ndWFyZGVkRWxlbWVudD8uZ2V0QnJvd3NlckZvY3VzRGVsdGEoKSA/PyAwO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXJPbkVsZW1lbnQoZWxlbWVudFR5cGUsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiB9ID0gdGhpcy5yb290RWxlbWVudHNbZWxlbWVudFR5cGVdO1xuICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlbGVtZW50Mi5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9O1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgZG9tRWxlbWVudENvbmZpZy5mb3JFYWNoKChjb25maWcsIGVsVHlwZSkgPT4ge1xuICAgICAgaWYgKCFjb25maWcuZXZlbnRUeXBlcz8uaW5jbHVkZXModHlwZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGVscyA9IHRoaXMucm9vdEVsZW1lbnRzW2VsVHlwZV07XG4gICAgICBlbHMubGlzdGVuZXJzLnB1c2goW3R5cGUsIGxpc3RlbmVyLCBvcHRpb25zXSk7XG4gICAgICBlbHMuY2hpbGRyZW4uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIGRvbUVsZW1lbnRDb25maWcuZm9yRWFjaCgoY29uZmlnLCBlbFR5cGUpID0+IHtcbiAgICAgIGlmICghY29uZmlnLmV2ZW50VHlwZXM/LmluY2x1ZGVzKHR5cGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBlbHMgPSB0aGlzLnJvb3RFbGVtZW50c1tlbFR5cGVdO1xuICAgICAgZWxzLmxpc3RlbmVycyA9IGVscy5saXN0ZW5lcnMuZmlsdGVyKChbdCwgbF0pID0+IHQgIT09IHR5cGUgJiYgbCAhPT0gbGlzdGVuZXIpO1xuICAgICAgZWxzLmNoaWxkcmVuLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIEdldCB0aGUgbWFpbiBjaGFydCBhcmVhIGNsaWVudCBib3VuZCByZWN0LiAqL1xuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnRzW1wiY2FudmFzXCJdLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xpZW50IGJvdW5kaW5nIHJlY3QgZm9yIG92ZXJsYXkgZWxlbWVudHMgdGhhdCBtaWdodCBmbG9hdCBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlXG4gICAqIG1haW4gY2hhcnQgYXJlYS5cbiAgICovXG4gIGdldE92ZXJsYXlDbGllbnRSZWN0KCkge1xuICAgIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3coKTtcbiAgICBjb25zdCB3aW5kb3dCQm94ID0gbmV3IEJCb3goMCwgMCwgd2luZG93Mi5pbm5lcldpZHRoLCB3aW5kb3cyLmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldFJhd092ZXJsYXlDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY29udGFpbmVyQkJveCA9IEJCb3guZnJvbURPTVJlY3QoY29udGFpbmVyID8/IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgIHJldHVybiB3aW5kb3dCQm94LmludGVyc2VjdGlvbihjb250YWluZXJCQm94KT8udG9ET01SZWN0KCkgPz8gTlVMTF9ET01SRUNUO1xuICB9XG4gIGdldFJhd092ZXJsYXlDbGllbnRSZWN0KCkge1xuICAgIGxldCBlbGVtZW50MiA9IHRoaXMuZWxlbWVudDtcbiAgICB3aGlsZSAoZWxlbWVudDIgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3R5bGVNYXAgPSBlbGVtZW50Mi5jb21wdXRlZFN0eWxlTWFwPy4oKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WCA9IHN0eWxlTWFwPy5nZXQoXCJvdmVyZmxvdy14XCIpPy50b1N0cmluZygpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gc3R5bGVNYXA/LmdldChcIm92ZXJmbG93LXlcIik/LnRvU3RyaW5nKCk7XG4gICAgICBpZiAob3ZlcmZsb3dYICE9IG51bGwgJiYgb3ZlcmZsb3dYICE9PSBcInZpc2libGVcIiB8fCBvdmVyZmxvd1kgJiYgb3ZlcmZsb3dZICE9PSBcInZpc2libGVcIikge1xuICAgICAgICByZXR1cm4gZWxlbWVudDIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50MiA9IGVsZW1lbnQyLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGRvY1Jvb3QgPSB0aGlzLmdldERvY3VtZW50Um9vdCgpO1xuICAgIGlmIChkb2NSb290KSB7XG4gICAgICByZXR1cm4gZG9jUm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH1cbiAgZ2V0RG9jdW1lbnRSb290KGN1cnJlbnQgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGNvbnN0IGRvY1Jvb3QgPSBjdXJyZW50Py5vd25lckRvY3VtZW50Py5ib2R5ID8/IGdldERvY3VtZW50KFwiYm9keVwiKTtcbiAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gZG9jUm9vdCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQucGFyZW50Tm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldENoaWxkQm91bmRpbmdDbGllbnRSZWN0KHR5cGUpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnJvb3RFbGVtZW50c1t0eXBlXTtcbiAgICBjb25zdCBjaGlsZFJlY3RzID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgY2hpbGRSZWN0cy5wdXNoKEJCb3guZnJvbURPTVJlY3QoY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UoY2hpbGRSZWN0cyk7XG4gIH1cbiAgY2FsY3VsYXRlQ2FudmFzUG9zaXRpb24oZWwpIHtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGNvbnN0IHsgeDogY3ggPSAwLCB5OiBjeSA9IDAgfSA9IHRoaXMuZ2V0Q2hpbGRCb3VuZGluZ0NsaWVudFJlY3QoXCJjYW52YXNcIikgPz8ge307XG4gICAgY29uc3QgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IGVsUmVjdC54IC0gY3g7XG4gICAgeSA9IGVsUmVjdC55IC0gY3k7XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9XG4gIGlzTWFuYWdlZENoaWxkRE9NRWxlbWVudChlbCwgZG9tRWxlbWVudENsYXNzLCBpZCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc107XG4gICAgY29uc3Qgc2VhcmNoID0gY2hpbGRyZW4/LmdldChpZCk7XG4gICAgcmV0dXJuIHNlYXJjaCAhPSBudWxsICYmIGVsLmNvbnRhaW5zKHNlYXJjaCk7XG4gIH1cbiAgaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudDIgPSBldmVudC50YXJnZXQ7XG4gICAgcmV0dXJuIGVsZW1lbnQyICE9IG51bGwgJiYgdGhpcy5lbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQyKTtcbiAgfVxuICBhZGRTdHlsZXMoaWQsIHN0eWxlcykge1xuICAgIHRoaXMuc3R5bGVzW2lkXSA9IHN0eWxlcztcbiAgICBpZiAodGhpcy5jb250YWluZXIgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBkYXRhQXR0cmlidXRlID0gXCJkYXRhLWFnLWNoYXJ0c1wiO1xuICAgIGNvbnN0IGRvY3VtZW50Um9vdCA9IHRoaXMuZ2V0RG9jdW1lbnRSb290KCk7XG4gICAgbGV0IHN0eWxlRWxlbWVudDtcbiAgICBpZiAoZG9jdW1lbnRSb290ICE9IG51bGwpIHtcbiAgICAgIHN0eWxlRWxlbWVudCA9IHRoaXMuYWRkQ2hpbGQoXCJzdHlsZXNcIiwgaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWFkID0gZ2V0RG9jdW1lbnQoXCJoZWFkXCIpO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBoZWFkLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5nZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSkgPT09IGlkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHN0eWxlRWxlbWVudC5nZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSkgPT09IGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSwgaWQpO1xuICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZXM7XG4gIH1cbiAgcmVtb3ZlU3R5bGVzKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVDaGlsZChcInN0eWxlc1wiLCBpZCk7XG4gIH1cbiAgdXBkYXRlQ3Vyc29yKHN0eWxlKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9IHN0eWxlO1xuICB9XG4gIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvcjtcbiAgfVxuICBhZGRDaGlsZChkb21FbGVtZW50Q2xhc3MsIGlkLCBjaGlsZCkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIsIGNoaWxkcmVuLCBsaXN0ZW5lcnMgfSA9IHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc107XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIGNyZWF0ZSBET00gZWxlbWVudHMgYWZ0ZXIgZGVzdHJveSgpXCIpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZyA9IGNoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGV4aXN0aW5nICE9IG51bGwpXG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgY29uc3QgeyBjaGlsZEVsZW1lbnRUeXBlID0gXCJkaXZcIiB9ID0gZG9tRWxlbWVudENvbmZpZy5nZXQoZG9tRWxlbWVudENsYXNzKSA/PyB7fTtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBjaGlsZEVsZW1lbnRUeXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIG1pc21hdGNoaW5nIERPTSBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQgPz8gY3JlYXRlRWxlbWVudChjaGlsZEVsZW1lbnRUeXBlKTtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBmbiwgb3B0c10gb2YgbGlzdGVuZXJzKSB7XG4gICAgICBuZXdDaGlsZC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRzKTtcbiAgICB9XG4gICAgY2hpbGRyZW4uc2V0KGlkLCBuZXdDaGlsZCk7XG4gICAgZWxlbWVudDI/LmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoZG9tRWxlbWVudENsYXNzLCBpZCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc107XG4gICAgaWYgKCFjaGlsZHJlbilcbiAgICAgIHJldHVybjtcbiAgICBjaGlsZHJlbi5nZXQoaWQpPy5yZW1vdmUoKTtcbiAgICBjaGlsZHJlbi5kZWxldGUoaWQpO1xuICB9XG4gIGluY3JlbWVudERhdGFDb3VudGVyKG5hbWUpIHtcbiAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBkYXRhc2V0W25hbWVdID8/IChkYXRhc2V0W25hbWVdID0gXCIwXCIpO1xuICAgIGRhdGFzZXRbbmFtZV0gPSBTdHJpbmcoTnVtYmVyKGRhdGFzZXRbbmFtZV0pICsgMSk7XG4gIH1cbiAgZ2V0SWNvbkNsYXNzTmFtZXMoaWNvbikge1xuICAgIHJldHVybiBgYWctY2hhcnRzLWljb24gYWctY2hhcnRzLWljb24tJHtpY29ufWA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3BvbHlSb290cy50c1xuZnVuY3Rpb24gbGluZWFyUm9vdChhLCBiKSB7XG4gIGNvbnN0IHQgPSAtYiAvIGE7XG4gIHJldHVybiBhICE9PSAwICYmIHQgPj0gMCAmJiB0IDw9IDEgPyBbdF0gOiBbXTtcbn1cbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RzKGEsIGIsIGMpIHtcbiAgaWYgKGEgPT09IDApIHtcbiAgICByZXR1cm4gbGluZWFyUm9vdChiLCBjKTtcbiAgfVxuICBjb25zdCBEID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGlmIChEID09PSAwKSB7XG4gICAgY29uc3QgdCA9IC1iIC8gKDIgKiBhKTtcbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoRCA+IDApIHtcbiAgICBjb25zdCByRCA9IE1hdGguc3FydChEKTtcbiAgICBjb25zdCB0MSA9ICgtYiAtIHJEKSAvICgyICogYSk7XG4gICAgY29uc3QgdDIgPSAoLWIgKyByRCkgLyAoMiAqIGEpO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDEpO1xuICAgIH1cbiAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3RzO1xufVxuZnVuY3Rpb24gY3ViaWNSb290cyhhLCBiLCBjLCBkKSB7XG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIHF1YWRyYXRpY1Jvb3RzKGIsIGMsIGQpO1xuICB9XG4gIGNvbnN0IEEgPSBiIC8gYTtcbiAgY29uc3QgQiA9IGMgLyBhO1xuICBjb25zdCBDID0gZCAvIGE7XG4gIGNvbnN0IFEgPSAoMyAqIEIgLSBBICogQSkgLyA5O1xuICBjb25zdCBSID0gKDkgKiBBICogQiAtIDI3ICogQyAtIDIgKiBBICogQSAqIEEpIC8gNTQ7XG4gIGNvbnN0IEQgPSBRICogUSAqIFEgKyBSICogUjtcbiAgY29uc3QgdGhpcmQgPSAxIC8gMztcbiAgY29uc3Qgcm9vdHMgPSBbXTtcbiAgaWYgKEQgPj0gMCkge1xuICAgIGNvbnN0IHJEID0gTWF0aC5zcXJ0KEQpO1xuICAgIGNvbnN0IFMgPSBNYXRoLnNpZ24oUiArIHJEKSAqIE1hdGgucG93KE1hdGguYWJzKFIgKyByRCksIHRoaXJkKTtcbiAgICBjb25zdCBUID0gTWF0aC5zaWduKFIgLSByRCkgKiBNYXRoLnBvdyhNYXRoLmFicyhSIC0gckQpLCB0aGlyZCk7XG4gICAgY29uc3QgSW0gPSBNYXRoLmFicyhNYXRoLnNxcnQoMykgKiAoUyAtIFQpIC8gMik7XG4gICAgY29uc3QgdCA9IC10aGlyZCAqIEEgKyAoUyArIFQpO1xuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQpO1xuICAgIH1cbiAgICBpZiAoSW0gPT09IDApIHtcbiAgICAgIGNvbnN0IHQyID0gLXRoaXJkICogQSAtIChTICsgVCkgLyAyO1xuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290cy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGhldGEgPSBNYXRoLmFjb3MoUiAvIE1hdGguc3FydCgtUSAqIFEgKiBRKSk7XG4gICAgY29uc3QgdGhpcmRBID0gdGhpcmQgKiBBO1xuICAgIGNvbnN0IHR3b1NxcnRRID0gMiAqIE1hdGguc3FydCgtUSk7XG4gICAgY29uc3QgdDEgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogdGhldGEpIC0gdGhpcmRBO1xuICAgIGNvbnN0IHQyID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqICh0aGV0YSArIDIgKiBNYXRoLlBJKSkgLSB0aGlyZEE7XG4gICAgY29uc3QgdDMgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogKHRoZXRhICsgNCAqIE1hdGguUEkpKSAtIHRoaXJkQTtcbiAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQxKTtcbiAgICB9XG4gICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgfVxuICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdHM7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2ludGVyc2VjdGlvbi50c1xuZnVuY3Rpb24gc2VnbWVudEludGVyc2VjdGlvbihheDEsIGF5MSwgYXgyLCBheTIsIGJ4MSwgYnkxLCBieDIsIGJ5Mikge1xuICBjb25zdCBkID0gKGF4MiAtIGF4MSkgKiAoYnkyIC0gYnkxKSAtIChheTIgLSBheTEpICogKGJ4MiAtIGJ4MSk7XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgdWEgPSAoKGJ4MiAtIGJ4MSkgKiAoYXkxIC0gYnkxKSAtIChheDEgLSBieDEpICogKGJ5MiAtIGJ5MSkpIC8gZDtcbiAgY29uc3QgdWIgPSAoKGF4MiAtIGF4MSkgKiAoYXkxIC0gYnkxKSAtIChheTIgLSBheTEpICogKGF4MSAtIGJ4MSkpIC8gZDtcbiAgaWYgKHVhID49IDAgJiYgdWEgPD0gMSAmJiB1YiA+PSAwICYmIHViIDw9IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGN1YmljU2VnbWVudEludGVyc2VjdGlvbnMocHgxLCBweTEsIHB4MiwgcHkyLCBweDMsIHB5MywgcHg0LCBweTQsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGxldCBpbnRlcnNlY3Rpb25zID0gMDtcbiAgY29uc3QgQSA9IHkxIC0geTI7XG4gIGNvbnN0IEIgPSB4MiAtIHgxO1xuICBjb25zdCBDID0geDEgKiAoeTIgLSB5MSkgLSB5MSAqICh4MiAtIHgxKTtcbiAgY29uc3QgYnggPSBiZXppZXJDb2VmZmljaWVudHMocHgxLCBweDIsIHB4MywgcHg0KTtcbiAgY29uc3QgYnkgPSBiZXppZXJDb2VmZmljaWVudHMocHkxLCBweTIsIHB5MywgcHk0KTtcbiAgY29uc3QgYSA9IEEgKiBieFswXSArIEIgKiBieVswXTtcbiAgY29uc3QgYiA9IEEgKiBieFsxXSArIEIgKiBieVsxXTtcbiAgY29uc3QgYyA9IEEgKiBieFsyXSArIEIgKiBieVsyXTtcbiAgY29uc3QgZCA9IEEgKiBieFszXSArIEIgKiBieVszXSArIEM7XG4gIGNvbnN0IHJvb3RzID0gY3ViaWNSb290cyhhLCBiLCBjLCBkKTtcbiAgZm9yIChjb25zdCB0IG9mIHJvb3RzKSB7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0ICogdHQ7XG4gICAgY29uc3QgeCA9IGJ4WzBdICogdHR0ICsgYnhbMV0gKiB0dCArIGJ4WzJdICogdCArIGJ4WzNdO1xuICAgIGNvbnN0IHkgPSBieVswXSAqIHR0dCArIGJ5WzFdICogdHQgKyBieVsyXSAqIHQgKyBieVszXTtcbiAgICBsZXQgcztcbiAgICBpZiAoeDEgPT09IHgyKSB7XG4gICAgICBzID0gKHkgLSB5MSkgLyAoeTIgLSB5MSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKTtcbiAgICB9XG4gICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEpIHtcbiAgICAgIGludGVyc2VjdGlvbnMrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59XG5mdW5jdGlvbiBiZXppZXJDb2VmZmljaWVudHMoUDEsIFAyLCBQMywgUDQpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBCw6l6aWVyIGV4cHJlc3NlZCBhcyBtYXRyaXggb3BlcmF0aW9uczpcbiAgICAtUDEgKyAzICogUDIgLSAzICogUDMgKyBQNCxcbiAgICAvLyAgICAgICAgICAgICAgICAgfC0xICAzIC0zICAxfCB8UDF8XG4gICAgMyAqIFAxIC0gNiAqIFAyICsgMyAqIFAzLFxuICAgIC8vICAgW3ReMyB0XjIgdCAxXSB8IDMgLTYgIDMgIDB8IHxQMnxcbiAgICAtMyAqIFAxICsgMyAqIFAyLFxuICAgIC8vICAgICAgICAgICAgICAgICB8LTMgIDMgIDAgIDB8IHxQM3xcbiAgICBQMVxuICAgIC8vICAgICAgICAgICAgICAgICB8IDEgIDAgIDAgIDB8IHxQNHxcbiAgXTtcbn1cbmZ1bmN0aW9uIGFyY0ludGVyc2VjdGlvbnMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgaWYgKGlzTmFOKGN4KSB8fCBpc05hTihjeSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgIFtlbmRBbmdsZSwgc3RhcnRBbmdsZV0gPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdO1xuICB9XG4gIGNvbnN0IGsgPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSk7XG4gIGNvbnN0IHkwID0geTEgLSBrICogeDE7XG4gIGNvbnN0IGEgPSBNYXRoLnBvdyhrLCAyKSArIDE7XG4gIGNvbnN0IGIgPSAyICogKGsgKiAoeTAgLSBjeSkgLSBjeCk7XG4gIGNvbnN0IGMgPSBNYXRoLnBvdyhjeCwgMikgKyBNYXRoLnBvdyh5MCAtIGN5LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuICBjb25zdCBkID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG4gIGlmIChkIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGkxeCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAyIC8gYTtcbiAgY29uc3QgaTJ4ID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvIDIgLyBhO1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIFtpMXgsIGkyeF0uZm9yRWFjaCgoeCkgPT4ge1xuICAgIGNvbnN0IGlzWEluc2lkZUxpbmUgPSB4ID49IE1hdGgubWluKHgxLCB4MikgJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpO1xuICAgIGlmICghaXNYSW5zaWRlTGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5ID0gayAqIHggKyB5MDtcbiAgICBjb25zdCBhZGphY2VudCA9IHggLSBjeDtcbiAgICBjb25zdCBvcHBvc2l0ZSA9IHkgLSBjeTtcbiAgICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKG9wcG9zaXRlLCBhZGphY2VudCk7XG4gICAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhhbmdsZTIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaW50ZXJzZWN0aW9ucysrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9leHRlbmRlZFBhdGgyRC50c1xudmFyIEV4dGVuZGVkUGF0aDJEID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBUaGUgbWV0aG9kcyBvZiB0aGlzIGNsYXNzIHdpbGwgbGlrZWx5IGJlIGNhbGxlZCBtYW55IHRpbWVzIHBlciBhbmltYXRpb24gZnJhbWUsXG4gICAgLy8gYW5kIGFueSBhbGxvY2F0aW9uIGNhbiB0cmlnZ2VyIGEgR0MgY3ljbGUgZHVyaW5nIGFuaW1hdGlvbiwgc28gd2UgYXR0ZW1wdFxuICAgIC8vIHRvIG1pbmltaXplIHRoZSBudW1iZXIgb2YgYWxsb2NhdGlvbnMuXG4gICAgdGhpcy5wYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmRzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1BhcmFtcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWRQYXRoID0gZmFsc2U7XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZWRQYXRoICE9PSB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCB8fCB0aGlzLnByZXZpb3VzQ29tbWFuZHMubGVuZ3RoICE9PSB0aGlzLmNvbW1hbmRzLmxlbmd0aCB8fCB0aGlzLnByZXZpb3VzUGFyYW1zLmxlbmd0aCAhPT0gdGhpcy5wYXJhbXMubGVuZ3RoIHx8IHRoaXMucHJldmlvdXNDb21tYW5kcy50b1N0cmluZygpICE9PSB0aGlzLmNvbW1hbmRzLnRvU3RyaW5nKCkgfHwgdGhpcy5wcmV2aW91c1BhcmFtcy50b1N0cmluZygpICE9PSB0aGlzLnBhcmFtcy50b1N0cmluZygpO1xuICB9XG4gIGdldFBhdGgyRCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoMmQ7XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSB0cnVlO1xuICAgIHRoaXMucGF0aDJkLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMCAvKiBNb3ZlICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xuICB9XG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgaWYgKHRoaXMub3BlbmVkUGF0aCkge1xuICAgICAgdGhpcy5wYXRoMmQubGluZVRvKHgsIHkpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKDEgLyogTGluZSAqLyk7XG4gICAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cbiAgcmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgcm91bmRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGlpKSB7XG4gICAgcmFkaWkgPSBNYXRoLm1pbihyYWRpaSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICB0aGlzLm1vdmVUbyh4LCB5ICsgcmFkaWkpO1xuICAgIHRoaXMuYXJjKHggKyByYWRpaSwgeSArIHJhZGlpLCByYWRpaSwgTWF0aC5QSSwgMS41ICogTWF0aC5QSSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHJhZGlpLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpaSwgeSk7XG4gICAgdGhpcy5hcmMoeCArIHdpZHRoIC0gcmFkaWksIHkgKyByYWRpaSwgcmFkaWksIDEuNSAqIE1hdGguUEksIDIgKiBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyByYWRpaSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaWkpO1xuICAgIHRoaXMuYXJjKHggKyB3aWR0aCAtIHJhZGlpLCB5ICsgaGVpZ2h0IC0gcmFkaWksIHJhZGlpLCAwLCBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoIC0gcmFkaWksIHkgKyBoZWlnaHQpO1xuICAgIHRoaXMubGluZVRvKHggKyByYWRpaSwgeSArIGhlaWdodCk7XG4gICAgdGhpcy5hcmMoeCArICtyYWRpaSwgeSArIGhlaWdodCAtIHJhZGlpLCByYWRpaSwgTWF0aC5QSSAvIDIsIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQgLSByYWRpaSk7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgfVxuICBhcmMoeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSB0cnVlO1xuICAgIHRoaXMucGF0aDJkLmFyYyh4LCB5LCByLCBzQW5nbGUsIGVBbmdsZSwgY291bnRlckNsb2Nrd2lzZSk7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKDIgLyogQXJjICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHksIHIsIHNBbmdsZSwgZUFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlID8gMSA6IDApO1xuICB9XG4gIGN1YmljQ3VydmVUbyhjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHkpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkUGF0aCkge1xuICAgICAgdGhpcy5tb3ZlVG8oY3gxLCBjeTEpO1xuICAgIH1cbiAgICB0aGlzLnBhdGgyZC5iZXppZXJDdXJ2ZVRvKGN4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeSk7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKDMgLyogQ3VydmUgKi8pO1xuICAgIHRoaXMucGFyYW1zLnB1c2goY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkUGF0aCkge1xuICAgICAgdGhpcy5wYXRoMmQuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmNvbW1hbmRzLnB1c2goNCAvKiBDbG9zZVBhdGggKi8pO1xuICAgICAgdGhpcy5vcGVuZWRQYXRoID0gZmFsc2U7XG4gICAgICB0aGlzLmNsb3NlZFBhdGggPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjbGVhcih0cmFja0NoYW5nZXMpIHtcbiAgICBpZiAodHJhY2tDaGFuZ2VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgICAgdGhpcy5wcmV2aW91c1BhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgdGhpcy5wcmV2aW91c0Nsb3NlZFBhdGggPSB0aGlzLmNsb3NlZFBhdGg7XG4gICAgfVxuICAgIHRoaXMucGF0aDJkID0gbmV3IFBhdGgyRCgpO1xuICAgIHRoaXMub3BlbmVkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBjbiA9IGNvbW1hbmRzLmxlbmd0aDtcbiAgICBjb25zdCBveCA9IC0xZTQ7XG4gICAgY29uc3Qgb3kgPSAtMWU0O1xuICAgIGxldCBzeCA9IE5hTjtcbiAgICBsZXQgc3kgPSBOYU47XG4gICAgbGV0IHB4ID0gMDtcbiAgICBsZXQgcHkgPSAwO1xuICAgIGxldCBpbnRlcnNlY3Rpb25Db3VudCA9IDA7XG4gICAgZm9yIChsZXQgY2kgPSAwLCBwaSA9IDA7IGNpIDwgY247IGNpKyspIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24oc3gsIHN5LCBweCwgcHksIG94LCBveSwgeCwgeSk7XG4gICAgICAgICAgcHggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgc3ggPSBweDtcbiAgICAgICAgICBweSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBzeSA9IHB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTGluZSAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHB4LCBweSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIG94LCBveSwgeCwgeSk7XG4gICAgICAgICAgcHggPSBwYXJhbXNbcGkgLSAyXTtcbiAgICAgICAgICBweSA9IHBhcmFtc1twaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gY3ViaWNTZWdtZW50SW50ZXJzZWN0aW9ucyhcbiAgICAgICAgICAgIHB4LFxuICAgICAgICAgICAgcHksXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBveCxcbiAgICAgICAgICAgIG95LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgICApO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpIC0gMl07XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkgLSAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzpcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IEJvb2xlYW4ocGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBhcmNJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgY3gsXG4gICAgICAgICAgICBjeSxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgICBjb3VudGVyQ2xvY2t3aXNlLFxuICAgICAgICAgICAgb3gsXG4gICAgICAgICAgICBveSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHN4KSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24ocHgsIHB5LCBzdGFydFgsIHN0YXJ0WSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHggPSBjeCArIE1hdGguY29zKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgcHkgPSBjeSArIE1hdGguc2luKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihzeCwgc3ksIHB4LCBweSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbkNvdW50ICUgMiA9PT0gMTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIGxldCBiZXN0ID0gSW5maW5pdHk7XG4gICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGxldCBzeCA9IE5hTjtcbiAgICBsZXQgc3kgPSBOYU47XG4gICAgbGV0IHB4ID0gMDtcbiAgICBsZXQgcHkgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMCwgcGkgPSAwOyBjaSA8IGNuOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBweCA9IHN4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHB5ID0gc3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOiB7XG4gICAgICAgICAgY29uc3QgbnggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgbnkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgYmVzdCA9IGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgcHgsIHB5LCBueCwgbnksIGJlc3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzpcbiAgICAgICAgICBMb2dnZXIuZXJyb3IoXCJDb21tYW5kLkN1cnZlIGRpc3RhbmNlU3F1YXJlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzoge1xuICAgICAgICAgIGNvbnN0IGN4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGN5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHIgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICBjb25zdCBjb3VudGVyQ2xvY2t3aXNlID0gQm9vbGVhbihwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJlc3QgPSBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHB4LCBweSwgc3RhcnRYLCBzdGFydFksIGJlc3QpO1xuICAgICAgICAgIGJlc3QgPSBhcmNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgYmVzdCk7XG4gICAgICAgICAgcHggPSBjeCArIE1hdGguY29zKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgcHkgPSBjeSArIE1hdGguc2luKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIHN4LCBzeSwgYmVzdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xuICB9XG4gIGdldFBvaW50cygpIHtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29vcmRzID0gW107XG4gICAgbGV0IHBpID0gMDtcbiAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY29tbWFuZHMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgY29vcmRzLnB1c2goeyB4OiBwYXJhbXNbcGkrK10sIHk6IHBhcmFtc1twaSsrXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIHBpICs9IDQ7XG4gICAgICAgICAgY29vcmRzLnB1c2goeyB4OiBwYXJhbXNbcGkrK10sIHk6IHBhcmFtc1twaSsrXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzpcbiAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xuICAgICAgICAgIHBpICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb29yZHM7XG4gIH1cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kXG4gIGNvbXB1dGVTVkdEYXRhUGF0aChveCwgb3kpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgbGV0IHBpID0gMDtcbiAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY29tbWFuZHMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBidWZmZXIucHVzaChcIk1cIiwgb3ggKyBwYXJhbXNbcGkrK10sIG95ICsgcGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgYnVmZmVyLnB1c2goXCJMXCIsIG94ICsgcGFyYW1zW3BpKytdLCBveSArIHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzpcbiAgICAgICAgICBidWZmZXIucHVzaChcbiAgICAgICAgICAgIFwiQ1wiLFxuICAgICAgICAgICAgb3ggKyBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBveSArIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG94ICsgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3kgKyBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBveCArIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG95ICsgcGFyYW1zW3BpKytdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzpcbiAgICAgICAgICBjb25zdCBbY3gsIGN5LCByLCBhMCwgYTEsIGNjd10gPSBbXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBwYXJhbXNbcGkrK11cbiAgICAgICAgICBdO1xuICAgICAgICAgIGNvbnN0IHgwID0gb3ggKyBjeCArIE1hdGguY29zKGEwKSAqIHI7XG4gICAgICAgICAgY29uc3QgeTAgPSBveSArIGN5ICsgTWF0aC5zaW4oYTApICogcjtcbiAgICAgICAgICBjb25zdCB4MSA9IG94ICsgY3ggKyBNYXRoLmNvcyhhMSkgKiByO1xuICAgICAgICAgIGNvbnN0IHkxID0gb3kgKyBjeSArIE1hdGguc2luKGExKSAqIHI7XG4gICAgICAgICAgY29uc3QgbGFyZ2VBcmNGbGFnID0gYW5nbGVEaWZmKGEwLCBhMSwgISFjY3cpID4gTWF0aC5QSSA/IDEgOiAwO1xuICAgICAgICAgIGNvbnN0IHN3ZWVwRmxhZyA9IChjY3cgKyAxKSAlIDI7XG4gICAgICAgICAgY29uc3QgbW92ZSA9IGJ1ZmZlci5sZW5ndGggPT09IDAgPyBcIk1cIiA6IFwiTFwiO1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKG1vdmUsIHgwLCB5MCwgXCJBXCIsIHIsIHIsIDAsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4MSwgeTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcGF0aC50c1xuZnVuY3Rpb24gU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAzIC8qIE1BSk9SICovLCBjaGFuZ2VDYiwgY29udmVydG9yIH0gPSBvcHRzID8/IHt9O1xuICByZXR1cm4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXcsIHR5cGU6IFwicGF0aFwiLCBjb252ZXJ0b3IsIGNoYW5nZUNiIH0pO1xufVxudmFyIFBhdGggPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBEZWNsYXJlIGEgcGF0aCB0byByZXRhaW4gZm9yIGxhdGVyIHJlbmRlcmluZyBhbmQgaGl0IHRlc3RpbmdcbiAgICAgKiB1c2luZyBjdXN0b20gUGF0aDJEIGNsYXNzLiBUaGluayBvZiBpdCBhcyBhIFR5cGVTY3JpcHQgdmVyc2lvblxuICAgICAqIG9mIHRoZSBuYXRpdmUgUGF0aDJEICh3aXRoIHNvbWUgZGlmZmVyZW5jZXMpIHRoYXQgd29ya3MgaW4gYWxsIGJyb3dzZXJzLlxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgIHRoaXMuX2NsaXBYID0gTmFOO1xuICAgIHRoaXMuX2NsaXBZID0gTmFOO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIG9ubHkgaGFzIHRvIGJlIHVwZGF0ZWQgd2hlbiBjZXJ0YWluIGF0dHJpYnV0ZXMgY2hhbmdlLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0cmFuc2Zvcm0gYXR0cmlidXRlcyAoc3VjaCBhcyBgdHJhbnNsYXRpb25YYClcbiAgICAgKiBhcmUgY2hhbmdlZCwgd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlIHBhdGguIFRoZSBgZGlydHlQYXRoYCBmbGFnXG4gICAgICogaXMgaG93IHdlIGtlZXAgdHJhY2sgaWYgdGhlIHBhdGggaGFzIHRvIGJlIHVwZGF0ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgc2V0IGNsaXBYKHZhbHVlKSB7XG4gICAgdGhpcy5fY2xpcFggPSB2YWx1ZTtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgc2V0IGNsaXBZKHZhbHVlKSB7XG4gICAgdGhpcy5fY2xpcFkgPSB2YWx1ZTtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgc2V0IGRpcnR5UGF0aCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9kaXJ0eVBhdGggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9kaXJ0eVBhdGggPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCAzIC8qIE1BSk9SICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHlQYXRoO1xuICB9XG4gIGNoZWNrUGF0aERpcnR5KCkge1xuICAgIGlmICh0aGlzLl9kaXJ0eVBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0aGlzLnBhdGguaXNEaXJ0eSgpIHx8ICh0aGlzLmZpbGxTaGFkb3c/LmlzRGlydHkoKSA/PyBmYWxzZSkgfHwgKHRoaXMuX2NsaXBQYXRoPy5pc0RpcnR5KCkgPz8gZmFsc2UpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICByZXR1cm4gdGhpcy5wYXRoLmNsb3NlZFBhdGggJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTcXVhcmVkVHJhbnNmb3JtZWRQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBjb21wdXRlU1ZHRGF0YVBhdGgoKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmludmVyc2VUcmFuc2Zvcm1Qb2ludCgwLCAwKTtcbiAgICBpZiAodGhpcy5kaXJ0eVBhdGgpIHtcbiAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgdGhpcy5kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGF0aC5jb21wdXRlU1ZHRGF0YVBhdGgoeCwgeSk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkVHJhbnNmb3JtZWRQb2ludCh4LCB5KSB7XG4gICAgaWYgKHRoaXMucGF0aC5jbG9zZWRQYXRoICYmIHRoaXMucGF0aC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGF0aC5kaXN0YW5jZVNxdWFyZWQoeCwgeSk7XG4gIH1cbiAgaXNEaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgpO1xuICAgIGlmICh0aGlzLmRpcnR5UGF0aCB8fCB0aGlzLmlzRGlydHlQYXRoKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgdGhpcy5kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc05hTih0aGlzLl9jbGlwWCkgJiYgIWlzTmFOKHRoaXMuX2NsaXBZKSAmJiB0aGlzLmNsaXBNb2RlICE9IG51bGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBtYXJnaW4gPSB0aGlzLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgIHRoaXMuX2NsaXBQYXRoID8/ICh0aGlzLl9jbGlwUGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpKTtcbiAgICAgIHRoaXMuX2NsaXBQYXRoLmNsZWFyKCk7XG4gICAgICB0aGlzLl9jbGlwUGF0aC5yZWN0KC1tYXJnaW4sIC1tYXJnaW4sIHRoaXMuX2NsaXBYICsgbWFyZ2luLCB0aGlzLl9jbGlwWSArIG1hcmdpbiArIG1hcmdpbik7XG4gICAgICBpZiAodGhpcy5jbGlwTW9kZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICBjdHguY2xpcCh0aGlzLl9jbGlwUGF0aD8uZ2V0UGF0aDJEKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NsaXBYID4gMCAmJiB0aGlzLl9jbGlwWSA+IDApIHtcbiAgICAgICAgdGhpcy5kcmF3UGF0aChjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xpcE1vZGUgPT09IFwicHVuY2gtb3V0XCIpIHtcbiAgICAgICAgY3R4LmNsaXAodGhpcy5fY2xpcFBhdGg/LmdldFBhdGgyRCgpKTtcbiAgICAgICAgY29uc3QgeyB4ID0gLTFlNCwgeSA9IC0xZTQsIHdpZHRoID0gMmU0LCBoZWlnaHQgPSAyZTQgfSA9IHRoaXMuZ2V0QkJveCgpID8/IHt9O1xuICAgICAgICBjdHguY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3UGF0aChjdHgpO1xuICAgIH1cbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG4gIGRyYXdQYXRoKGN0eCkge1xuICAgIHRoaXMuZmlsbFN0cm9rZShjdHgsIHRoaXMucGF0aC5nZXRQYXRoMkQoKSk7XG4gIH1cbn07XG5QYXRoLmNsYXNzTmFtZSA9IFwiUGF0aFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBNb2RlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBYXCIsIDEpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBZXCIsIDEpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kb20vZm9jdXNTdHlsZXMudHNcbnZhciBmb2N1c1N0eWxlc19leHBvcnRzID0ge307XG5fX2V4cG9ydChmb2N1c1N0eWxlc19leHBvcnRzLCB7XG4gIGJsb2NrOiAoKSA9PiBibG9jayxcbiAgZWxlbWVudHM6ICgpID0+IGVsZW1lbnRzLFxuICBtb2RpZmllcnM6ICgpID0+IG1vZGlmaWVyc1xufSk7XG52YXIgYmxvY2sgPSBcImFnLWNoYXJ0cy1mb2N1c1wiO1xudmFyIGVsZW1lbnRzID0geyBpbmRpY2F0b3I6IFwiYWctY2hhcnRzLWZvY3VzX19pbmRpY2F0b3JcIiwgc3ZnOiBcImFnLWNoYXJ0cy1mb2N1c19fc3ZnXCIgfTtcbnZhciBtb2RpZmllcnMgPSB7IGhpZGRlbjogXCJhZy1jaGFydHMtZm9jdXMtLWhpZGRlblwiIH07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RvbS9mb2N1c0luZGljYXRvci50c1xudmFyIEZvY3VzSW5kaWNhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICBjb25zdCB7IGJsb2NrOiBibG9jazMsIGVsZW1lbnRzOiBlbGVtZW50czMsIG1vZGlmaWVyczogbW9kaWZpZXJzMyB9ID0gZm9jdXNTdHlsZXNfZXhwb3J0cztcbiAgICB0aGlzLmRpdiA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLnN2ZyA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgdGhpcy5wYXRoID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgdGhpcy5zdmcuYXBwZW5kKHRoaXMucGF0aCk7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGJsb2NrMyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoYmxvY2szLCBlbGVtZW50czMuaW5kaWNhdG9yLCBtb2RpZmllcnMzLmhpZGRlbik7XG4gICAgdGhpcy5lbGVtZW50LmFyaWFIaWRkZW4gPSBcInRydWVcIjtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuc3ZnKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoYmxvY2spO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGJsb2NrKTtcbiAgfVxuICB1cGRhdGVCb3VuZHMoYm91bmRzKSB7XG4gICAgaWYgKGJvdW5kcyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChtb2RpZmllcnMuaGlkZGVuKTtcbiAgICB9IGVsc2UgaWYgKGJvdW5kcyBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgIHRoaXMucGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGJvdW5kcy5jb21wdXRlU1ZHRGF0YVBhdGgoKSk7XG4gICAgICB0aGlzLnNob3codGhpcy5zdmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFbGVtZW50QkJveCh0aGlzLmRpdiwgYm91bmRzKTtcbiAgICAgIHRoaXMuc2hvdyh0aGlzLmRpdik7XG4gICAgfVxuICB9XG4gIHNob3coY2hpbGQpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShtb2RpZmllcnMuaGlkZGVuKTtcbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZG9tL2JvdW5kZWRUZXh0LnRzXG52YXIgQm91bmRlZFRleHQgPSBjbGFzcyB7XG4gIHNldCB0ZXh0Q29udGVudCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgY29uc3QgYmJveENhbGN1bGF0b3IgPSB0aGlzLnRleHRFbGVtZW50O1xuICAgIGNvbnN0IGJib3ggPSBiYm94Q2FsY3VsYXRvci5nZXRCQm94Py4oKTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYCR7YmJveC54fSAke2Jib3gueX0gJHtiYm94LndpZHRofSAke2Jib3guaGVpZ2h0fWApO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50ZXh0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwidGV4dFwiKTtcbiAgICB0aGlzLnRleHRFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRleHRFbGVtZW50KTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICB0aGlzLmJvdW5kZWRDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnN2Z0VsZW1lbnQpO1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lci5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyLnJlbW92ZSgpO1xuICB9XG4gIGdldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZGVkQ29udGFpbmVyO1xuICB9XG4gIHVwZGF0ZUJvdW5kcyhib3VuZHMpIHtcbiAgICBzZXRFbGVtZW50QkJveCh0aGlzLmJvdW5kZWRDb250YWluZXIsIGJvdW5kcyk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RvbS9wcm94eUludGVyYWN0aW9uU2VydmljZS50c1xuZnVuY3Rpb24gY2hlY2tUeXBlKHR5cGUsIG1ldGEpIHtcbiAgcmV0dXJuIG1ldGEucGFyYW1zPy50eXBlID09PSB0eXBlO1xufVxuZnVuY3Rpb24gYWxsb2NhdGVSZXN1bHQodHlwZSkge1xuICBpZiAoXCJidXR0b25cIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICB9IGVsc2UgaWYgKFwic2xpZGVyXCIgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICB9IGVsc2UgaWYgKFwidG9vbGJhclwiID09PSB0eXBlIHx8IFwiZ3JvdXBcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB9IGVsc2UgaWYgKFwidGV4dFwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGVkVGV4dCgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKFwiQUcgQ2hhcnRzIC0gZXJyb3IgYWxsb2NhdGluZyBtZXRhXCIpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxvY2F0ZU1ldGEocGFyYW1zKSB7XG4gIGNvbnN0IG1ldGEgPSB7IHBhcmFtcywgcmVzdWx0OiB2b2lkIDAgfTtcbiAgbWV0YS5yZXN1bHQgPSBhbGxvY2F0ZVJlc3VsdChtZXRhLnBhcmFtcy50eXBlKTtcbiAgcmV0dXJuIG1ldGE7XG59XG52YXIgUHJveHlJbnRlcmFjdGlvblNlcnZpY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHVwZGF0ZVNlcnZpY2UsIGxvY2FsZU1hbmFnZXIsIGRvbU1hbmFnZXIsIGZvY3VzSW5kaWNhdG9yKSB7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbG9jYWxlTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IgPSBmb2N1c0luZGljYXRvcjtcbiAgICAvLyBUaGlzIGRlYnVnIG9wdGlvbiBtYWtlIHRoZSBwcm94aWVzIGJ1dHRvbiBwYXJ0aWFsbHkgdHJhbnNwYXJlbnQgaW5zdGVhZCBvZiBmdWxseSB0cmFuc3BhcmVudC5cbiAgICAvLyBUbyBlbmFibGVkIHRoaXMgb3B0aW9uLCBzZXQgd2luZG93LmFnQ2hhcnRzRGVidWcgPSBbJ3Nob3dET01Qcm94aWVzJ10uXG4gICAgdGhpcy5kZWJ1Z1Nob3dET01Qcm94aWVzID0gRGVidWcuY2hlY2soXCJzaG93RE9NUHJveGllc1wiKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCh1cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwidXBkYXRlLWNvbXBsZXRlXCIsICgpID0+IHRoaXMudXBkYXRlKCkpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmZvY3VzYWJsZSkge1xuICAgICAgdGhpcy5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModGhpcy5mb2N1c2FibGUuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpKTtcbiAgICB9XG4gIH1cbiAgYWRkTG9jYWxpc2F0aW9uKGZuKSB7XG4gICAgZm4oKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCh0aGlzLmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCBmbikpO1xuICB9XG4gIGNyZWF0ZVByb3h5Q29udGFpbmVyKGFyZ3MpIHtcbiAgICBjb25zdCBtZXRhID0gYWxsb2NhdGVNZXRhKGFyZ3MpO1xuICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IGRpdiB9ID0gbWV0YTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBwYXJhbXMuaWQsIGRpdik7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoLi4ucGFyYW1zLmNsYXNzTGlzdCk7XG4gICAgZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBkaXYucm9sZSA9IHBhcmFtcy50eXBlO1xuICAgIGRpdi5hcmlhT3JpZW50YXRpb24gPSBwYXJhbXMuYXJpYU9yaWVudGF0aW9uO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmFyaWFIaWRkZW4gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBkaXYuYXJpYUhpZGRlbiA9IHBhcmFtcy5hcmlhSGlkZGVuLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuYWRkTG9jYWxpc2F0aW9uKCgpID0+IHtcbiAgICAgIGRpdi5hcmlhTGFiZWwgPSB0aGlzLmxvY2FsZU1hbmFnZXIudChwYXJhbXMuYXJpYUxhYmVsLmlkLCBwYXJhbXMuYXJpYUxhYmVsLnBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBjcmVhdGVQcm94eUVsZW1lbnQoYXJncykge1xuICAgIGNvbnN0IG1ldGEgPSBhbGxvY2F0ZU1ldGEoYXJncyk7XG4gICAgaWYgKGNoZWNrVHlwZShcImJ1dHRvblwiLCBtZXRhKSkge1xuICAgICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdDogYnV0dG9uIH0gPSBtZXRhO1xuICAgICAgdGhpcy5pbml0SW50ZXJhY3QocGFyYW1zLCBidXR0b24pO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMudGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gcGFyYW1zLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0Q29udGVudCB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLmFkZExvY2FsaXNhdGlvbigoKSA9PiB7XG4gICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGhpcy5sb2NhbGVNYW5hZ2VyLnQodGV4dENvbnRlbnQuaWQsIHRleHRDb250ZW50LnBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hlY2tUeXBlKFwic2xpZGVyXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBzbGlkZXIgfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIHNsaWRlcik7XG4gICAgICBzbGlkZXIudHlwZSA9IFwicmFuZ2VcIjtcbiAgICAgIHNsaWRlci5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgIHNsaWRlci5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgc2xpZGVyLmFyaWFPcmllbnRhdGlvbiA9IHBhcmFtcy5hcmlhT3JpZW50YXRpb247XG4gICAgICB0aGlzLmFkZExvY2FsaXNhdGlvbigoKSA9PiB7XG4gICAgICAgIHNsaWRlci5hcmlhTGFiZWwgPSB0aGlzLmxvY2FsZU1hbmFnZXIudChwYXJhbXMuYXJpYUxhYmVsLmlkLCBwYXJhbXMuYXJpYUxhYmVsLnBhcmFtcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNoZWNrVHlwZShcInRleHRcIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IHRleHQgfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRFbGVtZW50KHBhcmFtcywgdGV4dC5nZXRDb250YWluZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhLnJlc3VsdDtcbiAgfVxuICBpbml0RWxlbWVudChwYXJhbXMsIGVsZW1lbnQyKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50IH0gPSBwYXJhbXM7XG4gICAgZWxlbWVudDIuaWQgPSBpZDtcbiAgICBlbGVtZW50Mi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgZWxlbWVudDIuc3R5bGUub3BhY2l0eSA9IHRoaXMuZGVidWdTaG93RE9NUHJveGllcyA/IFwiMC4yNVwiIDogXCIwXCI7XG4gICAgZWxlbWVudDIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZWxlbWVudDIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQocGFyZW50LCBpZCwgZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICAgIH1cbiAgfVxuICBpbml0SW50ZXJhY3QocGFyYW1zLCBlbGVtZW50Mikge1xuICAgIGNvbnN0IHsgZm9jdXNhYmxlLCBvbmNsaWNrLCBvbmNoYW5nZSwgb25mb2N1cywgb25ibHVyLCB0YWJJbmRleCB9ID0gcGFyYW1zO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQocGFyYW1zLCBlbGVtZW50Mik7XG4gICAgaWYgKHRhYkluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIGVsZW1lbnQyLnRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoX2V2ZW50KSA9PiB7XG4gICAgICB0aGlzLmZvY3VzYWJsZSA9IGZvY3VzYWJsZTtcbiAgICAgIGVsZW1lbnQyLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlckV2ZW50c1wiLCBudWxsKTtcbiAgICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKGZvY3VzYWJsZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCkpO1xuICAgIH0pO1xuICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIChfZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZm9jdXNhYmxlID0gdm9pZCAwO1xuICAgICAgZWxlbWVudDIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgdGhpcy5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgICB9KTtcbiAgICBpZiAob25jbGljaykge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uY2xpY2spO1xuICAgIH1cbiAgICBpZiAob25mb2N1cykge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG9uZm9jdXMpO1xuICAgIH1cbiAgICBpZiAob25ibHVyKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbmJsdXIpO1xuICAgIH1cbiAgICBpZiAob25jaGFuZ2UpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgb25jaGFuZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vYW5pbWF0aW9uQmF0Y2gudHNcbnZhciBBbmltYXRpb25CYXRjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWF4QW5pbWF0aW9uVGltZSkge1xuICAgIHRoaXMubWF4QW5pbWF0aW9uVGltZSA9IG1heEFuaW1hdGlvblRpbWU7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0b3BwZWRDYnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuY3VycmVudFBoYXNlID0gMDtcbiAgICB0aGlzLnBoYXNlcyA9IG5ldyBNYXAoUEhBU0VfT1JERVIubWFwKChwKSA9PiBbcCwgW11dKSk7XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkID0gMDtcbiAgICAvKiogR3VhcmQgYWdhaW5zdCBwcmVtYXR1cmUgYW5pbWF0aW9uIGV4ZWN1dGlvbi4gKi9cbiAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sbGVycy5zaXplO1xuICB9XG4gIGdldCBjb25zdW1lZFRpbWVNcygpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQ7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlcnMuc2l6ZSA+IDA7XG4gIH1cbiAgZ2V0QWN0aXZlQ29udHJvbGxlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGhhc2VzLmdldChQSEFTRV9PUkRFUlt0aGlzLmN1cnJlbnRQaGFzZV0pID8/IFtdO1xuICB9XG4gIGNoZWNrT3ZlcmxhcHBpbmdJZChpZCkge1xuICAgIGlmIChpZCAhPSBudWxsICYmIHRoaXMuY29udHJvbGxlcnMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5jb250cm9sbGVycy5nZXQoaWQpLnN0b3AoKTtcbiAgICAgIHRoaXMuZGVidWcoYFNraXBwaW5nIGFuaW1hdGlvbiBiYXRjaCBkdWUgdG8gdXBkYXRlIG9mIGV4aXN0aW5nIGFuaW1hdGlvbjogJHtpZH1gKTtcbiAgICAgIHRoaXMuc2tpcCgpO1xuICAgIH1cbiAgfVxuICBhZGRBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgaWYgKGFuaW1hdGlvbi5pc0NvbXBsZXRlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFuaW1hdGlvblBoYXNlSWR4ID0gUEhBU0VfT1JERVIuaW5kZXhPZihhbmltYXRpb24ucGhhc2UpO1xuICAgIGlmIChhbmltYXRpb25QaGFzZUlkeCA8IHRoaXMuY3VycmVudFBoYXNlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBTa2lwcGluZyBhbmltYXRpb24gZHVlIHRvIGJlaW5nIGZvciBhbiBlYXJsaWVyIHBoYXNlYCwgYW5pbWF0aW9uLmlkKTtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlcnMuc2V0KGFuaW1hdGlvbi5pZCwgYW5pbWF0aW9uKTtcbiAgICB0aGlzLnBoYXNlcy5nZXQoYW5pbWF0aW9uLnBoYXNlKT8ucHVzaChhbmltYXRpb24pO1xuICB9XG4gIHJlbW92ZUFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzLmRlbGV0ZShhbmltYXRpb24uaWQpO1xuICAgIGNvbnN0IHBoYXNlID0gdGhpcy5waGFzZXMuZ2V0KGFuaW1hdGlvbi5waGFzZSk7XG4gICAgY29uc3QgaW5kZXggPSBwaGFzZT8uaW5kZXhPZihhbmltYXRpb24pO1xuICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4ID49IDApIHtcbiAgICAgIHBoYXNlPy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBwcm9ncmVzcyhkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNSZWFkeSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdW51c2VkVGltZSA9IGRlbHRhVGltZSA9PT0gMCA/IDAuMDEgOiBkZWx0YVRpbWU7XG4gICAgY29uc3QgcmVmcmVzaCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlMiA9IFBIQVNFX09SREVSW3RoaXMuY3VycmVudFBoYXNlXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBoYXNlQ29udHJvbGxlcnM6IFsuLi50aGlzLmdldEFjdGl2ZUNvbnRyb2xsZXJzKCldLFxuICAgICAgICBwaGFzZTogcGhhc2UyLFxuICAgICAgICBwaGFzZU1ldGE6IFBIQVNFX01FVEFEQVRBW3BoYXNlMl1cbiAgICAgIH07XG4gICAgfTtcbiAgICBsZXQgeyBwaGFzZSwgcGhhc2VDb250cm9sbGVycywgcGhhc2VNZXRhIH0gPSByZWZyZXNoKCk7XG4gICAgY29uc3QgYXJlUGhhc2VzQ29tcGxldGUgPSAoKSA9PiBQSEFTRV9PUkRFUlt0aGlzLmN1cnJlbnRQaGFzZV0gPT0gbnVsbDtcbiAgICBjb25zdCBwcm9ncmVzc1BoYXNlID0gKCkgPT4ge1xuICAgICAgKHsgcGhhc2UsIHBoYXNlQ29udHJvbGxlcnMsIHBoYXNlTWV0YSB9ID0gcmVmcmVzaCgpKTtcbiAgICAgIHdoaWxlICghYXJlUGhhc2VzQ29tcGxldGUoKSAmJiBwaGFzZUNvbnRyb2xsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQaGFzZSsrO1xuICAgICAgICAoeyBwaGFzZSwgcGhhc2VDb250cm9sbGVycywgcGhhc2VNZXRhIH0gPSByZWZyZXNoKCkpO1xuICAgICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIHBoYXNlIGNoYW5naW5nIHRvICR7cGhhc2V9YCwgeyB1bnVzZWRUaW1lIH0sIHBoYXNlQ29udHJvbGxlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLmNvbnRyb2xsZXJzLnNpemU7XG4gICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSAke2RlbHRhVGltZX1tczsgcGhhc2UgJHtwaGFzZX0gd2l0aCAke3BoYXNlQ29udHJvbGxlcnM/Lmxlbmd0aH0gb2YgJHt0b3RhbH1gKTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBwaGFzZURlbHRhVGltZSA9IHVudXNlZFRpbWU7XG4gICAgICBjb25zdCBza2lwUGhhc2UgPSBwaGFzZU1ldGEuc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9ucyAmJiB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCA9PT0gMDtcbiAgICAgIGxldCBjb21wbGV0ZUNvdW50ID0gMDtcbiAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBwaGFzZUNvbnRyb2xsZXJzKSB7XG4gICAgICAgIGlmIChza2lwUGhhc2UpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bnVzZWRUaW1lID0gTWF0aC5taW4oY29udHJvbGxlci51cGRhdGUocGhhc2VEZWx0YVRpbWUpLCB1bnVzZWRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgY29tcGxldGVDb3VudCsrO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQW5pbWF0aW9uKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCArPSBwaGFzZURlbHRhVGltZSAtIHVudXNlZFRpbWU7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIHVwZGF0ZWQgJHtwaGFzZUNvbnRyb2xsZXJzLmxlbmd0aH0gY29udHJvbGxlcnM7ICR7Y29tcGxldGVDb3VudH0gY29tcGxldGVkYCk7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIGFuaW1hdGlvblRpbWVDb25zdW1lZDogJHt0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZH1gKTtcbiAgICAgIHByb2dyZXNzUGhhc2UoKTtcbiAgICB9IHdoaWxlICh1bnVzZWRUaW1lID4gMCAmJiAhYXJlUGhhc2VzQ29tcGxldGUoKSk7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkID4gdGhpcy5tYXhBbmltYXRpb25UaW1lKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIFwiQW5pbWF0aW9uIGJhdGNoIGV4Y2VlZGVkIG1heCBhbmltYXRpb24gdGltZSwgc2tpcHBpbmcuXCIsXG4gICAgICAgIG5ldyBNYXAodGhpcy5jb250cm9sbGVycy5lbnRyaWVzKCkpXG4gICAgICApO1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9XG4gIHJlYWR5KCkge1xuICAgIGlmICh0aGlzLmlzUmVhZHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIHJlYWR5OyBza2lwcGVkOiAke3RoaXMuc2tpcEFuaW1hdGlvbnN9YCwgWy4uLnRoaXMuY29udHJvbGxlcnNdKTtcbiAgICBsZXQgc2tpcEFsbCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBbLCBjb250cm9sbGVyXSBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICBpZiAoY29udHJvbGxlci5kdXJhdGlvbiA+IDAgJiYgUEhBU0VfTUVUQURBVEFbY29udHJvbGxlci5waGFzZV0uc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9ucyAhPT0gdHJ1ZSkge1xuICAgICAgICBza2lwQWxsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNraXBBbGwpIHtcbiAgICAgIGZvciAoY29uc3QgWywgY29udHJvbGxlcl0gb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgICBpZiAoY29udHJvbGxlci5hdXRvcGxheSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucGxheSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBza2lwKHNraXAgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc2tpcEFuaW1hdGlvbnMgPT09IGZhbHNlICYmIHNraXAgPT09IHRydWUpIHtcbiAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250cm9sbGVycy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gc2tpcDtcbiAgfVxuICBwbGF5KCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb250cm9sbGVyLnBsYXkoKTtcbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnRyb2xsZXIucGF1c2UoKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5pbWF0aW9uKGNvbnRyb2xsZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKFwiRXJyb3IgZHVyaW5nIGFuaW1hdGlvbiBzdG9wXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaFN0b3BwZWQoKTtcbiAgfVxuICBzdG9wQnlBbmltYXRpb25JZChpZCkge1xuICAgIGlmIChpZCAhPSBudWxsICYmIHRoaXMuY29udHJvbGxlcnMuaGFzKGlkKSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcnMuZ2V0KGlkKTtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZChpZCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoY29udHJvbGxlci5ncm91cElkID09PSBpZCkge1xuICAgICAgICB0aGlzLnN0b3BCeUFuaW1hdGlvbklkKGNvbnRyb2xsZXIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaFN0b3BwZWQoKSB7XG4gICAgdGhpcy5zdG9wcGVkQ2JzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB0aGlzLnN0b3BwZWRDYnMuY2xlYXIoKTtcbiAgfVxuICBpc1NraXBwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcEFuaW1hdGlvbnM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3ByZXZlbnRhYmxlRXZlbnQudHNcbmZ1bmN0aW9uIGJ1aWxkUHJldmVudGFibGUob2JqKSB7XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgLi4ub2JqLFxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgc2VsZi5zb3VyY2VFdmVudD8ucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hUeXBlZEV2ZW50KGxpc3RlbmVycywgZXZlbnQpIHtcbiAgbGlzdGVuZXJzLmRpc3BhdGNoV3JhcEhhbmRsZXJzKGV2ZW50LnR5cGUsIChoYW5kbGVyLCBlKSA9PiBoYW5kbGVyKGUpLCBidWlsZFByZXZlbnRhYmxlKGV2ZW50KSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2ludGVyYWN0aW9uTWFuYWdlci50c1xudmFyIFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMgPSBbXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwiaG92ZXJcIixcbiAgXCJkcmFnLXN0YXJ0XCIsXG4gIFwiZHJhZ1wiLFxuICBcImRyYWctZW5kXCIsXG4gIFwibGVhdmVcIixcbiAgXCJlbnRlclwiLFxuICBcInBhZ2UtbGVmdFwiLFxuICBcIndoZWVsXCJcbl07XG52YXIgRk9DVVNfSU5URVJBQ1RJT05fVFlQRVMgPSBbXCJibHVyXCIsIFwiZm9jdXNcIl07XG52YXIgS0VZX0lOVEVSQUNUSU9OX1RZUEVTID0gW1wia2V5ZG93blwiLCBcImtleXVwXCJdO1xudmFyIFNIQURPV19ET01fSEFORExFUlMgPSBbXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCJdO1xudmFyIFdJTkRPV19FVkVOVF9IQU5ETEVSUyA9IFtcInBhZ2VoaWRlXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiXTtcbnZhciBFVkVOVF9IQU5ETEVSUyA9IFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwiY29udGV4dG1lbnVcIixcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZWxlYXZlXCIsXG4gIFwibW91c2VlbnRlclwiLFxuICBcInRvdWNoc3RhcnRcIixcbiAgXCJ0b3VjaG1vdmVcIixcbiAgXCJ0b3VjaGVuZFwiLFxuICBcInRvdWNoY2FuY2VsXCIsXG4gIFwid2hlZWxcIixcbiAgXCJibHVyXCIsXG4gIFwiZm9jdXNcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5dXBcIlxuXTtcbnZhciBJbnRlcmFjdGlvblN0YXRlID0gLyogQF9fUFVSRV9fICovICgoSW50ZXJhY3Rpb25TdGF0ZTIpID0+IHtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJEZWZhdWx0XCJdID0gMTZdID0gXCJEZWZhdWx0XCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiWm9vbURyYWdcIl0gPSA4XSA9IFwiWm9vbURyYWdcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbm5vdGF0aW9uc1wiXSA9IDRdID0gXCJBbm5vdGF0aW9uc1wiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkNvbnRleHRNZW51XCJdID0gMl0gPSBcIkNvbnRleHRNZW51XCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQW5pbWF0aW9uXCJdID0gMV0gPSBcIkFuaW1hdGlvblwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkFsbFwiXSA9IDMxXSA9IFwiQWxsXCI7XG4gIHJldHVybiBJbnRlcmFjdGlvblN0YXRlMjtcbn0pKEludGVyYWN0aW9uU3RhdGUgfHwge30pO1xudmFyIFBvaW50ZXJDYXB0dXJlID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlckNhcHR1cmUyKSA9PiB7XG4gIFBvaW50ZXJDYXB0dXJlMltcIlJldGFpblwiXSA9IFwicmV0YWluXCI7XG4gIFBvaW50ZXJDYXB0dXJlMltcIkV4Y2x1c2l2ZVwiXSA9IFwiZXhjbHVzaXZlXCI7XG4gIHJldHVybiBQb2ludGVyQ2FwdHVyZTI7XG59KShQb2ludGVyQ2FwdHVyZSB8fCB7fSk7XG52YXIgcG9pbnRlckNhcHR1cmVzID0gbmV3IFNldChPYmplY3QudmFsdWVzKFBvaW50ZXJDYXB0dXJlKSk7XG5mdW5jdGlvbiBpc1BvaW50ZXJFdmVudCh0eXBlKSB7XG4gIHJldHVybiBQT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR5cGUpO1xufVxuZnVuY3Rpb24gaXNGb2N1c0V2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIEZPQ1VTX0lOVEVSQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR5cGUpO1xufVxuZnVuY3Rpb24gaXNLZXlFdmVudCh0eXBlKSB7XG4gIHJldHVybiBLRVlfSU5URVJBQ1RJT05fVFlQRVMuaW5jbHVkZXModHlwZSk7XG59XG52YXIgX0ludGVyYWN0aW9uTWFuYWdlciA9IGNsYXNzIF9JbnRlcmFjdGlvbk1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGtleWJvYXJkT3B0aW9ucywgZG9tTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXlib2FyZE9wdGlvbnMgPSBrZXlib2FyZE9wdGlvbnM7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiaW50ZXJhY3Rpb25cIik7XG4gICAgdGhpcy5ldmVudEhhbmRsZXIgPSAoZXZlbnQpID0+IHRoaXMucHJvY2Vzc0V2ZW50KGV2ZW50KTtcbiAgICB0aGlzLm92ZXJsYXlFdmVudEhhbmRsZXIgPSAoZXZlbnQpID0+IHRoaXMucHJvY2Vzc0NhbnZhc092ZXJsYXlFdmVudChldmVudCk7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLnRvdWNoRG93biA9IGZhbHNlO1xuICAgIHRoaXMucG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpY2tIaXN0b3J5ID0gW3sgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2Vkb3duXCIgfV07XG4gICAgdGhpcy5kYmxjbGlja0hpc3RvcnkgPSBbXG4gICAgICB7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNlZG93blwiIH0sXG4gICAgICB7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNldXBcIiB9LFxuICAgICAgeyBvZmZzZXRYOiBOYU4sIG9mZnNldFk6IE5hTiwgdHlwZTogXCJtb3VzZWRvd25cIiB9XG4gICAgXTtcbiAgICB0aGlzLnN0YXRlUXVldWUgPSAxNiAvKiBEZWZhdWx0ICovIHwgMSAvKiBBbmltYXRpb24gKi87XG4gICAgdGhpcy5yb290RWxlbWVudCA9IHRoaXMuZG9tTWFuYWdlci5nZXREb2N1bWVudFJvb3QoKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSB8fCB0eXBlID09PSBcIndoZWVsXCIpIHtcbiAgICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBXSU5ET1dfRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIGdldFdpbmRvdygpLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyT25FbGVtZW50KFwiY2FudmFzLW92ZXJsYXlcIiwgXCJtb3VzZW92ZXJcIiwgdGhpcy5vdmVybGF5RXZlbnRIYW5kbGVyKSxcbiAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyT25FbGVtZW50KFwiY2FudmFzLW92ZXJsYXlcIiwgXCJtb3VzZW91dFwiLCB0aGlzLm92ZXJsYXlFdmVudEhhbmRsZXIpXG4gICAgKTtcbiAgICB0aGlzLmNvbnRhaW5lckNoYW5nZWQodHJ1ZSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiY29udGFpbmVyLWNoYW5nZWRcIiwgKCkgPT4gdGhpcy5jb250YWluZXJDaGFuZ2VkKCkpO1xuICB9XG4gIGNvbnRhaW5lckNoYW5nZWQoZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5ld1Jvb3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0RG9jdW1lbnRSb290KCk7XG4gICAgaWYgKCFmb3JjZSAmJiBuZXdSb290ID09PSB0aGlzLnJvb3RFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBTSEFET1dfRE9NX0hBTkRMRVJTKSB7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5yb290RWxlbWVudCA9IG5ld1Jvb3Q7XG4gICAgdGhpcy5kZWJ1ZyhcIltJbnRlcmFjdGlvbk1hbmFnZXJdIFN3aXRjaGluZyByb290RWxlbWVudCB0bzpcIiwgdGhpcy5yb290RWxlbWVudCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFNIQURPV19ET01fSEFORExFUlMpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgV0lORE9XX0VWRU5UX0hBTkRMRVJTKSB7XG4gICAgICBnZXRXaW5kb3coKS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFNIQURPV19ET01fSEFORExFUlMpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcImludGVyYWN0aW9uTWFuYWdlclwiKTtcbiAgfVxuICAvLyBXcmFwcGVyIHRvIG9ubHkgYnJvYWRjYXN0IGV2ZW50cyB3aGVuIHRoZSBJbnRlcmFjdGlvbk1hbmFnZXIgaXMgYSBnaXZlbiBzdGF0ZS5cbiAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDE2IC8qIERlZmF1bHQgKi8pIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIodHlwZSwgKGUpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgJiB0cmlnZ2VyaW5nU3RhdGVzKSB7XG4gICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcHVzaFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZVF1ZXVlIHw9IHN0YXRlO1xuICB9XG4gIHBvcFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZVF1ZXVlICY9IH5zdGF0ZTtcbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVF1ZXVlICYgLXRoaXMuc3RhdGVRdWV1ZTtcbiAgfVxuICBwcm9jZXNzQ2FudmFzT3ZlcmxheUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgY29vcmRzID0gdGhpcy5jYWxjdWxhdGVDb29yZGluYXRlcyhldmVudCk7XG4gICAgaWYgKGNvb3JkcyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IHBvaW50ZXJDYXB0dXJlID0gbnVsbDtcbiAgICB3aGlsZSAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgIHBvaW50ZXJDYXB0dXJlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcG9pbnRlci1jYXB0dXJlXCIpO1xuICAgICAgaWYgKHBvaW50ZXJDYXB0dXJlID09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCA9PSBudWxsIHx8IHBvaW50ZXJDYXB0dXJlID09IG51bGwgfHwgIXBvaW50ZXJDYXB0dXJlcy5oYXMocG9pbnRlckNhcHR1cmUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzT3ZlckNhbnZhc092ZXJsYXkgPSBldmVudC50eXBlID09PSBcIm1vdXNlb3ZlclwiO1xuICAgIGNvbnN0IHBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudCA9IGlzT3ZlckNhbnZhc092ZXJsYXkgPyB0YXJnZXQgOiB2b2lkIDA7XG4gICAgaWYgKHRoaXMucG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50ID09PSBwb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5wb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQgPSBwb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQ7XG4gICAgaWYgKHBvaW50ZXJDYXB0dXJlID09PSBcImV4Y2x1c2l2ZVwiIC8qIEV4Y2x1c2l2ZSAqLykge1xuICAgICAgZGlzcGF0Y2hUeXBlZEV2ZW50KFxuICAgICAgICB0aGlzLmxpc3RlbmVycyxcbiAgICAgICAgdGhpcy5idWlsZFBvaW50ZXJFdmVudCh7IHR5cGU6IGlzT3ZlckNhbnZhc092ZXJsYXkgPyBcImxlYXZlXCIgOiBcImVudGVyXCIsIGV2ZW50LCAuLi5jb29yZHMgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NFdmVudChldmVudCkge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmRlY2lkZUludGVyYWN0aW9uRXZlbnRUeXBlcyhldmVudCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGlmIChldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgdGFyZ2V0Py5hcmlhRGlzYWJsZWQgPT09IFwidHJ1ZVwiKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHR5cGUpLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZSkge1xuICAgIGlmIChpc1BvaW50ZXJFdmVudCh0eXBlKSkge1xuICAgICAgdGhpcy5kaXNwYXRjaFBvaW50ZXJFdmVudChldmVudCwgdHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSA9IHRoaXMuZXh0cmFjdEVsZW1lbnRzKGV2ZW50KTtcbiAgICBpZiAoaXNGb2N1c0V2ZW50KHR5cGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgZGlzcGF0Y2hUeXBlZEV2ZW50KHRoaXMubGlzdGVuZXJzLCB7IHR5cGUsIHNvdXJjZUV2ZW50LCByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9KTtcbiAgICB9IGVsc2UgaWYgKGlzS2V5RXZlbnQodHlwZSkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQ7XG4gICAgICBkaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHsgdHlwZSwgc291cmNlRXZlbnQsIHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0pO1xuICAgIH1cbiAgfVxuICBleHRyYWN0RWxlbWVudHMoZXZlbnQpIHtcbiAgICBsZXQgcmVsYXRlZEVsZW1lbnQ7XG4gICAgbGV0IHRhcmdldEVsZW1lbnQ7XG4gICAgaWYgKFwicmVsYXRlZFRhcmdldFwiIGluIGV2ZW50ICYmIGV2ZW50W1wicmVsYXRlZFRhcmdldFwiXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZWxhdGVkRWxlbWVudCA9IGV2ZW50W1wicmVsYXRlZFRhcmdldFwiXTtcbiAgICB9XG4gICAgaWYgKFwidGFyZ2V0XCIgaW4gZXZlbnQgJiYgZXZlbnRbXCJ0YXJnZXRcIl0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGFyZ2V0RWxlbWVudCA9IGV2ZW50W1widGFyZ2V0XCJdO1xuICAgIH1cbiAgICByZXR1cm4geyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9O1xuICB9XG4gIGRpc3BhdGNoUG9pbnRlckV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gICAgY29uc3QgY29vcmRzID0gdGhpcy5jYWxjdWxhdGVDb29yZGluYXRlcyhldmVudCk7XG4gICAgaWYgKGNvb3JkcyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgdGhpcy5idWlsZFBvaW50ZXJFdmVudCh7IHR5cGUsIGV2ZW50LCAuLi5jb29yZHMgfSkpO1xuICB9XG4gIGdldEV2ZW50SFRNTFRhcmdldChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmVjb3JkRG93bihldmVudCkge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuY2xpY2tIaXN0b3J5WzBdLCBldmVudCk7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVsyXSwgdGhpcy5kYmxjbGlja0hpc3RvcnlbMF0pO1xuICAgICAgcGFydGlhbEFzc2lnbihbXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiXSwgdGhpcy5kYmxjbGlja0hpc3RvcnlbMF0sIGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5kcmFnU3RhcnRFbGVtZW50ID0gdGhpcy5nZXRFdmVudEhUTUxUYXJnZXQoZXZlbnQpO1xuICB9XG4gIHJlY29yZFVwKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgcGFydGlhbEFzc2lnbihbXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiXSwgdGhpcy5kYmxjbGlja0hpc3RvcnlbMV0sIGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5kcmFnU3RhcnRFbGVtZW50ID0gdm9pZCAwO1xuICB9XG4gIGRlY2lkZUludGVyYWN0aW9uRXZlbnRUeXBlcyhldmVudCkge1xuICAgIGNvbnN0IGRyYWdTdGFydCA9IFwiZHJhZy1zdGFydFwiO1xuICAgIGlmICh0aGlzLnBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudD8uaXNDb25uZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgY2FzZSBcImZvY3VzXCI6XG4gICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmtleWJvYXJkT3B0aW9ucy5lbmFibGVkID8gZXZlbnQudHlwZSA6IHZvaWQgMDtcbiAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgY2FzZSBcImRibGNsaWNrXCI6XG4gICAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICAgIGNhc2UgXCJ3aGVlbFwiOlxuICAgICAgICByZXR1cm4gZXZlbnQudHlwZTtcbiAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgaWYgKCF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29yZERvd24oZXZlbnQpO1xuICAgICAgICByZXR1cm4gZHJhZ1N0YXJ0O1xuICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgaWYgKCF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaERvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29yZERvd24oZXZlbnQpO1xuICAgICAgICByZXR1cm4gZHJhZ1N0YXJ0O1xuICAgICAgY2FzZSBcInRvdWNobW92ZVwiOlxuICAgICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duICYmICF0aGlzLnRvdWNoRG93biAmJiAhdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93biB8fCB0aGlzLnRvdWNoRG93biA/IFwiZHJhZ1wiIDogXCJob3ZlclwiO1xuICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93biAmJiAhdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb3JkVXAoZXZlbnQpO1xuICAgICAgICByZXR1cm4gXCJkcmFnLWVuZFwiO1xuICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgIGlmICghdGhpcy50b3VjaERvd24gJiYgIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoRG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29yZFVwKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIFwiZHJhZy1lbmRcIjtcbiAgICAgIGNhc2UgXCJtb3VzZWxlYXZlXCI6XG4gICAgICBjYXNlIFwidG91Y2hjYW5jZWxcIjpcbiAgICAgICAgcmV0dXJuIFwibGVhdmVcIjtcbiAgICAgIGNhc2UgXCJtb3VzZWVudGVyXCI6XG4gICAgICAgIHJldHVybiBcImVudGVyXCI7XG4gICAgICBjYXNlIFwicGFnZWhpZGVcIjpcbiAgICAgICAgcmV0dXJuIFwicGFnZS1sZWZ0XCI7XG4gICAgfVxuICB9XG4gIGlzRXZlbnRPdmVyRWxlbWVudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLmRvbU1hbmFnZXIuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KTtcbiAgfVxuICBjYWxjdWxhdGVDb29yZGluYXRlcyhldmVudCkge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1vdXNlRXZlbnRDb29yZHMoZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIFRvdWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICBjb25zdCBsYXN0VG91Y2ggPSBldmVudC50b3VjaGVzWzBdID8/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVkgfSA9IGxhc3RUb3VjaDtcbiAgICAgIHJldHVybiB7IC4uLl9JbnRlcmFjdGlvbk1hbmFnZXIuTlVMTF9DT09SRFMsIGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBQYWdlVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQucGVyc2lzdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfSW50ZXJhY3Rpb25NYW5hZ2VyLk5VTExfQ09PUkRTO1xuICAgIH1cbiAgfVxuICBnZXRNb3VzZUV2ZW50Q29vcmRzKGV2ZW50KSB7XG4gICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVkgfSA9IGV2ZW50O1xuICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0RXZlbnRIVE1MVGFyZ2V0KGV2ZW50KTtcbiAgICBjb25zdCB7IHggPSAwLCB5ID0gMCB9ID0gdGFyZ2V0ID8gdGhpcy5kb21NYW5hZ2VyLmNhbGN1bGF0ZUNhbnZhc1Bvc2l0aW9uKHRhcmdldCkgOiB7fTtcbiAgICBpZiAodGhpcy5kcmFnU3RhcnRFbGVtZW50ICE9IG51bGwgJiYgZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRyYWdTdGFydEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldERyYWdTdGFydCA9IHRoaXMuZG9tTWFuYWdlci5jYWxjdWxhdGVDYW52YXNQb3NpdGlvbih0aGlzLmRyYWdTdGFydEVsZW1lbnQpO1xuICAgICAgb2Zmc2V0WCAtPSBvZmZzZXREcmFnU3RhcnQueCAtIHg7XG4gICAgICBvZmZzZXRZIC09IG9mZnNldERyYWdTdGFydC55IC0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0WCArPSB4O1xuICAgICAgb2Zmc2V0WSArPSB5O1xuICAgIH1cbiAgICByZXR1cm4geyBjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVksIG9mZnNldFgsIG9mZnNldFkgfTtcbiAgfVxuICBpc1doZWVsRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJ3aGVlbFwiO1xuICB9XG4gIGJ1aWxkUG9pbnRlckV2ZW50KG9wdHMpIHtcbiAgICBjb25zdCB7IHR5cGUsIGV2ZW50LCBjbGllbnRYLCBjbGllbnRZIH0gPSBvcHRzO1xuICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFksIHBhZ2VYLCBwYWdlWSB9ID0gb3B0cztcbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKG9mZnNldFgpIHx8ICFpc0Zpbml0ZU51bWJlcihvZmZzZXRZKSkge1xuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZG9tTWFuYWdlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG9mZnNldFggPSBjbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgb2Zmc2V0WSA9IGNsaWVudFkgLSByZWN0LnRvcDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwYWdlWCkgfHwgIWlzRmluaXRlTnVtYmVyKHBhZ2VZKSkge1xuICAgICAgY29uc3QgcGFnZVJlY3QgPSB0aGlzLnJvb3RFbGVtZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHBhZ2VYID0gY2xpZW50WCAtIChwYWdlUmVjdD8ubGVmdCA/PyAwKTtcbiAgICAgIHBhZ2VZID0gY2xpZW50WSAtIChwYWdlUmVjdD8udG9wID8/IDApO1xuICAgIH1cbiAgICBsZXQgW2RlbHRhWCwgZGVsdGFZXSA9IFtOYU4sIE5hTl07XG4gICAgaWYgKHRoaXMuaXNXaGVlbEV2ZW50KGV2ZW50KSkge1xuICAgICAgY29uc3QgZmFjdG9yID0gZXZlbnQuZGVsdGFNb2RlID09PSAwID8gMC4wMSA6IDE7XG4gICAgICBkZWx0YVggPSBldmVudC5kZWx0YVggKiBmYWN0b3I7XG4gICAgICBkZWx0YVkgPSBldmVudC5kZWx0YVkgKiBmYWN0b3I7XG4gICAgfVxuICAgIGxldCBwb2ludGVySGlzdG9yeSA9IFtdO1xuICAgIGlmIChldmVudC50eXBlID09PSBcImNsaWNrXCIpIHtcbiAgICAgIHBvaW50ZXJIaXN0b3J5ID0gdGhpcy5jbGlja0hpc3Rvcnk7XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBcImRibGNsaWNrXCIpIHtcbiAgICAgIHBvaW50ZXJIaXN0b3J5ID0gdGhpcy5kYmxjbGlja0hpc3Rvcnk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSA9IHRoaXMuZXh0cmFjdEVsZW1lbnRzKGV2ZW50KTtcbiAgICBjb25zdCBidXR0b24gPSBcImJ1dHRvblwiIGluIGV2ZW50ID8gTnVtYmVyKGV2ZW50LmJ1dHRvbikgOiAwO1xuICAgIGNvbnN0IGJ1aWx0RXZlbnQgPSB7XG4gICAgICB0eXBlLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZLFxuICAgICAgZGVsdGFYLFxuICAgICAgZGVsdGFZLFxuICAgICAgYnV0dG9uLFxuICAgICAgcG9pbnRlckhpc3RvcnksXG4gICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICByZWxhdGVkRWxlbWVudCxcbiAgICAgIHRhcmdldEVsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuZGVidWcoXCJJbnRlcmFjdGlvbk1hbmFnZXIgLSBidWlsdEV2ZW50OiBcIiwgYnVpbHRFdmVudCk7XG4gICAgcmV0dXJuIGJ1aWx0RXZlbnQ7XG4gIH1cbn07XG5fSW50ZXJhY3Rpb25NYW5hZ2VyLk5VTExfQ09PUkRTID0ge1xuICBjbGllbnRYOiAtSW5maW5pdHksXG4gIGNsaWVudFk6IC1JbmZpbml0eSxcbiAgcGFnZVg6IC1JbmZpbml0eSxcbiAgcGFnZVk6IC1JbmZpbml0eSxcbiAgb2Zmc2V0WDogLUluZmluaXR5LFxuICBvZmZzZXRZOiAtSW5maW5pdHlcbn07XG52YXIgSW50ZXJhY3Rpb25NYW5hZ2VyID0gX0ludGVyYWN0aW9uTWFuYWdlcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vYW5pbWF0aW9uTWFuYWdlci50c1xuZnVuY3Rpb24gdmFsaWRBbmltYXRpb25EdXJhdGlvbih0ZXN0ZWUpIHtcbiAgaWYgKHRlc3RlZSA9PSBudWxsKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gIWlzTmFOKHRlc3RlZSkgJiYgdGVzdGVlID49IDAgJiYgdGVzdGVlIDw9IDI7XG59XG52YXIgQW5pbWF0aW9uTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihpbnRlcmFjdGlvbk1hbmFnZXIsIGNoYXJ0VXBkYXRlTXV0ZXgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gaW50ZXJhY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVNdXRleCA9IGNoYXJ0VXBkYXRlTXV0ZXg7XG4gICAgdGhpcy5kZWZhdWx0RHVyYXRpb24gPSAxZTM7XG4gICAgdGhpcy5iYXRjaCA9IG5ldyBBbmltYXRpb25CYXRjaCh0aGlzLmRlZmF1bHREdXJhdGlvbiAqIDEuNSk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLnJhZkF2YWlsYWJsZSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEFub255bW91c0FuaW1hdGlvbklkID0gMDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiB0byB0d2VlbiBhIHZhbHVlIGJldHdlZW4gdGhlIGBmcm9tYCBhbmQgYHRvYCBwcm9wZXJ0aWVzLiBJZiBhbiBhbmltYXRpb24gYWxyZWFkeSBleGlzdHNcbiAgICogd2l0aCB0aGUgc2FtZSBgaWRgLCBpbW1lZGlhdGVseSBzdG9wIGl0LlxuICAgKi9cbiAgYW5pbWF0ZSh7IC4uLm9wdHMgfSkge1xuICAgIGNvbnN0IGJhdGNoID0gdGhpcy5iYXRjaDtcbiAgICB0cnkge1xuICAgICAgYmF0Y2guY2hlY2tPdmVybGFwcGluZ0lkKG9wdHMuaWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IGlkIH0gPSBvcHRzO1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBpZCA9IGBfXyR7dGhpcy5jdXJyZW50QW5vbnltb3VzQW5pbWF0aW9uSWR9YDtcbiAgICAgIHRoaXMuY3VycmVudEFub255bW91c0FuaW1hdGlvbklkICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IHNraXAgPSB0aGlzLmlzU2tpcHBlZCgpIHx8IG9wdHMucGhhc2UgPT09IFwibm9uZVwiO1xuICAgIGlmIChza2lwKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlciAtIHNraXBwaW5nIGFuaW1hdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBkZWxheSwgZHVyYXRpb24gfSA9IG9wdHM7XG4gICAgaWYgKCF2YWxpZEFuaW1hdGlvbkR1cmF0aW9uKGRlbGF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRpb24gZGVsYXkgb2YgJHtkZWxheX0gaXMgdW5zdXBwb3J0ZWQgKCR7aWR9KWApO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkQW5pbWF0aW9uRHVyYXRpb24oZHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuaW1hdGlvbiBkdXJhdGlvbiBvZiAke2R1cmF0aW9ufSBpcyB1bnN1cHBvcnRlZCAoJHtpZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGlkLFxuICAgICAgc2tpcCxcbiAgICAgIGF1dG9wbGF5OiB0aGlzLmlzUGxheWluZyA/IG9wdHMuYXV0b3BsYXkgOiBmYWxzZSxcbiAgICAgIHBoYXNlOiBvcHRzLnBoYXNlLFxuICAgICAgZGVmYXVsdER1cmF0aW9uOiB0aGlzLmRlZmF1bHREdXJhdGlvblxuICAgIH0pO1xuICAgIGlmICh0aGlzLmZvcmNlVGltZUp1bXAoYW5pbWF0aW9uLCB0aGlzLmRlZmF1bHREdXJhdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5iYXRjaC5hZGRBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9XG4gIHBsYXkoKSB7XG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlci5wbGF5KClcIik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmF0Y2gucGxheSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbigpO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGlmICghdGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyLnBhdXNlKClcIik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmF0Y2gucGF1c2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlci5zdG9wKClcIik7XG4gICAgdGhpcy5iYXRjaC5zdG9wKCk7XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uSWQoaWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5zdG9wQnlBbmltYXRpb25JZChpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZChpZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQoaWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9XG4gIHNraXAoc2tpcCA9IHRydWUpIHtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gc2tpcDtcbiAgfVxuICBpc1NraXBwZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLnJhZkF2YWlsYWJsZSB8fCB0aGlzLnNraXBBbmltYXRpb25zIHx8IHRoaXMuYmF0Y2guaXNTa2lwcGVkKCk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQbGF5aW5nICYmIHRoaXMuYmF0Y2guaXNBY3RpdmUoKTtcbiAgfVxuICBza2lwQ3VycmVudEJhdGNoKCkge1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbk1hbmFnZXIgLSBza2lwQ3VycmVudEJhdGNoKClgLCB7IHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaC5za2lwKCk7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIGd1YXJhbnRlZSB0aGF0IGFuaW1hdGlvbiB1cGRhdGVzIGhhcHBlbi4gKi9cbiAgaXNTa2lwcGluZ0ZyYW1lcygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gY2FwdHVyZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2tzLiAqL1xuICBzY2hlZHVsZUFuaW1hdGlvbkZyYW1lKGNiKSB7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICB9XG4gIC8qKiBNb2NraW5nIHBvaW50IGZvciB0ZXN0cyB0byBza2lwIGFuaW1hdGlvbnMgdG8gYSBzcGVjaWZpYyBwb2ludCBpbiB0aW1lLiAqL1xuICBmb3JjZVRpbWVKdW1wKF9hbmltYXRpb24sIF9kZWZhdWx0RHVyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVxdWVzdEFuaW1hdGlvbigpIHtcbiAgICBpZiAoIXRoaXMucmFmQXZhaWxhYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghdGhpcy5iYXRjaC5pc0FjdGl2ZSgpIHx8IHRoaXMucmVxdWVzdElkICE9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBwcmV2VGltZTtcbiAgICBjb25zdCBvbkFuaW1hdGlvbkZyYW1lID0gYXN5bmMgKHRpbWUyKSA9PiB7XG4gICAgICBjb25zdCBleGVjdXRlQW5pbWF0aW9uRnJhbWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWUyIC0gKHByZXZUaW1lID8/IHRpbWUyKTtcbiAgICAgICAgcHJldlRpbWUgPSB0aW1lMjtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIgLSBvbkFuaW1hdGlvbkZyYW1lKClcIiwge1xuICAgICAgICAgIGNvbnRyb2xsZXJzQ291bnQ6IHRoaXMuYmF0Y2guc2l6ZSxcbiAgICAgICAgICBkZWx0YVRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnB1c2hTdGF0ZSgxIC8qIEFuaW1hdGlvbiAqLyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5iYXRjaC5wcm9ncmVzcyhkZWx0YVRpbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImFuaW1hdGlvbi1mcmFtZVwiLCB7XG4gICAgICAgICAgdHlwZTogXCJhbmltYXRpb24tZnJhbWVcIixcbiAgICAgICAgICBkZWx0YU1zOiBkZWx0YVRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuaXNTa2lwcGluZ0ZyYW1lcygpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlSW1tZWRpYXRlbHkoZXhlY3V0ZUFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlKGV4ZWN1dGVBbmltYXRpb25GcmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5iYXRjaC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmF0Y2guc3RvcCgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImFuaW1hdGlvbi1zdG9wXCIsIHtcbiAgICAgICAgICB0eXBlOiBcImFuaW1hdGlvbi1zdG9wXCIsXG4gICAgICAgICAgZGVsdGFNczogdGhpcy5iYXRjaC5jb25zdW1lZFRpbWVNc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYW5pbWF0aW9uLXN0YXJ0XCIsIHtcbiAgICAgIHR5cGU6IFwiYW5pbWF0aW9uLXN0YXJ0XCIsXG4gICAgICBkZWx0YU1zOiAwXG4gICAgfSk7XG4gICAgdGhpcy5zY2hlZHVsZUFuaW1hdGlvbkZyYW1lKG9uQW5pbWF0aW9uRnJhbWUpO1xuICB9XG4gIGNhbmNlbEFuaW1hdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0SWQgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0SWQpO1xuICAgIHRoaXMucmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgfVxuICBmYWlsc2FmZU9uRXJyb3IoZXJyb3IsIGNhbmNlbEFuaW1hdGlvbiA9IHRydWUpIHtcbiAgICBMb2dnZXIuZXJyb3IoXCJFcnJvciBkdXJpbmcgYW5pbWF0aW9uLCBza2lwcGluZyBhbmltYXRpb25zXCIsIGVycm9yKTtcbiAgICBpZiAoY2FuY2VsQW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuICAgIH1cbiAgfVxuICBzdGFydEJhdGNoKHNraXBBbmltYXRpb25zKSB7XG4gICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uTWFuYWdlciAtIHN0YXJ0QmF0Y2goKSB3aXRoIHNraXBBbmltYXRpb25zPSR7c2tpcEFuaW1hdGlvbnN9LmApO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmJhdGNoLnN0b3AoKTtcbiAgICB0aGlzLmJhdGNoLmRlc3Ryb3koKTtcbiAgICB0aGlzLmJhdGNoID0gbmV3IEFuaW1hdGlvbkJhdGNoKHRoaXMuZGVmYXVsdER1cmF0aW9uICogMS41KTtcbiAgICBpZiAoc2tpcEFuaW1hdGlvbnMgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuYmF0Y2guc2tpcCgpO1xuICAgIH1cbiAgfVxuICBlbmRCYXRjaCgpIHtcbiAgICBpZiAodGhpcy5iYXRjaC5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmJhdGNoLnJlYWR5KCk7XG4gICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIucG9wU3RhdGUoMSAvKiBBbmltYXRpb24gKi8pO1xuICAgICAgaWYgKHRoaXMuYmF0Y2guaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgdGhpcy5iYXRjaC5za2lwKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25CYXRjaFN0b3AoY2IpIHtcbiAgICB0aGlzLmJhdGNoLnN0b3BwZWRDYnMuYWRkKGNiKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vYXJpYUFubm91bmNlbWVudFNlcnZpY2VzLnRzXG52YXIgQXJpYUFubm91bmNlbWVudFNlcnZpY2UgPSBjbGFzcyBfQXJpYUFubm91bmNlbWVudFNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihsb2NhbGVNYW5hZ2VyLCBkb21NYW5hZ2VyLCBsYXlvdXRTZXJ2aWNlKSB7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbG9jYWxlTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMubGF5b3V0U2VydmljZSA9IGxheW91dFNlcnZpY2U7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFyaWFcIik7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5saXZlRWxlbSA9IF9BcmlhQW5ub3VuY2VtZW50U2VydmljZS5jcmVhdGVBbm5vdW5jZXIoKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtcHJveHlcIiwgXCJhZy1jaGFydHMtY2FudmFzLXByb3h5XCIsIHRoaXMubGl2ZUVsZW0pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChldikgPT4gdGhpcy5vblJlc2l6ZShldikpLFxuICAgICAgKCkgPT4gdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLXByb3h5XCIsIFwiYWctY2hhcnRzLWNhbnZhcy1wcm94eVwiKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUFubm91bmNlcigpIHtcbiAgICBjb25zdCBlID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGUuY2xhc3NMaXN0LmFkZChcImFnLWNoYXJ0cy1hcmlhLWFubm91bmNlclwiKTtcbiAgICBzZXRBdHRyaWJ1dGUoZSwgXCJyb2xlXCIsIFwic3RhdHVzXCIpO1xuICAgIHNldEF0dHJpYnV0ZShlLCBcImFyaWEtbGl2ZVwiLCBcImFzc2VydGl2ZVwiKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbiAgb25SZXNpemUoZXZlbnQpIHtcbiAgICB0aGlzLmxpdmVFbGVtLnN0eWxlLndpZHRoID0gYCR7ZXZlbnQuY2hhcnQud2lkdGh9cHhgO1xuICAgIHRoaXMubGl2ZUVsZW0uc3R5bGUuaGVpZ2h0ID0gYCR7ZXZlbnQuY2hhcnQuaGVpZ2h0fXB4YDtcbiAgfVxuICBhbm5vdW5jZVZhbHVlKGlkLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IGxvY2FsZU1hbmFnZXIsIGxpdmVFbGVtIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhbHVlID0gbG9jYWxlTWFuYWdlci50KGlkLCBwYXJhbXMpO1xuICAgIHRoaXMuZGVidWcoYEFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlIC0gYW5ub3VuY2VWYWx1ZTogJHt2YWx1ZX1gKTtcbiAgICBsaXZlRWxlbS50ZXh0Q29udGVudCA9IFwiXFx4QTBcIjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IGxpdmVFbGVtLmlubmVyVGV4dCA9IHZhbHVlLCAxNik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2NoYXJ0RXZlbnRNYW5hZ2VyLnRzXG52YXIgQ2hhcnRFdmVudE1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgbGVnZW5kSXRlbUNsaWNrKHNlcmllcywgaXRlbUlkLCBlbmFibGVkLCBsZWdlbmRJdGVtTmFtZSkge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJsZWdlbmQtaXRlbS1jbGlja1wiLFxuICAgICAgc2VyaWVzLFxuICAgICAgaXRlbUlkLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImxlZ2VuZC1pdGVtLWNsaWNrXCIsIGV2ZW50KTtcbiAgfVxuICBsZWdlbmRJdGVtRG91YmxlQ2xpY2soc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQsIG51bVZpc2libGVJdGVtcywgbGVnZW5kSXRlbU5hbWUpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwibGVnZW5kLWl0ZW0tZG91YmxlLWNsaWNrXCIsXG4gICAgICBzZXJpZXMsXG4gICAgICBpdGVtSWQsXG4gICAgICBlbmFibGVkLFxuICAgICAgbGVnZW5kSXRlbU5hbWUsXG4gICAgICBudW1WaXNpYmxlSXRlbXNcbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwibGVnZW5kLWl0ZW0tZG91YmxlLWNsaWNrXCIsIGV2ZW50KTtcbiAgfVxuICBheGlzSG92ZXIoYXhpc0lkLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwiYXhpcy1ob3ZlclwiLFxuICAgICAgYXhpc0lkLFxuICAgICAgZGlyZWN0aW9uXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImF4aXMtaG92ZXJcIiwgZXZlbnQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9jb250ZXh0TWVudVJlZ2lzdHJ5LnRzXG52YXIgQ29udGV4dE1lbnVSZWdpc3RyeSA9IGNsYXNzIF9Db250ZXh0TWVudVJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IocmVnaW9uTWFuYWdlcikge1xuICAgIHRoaXMuZGVmYXVsdEFjdGlvbnMgPSBbXTtcbiAgICB0aGlzLmRpc2FibGVkQWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5oaWRkZW5BY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB7IERlZmF1bHQ6IERlZmF1bHQyLCBDb250ZXh0TWVudSB9ID0gSW50ZXJhY3Rpb25TdGF0ZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbcmVnaW9uTWFuYWdlci5saXN0ZW5BbGwoXCJjb250ZXh0bWVudVwiLCAoZSkgPT4gdGhpcy5vbkNvbnRleHRNZW51KGUpLCBEZWZhdWx0MiB8IENvbnRleHRNZW51KV07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgfVxuICBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgY29uc3QgdHlwZSA9IF9Db250ZXh0TWVudVJlZ2lzdHJ5LnRvQ29udGV4dFR5cGUoZXZlbnQucmVnaW9uKTtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaENvbnRleHQoXCJhbGxcIiwgZXZlbnQsIHt9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRvQ29udGV4dFR5cGUocmVnaW9uKSB7XG4gICAgaWYgKHJlZ2lvbiA9PT0gXCJsZWdlbmRcIiB8fCByZWdpb24gPT09IFwic2VyaWVzXCIpIHtcbiAgICAgIHJldHVybiByZWdpb247XG4gICAgfVxuICAgIHJldHVybiBcImFsbFwiO1xuICB9XG4gIHN0YXRpYyBjaGVjayh0eXBlLCBldmVudCkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSB0eXBlO1xuICB9XG4gIHN0YXRpYyBjaGVja0NhbGxiYWNrKGRlc2lyZWRUeXBlLCB0eXBlLCBfY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZGVzaXJlZFR5cGUgPT09IHR5cGU7XG4gIH1cbiAgZGlzcGF0Y2hDb250ZXh0KHR5cGUsIHBvaW50ZXJFdmVudCwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0WDogeCwgb2Zmc2V0WTogeSwgc291cmNlRXZlbnQgfSA9IHBvaW50ZXJFdmVudDtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcIlwiLCBidWlsZFByZXZlbnRhYmxlKHsgdHlwZSwgeCwgeSwgY29udGV4dCwgc291cmNlRXZlbnQgfSkpO1xuICB9XG4gIGFkZExpc3RlbmVyKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuYWRkTGlzdGVuZXIoXCJcIiwgaGFuZGxlcik7XG4gIH1cbiAgZmlsdGVyQWN0aW9ucyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEFjdGlvbnMuZmlsdGVyKChhY3Rpb24pID0+IHtcbiAgICAgIHJldHVybiBhY3Rpb24uaWQgJiYgIXRoaXMuaGlkZGVuQWN0aW9ucy5oYXMoYWN0aW9uLmlkKSAmJiBbXCJhbGxcIiwgdHlwZV0uaW5jbHVkZXMoYWN0aW9uLnR5cGUpO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRGVmYXVsdEFjdGlvbihhY3Rpb24pIHtcbiAgICBpZiAoYWN0aW9uLmlkICYmIHRoaXMuZGVmYXVsdEFjdGlvbnMuZmluZCgoeyBpZCB9KSA9PiBpZCA9PT0gYWN0aW9uLmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRBY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfVxuICBlbmFibGVBY3Rpb24oYWN0aW9uSWQpIHtcbiAgICB0aGlzLmRpc2FibGVkQWN0aW9ucy5kZWxldGUoYWN0aW9uSWQpO1xuICB9XG4gIGRpc2FibGVBY3Rpb24oYWN0aW9uSWQpIHtcbiAgICB0aGlzLmRpc2FibGVkQWN0aW9ucy5hZGQoYWN0aW9uSWQpO1xuICB9XG4gIHNldEFjdGlvblZpc2libGl0eShhY3Rpb25JZCwgdmlzaWJsZSkge1xuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICB0aGlzLmhpZGRlbkFjdGlvbnMuZGVsZXRlKGFjdGlvbklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRkZW5BY3Rpb25zLmFkZChhY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIGlzRGlzYWJsZWQoYWN0aW9uSWQpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZEFjdGlvbnMuaGFzKGFjdGlvbklkKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zdGF0ZVRyYWNrZXIudHNcbnZhciBTdGF0ZVRyYWNrZXIgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSwgZGVmYXVsdFN0YXRlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0ZUlkKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5cygpKS5wb3AoKSA/PyB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgfVxuICBzdGF0ZVZhbHVlKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpLnBvcCgpID8/IHRoaXMuZGVmYXVsdFZhbHVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9jdXJzb3JNYW5hZ2VyLnRzXG52YXIgQ3Vyc29yID0gLyogQF9fUFVSRV9fICovICgoQ3Vyc29yMikgPT4ge1xuICBDdXJzb3IyW1wiQXV0b1wiXSA9IFwiYXV0b1wiO1xuICBDdXJzb3IyW1wiRGVmYXVsdFwiXSA9IFwiZGVmYXVsdFwiO1xuICBDdXJzb3IyW1wiR3JhYlwiXSA9IFwiZ3JhYlwiO1xuICBDdXJzb3IyW1wiR3JhYmJpbmdcIl0gPSBcImdyYWJiaW5nXCI7XG4gIEN1cnNvcjJbXCJNb3ZlXCJdID0gXCJtb3ZlXCI7XG4gIEN1cnNvcjJbXCJOb3RBbGxvd2VkXCJdID0gXCJub3QtYWxsb3dlZFwiO1xuICBDdXJzb3IyW1wiUG9pbnRlclwiXSA9IFwicG9pbnRlclwiO1xuICBDdXJzb3IyW1wiRVdSZXNpemVcIl0gPSBcImV3LXJlc2l6ZVwiO1xuICBDdXJzb3IyW1wiTlNSZXNpemVcIl0gPSBcIm5zLXJlc2l6ZVwiO1xuICBDdXJzb3IyW1wiWm9vbUluXCJdID0gXCJ6b29tLWluXCI7XG4gIEN1cnNvcjJbXCJab29tT3V0XCJdID0gXCJ6b29tLW91dFwiO1xuICByZXR1cm4gQ3Vyc29yMjtcbn0pKEN1cnNvciB8fCB7fSk7XG52YXIgQ3Vyc29yTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlcikge1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIgPSBuZXcgU3RhdGVUcmFja2VyKFwiZGVmYXVsdFwiKTtcbiAgfVxuICB1cGRhdGVDdXJzb3IoY2FsbGVySWQsIHN0eWxlKSB7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIuc2V0KGNhbGxlcklkLCBzdHlsZSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLnN0YXRlVHJhY2tlci5zdGF0ZVZhbHVlKCkpO1xuICB9XG4gIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kb21NYW5hZ2VyLmdldEN1cnNvcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9nZXN0dXJlRGV0ZWN0b3IudHNcbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlZChmaW5nZXIxLCBmaW5nZXIyKSB7XG4gIGNvbnN0IGR4ID0gZmluZ2VyMS5zY3JlZW5YIC0gZmluZ2VyMi5zY3JlZW5YO1xuICBjb25zdCBkeSA9IGZpbmdlcjEuc2NyZWVuWSAtIGZpbmdlcjIuc2NyZWVuWTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuZnVuY3Rpb24gZGlzdGFuY2UoZmluZ2VyMSwgZmluZ2VyMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZChmaW5nZXIxLCBmaW5nZXIyKSk7XG59XG52YXIgTUlOX0RJU1RBTkNFX1RPX1NUQVJUX1BJTkNIID0gMTtcbnZhciBHZXN0dXJlRGV0ZWN0b3IgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLnRvdWNoc3RhcnQgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLnRvdWNobW92ZSA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoTW92ZShldmVudCk7XG4gICAgdGhpcy50b3VjaGVuZCA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoRW5kKGV2ZW50KTtcbiAgICB0aGlzLnRvdWNoY2FuY2VsID0gKGV2ZW50KSA9PiB0aGlzLm9uVG91Y2hDYW5jZWwoZXZlbnQpO1xuICAgIHRoaXMucGluY2ggPSB7XG4gICAgICBmaW5nZXIxOiB7IGlkZW50aWZpZXI6IE5hTiwgc2NyZWVuWDogTmFOLCBzY3JlZW5ZOiBOYU4gfSxcbiAgICAgIGZpbmdlcjI6IHsgaWRlbnRpZmllcjogTmFOLCBzY3JlZW5YOiBOYU4sIHNjcmVlblk6IE5hTiB9LFxuICAgICAgb3JpZ2luOiB7IHg6IE5hTiwgeTogTmFOIH0sXG4gICAgICBkaXN0YW5jZTogTmFOLFxuICAgICAgc3RhdHVzOiAwIC8qIE9mZiAqL1xuICAgIH07XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMudG91Y2hzdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMudG91Y2htb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy50b3VjaGVuZCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLnRvdWNoY2FuY2VsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMudG91Y2htb3ZlKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy50b3VjaGNhbmNlbCk7XG4gIH1cbiAgZmluZFBpbmNoVG91Y2hlcyhtb3ZlRXZlbnQpIHtcbiAgICBjb25zdCB7IHRvdWNoZXMgfSA9IG1vdmVFdmVudDtcbiAgICBjb25zdCB7IGZpbmdlcjEsIGZpbmdlcjIgfSA9IHRoaXMucGluY2g7XG4gICAgaWYgKHRoaXMucGluY2guc3RhdHVzICE9PSAwIC8qIE9mZiAqLyAmJiB0b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKHRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gZmluZ2VyMS5pZGVudGlmaWVyICYmIHRvdWNoZXNbMV0uaWRlbnRpZmllciA9PT0gZmluZ2VyMi5pZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBbdG91Y2hlc1swXSwgdG91Y2hlc1sxXV07XG4gICAgICB9XG4gICAgICBpZiAodG91Y2hlc1swXS5pZGVudGlmaWVyID09PSBmaW5nZXIyLmlkZW50aWZpZXIgJiYgdG91Y2hlc1sxXS5pZGVudGlmaWVyID09PSBmaW5nZXIxLmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIFt0b3VjaGVzWzFdLCB0b3VjaGVzWzBdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weVRvdWNoRGF0YShldmVudCkge1xuICAgIGNvbnN0IGtleXMgPSBbXCJpZGVudGlmaWVyXCIsIFwic2NyZWVuWFwiLCBcInNjcmVlbllcIl07XG4gICAgcGFydGlhbEFzc2lnbihrZXlzLCB0aGlzLnBpbmNoLmZpbmdlcjEsIGV2ZW50LnRvdWNoZXNbMF0pO1xuICAgIHBhcnRpYWxBc3NpZ24oa2V5cywgdGhpcy5waW5jaC5maW5nZXIyLCBldmVudC50b3VjaGVzWzFdKTtcbiAgICB0aGlzLnBpbmNoLmRpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5waW5jaC5maW5nZXIxLCB0aGlzLnBpbmNoLmZpbmdlcjIpO1xuICB9XG4gIGRpc3BhdGNoUGluY2hFdmVudCh0eXBlLCBkZWx0YURpc3RhbmNlLCBzb3VyY2VFdmVudCkge1xuICAgIGNvbnN0IHsgZmluZ2VyMSwgZmluZ2VyMiwgb3JpZ2luIH0gPSB0aGlzLnBpbmNoO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKHR5cGUsIGJ1aWxkUHJldmVudGFibGUoeyBzb3VyY2VFdmVudCwgdHlwZSwgZmluZ2VyMSwgZmluZ2VyMiwgZGVsdGFEaXN0YW5jZSwgb3JpZ2luIH0pKTtcbiAgfVxuICBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KTtcbiAgICBjb25zdCB7IHBpbmNoIH0gPSB0aGlzO1xuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcGluY2guc3RhdHVzID0gMSAvKiBJbml0aWFsaXplZCAqLztcbiAgICAgIHRoaXMuY29weVRvdWNoRGF0YShldmVudCk7XG4gICAgICBwaW5jaC5vcmlnaW4ueCA9IChldmVudC50b3VjaGVzWzBdLmNsaWVudFggKyBldmVudC50b3VjaGVzWzFdLmNsaWVudFgpIC8gMjtcbiAgICAgIHBpbmNoLm9yaWdpbi55ID0gKGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSArIGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WSkgLyAyO1xuICAgIH1cbiAgfVxuICBvblRvdWNoTW92ZShldmVudCkge1xuICAgIGNvbnN0IHBpbmNoVG91Y2hlcyA9IHRoaXMuZmluZFBpbmNoVG91Y2hlcyhldmVudCk7XG4gICAgaWYgKHBpbmNoVG91Y2hlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBbdG91Y2gxLCB0b3VjaDJdID0gcGluY2hUb3VjaGVzO1xuICAgICAgY29uc3QgeyBwaW5jaCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpO1xuICAgICAgY29uc3QgZGVsdGFEaXN0YW5jZSA9IG5ld0Rpc3RhbmNlIC0gcGluY2guZGlzdGFuY2U7XG4gICAgICBpZiAocGluY2guc3RhdHVzID09PSAxIC8qIEluaXRpYWxpemVkICovKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkZWx0YURpc3RhbmNlKSA+IE1JTl9ESVNUQU5DRV9UT19TVEFSVF9QSU5DSCkge1xuICAgICAgICAgIHBpbmNoLnN0YXR1cyA9IDIgLyogUnVubmluZyAqLztcbiAgICAgICAgICB0aGlzLmNvcHlUb3VjaERhdGEoZXZlbnQpO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hQaW5jaEV2ZW50KFwicGluY2gtc3RhcnRcIiwgMCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBpbmNoLnN0YXR1cyA9PT0gMiAvKiBSdW5uaW5nICovKSB7XG4gICAgICAgIHBpbmNoLmRpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuY29weVRvdWNoRGF0YShldmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQaW5jaEV2ZW50KFwicGluY2gtbW92ZVwiLCBkZWx0YURpc3RhbmNlLCBldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2dnZXIuZXJyb3IoYHVuZXhwZWN0ZWQgcGluY2guc3RhdHVzOiAke3BpbmNoLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25Ub3VjaEVuZChldmVudCkge1xuICAgIHRoaXMuc3RvcFBpbmNoVHJhY2tpbmcoZXZlbnQpO1xuICB9XG4gIG9uVG91Y2hDYW5jZWwoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KTtcbiAgfVxuICBzdG9wUGluY2hUcmFja2luZyhldmVudCkge1xuICAgIGNvbnN0IHsgcGluY2ggfSA9IHRoaXM7XG4gICAgaWYgKHBpbmNoLnN0YXR1cyA9PT0gMiAvKiBSdW5uaW5nICovKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoUGluY2hFdmVudChcInBpbmNoLWVuZFwiLCAwLCBldmVudCk7XG4gICAgfVxuICAgIHRoaXMucGluY2guc3RhdHVzID0gMCAvKiBPZmYgKi87XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2hpZ2hsaWdodE1hbmFnZXIudHNcbnZhciBIaWdobGlnaHRNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5oaWdobGlnaHRTdGF0ZXMgPSBuZXcgU3RhdGVUcmFja2VyKCk7XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0KGNhbGxlcklkLCBoaWdobGlnaHRlZERhdHVtKSB7XG4gICAgY29uc3QgeyBhY3RpdmVIaWdobGlnaHQ6IHByZXZpb3VzSGlnaGxpZ2h0IH0gPSB0aGlzO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzLnNldChjYWxsZXJJZCwgaGlnaGxpZ2h0ZWREYXR1bSk7XG4gICAgdGhpcy5hY3RpdmVIaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodFN0YXRlcy5zdGF0ZVZhbHVlKCk7XG4gICAgaWYgKCF0aGlzLmlzRXF1YWwodGhpcy5hY3RpdmVIaWdobGlnaHQsIHByZXZpb3VzSGlnaGxpZ2h0KSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJoaWdobGlnaHQtY2hhbmdlXCIsIHtcbiAgICAgICAgdHlwZTogXCJoaWdobGlnaHQtY2hhbmdlXCIsXG4gICAgICAgIGN1cnJlbnRIaWdobGlnaHQ6IHRoaXMuYWN0aXZlSGlnaGxpZ2h0LFxuICAgICAgICBwcmV2aW91c0hpZ2hsaWdodCxcbiAgICAgICAgY2FsbGVySWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVIaWdobGlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlSGlnaGxpZ2h0O1xuICB9XG4gIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiIHx8IGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYT8uc2VyaWVzID09PSBiPy5zZXJpZXMgJiYgYT8uaXRlbUlkID09PSBiPy5pdGVtSWQgJiYgYT8uZGF0dW0gPT09IGI/LmRhdHVtO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9rZXlOYXZNYW5hZ2VyLnRzXG52YXIgS2V5TmF2TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihpbnRlcmFjdGlvbk1hbmFnZXIsIGRvbU1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5oYXNCcm93c2VyRm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzTW91c2VCbHVycmVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0NsaWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJkcmFnLXN0YXJ0XCIsIChlKSA9PiB0aGlzLm9uQ2xpY2tTdGFydChlKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB0aGlzLm9uQ2xpY2tTdG9wKGUpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiZHJhZy1lbmRcIiwgKGUpID0+IHRoaXMub25DbGlja1N0b3AoZSksIDMxIC8qIEFsbCAqLyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ3aGVlbFwiLCAoZSkgPT4gdGhpcy5tb3VzZUJsdXIoZSkpLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGUpID0+IHRoaXMubW91c2VCbHVyKGUpKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImRyYWdcIiwgKGUpID0+IHRoaXMubW91c2VCbHVyKGUpKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImJsdXJcIiwgKGUpID0+IHRoaXMub25CbHVyKGUpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiZm9jdXNcIiwgKGUpID0+IHRoaXMub25Gb2N1cyhlKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHRoaXMub25LZXlEb3duKGUpLCAzMSAvKiBBbGwgKi8pXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBvbkNsaWNrU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLmlzQ2xpY2tpbmcgPSB0cnVlO1xuICAgIHRoaXMubW91c2VCbHVyKGV2ZW50KTtcbiAgfVxuICBvbkNsaWNrU3RvcChldmVudCkge1xuICAgIHRoaXMubW91c2VCbHVyKGV2ZW50KTtcbiAgICB0aGlzLmlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgfVxuICBtb3VzZUJsdXIoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaGFzQnJvd3NlckZvY3VzKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghdGhpcy5pc01vdXNlQmx1cnJlZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaChcImJsdXJcIiwgMCwgZXZlbnQpO1xuICAgICAgdGhpcy5pc01vdXNlQmx1cnJlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIG9uQmx1cihldmVudCkge1xuICAgIHRoaXMuaGFzQnJvd3NlckZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc01vdXNlQmx1cnJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJibHVyXCIsIDAsIGV2ZW50KTtcbiAgfVxuICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgY29uc3QgZGVsdGEzID0gdGhpcy5kb21NYW5hZ2VyLmdldEJyb3dzZXJGb2N1c0RlbHRhKCk7XG4gICAgdGhpcy5kaXNwYXRjaChcImJyb3dzZXJmb2N1c1wiLCBkZWx0YTMsIGV2ZW50KTtcbiAgICB0aGlzLmhhc0Jyb3dzZXJGb2N1cyA9IHRydWU7XG4gICAgY29uc3QgdGFiRm9jdXNGcm9tQ2xpY2sgPSBldmVudC5yZWxhdGVkRWxlbWVudCA9PSBudWxsICYmIGV2ZW50LnRhcmdldEVsZW1lbnQ/LnRhZ05hbWUgPT09IFwiQ0FOVkFTXCI7XG4gICAgaWYgKHRoaXMuaXNDbGlja2luZyB8fCB0YWJGb2N1c0Zyb21DbGljaykge1xuICAgICAgdGhpcy5pc01vdXNlQmx1cnJlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2goXCJ0YWJcIiwgZGVsdGEzLCBldmVudCk7XG4gIH1cbiAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmhhc0Jyb3dzZXJGb2N1cylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzTW91c2VCbHVycmVkID0gZmFsc2U7XG4gICAgY29uc3QgeyBjb2RlLCBhbHRLZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5IH0gPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICBpZiAoY29kZSA9PT0gXCJUYWJcIikge1xuICAgICAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwidGFiXCIsIC0xLCBldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInRhYlwiLCAxLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRLZXkgfHwgc2hpZnRLZXkgfHwgbWV0YUtleSB8fCBjdHJsS2V5KVxuICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi12ZXJ0XCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXZlcnRcIiwgLTEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtaG9yaVwiLCAtMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtaG9yaVwiLCAxLCBldmVudCk7XG4gICAgICBjYXNlIFwiWm9vbUluXCI6XG4gICAgICBjYXNlIFwiQWRkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIlpvb21PdXRcIjpcbiAgICAgIGNhc2UgXCJTdWJzdHJhY3RcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtem9vbVwiLCAtMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIlNwYWNlXCI6XG4gICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzdWJtaXRcIiwgMCwgZXZlbnQpO1xuICAgICAgY2FzZSBcIkVzY2FwZVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImNhbmNlbFwiLCAwLCBldmVudCk7XG4gICAgICBjYXNlIFwiQmFja3NwYWNlXCI6XG4gICAgICBjYXNlIFwiRGVsZXRlXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIDAsIGV2ZW50KTtcbiAgICB9XG4gICAgc3dpdGNoIChldmVudC5zb3VyY2VFdmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtem9vbVwiLCAtMSwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBkaXNwYXRjaCh0eXBlLCBkZWx0YTMsIHNvdXJjZUV2ZW50KSB7XG4gICAgZGlzcGF0Y2hUeXBlZEV2ZW50KHRoaXMubGlzdGVuZXJzLCB7IHR5cGUsIGRlbHRhOiBkZWx0YTMsIHNvdXJjZUV2ZW50IH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9yZWdpb25NYW5hZ2VyLnRzXG52YXIgUkVHSU9OX1RBQl9PUkRFUklORyA9IFtcInNlcmllc1wiXTtcbnZhciBSZWdpb25MaXN0ZW5lcnMgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG59O1xuZnVuY3Rpb24gYWRkSGFuZGxlcihsaXN0ZW5lcnMsIGludGVyYWN0aW9uTWFuYWdlciwgdHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDE2IC8qIERlZmF1bHQgKi8pIHtcbiAgcmV0dXJuIGxpc3RlbmVycz8uYWRkTGlzdGVuZXIodHlwZSwgKGUpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBpbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoY3VycmVudFN0YXRlICYgdHJpZ2dlcmluZ1N0YXRlcykge1xuICAgICAgaGFuZGxlcihlKTtcbiAgICB9XG4gIH0pID8/ICgoKSA9PiB7XG4gIH0pO1xufVxudmFyIFJlZ2lvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlciwga2V5TmF2TWFuYWdlciwgZm9jdXNJbmRpY2F0b3IpIHtcbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IGludGVyYWN0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmtleU5hdk1hbmFnZXIgPSBrZXlOYXZNYW5hZ2VyO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IgPSBmb2N1c0luZGljYXRvcjtcbiAgICB0aGlzLmN1cnJlbnRUYWJJbmRleCA9IDA7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sZWZ0Q2FudmFzID0gZmFsc2U7XG4gICAgdGhpcy5yZWdpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmFsbFJlZ2lvbnNMaXN0ZW5lcnMgPSBuZXcgUmVnaW9uTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICAuLi5QT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTLm1hcChcbiAgICAgICAgKGV2ZW50TmFtZSkgPT4gaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5wcm9jZXNzUG9pbnRlckV2ZW50LmJpbmQodGhpcyksIDMxIC8qIEFsbCAqLylcbiAgICAgICksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJibHVyXCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJicm93c2VyZm9jdXNcIiwgdGhpcy5vbkJyb3dzZXJGb2N1cy5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcInRhYlwiLCB0aGlzLm9uVGFiLmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwibmF2LXZlcnRcIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcIm5hdi1ob3JpXCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJuYXYtem9vbVwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJjYW5jZWxcIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImRlbGV0ZVwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgdGhpcy5jdXJyZW50UmVnaW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgcmVnaW9uIG9mIHRoaXMucmVnaW9ucy52YWx1ZXMoKSkge1xuICAgICAgcmVnaW9uLmxpc3RlbmVycy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IuZGVzdHJveSgpO1xuICAgIHRoaXMucmVnaW9ucy5jbGVhcigpO1xuICB9XG4gIGFkZFJlZ2lvbihuYW1lLCAuLi5iYm94cHJvdmlkZXJzKSB7XG4gICAgaWYgKHRoaXMucmVnaW9ucy5oYXMobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gUmVnaW9uOiAke25hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lvbiA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHsgbmFtZSwgYmJveHByb3ZpZGVyczogWy4uLmJib3hwcm92aWRlcnNdIH0sXG4gICAgICBsaXN0ZW5lcnM6IG5ldyBSZWdpb25MaXN0ZW5lcnMoKVxuICAgIH07XG4gICAgdGhpcy5yZWdpb25zLnNldChuYW1lLCByZWdpb24pO1xuICAgIHJldHVybiB0aGlzLm1ha2VPYnNlcnZlcihyZWdpb24pO1xuICB9XG4gIHVwZGF0ZVJlZ2lvbihuYW1lLCAuLi5iYm94cHJvdmlkZXIpIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLnJlZ2lvbnMuZ2V0KG5hbWUpO1xuICAgIGlmIChyZWdpb24pIHtcbiAgICAgIHJlZ2lvbi5wcm9wZXJ0aWVzLmJib3hwcm92aWRlcnMgPSBbLi4uYmJveHByb3ZpZGVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5rbm93biByZWdpb246IFwiICsgbmFtZSk7XG4gICAgfVxuICB9XG4gIGdldFJlZ2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZU9ic2VydmVyKHRoaXMucmVnaW9ucy5nZXQobmFtZSkpO1xuICB9XG4gIGxpc3RlbkFsbCh0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMTYgLyogRGVmYXVsdCAqLykge1xuICAgIHJldHVybiBhZGRIYW5kbGVyKHRoaXMuYWxsUmVnaW9uc0xpc3RlbmVycywgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMpO1xuICB9XG4gIC8vIFRoaXMgbWV0aG9kIHJldHVybiBhIHdyYXBwZXIgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgaW50ZXJmYWNlIG9mIEludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lci5cbiAgLy8gVGhlIGludGVudCBpcyB0byBhbGxvdyB0aGUgSW50ZXJhY3Rpb25NYW5hZ2VyIGFuZCBSZWdpb25NYW5hZ2VyIHRvIGJlIHVzZWQgYWxtb3N0IGludGVyY2hhbmdlYWJseS5cbiAgbWFrZU9ic2VydmVyKHJlZ2lvbikge1xuICAgIGNvbnN0IHsgaW50ZXJhY3Rpb25NYW5hZ2VyIH0gPSB0aGlzO1xuICAgIGNsYXNzIE9ic2VydmFibGVSZWdpb25JbXBsZW1lbnRhdGlvbiB7XG4gICAgICBhZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMTYgLyogRGVmYXVsdCAqLykge1xuICAgICAgICByZXR1cm4gYWRkSGFuZGxlcihyZWdpb24/Lmxpc3RlbmVycywgaW50ZXJhY3Rpb25NYW5hZ2VyLCB0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUmVnaW9uSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuICBjaGVja1BvaW50ZXJIaXN0b3J5KHRhcmdldFJlZ2lvbiwgZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGhpc3RvcnlFdmVudCBvZiBldmVudC5wb2ludGVySGlzdG9yeSkge1xuICAgICAgY29uc3QgeyByZWdpb246IGhpc3RvcnlSZWdpb24gfSA9IHRoaXMucGlja1JlZ2lvbihoaXN0b3J5RXZlbnQub2Zmc2V0WCwgaGlzdG9yeUV2ZW50Lm9mZnNldFkpO1xuICAgICAgaWYgKHRhcmdldFJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUgIT09IGhpc3RvcnlSZWdpb24/LnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIENyZWF0ZSBhbmQgZGlzcGF0Y2ggYSBjb3B5IG9mIHRoZSBJbnRlcmFjdGlvbkV2ZW50LlxuICBkaXNwYXRjaChyZWdpb24sIHBhcnRpYWxFdmVudCwgYmJveFByb3ZpZGVySWQpIHtcbiAgICBpZiAocmVnaW9uID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXZlbnQgPSBidWlsZFByZXZlbnRhYmxlKHtcbiAgICAgIC4uLnBhcnRpYWxFdmVudCxcbiAgICAgIHJlZ2lvbjogcmVnaW9uLnByb3BlcnRpZXMubmFtZSxcbiAgICAgIGJib3hQcm92aWRlcklkXG4gICAgfSk7XG4gICAgdGhpcy5hbGxSZWdpb25zTGlzdGVuZXJzLmRpc3BhdGNoKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICByZWdpb24ubGlzdGVuZXJzLmRpc3BhdGNoKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgfVxuICAvLyBQcm9jZXNzIGV2ZW50cyBkdXJpbmcgYSBkcmFnIGFjdGlvbi4gUmV0dXJucyBmYWxzZSBpZiB0aGlzIGV2ZW50IHNob3VsZCBmb2xsb3cgdGhlIHN0YW5kYXJkXG4gIC8vIFJlZ2lvbk1hbmFnZXIucHJvY2Vzc0V2ZW50IGZsb3csIG9yIHRydWUgaWYgdGhpcyBldmVudCBhbHJlYWR5IHByb2Nlc3NlZCBieSB0aGlzIGZ1bmN0aW9uLlxuICBoYW5kbGVEcmFnZ2luZyhldmVudCkge1xuICAgIGNvbnN0IHsgY3VycmVudFJlZ2lvbiB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJkcmFnLXN0YXJ0XCI6XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMubGVmdENhbnZhcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsZWF2ZVwiOlxuICAgICAgICB0aGlzLmxlZnRDYW52YXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RyYWdnaW5nO1xuICAgICAgY2FzZSBcImVudGVyXCI6XG4gICAgICAgIHRoaXMubGVmdENhbnZhcyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RyYWdnaW5nO1xuICAgICAgY2FzZSBcImRyYWdcIjpcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudFJlZ2lvbiwgZXZlbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRyYWctZW5kXCI6XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnRSZWdpb24sIGV2ZW50KTtcbiAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnRSZWdpb24sIHsgLi4uZXZlbnQsIHR5cGU6IFwibGVhdmVcIiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9jZXNzUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlRHJhZ2dpbmcoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3VycmVudFJlZ2lvbiB9ID0gdGhpcztcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJsZWF2ZVwiKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnRSZWdpb24sIHsgLi4uZXZlbnQsIHR5cGU6IFwibGVhdmVcIiB9KTtcbiAgICAgIHRoaXMuY3VycmVudFJlZ2lvbiA9IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyByZWdpb246IG5ld1JlZ2lvbiwgYmJveFByb3ZpZGVySWQgfSA9IHRoaXMucGlja1JlZ2lvbihldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICBpZiAoY3VycmVudFJlZ2lvbiAhPT0gdm9pZCAwICYmIG5ld1JlZ2lvbj8ucHJvcGVydGllcy5uYW1lICE9PSBjdXJyZW50UmVnaW9uLnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50UmVnaW9uLCB7IC4uLmV2ZW50LCB0eXBlOiBcImxlYXZlXCIgfSwgdGhpcy5jdXJyZW50QkJveFByb3ZpZGVySWQpO1xuICAgIH1cbiAgICBpZiAobmV3UmVnaW9uICE9PSB2b2lkIDAgJiYgbmV3UmVnaW9uLnByb3BlcnRpZXMubmFtZSAhPT0gY3VycmVudFJlZ2lvbj8ucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKG5ld1JlZ2lvbiwgeyAuLi5ldmVudCwgdHlwZTogXCJlbnRlclwiIH0sIGJib3hQcm92aWRlcklkKTtcbiAgICB9XG4gICAgaWYgKG5ld1JlZ2lvbiAhPT0gdm9pZCAwICYmIHRoaXMuY2hlY2tQb2ludGVySGlzdG9yeShuZXdSZWdpb24sIGV2ZW50KSkge1xuICAgICAgdGhpcy5kaXNwYXRjaChuZXdSZWdpb24sIGV2ZW50LCBiYm94UHJvdmlkZXJJZCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFJlZ2lvbiA9IG5ld1JlZ2lvbjtcbiAgICB0aGlzLmN1cnJlbnRCQm94UHJvdmlkZXJJZCA9IGJib3hQcm92aWRlcklkO1xuICB9XG4gIHBpY2tSZWdpb24oeCwgeSkge1xuICAgIGxldCBjdXJyZW50QXJlYSA9IEluZmluaXR5O1xuICAgIGxldCBjdXJyZW50UmVnaW9uO1xuICAgIGxldCBjdXJyZW50QkJveFByb3ZpZGVySWQ7XG4gICAgZm9yIChjb25zdCByZWdpb24gb2YgdGhpcy5yZWdpb25zLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHJlZ2lvbi5wcm9wZXJ0aWVzLmJib3hwcm92aWRlcnMpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyLnZpc2libGUgPT09IGZhbHNlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBiYm94ID0gcHJvdmlkZXIuY29tcHV0ZVRyYW5zZm9ybWVkUmVnaW9uQkJveD8uKCkgPz8gcHJvdmlkZXIuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgICBjb25zdCBhcmVhMiA9IGJib3gud2lkdGggKiBiYm94LmhlaWdodDtcbiAgICAgICAgaWYgKGFyZWEyIDwgY3VycmVudEFyZWEgJiYgYmJveC5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICAgICAgY3VycmVudEFyZWEgPSBhcmVhMjtcbiAgICAgICAgICBjdXJyZW50UmVnaW9uID0gcmVnaW9uO1xuICAgICAgICAgIGN1cnJlbnRCQm94UHJvdmlkZXJJZCA9IHByb3ZpZGVyLmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZ2lvbjogY3VycmVudFJlZ2lvbiwgYmJveFByb3ZpZGVySWQ6IGN1cnJlbnRCQm94UHJvdmlkZXJJZCB9O1xuICB9XG4gIGdldFRhYlJlZ2lvbih0YWJJbmRleCkge1xuICAgIGlmICh0YWJJbmRleCAhPT0gdm9pZCAwICYmIHRhYkluZGV4ID49IDAgJiYgdGFiSW5kZXggPCBSRUdJT05fVEFCX09SREVSSU5HLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaW9ucy5nZXQoUkVHSU9OX1RBQl9PUkRFUklOR1t0YWJJbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldE5leHRJbnRlcmFjdGFibGVUYWJJbmRleChjdXJyZW50SW5kZXgsIGRlbHRhMykge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRlbHRhMyA8IDAgPyAtMSA6IDE7XG4gICAgbGV0IGkgPSBjdXJyZW50SW5kZXg7XG4gICAgd2hpbGUgKGRlbHRhMyAhPT0gMCkge1xuICAgICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRUYWJSZWdpb24oaSArIGRpcmVjdGlvbik7XG4gICAgICBpZiAocmVnaW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhMyA9IGRlbHRhMyAtIGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGkgPSBpICsgZGlyZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICB2YWxpZGF0ZUN1cnJlbnRUYWJJbmRleCgpIHtcbiAgICBjb25zdCBmb2N1c2VkUmVnaW9uID0gdGhpcy5nZXRUYWJSZWdpb24odGhpcy5jdXJyZW50VGFiSW5kZXgpO1xuICAgIGlmIChmb2N1c2VkUmVnaW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY3VycmVudFRhYkluZGV4ID0gdGhpcy5nZXROZXh0SW50ZXJhY3RhYmxlVGFiSW5kZXgoLTEsIDEpID8/IDA7XG4gICAgfVxuICB9XG4gIG9uQnJvd3NlckZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRlbHRhID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50VGFiSW5kZXggPSAtMTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhIDwgMCkge1xuICAgICAgdGhpcy5jdXJyZW50VGFiSW5kZXggPSBSRUdJT05fVEFCX09SREVSSU5HLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgb25UYWIoZXZlbnQpIHtcbiAgICB0aGlzLnZhbGlkYXRlQ3VycmVudFRhYkluZGV4KCk7XG4gICAgY29uc3QgbmV3VGFiSW5kZXggPSB0aGlzLmdldE5leHRJbnRlcmFjdGFibGVUYWJJbmRleCh0aGlzLmN1cnJlbnRUYWJJbmRleCwgZXZlbnQuZGVsdGEpO1xuICAgIGNvbnN0IG5ld1JlZ2lvbiA9IHRoaXMuZ2V0VGFiUmVnaW9uKG5ld1RhYkluZGV4KTtcbiAgICBjb25zdCBmb2N1c2VkUmVnaW9uID0gdGhpcy5nZXRUYWJSZWdpb24odGhpcy5jdXJyZW50VGFiSW5kZXgpO1xuICAgIGlmIChuZXdUYWJJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUYWJJbmRleCA9IG5ld1RhYkluZGV4O1xuICAgIH1cbiAgICBpZiAoZm9jdXNlZFJlZ2lvbiAhPT0gdm9pZCAwICYmIG5ld1JlZ2lvbj8ucHJvcGVydGllcy5uYW1lICE9PSBmb2N1c2VkUmVnaW9uLnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgY29uc3QgeyBkZWx0YTogZGVsdGEzLCBzb3VyY2VFdmVudCB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBibHVyRXZlbnQgPSBidWlsZFByZXZlbnRhYmxlKHsgdHlwZTogXCJibHVyXCIsIGRlbHRhOiBkZWx0YTMsIHNvdXJjZUV2ZW50IH0pO1xuICAgICAgdGhpcy5kaXNwYXRjaChmb2N1c2VkUmVnaW9uLCBibHVyRXZlbnQpO1xuICAgIH1cbiAgICBpZiAobmV3UmVnaW9uID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2gobmV3UmVnaW9uLCBldmVudCk7XG4gICAgfVxuICB9XG4gIG9uTmF2KGV2ZW50KSB7XG4gICAgY29uc3QgZm9jdXNlZFJlZ2lvbiA9IHRoaXMuZ2V0VGFiUmVnaW9uKHRoaXMuY3VycmVudFRhYkluZGV4KTtcbiAgICB0aGlzLmRpc3BhdGNoKGZvY3VzZWRSZWdpb24sIGV2ZW50KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyVHlwZXMudHNcbnZhciBUT09MQkFSX0FMSUdOTUVOVFMgPSBbXCJzdGFydFwiLCBcImNlbnRlclwiLCBcImVuZFwiXTtcbnZhciBUT09MQkFSX0dST1VQUyA9IFtcInNlcmllc1R5cGVcIiwgXCJhbm5vdGF0aW9uc1wiLCBcImFubm90YXRpb25PcHRpb25zXCIsIFwicmFuZ2VzXCIsIFwiem9vbVwiXTtcbnZhciBUT09MQkFSX0dST1VQX09SREVSSU5HID0ge1xuICBzZXJpZXNUeXBlOiAwLFxuICBhbm5vdGF0aW9uczogMSxcbiAgYW5ub3RhdGlvbk9wdGlvbnM6IDIsXG4gIHJhbmdlczogMyxcbiAgem9vbTogNFxufTtcbnZhciBUb29sYmFyUG9zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gKChUb29sYmFyUG9zaXRpb24yKSA9PiB7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJUb3BcIl0gPSBcInRvcFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiRmxvYXRpbmdcIl0gPSBcImZsb2F0aW5nXCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJGbG9hdGluZ1RvcFwiXSA9IFwiZmxvYXRpbmctdG9wXCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJGbG9hdGluZ0JvdHRvbVwiXSA9IFwiZmxvYXRpbmctYm90dG9tXCI7XG4gIHJldHVybiBUb29sYmFyUG9zaXRpb24yO1xufSkoVG9vbGJhclBvc2l0aW9uIHx8IHt9KTtcbnZhciBUT09MQkFSX1BPU0lUSU9OUyA9IE9iamVjdC52YWx1ZXMoVG9vbGJhclBvc2l0aW9uKTtcbmZ1bmN0aW9uIGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbihwb3NpdGlvbikge1xuICByZXR1cm4gW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi8sIFwiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dLmluY2x1ZGVzKHBvc2l0aW9uKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vdG9vbGJhck1hbmFnZXIudHNcbnZhciBUb29sYmFyTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBzdGF0aWMgaXNHcm91cChncm91cCwgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ3JvdXAgPT09IGdyb3VwO1xuICB9XG4gIHN0YXRpYyBpc0NoaWxkRWxlbWVudChkb21NYW5hZ2VyLCBlbGVtZW50Mikge1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIGlmIChkb21NYW5hZ2VyLmlzTWFuYWdlZENoaWxkRE9NRWxlbWVudChlbGVtZW50MiwgXCJjYW52YXMtb3ZlcmxheVwiLCBgdG9vbGJhci0ke3Bvc2l0aW9ufWApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJlc3NCdXR0b24oZ3JvdXAsIGlkLCB2YWx1ZSwgcmVjdCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYnV0dG9uLXByZXNzZWRcIiwgeyB0eXBlOiBcImJ1dHRvbi1wcmVzc2VkXCIsIGdyb3VwLCBpZCwgdmFsdWUsIHJlY3QgfSk7XG4gIH1cbiAgY2FuY2VsKGdyb3VwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJjYW5jZWxsZWRcIiwgeyB0eXBlOiBcImNhbmNlbGxlZFwiLCBncm91cCB9KTtcbiAgfVxuICB0b2dnbGVCdXR0b24oZ3JvdXAsIGlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhY3RpdmUgPSBmYWxzZSwgZW5hYmxlZCA9IHRydWUsIHZpc2libGUgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYnV0dG9uLXRvZ2dsZWRcIiwgeyB0eXBlOiBcImJ1dHRvbi10b2dnbGVkXCIsIGdyb3VwLCBpZCwgYWN0aXZlLCBlbmFibGVkLCB2aXNpYmxlIH0pO1xuICB9XG4gIHVwZGF0ZUJ1dHRvbihncm91cCwgaWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImJ1dHRvbi11cGRhdGVkXCIsIHsgdHlwZTogXCJidXR0b24tdXBkYXRlZFwiLCBncm91cCwgaWQsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAgdG9nZ2xlR3JvdXAoY2FsbGVyLCBncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWN0aXZlLCB2aXNpYmxlIH0gPSBvcHRpb25zO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiZ3JvdXAtdG9nZ2xlZFwiLCB7IHR5cGU6IFwiZ3JvdXAtdG9nZ2xlZFwiLCBjYWxsZXIsIGdyb3VwLCBhY3RpdmUsIHZpc2libGUgfSk7XG4gIH1cbiAgY2hhbmdlRmxvYXRpbmdBbmNob3IoZ3JvdXAsIGFuY2hvcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiZmxvYXRpbmctYW5jaG9yLWNoYW5nZWRcIiwgeyB0eXBlOiBcImZsb2F0aW5nLWFuY2hvci1jaGFuZ2VkXCIsIGdyb3VwLCBhbmNob3IgfSk7XG4gIH1cbiAgYnV0dG9uTW92ZWQoZ3JvdXAsIHZhbHVlLCByZWN0LCBncm91cFJlY3QpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImJ1dHRvbi1tb3ZlZFwiLCB7IHR5cGU6IFwiYnV0dG9uLW1vdmVkXCIsIGdyb3VwLCB2YWx1ZSwgcmVjdCwgZ3JvdXBSZWN0IH0pO1xuICB9XG4gIHByb3h5R3JvdXBPcHRpb25zKGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInByb3h5LWdyb3VwLW9wdGlvbnNcIiwgeyB0eXBlOiBcInByb3h5LWdyb3VwLW9wdGlvbnNcIiwgY2FsbGVyLCBncm91cCwgb3B0aW9ucyB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vdG9vbHRpcE1hbmFnZXIudHNcbnZhciBUb29sdGlwTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlciwgdG9vbHRpcCkge1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcbiAgICB0aGlzLnN0YXRlVHJhY2tlciA9IG5ldyBTdGF0ZVRyYWNrZXIoKTtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUgPSBuZXcgU3RhdGVUcmFja2VyKGZhbHNlKTtcbiAgICB0aGlzLmFwcGxpZWRTdGF0ZSA9IG51bGw7XG4gICAgdG9vbHRpcC5zZXR1cChkb21NYW5hZ2VyKTtcbiAgICBkb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiaGlkZGVuXCIsICgpID0+IHRoaXMudG9vbHRpcC50b2dnbGUoZmFsc2UpKTtcbiAgfVxuICB1cGRhdGVUb29sdGlwKGNhbGxlcklkLCBtZXRhLCBjb250ZW50KSB7XG4gICAgaWYgKCF0aGlzLnRvb2x0aXAuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb250ZW50ID8/IChjb250ZW50ID0gdGhpcy5zdGF0ZVRyYWNrZXIuZ2V0KGNhbGxlcklkKT8uY29udGVudCk7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIuc2V0KGNhbGxlcklkLCB7IGNvbnRlbnQsIG1ldGEgfSk7XG4gICAgdGhpcy5hcHBseVN0YXRlcygpO1xuICB9XG4gIHJlbW92ZVRvb2x0aXAoY2FsbGVySWQpIHtcbiAgICBpZiAoIXRoaXMudG9vbHRpcC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyLmRlbGV0ZShjYWxsZXJJZCk7XG4gICAgdGhpcy5hcHBseVN0YXRlcygpO1xuICB9XG4gIHN1cHByZXNzVG9vbHRpcChjYWxsZXJJZCkge1xuICAgIHRoaXMuc3VwcHJlc3NTdGF0ZS5zZXQoY2FsbGVySWQsIHRydWUpO1xuICB9XG4gIHVuc3VwcHJlc3NUb29sdGlwKGNhbGxlcklkKSB7XG4gICAgdGhpcy5zdXBwcmVzc1N0YXRlLmRlbGV0ZShjYWxsZXJJZCk7XG4gIH1cbiAgZ2V0VG9vbHRpcE1ldGEoY2FsbGVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVRyYWNrZXIuZ2V0KGNhbGxlcklkKT8ubWV0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoXCJ0b29sdGlwXCIpO1xuICB9XG4gIGFwcGx5U3RhdGVzKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5zdGF0ZVRyYWNrZXIuc3RhdGVJZCgpO1xuICAgIGNvbnN0IHN0YXRlID0gaWQgPyB0aGlzLnN0YXRlVHJhY2tlci5nZXQoaWQpIDogbnVsbDtcbiAgICBpZiAodGhpcy5zdXBwcmVzc1N0YXRlLnN0YXRlVmFsdWUoKSB8fCBzdGF0ZT8ubWV0YSA9PSBudWxsIHx8IHN0YXRlPy5jb250ZW50ID09IG51bGwpIHtcbiAgICAgIHRoaXMuYXBwbGllZFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMudG9vbHRpcC50b2dnbGUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXNSZWN0ID0gdGhpcy5kb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IHRoaXMudG9vbHRpcC5ib3VuZHMgPT09IFwiZXh0ZW5kZWRcIiA/IHRoaXMuZG9tTWFuYWdlci5nZXRPdmVybGF5Q2xpZW50UmVjdCgpIDogY2FudmFzUmVjdDtcbiAgICBpZiAodGhpcy5hcHBsaWVkU3RhdGU/LmNvbnRlbnQgPT09IHN0YXRlPy5jb250ZW50KSB7XG4gICAgICBjb25zdCByZW5kZXJJbnN0YW50bHkgPSB0aGlzLnRvb2x0aXAuaXNWaXNpYmxlKCk7XG4gICAgICB0aGlzLnRvb2x0aXAuc2hvdyhib3VuZGluZ1JlY3QsIGNhbnZhc1JlY3QsIHN0YXRlPy5tZXRhLCBudWxsLCByZW5kZXJJbnN0YW50bHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvb2x0aXAuc2hvdyhib3VuZGluZ1JlY3QsIGNhbnZhc1JlY3QsIHN0YXRlPy5tZXRhLCBzdGF0ZT8uY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMuYXBwbGllZFN0YXRlID0gc3RhdGU7XG4gIH1cbiAgc3RhdGljIG1ha2VUb29sdGlwTWV0YShldmVudCwgZGF0dW0pIHtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgdG9vbHRpcCB9ID0gZGF0dW0uc2VyaWVzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZW5hYmxlSW50ZXJhY3Rpb246IHRvb2x0aXAuaW50ZXJhY3Rpb24/LmVuYWJsZWQgPz8gZmFsc2UsXG4gICAgICBsYXN0UG9pbnRlckV2ZW50OiB7IHR5cGU6IGV2ZW50LnR5cGUsIG9mZnNldFgsIG9mZnNldFkgfSxcbiAgICAgIHNob3dBcnJvdzogdG9vbHRpcC5zaG93QXJyb3csXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB0eXBlOiB0b29sdGlwLnBvc2l0aW9uLnR5cGUsXG4gICAgICAgIHhPZmZzZXQ6IHRvb2x0aXAucG9zaXRpb24ueE9mZnNldCxcbiAgICAgICAgeU9mZnNldDogdG9vbHRpcC5wb3NpdGlvbi55T2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWZQb2ludCA9IGRhdHVtLnlCYXI/LnVwcGVyUG9pbnQgPz8gZGF0dW0ubWlkUG9pbnQgPz8gZGF0dW0uc2VyaWVzLmRhdHVtTWlkUG9pbnQ/LihkYXR1bSk7XG4gICAgaWYgKHRvb2x0aXAucG9zaXRpb24udHlwZSA9PT0gXCJub2RlXCIgJiYgcmVmUG9pbnQpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcmVmUG9pbnQ7XG4gICAgICBjb25zdCBwb2ludCA9IGRhdHVtLnNlcmllcy5jb250ZW50R3JvdXAuaW52ZXJzZVRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YSxcbiAgICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChwb2ludC55KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xheW91dC9sYXlvdXRTZXJ2aWNlLnRzXG52YXIgTGF5b3V0U2VydmljZSA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxheW91dENvbXBsZXRlID0gXCJsYXlvdXQtY29tcGxldGVcIjtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwibGF5b3V0XCIpO1xuICB9XG4gIGFkZExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLmlzTGF5b3V0U3RhZ2UoZXZlbnRUeXBlKSB8fCB0aGlzLmlzTGF5b3V0Q29tcGxldGUoZXZlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5zdXBwb3J0ZWQgbGlzdGVuZXIgdHlwZTogJHtldmVudFR5cGV9YCk7XG4gIH1cbiAgZGlzcGF0Y2hQZXJmb3JtTGF5b3V0KHN0YWdlLCBjdHgpIHtcbiAgICBpZiAodGhpcy5pc0xheW91dFN0YWdlKHN0YWdlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGlzdGVuZXJzQnlUeXBlKHN0YWdlKS5yZWR1Y2UoKHJlc3VsdCwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXdDdHggPSBsaXN0ZW5lci5oYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIltMYXlvdXRTZXJ2aWNlXSBDb250ZXh0IHVwZGF0ZWQgdG86IFwiLCB7IC4uLm5ld0N0eCB9LCBsaXN0ZW5lcik7XG4gICAgICAgICAgcmV0dXJuIG5ld0N0eDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIExvZ2dlci5lcnJvck9uY2UoZSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSwgY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBkaXNwYXRjaExheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaCh0aGlzLmxheW91dENvbXBsZXRlLCBldmVudCk7XG4gIH1cbiAgaXNMYXlvdXRTdGFnZShldmVudFR5cGUpIHtcbiAgICByZXR1cm4gZXZlbnRUeXBlICE9PSB0aGlzLmxheW91dENvbXBsZXRlO1xuICB9XG4gIGlzTGF5b3V0Q29tcGxldGUoZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZSA9PT0gdGhpcy5sYXlvdXRDb21wbGV0ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbG9jYWxlL2RlZmF1bHRNZXNzYWdlRm9ybWF0dGVyLnRzXG52YXIgbWVzc2FnZVJlZ0V4cCA9IC9cXCRcXHsoXFx3Kyl9KD86XFxbKFxcdyspXSk/L2dpO1xudmFyIGZvcm1hdHRlcnMgPSB7XG4gIG51bWJlcjogbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW4tVVNcIiksXG4gIHBlcmNlbnQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIsIHsgc3R5bGU6IFwicGVyY2VudFwiIH0pLFxuICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgZGF0ZVN0eWxlOiBcImZ1bGxcIiB9KSxcbiAgdGltZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVTdHlsZTogXCJmdWxsXCIgfSksXG4gIGRhdGV0aW1lOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgZGF0ZVN0eWxlOiBcImZ1bGxcIiwgdGltZVN0eWxlOiBcImZ1bGxcIiB9KVxufTtcbnZhciBkZWZhdWx0TWVzc2FnZUZvcm1hdHRlciA9ICh7IGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID0+IHtcbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZT8ucmVwbGFjZUFsbChtZXNzYWdlUmVnRXhwLCAoXywgbWF0Y2gsIGZvcm1hdCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmFyaWFibGVzW21hdGNoXTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBmb3JtYXQgIT0gbnVsbCA/IGZvcm1hdHRlcnNbZm9ybWF0XSA6IHZvaWQgMDtcbiAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0dGVyID09IG51bGwpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgRm9ybWF0IHN0eWxlIFske2Zvcm1hdH1dIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdHRlciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWJlci5mb3JtYXQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5kYXRldGltZS5mb3JtYXQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfSk7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sb2NhbGUvbG9jYWxlTWFuYWdlci50c1xudmFyIExvY2FsZU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sb2NhbGVUZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IHZvaWQgMDtcbiAgfVxuICBzZXRMb2NhbGVUZXh0KGxvY2FsZVRleHQpIHtcbiAgICBpZiAodGhpcy5sb2NhbGVUZXh0ICE9PSBsb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLmxvY2FsZVRleHQgPSBsb2NhbGVUZXh0O1xuICAgICAgdGhpcy5kaXNwYXRjaChcImxvY2FsZS1jaGFuZ2VkXCIpO1xuICAgIH1cbiAgfVxuICBzZXRMb2NhbGVUZXh0Rm9ybWF0dGVyKGdldExvY2FsZVRleHQpIHtcbiAgICB0aGlzLmdldExvY2FsZVRleHQgPSBnZXRMb2NhbGVUZXh0O1xuICAgIGlmICh0aGlzLmdldExvY2FsZVRleHQgIT09IGdldExvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IGdldExvY2FsZVRleHQ7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwibG9jYWxlLWNoYW5nZWRcIik7XG4gICAgfVxuICB9XG4gIHQoa2V5LCB2YXJpYWJsZXMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlVGV4dCA9IEFHX0NIQVJUU19MT0NBTEVfRU5fVVMsIGdldExvY2FsZVRleHQgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gbG9jYWxlVGV4dFtrZXldO1xuICAgIHJldHVybiBnZXRMb2NhbGVUZXh0Py4oeyBrZXksIGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID8/IGRlZmF1bHRNZXNzYWdlRm9ybWF0dGVyKHsga2V5LCBkZWZhdWx0VmFsdWUsIHZhcmlhYmxlcyB9KSA/PyBrZXk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNTdGF0ZU1hbmFnZXIudHNcbnZhciBTZXJpZXNTdGF0ZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJTZXJpZXMoe1xuICAgIGlkLFxuICAgIHNlcmllc0dyb3VwaW5nLFxuICAgIHZpc2libGUsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm47XG4gICAgKF9hID0gdGhpcy5ncm91cHMpW3R5cGVdID8/IChfYVt0eXBlXSA9IHt9KTtcbiAgICB0aGlzLmdyb3Vwc1t0eXBlXVtpZF0gPSB7IGdyb3VwaW5nOiBzZXJpZXNHcm91cGluZywgdmlzaWJsZSB9O1xuICB9XG4gIGRlcmVnaXN0ZXJTZXJpZXMoeyBpZCwgdHlwZSB9KSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV1baWRdO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncm91cHNbdHlwZV0gJiYgT2JqZWN0LmtleXModGhpcy5ncm91cHNbdHlwZV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW3R5cGVdO1xuICAgIH1cbiAgfVxuICBnZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgoe1xuICAgIHR5cGUsXG4gICAgc2VyaWVzR3JvdXBpbmcsXG4gICAgdmlzaWJsZVxuICB9KSB7XG4gICAgaWYgKCFzZXJpZXNHcm91cGluZylcbiAgICAgIHJldHVybiB7IHZpc2libGVHcm91cENvdW50OiB2aXNpYmxlID8gMSA6IDAsIHZpc2libGVTYW1lU3RhY2tDb3VudDogdmlzaWJsZSA/IDEgOiAwLCBpbmRleDogMCB9O1xuICAgIGNvbnN0IHZpc2libGVHcm91cHNTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHZpc2libGVTYW1lU3RhY2tTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmdyb3Vwc1t0eXBlXSA/PyB7fSkpIHtcbiAgICAgIGlmICghZW50cnkudmlzaWJsZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2aXNpYmxlR3JvdXBzU2V0LmFkZChlbnRyeS5ncm91cGluZy5ncm91cEluZGV4KTtcbiAgICAgIGlmIChlbnRyeS5ncm91cGluZy5ncm91cEluZGV4ID09PSBzZXJpZXNHcm91cGluZy5ncm91cEluZGV4KSB7XG4gICAgICAgIHZpc2libGVTYW1lU3RhY2tTZXQuYWRkKGVudHJ5Lmdyb3VwaW5nLnN0YWNrSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2aXNpYmxlR3JvdXBzID0gQXJyYXkuZnJvbSh2aXNpYmxlR3JvdXBzU2V0KTtcbiAgICB2aXNpYmxlR3JvdXBzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZUdyb3VwQ291bnQ6IHZpc2libGVHcm91cHMubGVuZ3RoLFxuICAgICAgdmlzaWJsZVNhbWVTdGFja0NvdW50OiB2aXNpYmxlU2FtZVN0YWNrU2V0LnNpemUsXG4gICAgICBpbmRleDogdmlzaWJsZUdyb3Vwcy5pbmRleE9mKHNlcmllc0dyb3VwaW5nLmdyb3VwSW5kZXgpXG4gICAgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRVcGRhdGVUeXBlLnRzXG52YXIgQ2hhcnRVcGRhdGVUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ2hhcnRVcGRhdGVUeXBlMykgPT4ge1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJGVUxMXCJdID0gMF0gPSBcIkZVTExcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiVVBEQVRFX0RBVEFcIl0gPSAxXSA9IFwiVVBEQVRFX0RBVEFcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiUFJPQ0VTU19EQVRBXCJdID0gMl0gPSBcIlBST0NFU1NfREFUQVwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJQRVJGT1JNX0xBWU9VVFwiXSA9IDNdID0gXCJQRVJGT1JNX0xBWU9VVFwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJTRVJJRVNfVVBEQVRFXCJdID0gNF0gPSBcIlNFUklFU19VUERBVEVcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiUFJFX1NDRU5FX1JFTkRFUlwiXSA9IDVdID0gXCJQUkVfU0NFTkVfUkVOREVSXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIlNDRU5FX1JFTkRFUlwiXSA9IDZdID0gXCJTQ0VORV9SRU5ERVJcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiTk9ORVwiXSA9IDddID0gXCJOT05FXCI7XG4gIHJldHVybiBDaGFydFVwZGF0ZVR5cGUzO1xufSkoQ2hhcnRVcGRhdGVUeXBlIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdXBkYXRlU2VydmljZS50c1xudmFyIFVwZGF0ZVNlcnZpY2UgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gdXBkYXRlQ2FsbGJhY2s7XG4gIH1cbiAgdXBkYXRlKHR5cGUgPSAwIC8qIEZVTEwgKi8sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHR5cGUsIG9wdGlvbnMpO1xuICB9XG4gIGRpc3BhdGNoVXBkYXRlQ29tcGxldGUocmVjdHMpIHtcbiAgICB0aGlzLmRpc3BhdGNoKFwidXBkYXRlLWNvbXBsZXRlXCIsIHtcbiAgICAgIHR5cGU6IFwidXBkYXRlLWNvbXBsZXRlXCIsXG4gICAgICBtaW5SZWN0OiByZWN0cz8ubWluUmVjdCxcbiAgICAgIG1pblZpc2libGVSZWN0OiByZWN0cz8ubWluVmlzaWJsZVJlY3RcbiAgICB9KTtcbiAgfVxuICBkaXNwYXRjaFByZVNjZW5lUmVuZGVyKHJlY3RzKSB7XG4gICAgdGhpcy5kaXNwYXRjaChcInByZS1zY2VuZS1yZW5kZXJcIiwgeyB0eXBlOiBcInByZS1zY2VuZS1yZW5kZXJcIiwgLi4ucmVjdHMgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0Q29udGV4dC50c1xudmFyIENoYXJ0Q29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIHZhcnMpIHtcbiAgICBjb25zdCB7IHNjZW5lLCByb290LCBzeW5jTWFuYWdlciwgY29udGFpbmVyLCB1cGRhdGVDYWxsYmFjaywgdXBkYXRlTXV0ZXgsIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyB9ID0gdmFycztcbiAgICB0aGlzLmNoYXJ0U2VydmljZSA9IGNoYXJ0O1xuICAgIHRoaXMuc3luY01hbmFnZXIgPSBzeW5jTWFuYWdlcjtcbiAgICB0aGlzLnpvb21NYW5hZ2VyID0gY2hhcnQuem9vbU1hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gbmV3IERPTU1hbmFnZXIoY29udGFpbmVyKTtcbiAgICBzY2VuZT8uc2V0Q29udGFpbmVyKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lID8/IG5ldyBTY2VuZSh7IHBpeGVsUmF0aW86IG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbywgZG9tTWFuYWdlcjogdGhpcy5kb21NYW5hZ2VyIH0pO1xuICAgIHRoaXMuc2NlbmUuc2V0Um9vdChyb290KTtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyID0gbmV3IEF4aXNNYW5hZ2VyKHJvb3QpO1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IG5ldyBMb2NhbGVNYW5hZ2VyKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uTWFuYWdlciA9IG5ldyBBbm5vdGF0aW9uTWFuYWdlcihjaGFydC5hbm5vdGF0aW9uUm9vdCk7XG4gICAgdGhpcy5jaGFydEV2ZW50TWFuYWdlciA9IG5ldyBDaGFydEV2ZW50TWFuYWdlcigpO1xuICAgIHRoaXMuY3Vyc29yTWFuYWdlciA9IG5ldyBDdXJzb3JNYW5hZ2VyKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5oaWdobGlnaHRNYW5hZ2VyID0gbmV3IEhpZ2hsaWdodE1hbmFnZXIoKTtcbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IG5ldyBJbnRlcmFjdGlvbk1hbmFnZXIoY2hhcnQua2V5Ym9hcmQsIHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5rZXlOYXZNYW5hZ2VyID0gbmV3IEtleU5hdk1hbmFnZXIodGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvciA9IG5ldyBGb2N1c0luZGljYXRvcih0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMucmVnaW9uTWFuYWdlciA9IG5ldyBSZWdpb25NYW5hZ2VyKHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLCB0aGlzLmtleU5hdk1hbmFnZXIsIHRoaXMuZm9jdXNJbmRpY2F0b3IpO1xuICAgIHRoaXMuY29udGV4dE1lbnVSZWdpc3RyeSA9IG5ldyBDb250ZXh0TWVudVJlZ2lzdHJ5KHRoaXMucmVnaW9uTWFuYWdlcik7XG4gICAgdGhpcy50b29sYmFyTWFuYWdlciA9IG5ldyBUb29sYmFyTWFuYWdlcigpO1xuICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMubGF5b3V0U2VydmljZSA9IG5ldyBMYXlvdXRTZXJ2aWNlKCk7XG4gICAgdGhpcy5hcmlhQW5ub3VuY2VtZW50U2VydmljZSA9IG5ldyBBcmlhQW5ub3VuY2VtZW50U2VydmljZShcbiAgICAgIHRoaXMubG9jYWxlTWFuYWdlcixcbiAgICAgIHRoaXMuZG9tTWFuYWdlcixcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZVxuICAgICk7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlID0gbmV3IFVwZGF0ZVNlcnZpY2UodXBkYXRlQ2FsbGJhY2spO1xuICAgIHRoaXMucHJveHlJbnRlcmFjdGlvblNlcnZpY2UgPSBuZXcgUHJveHlJbnRlcmFjdGlvblNlcnZpY2UoXG4gICAgICB0aGlzLnVwZGF0ZVNlcnZpY2UsXG4gICAgICB0aGlzLmxvY2FsZU1hbmFnZXIsXG4gICAgICB0aGlzLmRvbU1hbmFnZXIsXG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yXG4gICAgKTtcbiAgICB0aGlzLnNlcmllc1N0YXRlTWFuYWdlciA9IG5ldyBTZXJpZXNTdGF0ZU1hbmFnZXIoKTtcbiAgICB0aGlzLnN0YXRlTWFuYWdlciA9IG5ldyBTdGF0ZU1hbmFnZXIoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FjaGUgPSBuZXcgQ2FsbGJhY2tDYWNoZSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLCB1cGRhdGVNdXRleCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNraXAoKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIucGxheSgpO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBuZXcgRGF0YVNlcnZpY2UodGhpcy5hbmltYXRpb25NYW5hZ2VyKTtcbiAgICB0aGlzLnRvb2x0aXBNYW5hZ2VyID0gbmV3IFRvb2x0aXBNYW5hZ2VyKHRoaXMuZG9tTWFuYWdlciwgY2hhcnQudG9vbHRpcCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRvb2x0aXBNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNvbnRleHRNZW51UmVnaXN0cnkuZGVzdHJveSgpO1xuICAgIHRoaXMucmVnaW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5wcm94eUludGVyYWN0aW9uU2VydmljZS5kZXN0cm95KCk7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnN0b3AoKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXJpYUFubm91bmNlbWVudFNlcnZpY2UuZGVzdHJveSgpO1xuICAgIHRoaXMuY2hhcnRFdmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5jYWxsYmFja0NhY2hlLmludmFsaWRhdGVDYWNoZSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgIHRoaXMuc3luY01hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5heGlzTWFuYWdlci5kZXN0cm95KCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0SGlnaGxpZ2h0LnRzXG52YXIgQ2hhcnRIaWdobGlnaHQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnJhbmdlID0gXCJ0b29sdGlwXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJ0b29sdGlwXCIsIFwibm9kZVwiXSwgXCJhIHJhbmdlXCIpKVxuXSwgQ2hhcnRIaWdobGlnaHQucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFEb21haW4udHNcbnZhciBEaXNjcmV0ZURvbWFpbiA9IGNsYXNzIF9EaXNjcmV0ZURvbWFpbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZG9tYWluID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfRGlzY3JldGVEb21haW47XG4gIH1cbiAgZXh0ZW5kKHZhbCkge1xuICAgIHRoaXMuZG9tYWluLmFkZCh2YWwpO1xuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmRvbWFpbik7XG4gIH1cbn07XG52YXIgQ29udGludW91c0RvbWFpbiA9IGNsYXNzIF9Db250aW51b3VzRG9tYWluIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0NvbnRpbnVvdXNEb21haW47XG4gIH1cbiAgc3RhdGljIGV4dGVuZERvbWFpbih2YWx1ZXMsIGRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XSkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpblswXSA+IHZhbHVlKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpblsxXSA8IHZhbHVlKSB7XG4gICAgICAgIGRvbWFpblsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGV4dGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRvbWFpblswXSA+IHZhbHVlKSB7XG4gICAgICB0aGlzLmRvbWFpblswXSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb21haW5bMV0gPCB2YWx1ZSkge1xuICAgICAgdGhpcy5kb21haW5bMV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5kb21haW5dO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFNb2RlbC50c1xuZnVuY3Rpb24gdG9LZXlTdHJpbmcoa2V5cykge1xuICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gaXNPYmplY3Qoa2V5KSA/IEpTT04uc3RyaW5naWZ5KGtleSkgOiBrZXkpLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gcm91bmQyKHZhbCkge1xuICBjb25zdCBhY2N1cmFjeSA9IDFlNDtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnModmFsKSA+IGFjY3VyYWN5KSB7XG4gICAgcmV0dXJuIE1hdGgudHJ1bmModmFsKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiBhY2N1cmFjeSkgLyBhY2N1cmFjeTtcbn1cbmZ1bmN0aW9uIGZpeE51bWVyaWNFeHRlbnRJbnRlcm5hbChleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbGV0IFttaW4sIG1heF0gPSBleHRlbnQyLm1hcChOdW1iZXIpO1xuICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMCkge1xuICAgIHJldHVybiBbMCwgMV07XG4gIH1cbiAgaWYgKG1pbiA9PT0gSW5maW5pdHkgJiYgbWF4ID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAobWluID09PSBJbmZpbml0eSkge1xuICAgIG1pbiA9IDA7XG4gIH0gZWxzZSBpZiAobWF4ID09PSAtSW5maW5pdHkpIHtcbiAgICBtYXggPSAwO1xuICB9XG4gIHJldHVybiBpc0Zpbml0ZU51bWJlcihtaW4pICYmIGlzRmluaXRlTnVtYmVyKG1heCkgPyBbbWluLCBtYXhdIDogW107XG59XG5mdW5jdGlvbiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudDIsIGF4aXMpIHtcbiAgY29uc3QgZml4ZWRFeHRlbnQgPSBmaXhOdW1lcmljRXh0ZW50SW50ZXJuYWwoZXh0ZW50Mik7XG4gIGlmIChmaXhlZEV4dGVudC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZml4ZWRFeHRlbnQ7XG4gIH1cbiAgbGV0IFttaW4sIG1heF0gPSBmaXhlZEV4dGVudDtcbiAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgY29uc3QgW3BhZGRpbmdNaW4sIHBhZGRpbmdNYXhdID0gYXhpcz8uY2FsY3VsYXRlUGFkZGluZyhtaW4sIG1heCkgPz8gWzEsIDFdO1xuICAgIG1pbiAtPSBwYWRkaW5nTWluO1xuICAgIG1heCArPSBwYWRkaW5nTWF4O1xuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuZnVuY3Rpb24gZ2V0TWlzc0NvdW50KHNjb3BlUHJvdmlkZXIsIG1pc3NNYXApIHtcbiAgcmV0dXJuIG1pc3NNYXA/LmdldChzY29wZVByb3ZpZGVyLmlkKSA/PyAwO1xufVxudmFyIElOVkFMSURfVkFMVUUgPSBTeW1ib2woXCJpbnZhbGlkXCIpO1xuZnVuY3Rpb24gZ2V0UGF0aENvbXBvbmVudHMocGF0aCkge1xuICBjb25zdCBjb21wb25lbnRzID0gW107XG4gIGxldCBtYXRjaEluZGV4ID0gMDtcbiAgbGV0IG1hdGNoR3JvdXA7XG4gIGNvbnN0IHJlZ0V4cCA9IC8oKD86KD86XnxcXC4pXFxzKlxcdyt8XFxbXFxzKig/OicoPzpbXiddfFxcXFwnKSonfFwiKD86W15cIl18XFxcXFwiKSpcInwtP1xcZCspXFxzKlxcXSlcXHMqKS9nO1xuICB3aGlsZSAobWF0Y2hHcm91cCA9IHJlZ0V4cC5leGVjKHBhdGgpKSB7XG4gICAgaWYgKG1hdGNoR3JvdXAuaW5kZXggIT09IG1hdGNoSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0Y2hJbmRleCA9IG1hdGNoR3JvdXAuaW5kZXggKyBtYXRjaEdyb3VwWzBdLmxlbmd0aDtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoR3JvdXBbMV0udHJpbSgpO1xuICAgIGlmIChtYXRjaC5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKG1hdGNoLnNsaWNlKDEpLnRyaW0oKSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaC5zdGFydHNXaXRoKFwiW1wiKSkge1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSBtYXRjaC5zbGljZSgxLCAtMSkudHJpbSgpO1xuICAgICAgaWYgKGFjY2Vzc29yLnN0YXJ0c1dpdGgoYCdgKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3Iuc2xpY2UoMSwgLTEpLnJlcGxhY2UoLyg/PCFcXFxcKVxcXFwnL2csIGAnYCkpO1xuICAgICAgfSBlbHNlIGlmIChhY2Nlc3Nvci5zdGFydHNXaXRoKGBcImApKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChhY2Nlc3Nvci5zbGljZSgxLCAtMSkucmVwbGFjZSgvKD88IVxcXFwpXFxcXFwiL2csIGBcImApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChhY2Nlc3Nvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChtYXRjaCk7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaEluZGV4ICE9PSBwYXRoLmxlbmd0aClcbiAgICByZXR1cm47XG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEFjY2Vzc29yKGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gZGF0dW07XG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgY29tcG9uZW50cykge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbY29tcG9uZW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH07XG59XG52YXIgRGF0YU1vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzLCBtb2RlID0gXCJzdGFuZGFsb25lXCIpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImRhdGEtbW9kZWxcIik7XG4gICAgdGhpcy5zY29wZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIHRoaXMuYWdncmVnYXRlcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnJlZHVjZXJzID0gW107XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW107XG4gICAgbGV0IGtleXMgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgbmV4dCBvZiBvcHRzLnByb3BzKSB7XG4gICAgICBpZiAobmV4dC50eXBlID09PSBcImtleVwiICYmICFrZXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjoga2V5cyBtdXN0IGNvbWUgYmVmb3JlIHZhbHVlcy5cIik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dC50eXBlID09PSBcInZhbHVlXCIgJiYga2V5cykge1xuICAgICAgICBrZXlzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZlcmlmeU1hdGNoR3JvdXBJZCA9ICh7IG1hdGNoR3JvdXBJZHMgPSBbXSB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1hdGNoR3JvdXBJZCBvZiBtYXRjaEdyb3VwSWRzKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5ldmVyeSgoZGVmKSA9PiBkZWYuZ3JvdXBJZCAhPT0gbWF0Y2hHcm91cElkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IG1hdGNoR3JvdXBJZHMgcHJvcGVydGllcyBtdXN0IG1hdGNoIGRlZmluZWQgZ3JvdXBzICgke21hdGNoR3JvdXBJZH0pLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBvcHRzLnByb3BzKSB7XG4gICAgICBzd2l0Y2ggKGRlZi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgICB0aGlzLmtleXMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMua2V5cy5sZW5ndGgsIG1pc3Npbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgIGlmIChkZWYucHJvcGVydHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlnIGVycm9yOiBubyBwcm9wZXJ0aWVzIHNwZWNpZmllZCBmb3IgdmFsdWUgZGVmaW5pdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgZGVmXG4gICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMudmFsdWVzLmxlbmd0aCwgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFnZ3JlZ2F0ZVwiOlxuICAgICAgICAgIHZlcmlmeU1hdGNoR3JvdXBJZChkZWYpO1xuICAgICAgICAgIHRoaXMuYWdncmVnYXRlcy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5hZ2dyZWdhdGVzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICAgIHZlcmlmeU1hdGNoR3JvdXBJZChkZWYpO1xuICAgICAgICAgIHRoaXMuZ3JvdXBQcm9jZXNzb3JzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLmdyb3VwUHJvY2Vzc29ycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcm9wZXJ0eS12YWx1ZS1wcm9jZXNzb3JcIjpcbiAgICAgICAgICB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVkdWNlclwiOlxuICAgICAgICAgIHRoaXMucmVkdWNlcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMucmVkdWNlcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicHJvY2Vzc29yXCI6XG4gICAgICAgICAgdGhpcy5wcm9jZXNzb3JzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnByb2Nlc3NvcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XG4gICAgY29uc3QgZGVmID0gdGhpcy5zY29wZUNhY2hlLmdldChzY29wZS5pZCk/LmdldChzZWFyY2hJZCk7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gZGlkbid0IGZpbmQgcHJvcGVydHkgZGVmaW5pdGlvbiBmb3IgWyR7c2VhcmNoSWR9LCAke3Njb3BlLmlkfV1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGRlZi5pbmRleCwgZGVmIH07XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHNjb3BlLCBzZWFyY2hJZCkuaW5kZXg7XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzQnlJZHMoc2NvcGUsIHNlYXJjaElkcykge1xuICAgIHJldHVybiBzZWFyY2hJZHMubWFwKChzZWFyY2hJZCkgPT4gW3NlYXJjaElkLCB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZChzY29wZSwgc2VhcmNoSWQpXSk7XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzVmFsdWVzKGRlZnMsIHsga2V5cywgdmFsdWVzIH0pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtzZWFyY2hJZCwgeyBpbmRleCwgZGVmIH1dIG9mIGRlZnMpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBkZWYudHlwZSA9PT0gXCJrZXlcIiA/IGtleXMgOiB2YWx1ZXM7XG4gICAgICByZXN1bHRbc2VhcmNoSWRdID0gcHJvY2Vzc2VkRGF0YVtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0RG9tYWluKHNjb3BlLCBzZWFyY2hJZCwgdHlwZSA9IFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGRvbWFpbnMgPSB0aGlzLmdldERvbWFpbnNCeVR5cGUodHlwZSwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgcmV0dXJuIGRvbWFpbnM/Llt0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCldID8/IFtdO1xuICB9XG4gIGdldERvbWFpbnNCeVR5cGUodHlwZSwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cztcbiAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzO1xuICAgICAgY2FzZSBcImFnZ3JlZ2F0ZVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzO1xuICAgICAgY2FzZSBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4uZ3JvdXBzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NEYXRhKGRhdGEsIHNvdXJjZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGdyb3VwQnlLZXlzLCBncm91cEJ5Rm4gfSxcbiAgICAgIGFnZ3JlZ2F0ZXMsXG4gICAgICBncm91cFByb2Nlc3NvcnMsXG4gICAgICByZWR1Y2VycyxcbiAgICAgIHByb2Nlc3NvcnMsXG4gICAgICBwcm9wZXJ0eVByb2Nlc3NvcnNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChncm91cEJ5S2V5cyAmJiB0aGlzLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcm9jZXNzZWREYXRhID0gdGhpcy5leHRyYWN0RGF0YShkYXRhLCBzb3VyY2VzKTtcbiAgICBpZiAoZ3JvdXBCeUtleXMpIHtcbiAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmdyb3VwRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwQnlGbikge1xuICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZ3JvdXBEYXRhKHByb2Nlc3NlZERhdGEsIGdyb3VwQnlGbihwcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGlmIChncm91cFByb2Nlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc0dyb3Vwcyhwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKGFnZ3JlZ2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hZ2dyZWdhdGVEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlQcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NQcm9wZXJ0aWVzKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAocmVkdWNlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5yZWR1Y2VEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc3RQcm9jZXNzRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBkZWYgb2YgaXRlcmF0ZSh0aGlzLmtleXMsIHRoaXMudmFsdWVzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtzY29wZSwgbWlzc0NvdW50XSBvZiBkZWYubWlzc2luZykge1xuICAgICAgICAgIGlmIChtaXNzQ291bnQgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlSGludCA9IHNjb3BlID09IG51bGwgPyBcIlwiIDogYCBmb3IgJHtzY29wZX1gO1xuICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUga2V5ICcke2RlZi5wcm9wZXJ0eX0nIHdhcyBub3QgZm91bmQgaW4gYW55IGRhdGEgZWxlbWVudCR7c2NvcGVIaW50fS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcHJvY2Vzc2VkRGF0YS50aW1lID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgbG9nUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgdGhpcy5zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgaXRlcmF0ZSh0aGlzLmtleXMsIHRoaXMudmFsdWVzLCB0aGlzLmFnZ3JlZ2F0ZXMpKSB7XG4gICAgICBpZiAoIWRlZi5pZHNNYXApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBbc2NvcGUsIGlkc10gb2YgZGVmLmlkc01hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgIGlmICghdGhpcy5zY29wZUNhY2hlLmhhcyhzY29wZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVDYWNoZS5zZXQoc2NvcGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbaWQsIGRlZl1dKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjb3BlQ2FjaGUuZ2V0KHNjb3BlKT8uaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGRlZmluaXRpb24gaWRzIG9uIHRoZSBzYW1lIHNjb3BlIGFyZSBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUpLnNldChpZCwgZGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NlZERhdGE7XG4gIH1cbiAgdmFsdWVHcm91cElkeExvb2t1cCh7IG1hdGNoR3JvdXBJZHMgfSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBkZWZdIG9mIHRoaXMudmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKCFtYXRjaEdyb3VwSWRzIHx8IGRlZi5ncm91cElkICYmIG1hdGNoR3JvdXBJZHMuaW5jbHVkZXMoZGVmLmdyb3VwSWQpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YWx1ZUlkeExvb2t1cChzY29wZXMsIHByb3ApIHtcbiAgICBjb25zdCBub1Njb3Blc1RvTWF0Y2ggPSBzY29wZXMgPT0gbnVsbCB8fCBzY29wZXMubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IHByb3BJZCA9IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiID8gcHJvcCA6IHByb3AuaWQ7XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdTY29wZUlkID0gKGRlZikgPT4ge1xuICAgICAgaWYgKGRlZi5pZHNNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBbc2NvcGUsIGlkc10gb2YgZGVmLmlkc01hcCkge1xuICAgICAgICAgIGlmIChzY29wZXM/LmluY2x1ZGVzKHNjb3BlKSAmJiBpZHMuaGFzKHByb3BJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy52YWx1ZXMuZmluZEluZGV4KChkZWYpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkRGVmU2NvcGVzID0gZGVmLnNjb3BlcyA9PSBudWxsIHx8IG5vU2NvcGVzVG9NYXRjaCAmJiAhZGVmLnNjb3Blcy5sZW5ndGggfHwgZGVmLnNjb3Blcy5zb21lKChzKSA9PiBzY29wZXM/LmluY2x1ZGVzKHMpKTtcbiAgICAgIHJldHVybiB2YWxpZERlZlNjb3BlcyAmJiAoZGVmLnByb3BlcnR5ID09PSBwcm9wSWQgfHwgZGVmLmlkID09PSBwcm9wSWQgfHwgaGFzTWF0Y2hpbmdTY29wZUlkKGRlZikpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBRyBDaGFydHMgLSBjb25maWd1cmF0aW9uIGVycm9yLCB1bmtub3duIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkocHJvcCl9IGluIHNjb3BlKHMpICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc2NvcGVzXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBleHRyYWN0RGF0YShkYXRhLCBzb3VyY2VzKSB7XG4gICAgY29uc3QgeyBkYXRhRG9tYWluLCBwcm9jZXNzVmFsdWUsIHNjb3BlcywgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzIH0gPSB0aGlzLmluaXREYXRhRG9tYWluUHJvY2Vzc29yKCk7XG4gICAgY29uc3Qgc291cmNlc0J5SWQgPSBuZXcgTWFwKHNvdXJjZXM/Lm1hcCgocykgPT4gW3MuaWQsIHNdKSk7XG4gICAgY29uc3QgeyBrZXlzOiBrZXlEZWZzLCB2YWx1ZXM6IHZhbHVlRGVmcyB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHREYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBsZXQgcmVzdWx0RGF0YUlkeCA9IDA7XG4gICAgbGV0IHBhcnRpYWxWYWxpZERhdGFDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBbZGF0dW1JZHgsIGRhdHVtXSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgc291cmNlRGF0dW1zID0ge307XG4gICAgICBjb25zdCB2YWxpZFNjb3BlcyA9IHNjb3Blcy5zaXplID4gMCA/IG5ldyBTZXQoc2NvcGVzKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkoa2V5RGVmcy5sZW5ndGgpO1xuICAgICAgbGV0IGtleUlkeCA9IDA7XG4gICAgICBsZXQga2V5O1xuICAgICAgZm9yIChjb25zdCBkZWYgb2Yga2V5RGVmcykge1xuICAgICAgICBrZXkgPSBwcm9jZXNzVmFsdWUoZGVmLCBkYXR1bSwga2V5KTtcbiAgICAgICAgaWYgKGtleSA9PT0gSU5WQUxJRF9WQUxVRSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICBrZXlzW2tleUlkeCsrXSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gSU5WQUxJRF9WQUxVRSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZURlZnMubGVuZ3RoID4gMCA/IG5ldyBBcnJheSh2YWx1ZURlZnMubGVuZ3RoKSA6IHZvaWQgMDtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgW3ZhbHVlRGVmSWR4LCBkZWZdIG9mIHZhbHVlRGVmcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBkZWYuc2NvcGVzID8/IHNjb3Blcykge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNCeUlkLmdldChzY29wZSk7XG4gICAgICAgICAgY29uc3QgdmFsdWVEYXR1bSA9IHNvdXJjZT8uZGF0YVtkYXR1bUlkeF0gPz8gZGF0dW07XG4gICAgICAgICAgdmFsdWUgPSBwcm9jZXNzVmFsdWUoZGVmLCB2YWx1ZURhdHVtLCB2YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSU5WQUxJRF9WQUxVRSB8fCAhdmFsdWVzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIGRlZi5pbmNsdWRlUHJvcGVydHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGRlZi5pbmNsdWRlUHJvcGVydHkgJiYgZGVmLmlkICE9IG51bGwgPyBkZWYuaWQgOiBkZWYucHJvcGVydHk7XG4gICAgICAgICAgICBzb3VyY2VEYXR1bXNbc2NvcGVdID8/IChzb3VyY2VEYXR1bXNbc2NvcGVdID0ge30pO1xuICAgICAgICAgICAgc291cmNlRGF0dW1zW3Njb3BlXVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzW3ZhbHVlRGVmSWR4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSU5WQUxJRF9WQUxVRSkge1xuICAgICAgICAgIGlmIChhbGxTY29wZXNIYXZlU2FtZURlZnMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGRlZi5zY29wZXMgPz8gc2NvcGVzKSB7XG4gICAgICAgICAgICB2YWxpZFNjb3Blcz8uZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlkU2NvcGVzPy5zaXplID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5WQUxJRF9WQUxVRSAmJiBhbGxTY29wZXNIYXZlU2FtZURlZnMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHZhbGlkU2NvcGVzPy5zaXplID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHsgZGF0dW06IHsgLi4uZGF0dW0sIC4uLnNvdXJjZURhdHVtcyB9LCBrZXlzLCB2YWx1ZXMgfTtcbiAgICAgIGlmICghYWxsU2NvcGVzSGF2ZVNhbWVEZWZzICYmIHZhbGlkU2NvcGVzICYmIHZhbGlkU2NvcGVzLnNpemUgPCBzY29wZXMuc2l6ZSkge1xuICAgICAgICBwYXJ0aWFsVmFsaWREYXRhQ291bnQrKztcbiAgICAgICAgcmVzdWx0LnZhbGlkU2NvcGVzID0gbmV3IFNldCh2YWxpZFNjb3Blcyk7XG4gICAgICB9XG4gICAgICByZXN1bHREYXRhW3Jlc3VsdERhdGFJZHgrK10gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdERhdGEubGVuZ3RoID0gcmVzdWx0RGF0YUlkeDtcbiAgICBjb25zdCBwcm9wZXJ0eURvbWFpbiA9IChkZWYpID0+IHtcbiAgICAgIGNvbnN0IGRlZkRvbWFpbiA9IGRhdGFEb21haW4uZ2V0KGRlZik7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWZEb21haW4uZ2V0RG9tYWluKCk7XG4gICAgICBpZiAoQ29udGludW91c0RvbWFpbi5pcyhkZWZEb21haW4pICYmIHJlc3VsdFswXSA+IHJlc3VsdFsxXSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidW5ncm91cGVkXCIsXG4gICAgICBpbnB1dDogeyBjb3VudDogZGF0YS5sZW5ndGggfSxcbiAgICAgIGRhdGE6IHJlc3VsdERhdGEsXG4gICAgICBkb21haW46IHtcbiAgICAgICAga2V5czoga2V5RGVmcy5tYXAocHJvcGVydHlEb21haW4pLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlRGVmcy5tYXAocHJvcGVydHlEb21haW4pXG4gICAgICB9LFxuICAgICAgZGVmczoge1xuICAgICAgICBhbGxTY29wZXNIYXZlU2FtZURlZnMsXG4gICAgICAgIGtleXM6IGtleURlZnMsXG4gICAgICAgIHZhbHVlczogdmFsdWVEZWZzXG4gICAgICB9LFxuICAgICAgcGFydGlhbFZhbGlkRGF0YUNvdW50LFxuICAgICAgdGltZTogMFxuICAgIH07XG4gIH1cbiAgZ3JvdXBEYXRhKGRhdGEsIGdyb3VwaW5nRm4pIHtcbiAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGRhdGFFbnRyeSBvZiBkYXRhLmRhdGEpIHtcbiAgICAgIGNvbnN0IHsga2V5cywgdmFsdWVzLCBkYXR1bSwgdmFsaWRTY29wZXMgfSA9IGRhdGFFbnRyeTtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBpbmdGbj8uKGRhdGFFbnRyeSkgPz8ga2V5cztcbiAgICAgIGNvbnN0IGdyb3VwU3RyID0gdG9LZXlTdHJpbmcoZ3JvdXApO1xuICAgICAgaWYgKHByb2Nlc3NlZERhdGEuaGFzKGdyb3VwU3RyKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0RhdGEgPSBwcm9jZXNzZWREYXRhLmdldChncm91cFN0cik7XG4gICAgICAgIGV4aXN0aW5nRGF0YS52YWx1ZXMucHVzaCh2YWx1ZXMpO1xuICAgICAgICBleGlzdGluZ0RhdGEuZGF0dW0ucHVzaChkYXR1bSk7XG4gICAgICAgIGlmICh2YWxpZFNjb3BlcyAhPSBudWxsICYmIGV4aXN0aW5nRGF0YS52YWxpZFNjb3BlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBleGlzdGluZ0RhdGEudmFsaWRTY29wZXMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRTY29wZXMuaGFzKHNjb3BlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZ0RhdGEudmFsaWRTY29wZXMuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NlZERhdGEuc2V0KGdyb3VwU3RyLCB7XG4gICAgICAgICAga2V5czogZ3JvdXAsXG4gICAgICAgICAgdmFsdWVzOiBbdmFsdWVzXSxcbiAgICAgICAgICBkYXR1bTogW2RhdHVtXSxcbiAgICAgICAgICB2YWxpZFNjb3Blc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0RGF0YSA9IG5ldyBBcnJheShwcm9jZXNzZWREYXRhLnNpemUpO1xuICAgIGNvbnN0IHJlc3VsdEdyb3VwcyA9IG5ldyBBcnJheShwcm9jZXNzZWREYXRhLnNpemUpO1xuICAgIGxldCBkYXRhSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgeyBrZXlzLCB2YWx1ZXMsIGRhdHVtLCB2YWxpZFNjb3BlcyB9IG9mIHByb2Nlc3NlZERhdGEudmFsdWVzKCkpIHtcbiAgICAgIGlmICh2YWxpZFNjb3Blcz8uc2l6ZSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXN1bHRHcm91cHNbZGF0YUluZGV4XSA9IGtleXM7XG4gICAgICByZXN1bHREYXRhW2RhdGFJbmRleCsrXSA9IHtcbiAgICAgICAga2V5cyxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgdmFsaWRTY29wZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgdHlwZTogXCJncm91cGVkXCIsXG4gICAgICBkYXRhOiByZXN1bHREYXRhLFxuICAgICAgZG9tYWluOiB7XG4gICAgICAgIC4uLmRhdGEuZG9tYWluLFxuICAgICAgICBncm91cHM6IHJlc3VsdEdyb3Vwc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYWdncmVnYXRlRGF0YShwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgaXNVbmdyb3VwZWQgPSBwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwidW5ncm91cGVkXCI7XG4gICAgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGRlZl0gb2YgdGhpcy5hZ2dyZWdhdGVzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IHRoaXMudmFsdWVHcm91cElkeExvb2t1cChkZWYpO1xuICAgICAgY29uc3QgZG9tYWluID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgZm9yIChjb25zdCBkYXR1bSBvZiBwcm9jZXNzZWREYXRhLmRhdGEpIHtcbiAgICAgICAgZGF0dW0uYWdnVmFsdWVzID8/IChkYXR1bS5hZ2dWYWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5hZ2dyZWdhdGVzLmxlbmd0aCkpO1xuICAgICAgICBpZiAoZGF0dW0udmFsaWRTY29wZXMpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzVW5ncm91cGVkID8gW2RhdHVtLnZhbHVlc10gOiBkYXR1bS52YWx1ZXM7XG4gICAgICAgIGxldCBncm91cEFnZ1ZhbHVlcyA9IGRlZi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uPy4oKSA/PyBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGZvciAoY29uc3QgZGlzdGluY3RWYWx1ZXMgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVzVG9BZ2cgPSBpbmRpY2VzLm1hcCgodmFsdWVJZHgpID0+IGRpc3RpbmN0VmFsdWVzW3ZhbHVlSWR4XSk7XG4gICAgICAgICAgY29uc3QgdmFsdWVzQWdnID0gZGVmLmFnZ3JlZ2F0ZUZ1bmN0aW9uKHZhbHVlc1RvQWdnLCBkYXR1bS5rZXlzKTtcbiAgICAgICAgICBpZiAodmFsdWVzQWdnKSB7XG4gICAgICAgICAgICBncm91cEFnZ1ZhbHVlcyA9IGRlZi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uPy4odmFsdWVzQWdnLCBncm91cEFnZ1ZhbHVlcykgPz8gQ29udGludW91c0RvbWFpbi5leHRlbmREb21haW4odmFsdWVzQWdnLCBncm91cEFnZ1ZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmFsVmFsdWVzID0gKGRlZi5maW5hbEZ1bmN0aW9uPy4oZ3JvdXBBZ2dWYWx1ZXMpID8/IGdyb3VwQWdnVmFsdWVzKS5tYXAoKHYpID0+IHJvdW5kMih2KSk7XG4gICAgICAgIGRhdHVtLmFnZ1ZhbHVlc1tpbmRleF0gPSBmaW5hbFZhbHVlcztcbiAgICAgICAgQ29udGludW91c0RvbWFpbi5leHRlbmREb21haW4oZmluYWxWYWx1ZXMsIGRvbWFpbik7XG4gICAgICB9XG4gICAgICBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXMucHVzaChkb21haW4pO1xuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc0dyb3Vwcyhwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgeyBncm91cFByb2Nlc3NvcnMgfSA9IHRoaXM7XG4gICAgY29uc3QgYWZmZWN0ZWRJbmRpY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB1cGRhdGVkRG9tYWlucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ3JvdXBQcm9jZXNzb3JJbmRpY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBncm91cFByb2Nlc3NvckluaXRGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgcHJvY2Vzc29yIG9mIGdyb3VwUHJvY2Vzc29ycykge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IHRoaXMudmFsdWVHcm91cElkeExvb2t1cChwcm9jZXNzb3IpO1xuICAgICAgZ3JvdXBQcm9jZXNzb3JJbmRpY2VzLnNldChwcm9jZXNzb3IsIGluZGljZXMpO1xuICAgICAgZ3JvdXBQcm9jZXNzb3JJbml0Rm5zLnNldChwcm9jZXNzb3IsIHByb2Nlc3Nvci5hZGp1c3QoKSk7XG4gICAgICBmb3IgKGNvbnN0IGlkeCBvZiBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlRGVmID0gdGhpcy52YWx1ZXNbaWR4XTtcbiAgICAgICAgY29uc3QgaXNEaXNjcmV0ZSA9IHZhbHVlRGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICAgICAgICBhZmZlY3RlZEluZGljZXMuYWRkKGlkeCk7XG4gICAgICAgIHVwZGF0ZWREb21haW5zLnNldChpZHgsIGlzRGlzY3JldGUgPyBuZXcgRGlzY3JldGVEb21haW4oKSA6IG5ldyBDb250aW51b3VzRG9tYWluKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEb21haW5zID0gKHZhbHVlcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZUluZGV4IG9mIGFmZmVjdGVkSW5kaWNlcykge1xuICAgICAgICB1cGRhdGVkRG9tYWlucy5nZXQodmFsdWVJbmRleCk/LmV4dGVuZCh2YWx1ZXNbdmFsdWVJbmRleF0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBwcm9jZXNzZWREYXRhLmRhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvY2Vzc29yIG9mIGdyb3VwUHJvY2Vzc29ycykge1xuICAgICAgICBpZiAoZ3JvdXAudmFsaWRTY29wZXMpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHZhbHVlSW5kZXhlcyA9IGdyb3VwUHJvY2Vzc29ySW5kaWNlcy5nZXQocHJvY2Vzc29yKSA/PyBbXTtcbiAgICAgICAgY29uc3QgYWRqdXN0Rm4gPSBncm91cFByb2Nlc3NvckluaXRGbnMuZ2V0KHByb2Nlc3Nvcik/LigpO1xuICAgICAgICBpZiAoIWFkanVzdEZuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgICAgICAgIGZvciAoY29uc3QgdmFsdWVzIG9mIGdyb3VwLnZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICBhZGp1c3RGbih2YWx1ZXMsIHZhbHVlSW5kZXhlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLnZhbHVlcykge1xuICAgICAgICAgIGFkanVzdEZuKGdyb3VwLnZhbHVlcywgdmFsdWVJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJncm91cGVkXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZXMgb2YgZ3JvdXAudmFsdWVzKSB7XG4gICAgICAgICAgdXBkYXRlRG9tYWlucyh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVEb21haW5zKGdyb3VwLnZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkeCwgZGF0YURvbWFpbl0gb2YgdXBkYXRlZERvbWFpbnMpIHtcbiAgICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tpZHhdID0gZGF0YURvbWFpbi5nZXREb21haW4oKTtcbiAgICB9XG4gIH1cbiAgcG9zdFByb2Nlc3NQcm9wZXJ0aWVzKHByb2Nlc3NlZERhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHsgYWRqdXN0LCBwcm9wZXJ0eSwgc2NvcGVzIH0gb2YgdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMpIHtcbiAgICAgIGFkanVzdCgpKHByb2Nlc3NlZERhdGEsIHRoaXMudmFsdWVJZHhMb29rdXAoc2NvcGVzLCBwcm9wZXJ0eSkpO1xuICAgIH1cbiAgfVxuICByZWR1Y2VEYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWQgPz8gKHByb2Nlc3NlZERhdGEucmVkdWNlZCA9IHt9KTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLnJlZHVjZXJzKSB7XG4gICAgICBjb25zdCByZWR1Y2VyID0gZGVmLnJlZHVjZXIoKTtcbiAgICAgIGxldCBhY2NWYWx1ZSA9IGRlZi5pbml0aWFsVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIHByb2Nlc3NlZERhdGEuZGF0YSkge1xuICAgICAgICBpZiAoIWRhdHVtLnZhbGlkU2NvcGVzIHx8IGRlZi5zY29wZXM/LnNvbWUoKHMpID0+IGRhdHVtLnZhbGlkU2NvcGVzPy5oYXMocykpKSB7XG4gICAgICAgICAgYWNjVmFsdWUgPSByZWR1Y2VyKGFjY1ZhbHVlLCBkYXR1bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZFtkZWYucHJvcGVydHldID0gYWNjVmFsdWU7XG4gICAgfVxuICB9XG4gIHBvc3RQcm9jZXNzRGF0YShwcm9jZXNzZWREYXRhKSB7XG4gICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID8/IChwcm9jZXNzZWREYXRhLnJlZHVjZWQgPSB7fSk7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgdGhpcy5wcm9jZXNzb3JzKSB7XG4gICAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWRbZGVmLnByb3BlcnR5XSA9IGRlZi5jYWxjdWxhdGUocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICB9XG4gIGluaXREYXRhRG9tYWluUHJvY2Vzc29yKCkge1xuICAgIGNvbnN0IHsga2V5czoga2V5RGVmcywgdmFsdWVzOiB2YWx1ZURlZnMgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NvcGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlRGVmIG9mIHZhbHVlRGVmcykge1xuICAgICAgaWYgKCF2YWx1ZURlZi5zY29wZXMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBzY29wZSBvZiB2YWx1ZURlZi5zY29wZXMpIHtcbiAgICAgICAgc2NvcGVzLmFkZChzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGFEb21haW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHByb2Nlc3NvckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGFsbFNjb3Blc0hhdmVTYW1lRGVmcyA9IHRydWU7XG4gICAgY29uc3QgaW5pdERhdGFEb21haW4gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGRlZiBvZiBpdGVyYXRlKGtleURlZnMsIHZhbHVlRGVmcykpIHtcbiAgICAgICAgaWYgKGRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICAgIGRhdGFEb21haW4uc2V0KGRlZiwgbmV3IERpc2NyZXRlRG9tYWluKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFEb21haW4uc2V0KGRlZiwgbmV3IENvbnRpbnVvdXNEb21haW4oKSk7XG4gICAgICAgICAgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzICYmIChhbGxTY29wZXNIYXZlU2FtZURlZnMgPSAoZGVmLnNjb3BlcyA/PyBbXSkubGVuZ3RoID09PSBzY29wZXMuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXREYXRhRG9tYWluKCk7XG4gICAgY29uc3QgYWNjZXNzb3JzID0gdGhpcy5idWlsZEFjY2Vzc29ycyhpdGVyYXRlKGtleURlZnMsIHZhbHVlRGVmcykpO1xuICAgIGNvbnN0IHByb2Nlc3NWYWx1ZSA9IChkZWYsIGRhdHVtLCBwcmV2aW91c0RhdHVtLCBzY29wZSkgPT4ge1xuICAgICAgbGV0IHZhbHVlSW5EYXR1bTtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGlmIChhY2Nlc3NvcnMuaGFzKGRlZi5wcm9wZXJ0eSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IGFjY2Vzc29ycy5nZXQoZGVmLnByb3BlcnR5KShkYXR1bSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVJbkRhdHVtID0gdmFsdWUgIT0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlSW5EYXR1bSA9IGRlZi5wcm9wZXJ0eSBpbiBkYXR1bTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUluRGF0dW0gPyBkYXR1bVtkZWYucHJvcGVydHldIDogZGVmLm1pc3NpbmdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWYuZm9yY2VWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlTmVnYXRpdmUgPSB2YWx1ZUluRGF0dW0gJiYgaXNOZWdhdGl2ZSh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWVOZWdhdGl2ZSA/IC0xICogZGVmLmZvcmNlVmFsdWUgOiBkZWYuZm9yY2VWYWx1ZTtcbiAgICAgICAgdmFsdWVJbkRhdHVtID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pc3NpbmdWYWx1ZURlZiA9IFwibWlzc2luZ1ZhbHVlXCIgaW4gZGVmO1xuICAgICAgaWYgKCF2YWx1ZUluRGF0dW0gJiYgIW1pc3NpbmdWYWx1ZURlZikge1xuICAgICAgICBjb25zdCBtaXNzQ291bnQgPSBkZWYubWlzc2luZy5nZXQoc2NvcGUpID8/IDA7XG4gICAgICAgIGRlZi5taXNzaW5nLnNldChzY29wZSwgbWlzc0NvdW50ICsgMSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRhdGFEb21haW4uaGFzKGRlZikpIHtcbiAgICAgICAgaW5pdERhdGFEb21haW4oKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZUluRGF0dW0gJiYgZGVmLnZhbGlkYXRpb24/Lih2YWx1ZSwgZGF0dW0pID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoXCJpbnZhbGlkVmFsdWVcIiBpbiBkZWYpIHtcbiAgICAgICAgICB2YWx1ZSA9IGRlZi5pbnZhbGlkVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICAgICAgYGludmFsaWQgdmFsdWUgb2YgdHlwZSBbJHt0eXBlb2YgdmFsdWV9XSBmb3IgWyR7ZGVmLnNjb3Blc30gLyAke2RlZi5pZH1dIGlnbm9yZWQ6YCxcbiAgICAgICAgICAgICAgYFske3ZhbHVlfV1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSU5WQUxJRF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZi5wcm9jZXNzb3IpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzb3JGbnMuaGFzKGRlZikpIHtcbiAgICAgICAgICBwcm9jZXNzb3JGbnMuc2V0KGRlZiwgZGVmLnByb2Nlc3NvcigpKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHByb2Nlc3NvckZucy5nZXQoZGVmKT8uKHZhbHVlLCBwcmV2aW91c0RhdHVtID09PSBJTlZBTElEX1ZBTFVFID8gdm9pZCAwIDogcHJldmlvdXNEYXR1bSk7XG4gICAgICB9XG4gICAgICBkYXRhRG9tYWluLmdldChkZWYpPy5leHRlbmQodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIHsgZGF0YURvbWFpbiwgcHJvY2Vzc1ZhbHVlLCBpbml0RGF0YURvbWFpbiwgc2NvcGVzLCBhbGxTY29wZXNIYXZlU2FtZURlZnMgfTtcbiAgfVxuICBidWlsZEFjY2Vzc29ycyhkZWZzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSBcImludGVncmF0ZWRcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgICAgY29uc3QgaXNQYXRoID0gZGVmLnByb3BlcnR5LmluY2x1ZGVzKFwiLlwiKSB8fCBkZWYucHJvcGVydHkuaW5jbHVkZXMoXCJbXCIpO1xuICAgICAgaWYgKCFpc1BhdGgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldFBhdGhDb21wb25lbnRzKGRlZi5wcm9wZXJ0eSk7XG4gICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcIkludmFsaWQgcHJvcGVydHkgcGF0aCBbJXNdXCIsIGRlZi5wcm9wZXJ0eSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYWNjZXNzb3IgPSBjcmVhdGVQYXRoQWNjZXNzb3IoY29tcG9uZW50cyk7XG4gICAgICByZXN1bHQuc2V0KGRlZi5wcm9wZXJ0eSwgYWNjZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZnVuY3Rpb24gbG9nUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKSB7XG4gIGNvbnN0IGxvZ1ZhbHVlcyA9IChuYW1lLCBkYXRhKSA9PiB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgTG9nZ2VyLmxvZyhgRGF0YU1vZGVsLnByb2Nlc3NEYXRhKCkgLSAke25hbWV9YCk7XG4gICAgICBMb2dnZXIudGFibGUoZGF0YSk7XG4gICAgfVxuICB9O1xuICBMb2dnZXIubG9nKFwiRGF0YU1vZGVsLnByb2Nlc3NEYXRhKCkgLSBwcm9jZXNzZWREYXRhXCIsIHByb2Nlc3NlZERhdGEpO1xuICBsb2dWYWx1ZXMoXCJLZXkgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi5rZXlzKTtcbiAgbG9nVmFsdWVzKFwiR3JvdXAgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi5ncm91cHMgPz8gW10pO1xuICBsb2dWYWx1ZXMoXCJWYWx1ZSBEb21haW5zXCIsIHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlcyk7XG4gIGxvZ1ZhbHVlcyhcIkFnZ3JlZ2F0ZSBEb21haW5zXCIsIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcyA/PyBbXSk7XG4gIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkVmFsdWVzID0gcHJvY2Vzc2VkRGF0YS5kYXRhLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBrZXlzID0gbmV4dC5rZXlzID8/IFtdO1xuICAgICAgY29uc3QgYWdnVmFsdWVzID0gbmV4dC5hZ2dWYWx1ZXMgPz8gW107XG4gICAgICBjb25zdCBza2lwS2V5cyA9IG5leHQua2V5cy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICAgIGNvbnN0IHNraXBBZ2dWYWx1ZXMgPSBhZ2dWYWx1ZXM/Lm1hcCgoKSA9PiB2b2lkIDApO1xuICAgICAgYWNjLnB1c2goXG4gICAgICAgIC4uLm5leHQudmFsdWVzLm1hcCgodiwgaSkgPT4gW1xuICAgICAgICAgIC4uLmkgPT09IDAgPyBrZXlzIDogc2tpcEtleXMsXG4gICAgICAgICAgLi4udiA/PyBbXSxcbiAgICAgICAgICAuLi5pID09IDAgPyBhZ2dWYWx1ZXMgOiBza2lwQWdnVmFsdWVzXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgbG9nVmFsdWVzKFwiVmFsdWVzXCIsIGZsYXR0ZW5lZFZhbHVlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmxhdHRlbmVkVmFsdWVzID0gcHJvY2Vzc2VkRGF0YS5kYXRhLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBhZ2dWYWx1ZXMgPSBuZXh0LmFnZ1ZhbHVlcyA/PyBbXTtcbiAgICAgIGFjYy5wdXNoKFsuLi5uZXh0LmtleXMsIC4uLm5leHQudmFsdWVzLCAuLi5hZ2dWYWx1ZXNdKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIGxvZ1ZhbHVlcyhcIlZhbHVlc1wiLCBmbGF0dGVuZWRWYWx1ZXMpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YUNvbnRyb2xsZXIudHNcbnZhciBfRGF0YUNvbnRyb2xsZXIgPSBjbGFzcyBfRGF0YUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiZGF0YS1tb2RlbFwiKTtcbiAgICB0aGlzLnJlcXVlc3RlZCA9IFtdO1xuICAgIHRoaXMuc3RhdHVzID0gXCJzZXR1cFwiO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoaWQsIGRhdGEsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwic2V0dXBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkYXRhIHJlcXVlc3QgYWZ0ZXIgZGF0YSBzZXR1cCBwaGFzZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdGVkLnB1c2goeyBpZCwgb3B0cywgZGF0YSwgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICB9XG4gIGV4ZWN1dGUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInNldHVwXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gZGF0YSByZXF1ZXN0IGFmdGVyIGRhdGEgc2V0dXAgcGhhc2UuYCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdHVzID0gXCJleGVjdXRlZFwiO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhQ29udHJvbGxlci5leGVjdXRlKCkgLSByZXF1ZXN0ZWRcIiwgdGhpcy5yZXF1ZXN0ZWQpO1xuICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZVJlcXVlc3RzKHRoaXMucmVxdWVzdGVkKTtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSgpIC0gdmFsaWRhdGVkXCIsIHZhbGlkKTtcbiAgICBjb25zdCBtZXJnZWQgPSB0aGlzLm1lcmdlUmVxdWVzdGVkKHZhbGlkKTtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSgpIC0gbWVyZ2VkXCIsIG1lcmdlZCk7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgZ2V0V2luZG93KCkucHJvY2Vzc2VkRGF0YSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSB0aGlzLnJlcXVlc3RlZC5tYXAoKHsgaWQgfSkgPT4gaWQpO1xuICAgIGNvbnN0IG5lZWRzVmFsdWVFeHRyYWN0aW9uID0gdGhpcy5oYXNNdWx0aXBsZURhdGFTb3VyY2VzKHZhbGlkKTtcbiAgICBmb3IgKGNvbnN0IHsgb3B0cywgZGF0YSwgcmVzb2x2ZXMsIHJlamVjdHMsIGlkcyB9IG9mIG1lcmdlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YU1vZGVsID0gbmV3IERhdGFNb2RlbChvcHRzLCB0aGlzLm1vZGUpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gZGF0YU1vZGVsLnByb2Nlc3NEYXRhKGRhdGEsIHZhbGlkKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgICAgIGdldFdpbmRvdyhcInByb2Nlc3NlZERhdGFcIikucHVzaChwcm9jZXNzZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YT8ucGFydGlhbFZhbGlkRGF0YUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZXMuZm9yRWFjaChcbiAgICAgICAgICAgIChyZXNvbHZlLCByZXF1ZXN0SWR4KSA9PiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZGF0YU1vZGVsLFxuICAgICAgICAgICAgICBwcm9jZXNzZWREYXRhOiB0aGlzLnByb2Nlc3NTY29wZWREYXRhKFxuICAgICAgICAgICAgICAgIGlkc1tyZXF1ZXN0SWR4XSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWREYXRhLFxuICAgICAgICAgICAgICAgIHNjb3BlcyxcbiAgICAgICAgICAgICAgICBuZWVkc1ZhbHVlRXh0cmFjdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzc2VkRGF0YSkge1xuICAgICAgICAgIHRoaXMuc3BsaXRSZXN1bHQoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBpZHMsIHJlc29sdmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3RzLmZvckVhY2goKGNiKSA9PiBjYihuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIG5vIHByb2Nlc3NlZCBkYXRhIGdlbmVyYXRlZGApKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdHMuZm9yRWFjaCgoY2IpID0+IGNiKGVycm9yKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc011bHRpcGxlRGF0YVNvdXJjZXModmFsaWRSZXF1ZXN0cykge1xuICAgIGlmICh2YWxpZFJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgY29uc3QgW3sgZGF0YSB9LCAuLi5yZXN0UmVxdWVzdHNdID0gdmFsaWRSZXF1ZXN0cztcbiAgICAgIHJldHVybiByZXN0UmVxdWVzdHMuc29tZSgodikgPT4gZGF0YSAhPT0gdi5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb2Nlc3NTY29wZWREYXRhKGlkLCBwcm9jZXNzZWREYXRhLCBpZHMsIG5lZWRzVmFsdWVFeHRyYWN0aW9uKSB7XG4gICAgY29uc3QgZXh0cmFjdERhdHVtID0gKGRhdHVtKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdHVtLm1hcChleHRyYWN0RGF0dW0pO1xuICAgICAgfVxuICAgICAgY29uc3QgZXh0cmFjdGVkID0gbmVlZHNWYWx1ZUV4dHJhY3Rpb24gPyB7IC4uLmRhdHVtLCAuLi5kYXR1bVtpZF0gfSA6IGRhdHVtO1xuICAgICAgZm9yIChjb25zdCBvdGhlcklkIG9mIGlkcykge1xuICAgICAgICBkZWxldGUgZXh0cmFjdGVkW290aGVySWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhY3RWYWx1ZXMgPSAodmFsdWVzKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGV4dHJhY3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcz8uW2lkXSA/PyB2YWx1ZXM7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucHJvY2Vzc2VkRGF0YSxcbiAgICAgIGRhdGE6IHByb2Nlc3NlZERhdGEuZGF0YS5tYXAoKGRhdHVtKSA9PiAoe1xuICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgZGF0dW06IGV4dHJhY3REYXR1bShkYXR1bS5kYXR1bSksXG4gICAgICAgIHZhbHVlczogbmVlZHNWYWx1ZUV4dHJhY3Rpb24gPyBkYXR1bS52YWx1ZXM/Lm1hcChleHRyYWN0VmFsdWVzKSA6IGRhdHVtLnZhbHVlc1xuICAgICAgfSkpXG4gICAgfTtcbiAgfVxuICB2YWxpZGF0ZVJlcXVlc3RzKHJlcXVlc3RlZCkge1xuICAgIGNvbnN0IHZhbGlkID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHJlcXVlc3RdIG9mIHJlcXVlc3RlZC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpbmRleCA+IDAgJiYgcmVxdWVzdC5kYXRhLmxlbmd0aCAhPT0gcmVxdWVzdGVkWzBdLmRhdGEubGVuZ3RoICYmIHJlcXVlc3Qub3B0cy5ncm91cEJ5RGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVxdWVzdC5yZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKFwiYWxsIHNlcmllc1tdLmRhdGEgYXJyYXlzIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoIGFuZCBoYXZlIG1hdGNoaW5nIGtleXMuXCIpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZC5wdXNoKHJlcXVlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cbiAgbWVyZ2VSZXF1ZXN0ZWQocmVxdWVzdGVkKSB7XG4gICAgY29uc3QgZ3JvdXBlZCA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0ZWQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gZ3JvdXBlZC5maW5kKF9EYXRhQ29udHJvbGxlci5ncm91cE1hdGNoKHJlcXVlc3QpKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5wdXNoKHJlcXVlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBlZC5wdXNoKFtyZXF1ZXN0XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncm91cGVkLm1hcChfRGF0YUNvbnRyb2xsZXIubWVyZ2VSZXF1ZXN0cyk7XG4gIH1cbiAgc3BsaXRSZXN1bHQoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBzY29wZXMsIHJlc29sdmVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY29wZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzW2ldO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9IHJlc29sdmVzW2ldO1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIGRhdGFNb2RlbCxcbiAgICAgICAgcHJvY2Vzc2VkRGF0YToge1xuICAgICAgICAgIC4uLnByb2Nlc3NlZERhdGEsXG4gICAgICAgICAgZGF0YTogcHJvY2Vzc2VkRGF0YS5kYXRhLmZpbHRlcigoeyB2YWxpZFNjb3BlcyB9KSA9PiB2YWxpZFNjb3Blcz8uaGFzKHNjb3BlKSA/PyB0cnVlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdyb3VwTWF0Y2goeyBkYXRhLCBvcHRzIH0pIHtcbiAgICBmdW5jdGlvbiBrZXlzKHByb3BzKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZmlsdGVyKChwKSA9PiBwLnR5cGUgPT09IFwia2V5XCIpLm1hcCgocCkgPT4gcC5wcm9wZXJ0eSkuam9pbihcIjtcIik7XG4gICAgfVxuICAgIHJldHVybiAoW2dyb3VwXSkgPT4gKG9wdHMuZ3JvdXBCeURhdGEgPT09IGZhbHNlIHx8IGdyb3VwLmRhdGEgPT09IGRhdGEpICYmIGdyb3VwLm9wdHMuZ3JvdXBCeUtleXMgPT09IG9wdHMuZ3JvdXBCeUtleXMgJiYgZ3JvdXAub3B0cy5ncm91cEJ5Rm4gPT09IG9wdHMuZ3JvdXBCeUZuICYmIGtleXMoZ3JvdXAub3B0cy5wcm9wcykgPT09IGtleXMob3B0cy5wcm9wcyk7XG4gIH1cbiAgc3RhdGljIG1lcmdlUmVxdWVzdHMocmVxdWVzdHMpIHtcbiAgICByZXR1cm4gcmVxdWVzdHMucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgeyBpZCwgZGF0YSwgcmVzb2x2ZSwgcmVqZWN0LCBvcHRzOiB7IHByb3BzLCAuLi5vcHRzIH0gfSkgPT4ge1xuICAgICAgICByZXN1bHQuaWRzLnB1c2goaWQpO1xuICAgICAgICByZXN1bHQucmVqZWN0cy5wdXNoKHJlamVjdCk7XG4gICAgICAgIHJlc3VsdC5yZXNvbHZlcy5wdXNoKHJlc29sdmUpO1xuICAgICAgICByZXN1bHQuZGF0YSA/PyAocmVzdWx0LmRhdGEgPSBkYXRhKTtcbiAgICAgICAgcmVzdWx0Lm9wdHMgPz8gKHJlc3VsdC5vcHRzID0geyAuLi5vcHRzLCBwcm9wczogW10gfSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IGNsb25lID0geyAuLi5wcm9wLCBzY29wZXM6IFtpZF0gfTtcbiAgICAgICAgICBfRGF0YUNvbnRyb2xsZXIuY3JlYXRlSWRzTWFwKGlkLCBjbG9uZSk7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSByZXN1bHQub3B0cy5wcm9wcy5maW5kKFxuICAgICAgICAgICAgKGV4aXN0aW5nKSA9PiBleGlzdGluZy50eXBlID09PSBjbG9uZS50eXBlICYmIF9EYXRhQ29udHJvbGxlci5kZWVwRXF1YWwoZXhpc3RpbmcsIGNsb25lKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdHMucHJvcHMucHVzaChjbG9uZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2guc2NvcGVzID8/IChtYXRjaC5zY29wZXMgPSBbXSk7XG4gICAgICAgICAgbWF0Y2guc2NvcGVzLnB1c2goLi4uY2xvbmUuc2NvcGVzID8/IFtdKTtcbiAgICAgICAgICBpZiAoKG1hdGNoLnR5cGUgPT09IFwia2V5XCIgfHwgbWF0Y2gudHlwZSA9PT0gXCJ2YWx1ZVwiKSAmJiBjbG9uZS5pZHNNYXA/LnNpemUpIHtcbiAgICAgICAgICAgIF9EYXRhQ29udHJvbGxlci5tZXJnZUlkc01hcChjbG9uZS5pZHNNYXAsIG1hdGNoLmlkc01hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgeyBpZHM6IFtdLCByZWplY3RzOiBbXSwgcmVzb2x2ZXM6IFtdLCBkYXRhOiBudWxsLCBvcHRzOiBudWxsIH1cbiAgICApO1xuICB9XG4gIHN0YXRpYyBtZXJnZUlkc01hcChmcm9tTWFwLCB0b01hcCkge1xuICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGZyb21NYXApIHtcbiAgICAgIGNvbnN0IHRvTWFwVmFsdWUgPSB0b01hcC5nZXQoc2NvcGUpO1xuICAgICAgaWYgKHRvTWFwVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgIHRvTWFwVmFsdWUuYWRkKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9NYXAuc2V0KHNjb3BlLCBuZXcgU2V0KGlkcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlSWRzTWFwKHNjb3BlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AuaWQgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBwcm9wLmlkc01hcCA/PyAocHJvcC5pZHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBpZiAocHJvcC5pZHNNYXAuaGFzKHNjb3BlKSkge1xuICAgICAgcHJvcC5pZHNNYXAuZ2V0KHNjb3BlKS5hZGQocHJvcC5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuaWRzTWFwLnNldChzY29wZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW3Byb3AuaWRdKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBsZW5ndGgyO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgbGVuZ3RoMiA9IGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoMiAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gbGVuZ3RoMiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKCFfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgbGVuZ3RoMiA9IGtleXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aDIgIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBsZW5ndGgyIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFfRGF0YUNvbnRyb2xsZXIuc2tpcEtleXMuaGFzKGtleSkgJiYgKCFPYmplY3QuaGFzT3duKGIsIGtleSkgfHwgIV9EYXRhQ29udHJvbGxlci5kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8vIG9wdGltaXplZCB2ZXJzaW9uIG9mIGRlZXAgZXF1YWxpdHkgZm9yIGBtZXJnZVJlcXVlc3RzYCB3aGljaCBjYW4gcG90ZW50aWFsbHkgbG9vcCBvdmVyIDFNIHRpbWVzXG5fRGF0YUNvbnRyb2xsZXIuc2tpcEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpZFwiLCBcImlkc01hcFwiLCBcInR5cGVcIiwgXCJzY29wZXNcIl0pO1xudmFyIERhdGFDb250cm9sbGVyID0gX0RhdGFDb250cm9sbGVyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2F4aXNSZWdpc3RyeS50c1xudmFyIEF4aXNSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5heGVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmhpZGRlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIoYXhpc1R5cGUsIG1vZHVsZSkge1xuICAgIHRoaXMuYXhlc01hcC5zZXQoYXhpc1R5cGUsIG1vZHVsZS5tb2R1bGVGYWN0b3J5KTtcbiAgICBpZiAobW9kdWxlLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuc2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSwgbW9kdWxlLnRoZW1lVGVtcGxhdGUpO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLmhpZGRlbikge1xuICAgICAgdGhpcy5oaWRkZW4uYWRkKGF4aXNUeXBlKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKGF4aXNUeXBlLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3QgYXhpc0ZhY3RvcnkgPSB0aGlzLmF4ZXNNYXAuZ2V0KGF4aXNUeXBlKTtcbiAgICBpZiAoYXhpc0ZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBheGlzRmFjdG9yeShtb2R1bGVDb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmtub3duIGF4aXMgdHlwZTogJHtheGlzVHlwZX1gKTtcbiAgfVxuICBoYXMoYXhpc1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5heGVzTWFwLmhhcyhheGlzVHlwZSk7XG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5heGVzTWFwLmtleXMoKTtcbiAgfVxuICBwdWJsaWNLZXlzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5rZXlzKCldLmZpbHRlcigoaykgPT4gIXRoaXMuaGlkZGVuLmhhcyhrKSk7XG4gIH1cbiAgc2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSwgdGhlbWVUZW1wbGF0ZSkge1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMuc2V0KGF4aXNUeXBlLCB0aGVtZVRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVUZW1wbGF0ZXMuZ2V0KGF4aXNUeXBlKTtcbiAgfVxufTtcbnZhciBheGlzUmVnaXN0cnkgPSBuZXcgQXhpc1JlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvZXhwZWN0ZWRFbnRlcnByaXNlTW9kdWxlcy50c1xudmFyIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiYW5pbWF0aW9uXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXVxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcImFubm90YXRpb25zXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJiYWNrZ3JvdW5kXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXSxcbiAgICBvcHRpb25zSW5uZXJLZXk6IFwiaW1hZ2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJmb3JlZ3JvdW5kXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXSxcbiAgICBvcHRpb25zSW5uZXJLZXk6IFwiaW1hZ2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJjaGFydFRvb2xiYXJcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiY29udGV4dE1lbnVcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwic3RhdHVzQmFyXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJzdGF0dXMtYmFyXCIgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZGF0YVNvdXJjZVwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl1cbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJzeW5jXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcInpvb21cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwidG9wb2xvZ3lcIl0gfSxcbiAge1xuICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgb3B0aW9uc0tleTogXCJncmFkaWVudExlZ2VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl0sXG4gICAgaWRlbnRpZmllcjogXCJncmFkaWVudFwiXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwibmF2aWdhdG9yXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgb3B0aW9uc0lubmVyS2V5OiBcIm1pbmlDaGFydFwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcImFuZ2xlLWNhdGVnb3J5XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwiYW5nbGUtbnVtYmVyXCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaXVzLWNhdGVnb3J5XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaXVzLW51bWJlclwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJvcmRpbmFsLXRpbWVcIiB9LFxuICB7IHR5cGU6IFwiYXhpcy1vcHRpb25cIiwgb3B0aW9uc0tleTogXCJjcm9zc2hhaXJcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiYm94LXBsb3RcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImNhbmRsZXN0aWNrXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJvaGxjXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJidWxsZXRcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImhlYXRtYXBcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcInJhbmdlLWFyZWFcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcInJhbmdlLWJhclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwid2F0ZXJmYWxsXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcIm5pZ2h0aW5nYWxlXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGFyLWFyZWFcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkYXItbGluZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpYWwtYmFyXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGlhbC1jb2x1bW5cIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiaGllcmFyY2h5XCJdLCBpZGVudGlmaWVyOiBcInN1bmJ1cnN0XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImhpZXJhcmNoeVwiXSwgaWRlbnRpZmllcjogXCJ0cmVlbWFwXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1zaGFwZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbGluZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbWFya2VyXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1saW5lLWJhY2tncm91bmRcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiZmxvdy1wcm9wb3J0aW9uXCJdLCBpZGVudGlmaWVyOiBcImNob3JkXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImZsb3ctcHJvcG9ydGlvblwiXSwgaWRlbnRpZmllcjogXCJzYW5rZXlcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzLW9wdGlvblwiLCBvcHRpb25zS2V5OiBcImVycm9yQmFyXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJlcnJvci1iYXJzXCIgfVxuXTtcbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVNlcmllc1R5cGUodHlwZSkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLnNvbWUoKHMpID0+IHMudHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpO1xufVxuZnVuY3Rpb24gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXModHlwZSkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpPy5jaGFydFR5cGVzO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlQ2FydGVzaWFuKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwiY2FydGVzaWFuXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJjYXJ0ZXNpYW5cIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVBvbGFyKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwicG9sYXJcIik7XG4gIHJldHVybiB0eXBlID09PSBcInBvbGFyXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VIaWVyYXJjaHkoc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJoaWVyYXJjaHlcIik7XG4gIHJldHVybiB0eXBlID09PSBcImhpZXJhcmNoeVwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlVG9wb2xvZ3koc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJ0b3BvbG9neVwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwidG9wb2xvZ3lcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZUZsb3dQcm9wb3J0aW9uKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwiZmxvdy1wcm9wb3J0aW9uXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJmbG93LXByb3BvcnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZU1vZHVsZShtb2R1bGUpIHtcbiAgcmV0dXJuIG1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCI7XG59XG5mdW5jdGlvbiB2ZXJpZnlJZk1vZHVsZUV4cGVjdGVkKG1vZHVsZSkge1xuICBpZiAoIWlzRW50ZXJwcmlzZU1vZHVsZShtb2R1bGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlndXJhdGlvbiBlcnJvciwgb25seSBlbnRlcnByaXNlIG1vZHVsZXMgbmVlZCB2ZXJpZmljYXRpb24uXCIpO1xuICB9XG4gIGNvbnN0IHN0dWIgPSBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmluZCgocykgPT4ge1xuICAgIHJldHVybiBzLnR5cGUgPT09IG1vZHVsZS50eXBlICYmIHMub3B0aW9uc0tleSA9PT0gbW9kdWxlLm9wdGlvbnNLZXkgJiYgcy5pZGVudGlmaWVyID09PSBtb2R1bGUuaWRlbnRpZmllciAmJiBtb2R1bGUuY2hhcnRUeXBlcy5ldmVyeSgodCkgPT4gcy5jaGFydFR5cGVzLmluY2x1ZGVzKHQpKTtcbiAgfSk7XG4gIGlmIChzdHViKSB7XG4gICAgc3R1Yi51c2VDb3VudCA/PyAoc3R1Yi51c2VDb3VudCA9IDApO1xuICAgIHN0dWIudXNlQ291bnQrKztcbiAgfVxuICByZXR1cm4gc3R1YiAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VW51c2VkRXhwZWN0ZWRNb2R1bGVzKCkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbHRlcigoeyB1c2VDb3VudCB9KSA9PiB1c2VDb3VudCA9PSBudWxsIHx8IHVzZUNvdW50ID09PSAwKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9sZWdlbmRSZWdpc3RyeS50c1xudmFyIExlZ2VuZFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxlZ2VuZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIobGVnZW5kVHlwZSwgeyBvcHRpb25zS2V5LCBtb2R1bGVGYWN0b3J5LCB0aGVtZVRlbXBsYXRlIH0pIHtcbiAgICB0aGlzLmxlZ2VuZE1hcC5zZXQobGVnZW5kVHlwZSwgeyBvcHRpb25zS2V5LCBtb2R1bGVGYWN0b3J5IH0pO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMuc2V0KG9wdGlvbnNLZXksIHRoZW1lVGVtcGxhdGUpO1xuICB9XG4gIGNyZWF0ZShsZWdlbmRUeXBlLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3QgbGVnZW5kRmFjdG9yeSA9IHRoaXMubGVnZW5kTWFwLmdldChsZWdlbmRUeXBlKT8ubW9kdWxlRmFjdG9yeTtcbiAgICBpZiAobGVnZW5kRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGxlZ2VuZEZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBsZWdlbmQgdHlwZTogJHtsZWdlbmRUeXBlfWApO1xuICB9XG4gIGdldFRoZW1lVGVtcGxhdGVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy50aGVtZVRlbXBsYXRlcyk7XG4gIH1cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmxlZ2VuZE1hcC5lbnRyaWVzKCkpLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIFtsZWdlbmRUeXBlLCByZWNvcmRdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtsZWdlbmRUeXBlXSA9IHJlY29yZC5vcHRpb25zS2V5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxufTtcbnZhciBsZWdlbmRSZWdpc3RyeSA9IG5ldyBMZWdlbmRSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2NoYXJ0VHlwZXMudHNcbnZhciBDaGFydFR5cGVzID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBnZXQoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0KHNlcmllc1R5cGUyKSA/PyBcInVua25vd25cIjtcbiAgfVxuICBpc0NhcnRlc2lhbihzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwiY2FydGVzaWFuXCI7XG4gIH1cbiAgaXNQb2xhcihzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwicG9sYXJcIjtcbiAgfVxuICBpc0hpZXJhcmNoeShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwiaGllcmFyY2h5XCI7XG4gIH1cbiAgaXNUb3BvbG9neShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwidG9wb2xvZ3lcIjtcbiAgfVxuICBpc0Zsb3dQcm9wb3J0aW9uKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfVxuICBnZXQgc2VyaWVzVHlwZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlzKCkpO1xuICB9XG4gIGdldCBjYXJ0ZXNpYW5UeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNDYXJ0ZXNpYW4odCkpO1xuICB9XG4gIGdldCBwb2xhclR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc1BvbGFyKHQpKTtcbiAgfVxuICBnZXQgaGllcmFyY2h5VHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzSGllcmFyY2h5KHQpKTtcbiAgfVxuICBnZXQgdG9wb2xvZ3lUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNUb3BvbG9neSh0KSk7XG4gIH1cbiAgZ2V0IGZsb3dQcm9wb3J0aW9uVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzRmxvd1Byb3BvcnRpb24odCkpO1xuICB9XG59O1xudmFyIENoYXJ0RGVmYXVsdHMgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gIHNldChjaGFydFR5cGUyLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBzdXBlci5zZXQoY2hhcnRUeXBlMiwgbWVyZ2VEZWZhdWx0cyhkZWZhdWx0cywgdGhpcy5nZXQoY2hhcnRUeXBlMikpKTtcbiAgfVxufTtcbnZhciBjaGFydFR5cGVzID0gbmV3IENoYXJ0VHlwZXMoKTtcbnZhciBwdWJsaWNDaGFydFR5cGVzID0gbmV3IENoYXJ0VHlwZXMoKTtcbnZhciBjaGFydERlZmF1bHRzID0gbmV3IENoYXJ0RGVmYXVsdHMoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9zZXJpZXNSZWdpc3RyeS50c1xudmFyIFNlcmllc1JlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNlcmllc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIoc2VyaWVzVHlwZTIsIHtcbiAgICBjaGFydFR5cGVzOiBbY2hhcnRUeXBlMl0sXG4gICAgbW9kdWxlRmFjdG9yeSxcbiAgICB0b29sdGlwRGVmYXVsdHMsXG4gICAgZGVmYXVsdEF4ZXMsXG4gICAgdGhlbWVUZW1wbGF0ZSxcbiAgICBwYWxldHRlRmFjdG9yeSxcbiAgICBzb2xvLFxuICAgIHN0YWNrYWJsZSxcbiAgICBncm91cGFibGUsXG4gICAgc3RhY2tlZEJ5RGVmYXVsdCxcbiAgICBzd2FwRGVmYXVsdEF4ZXNDb25kaXRpb24sXG4gICAgaGlkZGVuXG4gIH0pIHtcbiAgICB0aGlzLnNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIsIHRoZW1lVGVtcGxhdGUpO1xuICAgIHRoaXMuc2VyaWVzTWFwLnNldChzZXJpZXNUeXBlMiwge1xuICAgICAgbW9kdWxlRmFjdG9yeSxcbiAgICAgIHRvb2x0aXBEZWZhdWx0cyxcbiAgICAgIGRlZmF1bHRBeGVzLFxuICAgICAgcGFsZXR0ZUZhY3RvcnksXG4gICAgICBzb2xvLFxuICAgICAgc3RhY2thYmxlLFxuICAgICAgZ3JvdXBhYmxlLFxuICAgICAgc3RhY2tlZEJ5RGVmYXVsdCxcbiAgICAgIHN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvblxuICAgIH0pO1xuICAgIGNoYXJ0VHlwZXMuc2V0KHNlcmllc1R5cGUyLCBjaGFydFR5cGUyKTtcbiAgICBpZiAoIWhpZGRlbikge1xuICAgICAgcHVibGljQ2hhcnRUeXBlcy5zZXQoc2VyaWVzVHlwZTIsIGNoYXJ0VHlwZTIpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUoc2VyaWVzVHlwZTIsIG1vZHVsZUNvbnRleHQpIHtcbiAgICBjb25zdCBzZXJpZXNGYWN0b3J5ID0gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8ubW9kdWxlRmFjdG9yeTtcbiAgICBpZiAoc2VyaWVzRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIHNlcmllc0ZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBzZXJpZXMgdHlwZTogJHtzZXJpZXNUeXBlMn1gKTtcbiAgfVxuICBjbG9uZURlZmF1bHRBeGVzKHNlcmllc1R5cGUyKSB7XG4gICAgY29uc3QgZGVmYXVsdEF4ZXMgPSB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5kZWZhdWx0QXhlcztcbiAgICByZXR1cm4gZGVmYXVsdEF4ZXMgPyB7IGF4ZXM6IGRlZXBDbG9uZShkZWZhdWx0QXhlcykgfSA6IG51bGw7XG4gIH1cbiAgc2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiwgdGhlbWVUZW1wbGF0ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IHRoaXMudGhlbWVUZW1wbGF0ZXMuZ2V0KHNlcmllc1R5cGUyKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChzZXJpZXNUeXBlMiwgbWVyZ2VEZWZhdWx0cyh0aGVtZVRlbXBsYXRlLCBjdXJyZW50VGVtcGxhdGUpKTtcbiAgfVxuICBnZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVUZW1wbGF0ZXMuZ2V0KHNlcmllc1R5cGUyKTtcbiAgfVxuICBnZXRQYWxldHRlRmFjdG9yeShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5wYWxldHRlRmFjdG9yeTtcbiAgfVxuICBnZXRUb29sdGlwRGVmYXVscyhzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy50b29sdGlwRGVmYXVsdHM7XG4gIH1cbiAgaXNTb2xvKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnNvbG8gPz8gZmFsc2U7XG4gIH1cbiAgaXNHcm91cGFibGUoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uZ3JvdXBhYmxlID8/IGZhbHNlO1xuICB9XG4gIGlzU3RhY2thYmxlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnN0YWNrYWJsZSA/PyBmYWxzZTtcbiAgfVxuICBpc1N0YWNrZWRCeURlZmF1bHQoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uc3RhY2tlZEJ5RGVmYXVsdCA/PyBmYWxzZTtcbiAgfVxuICBpc0RlZmF1bHRBeGlzU3dhcE5lZWRlZChvcHRpb25zKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBvcHRpb25zLnNlcmllcyA/PyBbXSkge1xuICAgICAgY29uc3QgeyB0eXBlID0gXCJsaW5lXCIgfSA9IHNlcmllcztcbiAgICAgIGNvbnN0IGlzRGVmYXVsdEF4aXNTd2FwcGVkID0gdGhpcy5zZXJpZXNNYXAuZ2V0KHR5cGUpPy5zd2FwRGVmYXVsdEF4ZXNDb25kaXRpb24/LihzZXJpZXMpO1xuICAgICAgaWYgKGlzRGVmYXVsdEF4aXNTd2FwcGVkICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsICYmIHJlc3VsdCAhPSBpc0RlZmF1bHRBeGlzU3dhcHBlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIFRoZSBwcm92aWRlZCBzZXJpZXMgaGF2ZSBpbmNvbXBhdGlibGUgZGlyZWN0aW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBpc0RlZmF1bHRBeGlzU3dhcHBlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBzZXJpZXNSZWdpc3RyeSA9IG5ldyBTZXJpZXNSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9zeW5jTWFuYWdlci50c1xudmFyIF9TeW5jTWFuYWdlciA9IGNsYXNzIF9TeW5jTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgfVxuICBzdWJzY3JpYmUoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgbGV0IHN5bmNHcm91cCA9IHRoaXMuZ2V0KGdyb3VwSWQpO1xuICAgIGlmICghc3luY0dyb3VwKSB7XG4gICAgICBzeW5jR3JvdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgX1N5bmNNYW5hZ2VyLmNoYXJ0c0dyb3Vwcy5zZXQoZ3JvdXBJZCwgc3luY0dyb3VwKTtcbiAgICB9XG4gICAgc3luY0dyb3VwLmFkZCh0aGlzLmNoYXJ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnN1YnNjcmliZShncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICB0aGlzLmdldChncm91cElkKT8uZGVsZXRlKHRoaXMuY2hhcnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldENoYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0O1xuICB9XG4gIGdldEdyb3VwKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIGNvbnN0IHN5bmNHcm91cCA9IHRoaXMuZ2V0KGdyb3VwSWQpO1xuICAgIHJldHVybiBzeW5jR3JvdXAgPyBBcnJheS5mcm9tKHN5bmNHcm91cCkgOiBbXTtcbiAgfVxuICBnZXRHcm91cFNpYmxpbmdzKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIHJldHVybiB0aGlzLmdldEdyb3VwKGdyb3VwSWQpLmZpbHRlcigoY2hhcnQpID0+IGNoYXJ0ICE9PSB0aGlzLmNoYXJ0KTtcbiAgfVxuICBnZXQoZ3JvdXBJZCkge1xuICAgIHJldHVybiBfU3luY01hbmFnZXIuY2hhcnRzR3JvdXBzLmdldChncm91cElkKTtcbiAgfVxufTtcbl9TeW5jTWFuYWdlci5jaGFydHNHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVAgPSBTeW1ib2woXCJzeW5jLWdyb3VwLWRlZmF1bHRcIik7XG52YXIgU3luY01hbmFnZXIgPSBfU3luY01hbmFnZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3pvb21NYW5hZ2VyLnRzXG52YXIgWm9vbU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGVUcmFja2VyKHZvaWQgMCwgXCJpbml0aWFsXCIpO1xuICAgIHRoaXMucmVqZWN0Q2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICB1cGRhdGVBeGVzKGF4ZXMpIHtcbiAgICBjb25zdCB6b29tTWFuYWdlcnMgPSBuZXcgTWFwKGF4ZXMubWFwKChheGlzKSA9PiBbYXhpcy5pZCwgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzLmlkKV0pKTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLnNldChheGlzLmlkLCB6b29tTWFuYWdlcnMuZ2V0KGF4aXMuaWQpID8/IG5ldyBBeGlzWm9vbU1hbmFnZXIoYXhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS5zaXplID4gMCAmJiBheGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSh0aGlzLnN0YXRlLnN0YXRlSWQoKSwgdGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tLCBjYW5DaGFuZ2VJbml0aWFsID0gdHJ1ZSwgcmVqZWN0Q2FsbGJhY2spIHtcbiAgICBpZiAocmVqZWN0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2tzLnNldChjYWxsZXJJZCwgcmVqZWN0Q2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzWm9vbU1hbmFnZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGNvbnN0IHN0YXRlSWQgPSB0aGlzLnN0YXRlLnN0YXRlSWQoKTtcbiAgICAgIGlmIChzdGF0ZUlkID09PSBcImluaXRpYWxcIiB8fCBzdGF0ZUlkID09PSBjYWxsZXJJZCB8fCBjYW5DaGFuZ2VJbml0aWFsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgICAgICAgaWYgKHN0YXRlSWQgIT09IGNhbGxlcklkKSB7XG4gICAgICAgICAgdGhpcy5yZWplY3RDYWxsYmFja3MuZ2V0KHN0YXRlSWQpPy4oY2FsbGVySWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3RDYWxsYmFjaz8uKHN0YXRlSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNldChjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMudXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbT8uW2F4aXMuZ2V0RGlyZWN0aW9uKCldKTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcGx5Q2hhbmdlcyhjYWxsZXJJZCk7XG4gIH1cbiAgdXBkYXRlQXhpc1pvb20oY2FsbGVySWQsIGF4aXNJZCwgbmV3Wm9vbSkge1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpc0lkKT8udXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgdGhpcy5hcHBseUNoYW5nZXMoY2FsbGVySWQpO1xuICB9XG4gIC8vIEZpcmUgdGhpcyBldmVudCB0byBzaWduYWwgdG8gbGlzdGVuZXJzIHRoYXQgdGhlIHZpZXcgaXMgY2hhbmdpbmcgdGhyb3VnaCBhIHpvb20gYW5kL29yIHBhbiBjaGFuZ2UuXG4gIGZpcmVab29tUGFuU3RhcnRFdmVudChjYWxsZXJJZCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiem9vbS1wYW4tc3RhcnRcIiwgeyB0eXBlOiBcInpvb20tcGFuLXN0YXJ0XCIsIGNhbGxlcklkIH0pO1xuICB9XG4gIGdldFpvb20oKSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGlmIChheGlzLmdldERpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIHggPz8gKHggPSBheGlzLmdldFpvb20oKSk7XG4gICAgICB9IGVsc2UgaWYgKGF4aXMuZ2V0RGlyZWN0aW9uKCkgPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICAgICAgeSA/PyAoeSA9IGF4aXMuZ2V0Wm9vbSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfVxuICB9XG4gIGdldEF4aXNab29tKGF4aXNJZCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNab29tTWFuYWdlcnMuZ2V0KGF4aXNJZCk/LmdldFpvb20oKSA/PyB7IG1pbjogMCwgbWF4OiAxIH07XG4gIH1cbiAgZ2V0QXhpc1pvb21zKCkge1xuICAgIGNvbnN0IGF4ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtheGlzSWQsIGF4aXNdIG9mIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5lbnRyaWVzKCkpIHtcbiAgICAgIGF4ZXNbYXhpc0lkXSA9IHtcbiAgICAgICAgZGlyZWN0aW9uOiBheGlzLmdldERpcmVjdGlvbigpLFxuICAgICAgICB6b29tOiBheGlzLmdldFpvb20oKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF4ZXM7XG4gIH1cbiAgYXBwbHlDaGFuZ2VzKGNhbGxlcklkKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IEFycmF5LmZyb20odGhpcy5heGlzWm9vbU1hbmFnZXJzLnZhbHVlcygpLCAoYXhpcykgPT4gYXhpcy5hcHBseUNoYW5nZXMoKSkuc29tZShCb29sZWFuKTtcbiAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXhlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2F4aXNJZCwgYXhpc10gb2YgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmVudHJpZXMoKSkge1xuICAgICAgYXhlc1theGlzSWRdID0gYXhpcy5nZXRab29tKCk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiem9vbS1jaGFuZ2VcIiwgeyB0eXBlOiBcInpvb20tY2hhbmdlXCIsIC4uLnRoaXMuZ2V0Wm9vbSgpLCBheGVzLCBjYWxsZXJJZCB9KTtcbiAgfVxufTtcbnZhciBBeGlzWm9vbU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGF4aXMpIHtcbiAgICB0aGlzLmF4aXMgPSBheGlzO1xuICAgIGNvbnN0IFttaW4gPSAwLCBtYXggPSAxXSA9IGF4aXMudmlzaWJsZVJhbmdlO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGVUcmFja2VyKHsgbWluLCBtYXggfSk7XG4gICAgdGhpcy5jdXJyZW50Wm9vbSA9IHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpO1xuICB9XG4gIGdldERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzLmRpcmVjdGlvbjtcbiAgfVxuICB1cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tKSB7XG4gICAgdGhpcy5zdGF0ZS5zZXQoY2FsbGVySWQsIG5ld1pvb20pO1xuICB9XG4gIGdldFpvb20oKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKSk7XG4gIH1cbiAgYXBwbHlDaGFuZ2VzKCkge1xuICAgIGNvbnN0IHByZXZab29tID0gdGhpcy5jdXJyZW50Wm9vbTtcbiAgICB0aGlzLmN1cnJlbnRab29tID0gdGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCk7XG4gICAgcmV0dXJuIHByZXZab29tLm1pbiAhPT0gdGhpcy5jdXJyZW50Wm9vbS5taW4gfHwgcHJldlpvb20ubWF4ICE9PSB0aGlzLmN1cnJlbnRab29tLm1heDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQva2V5Ym9hcmQudHNcbnZhciBLZXlib2FyZCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEtleWJvYXJkLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgS2V5Ym9hcmQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXBwaW5nL3ByZXBhcmVBeGlzLnRzXG52YXIgQ2FydGVzaWFuQXhpc1Bvc2l0aW9ucyA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbmZ1bmN0aW9uIGlzQXhpc1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgcG9zaXRpb24gPT09IFwic3RyaW5nXCIgJiYgQ2FydGVzaWFuQXhpc1Bvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBndWVzc0ludmFsaWRQb3NpdGlvbnMoYXhlcykge1xuICBjb25zdCBpbnZhbGlkQXhlcyA9IFtdO1xuICBjb25zdCB1c2VkUG9zaXRpb25zID0gW107XG4gIGNvbnN0IGd1ZXNzZXMgPSBbLi4uQ2FydGVzaWFuQXhpc1Bvc2l0aW9uc107XG4gIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgaWYgKGF4aXMgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5BeGlzKSB7XG4gICAgICBpZiAoaXNBeGlzUG9zaXRpb24oYXhpcy5wb3NpdGlvbikpIHtcbiAgICAgICAgdXNlZFBvc2l0aW9ucy5wdXNoKGF4aXMucG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZEF4ZXMucHVzaChheGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBheGlzIG9mIGludmFsaWRBeGVzKSB7XG4gICAgbGV0IG5leHRHdWVzcztcbiAgICBkbyB7XG4gICAgICBuZXh0R3Vlc3MgPSBndWVzc2VzLnBvcCgpO1xuICAgIH0gd2hpbGUgKG5leHRHdWVzcyAmJiB1c2VkUG9zaXRpb25zLmluY2x1ZGVzKG5leHRHdWVzcykpO1xuICAgIGlmIChuZXh0R3Vlc3MgPT0gbnVsbClcbiAgICAgIGJyZWFrO1xuICAgIGF4aXMucG9zaXRpb24gPSBuZXh0R3Vlc3M7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy9wcmVwYXJlU2VyaWVzLnRzXG52YXIgTUFUQ0hJTkdfS0VZUyA9IFtcImRpcmVjdGlvblwiLCBcInhLZXlcIiwgXCJ5S2V5XCIsIFwic2l6ZUtleVwiLCBcImFuZ2xlS2V5XCIsIFwicmFkaXVzS2V5XCIsIFwibm9ybWFsaXplZFRvXCJdO1xuZnVuY3Rpb24gbWF0Y2hTZXJpZXNPcHRpb25zKHNlcmllcywgb3B0U2VyaWVzLCBvbGRPcHRzU2VyaWVzKSB7XG4gIGNvbnN0IGdlbmVyYXRlS2V5ID0gKHR5cGUsIGksIG9wdHMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbdHlwZV07XG4gICAgZm9yIChjb25zdCBrZXkgb2YgTUFUQ0hJTkdfS0VZUykge1xuICAgICAgaWYgKGtleSBpbiBpICYmIGlba2V5XSAhPSBudWxsKVxuICAgICAgICByZXN1bHQucHVzaChgJHtrZXl9PSR7aVtrZXldfWApO1xuICAgIH1cbiAgICBpZiAob3B0cz8uc2VyaWVzR3JvdXBpbmcpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGBzZXJpZXNHcm91cGluZy5ncm91cElkPSR7b3B0cz8uc2VyaWVzR3JvdXBpbmcuZ3JvdXBJZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiO1wiKTtcbiAgfTtcbiAgY29uc3Qgc2VyaWVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciAoY29uc3QgcyBvZiBzZXJpZXMpIHtcbiAgICBjb25zdCBrZXkgPSBnZW5lcmF0ZUtleShzLnR5cGUsIHMucHJvcGVydGllcywgb2xkT3B0c1Nlcmllcz8uW2lkeF0pO1xuICAgIGlmICghc2VyaWVzTWFwLmhhcyhrZXkpKSB7XG4gICAgICBzZXJpZXNNYXAuc2V0KGtleSwgW10pO1xuICAgIH1cbiAgICBzZXJpZXNNYXAuZ2V0KGtleSk/LnB1c2goW3MsIGlkeCsrXSk7XG4gIH1cbiAgY29uc3Qgb3B0c01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbyBvZiBvcHRTZXJpZXMpIHtcbiAgICBjb25zdCBrZXkgPSBnZW5lcmF0ZUtleShvLnR5cGUsIG8sIG8pO1xuICAgIGlmICghb3B0c01hcC5oYXMoa2V5KSkge1xuICAgICAgb3B0c01hcC5zZXQoa2V5LCBbXSk7XG4gICAgfVxuICAgIG9wdHNNYXAuZ2V0KGtleSk/LnB1c2gobyk7XG4gIH1cbiAgY29uc3Qgb3ZlcmxhcCA9IFsuLi5zZXJpZXNNYXAua2V5cygpXS5zb21lKChrKSA9PiBvcHRzTWFwLmhhcyhrKSk7XG4gIGlmICghb3ZlcmxhcCkge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJuby1vdmVybGFwXCIsIG9sZEtleXM6IHNlcmllc01hcC5rZXlzKCksIG5ld0tleXM6IG9wdHNNYXAua2V5cygpIH07XG4gIH1cbiAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICBsZXQgdGFyZ2V0SWR4ID0gLTE7XG4gIGZvciAoY29uc3QgW2tleSwgb3B0QXJyYXldIG9mIG9wdHNNYXAuZW50cmllcygpKSB7XG4gICAgZm9yIChjb25zdCBvcHRzIG9mIG9wdEFycmF5KSB7XG4gICAgICB0YXJnZXRJZHgrKztcbiAgICAgIGNvbnN0IHNlcmllc0FycmF5ID0gc2VyaWVzTWFwLmdldChrZXkpO1xuICAgICAgaWYgKHNlcmllc0FycmF5ID09IG51bGwgfHwgc2VyaWVzQXJyYXkubGVuZ3RoIDwgMSkge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcHRzLCBpZHg6IHRhcmdldElkeCwgc3RhdHVzOiBcImFkZFwiIH0pO1xuICAgICAgICBzZXJpZXNNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgW291dHB1dFNlcmllcywgb3V0cHV0SWR4XSA9IHNlcmllc0FycmF5LnNoaWZ0KCk7XG4gICAgICBjb25zdCBwcmV2aW91c09wdHMgPSBvbGRPcHRzU2VyaWVzPy5bb3V0cHV0SWR4XSA/PyB7fTtcbiAgICAgIGNvbnN0IGRpZmYyID0ganNvbkRpZmYocHJldmlvdXNPcHRzLCBvcHRzID8/IHt9KTtcbiAgICAgIGNvbnN0IHsgZ3JvdXBJbmRleCwgc3RhY2tJbmRleCB9ID0gZGlmZjI/LnNlcmllc0dyb3VwaW5nID8/IHt9O1xuICAgICAgaWYgKGdyb3VwSW5kZXggIT0gbnVsbCB8fCBzdGFja0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGRpZmY6IGRpZmYyLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcInNlcmllcy1ncm91cGluZ1wiIH0pO1xuICAgICAgfSBlbHNlIGlmIChkaWZmMikge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcHRzLCBzZXJpZXM6IG91dHB1dFNlcmllcywgZGlmZjogZGlmZjIsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwidXBkYXRlXCIgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcHRzLCBzZXJpZXM6IG91dHB1dFNlcmllcywgaWR4OiBvdXRwdXRJZHgsIHN0YXR1czogXCJuby1vcFwiIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNlcmllc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXJpZXNNYXAuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VyaWVzQXJyYXkgb2Ygc2VyaWVzTWFwLnZhbHVlcygpKSB7XG4gICAgZm9yIChjb25zdCBbb3V0cHV0U2VyaWVzLCBvdXRwdXRJZHhdIG9mIHNlcmllc0FycmF5KSB7XG4gICAgICBjaGFuZ2VzLnB1c2goeyBzZXJpZXM6IG91dHB1dFNlcmllcywgaWR4OiBvdXRwdXRJZHgsIHN0YXR1czogXCJyZW1vdmVcIiB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgc3RhdHVzOiBcIm92ZXJsYXBcIiwgY2hhbmdlcyB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXBwaW5nL3R5cGVzLnRzXG5mdW5jdGlvbiBvcHRpb25zVHlwZShpbnB1dCkge1xuICByZXR1cm4gaW5wdXQuc2VyaWVzPy5bMF0/LnR5cGUgPz8gXCJsaW5lXCI7XG59XG5mdW5jdGlvbiBpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJjYXJ0ZXNpYW5cIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzQ2FydGVzaWFuKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZUNhcnRlc2lhbihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcInBvbGFyXCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc1BvbGFyKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZVBvbGFyKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcImhpZXJhcmNoeVwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNIaWVyYXJjaHkoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlSGllcmFyY2h5KHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwidG9wb2xvZ3lcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzVG9wb2xvZ3koc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlVG9wb2xvZ3koc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJmbG93LXByb3BvcnRpb25cIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzRmxvd1Byb3BvcnRpb24oc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlRmxvd1Byb3BvcnRpb24oc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnUG9sYXJDaGFydE9wdGlvbnNXaXRoU2VyaWVzQmFzZWRMZWdlbmQoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgcmV0dXJuIGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhpbnB1dCkgJiYgc3BlY2lmaWVkVHlwZSAhPT0gXCJwaWVcIiAmJiBzcGVjaWZpZWRUeXBlICE9PSBcImRvbnV0XCI7XG59XG5mdW5jdGlvbiBpc1Nlcmllc09wdGlvblR5cGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaGFzKGlucHV0KTtcbn1cbmZ1bmN0aW9uIGlzQXhpc09wdGlvblR5cGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGF4aXNSZWdpc3RyeS5oYXMoaW5wdXQpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tb2R1bGVzTWFuYWdlci50c1xudmFyIE1vZHVsZXNNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBNb2R1bGVNYXAge1xuICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKG0ubW9kdWxlLm9wdGlvbnNLZXkgaW4gb3B0aW9ucyAmJiBpc1Byb3BlcnRpZXMobS5tb2R1bGVJbnN0YW5jZSkpIHtcbiAgICAgICAgbS5tb2R1bGVJbnN0YW5jZS5zZXQob3B0aW9uc1ttLm1vZHVsZS5vcHRpb25zS2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICpsZWdlbmRzKCkge1xuICAgIGZvciAoY29uc3QgeyBtb2R1bGUsIG1vZHVsZUluc3RhbmNlIH0gb2YgdGhpcy5tb2R1bGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtb2R1bGUudHlwZSAhPT0gXCJsZWdlbmRcIilcbiAgICAgICAgY29udGludWU7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IG1vZHVsZS5pZGVudGlmaWVyLFxuICAgICAgICBsZWdlbmQ6IG1vZHVsZUluc3RhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvb3ZlcmxheS9vdmVybGF5LnRzXG52YXIgREVGQVVMVF9PVkVSTEFZX0NMQVNTID0gXCJhZy1jaGFydC1vdmVybGF5XCI7XG52YXIgREVGQVVMVF9PVkVSTEFZX0RBUktfQ0xBU1MgPSBcImFnLWNoYXJ0LWRhcmstb3ZlcmxheVwiO1xudmFyIE92ZXJsYXkgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBkZWZhdWx0TWVzc2FnZUlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB0aGlzLmRlZmF1bHRNZXNzYWdlSWQgPSBkZWZhdWx0TWVzc2FnZUlkO1xuICB9XG4gIGdldFRleHQobG9jYWxlTWFuYWdlcikge1xuICAgIHJldHVybiBsb2NhbGVNYW5hZ2VyLnQodGhpcy50ZXh0ID8/IHRoaXMuZGVmYXVsdE1lc3NhZ2VJZCk7XG4gIH1cbiAgZ2V0RWxlbWVudChhbmltYXRpb25NYW5hZ2VyLCBsb2NhbGVNYW5hZ2VyLCByZWN0KSB7XG4gICAgdGhpcy5jb250ZW50Py5yZW1vdmUoKTtcbiAgICB0aGlzLmZvY3VzQm94ID0gcmVjdDtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgY29uc3QgaHRtbENvbnRlbnQgPSB0aGlzLnJlbmRlcmVyKCk7XG4gICAgICBpZiAoaHRtbENvbnRlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBodG1sQ29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRlbXBEaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IGh0bWxDb250ZW50O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0ZW1wRGl2LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgbWFyZ2luOiBcIjhweFwiLFxuICAgICAgICBmb250OiBcIjEycHggVmVyZGFuYSwgc2Fucy1zZXJpZlwiXG4gICAgICB9KTtcbiAgICAgIGNvbnRlbnQuaW5uZXJUZXh0ID0gdGhpcy5nZXRUZXh0KGxvY2FsZU1hbmFnZXIpO1xuICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXI/LmFuaW1hdGUoe1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMSxcbiAgICAgICAgaWQ6IFwib3ZlcmxheVwiLFxuICAgICAgICBwaGFzZTogXCJhZGRcIixcbiAgICAgICAgZ3JvdXBJZDogXCJvcGFjaXR5XCIsXG4gICAgICAgIG9uVXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgY29udGVudC5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdG9wKCkge1xuICAgICAgICAgIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICByZW1vdmVFbGVtZW50KGNsZWFudXAgPSAoKSA9PiB0aGlzLmNvbnRlbnQ/LnJlbW92ZSgpLCBhbmltYXRpb25NYW5hZ2VyKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gdGhpcztcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICAgIGZyb206IDEsXG4gICAgICAgIHRvOiAwLFxuICAgICAgICBwaGFzZTogXCJyZW1vdmVcIixcbiAgICAgICAgaWQ6IFwib3ZlcmxheVwiLFxuICAgICAgICBncm91cElkOiBcIm9wYWNpdHlcIixcbiAgICAgICAgb25VcGRhdGUodmFsdWUpIHtcbiAgICAgICAgICBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0b3AoKSB7XG4gICAgICAgICAgY2xlYW51cD8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhbnVwPy4oKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9jdXNCb3ggPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE92ZXJsYXkucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT3ZlcmxheS5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvY2hhcnRPdmVybGF5cy50c1xudmFyIENoYXJ0T3ZlcmxheXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRhcmtUaGVtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9hZGluZyA9IG5ldyBPdmVybGF5KFwiYWctY2hhcnQtbG9hZGluZy1vdmVybGF5XCIsIFwib3ZlcmxheUxvYWRpbmdEYXRhXCIpO1xuICAgIHRoaXMubm9EYXRhID0gbmV3IE92ZXJsYXkoXCJhZy1jaGFydC1uby1kYXRhLW92ZXJsYXlcIiwgXCJvdmVybGF5Tm9EYXRhXCIpO1xuICAgIHRoaXMubm9WaXNpYmxlU2VyaWVzID0gbmV3IE92ZXJsYXkoXCJhZy1jaGFydC1uby12aXNpYmxlLXNlcmllc1wiLCBcIm92ZXJsYXlOb1Zpc2libGVTZXJpZXNcIik7XG4gIH1cbiAgZ2V0Rm9jdXNJbmZvKGxvY2FsZU1hbmFnZXIpIHtcbiAgICBmb3IgKGNvbnN0IG92ZXJsYXkgb2YgW3RoaXMubG9hZGluZywgdGhpcy5ub0RhdGEsIHRoaXMubm9WaXNpYmxlU2VyaWVzXSkge1xuICAgICAgaWYgKG92ZXJsYXkuZm9jdXNCb3ggIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvdmVybGF5LmdldFRleHQobG9jYWxlTWFuYWdlciksIHJlY3Q6IG92ZXJsYXkuZm9jdXNCb3ggfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGluZy5yZW1vdmVFbGVtZW50KCk7XG4gICAgdGhpcy5ub0RhdGEucmVtb3ZlRWxlbWVudCgpO1xuICAgIHRoaXMubm9WaXNpYmxlU2VyaWVzLnJlbW92ZUVsZW1lbnQoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJkYXJrVGhlbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwibm9EYXRhXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwibm9WaXNpYmxlU2VyaWVzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9vdmVybGF5L2xvYWRpbmdTcGlubmVyLnRzXG5mdW5jdGlvbiBnZXRMb2FkaW5nU3Bpbm5lcih0ZXh0LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgY29uc3QgeyBhbmltYXRpb25EdXJhdGlvbiB9ID0gUEhBU0VfTUVUQURBVEFbXCJhZGRcIl07XG4gIGNvbnN0IGR1cmF0aW9uID0gYW5pbWF0aW9uRHVyYXRpb24gKiBkZWZhdWx0RHVyYXRpb247XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgYCR7REVGQVVMVF9PVkVSTEFZX0NMQVNTfS0tbG9hZGluZ2AsIHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIGZvbnQ6IFwiMTNweCBWZXJkYW5hLCBzYW5zLXNlcmlmXCIsXG4gICAgLy8gRk9OVF9TSVpFLk1FRElVTVxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgIGFuaW1hdGlvbjogYGFnLWNoYXJ0cy1sb2FkaW5nICR7ZHVyYXRpb259bXMgbGluZWFyIDUwbXMgYm90aGBcbiAgfSk7XG4gIGNvbnN0IG1hdHJpeCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICB3aWR0aDogXCI0NXB4XCIsXG4gICAgaGVpZ2h0OiBcIjQwcHhcIixcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFtcbiAgICAgIFwibGluZWFyLWdyYWRpZW50KCMwMDAwIGNhbGMoMSAqIDEwMCUgLyA2KSwgI2NjYyAwIGNhbGMoMyAqIDEwMCUgLyA2KSwgIzAwMDAgMCksIFwiLFxuICAgICAgXCJsaW5lYXItZ3JhZGllbnQoIzAwMDAgY2FsYygyICogMTAwJSAvIDYpLCAjY2NjIDAgY2FsYyg0ICogMTAwJSAvIDYpLCAjMDAwMCAwKSwgXCIsXG4gICAgICBcImxpbmVhci1ncmFkaWVudCgjMDAwMCBjYWxjKDMgKiAxMDAlIC8gNiksICNjY2MgMCBjYWxjKDUgKiAxMDAlIC8gNiksICMwMDAwIDApXCJcbiAgICBdLmpvaW4oXCJcIiksXG4gICAgYmFja2dyb3VuZFNpemU6IFwiMTBweCA0MDAlXCIsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIixcbiAgICBhbmltYXRpb246IFwiYWctY2hhcnRzLWxvYWRpbmctbWF0cml4IDFzIGluZmluaXRlIGxpbmVhclwiXG4gIH0pO1xuICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgbWFyZ2luVG9wOiBcIjFlbVwiIH0pO1xuICBsYWJlbC5pbm5lclRleHQgPSB0ZXh0O1xuICBjb25zdCBiYWNrZ3JvdW5kID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBgJHtERUZBVUxUX09WRVJMQVlfQ0xBU1N9X19sb2FkaW5nLWJhY2tncm91bmRgLCB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBpbnNldDogXCIwXCIsXG4gICAgb3BhY2l0eTogXCIwLjVcIixcbiAgICB6SW5kZXg6IFwiLTFcIlxuICB9KTtcbiAgY29uc3QgYW5pbWF0aW9uU3R5bGVzID0gY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBhbmltYXRpb25TdHlsZXMuaW5uZXJUZXh0ID0gW1xuICAgIFwiQGtleWZyYW1lcyBhZy1jaGFydHMtbG9hZGluZyB7IGZyb20geyBvcGFjaXR5OiAwIH0gdG8geyBvcGFjaXR5OiAxIH0gfVwiLFxuICAgIFwiQGtleWZyYW1lcyBhZy1jaGFydHMtbG9hZGluZy1tYXRyaXgge1wiLFxuICAgIFwiMCUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSAwJSwgNTAlIDAlLCAxMDAlIDAlOyB9XCIsXG4gICAgXCIxMDAlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMTAwJSwgNTAlIDEwMCUsIDEwMCUgMTAwJTsgfVwiLFxuICAgIFwifVwiXG4gIF0uam9pbihcIiBcIik7XG4gIGNvbnRhaW5lci5yZXBsYWNlQ2hpbGRyZW4oYW5pbWF0aW9uU3R5bGVzLCBtYXRyaXgsIGxhYmVsLCBiYWNrZ3JvdW5kKTtcbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9hZ2dyZWdhdGVGdW5jdGlvbnMudHNcbmZ1bmN0aW9uIHN1bVZhbHVlcyh2YWx1ZXMsIGFjY3VtdWxhdG9yID0gWzAsIDBdKSB7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIGFjY3VtdWxhdG9yWzBdICs9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICBhY2N1bXVsYXRvclsxXSArPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuZnVuY3Rpb24gc3VtKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cFN1bShpZCwgbWF0Y2hHcm91cElkKSB7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBtYXRjaEdyb3VwSWRzOiBtYXRjaEdyb3VwSWQgPyBbbWF0Y2hHcm91cElkXSA6IHZvaWQgMCxcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcyksXG4gICAgZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjogKG5leHQsIGFjYyA9IFswLCAwXSkgPT4ge1xuICAgICAgYWNjWzBdICs9IG5leHQ/LlswXSA/PyAwO1xuICAgICAgYWNjWzFdICs9IG5leHQ/LlsxXSA/PyAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByYW5nZTIoaWQsIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gQ29udGludW91c0RvbWFpbi5leHRlbmREb21haW4odmFsdWVzKVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ3JvdXBDb3VudChpZCkge1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICgpID0+IFswLCAxXSxcbiAgICBncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uOiAobmV4dCwgYWNjID0gWzAsIDBdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwQXZlcmFnZShpZCwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IGRlZiA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBtYXRjaEdyb3VwSWQgPyBbbWF0Y2hHcm91cElkXSA6IHZvaWQgMCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKSxcbiAgICBncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uOiAobmV4dCwgYWNjID0gWzAsIDAsIC0xXSkgPT4ge1xuICAgICAgYWNjWzBdICs9IG5leHQ/LlswXSA/PyAwO1xuICAgICAgYWNjWzFdICs9IG5leHQ/LlsxXSA/PyAwO1xuICAgICAgYWNjWzJdKys7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAgZmluYWxGdW5jdGlvbjogKGFjYyA9IFswLCAwLCAwXSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWNjWzBdICsgYWNjWzFdO1xuICAgICAgaWYgKHJlc3VsdCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgcmVzdWx0IC8gYWNjWzJdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcmVzdWx0IC8gYWNjWzJdLCAwXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBhcmVhKGlkLCBhZ2dGbiwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBtYXRjaEdyb3VwSWQgPyBbbWF0Y2hHcm91cElkXSA6IHZvaWQgMCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzLCBrZXlSYW5nZSA9IFtdKSA9PiB7XG4gICAgICBjb25zdCBrZXlXaWR0aCA9IGtleVJhbmdlWzFdIC0ga2V5UmFuZ2VbMF07XG4gICAgICByZXR1cm4gYWdnRm4uYWdncmVnYXRlRnVuY3Rpb24odmFsdWVzKS5tYXAoKHYpID0+IHYgLyBrZXlXaWR0aCk7XG4gICAgfVxuICB9O1xuICBpZiAoYWdnRm4uZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbikge1xuICAgIHJlc3VsdC5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uID0gYWdnRm4uZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZWRWYWx1ZShvbmx5UG9zaXRpdmUpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZGF0dW0pKSB7XG4gICAgICAgIHJldHVybiBkYXR1bTtcbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IG9ubHlQb3NpdGl2ZSA/IE1hdGgubWF4KDAsIGRhdHVtKSA6IGRhdHVtO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWUoKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICByZXR1cm4gKGRhdHVtKSA9PiB7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGRhdHVtKSkge1xuICAgICAgICByZXR1cm4gZGF0dW07XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFpbGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgICB2YWx1ZSArPSBkYXR1bTtcbiAgICAgIHJldHVybiB0cmFpbGluZ1ZhbHVlO1xuICAgIH07XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbWVtby50c1xudmFyIG1lbW9yaXplZEZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWVtbyhwYXJhbXMsIGZuR2VuZXJhdG9yKSB7XG4gIGNvbnN0IHNlcmlhbGlzZWRQYXJhbXMgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDApO1xuICBpZiAoIW1lbW9yaXplZEZucy5oYXMoZm5HZW5lcmF0b3IpKSB7XG4gICAgbWVtb3JpemVkRm5zLnNldChmbkdlbmVyYXRvciwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgaWYgKCFtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uaGFzKHNlcmlhbGlzZWRQYXJhbXMpKSB7XG4gICAgbWVtb3JpemVkRm5zLmdldChmbkdlbmVyYXRvcik/LnNldChzZXJpYWxpc2VkUGFyYW1zLCBmbkdlbmVyYXRvcihwYXJhbXMpKTtcbiAgfVxuICByZXR1cm4gbWVtb3JpemVkRm5zLmdldChmbkdlbmVyYXRvcik/LmdldChzZXJpYWxpc2VkUGFyYW1zKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9wcm9jZXNzb3JzLnRzXG52YXIgU01BTExFU1RfS0VZX0lOVEVSVkFMID0ge1xuICB0eXBlOiBcInJlZHVjZXJcIixcbiAgcHJvcGVydHk6IFwic21hbGxlc3RLZXlJbnRlcnZhbFwiLFxuICBpbml0aWFsVmFsdWU6IEluZmluaXR5LFxuICByZWR1Y2VyOiAoKSA9PiB7XG4gICAgbGV0IHByZXZYID0gTmFOO1xuICAgIHJldHVybiAoc21hbGxlc3RTb0ZhciA9IEluZmluaXR5LCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBuZXh0WCA9IG5leHQua2V5c1swXTtcbiAgICAgIGNvbnN0IGludGVydmFsID0gTWF0aC5hYnMobmV4dFggLSBwcmV2WCk7XG4gICAgICBwcmV2WCA9IG5leHRYO1xuICAgICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwICYmIGludGVydmFsIDwgc21hbGxlc3RTb0Zhcikge1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc21hbGxlc3RTb0ZhcjtcbiAgICB9O1xuICB9XG59O1xudmFyIExBUkdFU1RfS0VZX0lOVEVSVkFMID0ge1xuICB0eXBlOiBcInJlZHVjZXJcIixcbiAgcHJvcGVydHk6IFwibGFyZ2VzdEtleUludGVydmFsXCIsXG4gIGluaXRpYWxWYWx1ZTogLUluZmluaXR5LFxuICByZWR1Y2VyOiAoKSA9PiB7XG4gICAgbGV0IHByZXZYID0gTmFOO1xuICAgIHJldHVybiAobGFyZ2VzdFNvRmFyID0gLUluZmluaXR5LCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBuZXh0WCA9IG5leHQua2V5c1swXTtcbiAgICAgIGNvbnN0IGludGVydmFsID0gTWF0aC5hYnMobmV4dFggLSBwcmV2WCk7XG4gICAgICBwcmV2WCA9IG5leHRYO1xuICAgICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwICYmIGludGVydmFsID4gbGFyZ2VzdFNvRmFyKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXJnZXN0U29GYXI7XG4gICAgfTtcbiAgfVxufTtcbnZhciBTT1JUX0RPTUFJTl9HUk9VUFMgPSB7XG4gIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gIHByb3BlcnR5OiBcInNvcnRlZEdyb3VwRG9tYWluXCIsXG4gIGNhbGN1bGF0ZTogKHsgZG9tYWluOiB7IGdyb3VwcyB9IH0pID0+IGdyb3Vwcz8uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhW2ldIC0gYltpXTtcbiAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pXG59O1xuZnVuY3Rpb24gbm9ybWFsaXNlRm5CdWlsZGVyKHsgbm9ybWFsaXNlVG8sIG1vZGUgfSkge1xuICBjb25zdCBub3JtYWxpc2UgPSAodmFsLCBleHRlbnQyKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsICogbm9ybWFsaXNlVG8gLyBleHRlbnQyO1xuICAgIGlmIChyZXN1bHQgPj0gMCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKG5vcm1hbGlzZVRvLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoLW5vcm1hbGlzZVRvLCByZXN1bHQpO1xuICB9O1xuICByZXR1cm4gKCkgPT4gKCkgPT4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzRXh0ZW50ID0gWzAsIDBdO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICBjb25zdCB2YWx1ZUV4dGVudCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogTWF0aC5tYXgoLi4udmFsdWUpO1xuICAgICAgY29uc3QgdmFsSWR4ID0gdmFsdWVFeHRlbnQgPCAwID8gMCA6IDE7XG4gICAgICBpZiAobW9kZSA9PT0gXCJzdW1cIikge1xuICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSArPSB2YWx1ZUV4dGVudDtcbiAgICAgIH0gZWxzZSBpZiAodmFsSWR4ID09PSAwKSB7XG4gICAgICAgIHZhbHVlc0V4dGVudFt2YWxJZHhdID0gTWF0aC5taW4odmFsdWVzRXh0ZW50W3ZhbElkeF0sIHZhbHVlRXh0ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc0V4dGVudFt2YWxJZHhdID0gTWF0aC5tYXgodmFsdWVzRXh0ZW50W3ZhbElkeF0sIHZhbHVlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW50MiA9IE1hdGgubWF4KE1hdGguYWJzKHZhbHVlc0V4dGVudFswXSksIHZhbHVlc0V4dGVudFsxXSk7XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyBub3JtYWxpc2UodmFsdWUsIGV4dGVudDIpIDogdmFsdWUubWFwKCh2KSA9PiBub3JtYWxpc2UodiwgZXh0ZW50MikpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUdyb3VwVG8obWF0Y2hHcm91cElkcywgbm9ybWFsaXNlVG8sIG1vZGUgPSBcInN1bVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBtYXRjaEdyb3VwSWRzLFxuICAgIGFkanVzdDogbWVtbyh7IG5vcm1hbGlzZVRvLCBtb2RlIH0sIG5vcm1hbGlzZUZuQnVpbGRlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZVByb3BlcnR5Rm5CdWlsZGVyKHtcbiAgbm9ybWFsaXNlVG8sXG4gIHplcm9Eb21haW4sXG4gIHJhbmdlTWluLFxuICByYW5nZU1heFxufSkge1xuICBjb25zdCBub3JtYWxpc2VTcGFuID0gbm9ybWFsaXNlVG9bMV0gLSBub3JtYWxpc2VUb1swXTtcbiAgY29uc3Qgbm9ybWFsaXNlID0gKHZhbCwgc3RhcnQsIHNwYW4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBub3JtYWxpc2VUb1swXSArICh2YWwgLSBzdGFydCkgLyBzcGFuICogbm9ybWFsaXNlU3BhbjtcbiAgICBpZiAoc3BhbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHplcm9Eb21haW47XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgPj0gbm9ybWFsaXNlVG9bMV0pIHtcbiAgICAgIHJldHVybiBub3JtYWxpc2VUb1sxXTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA8IG5vcm1hbGlzZVRvWzBdKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXNlVG9bMF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiAoKSA9PiAocERhdGEsIHBJZHgpID0+IHtcbiAgICBsZXQgW3N0YXJ0LCBlbmRdID0gcERhdGEuZG9tYWluLnZhbHVlc1twSWR4XTtcbiAgICBpZiAocmFuZ2VNaW4gIT0gbnVsbClcbiAgICAgIHN0YXJ0ID0gcmFuZ2VNaW47XG4gICAgaWYgKHJhbmdlTWF4ICE9IG51bGwpXG4gICAgICBlbmQgPSByYW5nZU1heDtcbiAgICBjb25zdCBzcGFuID0gZW5kIC0gc3RhcnQ7XG4gICAgcERhdGEuZG9tYWluLnZhbHVlc1twSWR4XSA9IFtub3JtYWxpc2VUb1swXSwgbm9ybWFsaXNlVG9bMV1dO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgcERhdGEuZGF0YSkge1xuICAgICAgbGV0IGdyb3VwVmFsdWVzID0gZ3JvdXAudmFsdWVzO1xuICAgICAgaWYgKHBEYXRhLnR5cGUgPT09IFwidW5ncm91cGVkXCIpIHtcbiAgICAgICAgZ3JvdXBWYWx1ZXMgPSBbZ3JvdXBWYWx1ZXNdO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZXMgb2YgZ3JvdXBWYWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzW3BJZHhdID0gbm9ybWFsaXNlKHZhbHVlc1twSWR4XSwgc3RhcnQsIHNwYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZVByb3BlcnR5VG8ocHJvcGVydHksIG5vcm1hbGlzZVRvLCB6ZXJvRG9tYWluLCByYW5nZU1pbiwgcmFuZ2VNYXgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInByb3BlcnR5LXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIHByb3BlcnR5LFxuICAgIGFkanVzdDogbWVtbyh7IG5vcm1hbGlzZVRvLCByYW5nZU1pbiwgcmFuZ2VNYXgsIHplcm9Eb21haW4gfSwgbm9ybWFsaXNlUHJvcGVydHlGbkJ1aWxkZXIpXG4gIH07XG59XG5mdW5jdGlvbiBhbmltYXRpb25WYWxpZGF0aW9uKHZhbHVlS2V5SWRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwcm9jZXNzb3JcIixcbiAgICBwcm9wZXJ0eTogXCJhbmltYXRpb25WYWxpZGF0aW9uXCIsXG4gICAgY2FsY3VsYXRlKHJlc3VsdCkge1xuICAgICAgY29uc3QgeyBrZXlzLCB2YWx1ZXMgfSA9IHJlc3VsdC5kZWZzO1xuICAgICAgY29uc3QgeyBpbnB1dCwgZGF0YSB9ID0gcmVzdWx0O1xuICAgICAgbGV0IHVuaXF1ZUtleXMgPSB0cnVlO1xuICAgICAgbGV0IG9yZGVyZWRLZXlzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB2YWx1ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKCF2YWx1ZUtleUlkcz8uaW5jbHVkZXModmFsdWVzW2tdLmlkKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFsdWVLZXlzLnB1c2goW2ssIHZhbHVlc1trXV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc0tleSA9IChpZHgsIGRlZiwgdHlwZSkgPT4ge1xuICAgICAgICBpZiAoZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsdWVzID0gcmVzdWx0LmRvbWFpblt0eXBlXVtpZHhdO1xuICAgICAgICAgIHVuaXF1ZUtleXMgJiYgKHVuaXF1ZUtleXMgPSBrZXlWYWx1ZXMubGVuZ3RoID09PSBpbnB1dC5jb3VudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0VmFsdWUgPSBkYXRhWzBdPy5bdHlwZV1baWR4XTtcbiAgICAgICAgZm9yIChsZXQgZCA9IDE7ICh1bmlxdWVLZXlzIHx8IG9yZGVyZWRLZXlzKSAmJiBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xuICAgICAgICAgIGNvbnN0IGtleVZhbHVlID0gZGF0YVtkXVt0eXBlXVtpZHhdO1xuICAgICAgICAgIG9yZGVyZWRLZXlzICYmIChvcmRlcmVkS2V5cyA9IGxhc3RWYWx1ZSA8PSBrZXlWYWx1ZSk7XG4gICAgICAgICAgdW5pcXVlS2V5cyAmJiAodW5pcXVlS2V5cyA9IGxhc3RWYWx1ZSAhPT0ga2V5VmFsdWUpO1xuICAgICAgICAgIGxhc3RWYWx1ZSA9IGtleVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgayA9IDA7ICh1bmlxdWVLZXlzIHx8IG9yZGVyZWRLZXlzKSAmJiBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICBwcm9jZXNzS2V5KGssIGtleXNba10sIFwia2V5c1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGsgPSAwOyAodW5pcXVlS2V5cyB8fCBvcmRlcmVkS2V5cykgJiYgayA8IHZhbHVlS2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCBbaWR4LCBrZXldID0gdmFsdWVLZXlzW2tdO1xuICAgICAgICBwcm9jZXNzS2V5KGlkeCwga2V5LCBcInZhbHVlc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHVuaXF1ZUtleXMsIG9yZGVyZWRLZXlzIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRHcm91cEFjY0ZuKHsgbW9kZSwgc2VwYXJhdGVOZWdhdGl2ZSB9KSB7XG4gIHJldHVybiAoKSA9PiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICBjb25zdCBhY2MgPSBbMCwgMF07XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWwgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgY29uc3QgYWNjSW5kZXggPSBpc05lZ2F0aXZlKGN1cnJlbnRWYWwpICYmIHNlcGFyYXRlTmVnYXRpdmUgPyAwIDogMTtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoY3VycmVudFZhbCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG1vZGUgPT09IFwibm9ybWFsXCIpXG4gICAgICAgIGFjY1thY2NJbmRleF0gKz0gY3VycmVudFZhbDtcbiAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2NbYWNjSW5kZXhdO1xuICAgICAgaWYgKG1vZGUgPT09IFwidHJhaWxpbmdcIilcbiAgICAgICAgYWNjW2FjY0luZGV4XSArPSBjdXJyZW50VmFsO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkR3JvdXBXaW5kb3dBY2NGbih7IG1vZGUsIHN1bTogc3VtMiB9KSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgbGFzdFZhbHVlcyA9IFtdO1xuICAgIGxldCBmaXJzdFJvdyA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICAgICAgbGV0IGFjYyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbCA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gZmlyc3RSb3cgJiYgc3VtMiA9PT0gXCJjdXJyZW50XCIgPyAwIDogbGFzdFZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICAgICAgbGFzdFZhbHVlc1t2YWx1ZUlkeF0gPSBjdXJyZW50VmFsO1xuICAgICAgICAgIGNvbnN0IHN1bVZhbHVlID0gc3VtMiA9PT0gXCJjdXJyZW50XCIgPyBjdXJyZW50VmFsIDogbGFzdFZhbHVlO1xuICAgICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoY3VycmVudFZhbCkgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2M7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgIGFjYyArPSBzdW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjYztcbiAgICAgICAgICBpZiAobW9kZSA9PT0gXCJ0cmFpbGluZ1wiKSB7XG4gICAgICAgICAgICBhY2MgKz0gc3VtVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcnN0Um93ID0gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlR3JvdXAobWF0Y2hHcm91cElkLCBtb2RlLCBzdW0yLCBzZXBhcmF0ZU5lZ2F0aXZlID0gZmFsc2UpIHtcbiAgbGV0IGFkanVzdDtcbiAgaWYgKG1vZGUuc3RhcnRzV2l0aChcIndpbmRvd1wiKSkge1xuICAgIGNvbnN0IG1vZGVQYXJhbSA9IG1vZGUuZW5kc1dpdGgoXCItdHJhaWxpbmdcIikgPyBcInRyYWlsaW5nXCIgOiBcIm5vcm1hbFwiO1xuICAgIGFkanVzdCA9IG1lbW8oeyBtb2RlOiBtb2RlUGFyYW0sIHN1bTogc3VtMiB9LCBidWlsZEdyb3VwV2luZG93QWNjRm4pO1xuICB9IGVsc2Uge1xuICAgIGFkanVzdCA9IG1lbW8oeyBtb2RlLCBzZXBhcmF0ZU5lZ2F0aXZlIH0sIGJ1aWxkR3JvdXBBY2NGbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIGFkanVzdFxuICB9O1xufVxuZnVuY3Rpb24gZ3JvdXBTdGFja0FjY0ZuKCkge1xuICByZXR1cm4gKCkgPT4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XG4gICAgY29uc3QgYWNjID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgbGV0IHN0YWNrQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgYWNjW3N0YWNrQ291bnRdID0gTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiBOYU47XG4gICAgICBzdGFja0NvdW50ICs9IDE7XG4gICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjLnN1YmFycmF5KDAsIHN0YWNrQ291bnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVTdGFjayhtYXRjaEdyb3VwSWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIGFkanVzdDogZ3JvdXBTdGFja0FjY0ZuXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmKHByZXZpb3VzRGF0YSwgdXBkYXRlTW92ZWREYXRhID0gdHJ1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHk6IFwiZGlmZlwiLFxuICAgIGNhbGN1bGF0ZTogKHByb2Nlc3NlZERhdGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBsZW5ndGgyID0gTWF0aC5tYXgocHJldmlvdXNEYXRhLmRhdGEubGVuZ3RoLCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBwcmV2aW91c0RhdGEuZGF0YVtpXTtcbiAgICAgICAgY29uc3QgZGF0dW0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaV07XG4gICAgICAgIGNvbnN0IHByZXZJZCA9IHByZXYgPyBjcmVhdGVEYXR1bUlkKHByZXYua2V5cykgOiBcIlwiO1xuICAgICAgICBjb25zdCBkYXR1bUlkID0gZGF0dW0gPyBjcmVhdGVEYXR1bUlkKGRhdHVtLmtleXMpIDogXCJcIjtcbiAgICAgICAgaWYgKGRhdHVtICYmIHByZXYgJiYgcHJldklkID09PSBkYXR1bUlkKSB7XG4gICAgICAgICAgaWYgKCFhcnJheXNFcXVhbChwcmV2LnZhbHVlcywgZGF0dW0udmFsdWVzKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZC5oYXMoZGF0dW1JZCkpIHtcbiAgICAgICAgICBpZiAodXBkYXRlTW92ZWREYXRhIHx8ICFhcnJheXNFcXVhbChyZW1vdmVkLmdldChkYXR1bUlkKS52YWx1ZXMsIGRhdHVtLnZhbHVlcykpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgICAgIG1vdmVkLnNldChkYXR1bUlkLCBkYXR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZWQuZGVsZXRlKGRhdHVtSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdHVtKSB7XG4gICAgICAgICAgYWRkZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkZWQuaGFzKHByZXZJZCkpIHtcbiAgICAgICAgICBpZiAodXBkYXRlTW92ZWREYXRhIHx8ICFhcnJheXNFcXVhbChhZGRlZC5nZXQocHJldklkKS52YWx1ZXMsIHByZXYudmFsdWVzKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQocHJldklkLCBwcmV2KTtcbiAgICAgICAgICAgIG1vdmVkLnNldChwcmV2SWQsIHByZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZC5kZWxldGUocHJldklkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICAgICAgdXBkYXRlZC5kZWxldGUocHJldklkKTtcbiAgICAgICAgICByZW1vdmVkLnNldChwcmV2SWQsIHByZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFuZ2VkID0gYWRkZWQuc2l6ZSA+IDAgfHwgdXBkYXRlZC5zaXplID4gMCB8fCByZW1vdmVkLnNpemUgPiAwO1xuICAgICAgcmV0dXJuIHsgY2hhbmdlZCwgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQsIG1vdmVkIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0dW1JZChrZXlzLCAuLi5leHRyYUtleXMpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICByZXN1bHQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShrZXkpKS5qb2luKFwiX19fXCIpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGtleXMpO1xuICB9XG4gIGNvbnN0IHByaW1pdGl2ZVR5cGUgPSB0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHJlc3VsdCA9PT0gXCJib29sZWFuXCIgfHwgcmVzdWx0IGluc3RhbmNlb2YgRGF0ZTtcbiAgaWYgKHByaW1pdGl2ZVR5cGUgJiYgZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgKz0gYF9fXyR7ZXh0cmFLZXlzLmpvaW4oXCJfX19cIil9YDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzLnRzXG52YXIgU2VyaWVzTm9kZVBpY2tNb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VyaWVzTm9kZVBpY2tNb2RlMikgPT4ge1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJFWEFDVF9TSEFQRV9NQVRDSFwiXSA9IDBdID0gXCJFWEFDVF9TSEFQRV9NQVRDSFwiO1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJORUFSRVNUX0JZX01BSU5fQVhJU19GSVJTVFwiXSA9IDFdID0gXCJORUFSRVNUX0JZX01BSU5fQVhJU19GSVJTVFwiO1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVFwiXSA9IDJdID0gXCJORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVFwiO1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJORUFSRVNUX05PREVcIl0gPSAzXSA9IFwiTkVBUkVTVF9OT0RFXCI7XG4gIHJldHVybiBTZXJpZXNOb2RlUGlja01vZGUyO1xufSkoU2VyaWVzTm9kZVBpY2tNb2RlIHx8IHt9KTtcbmZ1bmN0aW9uIGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzQ29udGludW91cyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBiYXNpY0Rpc2NyZXRlQ2hlY2tEYXR1bVZhbGlkYXRpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG59XG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSB7XG4gIHN3aXRjaCAoc2NhbGVUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJsb2dcIjpcbiAgICBjYXNlIFwib3JkaW5hbC10aW1lXCI6XG4gICAgY2FzZSBcInRpbWVcIjpcbiAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgIHJldHVybiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGJhc2ljRGlzY3JldGVDaGVja0RhdHVtVmFsaWRhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVUeXBlKHNjYWxlVHlwZSkge1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwibG9nXCI6XG4gICAgY2FzZSBcInRpbWVcIjpcbiAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgIHJldHVybiBcInJhbmdlXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNhdGVnb3J5XCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGtleVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcHJvcGVydHk6IHByb3BOYW1lLFxuICAgIHR5cGU6IFwia2V5XCIsXG4gICAgdmFsdWVUeXBlOiBnZXRWYWx1ZVR5cGUoc2NhbGVUeXBlKSxcbiAgICB2YWxpZGF0aW9uOiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSxcbiAgICAuLi5vcHRzXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcHJvcGVydHk6IHByb3BOYW1lLFxuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICB2YWx1ZVR5cGU6IGdldFZhbHVlVHlwZShzY2FsZVR5cGUpLFxuICAgIHZhbGlkYXRpb246IGdldFZhbGlkYXRpb25GbihzY2FsZVR5cGUpLFxuICAgIC4uLm9wdHNcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJhbmdlZFZhbHVlUHJvcGVydHkocHJvcE5hbWUsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHksIC4uLmRlZk9wdHMgfSA9IG9wdHM7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB2YWx1ZVR5cGU6IFwicmFuZ2VcIixcbiAgICB2YWxpZGF0aW9uOiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbixcbiAgICBwcm9jZXNzb3I6ICgpID0+IChkYXR1bSkgPT4gaXNGaW5pdGVOdW1iZXIoZGF0dW0pID8gY2xhbXAobWluLCBkYXR1bSwgbWF4KSA6IGRhdHVtLFxuICAgIC4uLmRlZk9wdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgb25seVBvc2l0aXZlLCAuLi5kZWZPcHRzIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4udmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBkZWZPcHRzKSxcbiAgICBwcm9jZXNzb3I6IGFjY3VtdWxhdGVkVmFsdWUob25seVBvc2l0aXZlKVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi52YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpLFxuICAgIHByb2Nlc3NvcjogdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlKClcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgbW9kZSwgc3VtMiA9IFwiY3VycmVudFwiLCBvcHRzLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIFtcbiAgICB2YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpLFxuICAgIGFjY3VtdWxhdGVHcm91cChvcHRzLmdyb3VwSWQsIG1vZGUsIHN1bTIsIG9wdHMuc2VwYXJhdGVOZWdhdGl2ZSksXG4gICAgLi4ub3B0cy5yYW5nZUlkICE9IG51bGwgPyBbcmFuZ2UyKG9wdHMucmFuZ2VJZCwgb3B0cy5ncm91cElkKV0gOiBbXVxuICBdO1xufVxuZnVuY3Rpb24gZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cykge1xuICByZXR1cm4gW3ZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyksIGFjY3VtdWxhdGVTdGFjayhvcHRzLmdyb3VwSWQpXTtcbn1cbnZhciBTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGV2ZW50LCB7IGRhdHVtIH0sIHNlcmllcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcbiAgICB0aGlzLnNlcmllc0lkID0gc2VyaWVzLmlkO1xuICB9XG59O1xudmFyIFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXJpZXMsIHNlcmllc0dyb3VwaW5nLCBvbGRHcm91cGluZykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgIHRoaXMuc2VyaWVzR3JvdXBpbmcgPSBzZXJpZXNHcm91cGluZztcbiAgICB0aGlzLm9sZEdyb3VwaW5nID0gb2xkR3JvdXBpbmc7XG4gICAgdGhpcy50eXBlID0gXCJncm91cGluZ0NoYW5nZWRcIjtcbiAgfVxufTtcbnZhciBTZXJpZXMgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvcihzZXJpZXNPcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnNlcmllc0dyb3VwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuaW50ZXJuYWxJZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIC8vIFRoZSBncm91cCBub2RlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBub2RlcyB1c2VkIHRvIHJlbmRlciB0aGlzIHNlcmllcy5cbiAgICB0aGlzLnJvb3RHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwic2VyaWVzUm9vdFwiLCBpc1ZpcnR1YWw6IHRydWUgfSk7XG4gICAgdGhpcy5heGVzID0ge1xuICAgICAgW1wieFwiIC8qIFggKi9dOiB2b2lkIDAsXG4gICAgICBbXCJ5XCIgLyogWSAqL106IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5kaXJlY3Rpb25zID0gW1wieFwiIC8qIFggKi8sIFwieVwiIC8qIFkgKi9dO1xuICAgIC8vIEZsYWcgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCByZWNhbGN1bGF0ZSBub2RlIGRhdGEuXG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIHRoaXMubW9kdWxlTWFwID0gbmV3IE1vZHVsZU1hcCgpO1xuICAgIHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIgPSAtMTtcbiAgICB0aGlzLnNlcmllc0xpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlID0gbmV3IExSVUNhY2hlKCk7XG4gICAgY29uc3Qge1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzID0gWzEgLyogTkVBUkVTVF9CWV9NQUlOX0FYSVNfRklSU1QgKi9dLFxuICAgICAgZGlyZWN0aW9uS2V5cyA9IHt9LFxuICAgICAgZGlyZWN0aW9uTmFtZXMgPSB7fSxcbiAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWwgPSB0cnVlLFxuICAgICAgY2FuSGF2ZUF4ZXMgPSBmYWxzZVxuICAgIH0gPSBzZXJpZXNPcHRzO1xuICAgIHRoaXMuY3R4ID0gbW9kdWxlQ3R4O1xuICAgIHRoaXMuZGlyZWN0aW9uS2V5cyA9IGRpcmVjdGlvbktleXM7XG4gICAgdGhpcy5kaXJlY3Rpb25OYW1lcyA9IGRpcmVjdGlvbk5hbWVzO1xuICAgIHRoaXMuY2FuSGF2ZUF4ZXMgPSBjYW5IYXZlQXhlcztcbiAgICB0aGlzLmNvbnRlbnRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1jb250ZW50YCxcbiAgICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxuICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIilcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaW50ZXJuYWxJZH0taGlnaGxpZ2h0YCxcbiAgICAgIGlzVmlydHVhbDogY29udGVudEdyb3VwVmlydHVhbCxcbiAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImhpZ2hsaWdodFwiKVxuICAgIH0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0Tm9kZSA9IHRoaXMuaGlnaGxpZ2h0R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJoaWdobGlnaHROb2RlXCIsIHpJbmRleDogMCB9KSk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbCA9IHRoaXMuaGlnaGxpZ2h0R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJoaWdobGlnaHRMYWJlbFwiLCB6SW5kZXg6IDEwIH0pKTtcbiAgICB0aGlzLnBpY2tNb2RlcyA9IHBpY2tNb2RlcztcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaW50ZXJuYWxJZH0tc2VyaWVzLWxhYmVsc2AsXG4gICAgICAgIHpJbmRleDogOCAvKiBTRVJJRVNfTEFCRUxfWklOREVYICovXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5hbm5vdGF0aW9uR3JvdXAgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYW5ub3RhdGlvbmAsXG4gICAgICBpc1ZpcnR1YWw6IGNvbnRlbnRHcm91cFZpcnR1YWwsXG4gICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJhbm5vdGF0aW9uXCIpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM/LmlkID8/IHRoaXMuaW50ZXJuYWxJZDtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlID8/IFwiXCI7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEgPz8gdGhpcy5fY2hhcnREYXRhO1xuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9wZXJ0aWVzLnZpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnZpc2libGVNYXliZUNoYW5nZWQoKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnZpc2libGU7XG4gIH1cbiAgZ2V0IGhhc0RhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSAhPSBudWxsICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwO1xuICB9XG4gIGdldCB0b29sdGlwRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvb2x0aXA/LmVuYWJsZWQgPz8gZmFsc2U7XG4gIH1cbiAgb25EYXRhQ2hhbmdlKCkge1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgc2V0T3B0aW9uc0RhdGEoaW5wdXQpIHtcbiAgICB0aGlzLl9kYXRhID0gaW5wdXQ7XG4gICAgdGhpcy5vbkRhdGFDaGFuZ2UoKTtcbiAgfVxuICBzZXRDaGFydERhdGEoaW5wdXQpIHtcbiAgICB0aGlzLl9jaGFydERhdGEgPSBpbnB1dDtcbiAgICBpZiAodGhpcy5kYXRhID09PSBpbnB1dCkge1xuICAgICAgdGhpcy5vbkRhdGFDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgb25TZXJpZXNHcm91cGluZ0NoYW5nZShwcmV2LCBuZXh0KSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCB0eXBlLCB2aXNpYmxlIH0gPSB0aGlzO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIuZGVyZWdpc3RlclNlcmllcyh7IGlkOiBpbnRlcm5hbElkLCB0eXBlIH0pO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLnJlZ2lzdGVyU2VyaWVzKHsgaWQ6IGludGVybmFsSWQsIHR5cGUsIHZpc2libGUsIHNlcmllc0dyb3VwaW5nOiBuZXh0IH0pO1xuICAgIH1cbiAgICB0aGlzLmZpcmVFdmVudChuZXcgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQodGhpcywgbmV4dCwgcHJldikpO1xuICB9XG4gIGdldEJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHsgaW5uZXI6IDEsIG91dGVyOiAwIH07XG4gIH1cbiAgZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlLCBzdWJJbmRleCA9IDApIHtcbiAgICBsZXQgbWFpbkFkanVzdCA9IDA7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgY2FzZSBcInBhdGhzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxhYmVsc1wiOlxuICAgICAgICBtYWluQWRqdXN0ICs9IDJlNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWFya2VyXCI6XG4gICAgICAgIG1haW5BZGp1c3QgKz0gMWU0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoaWdobGlnaHRcIjpcbiAgICAgICAgc3ViSW5kZXggKz0gMTVlMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYW5ub3RhdGlvblwiOlxuICAgICAgICBtYWluQWRqdXN0ICs9IDE1ZTM7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBtYWluID0gKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciArIG1haW5BZGp1c3Q7XG4gICAgcmV0dXJuIFttYWluLCBzdWJJbmRleF07XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNMaXN0ZW5lcnMuYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIGRpc3BhdGNoKHR5cGUsIGV2ZW50KSB7XG4gICAgdGhpcy5zZXJpZXNMaXN0ZW5lcnMuZGlzcGF0Y2godHlwZSwgZXZlbnQpO1xuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXModGhpcyk7XG4gIH1cbiAgZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgcHJvcGVydGllcykge1xuICAgIGNvbnN0IHJlc29sdmVkRGlyZWN0aW9uID0gdGhpcy5yZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgY29uc3Qga2V5cyA9IHByb3BlcnRpZXM/LltyZXNvbHZlZERpcmVjdGlvbl07XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgaWYgKCFrZXlzKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBjb25zdCBhZGRWYWx1ZXMgPSAoLi4uaXRlbXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgYWRkVmFsdWVzKC4uLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBhZGRWYWx1ZXMoLi4uT2JqZWN0LnZhbHVlcyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgYWRkVmFsdWVzKC4uLmtleXMubWFwKChrZXkpID0+IHRoaXMucHJvcGVydGllc1trZXldKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRLZXlzKGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHRoaXMuZGlyZWN0aW9uS2V5cyk7XG4gIH1cbiAgZ2V0S2V5UHJvcGVydGllcyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25LZXlzW3RoaXMucmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pXSA/PyBbXTtcbiAgfVxuICBnZXROYW1lcyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb25WYWx1ZXMoZGlyZWN0aW9uLCB0aGlzLmRpcmVjdGlvbk5hbWVzKTtcbiAgfVxuICByZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cbiAgLy8gVGhlIHVuaW9uIG9mIHRoZSBzZXJpZXMgZG9tYWluICgnY29tbXVuaXR5JykgYW5kIHNlcmllcy1vcHRpb24gZG9tYWlucyAoJ2VudGVycHJpc2UnKS5cbiAgZ2V0RG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbik7XG4gICAgY29uc3QgbW9kdWxlRG9tYWlucyA9IHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZHVsZSkgPT4gbW9kdWxlLmdldERvbWFpbihkaXJlY3Rpb24pKTtcbiAgICByZXR1cm4gc2VyaWVzRG9tYWluLmNvbmNhdChtb2R1bGVEb21haW5zLmZsYXQoKSk7XG4gIH1cbiAgLy8gSW5kaWNhdGUgdGhhdCBzb21ldGhpbmcgZXh0ZXJuYWwgY2hhbmdlZCBhbmQgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGVEYXRhLlxuICBtYXJrTm9kZURhdGFEaXJ0eSgpIHtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMudmlzaWJsZU1heWJlQ2hhbmdlZCgpO1xuICB9XG4gIHZpc2libGVNYXliZUNoYW5nZWQoKSB7XG4gICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLnJlZ2lzdGVyU2VyaWVzKHRoaXMpO1xuICB9XG4gIGdldE9wYWNpdHkoKSB7XG4gICAgY29uc3QgZGVmYXVsdE9wYWNpdHkgPSAxO1xuICAgIGNvbnN0IHsgZGltT3BhY2l0eSA9IDEsIGVuYWJsZWQgPSB0cnVlIH0gPSB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuc2VyaWVzO1xuICAgIGlmICghZW5hYmxlZCB8fCBkaW1PcGFjaXR5ID09PSBkZWZhdWx0T3BhY2l0eSkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRPcGFjaXR5O1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuaXNJdGVtSWRIaWdobGlnaHRlZCgpKSB7XG4gICAgICBjYXNlIDAgLyogTm9uZSAqLzpcbiAgICAgIGNhc2UgMSAvKiBUaGlzICovOlxuICAgICAgICByZXR1cm4gZGVmYXVsdE9wYWNpdHk7XG4gICAgICBjYXNlIDIgLyogT3RoZXIgKi86XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGltT3BhY2l0eTtcbiAgICB9XG4gIH1cbiAgZ2V0U3Ryb2tlV2lkdGgoZGVmYXVsdFN0cm9rZVdpZHRoKSB7XG4gICAgY29uc3QgeyBzdHJva2VXaWR0aCwgZW5hYmxlZCA9IHRydWUgfSA9IHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5zZXJpZXM7XG4gICAgaWYgKCFlbmFibGVkIHx8IHN0cm9rZVdpZHRoID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBkZWZhdWx0U3Ryb2tlV2lkdGg7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5pc0l0ZW1JZEhpZ2hsaWdodGVkKCkpIHtcbiAgICAgIGNhc2UgMSAvKiBUaGlzICovOlxuICAgICAgICByZXR1cm4gc3Ryb2tlV2lkdGg7XG4gICAgICBjYXNlIDAgLyogTm9uZSAqLzpcbiAgICAgIGNhc2UgMiAvKiBPdGhlciAqLzpcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJva2VXaWR0aDtcbiAgICB9XG4gIH1cbiAgaXNJdGVtSWRIaWdobGlnaHRlZCgpIHtcbiAgICBjb25zdCBzZXJpZXMgPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyPy5nZXRBY3RpdmVIaWdobGlnaHQoKT8uc2VyaWVzO1xuICAgIGlmIChzZXJpZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgaWYgKHNlcmllcyAhPT0gdGhpcykge1xuICAgICAgcmV0dXJuIDIgLyogT3RoZXIgKi87XG4gICAgfVxuICAgIHJldHVybiAxIC8qIFRoaXMgKi87XG4gIH1cbiAgZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAubWFwTW9kdWxlcygobW9kdWxlKSA9PiBtb2R1bGUuZ2V0VG9vbHRpcFBhcmFtcygpKS5yZWR1Y2UoKHRvdGFsLCBjdXJyZW50KSA9PiBPYmplY3QuYXNzaWduKHRvdGFsLCBjdXJyZW50KSwge30pO1xuICB9XG4gIHBpY2tOb2RlKHBvaW50LCBpbnRlbnQsIGV4YWN0TWF0Y2hPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHBpY2tNb2RlcywgdmlzaWJsZSwgcm9vdEdyb3VwIH0gPSB0aGlzO1xuICAgIGlmICghdmlzaWJsZSB8fCAhcm9vdEdyb3VwLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGludGVudCA9PT0gXCJoaWdobGlnaHRcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpbnRlbnQgPT09IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpbnRlbnQgPT09IFwiaGlnaGxpZ2h0XCIgJiYgIXRoaXMucHJvcGVydGllcy5oaWdobGlnaHQuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBpZiAoaW50ZW50ID09PSBcInRvb2x0aXBcIiB8fCBpbnRlbnQgPT09IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIikge1xuICAgICAgY29uc3QgeyB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICBtYXhEaXN0YW5jZSA9IHR5cGVvZiB0b29sdGlwLnJhbmdlID09PSBcIm51bWJlclwiID8gdG9vbHRpcC5yYW5nZSA6IEluZmluaXR5O1xuICAgICAgZXhhY3RNYXRjaE9ubHkgfHwgKGV4YWN0TWF0Y2hPbmx5ID0gdG9vbHRpcC5yYW5nZSA9PT0gXCJleGFjdFwiKTtcbiAgICB9IGVsc2UgaWYgKGludGVudCA9PT0gXCJldmVudFwiKSB7XG4gICAgICBjb25zdCB7IG5vZGVDbGlja1JhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICBtYXhEaXN0YW5jZSA9IHR5cGVvZiBub2RlQ2xpY2tSYW5nZSA9PT0gXCJudW1iZXJcIiA/IG5vZGVDbGlja1JhbmdlIDogSW5maW5pdHk7XG4gICAgICBleGFjdE1hdGNoT25seSB8fCAoZXhhY3RNYXRjaE9ubHkgPSBub2RlQ2xpY2tSYW5nZSA9PT0gXCJleGFjdFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRQaWNrTW9kZXMgPSBwaWNrTW9kZXMuZmlsdGVyKFxuICAgICAgKG0pID0+ICFleGFjdE1hdGNoT25seSB8fCBtID09PSAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgeCwgeSwgbWF4RGlzdGFuY2UsIHNlbGVjdGVkUGlja01vZGVzIH0pO1xuICAgIGlmICh0aGlzLl9waWNrTm9kZUNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwaWNrTW9kZSBvZiBzZWxlY3RlZFBpY2tNb2Rlcykge1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgc3dpdGNoIChwaWNrTW9kZSkge1xuICAgICAgICBjYXNlIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBORUFSRVNUX0JZX01BSU5fQVhJU19GSVJTVCAqLzpcbiAgICAgICAgY2FzZSAyIC8qIE5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUICovOlxuICAgICAgICAgIG1hdGNoID0gdGhpcy5waWNrTm9kZU1haW5BeGlzRmlyc3QoXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIHBpY2tNb2RlID09PSAyIC8qIE5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUICovXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIE5FQVJFU1RfTk9ERSAqLzpcbiAgICAgICAgICBtYXRjaCA9IHRoaXMucGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmRpc3RhbmNlIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWNrTm9kZUNhY2hlLnNldChrZXksIHsgcGlja01vZGUsIG1hdGNoOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IG1hdGNoLmRpc3RhbmNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5zZXQoa2V5LCB2b2lkIDApO1xuICB9XG4gIHBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCkge1xuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jb250ZW50R3JvdXAucGlja05vZGUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmRhdHVtLm1pc3NpbmcgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShfcG9pbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBTZXJpZXMucGlja05vZGVDbG9zZXN0RGF0dW0oKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcGlja05vZGVOZWFyZXN0RGlzdGFudE9iamVjdChwb2ludCwgaXRlbXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5lYXJlc3RTcXVhcmVkKHBvaW50LngsIHBvaW50LnksIGl0ZW1zKTtcbiAgICBpZiAobWF0Y2gubmVhcmVzdCAhPT0gdm9pZCAwICYmIG1hdGNoLm5lYXJlc3QuZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLm5lYXJlc3QuZGF0dW0sIGRpc3RhbmNlOiBNYXRoLnNxcnQobWF0Y2guZGlzdGFuY2VTcXVhcmVkKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHBpY2tOb2RlTWFpbkF4aXNGaXJzdChfcG9pbnQsIF9yZXF1aXJlQ2F0ZWdvcnlBeGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gU2VyaWVzLnBpY2tOb2RlTWFpbkF4aXNGaXJzdCgpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBmaXJlTm9kZUNsaWNrRXZlbnQoZXZlbnQsIGRhdHVtKSB7XG4gICAgdGhpcy5maXJlRXZlbnQobmV3IHRoaXMuTm9kZUV2ZW50KFwibm9kZUNsaWNrXCIsIGV2ZW50LCBkYXR1bSwgdGhpcykpO1xuICB9XG4gIGZpcmVOb2RlRG91YmxlQ2xpY2tFdmVudChldmVudCwgZGF0dW0pIHtcbiAgICB0aGlzLmZpcmVFdmVudChuZXcgdGhpcy5Ob2RlRXZlbnQoXCJub2RlRG91YmxlQ2xpY2tcIiwgZXZlbnQsIGRhdHVtLCB0aGlzKSk7XG4gIH1cbiAgY3JlYXRlTm9kZUNvbnRleHRNZW51QWN0aW9uRXZlbnQoZXZlbnQsIGRhdHVtKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLk5vZGVFdmVudChcIm5vZGVDb250ZXh0TWVudUFjdGlvblwiLCBldmVudCwgZGF0dW0sIHRoaXMpO1xuICB9XG4gIHRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKSB7XG4gICAgdGhpcy52aXNpYmxlID0gZW5hYmxlZDtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJ2aXNpYmlsaXR5LWNoYW5nZWRcIiwgeyBpdGVtSWQsIGVuYWJsZWQgfSk7XG4gIH1cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gIH1cbiAgZ2V0TW9kdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcDtcbiAgfVxuICBjcmVhdGVNb2R1bGVDb250ZXh0KCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY3R4LCBzZXJpZXM6IHRoaXMgfTtcbiAgfVxuICBnZXRMYWJlbFRleHQobGFiZWwsIHBhcmFtcywgZGVmYXVsdEZvcm1hdHRlciA9IFN0cmluZykge1xuICAgIGlmIChsYWJlbC5mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmN0eC5jYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7IHNlcmllc0lkOiB0aGlzLmlkLCAuLi5wYXJhbXMgfSkgPz8gZGVmYXVsdEZvcm1hdHRlcihwYXJhbXMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcihwYXJhbXMudmFsdWUpO1xuICB9XG4gIGdldE1hcmtlclN0eWxlKG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUgPSBtYXJrZXIuZ2V0U3R5bGUoKSkge1xuICAgIGNvbnN0IGRlZmF1bHRTaXplID0geyBzaXplOiBwYXJhbXMuZGF0dW0ucG9pbnQ/LnNpemUgPz8gMCB9O1xuICAgIGNvbnN0IG1hcmtlclN0eWxlID0gbWVyZ2VEZWZhdWx0cyhkZWZhdWx0U2l6ZSwgZGVmYXVsdFN0eWxlKTtcbiAgICBpZiAobWFya2VyLml0ZW1TdHlsZXIpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5jdHguY2FsbGJhY2tDYWNoZS5jYWxsKG1hcmtlci5pdGVtU3R5bGVyLCB7XG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICAuLi5tYXJrZXJTdHlsZSxcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBkYXR1bTogcGFyYW1zLmRhdHVtLmRhdHVtXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKHN0eWxlLCBtYXJrZXJTdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTdHlsZTtcbiAgfVxuICB1cGRhdGVNYXJrZXJTdHlsZShtYXJrZXJOb2RlLCBtYXJrZXIsIHBhcmFtcywgZGVmYXVsdFN0eWxlID0gbWFya2VyLmdldFN0eWxlKCksIHsgYXBwbHlUcmFuc2xhdGlvbiA9IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgeyBwb2ludCB9ID0gcGFyYW1zLmRhdHVtO1xuICAgIGNvbnN0IGFjdGl2ZVN0eWxlID0gdGhpcy5nZXRNYXJrZXJTdHlsZShtYXJrZXIsIHBhcmFtcywgZGVmYXVsdFN0eWxlKTtcbiAgICBjb25zdCB2aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIGFjdGl2ZVN0eWxlLnNpemUgPiAwICYmIHBvaW50ICYmICFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSk7XG4gICAgaWYgKGFwcGx5VHJhbnNsYXRpb24pIHtcbiAgICAgIG1hcmtlck5vZGUuc2V0UHJvcGVydGllcyh7IHZpc2libGUsIC4uLmFjdGl2ZVN0eWxlLCB0cmFuc2xhdGlvblg6IHBvaW50Py54LCB0cmFuc2xhdGlvblk6IHBvaW50Py55IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrZXJOb2RlLnNldFByb3BlcnRpZXMoeyB2aXNpYmxlLCAuLi5hY3RpdmVTdHlsZSB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIuc2hhcGUgPT09IFwiZnVuY3Rpb25cIiAmJiAhbWFya2VyTm9kZS5kaXJ0eVBhdGgpIHtcbiAgICAgIG1hcmtlck5vZGUucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgIG1hcmtlck5vZGUudXBkYXRlUGF0aCgpO1xuICAgICAgbWFya2VyTm9kZS5jaGVja1BhdGhEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBnZXRNaW5SZWN0cyhfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IG5vZGVEYXRhRGVwZW5kZW5jaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA/PyB7IHNlcmllc1JlY3RXaWR0aDogTmFOLCBzZXJpZXNSZWN0SGVpZ2h0OiBOYU4gfTtcbiAgfVxuICBjaGVja1Jlc2l6ZShuZXdTZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyB3aWR0aDogc2VyaWVzUmVjdFdpZHRoLCBoZWlnaHQ6IHNlcmllc1JlY3RIZWlnaHQgfSA9IG5ld1Nlcmllc1JlY3QgPz8geyB3aWR0aDogTmFOLCBoZWlnaHQ6IE5hTiB9O1xuICAgIGNvbnN0IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3U2VyaWVzUmVjdCA/IHsgc2VyaWVzUmVjdFdpZHRoLCBzZXJpZXNSZWN0SGVpZ2h0IH0gOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzaXplID0ganNvbkRpZmYodGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcywgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMpICE9IG51bGw7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdOb2RlRGF0YURlcGVuZGVuY2llcztcbiAgICAgIHRoaXMubWFya05vZGVEYXRhRGlydHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc2l6ZTtcbiAgfVxuICBwaWNrRm9jdXMoX29wdHMpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuU2VyaWVzLmhpZ2hsaWdodGVkWkluZGV4ID0gMWUxMjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZTogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgIHRoaXMub25TZXJpZXNHcm91cGluZ0NoYW5nZShvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuICB9KVxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJzZXJpZXNHcm91cGluZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3V0aWwudHNcbmZ1bmN0aW9uIGNvbnZlcnRWYWx1ZXNUb1NjYWxlQnlEZWZzKHtcbiAgZGVmcyxcbiAgdmFsdWVzLFxuICB4QXhpcyxcbiAgeUF4aXNcbn0pIHtcbiAgaWYgKCEoeEF4aXMgJiYgeUF4aXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXhlcyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW3NlYXJjaElkLCB7IGRlZiB9XSBvZiBkZWZzKSB7XG4gICAgaWYgKE9iamVjdC5oYXNPd24odmFsdWVzLCBzZWFyY2hJZCkpIHtcbiAgICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gZGVmLnR5cGUgPT09IFwia2V5XCIgPyB4QXhpcyA6IHlBeGlzO1xuICAgICAgcmVzdWx0W3NlYXJjaElkXSA9IE1hdGgucm91bmQoc2NhbGUyLmNvbnZlcnQodmFsdWVzW3NlYXJjaElkXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGlja05vZGUoaW5wdXRTZXJpZXMsIHBvaW50LCBpbnRlbnQsIGV4YWN0TWF0Y2hPbmx5KSB7XG4gIGNvbnN0IHJldmVyc2VTZXJpZXMgPSBbLi4uaW5wdXRTZXJpZXNdLnJldmVyc2UoKTtcbiAgbGV0IHJlc3VsdDtcbiAgZm9yIChjb25zdCBzZXJpZXMgb2YgcmV2ZXJzZVNlcmllcykge1xuICAgIGlmICghc2VyaWVzLnZpc2libGUgfHwgIXNlcmllcy5yb290R3JvdXAudmlzaWJsZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHsgbWF0Y2gsIGRpc3RhbmNlOiBkaXN0YW5jZTMgfSA9IHNlcmllcy5waWNrTm9kZShwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSkgPz8ge307XG4gICAgaWYgKCFtYXRjaCB8fCBkaXN0YW5jZTMgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghcmVzdWx0IHx8IHJlc3VsdC5kaXN0YW5jZSA+IGRpc3RhbmNlMykge1xuICAgICAgcmVzdWx0ID0geyBzZXJpZXMsIGRpc3RhbmNlOiBkaXN0YW5jZTMsIGRhdHVtOiBtYXRjaCB9O1xuICAgIH1cbiAgICBpZiAoZGlzdGFuY2UzID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0FyZWFDbGlja01hbmFnZXIudHNcbnZhciBTZXJpZXNBcmVhQ2xpY2tNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGlkLCBjaGFydCwgY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8pO1xuICAgIGNvbnN0IGhvcml6b250YWxBeGVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8pO1xuICAgIGNvbnN0IHZlcnRpY2FsQXhlc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHgucmVnaW9uTWFuYWdlci5saXN0ZW5BbGwoXCJjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCkpLFxuICAgICAgdGhpcy5jdHgucmVnaW9uTWFuYWdlci5saXN0ZW5BbGwoXCJkYmxjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCkpLFxuICAgICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZXZlbnQpID0+IHRoaXMubGF5b3V0Q29tcGxldGUoZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLm9uTGVhdmUoKSksXG4gICAgICBob3Jpem9udGFsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMub25MZWF2ZSgpKSxcbiAgICAgIHZlcnRpY2FsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMub25MZWF2ZSgpKVxuICAgICk7XG4gIH1cbiAgc2VyaWVzQ2hhbmdlZChzZXJpZXMpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgfVxuICBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmxhc3RIb3ZlciA9IHZvaWQgMDtcbiAgfVxuICBwcmVTY2VuZVJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5sYXN0SG92ZXIpIHtcbiAgICAgIHRoaXMub25Ib3Zlcih0aGlzLmxhc3RIb3Zlcik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSh0eXBlLCBvcHRzKSB7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUodHlwZSwgb3B0cyk7XG4gIH1cbiAgbGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBldmVudC5zZXJpZXMucGFkZGVkUmVjdDtcbiAgfVxuICBvbkxlYXZlKCkge1xuICAgIHRoaXMubGFzdEhvdmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICB9XG4gIG9uSG92ZXIoeyBvZmZzZXRYLCBvZmZzZXRZIH0pIHtcbiAgICBjb25zdCBmb3VuZCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfSwgXCJldmVudFwiKTtcbiAgICBpZiAoZm91bmQ/LnNlcmllcy5oYXNFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIpIHx8IGZvdW5kPy5zZXJpZXMuaGFzRXZlbnRMaXN0ZW5lcihcIm5vZGVEb3VibGVDbGlja1wiKSkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcbiAgICB9XG4gIH1cbiAgb25DbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnNlcmllc1JlY3Q/LmNvbnRhaW5zUG9pbnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSkgJiYgdGhpcy5jaGVja1Nlcmllc05vZGVDbGljayhldmVudCkpIHtcbiAgICAgIHRoaXMudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdFdmVudCA9IHsgdHlwZTogZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiID8gXCJjbGlja1wiIDogXCJkb3VibGVDbGlja1wiLCBldmVudDogZXZlbnQuc291cmNlRXZlbnQgfTtcbiAgICB0aGlzLmNoYXJ0LmZpcmVFdmVudChuZXdFdmVudCk7XG4gIH1cbiAgY2hlY2tTZXJpZXNOb2RlQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgeyB4OiBldmVudC5vZmZzZXRYLCB5OiBldmVudC5vZmZzZXRZIH0sIFwiZXZlbnRcIik7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudC50eXBlID09PSBcImNsaWNrXCIpIHtcbiAgICAgIHJlc3VsdC5zZXJpZXMuZmlyZU5vZGVDbGlja0V2ZW50KGV2ZW50LnNvdXJjZUV2ZW50LCByZXN1bHQuZGF0dW0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSBcImRibGNsaWNrXCIpIHtcbiAgICAgIGV2ZW50LnByZXZlbnRab29tRGJsQ2xpY2sgPSByZXN1bHQuZGlzdGFuY2UgPT09IDA7XG4gICAgICByZXN1bHQuc2VyaWVzLmZpcmVOb2RlRG91YmxlQ2xpY2tFdmVudChldmVudC5zb3VyY2VFdmVudCwgcmVzdWx0LmRhdHVtKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2tleWJvYXJkVXRpbC50c1xuZnVuY3Rpb24gY29tcHV0ZUNlbnRlcihiYm94T3JQYXRoKSB7XG4gIGlmIChiYm94T3JQYXRoIGluc3RhbmNlb2YgQkJveCkge1xuICAgIHJldHVybiBiYm94T3JQYXRoLmNvbXB1dGVDZW50ZXIoKTtcbiAgfVxuICByZXR1cm4gYmJveE9yUGF0aD8uY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpPy5jb21wdXRlQ2VudGVyKCk7XG59XG5mdW5jdGlvbiBkcmF3UGlja2VkRm9jdXMoZm9jdXNJbmRpY2F0b3IsIHBpY2spIHtcbiAgY29uc3QgeyBib3VuZHMsIHNob3dGb2N1c0JveCB9ID0gcGljaztcbiAgaWYgKHNob3dGb2N1c0JveCkge1xuICAgIGZvY3VzSW5kaWNhdG9yPy51cGRhdGVCb3VuZHMoYm91bmRzKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFrZUtleWJvYXJkUG9pbnRlckV2ZW50KGZvY3VzSW5kaWNhdG9yLCBwaWNrKSB7XG4gIGRyYXdQaWNrZWRGb2N1cyhmb2N1c0luZGljYXRvciwgcGljayk7XG4gIGNvbnN0IHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9ID0gY29tcHV0ZUNlbnRlcihwaWNrLmJvdW5kcykgPz8ge307XG4gIGlmIChvZmZzZXRYICE9PSB2b2lkIDAgJiYgb2Zmc2V0WSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJrZXlib2FyZFwiLCBvZmZzZXRYLCBvZmZzZXRZIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0FyZWFGb2N1c01hbmFnZXIudHNcbnZhciBTZXJpZXNBcmVhRm9jdXNNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGlkLCBjaGFydCwgY3R4LCBjaGFydFR5cGUyLCBvdmVybGF5cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNoYXJ0VHlwZSA9IGNoYXJ0VHlwZTI7XG4gICAgdGhpcy5vdmVybGF5cyA9IG92ZXJsYXlzO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5mb2N1cyA9IHtcbiAgICAgIGhhc0ZvY3VzOiBmYWxzZSxcbiAgICAgIHNlcmllczogdm9pZCAwLFxuICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAgICBkYXR1bUluZGV4OiAwLFxuICAgICAgZGF0dW06IHZvaWQgMFxuICAgIH07XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZXZlbnQpID0+IHRoaXMubGF5b3V0Q29tcGxldGUoZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tc3RhcnRcIiwgKCkgPT4gdGhpcy5vbkFuaW1hdGlvblN0YXJ0KCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLm9uQmx1cigpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcInRhYlwiLCAoZXZlbnQpID0+IHRoaXMub25UYWIoZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcIm5hdi12ZXJ0XCIsIChldmVudCkgPT4gdGhpcy5vbk5hdlZlcnQoZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcIm5hdi1ob3JpXCIsIChldmVudCkgPT4gdGhpcy5vbk5hdkhvcmkoZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZXZlbnQpID0+IHRoaXMub25TdWJtaXQoZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJicm93c2VyZm9jdXNcIiwgKGV2ZW50KSA9PiB0aGlzLm9uQnJvd3NlckZvY3VzKGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5jdHguZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHZvaWQgMCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgc2VyaWVzQ2hhbmdlZChzZXJpZXMpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICB0aGlzLm9uQmx1cigpO1xuICB9XG4gIGRhdGFDaGFuZ2VkKCkge1xuICAgIHRoaXMuY3R4LmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh2b2lkIDApO1xuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIHRoaXMucmVmcmVzaEZvY3VzKCk7XG4gIH1cbiAgbGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBldmVudC5zZXJpZXMucmVjdDtcbiAgfVxuICByZWZyZXNoRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXMuaGFzRm9jdXMpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VyaWVzRm9jdXMoMCwgMCk7XG4gICAgfVxuICB9XG4gIG9uVGFiKGV2ZW50KSB7XG4gICAgdGhpcy5oYW5kbGVGb2N1cygwLCAwKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZm9jdXMuaGFzRm9jdXMgPSB0cnVlO1xuICB9XG4gIG9uTmF2VmVydChldmVudCkge1xuICAgIHRoaXMuZm9jdXMuc2VyaWVzSW5kZXggKz0gZXZlbnQuZGVsdGE7XG4gICAgdGhpcy5oYW5kbGVGb2N1cyhldmVudC5kZWx0YSwgMCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBvbk5hdkhvcmkoZXZlbnQpIHtcbiAgICB0aGlzLmZvY3VzLmRhdHVtSW5kZXggKz0gZXZlbnQuZGVsdGE7XG4gICAgdGhpcy5oYW5kbGVGb2N1cygwLCBldmVudC5kZWx0YSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBvbkJyb3dzZXJGb2N1cyhldmVudCkge1xuICAgIGlmIChldmVudC5kZWx0YSA+IDApIHtcbiAgICAgIHRoaXMuZm9jdXMuZGF0dW0gPSB2b2lkIDA7XG4gICAgICB0aGlzLmZvY3VzLnNlcmllcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZm9jdXMuZGF0dW1JbmRleCA9IDA7XG4gICAgICB0aGlzLmZvY3VzLnNlcmllc0luZGV4ID0gMDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhIDwgMCkge1xuICAgICAgdGhpcy5mb2N1cy5kYXR1bSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZm9jdXMuc2VyaWVzID0gdm9pZCAwO1xuICAgICAgdGhpcy5mb2N1cy5kYXR1bUluZGV4ID0gSW5maW5pdHk7XG4gICAgICB0aGlzLmZvY3VzLnNlcmllc0luZGV4ID0gSW5maW5pdHk7XG4gICAgfVxuICB9XG4gIG9uQW5pbWF0aW9uU3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXMuaGFzRm9jdXMpIHtcbiAgICAgIHRoaXMub25CbHVyKCk7XG4gICAgfVxuICB9XG4gIG9uQmx1cigpIHtcbiAgICB0aGlzLmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgICB0aGlzLmZvY3VzLmhhc0ZvY3VzID0gZmFsc2U7XG4gIH1cbiAgaGFuZGxlRm9jdXMoc2VyaWVzSW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKSB7XG4gICAgdGhpcy5mb2N1cy5oYXNGb2N1cyA9IHRydWU7XG4gICAgY29uc3Qgb3ZlcmxheUZvY3VzID0gdGhpcy5vdmVybGF5cy5nZXRGb2N1c0luZm8odGhpcy5jdHgubG9jYWxlTWFuYWdlcik7XG4gICAgaWYgKG92ZXJsYXlGb2N1cyA9PSBudWxsKSB7XG4gICAgICB0aGlzLmhhbmRsZVNlcmllc0ZvY3VzKHNlcmllc0luZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyhvdmVybGF5Rm9jdXMucmVjdCk7XG4gICAgICB0aGlzLmN0eC5hcmlhQW5ub3VuY2VtZW50U2VydmljZS5hbm5vdW5jZVZhbHVlKG92ZXJsYXlGb2N1cy50ZXh0KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlU2VyaWVzRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpIHtcbiAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09IFwiaGllcmFyY2h5XCIpIHtcbiAgICAgIHRoaXMuaGFuZGxlSGllcmFyY2h5U2VyaWVzRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZvY3VzLCBzZXJpZXNSZWN0LCBzZXJpZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmlzaWJsZVNlcmllcyA9IHNlcmllcy5maWx0ZXIoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgaWYgKHZpc2libGVTZXJpZXMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGZvY3VzLnNlcmllc0luZGV4ID0gY2xhbXAoMCwgZm9jdXMuc2VyaWVzSW5kZXgsIHZpc2libGVTZXJpZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9jdXMuc2VyaWVzID0gdmlzaWJsZVNlcmllc1tmb2N1cy5zZXJpZXNJbmRleF07XG4gICAgY29uc3QgeyBkYXR1bUluZGV4LCBzZXJpZXNJbmRleDogb3RoZXJJbmRleCB9ID0gZm9jdXM7XG4gICAgY29uc3QgcGljayA9IGZvY3VzLnNlcmllcy5waWNrRm9jdXMoeyBkYXR1bUluZGV4LCBkYXR1bUluZGV4RGVsdGEsIG90aGVySW5kZXgsIG90aGVySW5kZXhEZWx0YSwgc2VyaWVzUmVjdCB9KTtcbiAgICB0aGlzLnVwZGF0ZVBpY2tlZEZvY3VzKHBpY2spO1xuICB9XG4gIGhhbmRsZUhpZXJhcmNoeVNlcmllc0ZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKSB7XG4gICAgdGhpcy5mb2N1cy5zZXJpZXMgPSB0aGlzLnNlcmllc1swXTtcbiAgICBjb25zdCB7XG4gICAgICBmb2N1czogeyBzZXJpZXMsIHNlcmllc0luZGV4OiBvdGhlckluZGV4LCBkYXR1bUluZGV4IH0sXG4gICAgICBzZXJpZXNSZWN0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHNlcmllcyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBpY2sgPSBzZXJpZXMucGlja0ZvY3VzKHsgZGF0dW1JbmRleCwgZGF0dW1JbmRleERlbHRhLCBvdGhlckluZGV4LCBvdGhlckluZGV4RGVsdGEsIHNlcmllc1JlY3QgfSk7XG4gICAgdGhpcy51cGRhdGVQaWNrZWRGb2N1cyhwaWNrKTtcbiAgfVxuICB1cGRhdGVQaWNrZWRGb2N1cyhwaWNrKSB7XG4gICAgY29uc3QgeyBmb2N1cyB9ID0gdGhpcztcbiAgICBpZiAocGljayA9PT0gdm9pZCAwIHx8IGZvY3VzLnNlcmllcyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGF0dW0sIGRhdHVtSW5kZXggfSA9IHBpY2s7XG4gICAgZm9jdXMuZGF0dW1JbmRleCA9IGRhdHVtSW5kZXg7XG4gICAgZm9jdXMuZGF0dW0gPSBkYXR1bTtcbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gbWFrZUtleWJvYXJkUG9pbnRlckV2ZW50KHRoaXMuY3R4LmZvY3VzSW5kaWNhdG9yLCBwaWNrKTtcbiAgICBpZiAoa2V5Ym9hcmRFdmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBodG1sID0gZm9jdXMuc2VyaWVzLmdldFRvb2x0aXBIdG1sKGRhdHVtKTtcbiAgICAgIGNvbnN0IG1ldGEgPSBUb29sdGlwTWFuYWdlci5tYWtlVG9vbHRpcE1ldGEoa2V5Ym9hcmRFdmVudCwgZGF0dW0pO1xuICAgICAgY29uc3QgYXJpYSA9IHRoaXMuZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgaHRtbCk7XG4gICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCBkYXR1bSk7XG4gICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKHRoaXMuaWQsIG1ldGEsIGh0bWwpO1xuICAgICAgdGhpcy5jdHguYXJpYUFubm91bmNlbWVudFNlcnZpY2UuYW5ub3VuY2VWYWx1ZShcImFyaWFBbm5vdW5jZUhvdmVyRGF0dW1cIiwgeyBkYXR1bTogYXJpYSB9KTtcbiAgICB9XG4gIH1cbiAgb25TdWJtaXQoZXZlbnQpIHtcbiAgICBjb25zdCB7IHNlcmllcywgZGF0dW0gfSA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3Qgc291cmNlRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudC5zb3VyY2VFdmVudDtcbiAgICBpZiAoc2VyaWVzICE9PSB2b2lkIDAgJiYgZGF0dW0gIT09IHZvaWQgMCkge1xuICAgICAgc2VyaWVzLmZpcmVOb2RlQ2xpY2tFdmVudChzb3VyY2VFdmVudCwgZGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJ0LmZpcmVFdmVudCh7XG4gICAgICAgIHR5cGU6IFwiY2xpY2tcIixcbiAgICAgICAgZXZlbnQ6IHNvdXJjZUV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBnZXREYXR1bUFyaWFUZXh0KGRhdHVtLCBodG1sKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBodG1sLmFyaWFMYWJlbDtcbiAgICByZXR1cm4gZGF0dW0uc2VyaWVzLmdldERhdHVtQXJpYVRleHQ/LihkYXR1bSwgZGVzY3JpcHRpb24pID8/IGRlc2NyaXB0aW9uO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzQXJlYUhpZ2hsaWdodE1hbmFnZXIudHNcbnZhciBTZXJpZXNBcmVhSGlnaGxpZ2h0TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihpZCwgY2hhcnQsIGN0eCwgaGlnaGxpZ2h0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5ob3ZlclNjaGVkdWxlciA9IGRlYm91bmNlZEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wZW5kaW5nSG92ZXJFdmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuY2hhcnQucGVyZm9ybVVwZGF0ZVR5cGUgPD0gNCAvKiBTRVJJRVNfVVBEQVRFICovKSB7XG4gICAgICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVIb3ZlcihmYWxzZSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8pO1xuICAgIGNvbnN0IGhvcml6b250YWxBeGVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8pO1xuICAgIGNvbnN0IHZlcnRpY2FsQXhlc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8pO1xuICAgIGNvbnN0IG1vdXNlTW92ZVN0YXRlcyA9IDE2IC8qIERlZmF1bHQgKi8gfCA0IC8qIEFubm90YXRpb25zICovO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZXZlbnQpID0+IHRoaXMubGF5b3V0Q29tcGxldGUoZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJoaWdobGlnaHQtY2hhbmdlXCIsIChldmVudCkgPT4gdGhpcy5jaGFuZ2VIaWdobGlnaHREYXR1bShldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZ1wiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICBob3Jpem9udGFsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSksXG4gICAgICB2ZXJ0aWNhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCkpLFxuICAgICAgLy8gQ2FzZXMgd2hlcmUgaGlnaGxpZ2h0IHNob3VsZCBiZSBjbGVhcmVkLlxuICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5hZGRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLmNsZWFySGlnaGxpZ2h0KCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5jbGVhckhpZ2hsaWdodCgpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLmNsZWFySGlnaGxpZ2h0KCkpLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdGFydFwiLCAoKSA9PiB0aGlzLmNsZWFySGlnaGxpZ2h0KCkpLFxuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLXBhbi1zdGFydFwiLCAoKSA9PiB0aGlzLmNsZWFySGlnaGxpZ2h0KCkpLFxuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB0aGlzLmNsZWFySGlnaGxpZ2h0KCkpXG4gICAgKTtcbiAgfVxuICBzZXJpZXNDaGFuZ2VkKHNlcmllcykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICB9XG4gIGRhdGFDaGFuZ2VkKCkge1xuICAgIHRoaXMuc3Rhc2hlZEhvdmVyRXZlbnQgPz8gKHRoaXMuc3Rhc2hlZEhvdmVyRXZlbnQgPSB0aGlzLmFwcGxpZWRIb3ZlckV2ZW50KTtcbiAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gIH1cbiAgcHJlU2NlbmVSZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3Rhc2hlZEhvdmVyRXZlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wZW5kaW5nSG92ZXJFdmVudCA9IHRoaXMuc3Rhc2hlZEhvdmVyRXZlbnQ7XG4gICAgICB0aGlzLnN0YXNoZWRIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5oYW5kbGVIb3Zlcih0cnVlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHR5cGUsIG9wdHMpIHtcbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSh0eXBlLCBvcHRzKTtcbiAgfVxuICBsYXlvdXRDb21wbGV0ZShldmVudCkge1xuICAgIHRoaXMuaG92ZXJSZWN0ID0gZXZlbnQuc2VyaWVzLnBhZGRlZFJlY3Q7XG4gIH1cbiAgY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgdGhpcy5wZW5kaW5nSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmFwcGxpZWRIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICB9XG4gIG9uSG92ZXIoZXZlbnQpIHtcbiAgICB0aGlzLnBlbmRpbmdIb3ZlckV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5ob3ZlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICB9XG4gIGhhbmRsZUhvdmVyKHJlZGlzcGxheSkge1xuICAgIHRoaXMuYXBwbGllZEhvdmVyRXZlbnQgPSB0aGlzLnBlbmRpbmdIb3ZlckV2ZW50O1xuICAgIHRoaXMucGVuZGluZ0hvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFwcGxpZWRIb3ZlckV2ZW50O1xuICAgIGlmICghZXZlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgIT09IDE2IC8qIERlZmF1bHQgKi8gJiYgc3RhdGUgIT09IDQgLyogQW5ub3RhdGlvbnMgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAocmVkaXNwbGF5ID8gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpIDogIXRoaXMuaG92ZXJSZWN0Py5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcy5oaWdobGlnaHQ7XG4gICAgY29uc3QgaW50ZW50ID0gcmFuZ2UzID09PSBcInRvb2x0aXBcIiA/IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIiA6IFwiaGlnaGxpZ2h0XCI7XG4gICAgY29uc3QgZm91bmQgPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgeyB4OiBldmVudC5vZmZzZXRYLCB5OiBldmVudC5vZmZzZXRZIH0sIGludGVudCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCBmb3VuZC5kYXR1bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICB9XG4gIGNoYW5nZUhpZ2hsaWdodERhdHVtKGV2ZW50KSB7XG4gICAgY29uc3Qgc2VyaWVzVG9VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHsgc2VyaWVzOiBuZXdTZXJpZXMgPSB2b2lkIDAsIGRhdHVtOiBuZXdEYXR1bSB9ID0gZXZlbnQuY3VycmVudEhpZ2hsaWdodCA/PyB7fTtcbiAgICBjb25zdCB7IHNlcmllczogbGFzdFNlcmllcyA9IHZvaWQgMCwgZGF0dW06IGxhc3REYXR1bSB9ID0gZXZlbnQucHJldmlvdXNIaWdobGlnaHQgPz8ge307XG4gICAgaWYgKGxhc3RTZXJpZXMpIHtcbiAgICAgIHNlcmllc1RvVXBkYXRlLmFkZChsYXN0U2VyaWVzKTtcbiAgICB9XG4gICAgaWYgKG5ld1Nlcmllcykge1xuICAgICAgc2VyaWVzVG9VcGRhdGUuYWRkKG5ld1Nlcmllcyk7XG4gICAgfVxuICAgIGlmIChsYXN0U2VyaWVzPy5wcm9wZXJ0aWVzLmN1cnNvciAmJiBsYXN0RGF0dW0pIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKGxhc3RTZXJpZXMuaWQpO1xuICAgIH1cbiAgICBpZiAobmV3U2VyaWVzPy5wcm9wZXJ0aWVzLmN1cnNvciAmJiBuZXdTZXJpZXM/LnByb3BlcnRpZXMuY3Vyc29yICE9PSBcImRlZmF1bHRcIiAmJiBuZXdEYXR1bSkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IobmV3U2VyaWVzLmlkLCBuZXdTZXJpZXMucHJvcGVydGllcy5jdXJzb3IpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVBbGwgPSBuZXdTZXJpZXMgPT0gbnVsbCB8fCBsYXN0U2VyaWVzID09IG51bGw7XG4gICAgaWYgKHVwZGF0ZUFsbCkge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovLCB7IHNlcmllc1RvVXBkYXRlIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0FyZWFUb29sdGlwTWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFUb29sdGlwTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihpZCwgY2hhcnQsIGN0eCwgdG9vbHRpcCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5ob3ZlclNjaGVkdWxlciA9IGRlYm91bmNlZEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5sYXN0SG92ZXIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LnBlcmZvcm1VcGRhdGVUeXBlIDw9IDQgLyogU0VSSUVTX1VQREFURSAqLykge1xuICAgICAgICB0aGlzLmhvdmVyU2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlSG92ZXIodGhpcy5sYXN0SG92ZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXJpZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLyk7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4ZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcImhvcml6b250YWwtYXhlc1wiIC8qIEhPUklaT05UQUxfQVhFUyAqLyk7XG4gICAgY29uc3QgdmVydGljYWxBeGVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChldmVudCkgPT4gdGhpcy5sYXlvdXRDb21wbGV0ZShldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFxuICAgICAgICBcImhvdmVyXCIsXG4gICAgICAgIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSxcbiAgICAgICAgMTYgLyogRGVmYXVsdCAqLyB8IDQgLyogQW5ub3RhdGlvbnMgKi9cbiAgICAgICksXG4gICAgICBob3Jpem9udGFsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSksXG4gICAgICB2ZXJ0aWNhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCkpLFxuICAgICAgLy8gRXZlbnRzIHRoYXQgY2xlYXIgdG9vbHRpcC5cbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCksIDMxIC8qIEFsbCAqLyksXG4gICAgICBob3Jpem9udGFsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgdmVydGljYWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLXN0YXJ0XCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5hZGRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1wYW4tc3RhcnRcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpXG4gICAgKTtcbiAgfVxuICBzZXJpZXNDaGFuZ2VkKHNlcmllcykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICB9XG4gIGRhdGFDaGFuZ2VkKCkge1xuICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gIH1cbiAgcHJlU2NlbmVSZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubGFzdEhvdmVyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaGFuZGxlSG92ZXIodGhpcy5sYXN0SG92ZXIsIHRydWUpO1xuICAgIH1cbiAgfVxuICBsYXlvdXRDb21wbGV0ZShldmVudCkge1xuICAgIHRoaXMuaG92ZXJSZWN0ID0gZXZlbnQuc2VyaWVzLnBhZGRlZFJlY3Q7XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIHRoaXMubGFzdEhvdmVyID0gZXZlbnQ7XG4gICAgdGhpcy5ob3ZlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICB9XG4gIGNsZWFyVG9vbHRpcCgpIHtcbiAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICAgIHRoaXMubGFzdEhvdmVyID0gdm9pZCAwO1xuICB9XG4gIGhhbmRsZUhvdmVyKGV2ZW50LCByZWRpc3BsYXkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSAhPT0gMTYgLyogRGVmYXVsdCAqLyAmJiBzdGF0ZSAhPT0gNCAvKiBBbm5vdGF0aW9ucyAqLylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIHRhcmdldEVsZW1lbnQgfSA9IGV2ZW50O1xuICAgIGlmIChyZWRpc3BsYXkgPyB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzQWN0aXZlKCkgOiAhdGhpcy5ob3ZlclJlY3Q/LmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY2xlYXJUb29sdGlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0YXJnZXRFbGVtZW50ICYmIHRoaXMudG9vbHRpcC5pbnRlcmFjdGl2ZSAmJiB0aGlzLmN0eC5kb21NYW5hZ2VyLmlzTWFuYWdlZENoaWxkRE9NRWxlbWVudCh0YXJnZXRFbGVtZW50LCBcImNhbnZhcy1vdmVybGF5XCIsIERFRkFVTFRfVE9PTFRJUF9DTEFTUykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGljayA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfSwgXCJ0b29sdGlwXCIpO1xuICAgIGlmICghcGljaykge1xuICAgICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IHBpY2suc2VyaWVzLmdldFRvb2x0aXBIdG1sKHBpY2suZGF0dW0pO1xuICAgIGNvbnN0IHRvb2x0aXBFbmFibGVkID0gdGhpcy50b29sdGlwLmVuYWJsZWQgJiYgcGljay5zZXJpZXMudG9vbHRpcEVuYWJsZWQ7XG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlVG9vbHRpcCA9IHRvb2x0aXBFbmFibGVkICYmIGh0bWwgIT0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlVG9vbHRpcCkge1xuICAgICAgY29uc3QgbWV0YSA9IFRvb2x0aXBNYW5hZ2VyLm1ha2VUb29sdGlwTWV0YShldmVudCwgcGljay5kYXR1bSk7XG4gICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKHRoaXMuaWQsIG1ldGEsIGh0bWwpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0FyZWFNYW5hZ2VyLnRzXG52YXIgU2VyaWVzQXJlYU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGN0eCwgY2hhcnRUeXBlMiwgdG9vbHRpcCwgaGlnaGxpZ2h0LCBvdmVybGF5cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5zdWJNYW5hZ2VycyA9IFtcbiAgICAgIG5ldyBTZXJpZXNBcmVhRm9jdXNNYW5hZ2VyKHRoaXMuaWQsIGNoYXJ0LCBjdHgsIGNoYXJ0VHlwZTIsIG92ZXJsYXlzKSxcbiAgICAgIG5ldyBTZXJpZXNBcmVhSGlnaGxpZ2h0TWFuYWdlcih0aGlzLmlkLCBjaGFydCwgY3R4LCBoaWdobGlnaHQpLFxuICAgICAgbmV3IFNlcmllc0FyZWFUb29sdGlwTWFuYWdlcih0aGlzLmlkLCBjaGFydCwgY3R4LCB0b29sdGlwKSxcbiAgICAgIG5ldyBTZXJpZXNBcmVhQ2xpY2tNYW5hZ2VyKHRoaXMuaWQsIGNoYXJ0LCBjdHgpXG4gICAgXTtcbiAgICBjb25zdCBzZXJpZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICAoKSA9PiB0aGlzLnN1Yk1hbmFnZXJzLmZvckVhY2goKHMpID0+IHMuZGVzdHJveSgpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIChldmVudCkgPT4gdGhpcy5vbkNvbnRleHRNZW51KGV2ZW50KSwgMzEgLyogQWxsICovKSxcbiAgICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJwcmUtc2NlbmUtcmVuZGVyXCIsICgpID0+IHRoaXMucHJlU2NlbmVSZW5kZXIoKSlcbiAgICApO1xuICB9XG4gIGRhdGFDaGFuZ2VkKCkge1xuICAgIGZvciAoY29uc3QgbWFuYWdlciBvZiB0aGlzLnN1Yk1hbmFnZXJzKSB7XG4gICAgICBtYW5hZ2VyLmRhdGFDaGFuZ2VkPy4oKTtcbiAgICB9XG4gIH1cbiAgcHJlU2NlbmVSZW5kZXIoKSB7XG4gICAgZm9yIChjb25zdCBtYW5hZ2VyIG9mIHRoaXMuc3ViTWFuYWdlcnMpIHtcbiAgICAgIG1hbmFnZXIucHJlU2NlbmVSZW5kZXI/LigpO1xuICAgIH1cbiAgfVxuICBzZXJpZXNDaGFuZ2VkKHNlcmllcykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgIGZvciAoY29uc3QgbWFuYWdlciBvZiB0aGlzLnN1Yk1hbmFnZXJzKSB7XG4gICAgICBtYW5hZ2VyLnNlcmllc0NoYW5nZWQoc2VyaWVzKTtcbiAgICB9XG4gIH1cbiAgb25Db250ZXh0TWVudShldmVudCkge1xuICAgIGNvbnN0IHsgRGVmYXVsdDogRGVmYXVsdDIsIENvbnRleHRNZW51IH0gPSBJbnRlcmFjdGlvblN0YXRlO1xuICAgIGxldCBwaWNrZWROb2RlO1xuICAgIGlmICh0aGlzLmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKSAmIChEZWZhdWx0MiB8IENvbnRleHRNZW51KSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgeyB4OiBldmVudC5vZmZzZXRYLCB5OiBldmVudC5vZmZzZXRZIH0sIFwiY29udGV4dC1tZW51XCIpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICAgICAgICBwaWNrZWROb2RlID0gbWF0Y2guZGF0dW07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzcGF0Y2hDb250ZXh0KFwic2VyaWVzXCIsIGV2ZW50LCB7IHBpY2tlZE5vZGUgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNMYXllck1hbmFnZXIudHNcbnZhciBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTiA9IDMwO1xudmFyIFNlcmllc0xheWVyTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzUm9vdCwgaGlnaGxpZ2h0Um9vdCwgYW5ub3RhdGlvblJvb3QpIHtcbiAgICB0aGlzLnNlcmllc1Jvb3QgPSBzZXJpZXNSb290O1xuICAgIHRoaXMuaGlnaGxpZ2h0Um9vdCA9IGhpZ2hsaWdodFJvb3Q7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdCA9IGFubm90YXRpb25Sb290O1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5zZXJpZXMgPSB7fTtcbiAgICB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPSAxO1xuICAgIHRoaXMubW9kZSA9IFwibm9ybWFsXCI7XG4gIH1cbiAgc2V0U2VyaWVzQ291bnQoY291bnQpIHtcbiAgICB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPSBjb3VudDtcbiAgfVxuICByZXF1ZXN0R3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbElkLFxuICAgICAgdHlwZSxcbiAgICAgIHJvb3RHcm91cDogc2VyaWVzUm9vdEdyb3VwLFxuICAgICAgaGlnaGxpZ2h0R3JvdXA6IHNlcmllc0hpZ2hsaWdodEdyb3VwLFxuICAgICAgYW5ub3RhdGlvbkdyb3VwOiBzZXJpZXNBbm5vdGF0aW9uR3JvdXAsXG4gICAgICBzZXJpZXNHcm91cGluZ1xuICAgIH0gPSBzZXJpZXNDb25maWc7XG4gICAgY29uc3QgeyBncm91cEluZGV4ID0gaW50ZXJuYWxJZCB9ID0gc2VyaWVzR3JvdXBpbmcgPz8ge307XG4gICAgaWYgKHRoaXMuc2VyaWVzW2ludGVybmFsSWRdICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gc2VyaWVzIGFscmVhZHkgaGFzIGFuIGFsbG9jYXRlZCBsYXllcjogJHt0aGlzLnNlcmllc1tpbnRlcm5hbElkXX1gKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc2VyaWVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA+PSBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTiA/IFwiYWdncmVzc2l2ZS1ncm91cGluZ1wiIDogXCJub3JtYWxcIjtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5ncm91cHMpW3R5cGVdID8/IChfYVt0eXBlXSA9IHt9KTtcbiAgICBjb25zdCBsb29rdXBJbmRleCA9IHRoaXMubG9va3VwSWR4KGdyb3VwSW5kZXgpO1xuICAgIGxldCBncm91cEluZm8gPSB0aGlzLmdyb3Vwc1t0eXBlXVtsb29rdXBJbmRleF07XG4gICAgaWYgKCFncm91cEluZm8pIHtcbiAgICAgIGdyb3VwSW5mbyA9IChfYiA9IHRoaXMuZ3JvdXBzW3R5cGVdKVtsb29rdXBJbmRleF0gPz8gKF9iW2xvb2t1cEluZGV4XSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaWQ6IGxvb2t1cEluZGV4LFxuICAgICAgICBzZXJpZXNJZHM6IFtdLFxuICAgICAgICBncm91cDogdGhpcy5zZXJpZXNSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1jb250ZW50YCxcbiAgICAgICAgICAgIGxheWVyOiB0cnVlLFxuICAgICAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogc2VyaWVzQ29uZmlnLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJkYXRhXCIpXG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgaGlnaGxpZ2h0OiB0aGlzLmhpZ2hsaWdodFJvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWhpZ2hsaWdodGAsXG4gICAgICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImhpZ2hsaWdodFwiKVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIGFubm90YXRpb246IHRoaXMuYW5ub3RhdGlvblJvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWFubm90YXRpb25gLFxuICAgICAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogc2VyaWVzQ29uZmlnLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJhbm5vdGF0aW9uXCIpXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc2VyaWVzW2ludGVybmFsSWRdID0geyBsYXllclN0YXRlOiBncm91cEluZm8sIHNlcmllc0NvbmZpZyB9O1xuICAgIGdyb3VwSW5mby5zZXJpZXNJZHMucHVzaChpbnRlcm5hbElkKTtcbiAgICBncm91cEluZm8uZ3JvdXAuYXBwZW5kQ2hpbGQoc2VyaWVzUm9vdEdyb3VwKTtcbiAgICBncm91cEluZm8uaGlnaGxpZ2h0LmFwcGVuZENoaWxkKHNlcmllc0hpZ2hsaWdodEdyb3VwKTtcbiAgICBncm91cEluZm8uYW5ub3RhdGlvbi5hcHBlbmRDaGlsZChzZXJpZXNBbm5vdGF0aW9uR3JvdXApO1xuICAgIHJldHVybiBncm91cEluZm8uZ3JvdXA7XG4gIH1cbiAgY2hhbmdlR3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCBzZXJpZXNHcm91cGluZywgdHlwZSwgcm9vdEdyb3VwLCBoaWdobGlnaHRHcm91cCwgYW5ub3RhdGlvbkdyb3VwLCBvbGRHcm91cGluZyB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGNvbnN0IHsgZ3JvdXBJbmRleCA9IGludGVybmFsSWQgfSA9IHNlcmllc0dyb3VwaW5nID8/IHt9O1xuICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXT8uW2dyb3VwSW5kZXhdPy5zZXJpZXNJZHMuaW5jbHVkZXMoaW50ZXJuYWxJZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VyaWVzW2ludGVybmFsSWRdICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmVsZWFzZUdyb3VwKHtcbiAgICAgICAgaW50ZXJuYWxJZCxcbiAgICAgICAgc2VyaWVzR3JvdXBpbmc6IG9sZEdyb3VwaW5nLFxuICAgICAgICB0eXBlLFxuICAgICAgICByb290R3JvdXAsXG4gICAgICAgIGhpZ2hsaWdodEdyb3VwLFxuICAgICAgICBhbm5vdGF0aW9uR3JvdXBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RHcm91cChzZXJpZXNDb25maWcpO1xuICB9XG4gIHJlbGVhc2VHcm91cChzZXJpZXNDb25maWcpIHtcbiAgICBjb25zdCB7IGludGVybmFsSWQsIHJvb3RHcm91cCwgaGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cCwgdHlwZSB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGlmICh0aGlzLnNlcmllc1tpbnRlcm5hbElkXSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHNlcmllcyBkb2Vzbid0IGhhdmUgYW4gYWxsb2NhdGVkIGxheWVyOiAke2ludGVybmFsSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwSW5mbyA9IHRoaXMuc2VyaWVzW2ludGVybmFsSWRdPy5sYXllclN0YXRlO1xuICAgIGlmIChncm91cEluZm8pIHtcbiAgICAgIGdyb3VwSW5mby5zZXJpZXNJZHMgPSBncm91cEluZm8uc2VyaWVzSWRzLmZpbHRlcigodikgPT4gdiAhPT0gaW50ZXJuYWxJZCk7XG4gICAgICBncm91cEluZm8uZ3JvdXAucmVtb3ZlQ2hpbGQocm9vdEdyb3VwKTtcbiAgICAgIGdyb3VwSW5mby5oaWdobGlnaHQucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0R3JvdXApO1xuICAgICAgZ3JvdXBJbmZvLmFubm90YXRpb24ucmVtb3ZlQ2hpbGQoYW5ub3RhdGlvbkdyb3VwKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwSW5mbz8uc2VyaWVzSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zZXJpZXNSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5ncm91cCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodFJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmhpZ2hsaWdodCk7XG4gICAgICB0aGlzLmFubm90YXRpb25Sb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5hbm5vdGF0aW9uKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cEluZm8udHlwZV1bZ3JvdXBJbmZvLmlkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXVtpbnRlcm5hbElkXTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwSW5mbz8uc2VyaWVzSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxlYWRTZXJpZXNDb25maWcgPSB0aGlzLnNlcmllc1tncm91cEluZm8/LnNlcmllc0lkcz8uWzBdXT8uc2VyaWVzQ29uZmlnO1xuICAgICAgZ3JvdXBJbmZvLmdyb3VwLnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZz8uZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIik7XG4gICAgICBncm91cEluZm8uaGlnaGxpZ2h0LnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZz8uZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImhpZ2hsaWdodFwiKTtcbiAgICAgIGdyb3VwSW5mby5hbm5vdGF0aW9uLnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZz8uZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImFubm90YXRpb25cIik7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnNlcmllc1tpbnRlcm5hbElkXTtcbiAgfVxuICBsb29rdXBJZHgoZ3JvdXBJbmRleCkge1xuICAgIGlmICh0aGlzLm1vZGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgIHJldHVybiBncm91cEluZGV4O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdyb3VwSW5kZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdyb3VwSW5kZXggPSBOdW1iZXIoZ3JvdXBJbmRleC5zcGxpdChcIi1cIikuYXQoLTEpKTtcbiAgICAgIGlmICghZ3JvdXBJbmRleCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICBjbGFtcCgwLCBncm91cEluZGV4IC8gdGhpcy5leHBlY3RlZFNlcmllc0NvdW50LCAxKSAqIFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgZ3JvdXBzIG9mIE9iamVjdC52YWx1ZXModGhpcy5ncm91cHMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwSW5mbyBvZiBPYmplY3QudmFsdWVzKGdyb3VwcykpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5ncm91cCk7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Um9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uaGlnaGxpZ2h0KTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uYW5ub3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5zZXJpZXMgPSB7fTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdXBkYXRlL2Jhc2VMYXlvdXRQcm9jZXNzb3IudHNcbnZhciBCYXNlTGF5b3V0UHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydExpa2UsIGxheW91dFNlcnZpY2UpIHtcbiAgICB0aGlzLmNoYXJ0TGlrZSA9IGNoYXJ0TGlrZTtcbiAgICB0aGlzLmxheW91dFNlcnZpY2UgPSBsYXlvdXRTZXJ2aWNlO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvbmFyanMvbm8tZHVwbGljYXRlLXN0cmluZ1xuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwic3RhcnQtbGF5b3V0XCIsIChlKSA9PiB0aGlzLnBvc2l0aW9uUGFkZGluZyhlKSksXG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGUpID0+IHRoaXMuYWxpZ25DYXB0aW9ucyhlKSksXG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJzdGFydC1sYXlvdXRcIiwgKGUpID0+IHRoaXMucG9zaXRpb25DYXB0aW9ucyhlKSlcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgfVxuICBwb3NpdGlvblBhZGRpbmcoY3R4KSB7XG4gICAgY29uc3QgeyBzaHJpbmtSZWN0IH0gPSBjdHg7XG4gICAgY29uc3QgeyBwYWRkaW5nIH0gPSB0aGlzLmNoYXJ0TGlrZTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmxlZnQsIFwibGVmdFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgXCJ0b3BcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5yaWdodCwgXCJyaWdodFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmJvdHRvbSwgXCJib3R0b21cIik7XG4gICAgcmV0dXJuIHsgLi4uY3R4LCBzaHJpbmtSZWN0IH07XG4gIH1cbiAgcG9zaXRpb25DYXB0aW9ucyhjdHgpIHtcbiAgICBjb25zdCB7IHNocmlua1JlY3QsIHBvc2l0aW9ucywgcGFkZGluZyB9ID0gY3R4O1xuICAgIGNvbnN0IHsgdGl0bGUsIHN1YnRpdGxlLCBmb290bm90ZSwgdGl0bGVQYWRkaW5nIH0gPSB0aGlzLmNoYXJ0TGlrZTtcbiAgICBjb25zdCBwYWRkZWRTaHJpbmtSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpLnNocmluayh0aXRsZVBhZGRpbmcpO1xuICAgIGNvbnN0IG5ld1Nocmlua1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCk7XG4gICAgY29uc3QgdXBkYXRlQ2FwdGlvbiA9IChjYXB0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0Q2FwdGlvbkhlaWdodCA9IHNocmlua1JlY3QuaGVpZ2h0IC8gMTA7XG4gICAgICBjb25zdCBjYXB0aW9uTGluZUhlaWdodCA9IGNhcHRpb24ubGluZUhlaWdodCA/PyBjYXB0aW9uLmZvbnRTaXplICogVGV4dC5kZWZhdWx0TGluZUhlaWdodFJhdGlvO1xuICAgICAgY29uc3QgbWF4V2lkdGggPSBzaHJpbmtSZWN0LndpZHRoO1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoY2FwdGlvbkxpbmVIZWlnaHQsIGRlZmF1bHRDYXB0aW9uSGVpZ2h0KTtcbiAgICAgIGNhcHRpb24uY29tcHV0ZVRleHRXcmFwKG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuICAgIH07XG4gICAgY29uc3QgY29tcHV0ZVggPSAoYWxpZ24pID0+IHtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhZGRlZFNocmlua1JlY3QueDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICByZXR1cm4gcGFkZGVkU2hyaW5rUmVjdC54ICsgcGFkZGVkU2hyaW5rUmVjdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKGBpbnZhbGlkIHRleHRBbGlnbiB2YWx1ZTogJHthbGlnbn1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWRkZWRTaHJpbmtSZWN0LnggKyBwYWRkZWRTaHJpbmtSZWN0LndpZHRoIC8gMjtcbiAgICB9O1xuICAgIGNvbnN0IHBvc2l0aW9uVG9wQW5kU2hyaW5rQkJveCA9IChjYXB0aW9uLCBzcGFjaW5nKSA9PiB7XG4gICAgICBjb25zdCBiYXNlWSA9IHBhZGRlZFNocmlua1JlY3QueTtcbiAgICAgIGNhcHRpb24ubm9kZS54ID0gY29tcHV0ZVgoY2FwdGlvbi50ZXh0QWxpZ24pO1xuICAgICAgY2FwdGlvbi5ub2RlLnkgPSBiYXNlWTtcbiAgICAgIGNhcHRpb24ubm9kZS50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgICAgdXBkYXRlQ2FwdGlvbihjYXB0aW9uKTtcbiAgICAgIGNvbnN0IGJib3ggPSBjYXB0aW9uLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgY29uc3QgYmJveEhlaWdodCA9IE1hdGguY2VpbChiYm94LnkgLSBiYXNlWSArIGJib3guaGVpZ2h0ICsgc3BhY2luZyk7XG4gICAgICBpZiAoY2FwdGlvbi5sYXlvdXRTdHlsZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIG5ld1Nocmlua1JlY3Quc2hyaW5rKGJib3hIZWlnaHQgKyAyICogdGl0bGVQYWRkaW5nLCBcInRvcFwiKTtcbiAgICAgICAgcGFkZGVkU2hyaW5rUmVjdC5zaHJpbmsoYmJveEhlaWdodCwgXCJ0b3BcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmJveDtcbiAgICB9O1xuICAgIGNvbnN0IHBvc2l0aW9uQm90dG9tQW5kU2hyaW5rQkJveCA9IChjYXB0aW9uLCBzcGFjaW5nKSA9PiB7XG4gICAgICBjb25zdCBiYXNlWSA9IHBhZGRlZFNocmlua1JlY3QueSArIHBhZGRlZFNocmlua1JlY3QuaGVpZ2h0O1xuICAgICAgY2FwdGlvbi5ub2RlLnggPSBjb21wdXRlWChjYXB0aW9uLnRleHRBbGlnbik7XG4gICAgICBjYXB0aW9uLm5vZGUueSA9IGJhc2VZO1xuICAgICAgY2FwdGlvbi5ub2RlLnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICB1cGRhdGVDYXB0aW9uKGNhcHRpb24pO1xuICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5nZXRCQm94KCk7XG4gICAgICBjb25zdCBiYm94SGVpZ2h0ID0gTWF0aC5jZWlsKGJhc2VZIC0gYmJveC55ICsgc3BhY2luZyk7XG4gICAgICBpZiAoY2FwdGlvbi5sYXlvdXRTdHlsZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIG5ld1Nocmlua1JlY3Quc2hyaW5rKGJib3hIZWlnaHQgKyAyICogdGl0bGVQYWRkaW5nLCBcImJvdHRvbVwiKTtcbiAgICAgICAgcGFkZGVkU2hyaW5rUmVjdC5zaHJpbmsoYmJveEhlaWdodCwgXCJib3R0b21cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmJveDtcbiAgICB9O1xuICAgIHRpdGxlLm5vZGUudmlzaWJsZSA9IHRpdGxlLmVuYWJsZWQ7XG4gICAgc3VidGl0bGUubm9kZS52aXNpYmxlID0gc3VidGl0bGUuZW5hYmxlZDtcbiAgICBmb290bm90ZS5ub2RlLnZpc2libGUgPSBmb290bm90ZS5lbmFibGVkO1xuICAgIGlmICh0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjb25zdCB7IHNwYWNpbmcgPSBzdWJ0aXRsZS5lbmFibGVkID8gQ2FwdGlvbi5TTUFMTF9QQURESU5HIDogQ2FwdGlvbi5MQVJHRV9QQURESU5HIH0gPSB0aXRsZTtcbiAgICAgIHBvc2l0aW9ucy50aXRsZSA9IHBvc2l0aW9uVG9wQW5kU2hyaW5rQkJveCh0aXRsZSwgc3BhY2luZyk7XG4gICAgfVxuICAgIGlmIChzdWJ0aXRsZS5lbmFibGVkKSB7XG4gICAgICBwb3NpdGlvbnMuc3VidGl0bGUgPSBwb3NpdGlvblRvcEFuZFNocmlua0JCb3goc3VidGl0bGUsIHN1YnRpdGxlLnNwYWNpbmcgPz8gMCk7XG4gICAgfVxuICAgIGlmIChmb290bm90ZS5lbmFibGVkKSB7XG4gICAgICBwb3NpdGlvbnMuZm9vdG5vdGUgPSBwb3NpdGlvbkJvdHRvbUFuZFNocmlua0JCb3goZm9vdG5vdGUsIGZvb3Rub3RlLnNwYWNpbmcgPz8gMCk7XG4gICAgfVxuICAgIHBhZGRpbmcudGl0bGUgPSB0aXRsZVBhZGRpbmc7XG4gICAgcmV0dXJuIHsgLi4uY3R4LCBzaHJpbmtSZWN0OiBuZXdTaHJpbmtSZWN0LCBwb3NpdGlvbnMgfTtcbiAgfVxuICBhbGlnbkNhcHRpb25zKGN0eCkge1xuICAgIGNvbnN0IHsgcmVjdCB9ID0gY3R4LnNlcmllcztcbiAgICBjb25zdCB7IHRpdGxlLCBzdWJ0aXRsZSwgZm9vdG5vdGUsIHRpdGxlUGFkZGluZyB9ID0gdGhpcy5jaGFydExpa2U7XG4gICAgZm9yIChjb25zdCBjYXB0aW9uIG9mIFt0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlXSkge1xuICAgICAgaWYgKGNhcHRpb24ubGF5b3V0U3R5bGUgIT09IFwib3ZlcmxheVwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjYXB0aW9uLnRleHRBbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgY2FwdGlvbi5ub2RlLnggPSByZWN0LnggKyB0aXRsZVBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGNhcHRpb24udGV4dEFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5nZXRCQm94KCk7XG4gICAgICAgIGNhcHRpb24ubm9kZS54ID0gcmVjdC54ICsgcmVjdC53aWR0aCAtIGJib3gud2lkdGggLSB0aXRsZVBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGUvZGF0YVdpbmRvd1Byb2Nlc3Nvci50c1xudmFyIERhdGFXaW5kb3dQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhU2VydmljZSwgdXBkYXRlU2VydmljZSwgem9vbU1hbmFnZXIpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5kYXRhU2VydmljZSA9IGRhdGFTZXJ2aWNlO1xuICAgIHRoaXMudXBkYXRlU2VydmljZSA9IHVwZGF0ZVNlcnZpY2U7XG4gICAgdGhpcy56b29tTWFuYWdlciA9IHpvb21NYW5hZ2VyO1xuICAgIHRoaXMuZGlydHlab29tID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eURhdGFTb3VyY2UgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RBeGlzWm9vbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5kYXRhU2VydmljZS5hZGRMaXN0ZW5lcihcImRhdGEtc291cmNlLWNoYW5nZVwiLCAoKSA9PiB0aGlzLm9uRGF0YVNvdXJjZUNoYW5nZSgpKSxcbiAgICAgIHRoaXMuZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLWxvYWRcIiwgKCkgPT4gdGhpcy5vbkRhdGFMb2FkKCkpLFxuICAgICAgdGhpcy5kYXRhU2VydmljZS5hZGRMaXN0ZW5lcihcImRhdGEtZXJyb3JcIiwgKCkgPT4gdGhpcy5vbkRhdGFFcnJvcigpKSxcbiAgICAgIHRoaXMudXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcihcInVwZGF0ZS1jb21wbGV0ZVwiLCAoKSA9PiB0aGlzLm9uVXBkYXRlQ29tcGxldGUoKSksXG4gICAgICB0aGlzLnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5vblpvb21DaGFuZ2UoKSlcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgfVxuICBvbkRhdGFMb2FkKCkge1xuICAgIHRoaXMudXBkYXRlU2VydmljZS51cGRhdGUoMSAvKiBVUERBVEVfREFUQSAqLyk7XG4gIH1cbiAgb25EYXRhRXJyb3IoKSB7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgzIC8qIFBFUkZPUk1fTEFZT1VUICovKTtcbiAgfVxuICBvbkRhdGFTb3VyY2VDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXJ0eURhdGFTb3VyY2UgPSB0cnVlO1xuICB9XG4gIG9uVXBkYXRlQ29tcGxldGUoKSB7XG4gICAgaWYgKCF0aGlzLmRpcnR5Wm9vbSAmJiAhdGhpcy5kaXJ0eURhdGFTb3VyY2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVXaW5kb3coKS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gIH1cbiAgb25ab29tQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHlab29tID0gdHJ1ZTtcbiAgfVxuICBhc3luYyB1cGRhdGVXaW5kb3coKSB7XG4gICAgaWYgKCF0aGlzLmRhdGFTZXJ2aWNlLmlzTGF6eSgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmdldFZhbGlkQXhpcygpO1xuICAgIGxldCB3aW5kb3cyO1xuICAgIGxldCBzaG91bGRSZWZyZXNoID0gdHJ1ZTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgY29uc3Qgem9vbTIgPSB0aGlzLnpvb21NYW5hZ2VyLmdldEF4aXNab29tKGF4aXMuaWQpO1xuICAgICAgd2luZG93MiA9IHRoaXMuZ2V0QXhpc1dpbmRvdyhheGlzLCB6b29tMik7XG4gICAgICBzaG91bGRSZWZyZXNoID0gdGhpcy5zaG91bGRSZWZyZXNoKGF4aXMsIHpvb20yKTtcbiAgICB9XG4gICAgdGhpcy5kaXJ0eVpvb20gPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmICghc2hvdWxkUmVmcmVzaClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRhdGFTZXJ2aWNlLmxvYWQoeyB3aW5kb3dTdGFydDogd2luZG93Mj8ubWluLCB3aW5kb3dFbmQ6IHdpbmRvdzI/Lm1heCB9KTtcbiAgfVxuICBnZXRWYWxpZEF4aXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLnR5cGUgPT09IFwidGltZVwiKTtcbiAgfVxuICBzaG91bGRSZWZyZXNoKGF4aXMsIHpvb20yKSB7XG4gICAgaWYgKHRoaXMuZGlydHlEYXRhU291cmNlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF0aGlzLmRpcnR5Wm9vbSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsYXN0Wm9vbSA9IHRoaXMubGFzdEF4aXNab29tcy5nZXQoYXhpcy5pZCk7XG4gICAgaWYgKGxhc3Rab29tICYmIHpvb20yLm1pbiA9PT0gbGFzdFpvb20ubWluICYmIHpvb20yLm1heCA9PT0gbGFzdFpvb20ubWF4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGFzdEF4aXNab29tcy5zZXQoYXhpcy5pZCwgem9vbTIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldEF4aXNXaW5kb3coYXhpcywgem9vbTIpIHtcbiAgICBjb25zdCBkb21haW4gPSBheGlzLnNjYWxlLmdldERvbWFpbj8uKCk7XG4gICAgaWYgKCF6b29tMiB8fCAhZG9tYWluIHx8IGRvbWFpbi5sZW5ndGggPT09IDAgfHwgaXNOYU4oTnVtYmVyKGRvbWFpblswXSkpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRpZmYyID0gTnVtYmVyKGRvbWFpblsxXSkgLSBOdW1iZXIoZG9tYWluWzBdKTtcbiAgICBjb25zdCBtaW4gPSBuZXcgRGF0ZShOdW1iZXIoZG9tYWluWzBdKSArIGRpZmYyICogem9vbTIubWluKTtcbiAgICBjb25zdCBtYXggPSBuZXcgRGF0ZShOdW1iZXIoZG9tYWluWzBdKSArIGRpZmYyICogem9vbTIubWF4KTtcbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGUvb3ZlcmxheXNQcm9jZXNzb3IudHNcbnZhciBPdmVybGF5c1Byb2Nlc3NvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnRMaWtlLCBvdmVybGF5cywgZGF0YVNlcnZpY2UsIGxheW91dFNlcnZpY2UsIGxvY2FsZU1hbmFnZXIsIGFuaW1hdGlvbk1hbmFnZXIsIGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmNoYXJ0TGlrZSA9IGNoYXJ0TGlrZTtcbiAgICB0aGlzLm92ZXJsYXlzID0gb3ZlcmxheXM7XG4gICAgdGhpcy5kYXRhU2VydmljZSA9IGRhdGFTZXJ2aWNlO1xuICAgIHRoaXMubGF5b3V0U2VydmljZSA9IGxheW91dFNlcnZpY2U7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbG9jYWxlTWFuYWdlcjtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBhbmltYXRpb25NYW5hZ2VyO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5vdmVybGF5RWxlbSA9IHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIFwib3ZlcmxheVwiKTtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnJvbGUgPSBcInN0YXR1c1wiO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uYXJpYUF0b21pYyA9IFwiZmFsc2VcIjtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmFyaWFMaXZlID0gXCJwb2xpdGVcIjtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmNsYXNzTGlzdC50b2dnbGUoREVGQVVMVF9PVkVSTEFZX0NMQVNTKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCh0aGlzLmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGUpID0+IHRoaXMub25MYXlvdXRDb21wbGV0ZShlKSkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKFwib3ZlcmxheXNcIik7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgXCJvdmVybGF5XCIpO1xuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUoeyBzZXJpZXM6IHsgcmVjdCB9IH0pIHtcbiAgICBjb25zdCBpc0xvYWRpbmcgPSB0aGlzLmRhdGFTZXJ2aWNlLmlzTG9hZGluZygpO1xuICAgIGNvbnN0IGhhc0RhdGEgPSB0aGlzLmNoYXJ0TGlrZS5zZXJpZXMuc29tZSgocykgPT4gcy5oYXNEYXRhKTtcbiAgICBjb25zdCBhbnlTZXJpZXNWaXNpYmxlID0gdGhpcy5jaGFydExpa2Uuc2VyaWVzLnNvbWUoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgaWYgKHRoaXMub3ZlcmxheXMuZGFya1RoZW1lKSB7XG4gICAgICB0aGlzLm92ZXJsYXlFbGVtLmNsYXNzTGlzdC5hZGQoREVGQVVMVF9PVkVSTEFZX0RBUktfQ0xBU1MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm92ZXJsYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoREVGQVVMVF9PVkVSTEFZX0RBUktfQ0xBU1MpO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLmxlZnQgPSBgJHtyZWN0Lnh9cHhgO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aH1weGA7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGA7XG4gICAgdGhpcy50b2dnbGVPdmVybGF5KHRoaXMub3ZlcmxheXMubG9hZGluZywgcmVjdCwgaXNMb2FkaW5nKTtcbiAgICB0aGlzLnRvZ2dsZU92ZXJsYXkodGhpcy5vdmVybGF5cy5ub0RhdGEsIHJlY3QsICFpc0xvYWRpbmcgJiYgIWhhc0RhdGEpO1xuICAgIHRoaXMudG9nZ2xlT3ZlcmxheSh0aGlzLm92ZXJsYXlzLm5vVmlzaWJsZVNlcmllcywgcmVjdCwgaGFzRGF0YSAmJiAhYW55U2VyaWVzVmlzaWJsZSk7XG4gIH1cbiAgdG9nZ2xlT3ZlcmxheShvdmVybGF5LCBzZXJpZXNSZWN0LCB2aXNpYmxlKSB7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcmlhSGlkZGVuID0gKCF2aXNpYmxlKS50b1N0cmluZygpO1xuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICBjb25zdCBlbGVtZW50MiA9IG92ZXJsYXkuZ2V0RWxlbWVudCh0aGlzLmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubG9jYWxlTWFuYWdlciwgc2VyaWVzUmVjdCk7XG4gICAgICB0aGlzLm92ZXJsYXlFbGVtLmFwcGVuZENoaWxkKGVsZW1lbnQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3ZlcmxheS5yZW1vdmVFbGVtZW50KCgpID0+IHtcbiAgICAgICAgdGhpcy5vdmVybGF5RWxlbS5pbm5lclRleHQgPSBcIlxceEEwXCI7XG4gICAgICB9LCB0aGlzLmFuaW1hdGlvbk1hbmFnZXIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnQudHNcbnZhciBkZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG52YXIgU2VyaWVzQXJlYSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGFkZGluZyA9IG5ldyBQYWRkaW5nKDApO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzQXJlYS5wcm90b3R5cGUsIFwiY2xpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc0FyZWEucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG52YXIgX0NoYXJ0ID0gY2xhc3MgX0NoYXJ0IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLnNlcmllc1Jvb3QgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1zZXJpZXMtcm9vdGAgfSk7XG4gICAgdGhpcy5oaWdobGlnaHRSb290ID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWhpZ2hsaWdodC1yb290YCxcbiAgICAgIGxheWVyOiB0cnVlLFxuICAgICAgekluZGV4OiA1IC8qIFNFUklFU19ISUdITElHSFRfWklOREVYICovLFxuICAgICAgbm9uRW1wdHlDaGlsZERlcml2ZWRaSW5kZXg6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25Sb290ID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWFubm90YXRpb24tcm9vdGAsXG4gICAgICBsYXllcjogdHJ1ZSxcbiAgICAgIHpJbmRleDogMTAgLyogU0VSSUVTX0FOTk9UQVRJT05fWklOREVYICovXG4gICAgfSk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSgpO1xuICAgIHRoaXMuZXh0cmFEZWJ1Z1N0YXRzID0ge307XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5fZmlyc3RBdXRvU2l6ZSA9IHRydWU7XG4gICAgdGhpcy5wYWRkaW5nID0gbmV3IFBhZGRpbmcoMjApO1xuICAgIHRoaXMudGl0bGVQYWRkaW5nID0gMDtcbiAgICB0aGlzLnNlcmllc0FyZWEgPSBuZXcgU2VyaWVzQXJlYSgpO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuc3VidGl0bGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuZm9vdG5vdGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMua2V5Ym9hcmQgPSBuZXcgS2V5Ym9hcmQoKTtcbiAgICB0aGlzLm1vZGUgPSBcInN0YW5kYWxvbmVcIjtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NraXBTeW5jID0gZmFsc2U7XG4gICAgdGhpcy5fZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwiaW5pdGlhbFwiO1xuICAgIHRoaXMubW9kdWxlc01hbmFnZXIgPSBuZXcgTW9kdWxlc01hbmFnZXIoKTtcbiAgICAvLyBGSVhNRTogem9vbU1hbmFnZXIgc2hvdWxkIGJlIG93bmVkIGJ5IGN0eCwgYnV0IGl0IGNhbid0IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBDYXJ0ZXNpYW5DaGFydC5vbkF4aXNDaGFuZ2UgYmVmb3JlIGN0eCBpcyBpbml0aWFsaXNlZFxuICAgIHRoaXMuem9vbU1hbmFnZXIgPSBuZXcgWm9vbU1hbmFnZXIoKTtcbiAgICB0aGlzLnByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnF1ZXVlZFVzZXJPcHRpb25zID0gW107XG4gICAgdGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQgPSAwO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVOb1JlbmRlckNvdW50ID0gMDtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gNyAvKiBOT05FICovO1xuICAgIHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA9IDA7XG4gICAgdGhpcy5zZXJpZXNUb1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy51cGRhdGVNdXRleCA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMudXBkYXRlUmVxdWVzdG9ycyA9IHt9O1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVRyaWdnZXIgPSBkZWJvdW5jZWRDYWxsYmFjayhhc3luYyAoeyBjb3VudCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMudXBkYXRlTXV0ZXguYWNxdWlyZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wZXJmb3JtVXBkYXRlKGNvdW50KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBMb2dnZXIuZXJyb3IoXCJ1cGRhdGUgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNwbGl0cyA9IHt9O1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5vblNlcmllc05vZGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzTm9kZUNsaWNrRXZlbnQgPSB7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICB0eXBlOiBcInNlcmllc05vZGVDbGlja1wiXG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlcmllc05vZGVDbGlja0V2ZW50LCBcInNlcmllc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAvLyBTaG91bGQgZGlzcGxheSB0aGUgZGVwcmVjYXRpb24gd2FybmluZ1xuICAgICAgICBnZXQ6ICgpID0+IGV2ZW50LnNlcmllc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZpcmVFdmVudChzZXJpZXNOb2RlQ2xpY2tFdmVudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNOb2RlRG91YmxlQ2xpY2sgPSB7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICB0eXBlOiBcInNlcmllc05vZGVEb3VibGVDbGlja1wiXG4gICAgICB9O1xuICAgICAgdGhpcy5maXJlRXZlbnQoc2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcbiAgICB9O1xuICAgIHRoaXMuc2VyaWVzR3JvdXBpbmdDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIShldmVudCBpbnN0YW5jZW9mIFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBzZXJpZXMsIHNlcmllc0dyb3VwaW5nLCBvbGRHcm91cGluZyB9ID0gZXZlbnQ7XG4gICAgICBpZiAoc2VyaWVzLnJvb3RHcm91cC5wYXJlbnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIuY2hhbmdlR3JvdXAoe1xuICAgICAgICBpbnRlcm5hbElkOiBzZXJpZXMuaW50ZXJuYWxJZCxcbiAgICAgICAgdHlwZTogc2VyaWVzLnR5cGUsXG4gICAgICAgIHJvb3RHcm91cDogc2VyaWVzLnJvb3RHcm91cCxcbiAgICAgICAgaGlnaGxpZ2h0R3JvdXA6IHNlcmllcy5oaWdobGlnaHRHcm91cCxcbiAgICAgICAgYW5ub3RhdGlvbkdyb3VwOiBzZXJpZXMuYW5ub3RhdGlvbkdyb3VwLFxuICAgICAgICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyOiAodHlwZSkgPT4gc2VyaWVzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSksXG4gICAgICAgIHNlcmllc0dyb3VwaW5nLFxuICAgICAgICBvbGRHcm91cGluZ1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmRhdGFQcm9jZXNzTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2NlbmUgPSByZXNvdXJjZXM/LnNjZW5lO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHJlc291cmNlcz8uY29udGFpbmVyO1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInJvb3RcIiB9KTtcbiAgICBjb25zdCB0aXRsZUdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJ0aXRsZXNcIiwgbGF5ZXI6IHRydWUsIHpJbmRleDogOCAvKiBTRVJJRVNfTEFCRUxfWklOREVYICovIH0pO1xuICAgIHJvb3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIHJvb3QuYXBwZW5kKHRpdGxlR3JvdXApO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMuc2VyaWVzUm9vdCk7XG4gICAgcm9vdC5hcHBlbmQodGhpcy5oaWdobGlnaHRSb290KTtcbiAgICByb290LmFwcGVuZCh0aGlzLmFubm90YXRpb25Sb290KTtcbiAgICB0aXRsZUdyb3VwLmFwcGVuZCh0aGlzLnRpdGxlLm5vZGUpO1xuICAgIHRpdGxlR3JvdXAuYXBwZW5kKHRoaXMuc3VidGl0bGUubm9kZSk7XG4gICAgdGl0bGVHcm91cC5hcHBlbmQodGhpcy5mb290bm90ZS5ub2RlKTtcbiAgICBjb25zdCB7IG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyB9ID0gb3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBUb29sdGlwKCk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIgPSBuZXcgU2VyaWVzTGF5ZXJNYW5hZ2VyKHRoaXMuc2VyaWVzUm9vdCwgdGhpcy5oaWdobGlnaHRSb290LCB0aGlzLmFubm90YXRpb25Sb290KTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eCA9IG5ldyBDaGFydENvbnRleHQodGhpcywge1xuICAgICAgc2NlbmUsXG4gICAgICByb290LFxuICAgICAgc3luY01hbmFnZXI6IG5ldyBTeW5jTWFuYWdlcih0aGlzKSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHVwZGF0ZUNhbGxiYWNrOiAodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0cykgPT4gdGhpcy51cGRhdGUodHlwZSwgb3B0cyksXG4gICAgICB1cGRhdGVNdXRleDogdGhpcy51cGRhdGVNdXRleCxcbiAgICAgIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpb1xuICAgIH0pO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHRoaXMucGFyZW50UmVzaXplKGN0eC5kb21NYW5hZ2VyLmNvbnRhaW5lclNpemUpKVxuICAgICk7XG4gICAgdGhpcy5vdmVybGF5cyA9IG5ldyBDaGFydE92ZXJsYXlzKCk7XG4gICAgKF9hID0gdGhpcy5vdmVybGF5cy5sb2FkaW5nKS5yZW5kZXJlciA/PyAoX2EucmVuZGVyZXIgPSAoKSA9PiBnZXRMb2FkaW5nU3Bpbm5lcih0aGlzLm92ZXJsYXlzLmxvYWRpbmcuZ2V0VGV4dChjdHgubG9jYWxlTWFuYWdlciksIGN0eC5hbmltYXRpb25NYW5hZ2VyLmRlZmF1bHREdXJhdGlvbikpO1xuICAgIHRoaXMucHJvY2Vzc29ycyA9IFtcbiAgICAgIG5ldyBCYXNlTGF5b3V0UHJvY2Vzc29yKHRoaXMsIGN0eC5sYXlvdXRTZXJ2aWNlKSxcbiAgICAgIG5ldyBEYXRhV2luZG93UHJvY2Vzc29yKHRoaXMsIGN0eC5kYXRhU2VydmljZSwgY3R4LnVwZGF0ZVNlcnZpY2UsIGN0eC56b29tTWFuYWdlciksXG4gICAgICBuZXcgT3ZlcmxheXNQcm9jZXNzb3IoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMub3ZlcmxheXMsXG4gICAgICAgIGN0eC5kYXRhU2VydmljZSxcbiAgICAgICAgY3R4LmxheW91dFNlcnZpY2UsXG4gICAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLFxuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgICAgY3R4LmRvbU1hbmFnZXJcbiAgICAgIClcbiAgICBdO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gbmV3IENoYXJ0SGlnaGxpZ2h0KCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpO1xuICAgIGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLywgdGhpcy5zZXJpZXNSb290LCB0aGlzLmN0eC5heGlzTWFuYWdlci5heGlzR3JpZEdyb3VwKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8pO1xuICAgIGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovKTtcbiAgICBjb25zdCB0aGlzQ2hhcnQgPSB0aGlzO1xuICAgIHRoaXMuc2VyaWVzQXJlYU1hbmFnZXIgPSBuZXcgU2VyaWVzQXJlYU1hbmFnZXIoXG4gICAgICB7XG4gICAgICAgIGZpcmVFdmVudDogdGhpcy5maXJlRXZlbnQuYmluZCh0aGlzQ2hhcnQpLFxuICAgICAgICBnZXQgcGVyZm9ybVVwZGF0ZVR5cGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNDaGFydC5wZXJmb3JtVXBkYXRlVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN0eCxcbiAgICAgIHRoaXMuZ2V0Q2hhcnRUeXBlKCksXG4gICAgICB0aGlzLnRvb2x0aXAsXG4gICAgICB0aGlzLmhpZ2hsaWdodCxcbiAgICAgIHRoaXMub3ZlcmxheXNcbiAgICApO1xuICAgIGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcInJvb3RcIiwgcm9vdCk7XG4gICAgdGhpcy5fZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1sb2FkXCIsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLmRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgfSksXG4gICAgICB0aGlzLnRpdGxlLnJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ29udGV4dCksXG4gICAgICB0aGlzLnN1YnRpdGxlLnJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ29udGV4dCksXG4gICAgICB0aGlzLmZvb3Rub3RlLnJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ29udGV4dCksXG4gICAgICBjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwicGFnZS1sZWZ0XCIsICgpID0+IHRoaXMuZGVzdHJveSgpKSxcbiAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLWZyYW1lXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGUoNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICAgICAgfSksXG4gICAgICBjdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VyaWVzLm1hcCgocykgPT4gcy5hbmltYXRpb25TdGF0ZT8udHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIikpO1xuICAgICAgICBjb25zdCBza2lwQW5pbWF0aW9ucyA9IHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSAhPT0gXCJpbml0aWFsXCI7XG4gICAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUsIHNraXBBbmltYXRpb25zIH0pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucGFyZW50UmVzaXplKGN0eC5kb21NYW5hZ2VyLmNvbnRhaW5lclNpemUpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50Mikge1xuICAgIHJldHVybiBfQ2hhcnQuY2hhcnRzSW5zdGFuY2VzLmdldChlbGVtZW50Mik7XG4gIH1cbiAgLyoqIE5PVEU6IFRoaXMgaXMgZXhwb3NlZCBmb3IgdXNlIGJ5IEludGVncmF0ZWQgY2hhcnRzIG9ubHkuICovXG4gIGdldCBjYW52YXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5zY2VuZS5jYW52YXMuZWxlbWVudDtcbiAgfVxuICBkb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCkge1xuICAgIHRoaXMuY3R4LnNjZW5lLmRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KTtcbiAgfVxuICBnZXRDYW52YXNEYXRhVVJMKGZpbGVGb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguc2NlbmUuZ2V0RGF0YVVSTChmaWxlRm9ybWF0KTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlZFVzZXJPcHRpb25zLmF0KC0xKSA/PyB0aGlzLmNoYXJ0T3B0aW9ucy51c2VyT3B0aW9ucztcbiAgfVxuICBnZXRNb2R1bGVDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN0eDtcbiAgfVxuICBnZXRDYXB0aW9uVGV4dCgpIHtcbiAgICByZXR1cm4gW3RoaXMudGl0bGUsIHRoaXMuc3VidGl0bGUsIHRoaXMuZm9vdG5vdGVdLmZpbHRlcigoY2FwdGlvbikgPT4gY2FwdGlvbi5lbmFibGVkICYmIGNhcHRpb24udGV4dCkubWFwKChjYXB0aW9uKSA9PiBjYXB0aW9uLnRleHQpLmpvaW4oXCIuIFwiKTtcbiAgfVxuICBnZXRBcmlhTGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFBbm5vdW5jZUNoYXJ0XCIsIHsgc2VyaWVzQ291bnQ6IHRoaXMuc2VyaWVzLmxlbmd0aCB9KTtcbiAgfVxuICByZXNldEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlID0gXCJpbml0aWFsXCI7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgdGhpcy5zZXJpZXMpIHtcbiAgICAgIHNlcmllcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBheGlzLnJlc2V0QW5pbWF0aW9uKHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnJlc2V0KCk7XG4gIH1cbiAgc2tpcEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KG9wdHMpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2VlcFRyYW5zZmVyYWJsZVJlc291cmNlcyA9IG9wdHM/LmtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gNyAvKiBOT05FICovO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIHRoaXMucHJvY2Vzc29ycy5mb3JFYWNoKChwKSA9PiBwLmRlc3Ryb3koKSk7XG4gICAgdGhpcy50b29sdGlwLmRlc3Ryb3kodGhpcy5jdHguZG9tTWFuYWdlcik7XG4gICAgdGhpcy5vdmVybGF5cy5kZXN0cm95KCk7XG4gICAgdGhpcy5tb2R1bGVzTWFuYWdlci5kZXN0cm95KCk7XG4gICAgaWYgKGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXMpIHtcbiAgICAgIHRoaXMuY3R4LnNjZW5lLnN0cmlwKCk7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgIHNjZW5lOiB0aGlzLmN0eC5zY2VuZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguc2NlbmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveVNlcmllcyh0aGlzLnNlcmllcyk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChhKSA9PiBhLmRlc3Ryb3koKSk7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuY3R4LmRlc3Ryb3koKTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlcXVlc3RGYWN0b3J5VXBkYXRlKGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50Kys7XG4gICAgdGhpcy51cGRhdGVNdXRleC5hY3F1aXJlKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXdhaXQgY2IodGhpcyk7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50LS07XG4gICAgfSkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICB9XG4gIHVwZGF0ZSh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSBmYWxzZSxcbiAgICAgIHNraXBBbmltYXRpb25zLFxuICAgICAgc2VyaWVzVG9VcGRhdGUgPSB0aGlzLnNlcmllcyxcbiAgICAgIG5ld0FuaW1hdGlvbkJhdGNoXG4gICAgfSA9IG9wdHMgPz8ge307XG4gICAgaWYgKGZvcmNlTm9kZURhdGFSZWZyZXNoKSB7XG4gICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHNlcmllcy5tYXJrTm9kZURhdGFEaXJ0eSgpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2Ygc2VyaWVzVG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUuYWRkKHNlcmllcyk7XG4gICAgfVxuICAgIGlmIChza2lwQW5pbWF0aW9ucykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmV3QW5pbWF0aW9uQmF0Y2ggJiYgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9za2lwU3luYyA9IG9wdHM/LnNraXBTeW5jID8/IGZhbHNlO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrID8/IFwiPHVua25vd24+XCI7XG4gICAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL1xcKFteKV0qL2csIFwiXCIpO1xuICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzW3N0YWNrXSA9IHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlIDwgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSkge1xuICAgICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLnBlcmZvcm1VcGRhdGVUcmlnZ2VyLnNjaGVkdWxlKG9wdHM/LmJhY2tPZmZNcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHBlcmZvcm1VcGRhdGUoY291bnQpIHtcbiAgICBjb25zdCB7IHBlcmZvcm1VcGRhdGVUeXBlLCBleHRyYURlYnVnU3RhdHMsIF9wZXJmb3JtVXBkYXRlU3BsaXRzOiBzcGxpdHMsIGN0eCB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpZXNUb1VwZGF0ZSA9IFsuLi50aGlzLnNlcmllc1RvVXBkYXRlXTtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gNyAvKiBOT05FICovO1xuICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUuY2xlYXIoKTtcbiAgICBpZiAodGhpcy51cGRhdGVTaG9ydGN1dENvdW50ID09PSAwICYmIHBlcmZvcm1VcGRhdGVUeXBlIDwgNiAvKiBTQ0VORV9SRU5ERVIgKi8pIHtcbiAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLnN0YXJ0QmF0Y2godGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zKTtcbiAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLm9uQmF0Y2hTdG9wKCgpID0+IHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwicmVhZHlcIik7XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBzdGFydFwiLCBDaGFydFVwZGF0ZVR5cGVbcGVyZm9ybVVwZGF0ZVR5cGVdKTtcbiAgICBsZXQgcHJldmlvdXNTcGxpdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHNwbGl0cy5zdGFydCA/PyAoc3BsaXRzLnN0YXJ0ID0gcHJldmlvdXNTcGxpdCk7XG4gICAgY29uc3QgdXBkYXRlU3BsaXRzID0gKHNwbGl0TmFtZSkgPT4ge1xuICAgICAgc3BsaXRzW3NwbGl0TmFtZV0gPz8gKHNwbGl0c1tzcGxpdE5hbWVdID0gMCk7XG4gICAgICBzcGxpdHNbc3BsaXROYW1lXSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByZXZpb3VzU3BsaXQ7XG4gICAgICBwcmV2aW91c1NwbGl0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgICBsZXQgdXBkYXRlRGVmZXJyZWQgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHBlcmZvcm1VcGRhdGVUeXBlKSB7XG4gICAgICBjYXNlIDAgLyogRlVMTCAqLzpcbiAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICAgIGNhc2UgMSAvKiBVUERBVEVfREFUQSAqLzpcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdTJCMDdcXHVGRTBGXCIpO1xuICAgICAgY2FzZSAyIC8qIFBST0NFU1NfREFUQSAqLzpcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyLmRhdGFDaGFuZ2VkKCk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdXsxRjNFRH1cIik7XG4gICAgICBjYXNlIDMgLyogUEVSRk9STV9MQVlPVVQgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0ZpcnN0QXV0b1NpemUoc2VyaWVzVG9VcGRhdGUpKSB7XG4gICAgICAgICAgdXBkYXRlRGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0xheW91dCgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHUyMzE2XCIpO1xuICAgICAgY2FzZSA0IC8qIFNFUklFU19VUERBVEUgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNCAvKiBTRVJJRVNfVVBEQVRFICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3QgeyBzZXJpZXNSZWN0IH0gPSB0aGlzO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzZXJpZXNUb1VwZGF0ZS5tYXAoKHNlcmllcykgPT4gc2VyaWVzLnVwZGF0ZSh7IHNlcmllc1JlY3QgfSkpKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1ezFGOTE0fVwiKTtcbiAgICAgIGNhc2UgNSAvKiBQUkVfU0NFTkVfUkVOREVSICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDUgLyogUFJFX1NDRU5FX1JFTkRFUiAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoUHJlU2NlbmVSZW5kZXIodGhpcy5nZXRNaW5SZWN0cygpKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1MjE5NlwiKTtcbiAgICAgIGNhc2UgNiAvKiBTQ0VORV9SRU5ERVIgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNiAvKiBTQ0VORV9SRU5ERVIgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5lbmRCYXRjaCgpO1xuICAgICAgICBleHRyYURlYnVnU3RhdHNbXCJ1cGRhdGVTaG9ydGN1dENvdW50XCJdID0gdGhpcy51cGRhdGVTaG9ydGN1dENvdW50O1xuICAgICAgICBhd2FpdCBjdHguc2NlbmUucmVuZGVyKHsgZGVidWdTcGxpdFRpbWVzOiBzcGxpdHMsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdDogdGhpcy5zZXJpZXNSZWN0IH0pO1xuICAgICAgICB0aGlzLmV4dHJhRGVidWdTdGF0cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzcGxpdHMpIHtcbiAgICAgICAgICBkZWxldGUgc3BsaXRzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5pbmNyZW1lbnREYXRhQ291bnRlcihcInNjZW5lUmVuZGVyc1wiKTtcbiAgICAgIGNhc2UgNyAvKiBOT05FICovOlxuICAgICAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIGlmICghdXBkYXRlRGVmZXJyZWQpIHtcbiAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoVXBkYXRlQ29tcGxldGUodGhpcy5nZXRNaW5SZWN0cygpKTtcbiAgICB9XG4gICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LnBlcmZvcm1VcGRhdGUoKSAtIGVuZFwiLCB7XG4gICAgICBjaGFydDogdGhpcyxcbiAgICAgIGR1cmF0aW9uTXM6IE1hdGgucm91bmQoKGVuZCAtIHNwbGl0c1tcInN0YXJ0XCJdKSAqIDEwMCkgLyAxMDAsXG4gICAgICBjb3VudCxcbiAgICAgIHBlcmZvcm1VcGRhdGVUeXBlOiBDaGFydFVwZGF0ZVR5cGVbcGVyZm9ybVVwZGF0ZVR5cGVdXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVGhlbWVDbGFzc05hbWUoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucztcbiAgICBjb25zdCB0aGVtZUNsYXNzTmFtZVByZWZpeCA9IFwiYWctY2hhcnRzLXRoZW1lLVwiO1xuICAgIGNvbnN0IHZhbGlkVGhlbWVDbGFzc05hbWVzID0gW2Ake3RoZW1lQ2xhc3NOYW1lUHJlZml4fWRlZmF1bHRgLCBgJHt0aGVtZUNsYXNzTmFtZVByZWZpeH1kZWZhdWx0LWRhcmtgXTtcbiAgICBsZXQgdGhlbWVDbGFzc05hbWUgPSB2YWxpZFRoZW1lQ2xhc3NOYW1lc1swXTtcbiAgICBsZXQgaXNEYXJrID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSB0aGVtZS5yZXBsYWNlKFwiYWctXCIsIHRoZW1lQ2xhc3NOYW1lUHJlZml4KTtcbiAgICAgIGlzRGFyayA9IHRoZW1lLmluY2x1ZGVzKFwiLWRhcmtcIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbWU/LmJhc2VUaGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSB0aGVtZS5iYXNlVGhlbWUucmVwbGFjZShcImFnLVwiLCB0aGVtZUNsYXNzTmFtZVByZWZpeCk7XG4gICAgICBpc0RhcmsgPSB0aGVtZS5iYXNlVGhlbWUuaW5jbHVkZXMoXCItZGFya1wiKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZFRoZW1lQ2xhc3NOYW1lcy5pbmNsdWRlcyh0aGVtZUNsYXNzTmFtZSkpIHtcbiAgICAgIHRoZW1lQ2xhc3NOYW1lID0gaXNEYXJrID8gdmFsaWRUaGVtZUNsYXNzTmFtZXNbMV0gOiB2YWxpZFRoZW1lQ2xhc3NOYW1lc1swXTtcbiAgICB9XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRUaGVtZUNsYXNzKHRoZW1lQ2xhc3NOYW1lKTtcbiAgfVxuICB1cGRhdGVET00oKSB7XG4gICAgdGhpcy51cGRhdGVUaGVtZUNsYXNzTmFtZSgpO1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgdGFiSW5kZXggfSA9IHRoaXMua2V5Ym9hcmQ7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRUYWJJbmRleChlbmFibGVkID8gdGFiSW5kZXggPz8gMCA6IC0xKTtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5jdHguc2NlbmUuY2FudmFzLmVsZW1lbnQsIFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5jdHguc2NlbmUuY2FudmFzLmVsZW1lbnQsIFwiYXJpYS1sYWJlbFwiLCB0aGlzLmdldEFyaWFMYWJlbCgpKTtcbiAgfVxuICBjaGVja1VwZGF0ZVNob3J0Y3V0KGNoZWNrVXBkYXRlVHlwZSkge1xuICAgIGNvbnN0IG1heFNob3J0Y3V0cyA9IDM7XG4gICAgaWYgKHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA+IG1heFNob3J0Y3V0cykge1xuICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgIGBleGNlZWRlZCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzIHVwZGF0ZXMgKCR7bWF4U2hvcnRjdXRzICsgMX0pLCBkaXNjYXJkaW5nIGNoYW5nZXMgYW5kIHJlbmRlcmluZ2AsXG4gICAgICAgIHRoaXMudXBkYXRlUmVxdWVzdG9yc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPD0gY2hlY2tVcGRhdGVUeXBlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQrKztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2hlY2tGaXJzdEF1dG9TaXplKHNlcmllc1RvVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fbGFzdEF1dG9TaXplKSB7XG4gICAgICBjb25zdCBjb3VudCA9IHRoaXMuX3BlcmZvcm1VcGRhdGVOb1JlbmRlckNvdW50Kys7XG4gICAgICBjb25zdCBiYWNrT2ZmTXMgPSAoY291bnQgKyAxKSAqKiAyICogNDA7XG4gICAgICBpZiAoY291bnQgPCA4KSB7XG4gICAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgc2VyaWVzVG9VcGRhdGUsIGJhY2tPZmZNcyB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LmNoZWNrRmlyc3RBdXRvU2l6ZSgpIC0gYmFja2luZyBvZmYgdW50aWwgZmlyc3Qgc2l6ZSB1cGRhdGVcIiwgYmFja09mZk1zKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LmNoZWNrRmlyc3RBdXRvU2l6ZSgpIC0gdGltZW91dCBmb3IgZmlyc3Qgc2l6ZSB1cGRhdGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmIChvbGRWYWx1ZSA9PSBudWxsICYmIG5ld1ZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmN0eC5heGlzTWFuYWdlci51cGRhdGVBeGVzKG9sZFZhbHVlID8/IFtdLCBuZXdWYWx1ZSk7XG4gIH1cbiAgb25TZXJpZXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3Qgc2VyaWVzVG9EZXN0cm95ID0gb2xkVmFsdWU/LmZpbHRlcigoc2VyaWVzKSA9PiAhbmV3VmFsdWUuaW5jbHVkZXMoc2VyaWVzKSkgPz8gW107XG4gICAgdGhpcy5kZXN0cm95U2VyaWVzKHNlcmllc1RvRGVzdHJveSk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXI/LnNldFNlcmllc0NvdW50KG5ld1ZhbHVlLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZT8uaW5jbHVkZXMoc2VyaWVzKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoc2VyaWVzLnJvb3RHcm91cC5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5yZXF1ZXN0R3JvdXAoc2VyaWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcztcbiAgICAgIHNlcmllcy5jaGFydCA9IHtcbiAgICAgICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0Lm1vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc01pbmlDaGFydCgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzZXJpZXNSZWN0KCkge1xuICAgICAgICAgIHJldHVybiBjaGFydC5zZXJpZXNSZWN0O1xuICAgICAgICB9LFxuICAgICAgICBwbGFjZUxhYmVscygpIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnQucGxhY2VMYWJlbHMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNlcmllcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgICAgdGhpcy5hZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKTtcbiAgICAgIHNlcmllcy5hZGRDaGFydEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuc2VyaWVzQXJlYU1hbmFnZXI/LnNlcmllc0NoYW5nZWQobmV3VmFsdWUpO1xuICB9XG4gIGRlc3Ryb3lTZXJpZXMoYWxsU2VyaWVzKSB7XG4gICAgYWxsU2VyaWVzPy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayk7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdyb3VwaW5nQ2hhbmdlZFwiLCB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCk7XG4gICAgICBzZXJpZXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIucmVsZWFzZUdyb3VwKHNlcmllcyk7XG4gICAgICBzZXJpZXMuY2hhcnQgPSB2b2lkIDA7XG4gICAgfSk7XG4gIH1cbiAgYWRkU2VyaWVzTGlzdGVuZXJzKHNlcmllcykge1xuICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJzZXJpZXNOb2RlQ2xpY2tcIikpIHtcbiAgICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwic2VyaWVzTm9kZURvdWJsZUNsaWNrXCIpKSB7XG4gICAgICBzZXJpZXMuYWRkRXZlbnRMaXN0ZW5lcihcIm5vZGVEb3VibGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcbiAgICB9XG4gICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJncm91cGluZ0NoYW5nZWRcIiwgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQpO1xuICB9XG4gIHVwZGF0ZUFsbFNlcmllc0xpc3RlbmVycygpIHtcbiAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayk7XG4gICAgICB0aGlzLmFkZFNlcmllc0xpc3RlbmVycyhzZXJpZXMpO1xuICAgIH0pO1xuICB9XG4gIGFzc2lnblNlcmllc1RvQXhlcygpIHtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy5ib3VuZFNlcmllcyA9IHRoaXMuc2VyaWVzLmZpbHRlcigocykgPT4ge1xuICAgICAgICBjb25zdCBzZXJpZXNBeGlzID0gcy5heGVzW2F4aXMuZGlyZWN0aW9uXTtcbiAgICAgICAgcmV0dXJuIHNlcmllc0F4aXMgPT09IGF4aXM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3NpZ25BeGVzVG9TZXJpZXMoKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uVG9BeGVzTWFwID0gZ3JvdXBCeSh0aGlzLmF4ZXMsIChheGlzKSA9PiBheGlzLmRpcmVjdGlvbik7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMuZGlyZWN0aW9ucy5mb3JFYWNoKChkaXJlY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uQXhlcyA9IGRpcmVjdGlvblRvQXhlc01hcFtkaXJlY3Rpb25dO1xuICAgICAgICBpZiAoIWRpcmVjdGlvbkF4ZXMpIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICBgbm8gYXZhaWxhYmxlIGF4aXMgZm9yIGRpcmVjdGlvbiBbJHtkaXJlY3Rpb259XTsgY2hlY2sgc2VyaWVzIGFuZCBheGVzIGNvbmZpZ3VyYXRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmllc0tleXMgPSBzZXJpZXMuZ2V0S2V5cyhkaXJlY3Rpb24pO1xuICAgICAgICBjb25zdCBuZXdBeGlzID0gZGlyZWN0aW9uQXhlcy5maW5kKFxuICAgICAgICAgIChheGlzKSA9PiAhYXhpcy5rZXlzLmxlbmd0aCB8fCBzZXJpZXNLZXlzLnNvbWUoKGtleSkgPT4gYXhpcy5rZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghbmV3QXhpcykge1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICAgIGBubyBtYXRjaGluZyBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV0gYW5kIGtleXMgWyR7c2VyaWVzS2V5c31dOyBjaGVjayBzZXJpZXMgYW5kIGF4ZXMgY29uZmlndXJhdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWVzLmF4ZXNbZGlyZWN0aW9uXSA9IG5ld0F4aXM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBwYXJlbnRSZXNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplID09IG51bGwgfHwgdGhpcy53aWR0aCAhPSBudWxsICYmIHRoaXMuaGVpZ2h0ICE9IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2l6ZTtcbiAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0KTtcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFthdXRvV2lkdGggPSAwLCBhdXRoSGVpZ2h0ID0gMF0gPSB0aGlzLl9sYXN0QXV0b1NpemUgPz8gW107XG4gICAgaWYgKGF1dG9XaWR0aCA9PT0gd2lkdGggJiYgYXV0aEhlaWdodCA9PT0gaGVpZ2h0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2xhc3RBdXRvU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLnJlc2l6ZShcIlNpemVNb25pdG9yXCIsIHt9KTtcbiAgfVxuICByZXNpemUoc291cmNlLCBvcHRzKSB7XG4gICAgY29uc3QgeyBzY2VuZSwgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBpbldpZHRoLCBpbkhlaWdodCwgaW5NaW5XaWR0aCwgaW5NaW5IZWlnaHQgfSA9IG9wdHM7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRTaXplT3B0aW9ucyhcbiAgICAgIGluTWluV2lkdGggPz8gdGhpcy5taW5XaWR0aCxcbiAgICAgIGluTWluSGVpZ2h0ID8/IHRoaXMubWluSGVpZ2h0LFxuICAgICAgaW5XaWR0aCA/PyB0aGlzLndpZHRoLFxuICAgICAgaW5IZWlnaHQgPz8gdGhpcy5oZWlnaHRcbiAgICApO1xuICAgIGNvbnN0IHdpZHRoID0gaW5XaWR0aCA/PyB0aGlzLndpZHRoID8/IHRoaXMuX2xhc3RBdXRvU2l6ZT8uWzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSGVpZ2h0ID8/IHRoaXMuaGVpZ2h0ID8/IHRoaXMuX2xhc3RBdXRvU2l6ZT8uWzFdO1xuICAgIHRoaXMuZGVidWcoYENoYXJ0LnJlc2l6ZSgpIGZyb20gJHtzb3VyY2V9YCwgeyB3aWR0aCwgaGVpZ2h0LCBzdGFjazogbmV3IEVycm9yKCkuc3RhY2sgfSk7XG4gICAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwgfHwgIWlzRmluaXRlTnVtYmVyKHdpZHRoKSB8fCAhaXNGaW5pdGVOdW1iZXIoaGVpZ2h0KSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc2NlbmUucmVzaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICBsZXQgc2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgaWYgKCh0aGlzLndpZHRoID09IG51bGwgfHwgdGhpcy5oZWlnaHQgPT0gbnVsbCkgJiYgdGhpcy5fZmlyc3RBdXRvU2l6ZSkge1xuICAgICAgICBza2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maXJzdEF1dG9TaXplID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZSgzIC8qIFBFUkZPUk1fTEFZT1VUICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlLCBza2lwQW5pbWF0aW9ucyB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0YSgpIHtcbiAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzKSA9PiBzLnNldENoYXJ0RGF0YSh0aGlzLmRhdGEpKTtcbiAgICBjb25zdCBtb2R1bGVQcm9taXNlcyA9IHRoaXMubW9kdWxlc01hbmFnZXIubWFwTW9kdWxlcygobSkgPT4gbS51cGRhdGVEYXRhPy4oeyBkYXRhOiB0aGlzLmRhdGEgfSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZVByb21pc2VzKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YSgpIHtcbiAgICBpZiAodGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy5jYW5IYXZlQXhlcykpIHtcbiAgICAgIHRoaXMuYXNzaWduQXhlc1RvU2VyaWVzKCk7XG4gICAgICBjb25zdCBzeW5jTW9kdWxlID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJzeW5jXCIpO1xuICAgICAgaWYgKHN5bmNNb2R1bGU/LmVuYWJsZWQpIHtcbiAgICAgICAgc3luY01vZHVsZS5zeW5jQXhlcyh0aGlzLl9za2lwU3luYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFzc2lnblNlcmllc1RvQXhlcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhQ29udHJvbGxlciA9IG5ldyBEYXRhQ29udHJvbGxlcih0aGlzLm1vZGUpO1xuICAgIGNvbnN0IHNlcmllc1Byb21pc2VzID0gdGhpcy5zZXJpZXMubWFwKChzKSA9PiBzLnByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSk7XG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1hcE1vZHVsZXMoKG0pID0+IG0ucHJvY2Vzc0RhdGE/Lih7IGRhdGFDb250cm9sbGVyIH0pKTtcbiAgICBkYXRhQ29udHJvbGxlci5leGVjdXRlKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLnNlcmllc1Byb21pc2VzLCAuLi5tb2R1bGVQcm9taXNlc10pO1xuICAgIGZvciAoY29uc3QgeyBsZWdlbmRUeXBlLCBsZWdlbmQgfSBvZiB0aGlzLm1vZHVsZXNNYW5hZ2VyLmxlZ2VuZHMoKSkge1xuICAgICAgbGVnZW5kLmRhdGEgPSB0aGlzLmdldExlZ2VuZERhdGEobGVnZW5kVHlwZSwgdGhpcy5tb2RlICE9PSBcImludGVncmF0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuZGF0YVByb2Nlc3NMaXN0ZW5lcnMuZm9yRWFjaCgocmVzb2x2ZSkgPT4gcmVzb2x2ZSgpKTtcbiAgICB0aGlzLmRhdGFQcm9jZXNzTGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbiAgcGxhY2VMYWJlbHMoKSB7XG4gICAgY29uc3QgdmlzaWJsZVNlcmllcyA9IFtdO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiB0aGlzLnNlcmllcykge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBsYWJlbERhdGEgPSBzZXJpZXMuZ2V0TGFiZWxEYXRhKCk7XG4gICAgICBpZiAoaXNQb2ludExhYmVsRGF0dW0obGFiZWxEYXRhPy5bMF0pKSB7XG4gICAgICAgIGRhdGEucHVzaChsYWJlbERhdGEpO1xuICAgICAgICB2aXNpYmxlU2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBzZXJpZXNSZWN0IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IH0gPSB0aGlzLnNlcmllc0FyZWEucGFkZGluZztcbiAgICBjb25zdCBsYWJlbHMgPSBzZXJpZXNSZWN0ICYmIGRhdGEubGVuZ3RoID4gMCA/IHBsYWNlTGFiZWxzKGRhdGEsIHtcbiAgICAgIHg6IC1sZWZ0LFxuICAgICAgeTogLXRvcCxcbiAgICAgIHdpZHRoOiBzZXJpZXNSZWN0LndpZHRoICsgbGVmdCArIHJpZ2h0LFxuICAgICAgaGVpZ2h0OiBzZXJpZXNSZWN0LmhlaWdodCArIHRvcCArIGJvdHRvbVxuICAgIH0pIDogW107XG4gICAgcmV0dXJuIG5ldyBNYXAobGFiZWxzLm1hcCgobCwgaSkgPT4gW3Zpc2libGVTZXJpZXNbaV0sIGxdKSk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlLCB3YXJuQ29uZmxpY3RzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHMpID0+IHMucHJvcGVydGllcy5zaG93SW5MZWdlbmQpLmZsYXRNYXAoKHMpID0+IHMuZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSk7XG4gICAgY29uc3QgaXNDYXRlZ29yeUxlZ2VuZERhdGEgPSAoZGF0YSkgPT4gZGF0YS5ldmVyeSgoZCkgPT4gZC5sZWdlbmRUeXBlID09PSBcImNhdGVnb3J5XCIpO1xuICAgIGlmICh3YXJuQ29uZmxpY3RzICYmIGlzQ2F0ZWdvcnlMZWdlbmREYXRhKGxlZ2VuZERhdGEpKSB7XG4gICAgICBjb25zdCBzZXJpZXNNYXJrZXJGaWxscyA9IHt9O1xuICAgICAgY29uc3Qgc2VyaWVzVHlwZU1hcCA9IG5ldyBNYXAodGhpcy5zZXJpZXMubWFwKChzKSA9PiBbcy5pZCwgcy50eXBlXSkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBzeW1ib2xzOiBbeyBtYXJrZXIgfV0sXG4gICAgICAgIGxhYmVsXG4gICAgICB9IG9mIGxlZ2VuZERhdGEpIHtcbiAgICAgICAgaWYgKG1hcmtlci5maWxsID09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gc2VyaWVzVHlwZU1hcC5nZXQoc2VyaWVzSWQpO1xuICAgICAgICBjb25zdCBtYXJrZXJGaWxsID0gc2VyaWVzTWFya2VyRmlsbHNbc2VyaWVzVHlwZTJdID8/IChzZXJpZXNNYXJrZXJGaWxsc1tzZXJpZXNUeXBlMl0gPSB7fSk7XG4gICAgICAgIG1hcmtlckZpbGxbX2EgPSBsYWJlbC50ZXh0XSA/PyAobWFya2VyRmlsbFtfYV0gPSBtYXJrZXIuZmlsbCk7XG4gICAgICAgIGlmIChtYXJrZXJGaWxsW2xhYmVsLnRleHRdICE9PSBtYXJrZXIuZmlsbCkge1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICAgIGBsZWdlbmQgaXRlbSAnJHtsYWJlbC50ZXh0fScgaGFzIG11bHRpcGxlIGZpbGwgY29sb3JzLCB0aGlzIG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kRGF0YTtcbiAgfVxuICBhc3luYyBwcm9jZXNzTGF5b3V0KCkge1xuICAgIGNvbnN0IG9sZFJlY3QgPSB0aGlzLmFuaW1hdGlvblJlY3Q7XG4gICAgYXdhaXQgdGhpcy5wZXJmb3JtTGF5b3V0KCk7XG4gICAgaWYgKG9sZFJlY3QgJiYgIXRoaXMuYW5pbWF0aW9uUmVjdD8uZXF1YWxzKG9sZFJlY3QpKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LnBlcmZvcm1VcGRhdGUoKSAtIHNlcmllc1JlY3RcIiwgdGhpcy5zZXJpZXNSZWN0KTtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5jdHguc2NlbmU7XG4gICAgbGV0IGN0eCA9IHsgc2hyaW5rUmVjdDogbmV3IEJCb3goMCwgMCwgd2lkdGgsIGhlaWdodCksIHBvc2l0aW9uczoge30sIHBhZGRpbmc6IHt9IH07XG4gICAgY3R4ID0gdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaFBlcmZvcm1MYXlvdXQoXCJzdGFydC1sYXlvdXRcIiwgY3R4KTtcbiAgICBjdHggPSB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoUGVyZm9ybUxheW91dChcImJlZm9yZS1zZXJpZXNcIiwgY3R4KTtcbiAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5tb2R1bGVzTWFuYWdlci5tb2R1bGVzKCkpIHtcbiAgICAgIGlmIChtLnBlcmZvcm1MYXlvdXQgIT0gbnVsbCkge1xuICAgICAgICBjdHggPSBhd2FpdCBtLnBlcmZvcm1MYXlvdXQoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0eC5zaHJpbmtSZWN0O1xuICB9XG4gIGFzeW5jIHdhaXRGb3JVcGRhdGUodGltZW91dE1zID0gMWU0LCBmYWlsT25UaW1lb3V0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTXV0ZXgud2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCk7XG4gICAgfVxuICAgIHdoaWxlICh0aGlzLnBlcmZvcm1VcGRhdGVUeXBlICE9PSA3IC8qIE5PTkUgKi8pIHtcbiAgICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dE1zKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ2hhcnQud2FpdEZvclVwZGF0ZSgpIHRpbWVvdXQgb2YgJHt0aW1lb3V0TXN9IHJlYWNoZWQgLSBmaXJzdCBjaGFydCB1cGRhdGUgdGFraW5nIHRvbyBsb25nLmA7XG4gICAgICAgIGlmIChmYWlsT25UaW1lb3V0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgc2xlZXAoNTApO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU11dGV4LndhaXRGb3JDbGVhckFjcXVpcmVRdWV1ZSgpO1xuICB9XG4gIHdhaXRGb3JEYXRhUHJvY2Vzcyh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmRhdGFQcm9jZXNzTGlzdGVuZXJzLmFkZChyZXNvbHZlKTtcbiAgICAgIGlmIChpc051bWJlcih0aW1lb3V0KSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kYXRhUHJvY2Vzc0xpc3RlbmVycy5oYXMocmVzb2x2ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb2Nlc3NMaXN0ZW5lcnMuZGVsZXRlKHJlc29sdmUpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TWluUmVjdHMoKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmN0eC5zY2VuZTtcbiAgICBjb25zdCBtaW5SZWN0cyA9IHRoaXMuc2VyaWVzLm1hcCgoc2VyaWVzKSA9PiBzZXJpZXMuZ2V0TWluUmVjdHMod2lkdGgsIGhlaWdodCkpLmZpbHRlcihpc0RlZmluZWQpO1xuICAgIGlmIChtaW5SZWN0cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBsZXQgbWF4VmlzaWJsZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4VmlzaWJsZUhlaWdodCA9IDA7XG4gICAgZm9yIChjb25zdCB7IG1pblJlY3Q6IG1pblJlY3QyLCBtaW5WaXNpYmxlUmVjdDogbWluVmlzaWJsZVJlY3QyIH0gb2YgbWluUmVjdHMpIHtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIG1pblJlY3QyLndpZHRoKTtcbiAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgbWluUmVjdDIuaGVpZ2h0KTtcbiAgICAgIG1heFZpc2libGVXaWR0aCA9IE1hdGgubWF4KG1heFZpc2libGVXaWR0aCwgbWluVmlzaWJsZVJlY3QyLndpZHRoKTtcbiAgICAgIG1heFZpc2libGVIZWlnaHQgPSBNYXRoLm1heChtYXhWaXNpYmxlSGVpZ2h0LCBtaW5WaXNpYmxlUmVjdDIuaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbWluUmVjdCA9IG5ldyBCQm94KDAsIDAsIG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuICAgIGxldCBtaW5WaXNpYmxlUmVjdCA9IG1pblJlY3QuY2xvbmUoKTtcbiAgICBpZiAobWF4VmlzaWJsZVdpZHRoID4gMCAmJiBtYXhWaXNpYmxlSGVpZ2h0ID4gMCkge1xuICAgICAgbWluVmlzaWJsZVJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhWaXNpYmxlV2lkdGgsIG1heFZpc2libGVIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4geyBtaW5SZWN0LCBtaW5WaXNpYmxlUmVjdCB9O1xuICB9XG4gIGZpbHRlck1pbmlDaGFydFNlcmllcyhzZXJpZXMpIHtcbiAgICByZXR1cm4gc2VyaWVzPy5maWx0ZXIoKHMpID0+IHMuc2hvd0luTWluaUNoYXJ0ICE9PSBmYWxzZSk7XG4gIH1cbiAgYXBwbHlPcHRpb25zKG5ld0NoYXJ0T3B0aW9ucykge1xuICAgIGNvbnN0IGlzRGlmZmVyZW50T3B0cyA9IG5ld0NoYXJ0T3B0aW9ucyAhPT0gdGhpcy5jaGFydE9wdGlvbnM7XG4gICAgY29uc3Qgb2xkT3B0cyA9IGlzRGlmZmVyZW50T3B0cyA/IHRoaXMuY2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBuZXdPcHRzID0gbmV3Q2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnM7XG4gICAgY29uc3QgZGVsdGFPcHRpb25zID0gbmV3Q2hhcnRPcHRpb25zLmRpZmZPcHRpb25zKG9sZE9wdHMpO1xuICAgIGlmIChkZWx0YU9wdGlvbnMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBkZWJ1ZyhcIkNoYXJ0LmFwcGx5T3B0aW9ucygpIC0gYXBwbHlpbmcgZGVsdGFcIiwgZGVsdGFPcHRpb25zKTtcbiAgICBjb25zdCBtb2R1bGVzQ2hhbmdlZCA9IHRoaXMuYXBwbHlNb2R1bGVzKG5ld09wdHMpO1xuICAgIGNvbnN0IHNraXAgPSBbXG4gICAgICBcInR5cGVcIixcbiAgICAgIFwiZGF0YVwiLFxuICAgICAgXCJzZXJpZXNcIixcbiAgICAgIFwibGlzdGVuZXJzXCIsXG4gICAgICBcInByZXNldFwiLFxuICAgICAgXCJ0aGVtZVwiLFxuICAgICAgXCJsZWdlbmQubGlzdGVuZXJzXCIsXG4gICAgICBcIm5hdmlnYXRvci5taW5pQ2hhcnQuc2VyaWVzXCIsXG4gICAgICBcIm5hdmlnYXRvci5taW5pQ2hhcnQubGFiZWxcIixcbiAgICAgIFwibG9jYWxlLmxvY2FsZVRleHRcIixcbiAgICAgIFwiYXhlc1wiLFxuICAgICAgXCJ0b3BvbG9neVwiLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgXCJpbml0aWFsU3RhdGVcIlxuICAgIF07XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgZGVsdGFPcHRpb25zLmxpc3RlbmVycyk7XG4gICAgfVxuICAgIGpzb25BcHBseSh0aGlzLCBkZWx0YU9wdGlvbnMsIHsgc2tpcCB9KTtcbiAgICBsZXQgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgICBsZXQgc2VyaWVzU3RhdHVzID0gXCJuby1vcFwiO1xuICAgIGlmIChkZWx0YU9wdGlvbnMuc2VyaWVzICE9IG51bGwpIHtcbiAgICAgIHNlcmllc1N0YXR1cyA9IHRoaXMuYXBwbHlTZXJpZXModGhpcywgZGVsdGFPcHRpb25zLnNlcmllcywgb2xkT3B0cz8uc2VyaWVzKTtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNlcmllc1N0YXR1cyA9PT0gXCJyZXBsYWNlZFwiKSB7XG4gICAgICB0aGlzLnJlc2V0QW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcHBseUF4ZXModGhpcywgbmV3T3B0cywgb2xkT3B0cywgc2VyaWVzU3RhdHVzLCBbXSwgdHJ1ZSkpIHtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkZWx0YU9wdGlvbnMuZGF0YTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5sZWdlbmQ/Lmxpc3RlbmVycyAmJiB0aGlzLm1vZHVsZXNNYW5hZ2VyLmlzRW5hYmxlZChcImxlZ2VuZFwiKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmxlZ2VuZC5saXN0ZW5lcnMsIGRlbHRhT3B0aW9ucy5sZWdlbmQubGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMudXBkYXRlQWxsU2VyaWVzTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubG9jYWxlPy5sb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcImxvY2FsZVwiKS5sb2NhbGVUZXh0ID0gZGVsdGFPcHRpb25zLmxvY2FsZT8ubG9jYWxlVGV4dDtcbiAgICB9XG4gICAgdGhpcy5jaGFydE9wdGlvbnMgPSBuZXdDaGFydE9wdGlvbnM7XG4gICAgY29uc3QgbmF2aWdhdG9yTW9kdWxlID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJuYXZpZ2F0b3JcIik7XG4gICAgY29uc3Qgem9vbU1vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwiem9vbVwiKTtcbiAgICBpZiAoIW5hdmlnYXRvck1vZHVsZT8uZW5hYmxlZCAmJiAhem9vbU1vZHVsZT8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcImNoYXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBtaW5pQ2hhcnQgPSBuYXZpZ2F0b3JNb2R1bGU/Lm1pbmlDaGFydDtcbiAgICBjb25zdCBtaW5pQ2hhcnRTZXJpZXMgPSBuZXdPcHRzLm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXMgPz8gbmV3T3B0cy5zZXJpZXM7XG4gICAgaWYgKG1pbmlDaGFydD8uZW5hYmxlZCA9PT0gdHJ1ZSAmJiBtaW5pQ2hhcnRTZXJpZXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBseU1pbmlDaGFydE9wdGlvbnMobWluaUNoYXJ0LCBtaW5pQ2hhcnRTZXJpZXMsIG5ld09wdHMsIG9sZE9wdHMpO1xuICAgIH0gZWxzZSBpZiAobWluaUNoYXJ0Py5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgbWluaUNoYXJ0LnNlcmllcyA9IFtdO1xuICAgICAgbWluaUNoYXJ0LmF4ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jdHguYW5ub3RhdGlvbk1hbmFnZXIuc2V0QW5ub3RhdGlvblN0eWxlcyhuZXdDaGFydE9wdGlvbnMuYW5ub3RhdGlvblRoZW1lcyk7XG4gICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggfHwgKGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdGhpcy5zaG91bGRGb3JjZU5vZGVEYXRhUmVmcmVzaChkZWx0YU9wdGlvbnMsIHNlcmllc1N0YXR1cykpO1xuICAgIGNvbnN0IG1ham9yQ2hhbmdlID0gZm9yY2VOb2RlRGF0YVJlZnJlc2ggfHwgbW9kdWxlc0NoYW5nZWQ7XG4gICAgY29uc3QgdXBkYXRlVHlwZSA9IG1ham9yQ2hhbmdlID8gMCAvKiBGVUxMICovIDogMyAvKiBQRVJGT1JNX0xBWU9VVCAqLztcbiAgICB0aGlzLm1heWJlUmVzZXRBbmltYXRpb25zKHNlcmllc1N0YXR1cyk7XG4gICAgZGVidWcoXCJDaGFydC5hcHBseU9wdGlvbnMoKSAtIHVwZGF0ZSB0eXBlXCIsIENoYXJ0VXBkYXRlVHlwZVt1cGRhdGVUeXBlXSwge1xuICAgICAgc2VyaWVzU3RhdHVzLFxuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2hcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZSh1cGRhdGVUeXBlLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoLCBuZXdBbmltYXRpb25CYXRjaDogdHJ1ZSB9KTtcbiAgICBpZiAoZGVsdGFPcHRpb25zLmluaXRpYWxTdGF0ZSkge1xuICAgICAgdGhpcy5hcHBseUluaXRpYWxTdGF0ZShuZXdDaGFydE9wdGlvbnMudXNlck9wdGlvbnMuaW5pdGlhbFN0YXRlKTtcbiAgICB9XG4gIH1cbiAgYXBwbHlJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGFubm90YXRpb25NYW5hZ2VyLCBzdGF0ZU1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpbml0aWFsU3RhdGU/LmFubm90YXRpb25zICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGFubm90YXRpb25zMiA9IGluaXRpYWxTdGF0ZS5hbm5vdGF0aW9ucy5tYXAoKGFubm90YXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvblRoZW1lID0gYW5ub3RhdGlvbk1hbmFnZXIuZ2V0QW5ub3RhdGlvblR5cGVTdHlsZXMoYW5ub3RhdGlvbi50eXBlKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoYW5ub3RhdGlvbiwgYW5ub3RhdGlvblRoZW1lKTtcbiAgICAgIH0pO1xuICAgICAgc3RhdGVNYW5hZ2VyLnNldFN0YXRlKGFubm90YXRpb25NYW5hZ2VyLCBhbm5vdGF0aW9uczIpO1xuICAgIH1cbiAgfVxuICBtYXliZVJlc2V0QW5pbWF0aW9ucyhzZXJpZXNTdGF0dXMpIHtcbiAgICBpZiAodGhpcy5tb2RlICE9PSBcInN0YW5kYWxvbmVcIilcbiAgICAgIHJldHVybjtcbiAgICBzd2l0Y2ggKHNlcmllc1N0YXR1cykge1xuICAgICAgY2FzZSBcInNlcmllcy1ncm91cGluZy1jaGFuZ2VcIjpcbiAgICAgIGNhc2UgXCJyZXBsYWNlZFwiOlxuICAgICAgICB0aGlzLnJlc2V0QW5pbWF0aW9ucygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG4gIHNob3VsZEZvcmNlTm9kZURhdGFSZWZyZXNoKGRlbHRhT3B0aW9ucywgc2VyaWVzU3RhdHVzKSB7XG4gICAgY29uc3Qgc2VyaWVzRGF0YVVwZGF0ZSA9ICEhZGVsdGFPcHRpb25zLmRhdGEgfHwgc2VyaWVzU3RhdHVzID09PSBcImRhdGEtY2hhbmdlXCIgfHwgc2VyaWVzU3RhdHVzID09PSBcInJlcGxhY2VkXCI7XG4gICAgY29uc3QgbGVnZW5kS2V5cyA9IGxlZ2VuZFJlZ2lzdHJ5LmdldEtleXMoKTtcbiAgICBjb25zdCBvcHRpb25zSGF2ZUxlZ2VuZCA9IE9iamVjdC52YWx1ZXMobGVnZW5kS2V5cykuc29tZShcbiAgICAgIChsZWdlbmRLZXkpID0+IGRlbHRhT3B0aW9uc1tsZWdlbmRLZXldICE9IG51bGxcbiAgICApO1xuICAgIGNvbnN0IG90aGVyUmVmcmVzaFVwZGF0ZSA9IGRlbHRhT3B0aW9ucy50aXRsZSAhPSBudWxsICYmIGRlbHRhT3B0aW9ucy5zdWJ0aXRsZSAhPSBudWxsO1xuICAgIHJldHVybiBzZXJpZXNEYXRhVXBkYXRlIHx8IG9wdGlvbnNIYXZlTGVnZW5kIHx8IG90aGVyUmVmcmVzaFVwZGF0ZTtcbiAgfVxuICBhcHBseU1pbmlDaGFydE9wdGlvbnMobWluaUNoYXJ0LCBtaW5pQ2hhcnRTZXJpZXMsIGNvbXBsZXRlT3B0aW9ucywgb2xkT3B0cykge1xuICAgIGNvbnN0IG9sZFNlcmllcyA9IG9sZE9wdHM/Lm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXMgPz8gb2xkT3B0cz8uc2VyaWVzO1xuICAgIGNvbnN0IG1pbmlDaGFydFNlcmllc1N0YXR1cyA9IHRoaXMuYXBwbHlTZXJpZXMoXG4gICAgICBtaW5pQ2hhcnQsXG4gICAgICB0aGlzLmZpbHRlck1pbmlDaGFydFNlcmllcyhtaW5pQ2hhcnRTZXJpZXMpLFxuICAgICAgdGhpcy5maWx0ZXJNaW5pQ2hhcnRTZXJpZXMob2xkU2VyaWVzKVxuICAgICk7XG4gICAgdGhpcy5hcHBseUF4ZXMobWluaUNoYXJ0LCBjb21wbGV0ZU9wdGlvbnMsIG9sZE9wdHMsIG1pbmlDaGFydFNlcmllc1N0YXR1cywgW1xuICAgICAgXCJheGVzW10udGlja1wiLFxuICAgICAgXCJheGVzW10udGhpY2tuZXNzXCIsXG4gICAgICBcImF4ZXNbXS50aXRsZVwiLFxuICAgICAgXCJheGVzW10uY3Jvc3NoYWlyXCIsXG4gICAgICBcImF4ZXNbXS5ncmlkTGluZVwiLFxuICAgICAgXCJheGVzW10ubGFiZWxcIlxuICAgIF0pO1xuICAgIGNvbnN0IGF4ZXMgPSBtaW5pQ2hhcnQuYXhlcztcbiAgICBjb25zdCBob3Jpem9udGFsQXhpcyA9IGF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICBheGlzLmdyaWRMaW5lLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGF4aXMubGFiZWwuZW5hYmxlZCA9IGF4aXMgPT09IGhvcml6b250YWxBeGlzO1xuICAgICAgYXhpcy50aWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGF4aXMuaW50ZXJhY3Rpb25FbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChob3Jpem9udGFsQXhpcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBtaW5pQ2hhcnRPcHRzID0gY29tcGxldGVPcHRpb25zLm5hdmlnYXRvcj8ubWluaUNoYXJ0O1xuICAgICAgY29uc3QgbGFiZWxPcHRpb25zID0gbWluaUNoYXJ0T3B0cz8ubGFiZWw7XG4gICAgICBjb25zdCBpbnRlcnZhbE9wdGlvbnMgPSBtaW5pQ2hhcnRPcHRzPy5sYWJlbD8uaW50ZXJ2YWw7XG4gICAgICBob3Jpem9udGFsQXhpcy5saW5lLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGhvcml6b250YWxBeGlzLmxhYmVsLnNldChcbiAgICAgICAgd2l0aG91dChsYWJlbE9wdGlvbnMsIFtcImludGVydmFsXCIsIFwicm90YXRpb25cIiwgXCJtaW5TcGFjaW5nXCIsIFwiYXV0b1JvdGF0ZVwiLCBcImF1dG9Sb3RhdGVBbmdsZVwiXSlcbiAgICAgICk7XG4gICAgICBob3Jpem9udGFsQXhpcy50aWNrLnNldChcbiAgICAgICAgd2l0aG91dChpbnRlcnZhbE9wdGlvbnMsIFtcImVuYWJsZWRcIiwgXCJ3aWR0aFwiLCBcInNpemVcIiwgXCJjb2xvclwiLCBcImludGVydmFsXCIsIFwic3RlcFwiXSlcbiAgICAgICk7XG4gICAgICBjb25zdCBzdGVwID0gaW50ZXJ2YWxPcHRpb25zPy5zdGVwO1xuICAgICAgaWYgKHN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBob3Jpem9udGFsQXhpcy5pbnRlcnZhbC5zdGVwID0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXBwbHlNb2R1bGVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHR5cGU6IGNoYXJ0VHlwZTIgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgbGV0IG1vZHVsZXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlUmVnaXN0cnkuYnlUeXBlKFwicm9vdFwiLCBcImxlZ2VuZFwiKSkge1xuICAgICAgY29uc3QgaXNDb25maWd1cmVkID0gb3B0aW9uc1ttb2R1bGUub3B0aW9uc0tleV0gIT0gbnVsbDtcbiAgICAgIGNvbnN0IHNob3VsZEJlRW5hYmxlZCA9IGlzQ29uZmlndXJlZCAmJiBtb2R1bGUuY2hhcnRUeXBlcy5pbmNsdWRlcyhjaGFydFR5cGUyKTtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQgPT09IHRoaXMubW9kdWxlc01hbmFnZXIuaXNFbmFibGVkKG1vZHVsZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCkge1xuICAgICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmFkZE1vZHVsZShtb2R1bGUsIChtKSA9PiBtLm1vZHVsZUZhY3RvcnkodGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpKTtcbiAgICAgICAgaWYgKG1vZHVsZS50eXBlID09PSBcImxlZ2VuZFwiKSB7XG4gICAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUobW9kdWxlKT8uYXR0YWNoTGVnZW5kKHRoaXMuY3R4LnNjZW5lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW21vZHVsZS5vcHRpb25zS2V5XSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKG1vZHVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLnJlbW92ZU1vZHVsZShtb2R1bGUpO1xuICAgICAgICBkZWxldGUgdGhpc1ttb2R1bGUub3B0aW9uc0tleV07XG4gICAgICB9XG4gICAgICBtb2R1bGVzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtb2R1bGVzQ2hhbmdlZDtcbiAgfVxuICBhcHBseVNlcmllcyhjaGFydCwgb3B0U2VyaWVzLCBvbGRPcHRTZXJpZXMpIHtcbiAgICBpZiAoIW9wdFNlcmllcykge1xuICAgICAgcmV0dXJuIFwibm8tY2hhbmdlXCI7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gbWF0Y2hTZXJpZXNPcHRpb25zKGNoYXJ0LnNlcmllcywgb3B0U2VyaWVzLCBvbGRPcHRTZXJpZXMpO1xuICAgIGlmIChtYXRjaFJlc3VsdC5zdGF0dXMgPT09IFwibm8tb3ZlcmxhcFwiKSB7XG4gICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIGNyZWF0aW5nIG5ldyBzZXJpZXMgaW5zdGFuY2VzLCBzdGF0dXM6ICR7bWF0Y2hSZXN1bHQuc3RhdHVzfWAsIG1hdGNoUmVzdWx0KTtcbiAgICAgIGNoYXJ0LnNlcmllcyA9IG9wdFNlcmllcy5tYXAoKG9wdHMpID0+IHRoaXMuY3JlYXRlU2VyaWVzKG9wdHMpKTtcbiAgICAgIHJldHVybiBcInJlcGxhY2VkXCI7XG4gICAgfVxuICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gbWF0Y2hSZXN1bHRgLCBtYXRjaFJlc3VsdCk7XG4gICAgY29uc3Qgc2VyaWVzSW5zdGFuY2VzID0gW107XG4gICAgbGV0IGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IGdyb3VwaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGxldCBpc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBtYXRjaFJlc3VsdC5jaGFuZ2VzKSB7XG4gICAgICBncm91cGluZ0NoYW5nZWQgfHwgKGdyb3VwaW5nQ2hhbmdlZCA9IGNoYW5nZS5zdGF0dXMgPT09IFwic2VyaWVzLWdyb3VwaW5nXCIpO1xuICAgICAgZGF0YUNoYW5nZWQgfHwgKGRhdGFDaGFuZ2VkID0gY2hhbmdlLmRpZmY/LmRhdGEgIT0gbnVsbCk7XG4gICAgICBpc1VwZGF0ZWQgfHwgKGlzVXBkYXRlZCA9IGNoYW5nZS5zdGF0dXMgIT09IFwibm8tb3BcIik7XG4gICAgICBzd2l0Y2ggKGNoYW5nZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGNvbnN0IG5ld1NlcmllcyA9IHRoaXMuY3JlYXRlU2VyaWVzKGNoYW5nZS5vcHRzKTtcbiAgICAgICAgICBzZXJpZXNJbnN0YW5jZXMucHVzaChuZXdTZXJpZXMpO1xuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gY3JlYXRlZCBuZXcgc2VyaWVzYCwgbmV3U2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gcmVtb3Zpbmcgc2VyaWVzIGF0IHByZXZpb3VzIGlkeCAke2NoYW5nZS5pZHh9YCwgY2hhbmdlLnNlcmllcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuby1vcFwiOlxuICAgICAgICAgIHNlcmllc0luc3RhbmNlcy5wdXNoKGNoYW5nZS5zZXJpZXMpO1xuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gbm8gY2hhbmdlIHRvIHNlcmllcyBhdCBwcmV2aW91cyBpZHggJHtjaGFuZ2UuaWR4fWAsIGNoYW5nZS5zZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2VyaWVzLWdyb3VwaW5nXCI6XG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zdCB7IHNlcmllcywgZGlmZjogZGlmZjIsIGlkeCB9ID0gY2hhbmdlO1xuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gYXBwbHlpbmcgc2VyaWVzIGRpZmYgcHJldmlvdXMgaWR4ICR7aWR4fWAsIGRpZmYyLCBzZXJpZXMpO1xuICAgICAgICAgIHRoaXMuYXBwbHlTZXJpZXNWYWx1ZXMoc2VyaWVzLCBkaWZmMik7XG4gICAgICAgICAgc2VyaWVzLm1hcmtOb2RlRGF0YURpcnR5KCk7XG4gICAgICAgICAgc2VyaWVzSW5zdGFuY2VzLnB1c2goc2VyaWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VyaWVzSW5zdGFuY2VzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHNlcmllc0luc3RhbmNlc1tpZHhdLl9kZWNsYXJhdGlvbk9yZGVyID0gaWR4O1xuICAgIH1cbiAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIGZpbmFsIHNlcmllcyBpbnN0YW5jZXNgLCBzZXJpZXNJbnN0YW5jZXMpO1xuICAgIGNoYXJ0LnNlcmllcyA9IHNlcmllc0luc3RhbmNlcztcbiAgICBpZiAoZ3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gXCJzZXJpZXMtZ3JvdXBpbmctY2hhbmdlXCI7XG4gICAgfVxuICAgIGlmIChkYXRhQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIFwiZGF0YS1jaGFuZ2VcIjtcbiAgICB9XG4gICAgcmV0dXJuIGlzVXBkYXRlZCA/IFwidXBkYXRlZFwiIDogXCJuby1vcFwiO1xuICB9XG4gIGFwcGx5QXhlcyhjaGFydCwgb3B0aW9ucywgb2xkT3B0cywgc2VyaWVzU3RhdHVzLCBza2lwID0gW10sIHJlZ2lzdGVyUmVnaW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykgfHwgIW9wdGlvbnMuYXhlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBza2lwID0gW1wiYXhlc1tdLnR5cGVcIiwgLi4uc2tpcF07XG4gICAgY29uc3QgeyBheGVzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGZvcmNlUmVjcmVhdGUgPSBzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIjtcbiAgICBjb25zdCBtYXRjaGluZ1R5cGVzID0gIWZvcmNlUmVjcmVhdGUgJiYgY2hhcnQuYXhlcy5sZW5ndGggPT09IGF4ZXMubGVuZ3RoICYmIGNoYXJ0LmF4ZXMuZXZlcnkoKGEsIGkpID0+IGEudHlwZSA9PT0gYXhlc1tpXS50eXBlKTtcbiAgICBpZiAobWF0Y2hpbmdUeXBlcyAmJiBpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9sZE9wdHMpKSB7XG4gICAgICBjaGFydC5heGVzLmZvckVhY2goKGF4aXMsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzT3B0cyA9IG9sZE9wdHMuYXhlcz8uW2luZGV4XSA/PyB7fTtcbiAgICAgICAgY29uc3QgYXhpc0RpZmYgPSBqc29uRGlmZihwcmV2aW91c09wdHMsIGF4ZXNbaW5kZXhdKTtcbiAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5QXhlcygpIC0gYXBwbHlpbmcgYXhpcyBkaWZmIGlkeCAke2luZGV4fWAsIGF4aXNEaWZmKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGBheGVzWyR7aW5kZXh9XWA7XG4gICAgICAgIGpzb25BcHBseShheGlzLCBheGlzRGlmZiwgeyBwYXRoLCBza2lwIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5QXhlcygpIC0gY3JlYXRpbmcgbmV3IGF4ZXMgaW5zdGFuY2VzOyBzZXJpZXNTdGF0dXM6ICR7c2VyaWVzU3RhdHVzfWApO1xuICAgIGNoYXJ0LmF4ZXMgPSB0aGlzLmNyZWF0ZUF4aXMoYXhlcywgc2tpcCk7XG4gICAgY29uc3QgYXhpc0dyb3VwcyA9IHtcbiAgICAgIFtcInhcIiAvKiBYICovXTogW10sXG4gICAgICBbXCJ5XCIgLyogWSAqL106IFtdXG4gICAgfTtcbiAgICBjaGFydC5heGVzLmZvckVhY2goKGF4aXMpID0+IGF4aXNHcm91cHNbYXhpcy5kaXJlY3Rpb25dLnB1c2goYXhpcy5nZXRSZWdpb25CQm94UHJvdmlkZXIoKSkpO1xuICAgIGlmIChyZWdpc3RlclJlZ2lvbnMpIHtcbiAgICAgIHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIudXBkYXRlUmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovLCAuLi5heGlzR3JvdXBzW1wieFwiIC8qIFggKi9dKTtcbiAgICAgIHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIudXBkYXRlUmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8sIC4uLmF4aXNHcm91cHNbXCJ5XCIgLyogWSAqL10pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjcmVhdGVTZXJpZXMoc2VyaWVzT3B0aW9ucykge1xuICAgIGNvbnN0IHNlcmllc0luc3RhbmNlID0gc2VyaWVzUmVnaXN0cnkuY3JlYXRlKHNlcmllc09wdGlvbnMudHlwZSwgdGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpO1xuICAgIHRoaXMuYXBwbHlTZXJpZXNPcHRpb25Nb2R1bGVzKHNlcmllc0luc3RhbmNlLCBzZXJpZXNPcHRpb25zKTtcbiAgICB0aGlzLmFwcGx5U2VyaWVzVmFsdWVzKHNlcmllc0luc3RhbmNlLCBzZXJpZXNPcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWVzSW5zdGFuY2U7XG4gIH1cbiAgYXBwbHlTZXJpZXNPcHRpb25Nb2R1bGVzKHNlcmllcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSBzZXJpZXMuY3JlYXRlTW9kdWxlQ29udGV4dCgpO1xuICAgIGNvbnN0IG1vZHVsZU1hcCA9IHNlcmllcy5nZXRNb2R1bGVNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJzZXJpZXMtb3B0aW9uXCIpKSB7XG4gICAgICBpZiAobW9kdWxlLm9wdGlvbnNLZXkgaW4gb3B0aW9ucyAmJiBtb2R1bGUuc2VyaWVzVHlwZXMuaW5jbHVkZXMoc2VyaWVzLnR5cGUpKSB7XG4gICAgICAgIG1vZHVsZU1hcC5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KG1vZHVsZUNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXBwbHlTZXJpZXNWYWx1ZXModGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kdWxlTWFwID0gdGFyZ2V0LmdldE1vZHVsZU1hcCgpO1xuICAgIGNvbnN0IHsgdHlwZTogXywgZGF0YSwgbGlzdGVuZXJzLCBzZXJpZXNHcm91cGluZywgc2hvd0luTWluaUNoYXJ0OiBfXywgLi4uc2VyaWVzT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IG1vZHVsZURlZiBvZiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMpIHtcbiAgICAgIGlmIChtb2R1bGVEZWYudHlwZSAhPT0gXCJzZXJpZXMtb3B0aW9uXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG1vZHVsZURlZi5vcHRpb25zS2V5IGluIHNlcmllc09wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbW9kdWxlTWFwLmdldE1vZHVsZShtb2R1bGVEZWYub3B0aW9uc0tleSk7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGVPcHRpb25zID0gc2VyaWVzT3B0aW9uc1ttb2R1bGVEZWYub3B0aW9uc0tleV07XG4gICAgICAgICAgZGVsZXRlIHNlcmllc09wdGlvbnNbbW9kdWxlRGVmLm9wdGlvbnNLZXldO1xuICAgICAgICAgIG1vZHVsZS5wcm9wZXJ0aWVzLnNldChtb2R1bGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQucHJvcGVydGllcy5zZXQoc2VyaWVzT3B0aW9ucyk7XG4gICAgaWYgKFwiZGF0YVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldC5zZXRPcHRpb25zRGF0YShkYXRhKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycyh0YXJnZXQsIGxpc3RlbmVycyk7XG4gICAgfVxuICAgIGlmIChcInNlcmllc0dyb3VwaW5nXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHNlcmllc0dyb3VwaW5nID09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LnNlcmllc0dyb3VwaW5nID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnNlcmllc0dyb3VwaW5nID0geyAuLi50YXJnZXQuc2VyaWVzR3JvdXBpbmcsIC4uLnNlcmllc0dyb3VwaW5nIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUF4aXMob3B0aW9ucywgc2tpcCkge1xuICAgIGNvbnN0IG5ld0F4ZXMgPSBbXTtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gdGhpcy5nZXRNb2R1bGVDb250ZXh0KCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG9wdGlvbnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBheGlzT3B0aW9ucyA9IG9wdGlvbnNbaW5kZXhdO1xuICAgICAgY29uc3QgYXhpcyA9IGF4aXNSZWdpc3RyeS5jcmVhdGUoYXhpc09wdGlvbnMudHlwZSwgbW9kdWxlQ29udGV4dCk7XG4gICAgICB0aGlzLmFwcGx5QXhpc01vZHVsZXMoYXhpcywgYXhpc09wdGlvbnMpO1xuICAgICAganNvbkFwcGx5KGF4aXMsIGF4aXNPcHRpb25zLCB7IHBhdGg6IGBheGVzWyR7aW5kZXh9XWAsIHNraXAgfSk7XG4gICAgICBuZXdBeGVzLnB1c2goYXhpcyk7XG4gICAgfVxuICAgIGd1ZXNzSW52YWxpZFBvc2l0aW9ucyhuZXdBeGVzKTtcbiAgICByZXR1cm4gbmV3QXhlcztcbiAgfVxuICBhcHBseUF4aXNNb2R1bGVzKGF4aXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gYXhpcy5jcmVhdGVNb2R1bGVDb250ZXh0KCk7XG4gICAgY29uc3QgbW9kdWxlTWFwID0gYXhpcy5nZXRNb2R1bGVNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJheGlzLW9wdGlvblwiKSkge1xuICAgICAgY29uc3Qgc2hvdWxkQmVFbmFibGVkID0gb3B0aW9uc1ttb2R1bGUub3B0aW9uc0tleV0gIT0gbnVsbDtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQgPT09IG1vZHVsZU1hcC5pc0VuYWJsZWQobW9kdWxlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkKSB7XG4gICAgICAgIG1vZHVsZU1hcC5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KG1vZHVsZUNvbnRleHQpKTtcbiAgICAgICAgYXhpc1ttb2R1bGUub3B0aW9uc0tleV0gPSBtb2R1bGVNYXAuZ2V0TW9kdWxlKG1vZHVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2R1bGVNYXAucmVtb3ZlTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIGRlbGV0ZSBheGlzW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoc291cmNlLCBsaXN0ZW5lcnMpIHtcbiAgICBzb3VyY2UuY2xlYXJFdmVudExpc3RlbmVycygpO1xuICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBsaXN0ZW5lcl0gb2YgT2JqZWN0LmVudHJpZXMobGlzdGVuZXJzKSkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKHByb3BlcnR5LCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0Q29udGFpbmVyKHZhbHVlKTtcbiAgICAgIF9DaGFydC5jaGFydHNJbnN0YW5jZXMuc2V0KHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuICAgIG9sZFZhbHVlKHZhbHVlKSB7XG4gICAgICBfQ2hhcnQuY2hhcnRzSW5zdGFuY2VzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwid2lkdGggb3B0aW9uXCIsIHsgaW5XaWR0aDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJoZWlnaHQgb3B0aW9uXCIsIHsgaW5IZWlnaHQ6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcIm1pbldpZHRoIG9wdGlvblwiLCB7IGluTWluV2lkdGg6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwibWluSGVpZ2h0IG9wdGlvblwiLCB7IGluTWluSGVpZ2h0OiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm1pbkhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwidGl0bGVQYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJzZXJpZXNBcmVhXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic3VidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImZvb3Rub3RlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJrZXlib2FyZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInN0YW5kYWxvbmVcIiwgXCJpbnRlZ3JhdGVkXCJdLCBcImEgY2hhcnQgbW9kZVwiKSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwibW9kZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIHRoaXMub25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJheGVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgdGhpcy5vblNlcmllc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic2VyaWVzXCIsIDIpO1xudmFyIENoYXJ0ID0gX0NoYXJ0O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL3F1YWR0cmVlLnRzXG52YXIgUXVhZHRyZWVOZWFyZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYXBhY2l0eSwgbWF4ZGVwdGgsIGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5yb290ID0gbmV3IFF1YWR0cmVlTm9kZU5lYXJlc3QoY2FwYWNpdHksIG1heGRlcHRoLCBib3VuZGFyeSk7XG4gIH1cbiAgY2xlYXIoYm91bmRhcnkpIHtcbiAgICB0aGlzLnJvb3QuY2xlYXIoYm91bmRhcnkpO1xuICB9XG4gIGFkZFZhbHVlKGhpdFRlc3RlciwgdmFsdWUpIHtcbiAgICBjb25zdCBlbGVtID0ge1xuICAgICAgaGl0VGVzdGVyLFxuICAgICAgdmFsdWUsXG4gICAgICBkaXN0YW5jZVNxdWFyZWQ6ICh4LCB5KSA9PiB7XG4gICAgICAgIHJldHVybiBoaXRUZXN0ZXIuZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yb290LmFkZEVsZW0oZWxlbSk7XG4gIH1cbiAgZmluZCh4LCB5KSB7XG4gICAgY29uc3QgYXJnID0geyBiZXN0OiB7IG5lYXJlc3Q6IHZvaWQgMCwgZGlzdGFuY2VTcXVhcmVkOiBJbmZpbml0eSB9IH07XG4gICAgdGhpcy5yb290LmZpbmQoeCwgeSwgYXJnKTtcbiAgICByZXR1cm4gYXJnLmJlc3Q7XG4gIH1cbn07XG52YXIgUXVhZHRyZWVTdWJkaXZpc2lvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG53LCBuZSwgc3csIHNlKSB7XG4gICAgdGhpcy5udyA9IG53O1xuICAgIHRoaXMubmUgPSBuZTtcbiAgICB0aGlzLnN3ID0gc3c7XG4gICAgdGhpcy5zZSA9IHNlO1xuICB9XG4gIGFkZEVsZW0oZWxlbSkge1xuICAgIHRoaXMubncuYWRkRWxlbShlbGVtKTtcbiAgICB0aGlzLm5lLmFkZEVsZW0oZWxlbSk7XG4gICAgdGhpcy5zdy5hZGRFbGVtKGVsZW0pO1xuICAgIHRoaXMuc2UuYWRkRWxlbShlbGVtKTtcbiAgfVxuICBmaW5kKHgsIHksIGFyZykge1xuICAgIHRoaXMubncuZmluZCh4LCB5LCBhcmcpO1xuICAgIHRoaXMubmUuZmluZCh4LCB5LCBhcmcpO1xuICAgIHRoaXMuc3cuZmluZCh4LCB5LCBhcmcpO1xuICAgIHRoaXMuc2UuZmluZCh4LCB5LCBhcmcpO1xuICB9XG59O1xudmFyIFF1YWR0cmVlTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FwYWNpdHksIG1heGRlcHRoLCBib3VuZGFyeSkge1xuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLm1heGRlcHRoID0gbWF4ZGVwdGg7XG4gICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5ID8/IEJCb3guTmFOO1xuICAgIHRoaXMuZWxlbXMgPSBbXTtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHZvaWQgMDtcbiAgfVxuICBjbGVhcihib3VuZGFyeSkge1xuICAgIHRoaXMuZWxlbXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMgPSB2b2lkIDA7XG4gIH1cbiAgYWRkRWxlbShlKSB7XG4gICAgaWYgKHRoaXMuYWRkQ29uZGl0aW9uKGUpKSB7XG4gICAgICBpZiAodGhpcy5zdWJkaXZpc2lvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5tYXhkZXB0aCA9PT0gMCB8fCB0aGlzLmVsZW1zLmxlbmd0aCA8IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgICAgICB0aGlzLmVsZW1zLnB1c2goZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdWJkaXZpZGUoZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3ViZGl2aXNpb25zLmFkZEVsZW0oZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmQoeCwgeSwgYXJnKSB7XG4gICAgaWYgKHRoaXMuZmluZENvbmRpdGlvbih4LCB5LCBhcmcpKSB7XG4gICAgICBpZiAodGhpcy5zdWJkaXZpc2lvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmZpbmRBY3Rpb24oeCwgeSwgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3ViZGl2aXNpb25zLmZpbmQoeCwgeSwgYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3ViZGl2aWRlKG5ld0VsZW0pIHtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHRoaXMubWFrZVN1YmRpdmlzaW9ucygpO1xuICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmVsZW1zKSB7XG4gICAgICB0aGlzLnN1YmRpdmlzaW9ucy5hZGRFbGVtKGUpO1xuICAgIH1cbiAgICB0aGlzLnN1YmRpdmlzaW9ucy5hZGRFbGVtKG5ld0VsZW0pO1xuICAgIHRoaXMuZWxlbXMubGVuZ3RoID0gMDtcbiAgfVxuICBtYWtlU3ViZGl2aXNpb25zKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5ib3VuZGFyeTtcbiAgICBjb25zdCB7IGNhcGFjaXR5IH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlcHRoID0gdGhpcy5tYXhkZXB0aCAtIDE7XG4gICAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIGNvbnN0IG53Qm91bmRhcnkgPSBuZXcgQkJveCh4LCB5LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIGNvbnN0IG5lQm91bmRhcnkgPSBuZXcgQkJveCh4ICsgaGFsZldpZHRoLCB5LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIGNvbnN0IHN3Qm91bmRhcnkgPSBuZXcgQkJveCh4LCB5ICsgaGFsZkhlaWdodCwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICBjb25zdCBzZUJvdW5kYXJ5ID0gbmV3IEJCb3goeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgcmV0dXJuIG5ldyBRdWFkdHJlZVN1YmRpdmlzaW9ucyhcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBud0JvdW5kYXJ5KSxcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBuZUJvdW5kYXJ5KSxcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBzd0JvdW5kYXJ5KSxcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBzZUJvdW5kYXJ5KVxuICAgICk7XG4gIH1cbn07XG52YXIgUXVhZHRyZWVOb2RlTmVhcmVzdCA9IGNsYXNzIF9RdWFkdHJlZU5vZGVOZWFyZXN0IGV4dGVuZHMgUXVhZHRyZWVOb2RlIHtcbiAgYWRkQ29uZGl0aW9uKGUpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGUuaGl0VGVzdGVyLm1pZFBvaW50O1xuICAgIHJldHVybiB0aGlzLmJvdW5kYXJ5LmNvbnRhaW5zUG9pbnQoeCwgeSk7XG4gIH1cbiAgZmluZENvbmRpdGlvbih4LCB5LCBhcmcpIHtcbiAgICBjb25zdCB7IGJlc3QgfSA9IGFyZztcbiAgICByZXR1cm4gYmVzdC5kaXN0YW5jZVNxdWFyZWQgIT09IDAgJiYgdGhpcy5ib3VuZGFyeS5kaXN0YW5jZVNxdWFyZWQoeCwgeSkgPCBiZXN0LmRpc3RhbmNlU3F1YXJlZDtcbiAgfVxuICBmaW5kQWN0aW9uKHgsIHksIGFyZykge1xuICAgIGNvbnN0IG90aGVyID0gbmVhcmVzdFNxdWFyZWQoeCwgeSwgdGhpcy5lbGVtcywgYXJnLmJlc3QuZGlzdGFuY2VTcXVhcmVkKTtcbiAgICBpZiAob3RoZXIubmVhcmVzdCAhPT0gdm9pZCAwICYmIG90aGVyLmRpc3RhbmNlU3F1YXJlZCA8IGFyZy5iZXN0LmRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgYXJnLmJlc3QgPSBvdGhlcjtcbiAgICB9XG4gIH1cbiAgY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBib3VuZGFyeSkge1xuICAgIHJldHVybiBuZXcgX1F1YWR0cmVlTm9kZU5lYXJlc3QoY2FwYWNpdHksIGRlcHRoLCBib3VuZGFyeSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9tYXJrZXIudHNcbnZhciBNYXJrZXIgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnNpemUgPSAxMjtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHNpemUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjZW50ZXIgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBCQm94KHggLSBzaXplICogY2VudGVyLngsIHkgLSBzaXplICogY2VudGVyLnksIHNpemUsIHNpemUpO1xuICB9XG4gIGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgfVxuICBhcHBseVBhdGgocywgbW92ZXMpIHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgbGV0IHsgeCwgeSB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5yZXBlYXQgIT0gbnVsbCkge1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICB9XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgeyB4OiBteCwgeTogbXksIHQgfSBvZiBtb3Zlcykge1xuICAgICAgeCArPSBteCAqIHM7XG4gICAgICB5ICs9IG15ICogcztcbiAgICAgIGlmICh0ID09PSBcIm1vdmVcIikge1xuICAgICAgICBwYXRoLm1vdmVUbyh4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIGV4ZWN1dGVGaWxsKGN0eCwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5yZXBlYXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmV4ZWN1dGVGaWxsKGN0eCwgcGF0aCk7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICBsZXQgeSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIGZvciAoY29uc3QgdHJhbnNsYXRpb24gb2YgdGhpcy5yZXBlYXQpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUodHJhbnNsYXRpb24ueCAtIHgsIHRyYW5zbGF0aW9uLnkgLSB5KTtcbiAgICAgIGN0eC5maWxsKHBhdGgpO1xuICAgICAgeCA9IHRyYW5zbGF0aW9uLng7XG4gICAgICB5ID0gdHJhbnNsYXRpb24ueTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBleGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5yZXBlYXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgeCA9IHRoaXMudHJhbnNsYXRpb25YO1xuICAgIGxldCB5ID0gdGhpcy50cmFuc2xhdGlvblk7XG4gICAgZm9yIChjb25zdCB0cmFuc2xhdGlvbiBvZiB0aGlzLnJlcGVhdCkge1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54IC0geCwgdHJhbnNsYXRpb24ueSAtIHkpO1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICAgIHggPSB0cmFuc2xhdGlvbi54O1xuICAgICAgeSA9IHRyYW5zbGF0aW9uLnk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5NYXJrZXIuY2VudGVyID0geyB4OiAwLjUsIHk6IDAuNSB9O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIE1hcmtlci5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBNYXJrZXIucHJvdG90eXBlLCBcInlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oeyBjb252ZXJ0b3I6IE1hdGguYWJzIH0pXG5dLCBNYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgTWFya2VyLnByb3RvdHlwZSwgXCJyZXBlYXRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9jaXJjbGUudHNcbnZhciBDaXJjbGUgPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyB4LCB5LCBwYXRoLCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IHIgPSBzaXplIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5DaXJjbGUuY2xhc3NOYW1lID0gXCJDaXJjbGVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL2Nyb3NzLnRzXG52YXIgX0Nyb3NzID0gY2xhc3MgX0Nyb3NzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gNC4yO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfQ3Jvc3MubW92ZXMpO1xuICB9XG59O1xuX0Nyb3NzLmNsYXNzTmFtZSA9IFwiQ3Jvc3NcIjtcbl9Dcm9zcy5tb3ZlcyA9IFtcbiAgeyB4OiAtMSwgeTogMCwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAtMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAxLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAtMSB9LFxuICB7IHg6IC0xLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IC0xIH1cbl07XG52YXIgQ3Jvc3MgPSBfQ3Jvc3M7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9kaWFtb25kLnRzXG52YXIgX0RpYW1vbmQgPSBjbGFzcyBfRGlhbW9uZCBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDI7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9EaWFtb25kLm1vdmVzKTtcbiAgfVxufTtcbl9EaWFtb25kLmNsYXNzTmFtZSA9IFwiRGlhbW9uZFwiO1xuX0RpYW1vbmQubW92ZXMgPSBbXG4gIHsgeDogMCwgeTogLTEsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogLTEgfVxuXTtcbnZhciBEaWFtb25kID0gX0RpYW1vbmQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9oZWFydC50c1xudmFyIEhlYXJ0ID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICByYWQoZGVncmVlMikge1xuICAgIHJldHVybiBkZWdyZWUyIC8gMTgwICogTWF0aC5QSTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgeCwgcGF0aCwgc2l6ZSwgcmFkIH0gPSB0aGlzO1xuICAgIGNvbnN0IHIgPSBzaXplIC8gNDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICsgciAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHggLSByLCB5IC0gciwgciwgcmFkKDEzMCksIHJhZCgzMzApKTtcbiAgICBwYXRoLmFyYyh4ICsgciwgeSAtIHIsIHIsIHJhZCgyMjApLCByYWQoNTApKTtcbiAgICBwYXRoLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbkhlYXJ0LmNsYXNzTmFtZSA9IFwiSGVhcnRcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3Bpbi50c1xudmFyIFBpbiA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHkgfSA9IHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBjeCA9IDAuNTtcbiAgICBjb25zdCBjeSA9IDE7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGgubW92ZVRvKHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsIHkgKyAoMC4zNDM3NSAtIGN5KSAqIHMpO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjE1NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4xNTE0OTEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjMwNzc0MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNjkyMjU5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuODQzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjE1MTQ5MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuODQzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjM0Mzc1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuODQzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjQ5MzgyNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNzg0NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42MDAxODEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjcxNjQ2MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjk1MzkzIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNjk5MDA5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43MTk3NjkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjY4MTI3MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzQzMTA0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC42NjM3ODUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc2NjEwNSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjYxMTg5MyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODM0MzY3IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41NjIyMjggLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjg5OTY5OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNTI4ODk2IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45ODA2NDggLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC41MjQwNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk5MjM1OCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNTEyNjYzIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC40ODczMzcgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzU5MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk5MjM1OCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDcxMTA0IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45ODA2NDggLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC40ODczMzcgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzU5MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk5MjM1OCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDcxMTA0IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45ODA2NDggLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC40Mzc3NzIgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjg5OTY5OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzg4MTA3IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44MzQzNjcgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjMzNjIxNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzY2MTA1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuMzE4NzI5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NDMxMDQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjMwMDk5MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzE5NzY5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4yODM1MzkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjY5NTM5MyAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjIxNTM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjAwMTgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNDkzODI0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMzQzNzUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuUGluLmNsYXNzTmFtZSA9IFwiTWFwUGluXCI7XG5QaW4uY2VudGVyID0geyB4OiAwLjUsIHk6IDEgfTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3BsdXMudHNcbnZhciBfUGx1cyA9IGNsYXNzIF9QbHVzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gMztcbiAgICBzdXBlci5hcHBseVBhdGgocywgX1BsdXMubW92ZXMpO1xuICB9XG59O1xuX1BsdXMuY2xhc3NOYW1lID0gXCJQbHVzXCI7XG5fUGx1cy5tb3ZlcyA9IFtcbiAgeyB4OiAtMC41LCB5OiAtMC41LCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDAsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDEgfSxcbiAgeyB4OiAxLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogLTEgfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IC0xIH1cbl07XG52YXIgUGx1cyA9IF9QbHVzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvc3F1YXJlLnRzXG52YXIgU3F1YXJlID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSB9ID0gdGhpcztcbiAgICBjb25zdCBocyA9IHRoaXMuc2l6ZSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGgubW92ZVRvKHRoaXMuYWxpZ24oeCAtIGhzKSwgdGhpcy5hbGlnbih5IC0gaHMpKTtcbiAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKHggKyBocyksIHRoaXMuYWxpZ24oeSAtIGhzKSk7XG4gICAgcGF0aC5saW5lVG8odGhpcy5hbGlnbih4ICsgaHMpLCB0aGlzLmFsaWduKHkgKyBocykpO1xuICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oeCAtIGhzKSwgdGhpcy5hbGlnbih5ICsgaHMpKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuU3F1YXJlLmNsYXNzTmFtZSA9IFwiU3F1YXJlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9zdGFyLnRzXG52YXIgU3RhciA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHBhdGgsIHNpemUgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3Bpa2VzID0gNTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHNpemUgLyAyO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5QSSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Bpa2VzICogMjsgaSsrKSB7XG4gICAgICBjb25zdCByYWRpdXMgPSBpICUgMiA9PT0gMCA/IHNpemUgOiBpbm5lclJhZGl1cztcbiAgICAgIGNvbnN0IGFuZ2xlMiA9IGkgKiBNYXRoLlBJIC8gc3Bpa2VzIC0gcm90YXRpb247XG4gICAgICBjb25zdCB4Q29vcmRpbmF0ZSA9IHggKyBNYXRoLmNvcyhhbmdsZTIpICogcmFkaXVzO1xuICAgICAgY29uc3QgeUNvb3JkaW5hdGUgPSB5ICsgTWF0aC5zaW4oYW5nbGUyKSAqIHJhZGl1cztcbiAgICAgIHBhdGgubGluZVRvKHhDb29yZGluYXRlLCB5Q29vcmRpbmF0ZSk7XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5TdGFyLmNsYXNzTmFtZSA9IFwiU3RhclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvdHJpYW5nbGUudHNcbnZhciBfVHJpYW5nbGUgPSBjbGFzcyBfVHJpYW5nbGUgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgKiAxLjE7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9UcmlhbmdsZS5tb3Zlcyk7XG4gIH1cbn07XG5fVHJpYW5nbGUuY2xhc3NOYW1lID0gXCJUcmlhbmdsZVwiO1xuX1RyaWFuZ2xlLm1vdmVzID0gW1xuICB7IHg6IDAsIHk6IC0wLjQ4LCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDAuNSwgeTogMC44NyB9LFxuICB7IHg6IC0xLCB5OiAwIH1cbl07XG52YXIgVHJpYW5nbGUgPSBfVHJpYW5nbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci91dGlsLnRzXG52YXIgTUFSS0VSX1NIQVBFUyA9IHtcbiAgY2lyY2xlOiBDaXJjbGUsXG4gIGNyb3NzOiBDcm9zcyxcbiAgZGlhbW9uZDogRGlhbW9uZCxcbiAgaGVhcnQ6IEhlYXJ0LFxuICBwaW46IFBpbixcbiAgcGx1czogUGx1cyxcbiAgc3F1YXJlOiBTcXVhcmUsXG4gIHN0YXI6IFN0YXIsXG4gIHRyaWFuZ2xlOiBUcmlhbmdsZVxufTtcbnZhciBNQVJLRVJfU1VQUE9SVEVEX1NIQVBFUyA9IE9iamVjdC5rZXlzKE1BUktFUl9TSEFQRVMpO1xuZnVuY3Rpb24gaXNNYXJrZXJTaGFwZShzaGFwZSkge1xuICByZXR1cm4gdHlwZW9mIHNoYXBlID09PSBcInN0cmluZ1wiICYmIE1BUktFUl9TVVBQT1JURURfU0hBUEVTLmluY2x1ZGVzKHNoYXBlKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmtlcihzaGFwZSA9IFNxdWFyZSkge1xuICBpZiAoaXNNYXJrZXJTaGFwZShzaGFwZSkpIHtcbiAgICByZXR1cm4gTUFSS0VSX1NIQVBFU1tzaGFwZV07XG4gIH1cbiAgaWYgKHR5cGVvZiBzaGFwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9XG4gIHJldHVybiBTcXVhcmU7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9kYXRhTW9kZWxTZXJpZXMudHNcbnZhciBEYXRhTW9kZWxTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93Rm9jdXNCb3ggPSB0cnVlO1xuICB9XG4gIGdldFNjYWxlSW5mb3JtYXRpb24oe1xuICAgIHhTY2FsZSxcbiAgICB5U2NhbGVcbiAgfSkge1xuICAgIGNvbnN0IGlzQ29udGludW91c1ggPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKTtcbiAgICBjb25zdCBpc0NvbnRpbnVvdXNZID0gQ29udGludW91c1NjYWxlLmlzKHlTY2FsZSk7XG4gICAgcmV0dXJuIHsgaXNDb250aW51b3VzWCwgaXNDb250aW51b3VzWSwgeFNjYWxlVHlwZTogeFNjYWxlPy50eXBlLCB5U2NhbGVUeXBlOiB5U2NhbGU/LnR5cGUgfTtcbiAgfVxuICBnZXRNb2R1bGVQcm9wZXJ0eURlZmluaXRpb25zKCkge1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAubWFwTW9kdWxlcygobW9kMikgPT4gbW9kMi5nZXRQcm9wZXJ0eURlZmluaXRpb25zKHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pKSkuZmxhdCgpO1xuICB9XG4gIC8vIFJlcXVlc3QgZGF0YSwgYnV0IHdpdGggbWVzc2FnZSBkaXNwYXRjaGluZyB0byBzZXJpZXMtb3B0aW9ucyAobW9kdWxlcykuXG4gIGFzeW5jIHJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIG9wdHMpIHtcbiAgICBvcHRzLnByb3BzLnB1c2goLi4udGhpcy5nZXRNb2R1bGVQcm9wZXJ0eURlZmluaXRpb25zKCkpO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCBkYXRhQ29udHJvbGxlci5yZXF1ZXN0KHRoaXMuaWQsIGRhdGEgPz8gW10sIG9wdHMpO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gZGF0YU1vZGVsO1xuICAgIHRoaXMucHJvY2Vzc2VkRGF0YSA9IHByb2Nlc3NlZERhdGE7XG4gICAgdGhpcy5kaXNwYXRjaChcImRhdGEtcHJvY2Vzc2VkXCIsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xuICAgIHJldHVybiB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9O1xuICB9XG4gIGlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHMgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb247XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgb3JkZXJlZEtleXMsIHVuaXF1ZUtleXMgfSA9IHZhbGlkYXRpb25SZXN1bHRzO1xuICAgIHJldHVybiBvcmRlcmVkS2V5cyAmJiB1bmlxdWVLZXlzO1xuICB9XG4gIGNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIHBpY2tGb2N1cyhvcHRzKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldE5vZGVEYXRhKCk7XG4gICAgaWYgKG5vZGVEYXRhID09PSB2b2lkIDAgfHwgbm9kZURhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBkYXR1bUluZGV4ID0gdGhpcy5jb21wdXRlRm9jdXNEYXR1bUluZGV4KG9wdHMsIG5vZGVEYXRhKTtcbiAgICBpZiAoZGF0dW1JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCB7IHNob3dGb2N1c0JveCB9ID0gdGhpcztcbiAgICBjb25zdCBkYXR1bSA9IG5vZGVEYXRhW2RhdHVtSW5kZXhdO1xuICAgIGNvbnN0IGRlcml2ZWRPcHRzID0geyAuLi5vcHRzLCBkYXR1bUluZGV4IH07XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5jb21wdXRlRm9jdXNCb3VuZHMoZGVyaXZlZE9wdHMpO1xuICAgIGlmIChib3VuZHMgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgYm91bmRzLCBzaG93Rm9jdXNCb3gsIGRhdHVtLCBkYXR1bUluZGV4IH07XG4gICAgfVxuICB9XG4gIGNvbXB1dGVGb2N1c0RhdHVtSW5kZXgob3B0cywgbm9kZURhdGEpIHtcbiAgICBjb25zdCBpc0RhdHVtRW5hYmxlZCA9IChkYXR1bUluZGV4MikgPT4ge1xuICAgICAgY29uc3QgeyBtaXNzaW5nID0gZmFsc2UsIGVuYWJsZWQgPSB0cnVlLCBmb2N1c2FibGUgPSB0cnVlIH0gPSBub2RlRGF0YVtkYXR1bUluZGV4Ml07XG4gICAgICByZXR1cm4gIW1pc3NpbmcgJiYgZW5hYmxlZCAmJiBmb2N1c2FibGU7XG4gICAgfTtcbiAgICBjb25zdCBzZWFyY2hCYWNrd2FyZCA9IChkYXR1bUluZGV4MikgPT4ge1xuICAgICAgd2hpbGUgKGRhdHVtSW5kZXgyID49IDAgJiYgIWlzRGF0dW1FbmFibGVkKGRhdHVtSW5kZXgyKSkge1xuICAgICAgICBkYXR1bUluZGV4Mi0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdHVtSW5kZXgyID09PSAtMSA/IHZvaWQgMCA6IGRhdHVtSW5kZXgyO1xuICAgIH07XG4gICAgY29uc3Qgc2VhcmNoRm9yd2FyZCA9IChkYXR1bUluZGV4MikgPT4ge1xuICAgICAgd2hpbGUgKGRhdHVtSW5kZXgyIDwgbm9kZURhdGEubGVuZ3RoICYmICFpc0RhdHVtRW5hYmxlZChkYXR1bUluZGV4MikpIHtcbiAgICAgICAgZGF0dW1JbmRleDIrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXR1bUluZGV4MiA9PT0gbm9kZURhdGEubGVuZ3RoID8gdm9pZCAwIDogZGF0dW1JbmRleDI7XG4gICAgfTtcbiAgICBsZXQgZGF0dW1JbmRleDtcbiAgICBjb25zdCBjbGFtcGVkSW5kZXggPSBjbGFtcCgwLCBvcHRzLmRhdHVtSW5kZXgsIG5vZGVEYXRhLmxlbmd0aCAtIDEpO1xuICAgIGlmIChvcHRzLmRhdHVtSW5kZXhEZWx0YSA8IDApIHtcbiAgICAgIGRhdHVtSW5kZXggPSBzZWFyY2hCYWNrd2FyZChjbGFtcGVkSW5kZXgpO1xuICAgIH0gZWxzZSBpZiAob3B0cy5kYXR1bUluZGV4RGVsdGEgPiAwKSB7XG4gICAgICBkYXR1bUluZGV4ID0gc2VhcmNoRm9yd2FyZChjbGFtcGVkSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXR1bUluZGV4ID8/IChkYXR1bUluZGV4ID0gc2VhcmNoRm9yd2FyZChjbGFtcGVkSW5kZXgpKTtcbiAgICAgIGRhdHVtSW5kZXggPz8gKGRhdHVtSW5kZXggPSBzZWFyY2hCYWNrd2FyZChjbGFtcGVkSW5kZXgpKTtcbiAgICB9XG4gICAgaWYgKGRhdHVtSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3B0cy5kYXR1bUluZGV4IC0gb3B0cy5kYXR1bUluZGV4RGVsdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXR1bUluZGV4O1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1Byb3BlcnRpZXMudHNcbnZhciBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGwgPSBcInJnYmEoMjU1LDI1NSwyNTUsIDAuMzMpXCI7XG4gICAgdGhpcy5zdHJva2UgPSBgcmdiYSgwLCAwLCAwLCAwLjQpYDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbnZhciBTZXJpZXNIaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJkaW1PcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgVGV4dEhpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvciA9IFwiYmxhY2tcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVGV4dEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbnZhciBIaWdobGlnaHRQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZ2hsaWdodFByb3BlcnRpZXMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgSGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLml0ZW0gPSBuZXcgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgdGhpcy5zZXJpZXMgPSBuZXcgU2VyaWVzSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB0aGlzLnRleHQgPSBuZXcgVGV4dEhpZ2hsaWdodFN0eWxlKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiaXRlbVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbnZhciBTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnNob3dJbkxlZ2VuZCA9IHRydWU7XG4gICAgdGhpcy5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICB0aGlzLm5vZGVDbGlja1JhbmdlID0gXCJleGFjdFwiO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gbmV3IEhpZ2hsaWdodFByb3BlcnRpZXMoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFN0eWxlID0gbmV3IEhpZ2hsaWdodFN0eWxlKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY3Vyc29yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJBQ1RJT05fUkFOR0UpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub2RlQ2xpY2tSYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImhpZ2hsaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImhpZ2hsaWdodFN0eWxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2NhcnRlc2lhblNlcmllcy50c1xudmFyIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTID0ge1xuICBbXCJ4XCIgLyogWCAqL106IFtcInhLZXlcIl0sXG4gIFtcInlcIiAvKiBZICovXTogW1wieUtleVwiXVxufTtcbnZhciBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMgPSB7XG4gIFtcInhcIiAvKiBYICovXTogW1wieE5hbWVcIl0sXG4gIFtcInlcIiAvKiBZICovXTogW1wieU5hbWVcIl1cbn07XG52YXIgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLnhLZXkgPSBzZXJpZXMucHJvcGVydGllcy54S2V5O1xuICAgIHRoaXMueUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnlLZXk7XG4gIH1cbn07XG52YXIgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5waWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXMgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXNcIiwgMik7XG52YXIgQ2FydGVzaWFuU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBEYXRhTW9kZWxTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGF0aHNQZXJTZXJpZXMgPSBbXCJwYXRoXCJdLFxuICAgIGhhc01hcmtlcnMgPSBmYWxzZSxcbiAgICBoYXNIaWdobGlnaHRlZExhYmVscyA9IGZhbHNlLFxuICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQgPSBbXSxcbiAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uID0gdHJ1ZSxcbiAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUsXG4gICAgYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyA9IGZhbHNlLFxuICAgIGFuaW1hdGlvblJlc2V0Rm5zLFxuICAgIGRpcmVjdGlvbktleXMsXG4gICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgLi4ub3RoZXJPcHRzXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBkaXJlY3Rpb25LZXlzLFxuICAgICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgICBjYW5IYXZlQXhlczogdHJ1ZSxcbiAgICAgIC4uLm90aGVyT3B0c1xuICAgIH0pO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuZGF0YU5vZGVHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLWRhdGFOb2Rlc2AsXG4gICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMubWFya2VyR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1tYXJrZXJzYCxcbiAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJtYXJrZXJcIilcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1sYWJlbHNgLFxuICAgICAgICB6SW5kZXg6IDggLyogU0VSSUVTX0xBQkVMX1pJTkRFWCAqLyxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImxhYmVsc1wiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMubGFiZWxHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5oaWdobGlnaHROb2RlLFxuICAgICAgKCkgPT4gdGhpcy5vcHRzLmhhc01hcmtlcnMgPyB0aGlzLm1hcmtlckZhY3RvcnkoKSA6IHRoaXMubm9kZUZhY3RvcnkoKVxuICAgICk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5oaWdobGlnaHRMYWJlbCwgVGV4dCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU2VsZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5taW5SZWN0c0NhY2hlID0ge1xuICAgICAgZGlydHlOb2RlRGF0YTogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSgpO1xuICAgIGlmICghZGlyZWN0aW9uS2V5cyB8fCAhZGlyZWN0aW9uTmFtZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBpbml0aWFsaXNlIHNlcmllcyB0eXBlICR7dGhpcy50eXBlfWApO1xuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIHBhdGhzUGVyU2VyaWVzLFxuICAgICAgaGFzTWFya2VycyxcbiAgICAgIGhhc0hpZ2hsaWdodGVkTGFiZWxzLFxuICAgICAgcGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldCxcbiAgICAgIGRpcmVjdGlvbktleXMsXG4gICAgICBkaXJlY3Rpb25OYW1lcyxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zLFxuICAgICAgYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24sXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvblxuICAgIH07XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXRoc1BlclNlcmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHRoaXMucGF0aHNbaW5kZXhdID0gbmV3IFBhdGgoeyBuYW1lOiBgJHt0aGlzLmlkfS0ke3BhdGhzUGVyU2VyaWVzW2luZGV4XX1gIH0pO1xuICAgICAgdGhpcy5wYXRoc1tpbmRleF0uekluZGV4ID0gNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovO1xuICAgICAgdGhpcy5wYXRoc1tpbmRleF0uekluZGV4U3ViT3JkZXIgPSB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJwYXRoc1wiLCBpbmRleCk7XG4gICAgICB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZCh0aGlzLnBhdGhzW2luZGV4XSk7XG4gICAgfVxuICAgIHRoaXMuZGF0dW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5kYXRhTm9kZUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvblxuICAgICk7XG4gICAgdGhpcy5tYXJrZXJTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5tYXJrZXJHcm91cCxcbiAgICAgICgpID0+IHRoaXMubWFya2VyRmFjdG9yeSgpLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICApO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgICB1cGRhdGU6IChkYXRhKSA9PiB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICBnZXQgY29udGV4dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gIH1cbiAgZ2V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcImRpc2FibGVkXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImRpc2FibGVcIik7XG4gICAgfVxuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihcImxlZ2VuZC1pdGVtLWNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1DbGljayhldmVudCkpLFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgIFwibGVnZW5kLWl0ZW0tZG91YmxlLWNsaWNrXCIsXG4gICAgICAgIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1Eb3VibGVDbGljayhldmVudClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2NvbnRleHROb2RlRGF0YSA9IHZvaWQgMDtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCB7IHZpc2libGUsIF9jb250ZXh0Tm9kZURhdGE6IHByZXZpb3VzQ29udGV4dERhdGEgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWVzID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk/LnNlcmllcztcbiAgICBjb25zdCBzZXJpZXNIaWdobGlnaHRlZCA9IHNlcmllcyA9PT0gdGhpcztcbiAgICBjb25zdCByZXNpemUgPSB0aGlzLmNoZWNrUmVzaXplKHNlcmllc1JlY3QpO1xuICAgIGNvbnN0IGhpZ2hsaWdodEl0ZW1zID0gYXdhaXQgdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb24oc2VyaWVzSGlnaGxpZ2h0ZWQpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucyh2aXNpYmxlKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKGhpZ2hsaWdodEl0ZW1zLCBzZXJpZXNIaWdobGlnaHRlZCwgdmlzaWJsZSk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHRoaXMuZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0LCBwcmV2aW91c0NvbnRleHREYXRhKTtcbiAgICBpZiAoIWFuaW1hdGlvbkRhdGEpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzaXplXCIsIGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlU2VsZWN0aW9ucyhhbnlTZXJpZXNJdGVtRW5hYmxlZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbmltYXRpb25Ta2lwVXBkYXRlID0gIXRoaXMub3B0cy5hbmltYXRpb25BbHdheXNVcGRhdGVTZWxlY3Rpb25zICYmIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgaWYgKCFhbnlTZXJpZXNJdGVtRW5hYmxlZCAmJiBhbmltYXRpb25Ta2lwVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5ub2RlRGF0YVJlZnJlc2ggJiYgIXRoaXMuaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vZGVEYXRhUmVmcmVzaCkge1xuICAgICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVidWcoYENhcnRlc2lhblNlcmllcy51cGRhdGVTZWxlY3Rpb25zKCkgLSBjYWxsaW5nIGNyZWF0ZU5vZGVEYXRhKCkgZm9yYCwgdGhpcy5pZCk7XG4gICAgICB0aGlzLm1hcmtRdWFkdHJlZURpcnR5KCk7XG4gICAgICB0aGlzLl9jb250ZXh0Tm9kZURhdGEgPSBhd2FpdCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCk7XG4gICAgICBjb25zdCBhbmltYXRpb25WYWxpZCA9IHRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpO1xuICAgICAgaWYgKHRoaXMuX2NvbnRleHROb2RlRGF0YSkge1xuICAgICAgICAoX2EgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGEpLmFuaW1hdGlvblZhbGlkID8/IChfYS5hbmltYXRpb25WYWxpZCA9IGFuaW1hdGlvblZhbGlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWluUmVjdHNDYWNoZS5kaXJ0eU5vZGVEYXRhID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgICAgaWYgKGRhdGFNb2RlbCAhPT0gdm9pZCAwICYmIHByb2Nlc3NlZERhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS11cGRhdGVcIiwgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VyaWVzU2VsZWN0aW9ucygpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlcmllc1NlbGVjdGlvbnMoc2VyaWVzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgbWFya2VyU2VsZWN0aW9uLCBwYXRocyB9ID0gdGhpcztcbiAgICBjb25zdCBjb250ZXh0RGF0YSA9IHRoaXMuX2NvbnRleHROb2RlRGF0YTtcbiAgICBpZiAoIWNvbnRleHREYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIGxhYmVsRGF0YSwgaXRlbUlkIH0gPSBjb250ZXh0RGF0YTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVBhdGhzKHsgc2VyaWVzSGlnaGxpZ2h0ZWQsIGl0ZW1JZCwgY29udGV4dERhdGEsIHBhdGhzIH0pO1xuICAgIHRoaXMuZGF0dW1TZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZURhdHVtU2VsZWN0aW9uKHsgbm9kZURhdGEsIGRhdHVtU2VsZWN0aW9uIH0pO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZUxhYmVsU2VsZWN0aW9uKHsgbGFiZWxEYXRhLCBsYWJlbFNlbGVjdGlvbiB9KTtcbiAgICBpZiAodGhpcy5vcHRzLmhhc01hcmtlcnMpIHtcbiAgICAgIHRoaXMubWFya2VyU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVNYXJrZXJTZWxlY3Rpb24oeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0pO1xuICAgIH1cbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSwgc3ViSW5kZXggPSAwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlLCBzdWJJbmRleCk7XG4gICAgaWYgKHR5cGUgPT09IFwicGF0aHNcIikge1xuICAgICAgY29uc3QgW3N1cGVyRm5dID0gcmVzdWx0O1xuICAgICAgY29uc3QgcGF0aE9mZnNldCA9IHRoaXMub3B0cy5wYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0W3N1YkluZGV4XSA/PyAwO1xuICAgICAgcmVzdWx0WzBdID0gaXNGdW5jdGlvbihzdXBlckZuKSA/ICgpID0+IE51bWJlcihzdXBlckZuKCkpICsgcGF0aE9mZnNldCA6IE51bWJlcihzdXBlckZuKSArIHBhdGhPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTm9kZXMoaGlnaGxpZ2h0ZWRJdGVtcywgc2VyaWVzSGlnaGxpZ2h0ZWQsIGFueVNlcmllc0l0ZW1FbmFibGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMsIGhhc0hpZ2hsaWdodGVkTGFiZWxzIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB0aGlzLl9jb250ZXh0Tm9kZURhdGEgIT0gbnVsbCAmJiBhbnlTZXJpZXNJdGVtRW5hYmxlZDtcbiAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnZpc2libGUgPSBhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gKGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZSkgJiYgc2VyaWVzSGlnaGxpZ2h0ZWQ7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZU1hcmtlck5vZGVzKHtcbiAgICAgICAgbWFya2VyU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICAgIGlzSGlnaGxpZ2h0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImhpZ2hsaWdodE1hcmtlcnNcIiwgaGlnaGxpZ2h0U2VsZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVEYXR1bU5vZGVzKHtcbiAgICAgICAgZGF0dW1TZWxlY3Rpb246IGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgICAgaXNIaWdobGlnaHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiaGlnaGxpZ2h0XCIsIGhpZ2hsaWdodFNlbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChoYXNIaWdobGlnaHRlZExhYmVscykge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVMYWJlbE5vZGVzKHsgbGFiZWxTZWxlY3Rpb246IGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGFOb2RlR3JvdXAsIG1hcmtlckdyb3VwLCBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIG1hcmtlclNlbGVjdGlvbiwgcGF0aHMsIGxhYmVsR3JvdXAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpdGVtSWQgfSA9IHRoaXMuY29udGV4dE5vZGVEYXRhID8/IHt9O1xuICAgIGRhdGFOb2RlR3JvdXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgZGF0YU5vZGVHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIGxhYmVsR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgIG1hcmtlckdyb3VwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgbWFya2VyR3JvdXAuekluZGV4ID0gZGF0YU5vZGVHcm91cC56SW5kZXggPj0gNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovID8gZGF0YU5vZGVHcm91cC56SW5kZXggOiBkYXRhTm9kZUdyb3VwLnpJbmRleCArIDE7XG4gICAgICBtYXJrZXJHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKGxhYmVsR3JvdXApIHtcbiAgICAgIGxhYmVsR3JvdXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlUGF0aE5vZGVzKHtcbiAgICAgIHNlcmllc0hpZ2hsaWdodGVkLFxuICAgICAgaXRlbUlkLFxuICAgICAgcGF0aHMsXG4gICAgICBvcGFjaXR5LFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9KTtcbiAgICBpZiAoIWRhdGFOb2RlR3JvdXAudmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZURhdHVtTm9kZXMoeyBkYXR1bVNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWRJdGVtcywgaXNIaWdobGlnaHQ6IGZhbHNlIH0pO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTGFiZWxOb2Rlcyh7IGxhYmVsU2VsZWN0aW9uIH0pO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZU1hcmtlck5vZGVzKHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogZmFsc2UgfSk7XG4gICAgfVxuICB9XG4gIGdldEhpZ2hsaWdodExhYmVsRGF0YShsYWJlbERhdGEsIGhpZ2hsaWdodGVkSXRlbSkge1xuICAgIGNvbnN0IGxhYmVsSXRlbXMgPSBsYWJlbERhdGEuZmlsdGVyKFxuICAgICAgKGxkKSA9PiBsZC5kYXR1bSA9PT0gaGlnaGxpZ2h0ZWRJdGVtLmRhdHVtICYmIGxkLml0ZW1JZCA9PT0gaGlnaGxpZ2h0ZWRJdGVtLml0ZW1JZFxuICAgICk7XG4gICAgcmV0dXJuIGxhYmVsSXRlbXMubGVuZ3RoID09PSAwID8gdm9pZCAwIDogbGFiZWxJdGVtcztcbiAgfVxuICBnZXRIaWdobGlnaHREYXRhKF9ub2RlRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkSXRlbSA/IFtoaWdobGlnaHRlZEl0ZW1dIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbihzZXJpZXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbiwgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dE5vZGVEYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0dW0gPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyPy5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCBpdGVtID0gc2VyaWVzSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uZGF0dW0gPyBoaWdobGlnaHRlZERhdHVtIDogdm9pZCAwO1xuICAgIGxldCBsYWJlbEl0ZW1zO1xuICAgIGxldCBoaWdobGlnaHRJdGVtcztcbiAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBsYWJlbHNFbmFibGVkID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpO1xuICAgICAgY29uc3QgeyBsYWJlbERhdGEsIG5vZGVEYXRhIH0gPSBjb250ZXh0Tm9kZURhdGE7XG4gICAgICBoaWdobGlnaHRJdGVtcyA9IHRoaXMuZ2V0SGlnaGxpZ2h0RGF0YShub2RlRGF0YSwgaXRlbSk7XG4gICAgICBsYWJlbEl0ZW1zID0gbGFiZWxzRW5hYmxlZCA/IHRoaXMuZ2V0SGlnaGxpZ2h0TGFiZWxEYXRhKGxhYmVsRGF0YSwgaXRlbSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25JdGVtKHtcbiAgICAgIGl0ZW1zOiBoaWdobGlnaHRJdGVtcyxcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvblxuICAgIH0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkxhYmVsKHtcbiAgICAgIGl0ZW1zOiBsYWJlbEl0ZW1zLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGxpZ2h0SXRlbXM7XG4gIH1cbiAgbWFya1F1YWR0cmVlRGlydHkoKSB7XG4gICAgdGhpcy5xdWFkdHJlZSA9IHZvaWQgMDtcbiAgfVxuICAqZGF0dW1Ob2Rlc0l0ZXIoKSB7XG4gICAgZm9yIChjb25zdCB7IG5vZGUgfSBvZiB0aGlzLmRhdHVtU2VsZWN0aW9uKSB7XG4gICAgICBpZiAobm9kZS5kYXR1bS5taXNzaW5nID09PSB0cnVlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG4gIGdldFF1YWRUcmVlKCkge1xuICAgIGlmICh0aGlzLnF1YWR0cmVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5jdHguc2NlbmUuY2FudmFzO1xuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IG5ldyBCQm94KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5xdWFkdHJlZSA9IG5ldyBRdWFkdHJlZU5lYXJlc3QoMTAwLCAxMCwgY2FudmFzUmVjdCk7XG4gICAgICB0aGlzLmluaXRRdWFkVHJlZSh0aGlzLnF1YWR0cmVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVhZHRyZWU7XG4gIH1cbiAgaW5pdFF1YWRUcmVlKF9xdWFkdHJlZSkge1xuICB9XG4gIHBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCB7IGRhdGFOb2RlR3JvdXAsIG1hcmtlckdyb3VwIH0gPSB0aGlzO1xuICAgIG1hdGNoID0gZGF0YU5vZGVHcm91cC5waWNrTm9kZSh4LCB5KTtcbiAgICBpZiAoIW1hdGNoICYmIGhhc01hcmtlcnMpIHtcbiAgICAgIG1hdGNoID0gbWFya2VyR3JvdXA/LnBpY2tOb2RlKHgsIHkpO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLmRhdHVtLCBkaXN0YW5jZTogMCB9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZDIgb2YgdGhpcy5tb2R1bGVNYXAubW9kdWxlcygpKSB7XG4gICAgICBjb25zdCB7IGRhdHVtIH0gPSBtb2QyLnBpY2tOb2RlRXhhY3QocG9pbnQpID8/IHt9O1xuICAgICAgaWYgKGRhdHVtID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGRhdHVtPy5taXNzaW5nID09PSB0cnVlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiB7IGRhdHVtLCBkaXN0YW5jZTogMCB9O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3QgeyBheGVzLCByb290R3JvdXAsIF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHROb2RlRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHROb2RlRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IGhpdFBvaW50ID0gcm9vdEdyb3VwLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCBjbG9zZXN0RGF0dW07XG4gICAgZm9yIChjb25zdCBkYXR1bSBvZiBjb250ZXh0Tm9kZURhdGEubm9kZURhdGEpIHtcbiAgICAgIGNvbnN0IHsgcG9pbnQ6IHsgeDogZGF0dW1YID0gTmFOLCB5OiBkYXR1bVkgPSBOYU4gfSA9IHt9IH0gPSBkYXR1bTtcbiAgICAgIGlmIChpc05hTihkYXR1bVgpIHx8IGlzTmFOKGRhdHVtWSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0luUmFuZ2UgPSB4QXhpcz8uaW5SYW5nZShkYXR1bVgpICYmIHlBeGlzPy5pblJhbmdlKGRhdHVtWSk7XG4gICAgICBpZiAoIWlzSW5SYW5nZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IE1hdGgubWF4KChoaXRQb2ludC54IC0gZGF0dW1YKSAqKiAyICsgKGhpdFBvaW50LnkgLSBkYXR1bVkpICoqIDIsIDApO1xuICAgICAgaWYgKGRpc3RhbmNlMyA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UzO1xuICAgICAgICBjbG9zZXN0RGF0dW0gPSBkYXR1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2QyIG9mIHRoaXMubW9kdWxlTWFwLm1vZHVsZXMoKSkge1xuICAgICAgY29uc3QgbW9kUGljayA9IG1vZDIucGlja05vZGVOZWFyZXN0KHBvaW50KTtcbiAgICAgIGlmIChtb2RQaWNrICE9PSB2b2lkIDAgJiYgbW9kUGljay5kaXN0YW5jZVNxdWFyZWQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkO1xuICAgICAgICBjbG9zZXN0RGF0dW0gPSBtb2RQaWNrLmRhdHVtO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsb3Nlc3REYXR1bSkge1xuICAgICAgY29uc3QgZGlzdGFuY2UzID0gTWF0aC5tYXgoTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKSAtIChjbG9zZXN0RGF0dW0ucG9pbnQ/LnNpemUgPz8gMCksIDApO1xuICAgICAgcmV0dXJuIHsgZGF0dW06IGNsb3Nlc3REYXR1bSwgZGlzdGFuY2U6IGRpc3RhbmNlMyB9O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZU1haW5BeGlzRmlyc3QocG9pbnQsIHJlcXVpcmVDYXRlZ29yeUF4aXMpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IHsgYXhlcywgcm9vdEdyb3VwLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXMgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWNvbnRleHROb2RlRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IGRpcmVjdGlvbnMyID0gW3hBeGlzLCB5QXhpc10uZmlsdGVyKChhKSA9PiBhIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzKS5tYXAoKGEpID0+IGEuZGlyZWN0aW9uKTtcbiAgICBpZiAocmVxdWlyZUNhdGVnb3J5QXhpcyAmJiBkaXJlY3Rpb25zMi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW21ham9yRGlyZWN0aW9uID0gXCJ4XCIgLyogWCAqL10gPSBkaXJlY3Rpb25zMjtcbiAgICBjb25zdCBoaXRQb2ludCA9IHJvb3RHcm91cC50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICBjb25zdCBoaXRQb2ludENvb3JkcyA9IFtoaXRQb2ludC54LCBoaXRQb2ludC55XTtcbiAgICBpZiAobWFqb3JEaXJlY3Rpb24gIT09IFwieFwiIC8qIFggKi8pXG4gICAgICBoaXRQb2ludENvb3Jkcy5yZXZlcnNlKCk7XG4gICAgY29uc3QgbWluRGlzdGFuY2UgPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBsZXQgY2xvc2VzdERhdHVtO1xuICAgIGZvciAoY29uc3QgZGF0dW0gb2YgY29udGV4dE5vZGVEYXRhLm5vZGVEYXRhKSB7XG4gICAgICBjb25zdCB7IHg6IGRhdHVtWCA9IE5hTiwgeTogZGF0dW1ZID0gTmFOIH0gPSBkYXR1bS5wb2ludCA/PyBkYXR1bS5taWRQb2ludCA/PyB7fTtcbiAgICAgIGlmIChpc05hTihkYXR1bVgpIHx8IGlzTmFOKGRhdHVtWSkgfHwgZGF0dW0ubWlzc2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpc2libGUgPSBbeEF4aXM/LmluUmFuZ2UoZGF0dW1YKSwgeUF4aXM/LmluUmFuZ2UoZGF0dW1ZKV07XG4gICAgICBpZiAobWFqb3JEaXJlY3Rpb24gIT09IFwieFwiIC8qIFggKi8pXG4gICAgICAgIHZpc2libGUucmV2ZXJzZSgpO1xuICAgICAgaWYgKCF2aXNpYmxlWzBdIHx8ICFwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXMgJiYgIXZpc2libGVbMV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXR1bVBvaW50ID0gW2RhdHVtWCwgZGF0dW1ZXTtcbiAgICAgIGlmIChtYWpvckRpcmVjdGlvbiAhPT0gXCJ4XCIgLyogWCAqLylcbiAgICAgICAgZGF0dW1Qb2ludC5yZXZlcnNlKCk7XG4gICAgICBsZXQgbmV3TWluRGlzdGFuY2UgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXR1bVBvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmFicyhkYXR1bVBvaW50W2ldIC0gaGl0UG9pbnRDb29yZHNbaV0pO1xuICAgICAgICBpZiAoZGlzdCA+IG1pbkRpc3RhbmNlW2ldKSB7XG4gICAgICAgICAgbmV3TWluRGlzdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlW2ldKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2VbaV0gPSBkaXN0O1xuICAgICAgICAgIG1pbkRpc3RhbmNlLmZpbGwoSW5maW5pdHksIGkgKyAxLCBtaW5EaXN0YW5jZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3TWluRGlzdGFuY2UpIHtcbiAgICAgICAgY2xvc2VzdERhdHVtID0gZGF0dW07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RGF0dW0pIHtcbiAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gTWF0aC5tYXgoXG4gICAgICAgIG1pbkRpc3RhbmNlWzBdICoqIDIgKyBtaW5EaXN0YW5jZVsxXSAqKiAyIC0gKGNsb3Nlc3REYXR1bS5wb2ludD8uc2l6ZSA/PyAwKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgbW9kMiBvZiB0aGlzLm1vZHVsZU1hcC5tb2R1bGVzKCkpIHtcbiAgICAgICAgY29uc3QgbW9kUGljayA9IG1vZDIucGlja05vZGVNYWluQXhpc0ZpcnN0KHBvaW50KTtcbiAgICAgICAgaWYgKG1vZFBpY2sgIT09IHZvaWQgMCAmJiBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZCA8IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgICBjbG9zZXN0RGF0dW0gPSBtb2RQaWNrLmRhdHVtO1xuICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0dW06IGNsb3Nlc3REYXR1bSwgZGlzdGFuY2U6IE1hdGguc3FydChjbG9zZXN0RGlzdGFuY2VTcXVhcmVkKSB9O1xuICAgIH1cbiAgfVxuICBvbkxlZ2VuZEl0ZW1DbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzIH0gPSBldmVudDtcbiAgICBjb25zdCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUgPSBsZWdlbmRJdGVtTmFtZSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1OYW1lID09PSBldmVudC5sZWdlbmRJdGVtTmFtZTtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkIHx8IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgfVxuICB9XG4gIG9uTGVnZW5kSXRlbURvdWJsZUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcywgbnVtVmlzaWJsZUl0ZW1zIH0gPSBldmVudDtcbiAgICBjb25zdCB7IGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lID0gbGVnZW5kSXRlbU5hbWUgIT0gbnVsbCAmJiBsZWdlbmRJdGVtTmFtZSA9PT0gZXZlbnQubGVnZW5kSXRlbU5hbWU7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCB8fCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZW5hYmxlZCAmJiBudW1WaXNpYmxlSXRlbXMgPT09IDEpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc2hvdWxkRmxpcFhZKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGFueSBhZGphY2VudCB0d28gbm9kZXMuIFRoZSBheGVzIGFyZSB0cmVhdGVkIGluZGVwZW5kZW50bHksIHNvIHRoaXNcbiAgICogbWF5IG5vdCByZXByZXNlbnQgdGhlIHNhbWUgdHdvIHBvaW50cyBmb3IgYm90aCBkaXJlY3Rpb25zLiBUaGUgZGltZW5zaW9ucyByZXByZXNlbnQgdGhlIGdyZWF0ZXN0IGRpc3RhbmNlXG4gICAqIGJldHdlZW4gYW55IHR3byBhZGphY2VudCBub2Rlcy5cbiAgICovXG4gIGdldE1pblJlY3RzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7IGRpcnR5Tm9kZURhdGEsIHNpemVDYWNoZSwgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfSA9IHRoaXMubWluUmVjdHNDYWNoZTtcbiAgICBjb25zdCBuZXdTaXplQ2FjaGUgPSBKU09OLnN0cmluZ2lmeSh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgY29uc3QgZGlydHlTaXplID0gbmV3U2l6ZUNhY2hlICE9PSBzaXplQ2FjaGU7XG4gICAgaWYgKCFkaXJ0eVNpemUgJiYgIWRpcnR5Tm9kZURhdGEgJiYgbWluUmVjdCAmJiBtaW5WaXNpYmxlUmVjdCkge1xuICAgICAgcmV0dXJuIHsgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfTtcbiAgICB9XG4gICAgY29uc3QgcmVjdHMgPSB0aGlzLmNvbXB1dGVNaW5SZWN0cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLm1pblJlY3RzQ2FjaGUgPSB7XG4gICAgICBkaXJ0eU5vZGVEYXRhOiBmYWxzZSxcbiAgICAgIHNpemVDYWNoZTogbmV3U2l6ZUNhY2hlLFxuICAgICAgbWluUmVjdDogcmVjdHM/Lm1pblJlY3QsXG4gICAgICBtaW5WaXNpYmxlUmVjdDogcmVjdHM/Lm1pblZpc2libGVSZWN0XG4gICAgfTtcbiAgICByZXR1cm4gcmVjdHM7XG4gIH1cbiAgY29tcHV0ZU1pblJlY3RzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dE5vZGVEYXRhO1xuICAgIGlmICghY29udGV4dD8ubm9kZURhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgbm9kZURhdGEgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbWluUmVjdFhzID0gQXJyYXkobm9kZURhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBtaW5SZWN0WXMgPSBBcnJheShub2RlRGF0YS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3QgW2ksIHsgbWlkUG9pbnQgfV0gb2Ygbm9kZURhdGEuZW50cmllcygpKSB7XG4gICAgICBtaW5SZWN0WHNbaV0gPSBtaWRQb2ludD8ueCA/PyAwO1xuICAgICAgbWluUmVjdFlzW2ldID0gbWlkUG9pbnQ/LnkgPz8gMDtcbiAgICB9XG4gICAgbWluUmVjdFhzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBtaW5SZWN0WXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGxldCB6ZXJvWCwgd2lkdGhYLCB6ZXJvWSwgaGVpZ2h0WTtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtaW5SZWN0WHNbaV0gPj0gMClcbiAgICAgICAgemVyb1ggPz8gKHplcm9YID0gaSk7XG4gICAgICBpZiAobWluUmVjdFhzW2ldID4gd2lkdGgpXG4gICAgICAgIHdpZHRoWCA/PyAod2lkdGhYID0gaSk7XG4gICAgICBpZiAobWluUmVjdFlzW2ldID49IDApXG4gICAgICAgIHplcm9ZID8/ICh6ZXJvWSA9IGkpO1xuICAgICAgaWYgKG1pblJlY3RZc1tpXSA+IGhlaWdodClcbiAgICAgICAgaGVpZ2h0WSA/PyAoaGVpZ2h0WSA9IGkpO1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgbWluUmVjdFhzW2ldIC0gbWluUmVjdFhzW2kgLSAxXSk7XG4gICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIG1pblJlY3RZc1tpXSAtIG1pblJlY3RZc1tpIC0gMV0pO1xuICAgIH1cbiAgICB3aWR0aFggPz8gKHdpZHRoWCA9IG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgaGVpZ2h0WSA/PyAoaGVpZ2h0WSA9IG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgY29uc3QgbWluVmlzaWJsZVJlY3RYcyA9IHplcm9YICE9IG51bGwgJiYgd2lkdGhYICE9IG51bGwgPyBtaW5SZWN0WHMuc2xpY2UoemVyb1gsIHdpZHRoWCkgOiBbXTtcbiAgICBjb25zdCBtaW5WaXNpYmxlUmVjdFlzID0gemVyb1kgIT0gbnVsbCAmJiBoZWlnaHRZICE9IG51bGwgPyBtaW5SZWN0WXMuc2xpY2UoemVyb1ksIGhlaWdodFkpIDogW107XG4gICAgbGV0IG1heFZpc2libGVXaWR0aCA9IDA7XG4gICAgbGV0IG1heFZpc2libGVIZWlnaHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5tYXgobWluVmlzaWJsZVJlY3RYcy5sZW5ndGgsIG1pblZpc2libGVSZWN0WXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCB4MSA9IG1pblZpc2libGVSZWN0WHNbaV07XG4gICAgICBjb25zdCB4MiA9IG1pblZpc2libGVSZWN0WHNbaSAtIDFdO1xuICAgICAgY29uc3QgeTEgPSBtaW5WaXNpYmxlUmVjdFlzW2ldO1xuICAgICAgY29uc3QgeTIgPSBtaW5WaXNpYmxlUmVjdFlzW2kgLSAxXTtcbiAgICAgIGlmICh4MSAhPSBudWxsICYmIHgyICE9IG51bGwpIHtcbiAgICAgICAgbWF4VmlzaWJsZVdpZHRoID0gTWF0aC5tYXgobWF4VmlzaWJsZVdpZHRoLCB4MSAtIHgyKTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSAhPSBudWxsICYmIHkyICE9IG51bGwpIHtcbiAgICAgICAgbWF4VmlzaWJsZUhlaWdodCA9IE1hdGgubWF4KG1heFZpc2libGVIZWlnaHQsIHkxIC0geTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtaW5SZWN0ID0gbmV3IEJCb3goMCwgMCwgbWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgY29uc3QgbWluVmlzaWJsZVJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhWaXNpYmxlV2lkdGgsIG1heFZpc2libGVIZWlnaHQpO1xuICAgIHJldHVybiB7IG1pblJlY3QsIG1pblZpc2libGVSZWN0IH07XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uSXRlbShvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBoYXNNYXJrZXJzIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGl0ZW1zLCBoaWdobGlnaHRTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBpdGVtcyA/PyBbXTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgY29uc3QgbWFya2VyU2VsZWN0aW9uID0gaGlnaGxpZ2h0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGF0dW1TZWxlY3Rpb24oe1xuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgZGF0dW1TZWxlY3Rpb246IGhpZ2hsaWdodFNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkxhYmVsKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7XG4gICAgICBsYWJlbERhdGE6IG9wdHMuaXRlbXMgPz8gW10sXG4gICAgICBsYWJlbFNlbGVjdGlvbjogb3B0cy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5kYXR1bVNlbGVjdGlvbjtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bU5vZGVzKF9vcHRzKSB7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5tYXJrZXJTZWxlY3Rpb247XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMoX29wdHMpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRocyhvcHRzKSB7XG4gICAgb3B0cy5wYXRocy5mb3JFYWNoKChwKSA9PiBwLnZpc2libGUgPSBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IHBhdGhzLCBvcGFjaXR5LCB2aXNpYmxlIH0gPSBvcHRzO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgcGF0aC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIHBhdGgudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG4gIHJlc2V0UGF0aEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBkYXRhLnBhdGhzLmZvckVhY2goKHBhdGhzKSA9PiB7XG4gICAgICAgIHJlc2V0TW90aW9uKFtwYXRoc10sIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlc2V0RGF0dW1BbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGRhdHVtKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YS5kYXR1bVNlbGVjdGlvbl0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRMYWJlbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhLmxhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgfVxuICByZXNldE1hcmtlckFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKG1hcmtlciAmJiB0aGlzLm9wdHMuaGFzTWFya2Vycykge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGEubWFya2VyU2VsZWN0aW9uXSwgbWFya2VyKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRBbGxBbmltYXRpb24oZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICB0aGlzLnJlc2V0UGF0aEFuaW1hdGlvbihkYXRhKTtcbiAgICB0aGlzLnJlc2V0RGF0dW1BbmltYXRpb24oZGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGRhdGEpO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oZGF0YSk7XG4gICAgaWYgKGRhdGEuY29udGV4dERhdGE/LmFuaW1hdGlvblZhbGlkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChkYXR1bSkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChtYXJrZXIpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgbWFya2VyKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0gdGhpcy5nZXRBbmltYXRpb25EYXRhKCk7XG4gICAgaWYgKCFhbmltYXRpb25EYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImNsZWFyXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgX2NvbnRleHROb2RlRGF0YTogY29udGV4dERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0RGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0ge1xuICAgICAgZGF0dW1TZWxlY3Rpb246IHRoaXMuZGF0dW1TZWxlY3Rpb24sXG4gICAgICBtYXJrZXJTZWxlY3Rpb246IHRoaXMubWFya2VyU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb246IHRoaXMubGFiZWxTZWxlY3Rpb24sXG4gICAgICBhbm5vdGF0aW9uU2VsZWN0aW9uczogWy4uLnRoaXMuYW5ub3RhdGlvblNlbGVjdGlvbnNdLFxuICAgICAgY29udGV4dERhdGEsXG4gICAgICBwcmV2aW91c0NvbnRleHREYXRhLFxuICAgICAgcGF0aHM6IHRoaXMucGF0aHMsXG4gICAgICBzZXJpZXNSZWN0XG4gICAgfTtcbiAgICByZXR1cm4gYW5pbWF0aW9uRGF0YTtcbiAgfVxuICBjYWxjdWxhdGVTY2FsaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgZGlyZWN0aW9uIG9mIE9iamVjdC52YWx1ZXMoQ2hhcnRBeGlzRGlyZWN0aW9uKSkge1xuICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICAgICAgaWYgKCFheGlzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChheGlzLnNjYWxlIGluc3RhbmNlb2YgTG9nU2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyByYW5nZTogcmFuZ2UzLCBkb21haW4gfSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHJlc3VsdFtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgIHR5cGU6IFwibG9nXCIsXG4gICAgICAgICAgY29udmVydDogKGQpID0+IGF4aXMuc2NhbGUuY29udmVydChkKSxcbiAgICAgICAgICBkb21haW46IFtkb21haW5bMF0sIGRvbWFpblsxXV0sXG4gICAgICAgICAgcmFuZ2U6IFtyYW5nZTNbMF0sIHJhbmdlM1sxXV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcy5zY2FsZSBpbnN0YW5jZW9mIENvbnRpbnVvdXNTY2FsZSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGF4aXMuc2NhbGUuZ2V0RG9tYWluKCk7XG4gICAgICAgIHJlc3VsdFtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgIHR5cGU6IFwiY29udGludW91c1wiLFxuICAgICAgICAgIGRvbWFpbjogW2RvbWFpblswXSwgZG9tYWluWzFdXSxcbiAgICAgICAgICByYW5nZTogW3JhbmdlM1swXSwgcmFuZ2UzWzFdXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChheGlzLnNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgICAgZG9tYWluLFxuICAgICAgICAgIHJhbmdlOiBkb21haW4ubWFwKChkKSA9PiBheGlzLnNjYWxlLmNvbnZlcnQoZCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NhcnRlc2lhbkNoYXJ0LnRzXG52YXIgZGlyZWN0aW9ucyA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbnZhciBDYXJ0ZXNpYW5DaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIC8qKiBJbnRlZ3JhdGVkIENoYXJ0cyBmZWF0dXJlIHN0YXRlIC0gbm90IHVzZWQgaW4gU3RhbmRhbG9uZSBDaGFydHMuICovXG4gICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xuICAgIHRoaXMuZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5fbGFzdENyb3NzTGluZUlkcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0QXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2xhc3RDbGlwU2VyaWVzID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdFZpc2liaWxpdHkgPSB7XG4gICAgICBjcm9zc0xpbmVzOiB0cnVlLFxuICAgICAgc2VyaWVzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBvbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgc3VwZXIub25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgdGhpcy56b29tTWFuYWdlci51cGRhdGVBeGVzKG5ld1ZhbHVlKTtcbiAgfVxuICBkZXN0cm95U2VyaWVzKHNlcmllcykge1xuICAgIHN1cGVyLmRlc3Ryb3lTZXJpZXMoc2VyaWVzKTtcbiAgICB0aGlzLmZpcnN0U2VyaWVzVHJhbnNsYXRpb24gPSB0cnVlO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJjYXJ0ZXNpYW5cIjtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KCkge1xuICAgIGNvbnN0IHNocmlua1JlY3QgPSBhd2FpdCBzdXBlci5wZXJmb3JtTGF5b3V0KCk7XG4gICAgY29uc3QgeyBmaXJzdFNlcmllc1RyYW5zbGF0aW9uLCBzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvblJlY3QsIHNlcmllc1JlY3QsIHZpc2liaWxpdHksIGNsaXBTZXJpZXMgfSA9IHRoaXMudXBkYXRlQXhlcyhzaHJpbmtSZWN0KTtcbiAgICB0aGlzLnNlcmllc1Jvb3QudmlzaWJsZSA9IHZpc2liaWxpdHkuc2VyaWVzO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNlcmllc1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gYW5pbWF0aW9uUmVjdDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHNlcmllc1JlY3Q7XG4gICAgaWYgKGZpcnN0U2VyaWVzVHJhbnNsYXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJzdFNlcmllc1RyYW5zbGF0aW9uID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHNlcmllc1Jvb3Q7XG4gICAgICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgICAgIHRoaXMuaWQsXG4gICAgICAgIFwic2VyaWVzUmVjdFwiLFxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgICBbc2VyaWVzUm9vdCwgaGlnaGxpZ2h0Um9vdCwgYW5ub3RhdGlvblJvb3RdLFxuICAgICAgICB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0sXG4gICAgICAgIHsgdHJhbnNsYXRpb25YOiBNYXRoLmZsb29yKHgpLCB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IoeSkgfSxcbiAgICAgICAgeyBwaGFzZTogXCJ1cGRhdGVcIiB9XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBzZXJpZXNQYWRkZWRSZWN0ID0gc2VyaWVzUmVjdC5jbG9uZSgpLmdyb3codGhpcy5zZXJpZXNBcmVhLnBhZGRpbmcpO1xuICAgIGNvbnN0IGNsaXBSZWN0ID0gdGhpcy5zZXJpZXNBcmVhLmNsaXAgfHwgY2xpcFNlcmllcyA/IHNlcmllc1BhZGRlZFJlY3QgOiB2b2lkIDA7XG4gICAgc2VyaWVzUm9vdC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoY2xpcFJlY3QpO1xuICAgIGhpZ2hsaWdodFJvb3Quc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKGNsaXBSZWN0KTtcbiAgICBhbm5vdGF0aW9uUm9vdC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoY2xpcFJlY3QpO1xuICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZSh7XG4gICAgICB0eXBlOiBcImxheW91dC1jb21wbGV0ZVwiLFxuICAgICAgY2hhcnQ6IHsgd2lkdGg6IHRoaXMuY3R4LnNjZW5lLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3R4LnNjZW5lLmhlaWdodCB9LFxuICAgICAgY2xpcFNlcmllcyxcbiAgICAgIHNlcmllczoge1xuICAgICAgICByZWN0OiBzZXJpZXNSZWN0LFxuICAgICAgICBwYWRkZWRSZWN0OiBzZXJpZXNQYWRkZWRSZWN0LFxuICAgICAgICB2aXNpYmxlOiB2aXNpYmlsaXR5LnNlcmllcyxcbiAgICAgICAgc2hvdWxkRmxpcFhZOiB0aGlzLnNob3VsZEZsaXBYWSgpXG4gICAgICB9LFxuICAgICAgYXhlczogdGhpcy5heGVzLm1hcCgoYXhpcykgPT4gYXhpcy5nZXRMYXlvdXRTdGF0ZSgpKVxuICAgIH0pO1xuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gdGhpcy5tb2R1bGVzTWFuYWdlci5tYXBNb2R1bGVzKChtKSA9PiBtLnBlcmZvcm1DYXJ0ZXNpYW5MYXlvdXQ/Lih7IHNlcmllc1JlY3QgfSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZVByb21pc2VzKTtcbiAgICByZXR1cm4gc2hyaW5rUmVjdDtcbiAgfVxuICB1cGRhdGVBeGVzKGlucHV0U2hyaW5rUmVjdCkge1xuICAgIGNvbnN0IGNyb3NzTGluZUlkcyA9IHRoaXMuYXhlcy5mbGF0TWFwKChheGlzKSA9PiBheGlzLmNyb3NzTGluZXMgPz8gW10pLm1hcCgoY3Jvc3NMaW5lKSA9PiBjcm9zc0xpbmUuaWQpO1xuICAgIGNvbnN0IGF4ZXNWYWxpZCA9IHRoaXMuX2xhc3RDcm9zc0xpbmVJZHMgIT0gbnVsbCAmJiB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzLmxlbmd0aCA9PT0gY3Jvc3NMaW5lSWRzLmxlbmd0aCAmJiB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzLmV2ZXJ5KChpZCwgaW5kZXgpID0+IGNyb3NzTGluZUlkc1tpbmRleF0gPT09IGlkKTtcbiAgICBsZXQgYXhpc0FyZWFXaWR0aHM7XG4gICAgbGV0IGNsaXBTZXJpZXM7XG4gICAgbGV0IHZpc2liaWxpdHk7XG4gICAgaWYgKGF4ZXNWYWxpZCkge1xuICAgICAgYXhpc0FyZWFXaWR0aHMgPSBuZXcgTWFwKHRoaXMuX2xhc3RBeGlzQXJlYVdpZHRocy5lbnRyaWVzKCkpO1xuICAgICAgY2xpcFNlcmllcyA9IHRoaXMuX2xhc3RDbGlwU2VyaWVzO1xuICAgICAgdmlzaWJpbGl0eSA9IHsgLi4udGhpcy5fbGFzdFZpc2liaWxpdHkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY2xpcFNlcmllcyA9IGZhbHNlO1xuICAgICAgdmlzaWJpbGl0eSA9IHsgY3Jvc3NMaW5lczogdHJ1ZSwgc2VyaWVzOiB0cnVlIH07XG4gICAgICB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzID0gY3Jvc3NMaW5lSWRzO1xuICAgIH1cbiAgICBjb25zdCBsaXZlQXhpc1dpZHRocyA9IG5ldyBTZXQodGhpcy5heGVzLm1hcCgoYSkgPT4gYS5wb3NpdGlvbikpO1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgYXhpc0FyZWFXaWR0aHMua2V5cygpKSB7XG4gICAgICBpZiAoIWxpdmVBeGlzV2lkdGhzLmhhcyhwb3NpdGlvbikpIHtcbiAgICAgICAgYXhpc0FyZWFXaWR0aHMuZGVsZXRlKHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhYmxlT3V0cHV0cyA9IChvdGhlckF4aXNXaWR0aHMsIG90aGVyQ2xpcFNlcmllcywgb3RoZXJWaXNpYmlsaXR5KSA9PiB7XG4gICAgICBpZiAoWy4uLm90aGVyQXhpc1dpZHRocy5rZXlzKCldLnNvbWUoKGspID0+ICFheGlzQXJlYVdpZHRocy5oYXMoaykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmlsaXR5LmNyb3NzTGluZXMgIT09IG90aGVyVmlzaWJpbGl0eS5jcm9zc0xpbmVzIHx8IHZpc2liaWxpdHkuc2VyaWVzICE9PSBvdGhlclZpc2liaWxpdHkuc2VyaWVzIHx8IGNsaXBTZXJpZXMgIT09IG90aGVyQ2xpcFNlcmllcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLmF4aXNBcmVhV2lkdGhzLmVudHJpZXMoKV0uZXZlcnkoKFtwLCB3XSkgPT4ge1xuICAgICAgICBjb25zdCBvdGhlclcgPSBvdGhlckF4aXNXaWR0aHMuZ2V0KHApO1xuICAgICAgICBpZiAodyAhPSBudWxsIHx8IG90aGVyVyAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHcgPT09IG90aGVyVztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2VpbFZhbHVlcyA9IChtYXApID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIE1hdGguYWJzKHZhbHVlKSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgMCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlICE9IG51bGwgPyBNYXRoLmNlaWwodmFsdWUpIDogdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIGxldCBsYXN0UGFzc0F4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgbGFzdFBhc3NWaXNpYmlsaXR5ID0ge307XG4gICAgbGV0IGxhc3RQYXNzQ2xpcFNlcmllcyA9IGZhbHNlO1xuICAgIGxldCBzZXJpZXNSZWN0ID0gdGhpcy5zZXJpZXNSZWN0Py5jbG9uZSgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IHByaW1hcnlUaWNrQ291bnRzID0ge307XG4gICAgZG8ge1xuICAgICAgYXhpc0FyZWFXaWR0aHMgPSBuZXcgTWFwKGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMuZW50cmllcygpKTtcbiAgICAgIGNsaXBTZXJpZXMgPSBsYXN0UGFzc0NsaXBTZXJpZXM7XG4gICAgICBPYmplY3QuYXNzaWduKHZpc2liaWxpdHksIGxhc3RQYXNzVmlzaWJpbGl0eSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVwZGF0ZUF4ZXNQYXNzKGF4aXNBcmVhV2lkdGhzLCBpbnB1dFNocmlua1JlY3QuY2xvbmUoKSwgc2VyaWVzUmVjdCk7XG4gICAgICBsYXN0UGFzc0F4aXNBcmVhV2lkdGhzID0gY2VpbFZhbHVlcyhyZXN1bHQuYXhpc0FyZWFXaWR0aHMpO1xuICAgICAgbGFzdFBhc3NWaXNpYmlsaXR5ID0gcmVzdWx0LnZpc2liaWxpdHk7XG4gICAgICBsYXN0UGFzc0NsaXBTZXJpZXMgPSByZXN1bHQuY2xpcFNlcmllcztcbiAgICAgICh7IHNlcmllc1JlY3QsIHByaW1hcnlUaWNrQ291bnRzIH0gPSByZXN1bHQpO1xuICAgICAgaWYgKGNvdW50KysgPiAxMCkge1xuICAgICAgICBMb2dnZXIud2FybihcInVuYWJsZSB0byBmaW5kIHN0YWJsZSBheGlzIGxheW91dC5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCFzdGFibGVPdXRwdXRzKGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMsIGxhc3RQYXNzQ2xpcFNlcmllcywgbGFzdFBhc3NWaXNpYmlsaXR5KSk7XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMudXBkYXRlKHByaW1hcnlUaWNrQ291bnRzW2F4aXMuZGlyZWN0aW9uXSk7XG4gICAgfSk7XG4gICAgY29uc3QgY2xpcFJlY3RQYWRkaW5nID0gNTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy5zZXRDcm9zc0xpbmVzVmlzaWJsZSh2aXNpYmlsaXR5LmNyb3NzTGluZXMpO1xuICAgICAgaWYgKCFzZXJpZXNSZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF4aXMuY2xpcEdyaWQoXG4gICAgICAgIHNlcmllc1JlY3QueCxcbiAgICAgICAgc2VyaWVzUmVjdC55LFxuICAgICAgICBzZXJpZXNSZWN0LndpZHRoICsgY2xpcFJlY3RQYWRkaW5nLFxuICAgICAgICBzZXJpZXNSZWN0LmhlaWdodCArIGNsaXBSZWN0UGFkZGluZ1xuICAgICAgKTtcbiAgICAgIHN3aXRjaCAoYXhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICBheGlzLmNsaXBUaWNrTGluZXMoXG4gICAgICAgICAgICBpbnB1dFNocmlua1JlY3QueCxcbiAgICAgICAgICAgIHNlcmllc1JlY3QueSxcbiAgICAgICAgICAgIGlucHV0U2hyaW5rUmVjdC53aWR0aCArIGNsaXBSZWN0UGFkZGluZyxcbiAgICAgICAgICAgIHNlcmllc1JlY3QuaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgYXhpcy5jbGlwVGlja0xpbmVzKFxuICAgICAgICAgICAgc2VyaWVzUmVjdC54LFxuICAgICAgICAgICAgaW5wdXRTaHJpbmtSZWN0LnksXG4gICAgICAgICAgICBzZXJpZXNSZWN0LndpZHRoICsgY2xpcFJlY3RQYWRkaW5nLFxuICAgICAgICAgICAgaW5wdXRTaHJpbmtSZWN0LmhlaWdodCArIGNsaXBSZWN0UGFkZGluZ1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdEF4aXNBcmVhV2lkdGhzID0gYXhpc0FyZWFXaWR0aHM7XG4gICAgdGhpcy5fbGFzdFZpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuICAgIHRoaXMuX2xhc3RDbGlwU2VyaWVzID0gY2xpcFNlcmllcztcbiAgICByZXR1cm4geyBzZXJpZXNSZWN0LCBhbmltYXRpb25SZWN0OiBpbnB1dFNocmlua1JlY3QsIHZpc2liaWxpdHksIGNsaXBTZXJpZXMgfTtcbiAgfVxuICB1cGRhdGVBeGVzUGFzcyhheGlzQXJlYVdpZHRocywgYm91bmRzLCBsYXN0UGFzc1Nlcmllc1JlY3QpIHtcbiAgICBjb25zdCBheGlzV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBheGlzR3JvdXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCB2aXNpYmlsaXR5ID0ge1xuICAgICAgc2VyaWVzOiB0cnVlLFxuICAgICAgY3Jvc3NMaW5lczogdHJ1ZVxuICAgIH07XG4gICAgbGV0IGNsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICBjb25zdCBwcmltYXJ5VGlja0NvdW50cyA9IHt9O1xuICAgIGNvbnN0IHBhZGRlZEJvdW5kcyA9IHRoaXMuYXBwbHlTZXJpZXNQYWRkaW5nKGJvdW5kcyk7XG4gICAgY29uc3QgY3Jvc3NMaW5lUGFkZGluZyA9IGxhc3RQYXNzU2VyaWVzUmVjdCA/IHRoaXMuYnVpbGRDcm9zc0xpbmVQYWRkaW5nKGF4aXNBcmVhV2lkdGhzKSA6IHt9O1xuICAgIGNvbnN0IGF4aXNBcmVhQm91bmQgPSB0aGlzLmJ1aWxkQXhpc0JvdW5kKHBhZGRlZEJvdW5kcywgYXhpc0FyZWFXaWR0aHMsIGNyb3NzTGluZVBhZGRpbmcsIHZpc2liaWxpdHkpO1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSB0aGlzLmJ1aWxkU2VyaWVzUmVjdChheGlzQXJlYUJvdW5kLCBheGlzQXJlYVdpZHRocyk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcykge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbiA9IFwibGVmdFwiIH0gPSBheGlzO1xuICAgICAgY29uc3QgeyBjbGlwU2VyaWVzOiBuZXdDbGlwU2VyaWVzLCBheGlzVGhpY2tuZXNzIH0gPSB0aGlzLmNhbGN1bGF0ZUF4aXNEaW1lbnNpb25zKHtcbiAgICAgICAgYXhpcyxcbiAgICAgICAgc2VyaWVzUmVjdCxcbiAgICAgICAgcGFkZGVkQm91bmRzLFxuICAgICAgICBwcmltYXJ5VGlja0NvdW50cyxcbiAgICAgICAgY2xpcFNlcmllc1xuICAgICAgfSk7XG4gICAgICBheGlzV2lkdGhzLnNldChheGlzLmlkLCBheGlzVGhpY2tuZXNzKTtcbiAgICAgIGlmICghYXhpc0dyb3Vwcy5oYXMocG9zaXRpb24pKVxuICAgICAgICBheGlzR3JvdXBzLnNldChwb3NpdGlvbiwgW10pO1xuICAgICAgYXhpc0dyb3Vwcy5nZXQocG9zaXRpb24pPy5wdXNoKGF4aXMpO1xuICAgICAgY2xpcFNlcmllcyA9IGNsaXBTZXJpZXMgfHwgbmV3Q2xpcFNlcmllcztcbiAgICB9XG4gICAgY29uc3QgbmV3QXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGF4aXNPZmZzZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtwb3NpdGlvbiwgYXhlc10gb2YgYXhpc0dyb3Vwcy5lbnRyaWVzKCkpIHtcbiAgICAgIG5ld0F4aXNBcmVhV2lkdGhzLnNldChwb3NpdGlvbiwgdGhpcy5jYWxjdWxhdGVBeGlzQXJlYShheGVzLCBheGlzV2lkdGhzLCBheGlzT2Zmc2V0cykpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtwb3NpdGlvbiwgYXhlc10gb2YgYXhpc0dyb3Vwcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMucG9zaXRpb25BeGVzKHtcbiAgICAgICAgYXhlcyxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGF4aXNXaWR0aHMsXG4gICAgICAgIGF4aXNPZmZzZXRzLFxuICAgICAgICBheGlzQXJlYVdpZHRoczogbmV3QXhpc0FyZWFXaWR0aHMsXG4gICAgICAgIGF4aXNCb3VuZDogYXhpc0FyZWFCb3VuZCxcbiAgICAgICAgc2VyaWVzUmVjdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNsaXBTZXJpZXMsIHNlcmllc1JlY3QsIGF4aXNBcmVhV2lkdGhzOiBuZXdBeGlzQXJlYVdpZHRocywgdmlzaWJpbGl0eSwgcHJpbWFyeVRpY2tDb3VudHMgfTtcbiAgfVxuICBidWlsZENyb3NzTGluZVBhZGRpbmcoYXhpc0FyZWFTaXplKSB7XG4gICAgY29uc3QgY3Jvc3NMaW5lUGFkZGluZyA9IHt9O1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLmNyb3NzTGluZXM/LmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlUGFkZGluZz8uKGNyb3NzTGluZVBhZGRpbmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbc2lkZSwgcGFkZGluZyA9IDBdIG9mIE9iamVjdC5lbnRyaWVzKGNyb3NzTGluZVBhZGRpbmcpKSB7XG4gICAgICBjcm9zc0xpbmVQYWRkaW5nW3NpZGVdID0gTWF0aC5tYXgocGFkZGluZyAtIChheGlzQXJlYVNpemUuZ2V0KHNpZGUpID8/IDApLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyb3NzTGluZVBhZGRpbmc7XG4gIH1cbiAgYXBwbHlTZXJpZXNQYWRkaW5nKGJvdW5kcykge1xuICAgIGNvbnN0IHBhZGRlZFJlY3QgPSBib3VuZHMuY2xvbmUoKTtcbiAgICBjb25zdCByZXZlcnNlZEF4ZXMgPSB0aGlzLmF4ZXMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgZGlyZWN0aW9ucy5mb3JFYWNoKChkaXIpID0+IHtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnNlcmllc0FyZWEucGFkZGluZ1tkaXJdO1xuICAgICAgY29uc3QgYXhpcyA9IHJldmVyc2VkQXhlcy5maW5kKChhKSA9PiBhLnBvc2l0aW9uID09PSBkaXIpO1xuICAgICAgaWYgKGF4aXMpIHtcbiAgICAgICAgYXhpcy5zZXJpZXNBcmVhUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRkZWRSZWN0LnNocmluayhwYWRkaW5nLCBkaXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYWRkZWRSZWN0O1xuICB9XG4gIGJ1aWxkQXhpc0JvdW5kKGJvdW5kcywgYXhpc0FyZWFXaWR0aHMsIGNyb3NzTGluZVBhZGRpbmcsIHZpc2liaWxpdHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBib3VuZHMuY2xvbmUoKTtcbiAgICBjb25zdCB7IHRvcCA9IDAsIHJpZ2h0ID0gMCwgYm90dG9tID0gMCwgbGVmdCA9IDAgfSA9IGNyb3NzTGluZVBhZGRpbmc7XG4gICAgY29uc3QgaG9yaXpvbnRhbFBhZGRpbmcgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gdG9wICsgYm90dG9tO1xuICAgIGNvbnN0IHRvdGFsV2lkdGggPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwibGVmdFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJyaWdodFwiKSA/PyAwKSArIGhvcml6b250YWxQYWRkaW5nO1xuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gKGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJib3R0b21cIikgPz8gMCkgKyB2ZXJ0aWNhbFBhZGRpbmc7XG4gICAgaWYgKHJlc3VsdC53aWR0aCA8PSB0b3RhbFdpZHRoIHx8IHJlc3VsdC5oZWlnaHQgPD0gdG90YWxIZWlnaHQpIHtcbiAgICAgIHZpc2liaWxpdHkuY3Jvc3NMaW5lcyA9IGZhbHNlO1xuICAgICAgdmlzaWJpbGl0eS5zZXJpZXMgPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdC54ICs9IGxlZnQ7XG4gICAgcmVzdWx0LnkgKz0gdG9wO1xuICAgIHJlc3VsdC53aWR0aCAtPSBob3Jpem9udGFsUGFkZGluZztcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRpY2FsUGFkZGluZztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGJ1aWxkU2VyaWVzUmVjdChheGlzQm91bmQsIGF4aXNBcmVhV2lkdGhzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXhpc0JvdW5kLmNsb25lKCk7XG4gICAgcmVzdWx0LnggKz0gYXhpc0FyZWFXaWR0aHMuZ2V0KFwibGVmdFwiKSA/PyAwO1xuICAgIHJlc3VsdC55ICs9IGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwO1xuICAgIHJlc3VsdC53aWR0aCAtPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwibGVmdFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJyaWdodFwiKSA/PyAwKTtcbiAgICByZXN1bHQuaGVpZ2h0IC09IChheGlzQXJlYVdpZHRocy5nZXQoXCJ0b3BcIikgPz8gMCkgKyAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwiYm90dG9tXCIpID8/IDApO1xuICAgIHJlc3VsdC53aWR0aCA9IE1hdGgubWF4KDAsIHJlc3VsdC53aWR0aCk7XG4gICAgcmVzdWx0LmhlaWdodCA9IE1hdGgubWF4KDAsIHJlc3VsdC5oZWlnaHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KHNlcmllc1JlY3QsIHZhbHVlLCBkaW1lbnNpb24sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gc2VyaWVzUmVjdDtcbiAgICBjb25zdCBjbGFtcEJvdW5kcyA9IFt4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHRdO1xuICAgIGNvbnN0IGNvbXBhcmVUbyA9IGNsYW1wQm91bmRzWyhkaW1lbnNpb24gPT09IFwieFwiID8gMCA6IDEpICsgKGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAyKV07XG4gICAgY29uc3QgY2xhbXBGbiA9IGRpcmVjdGlvbiA9PT0gMSA/IE1hdGgubWluIDogTWF0aC5tYXg7XG4gICAgcmV0dXJuIGNsYW1wRm4odmFsdWUsIGNvbXBhcmVUbyk7XG4gIH1cbiAgY2FsY3VsYXRlQXhpc0RpbWVuc2lvbnMob3B0cykge1xuICAgIGNvbnN0IHsgYXhpcywgc2VyaWVzUmVjdCwgcGFkZGVkQm91bmRzLCBwcmltYXJ5VGlja0NvdW50cyB9ID0gb3B0cztcbiAgICBsZXQgeyBjbGlwU2VyaWVzIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgcG9zaXRpb24gPSBcImxlZnRcIiwgZGlyZWN0aW9uIH0gPSBheGlzO1xuICAgIHRoaXMuc2l6ZUF4aXMoYXhpcywgc2VyaWVzUmVjdCwgcG9zaXRpb24pO1xuICAgIGxldCBwcmltYXJ5VGlja0NvdW50ID0gYXhpcy5uaWNlID8gcHJpbWFyeVRpY2tDb3VudHNbZGlyZWN0aW9uXSA6IHZvaWQgMDtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgIGNvbnN0IHBhZGRlZEJvdW5kc0NvZWZmaWNpZW50ID0gMC4zO1xuICAgIGlmIChheGlzLnRoaWNrbmVzcykge1xuICAgICAgYXhpcy5tYXhUaGlja25lc3MgPSBheGlzLnRoaWNrbmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpcy5tYXhUaGlja25lc3MgPSAoaXNWZXJ0aWNhbCA/IHBhZGRlZEJvdW5kcy53aWR0aCA6IHBhZGRlZEJvdW5kcy5oZWlnaHQpICogcGFkZGVkQm91bmRzQ29lZmZpY2llbnQ7XG4gICAgfVxuICAgIGNvbnN0IGxheW91dCA9IGF4aXMuY2FsY3VsYXRlTGF5b3V0KHByaW1hcnlUaWNrQ291bnQpO1xuICAgIHByaW1hcnlUaWNrQ291bnQgPSBsYXlvdXQucHJpbWFyeVRpY2tDb3VudDtcbiAgICBwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dID8/IChwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dID0gcHJpbWFyeVRpY2tDb3VudCk7XG4gICAgY2xpcFNlcmllcyB8fCAoY2xpcFNlcmllcyA9IGF4aXMuZGF0YURvbWFpbi5jbGlwcGVkIHx8IGF4aXMudmlzaWJsZVJhbmdlWzBdID4gMCB8fCBheGlzLnZpc2libGVSYW5nZVsxXSA8IDEpO1xuICAgIGxldCBheGlzVGhpY2tuZXNzO1xuICAgIGlmIChheGlzLnRoaWNrbmVzcyAhPSBudWxsICYmIGF4aXMudGhpY2tuZXNzID4gMCkge1xuICAgICAgYXhpc1RoaWNrbmVzcyA9IGF4aXMudGhpY2tuZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzVGhpY2tuZXNzID0gaXNWZXJ0aWNhbCA/IGxheW91dC5iYm94LndpZHRoIDogbGF5b3V0LmJib3guaGVpZ2h0O1xuICAgIH1cbiAgICBheGlzVGhpY2tuZXNzID0gTWF0aC5jZWlsKGF4aXNUaGlja25lc3MpO1xuICAgIHJldHVybiB7IGNsaXBTZXJpZXMsIGF4aXNUaGlja25lc3MsIHByaW1hcnlUaWNrQ291bnQgfTtcbiAgfVxuICBzaXplQXhpcyhheGlzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IGlzQ2F0ZWdvcnkgPSBheGlzIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzIHx8IGF4aXMgaW5zdGFuY2VvZiBHcm91cGVkQ2F0ZWdvcnlBeGlzO1xuICAgIGNvbnN0IGlzTGVmdFJpZ2h0ID0gcG9zaXRpb24gPT09IFwibGVmdFwiIHx8IHBvc2l0aW9uID09PSBcInJpZ2h0XCI7XG4gICAgbGV0IHsgbWluLCBtYXggfSA9IHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmdldEF4aXNab29tKGF4aXMuaWQpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2VyaWVzUmVjdDtcbiAgICBjb25zdCBtaW5TdGFydCA9IDA7XG4gICAgY29uc3QgbWF4RW5kID0gaXNMZWZ0UmlnaHQgPyBoZWlnaHQgOiB3aWR0aDtcbiAgICBsZXQgc3RhcnQgPSBtaW5TdGFydDtcbiAgICBsZXQgZW5kID0gbWF4RW5kO1xuICAgIGNvbnN0IHsgd2lkdGg6IGF4aXNXaWR0aCwgdW5pdCwgYWxpZ24gfSA9IGF4aXMubGF5b3V0Q29uc3RyYWludHM7XG4gICAgaWYgKHVuaXQgPT09IFwicHhcIikge1xuICAgICAgZW5kID0gc3RhcnQgKyBheGlzV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IGVuZCAqIGF4aXNXaWR0aCAvIDEwMDtcbiAgICB9XG4gICAgaWYgKGFsaWduID09PSBcImVuZFwiKSB7XG4gICAgICBzdGFydCA9IG1heEVuZCAtIChlbmQgLSBzdGFydCk7XG4gICAgICBlbmQgPSBtYXhFbmQ7XG4gICAgfVxuICAgIGlmIChpc0NhdGVnb3J5ICYmIGlzTGVmdFJpZ2h0KSB7XG4gICAgICBbbWluLCBtYXhdID0gWzEgLSBtYXgsIDEgLSBtaW5dO1xuICAgIH0gZWxzZSBpZiAoaXNMZWZ0UmlnaHQpIHtcbiAgICAgIFtzdGFydCwgZW5kXSA9IFtlbmQsIHN0YXJ0XTtcbiAgICB9XG4gICAgYXhpcy5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICBheGlzLnZpc2libGVSYW5nZSA9IFttaW4sIG1heF07XG4gICAgYXhpcy5ncmlkTGVuZ3RoID0gaXNMZWZ0UmlnaHQgPyB3aWR0aCA6IGhlaWdodDtcbiAgfVxuICBjYWxjdWxhdGVBeGlzQXJlYShheGVzLCBheGlzV2lkdGhzLCBheGlzT2Zmc2V0cykge1xuICAgIGxldCB0b3RhbEF4aXNXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICBheGlzT2Zmc2V0cy5zZXQoYXhpcy5pZCwgY3VycmVudE9mZnNldCk7XG4gICAgICBjb25zdCBheGlzVGhpY2tuZXNzID0gYXhpc1dpZHRocy5nZXQoYXhpcy5pZCkgPz8gMDtcbiAgICAgIHRvdGFsQXhpc1dpZHRoID0gTWF0aC5tYXgodG90YWxBeGlzV2lkdGgsIGN1cnJlbnRPZmZzZXQgKyBheGlzVGhpY2tuZXNzKTtcbiAgICAgIGlmIChheGlzLmxheW91dENvbnN0cmFpbnRzLnN0YWNrZWQpIHtcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBheGlzVGhpY2tuZXNzICsgMTU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbEF4aXNXaWR0aDtcbiAgfVxuICBwb3NpdGlvbkF4ZXMob3B0cykge1xuICAgIGNvbnN0IHsgYXhlcywgYXhpc0JvdW5kLCBheGlzV2lkdGhzLCBheGlzT2Zmc2V0cywgYXhpc0FyZWFXaWR0aHMsIHNlcmllc1JlY3QsIHBvc2l0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IGF4aXNBcmVhV2lkdGggPSBheGlzQXJlYVdpZHRocy5nZXQocG9zaXRpb24pID8/IDA7XG4gICAgbGV0IG1haW5EaW1lbnNpb24gPSBcInhcIjtcbiAgICBsZXQgbWlub3JEaW1lbnNpb24gPSBcInlcIjtcbiAgICBsZXQgZGlyZWN0aW9uID0gMTtcbiAgICBsZXQgYXhpc0JvdW5kTWFpbk9mZnNldCA9IDA7XG4gICAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiIHx8IHBvc2l0aW9uID09PSBcImJvdHRvbVwiKSB7XG4gICAgICBtYWluRGltZW5zaW9uID0gXCJ5XCI7XG4gICAgICBtaW5vckRpbWVuc2lvbiA9IFwieFwiO1xuICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSAxO1xuICAgIH1cbiAgICBheGlzQm91bmRNYWluT2Zmc2V0ICs9IGF4aXNCb3VuZFttYWluRGltZW5zaW9uXTtcbiAgICBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIiB8fCBwb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICBheGlzQm91bmRNYWluT2Zmc2V0ICs9IG1haW5EaW1lbnNpb24gPT09IFwieFwiID8gYXhpc0JvdW5kLndpZHRoIDogYXhpc0JvdW5kLmhlaWdodDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIGNvbnN0IG1pbm9yT2Zmc2V0ID0gYXhpc0FyZWFXaWR0aHMuZ2V0KG1pbm9yRGltZW5zaW9uID09PSBcInhcIiA/IFwibGVmdFwiIDogXCJ0b3BcIikgPz8gMDtcbiAgICAgIGF4aXMudHJhbnNsYXRpb25bbWlub3JEaW1lbnNpb25dID0gYXhpc0JvdW5kW21pbm9yRGltZW5zaW9uXSArIG1pbm9yT2Zmc2V0O1xuICAgICAgY29uc3QgYXhpc1RoaWNrbmVzcyA9IGF4aXNXaWR0aHMuZ2V0KGF4aXMuaWQpID8/IDA7XG4gICAgICBjb25zdCBheGlzT2Zmc2V0ID0gYXhpc09mZnNldHMuZ2V0KGF4aXMuaWQpID8/IDA7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uW21haW5EaW1lbnNpb25dID0gdGhpcy5jbGFtcFRvT3V0c2lkZVNlcmllc1JlY3QoXG4gICAgICAgIHNlcmllc1JlY3QsXG4gICAgICAgIGF4aXNCb3VuZE1haW5PZmZzZXQgKyBkaXJlY3Rpb24gKiAoYXhpc09mZnNldCArIGF4aXNUaGlja25lc3MpLFxuICAgICAgICBtYWluRGltZW5zaW9uLFxuICAgICAgICBkaXJlY3Rpb25cbiAgICAgICk7XG4gICAgICBheGlzLmdyaWRQYWRkaW5nID0gYXhpc0FyZWFXaWR0aCAtIGF4aXNPZmZzZXQgLSBheGlzVGhpY2tuZXNzO1xuICAgICAgYXhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuICF0aGlzLnNlcmllcy5zb21lKChzZXJpZXMpID0+ICEoc2VyaWVzIGluc3RhbmNlb2YgQ2FydGVzaWFuU2VyaWVzICYmIHNlcmllcy5zaG91bGRGbGlwWFkoKSkpO1xuICB9XG59O1xuQ2FydGVzaWFuQ2hhcnQuY2xhc3NOYW1lID0gXCJDYXJ0ZXNpYW5DaGFydFwiO1xuQ2FydGVzaWFuQ2hhcnQudHlwZSA9IFwiY2FydGVzaWFuXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0UHJveHkudHNcbnZhciBfQWdDaGFydEluc3RhbmNlUHJveHkgPSBjbGFzcyBfQWdDaGFydEluc3RhbmNlUHJveHkge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZmFjdG9yeUFwaSwgbGljZW5zZU1hbmFnZXIpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkgPSBmYWN0b3J5QXBpO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXIgPSBsaWNlbnNlTWFuYWdlcjtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgY2hhcnQucHVibGljQXBpID0gdGhpcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZSh4KSB7XG4gICAgaWYgKHggaW5zdGFuY2VvZiBfQWdDaGFydEluc3RhbmNlUHJveHkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoeC5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gXCJBZ0NoYXJ0SW5zdGFuY2VQcm94eVwiICYmIHguY2hhcnQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB4LmNoYXJ0ICE9IG51bGwgJiYgdGhpcy52YWxpZGF0ZUltcGxlbWVudGF0aW9uKHgpO1xuICB9XG4gIHN0YXRpYyB2YWxpZGF0ZUltcGxlbWVudGF0aW9uKHgpIHtcbiAgICBjb25zdCBjaGFydFByb3BzID0gW1wiZ2V0T3B0aW9uc1wiLCBcImRlc3Ryb3lcIl07XG4gICAgY29uc3Qgc2lnbmF0dXJlUHJvcHMgPSBPYmplY3Qua2V5cyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgPz8ge30pO1xuICAgIHJldHVybiBjaGFydFByb3BzLmV2ZXJ5KChwcm9wKSA9PiBzaWduYXR1cmVQcm9wcy5pbmNsdWRlcyhwcm9wKSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkuY3JlYXRlT3JVcGRhdGUob3B0aW9ucywgdGhpcyk7XG4gICAgYXdhaXQgdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGVsdGEoZGVsdGFPcHRpb25zKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpLnVwZGF0ZVVzZXJEZWx0YSh0aGlzLCBkZWx0YU9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlZXBDbG9uZSh0aGlzLmNoYXJ0LmdldE9wdGlvbnMoKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICBkZWxldGUgb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICB3YWl0Rm9yVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICBhc3luYyBkb3dubG9hZChvcHRzKSB7XG4gICAgY29uc3QgY2xvbmUgPSBhd2FpdCB0aGlzLnByZXBhcmVSZXNpemVkQ2hhcnQodGhpcywgb3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIGNsb25lLmNoYXJ0LmRvd25sb2FkKG9wdHM/LmZpbGVOYW1lLCBvcHRzPy5maWxlRm9ybWF0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xvbmUuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRJbWFnZURhdGFVUkwob3B0cykge1xuICAgIGNvbnN0IGNsb25lID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVzaXplZENoYXJ0KHRoaXMsIG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2xvbmUuY2hhcnQuZ2V0Q2FudmFzRGF0YVVSTChvcHRzPy5maWxlRm9ybWF0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xvbmUuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mYWN0b3J5QXBpLmNhcmV0YWtlci5zYXZlKHRoaXMuY2hhcnQuY3R4LmFubm90YXRpb25NYW5hZ2VyKTtcbiAgfVxuICBhc3luYyBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuZmFjdG9yeUFwaS5jYXJldGFrZXIucmVzdG9yZShzdGF0ZSwgdGhpcy5jaGFydC5jdHguYW5ub3RhdGlvbk1hbmFnZXIpO1xuICAgIGF3YWl0IHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmNoYXJ0LnJlc2V0QW5pbWF0aW9ucygpO1xuICB9XG4gIHNraXBBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY2hhcnQuc2tpcEFuaW1hdGlvbnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2hhcnQucHVibGljQXBpID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xuICB9XG4gIGFzeW5jIHByZXBhcmVSZXNpemVkQ2hhcnQocHJveHksIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hhcnQgfSA9IHByb3h5O1xuICAgIGNvbnN0IHdpZHRoID0gb3B0cy53aWR0aCA/PyBjaGFydC53aWR0aCA/PyBjaGFydC5jdHguc2NlbmUuY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IG9wdHMuaGVpZ2h0ID8/IGNoYXJ0LmhlaWdodCA/PyBjaGFydC5jdHguc2NlbmUuY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzdGF0ZSA9IHByb3h5LmdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNFbnRlcnByaXNlID0gbW9kdWxlUmVnaXN0cnkuaGFzRW50ZXJwcmlzZU1vZHVsZXMoKTtcbiAgICBjb25zdCBvdmVycmlkZU9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBwcm9jZXNzZWRPcHRpb25zID0gY2hhcnQuY2hhcnRPcHRpb25zLmdldE9wdGlvbnMoKTtcbiAgICBpZiAoaXNFbnRlcnByaXNlKSB7XG4gICAgICBvdmVycmlkZU9wdGlvbnMuYW5pbWF0aW9uID0geyBlbmFibGVkOiBmYWxzZSB9O1xuICAgICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMocHJvY2Vzc2VkT3B0aW9ucykpIHtcbiAgICAgICAgb3ZlcnJpZGVPcHRpb25zLnRvb2xiYXIgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saWNlbnNlTWFuYWdlcj8uaXNEaXNwbGF5V2F0ZXJtYXJrKCkpIHtcbiAgICAgICAgb3ZlcnJpZGVPcHRpb25zLmZvcmVncm91bmQgPSB7XG4gICAgICAgICAgdGV4dDogdGhpcy5saWNlbnNlTWFuYWdlci5nZXRXYXRlcm1hcmtNZXNzYWdlKCksXG4gICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIHVybDogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qVTRJaUJvWldsbmFIUTlJalF3SWlCMmFXVjNRbTk0UFNJd0lEQWdNalU0SURRd0lpQm1hV3hzUFNKdWIyNWxJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lQZ284Y0dGMGFDQmtQU0pOTWpVdU56YzVJREk0TGpZMU4wZ3hNeTR6TlRsTU1URXVNVGN6SURNMExqQXhNa2cxTGpZM01qazNUREUzTGpFNE1pQTNMakExT1RrNVNESXhMamsxTTB3ek15NDBOaklnTXpRdU1ERXlTREkzTGprMk1rd3lOUzQzTnpZZ01qZ3VOalUzU0RJMUxqYzNPVnBOTWpRdU1EWTRJREkwTGpNNU4wd3hPUzQxT0RnZ01UTXVORE0wVERFMUxqRXdOeUF5TkM0ek9UZElNalF1TURZNFdrMDJNaTR3T1RJZ01UZ3VPREl6U0RRNUxqZ3hOMVl5TXk0d09EWklOVFl1TnpjMVF6VTJMalUxTlNBeU5TNHlNaklnTlRVdU56VTFJREkyTGpreU55QTFOQzR6TnpJZ01qZ3VNakF5UXpVeUxqazRPU0F5T1M0ME56WWdOVEV1TVRZMklETXdMakV4TlNBME9DNDVNRGtnTXpBdU1URTFRelEzTGpZeU1pQXpNQzR4TVRVZ05EWXVORFVnTWprdU9EZzFJRFExTGpNNU15QXlPUzQwTWpORE5EUXVNelU0TXlBeU9DNDVOemd4SURRekxqUXpNallnTWpndU16RXpPQ0EwTWk0Mk9DQXlOeTQwTnpaRE5ERXVPVEkzSURJMkxqWXpPU0EwTVM0ek5EUWdNalV1TmpNeElEUXdMamt6TVNBeU5DNDBOVE5ETkRBdU5URTVJREl6TGpJM05TQTBNQzR6TVRFZ01qRXVPVGNnTkRBdU16RXhJREl3TGpVek4wTTBNQzR6TVRFZ01Ua3VNVEExSURRd0xqVXhOaUF4Tnk0NElEUXdMamt6TVNBeE5pNDJNakZETkRFdU16UTBJREUxTGpRME15QTBNUzQ1TWpjZ01UUXVORE0ySURReUxqWTRJREV6TGpVNU9FTTBNeTQwTXpjMklERXlMamMxTnpjZ05EUXVNelk1TmlBeE1pNHdPVE15SURRMUxqUXhNU0F4TVM0Mk5URkRORFl1TkRjNElERXhMakU0T1NBME55NDJOVFlnTVRBdU9UWWdORGd1T1RRMklERXdMamsyUXpVeExqWXhNaUF4TUM0NU5pQTFNeTQyTXpjZ01URXVOakF5SURVMUxqQXlJREV5TGpnNE5VdzFPQzR6SURrdU5qQTBPVGxETlRVdU9ERTNJRGN1TmpZNU9Ua2dOVEl1TmpjMklEWXVOams1T1RrZ05EZ3VPRGN5SURZdU5qazVPVGxETkRZdU56WWdOaTQyT1RrNU9TQTBOQzQ0TlRNZ055NHdNelE1T1NBME15NHhOVFFnTnk0M01EQTVPVU0wTVM0ME5UVWdPQzR6TmpjNU9TQXpPUzQ1T1RnZ09TNHpNRE01T1NBek9DNDNPRE1nTVRBdU5UQTBRek0zTGpVMk55QXhNUzQzTURjZ016WXVOak0wSURFekxqRTFPQ0F6TlM0NU56Y2dNVFF1T0RVM1F6TTFMak14T1NBeE5pNDFOVFlnTXpRdU9UazBJREU0TGpRMU1TQXpOQzQ1T1RRZ01qQXVOVFJETXpRdU9UazBJREl5TGpZeklETTFMak15T1NBeU5DNDBPVFFnTXpVdU9UazFJREkyTGpJd05VTXpOaTQyTmpJZ01qY3VPVEUySURNM0xqWXdOU0F5T1M0ek56UWdNemd1T0RFM0lETXdMalUzTjBNME1DNHdNeklnTXpFdU56Z2dOREV1TkRnMklETXlMamN4TXlBME15NHhPRGdnTXpNdU16Z3pRelEwTGpnNE9DQXpOQzR3TkRrZ05EWXVOemd5SURNMExqTTROQ0EwT0M0NE56SWdNelF1TXpnMFF6VXdMamsyTVNBek5DNHpPRFFnTlRJdU56VWdNelF1TURRNUlEVTBMak01SURNekxqTTRNME0xTmk0d016RWdNekl1TnpFMklEVTNMalF5TmlBek1TNDNPQ0ExT0M0MU56a2dNekF1TlRjM1F6VTVMamN6TXlBeU9TNHpOelFnTmpBdU5qRTVJREkzTGpreE5pQTJNUzR5TXprZ01qWXVNakExUXpZeExqZzJJREkwTGpRNU5DQTJNaTR4TnlBeU1pNDJNRFVnTmpJdU1UY2dNakF1TlRSRE5qSXVNVFk1TmlBeE9TNDVOamc0SURZeUxqRTBORFVnTVRrdU16azRJRFl5TGpBNU5TQXhPQzQ0TWpsTU5qSXVNRGt5SURFNExqZ3lNMXBOTVRVeExqZ3hJREUyTGprNE1VTXhOVE11TkRFZ01UUXVOakE1SURFMU55NDBNVGtnTVRRdU16VTRJREUxT1M0d01qSWdNVFF1TXpVNFZqRTRMamt4UXpFMU5pNDVOVGNnTVRndU9URWdNVFUwTGprNE5TQXhPQzQ1T1RZZ01UVXpMamMxTnlBeE9TNDRPVEpETVRVeUxqVXlPU0F5TUM0M09USWdNVFV4TGpreE9TQXlNUzQ1T0RJZ01UVXhMamt4T1NBeU15NDBOalJXTXpNdU9UbElNVFEyTGprMk5GWXhOQzR6TlRoSU1UVXhMamN6Tmt3eE5URXVPREVnTVRZdU9UZ3hXazB4TkRNdU1ERXhJREUwTGpNMk1WWXpOQzR3TXpGSU1UTTRMakkwVERFek9DNHhNekVnTXpFdU1EUTFRekV6Tnk0ME5qWWdNekl1TURjMklERXpOaTQxTlRFZ016SXVPVEl4T1NBeE16VXVORGN4SURNekxqVXdORU14TXpRdU16YzJJRE0wTGpBNU9TQXhNek11TURZNElETTBMak01TmlBeE16RXVOVE0ySURNMExqTTVOa014TXpBdU1pQXpOQzR6T1RZZ01USTRMamsyTXlBek5DNHhOVElnTVRJM0xqZ3lNaUF6TXk0Mk5qaERNVEkyTGpjZ016TXVNVGsyTkNBeE1qVXVOamc1SURNeUxqUTVOU0F4TWpRdU9EVTFJRE14TGpZd09VTXhNalF1TURFNElETXdMamN5TWlBeE1qTXVNelUwSURJNUxqWTJNaUF4TWpJdU9EY3hJREk0TGpReU1rTXhNakl1TXpnMElESTNMakU0TlNBeE1qSXVNVFF5SURJMUxqZ3hNU0F4TWpJdU1UUXlJREkwTGpNd05FTXhNakl1TVRReUlESXlMamM1T0NBeE1qSXVNemcwSURJeExqTTNPQ0F4TWpJdU9EY3hJREl3TGpFeE5rTXhNak11TXpVM0lERTRMamcxTkNBeE1qUXVNREU0SURFM0xqYzNNaUF4TWpRdU9EVTFJREUyTGpnM00wTXhNalV1TmpnNElERTFMamszTmpRZ01USTJMalk1T0NBeE5TNHlOak0ySURFeU55NDRNaklnTVRRdU56aERNVEk0TGprMk15QXhOQzR5T0RFZ01UTXdMakl3TXlBeE5DNHdNek1nTVRNeExqVXpOaUF4TkM0d016TkRNVE16TGpBME15QXhOQzR3TXpNZ01UTTBMak16SURFMExqTXhPQ0F4TXpVdU16azNJREUwTGpnNE9FTXhNell1TkRZeUlERTFMalExT0RrZ01UTTNMak0zTlNBeE5pNHlOemdnTVRNNExqQTFOeUF4Tnk0eU56WldNVFF1TXpZeFNERTBNeTR3TVRGYVRURXpNaTQyTXpFZ016QXVNVE16UXpFek5DNHlOVFlnTXpBdU1UTXpJREV6TlM0MU5qY2dNamt1TlRrMElERXpOaTQxTmpVZ01qZ3VOVEV5UXpFek55NDFOakVnTWpjdU5ETWdNVE00TGpBMklESTFMams1TVNBeE16Z3VNRFlnTWpRdU1UazJRekV6T0M0d05pQXlNaTQwTURFZ01UTTNMalUyTVNBeU1DNDVPU0F4TXpZdU5UWTFJREU1TGpnNU9VTXhNelV1TlRjZ01UZ3VPREEzSURFek5DNHlOVGtnTVRndU1qVTRJREV6TWk0Mk16RWdNVGd1TWpVNFF6RXpNUzR3TURNZ01UZ3VNalU0SURFeU9TNDNNamtnTVRndU9EQTBJREV5T0M0M016UWdNVGt1T0RrNVF6RXlOeTQzTXpnZ01qQXVPVGt6SURFeU55NHlNemtnTWpJdU5ETTRJREV5Tnk0eU16a2dNalF1TWpNelF6RXlOeTR5TXprZ01qWXVNREk0SURFeU55NDNNelVnTWpjdU5ETXpJREV5T0M0M016UWdNamd1TlRFMVF6RXlPUzQzTWprZ01qa3VOVGswSURFek1TNHdNamdnTXpBdU1UTTJJREV6TWk0Mk16RWdNekF1TVRNMlZqTXdMakV6TTFwTk9UTXVOams0SURJM0xqZzNOa001TXk0MU56azFJREk0TGpBd01qVWdPVE11TkRVMk5DQXlPQzR4TWpRMklEa3pMak15T1NBeU9DNHlOREpET1RFdU9UUTNJREk1TGpVeE5pQTVNQzR4TWpNZ016QXVNVFUxSURnM0xqZzJOaUF6TUM0eE5UVkRPRFl1TlRnZ016QXVNVFUxSURnMUxqUXdPQ0F5T1M0NU1qWWdPRFF1TXpVZ01qa3VORFkwUXpnekxqTXhOVFVnTWprdU1ERTRPU0E0TWk0ek9EazRJREk0TGpNMU5EWWdPREV1TmpNM0lESTNMalV4TjBNNE1DNDRPRFFnTWpZdU5qYzVJRGd3TGpNd01TQXlOUzQyTnpJZ056a3VPRGc1SURJMExqUTVORU0zT1M0ME56WWdNak11TXpFMUlEYzVMakkyT1NBeU1pNHdNU0EzT1M0eU5qa2dNakF1TlRjNFF6YzVMakkyT1NBeE9TNHhORFVnTnprdU5EY3pJREUzTGpnMElEYzVMamc0T1NBeE5pNDJOakpET0RBdU16QXhJREUxTGpRNE5DQTRNQzQ0T0RRZ01UUXVORGMySURneExqWXpOeUF4TXk0Mk16bERPREl1TXprME9TQXhNaTQzT1RnM0lEZ3pMak15TnpNZ01USXVNVE0wTWlBNE5DNHpOamtnTVRFdU5qa3lRemcxTGpRek5pQXhNUzR5TXlBNE5pNDJNVFFnTVRFZ09EY3VPVEF6SURFeFF6a3dMalUzSURFeElEa3lMalU1TlNBeE1TNDJORElnT1RNdU9UYzNJREV5TGpreU5rdzVOeTR5TlRnZ09TNDJORFE1T1VNNU5DNDNOelFnTnk0M01UQTVPU0E1TVM0Mk16TWdOaTQzTXprNU9TQTROeTQ0TWprZ05pNDNNems1T1VNNE5TNDNNVGdnTmk0M016azVPU0E0TXk0NE1URWdOeTR3TnpRNU9TQTRNaTR4TVRJZ055NDNOREU1T1VNNE1DNDBNVE1nT0M0ME1EYzVPU0EzT0M0NU5UWWdPUzR6TkRRNU9TQTNOeTQzTkNBeE1DNDFORFZETnpZdU5USTFJREV4TGpjME55QTNOUzQxT1RJZ01UTXVNVGs1SURjMExqa3pOQ0F4TkM0NE9UaEROelF1TWpjM0lERTJMalU1TnlBM015NDVOVEVnTVRndU5Ea3hJRGN6TGprMU1TQXlNQzQxT0RGRE56TXVPVFV4SURJeUxqWTNJRGMwTGpJNE5pQXlOQzQxTXpRZ056UXVPVFV6SURJMkxqSTBOVU0zTlM0Mk1Ua2dNamN1T1RVM0lEYzJMalUyTWlBeU9TNDBNVFFnTnpjdU56YzBJRE13TGpZeE4wTTNPQzQ1T1NBek1TNDRNaUE0TUM0ME5EUWdNekl1TnpVeklEZ3lMakUwTmlBek15NDBNak5ET0RNdU9EUTFJRE0wTGpBNUlEZzFMamN6T1NBek5DNDBNalFnT0RjdU9ESTVJRE0wTGpReU5FTTRPUzQ1TVRrZ016UXVOREkwSURreExqY3dPQ0F6TkM0d09TQTVNeTR6TkRnZ016TXVOREl6UXprMExqY3hPQ0F6TWk0NE5qVWdPVFV1T1RFNElETXlMakV5TVNBNU5pNDVORGdnTXpFdU1Ua3hRemszTGpFME9TQXpNUzR3TURnZ09UY3VNelE0SURNd0xqZ3hOU0E1Tnk0MU16Y2dNekF1TmpKTU9UTXVOekF4SURJM0xqZzROVXc1TXk0Mk9UZ2dNamN1T0RjMldrMHhNVEF1T0RBeUlERTBMakF4TlVNeE1Ea3VNVGs1SURFMExqQXhOU0F4TURZdU9ETTJJREUwTGpRM01TQXhNRFV1TmpFeElERTJMakUxT0V3eE1EVXVOVE0zSURZdU1ERTFPVGxJTVRBd0xqYzJOVll6TXk0NU16bElNVEExTGpjeVZqSXlMalkwTVVNeE1EVXVOemN4SURJeExqUTJNRGNnTVRBMkxqSTRPQ0F5TUM0ek5EZzRJREV3Tnk0eE5UY2dNVGt1TlRRNE9VTXhNRGd1TURJM0lERTRMamMwT1RFZ01UQTVMakUzT0NBeE9DNHpNalkySURFeE1DNHpOVGdnTVRndU16YzBRekV4TXk0ek9UY2dNVGd1TXpjMElERXhOQzR5TmpnZ01qRXVNVFU1SURFeE5DNHlOamdnTWpJdU5qUXhWak16TGprek9VZ3hNVGt1TWpJelZqSXhMakExT1VNeE1Ua3VNakl6SURJeExqQTFPU0F4TVRrdU1UUXlJREUwTGpBeE5TQXhNVEF1T0RBeUlERTBMakF4TlZwTk1UY3pMamMyTXlBeE5DNHpOVGhJTVRZNUxqazVPVlk0TGpjeE5EazVTREUyTlM0d05EaFdNVFF1TXpVNFNERTJNUzR5T0RSV01UZ3VPVEUyU0RFMk5TNHdORGhXTXpRdU1EQXpTREUyT1M0NU9UbFdNVGd1T1RFMlNERTNNeTQzTmpOV01UUXVNelU0V2sweE9UQXVOemczSURJMUxqSTJNa014T1RBdU1USTVJREkwTGpVd01UUWdNVGc1TGpNd055QXlNeTQ0T1RrMElERTRPQzR6T0RRZ01qTXVOVEF4UXpFNE55NDBPRGdnTWpNdU1URTNJREU0Tmk0ek16RWdNakl1TnpNeUlERTROQzQ1TkRnZ01qSXVNelkwUXpFNE5DNHhOalVnTWpJdU1UUXpPU0F4T0RNdU16a2dNakV1T0RrM09DQXhPREl1TmpJeklESXhMall5TmtNeE9ESXVNVFl6SURJeExqUTJNakVnTVRneExqYzBNU0F5TVM0eU1EWTJJREU0TVM0ek9ETWdNakF1T0RjMVF6RTRNUzR5TXpVZ01qQXVOelF5TVNBeE9ERXVNVEU0SURJd0xqVTNPRGtnTVRneExqQXpPU0F5TUM0ek9UWTBRekU0TUM0NU5qRWdNakF1TWpFMElERTRNQzQ1TWpJZ01qQXVNREUyTmlBeE9EQXVPVEkzSURFNUxqZ3hPRU14T0RBdU9USTNJREU1TGpJM01pQXhPREV1TVRVMklERTRMamcwTkNBeE9ERXVOakkxSURFNExqVXhRekU0TWk0eE1qRWdNVGd1TVRVMklERTRNaTQ0TmpJZ01UY3VPVGMySURFNE15NDRNallnTVRjdU9UYzJRekU0TkM0M09TQXhOeTQ1TnpZZ01UZzFMalU0TnlBeE9DNHlNRGtnTVRnMkxqRTBPQ0F4T0M0Mk5qaERNVGcyTGpjd05pQXhPUzR4TWpRZ01UZzNMakF3TnlBeE9TNDNNalVnTVRnM0xqQTNNaUF5TUM0MVRERTROeTR3T1RRZ01qQXVOemd5U0RFNU1TNDJNek5NTVRreExqWXhOeUF5TUM0ME5rTXhPVEV1TlRJeElERTRMalE0TlNBeE9UQXVOemN4SURFMkxqa2dNVGc1TGpNNE5TQXhOUzQzTlVNeE9EZ3VNREV5SURFMExqWXhNaUF4T0RZdU1UZzFJREUwTGpBek15QXhPRE11T1RZeUlERTBMakF6TTBNeE9ESXVORGMzSURFMExqQXpNeUF4T0RFdU1UUXhJREUwTGpJNE55QXhOemt1T1RrMElERTBMamM0TmtNeE56Z3VPRE14SURFMUxqSTVNU0F4TnpjdU9USTJJREUxTGprNU5TQXhOemN1TWprMklERTJMamc0TWtNeE56WXVOamN6SURFM0xqYzBOVFVnTVRjMkxqTXpPQ0F4T0M0M09EUWdNVGMyTGpNME1TQXhPUzQ0TkRsRE1UYzJMak0wTVNBeU1TNHhOamNnTVRjMkxqWTVPQ0F5TWk0eU5Ea2dNVGMzTGpNNU9TQXlNeTR3TmpSRE1UYzRMakEySURJekxqZzBNeklnTVRjNExqZzVPQ0F5TkM0ME5UTTBJREUzT1M0NE5ESWdNalF1T0RRMFF6RTRNQzQzTkRRZ01qVXVNakUySURFNE1TNDVNamdnTWpVdU5qQTNJREU0TXk0ek5qRWdNalpETVRnMExqZ3dOaUF5Tmk0ME1TQXhPRFV1T0RjeUlESTJMamM0TlNBeE9EWXVOVE1nTWpjdU1USXpRekU0Tnk0eElESTNMalF4TkNBeE9EY3VNemM1SURJM0xqZzBOU0F4T0RjdU16YzVJREk0TGpRME5FTXhPRGN1TXpjNUlESTVMakEwTWlBeE9EY3VNVEl5SURJNUxqUTJOeUF4T0RZdU5UazFJREk1TGpnek9VTXhPRFl1TURReklETXdMakl5TmlBeE9EVXVNak0zSURNd0xqUXlOU0F4T0RRdU1qQXhJRE13TGpReU5VTXhPRE11TVRZMklETXdMalF5TlNBeE9ESXVNemswSURNd0xqRTNOQ0F4T0RFdU56UTVJREk1TGpZM05FTXhPREV1TVRFeklESTVMakU0TVNBeE9EQXVOemN5SURJNExqVTRPU0F4T0RBdU56RWdNamN1T0RZMFRERTRNQzQyT0RVZ01qY3VOVGd5U0RFM05pNHdNVE5NTVRjMkxqQXlOU0F5Tnk0NU1ERkRNVGMyTGpBMk55QXlPUzR3T1RVMUlERTNOaTQwTnpJZ016QXVNalE0TnlBeE56Y3VNVGc0SURNeExqSXdOa014TnpjdU9UQTNJRE15TGpFNElERTNPQzQ0T1RNZ016SXVPVFU0SURFNE1DNHhNVGdnTXpNdU5URTVRekU0TVM0ek16WWdNelF1TURjM0lERTRNaTQzTXpJZ016UXVNell5SURFNE5DNHlOallnTXpRdU16WXlRekU0TlM0NE1ERWdNelF1TXpZeUlERTROeTR4TURrZ016UXVNVEE0SURFNE9DNHlNemdnTXpNdU5qQTVRekU0T1M0ek56WWdNek11TVRBMElERTVNQzR5TnpJZ016SXVNemswSURFNU1DNDVNREVnTXpFdU5EazBRekU1TVM0MU16UWdNekF1TlRreUlERTVNUzQ0TlRNZ01qa3VOVFUwSURFNU1TNDROVE1nTWpndU5EQXpRekU1TVM0NE1qZ2dNamN1TVRFZ01Ua3hMalEyTmlBeU5pNHdOVE1nTVRrd0xqYzNOeUF5TlM0eU5qSklNVGt3TGpjNE4xb2lJR1pwYkd3OUlpTTVRamxDT1VJaUx6NEtQSEJoZEdnZ1pEMGlUVEkwTVM0NU9ESWdNalV1TmpVNE1sWXhOeTQzTVRFM1NESXlPQzQwTkRGTU1qSXdMalE1TkNBeU5TNDJOVGd5U0RJME1TNDVPREphSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU5UY3VNak01SURVdU9UVXdPREZJTWpRd0xqSTJOVXd5TXpJdU1qVTFJREV6TGpnNU56TklNalUzTGpJek9WWTFMamsxTURneFdpSWdabWxzYkQwaUl6bENPVUk1UWlJdlBnbzhjR0YwYUNCa1BTSk5NakV5TGpZeE1TQXpNeTQyTURRNFRESXhOaTQyT0NBeU9TNDFNell4U0RJek1DNDBNVEpXTXpjdU5EZ3lOMGd5TVRJdU5qRXhWak16TGpZd05EaGFJaUJtYVd4c1BTSWpPVUk1UWpsQ0lpOCtDanh3WVhSb0lHUTlJazB5TVRVdU5UazVJREl4TGpjNE1ETklNakkwTGpNM01rd3lNekl1TXpneUlERXpMamd6TXpkSU1qRTFMalU1T1ZZeU1TNDNPREF6V2lJZ1ptbHNiRDBpSXpsQ09VSTVRaUl2UGdvOGNHRjBhQ0JrUFNKTk1qQTJJRE16TGpZd05EZElNakV5TGpZeE1Vd3lNakF1TkRrMElESTFMalkxT0RKSU1qQTJWak16TGpZd05EZGFJaUJtYVd4c1BTSWpPVUk1UWpsQ0lpOCtDanh3WVhSb0lHUTlJazB5TkRBdU1qWTFJRFV1T1RVd09ERk1Nak0yTGpFNU55QXhNQzR3TVRrMFNESXhNQzR5TlRsV01pNHdOekk0T0VneU5EQXVNalkxVmpVdU9UVXdPREZhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p3dmMzWm5QZ289YCxcbiAgICAgICAgICAgIHdpZHRoOiAxNzAsXG4gICAgICAgICAgICBoZWlnaHQ6IDI1LFxuICAgICAgICAgICAgcmlnaHQ6IDI1LFxuICAgICAgICAgICAgYm90dG9tOiA1MCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSxcbiAgICAgIG92ZXJyaWRlT3B0aW9ucyxcbiAgICAgIHByb2Nlc3NlZE9wdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGNsb25lUHJveHkgPSBhd2FpdCB0aGlzLmZhY3RvcnlBcGkuY3JlYXRlT3JVcGRhdGUob3B0aW9ucyk7XG4gICAgYXdhaXQgY2xvbmVQcm94eS5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgY2xvbmVQcm94eS5jaGFydC5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcImFnQ2hhcnRWMlwiLCBjaGFydC5jdHguem9vbU1hbmFnZXIuZ2V0Wm9vbSgpKTtcbiAgICBjaGFydC5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSkge1xuICAgICAgICBjbG9uZVByb3h5LmNoYXJ0LnNlcmllc1tpbmRleF0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNoYXJ0LnVwZGF0ZSgwIC8qIEZVTEwgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUgfSk7XG4gICAgYXdhaXQgY2xvbmVQcm94eS53YWl0Rm9yVXBkYXRlKCk7XG4gICAgcmV0dXJuIGNsb25lUHJveHk7XG4gIH1cbn07XG5fQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBvbGRWYWx1ZShjaGFydCkge1xuICAgICAgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzLmRlbGV0ZShjaGFydCk7XG4gICAgfSxcbiAgICBuZXdWYWx1ZShjaGFydCkge1xuICAgICAgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzLnNldChjaGFydCwgdGhpcyk7XG4gICAgfVxuICB9KVxuXSwgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LnByb3RvdHlwZSwgXCJjaGFydFwiLCAyKTtcbnZhciBBZ0NoYXJ0SW5zdGFuY2VQcm94eSA9IF9BZ0NoYXJ0SW5zdGFuY2VQcm94eTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvbGluZWFyU2NhbGUudHNcbnZhciBMaW5lYXJTY2FsZSA9IGNsYXNzIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoWzAsIDFdLCBbMCwgMV0pO1xuICAgIHRoaXMudHlwZSA9IFwibnVtYmVyXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHRpY2tzKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aWNrQ291bnQgPz8gQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQ7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyIHx8IGNvdW50IDwgMSB8fCAhdGhpcy5kb21haW4uZXZlcnkoaXNGaW5pdGUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5nZXREb21haW4oKTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgY29uc3Qgc3RlcCA9IE1hdGguYWJzKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgaWYgKCFpc0RlbnNlSW50ZXJ2YWwoKGQxIC0gZDApIC8gc3RlcCwgdGhpcy5nZXRQaXhlbFJhbmdlKCkpKSB7XG4gICAgICAgIHJldHVybiByYW5nZShkMCwgZDEsIHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGlja3MoZDAsIGQxLCBjb3VudCwgdGhpcy5taW5UaWNrQ291bnQsIHRoaXMubWF4VGlja0NvdW50KTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xuICAgIH1cbiAgfVxuICBnZXRUaWNrU3RlcChzdGFydCwgc3RvcCkge1xuICAgIHJldHVybiB0aGlzLmludGVydmFsID8/IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCB0aGlzLnRpY2tDb3VudCwgdGhpcy5taW5UaWNrQ291bnQsIHRoaXMubWF4VGlja0NvdW50KTtcbiAgfVxuICAvKipcbiAgICogRXh0ZW5kcyB0aGUgZG9tYWluIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG9uIG5pY2Ugcm91bmQgdmFsdWVzLlxuICAgKi9cbiAgdXBkYXRlTmljZURvbWFpbigpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGlja0NvdW50O1xuICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgIHRoaXMubmljZURvbWFpbiA9IFsuLi50aGlzLmRvbWFpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBbc3RhcnQsIHN0b3BdID0gdGhpcy5kb21haW47XG4gICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICBbc3RhcnQsIHN0b3BdID0gbmljZVRpY2tzRG9tYWluKHN0YXJ0LCBzdG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRTdGFydCA9IHN0YXJ0ID4gc3RvcCA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgICBjb25zdCByb3VuZFN0b3AgPSBzdG9wIDwgc3RhcnQgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsO1xuICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBdHRlbXB0czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXYwID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IHByZXYxID0gc3RvcDtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0VGlja1N0ZXAoc3RhcnQsIHN0b3ApO1xuICAgICAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xuICAgICAgICBpZiAoc3RlcCA+PSAxKSB7XG4gICAgICAgICAgc3RhcnQgPSByb3VuZFN0YXJ0KGQwIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICAgIHN0b3AgPSByb3VuZFN0b3AoZDEgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcyA9IDEgLyBzdGVwO1xuICAgICAgICAgIHN0YXJ0ID0gcm91bmRTdGFydChkMCAqIHMpIC8gcztcbiAgICAgICAgICBzdG9wID0gcm91bmRTdG9wKGQxICogcykgLyBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gcHJldjAgJiYgc3RvcCA9PT0gcHJldjEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5pY2VEb21haW4gPSBbc3RhcnQsIHN0b3BdO1xuICB9XG4gIHRpY2tGb3JtYXQoeyB0aWNrczogc3BlY2lmaWVkVGlja3MsIHNwZWNpZmllciB9KSB7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoc3BlY2lmaWVkVGlja3MgPz8gdGhpcy50aWNrcygpLCBzcGVjaWZpZXIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3NlY29uZGFyeUF4aXNUaWNrcy50c1xuZnVuY3Rpb24gY2FsY3VsYXRlTmljZVNlY29uZGFyeUF4aXMoZG9tYWluLCBwcmltYXJ5VGlja0NvdW50LCByZXZlcnNlKSB7XG4gIGxldCBbc3RhcnQsIHN0b3BdID0gZmluZE1pbk1heChkb21haW4pO1xuICBzdGFydCA9IGNhbGN1bGF0ZU5pY2VTdGFydChNYXRoLmZsb29yKHN0YXJ0KSwgc3RvcCwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIGNvbnN0IHN0ZXAgPSBnZXRUaWNrU3RlcChzdGFydCwgc3RvcCwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gcHJpbWFyeVRpY2tDb3VudCAtIDE7XG4gIHN0b3AgPSBzdGFydCArIHNlZ21lbnRzICogc3RlcDtcbiAgY29uc3QgZCA9IHJldmVyc2UgPyBbc3RvcCwgc3RhcnRdIDogW3N0YXJ0LCBzdG9wXTtcbiAgY29uc3QgdGlja3MgPSBnZXRUaWNrcyhzdGFydCwgc3RlcCwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIHJldHVybiB7IGRvbWFpbjogZCwgdGlja3MgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBjb3VudCkge1xuICBjb25zdCByYXdTdGVwID0gTWF0aC5hYnMoYiAtIGEpIC8gKGNvdW50IC0gMSk7XG4gIGNvbnN0IG9yZGVyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHJhd1N0ZXApKTtcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYSAvIG1hZ25pdHVkZSkgKiBtYWduaXR1ZGU7XG59XG5mdW5jdGlvbiBnZXRUaWNrcyhzdGFydCwgc3RlcCwgY291bnQpIHtcbiAgY29uc3Qgc3RlcFBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHN0ZXApKTtcbiAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSBzdGVwID4gMCAmJiBzdGVwIDwgMSA/IE1hdGguYWJzKHN0ZXBQb3dlcikgOiAwO1xuICBjb25zdCBmID0gTWF0aC5wb3coMTAsIGZyYWN0aW9uRGlnaXRzKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3QgdGljayA9IHN0YXJ0ICsgc3RlcCAqIGk7XG4gICAgdGlja3NbaV0gPSBNYXRoLnJvdW5kKHRpY2sgKiBmKSAvIGY7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gZ2V0VGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gY291bnQgLSAxO1xuICBjb25zdCByYXdTdGVwID0gKHN0b3AgLSBzdGFydCkgLyBzZWdtZW50cztcbiAgcmV0dXJuIGNhbGN1bGF0ZU5leHROaWNlU3RlcChyYXdTdGVwKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5leHROaWNlU3RlcChyYXdTdGVwKSB7XG4gIGNvbnN0IG9yZGVyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHJhd1N0ZXApKTtcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcbiAgY29uc3Qgc3RlcCA9IHJhd1N0ZXAgLyBtYWduaXR1ZGUgKiAxMDtcbiAgaWYgKHN0ZXAgPiAwICYmIHN0ZXAgPD0gMSkge1xuICAgIHJldHVybiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDEgJiYgc3RlcCA8PSAyKSB7XG4gICAgcmV0dXJuIDIgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDEgJiYgc3RlcCA8PSA1KSB7XG4gICAgcmV0dXJuIDUgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDUgJiYgc3RlcCA8PSAxMCkge1xuICAgIHJldHVybiAxMCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gMTAgJiYgc3RlcCA8PSAyMCkge1xuICAgIHJldHVybiAyMCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gMjAgJiYgc3RlcCA8PSA0MCkge1xuICAgIHJldHVybiA0MCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gNDAgJiYgc3RlcCA8PSA1MCkge1xuICAgIHJldHVybiA1MCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gNTAgJiYgc3RlcCA8PSAxMDApIHtcbiAgICByZXR1cm4gMTAwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgcmV0dXJuIHN0ZXA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvbnVtYmVyQXhpcy50c1xudmFyIE51bWJlckF4aXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMiA9IG5ldyBMaW5lYXJTY2FsZSgpKSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBzY2FsZTIpO1xuICAgIHRoaXMubWluID0gTmFOO1xuICAgIHRoaXMubWF4ID0gTmFOO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBleHRlbnQ6IGV4dGVudDIsIGNsaXBwZWQgfSA9IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpO1xuICAgIHJldHVybiB7IGRvbWFpbjogZXh0ZW50MiwgY2xpcHBlZCB9O1xuICB9XG4gIHVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcyhwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgaWYgKHRoaXMuZGF0YURvbWFpbiA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBkYXRhRG9tYWluIG5vdCBjYWxjdWxhdGVkLCBjYW5ub3QgcGVyZm9ybSB0aWNrIGNhbGN1bGF0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YURvbWFpbi5kb21haW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgZG9tYWluLCB0aWNrcyB9ID0gY2FsY3VsYXRlTmljZVNlY29uZGFyeUF4aXMoXG4gICAgICB0aGlzLmRhdGFEb21haW4uZG9tYWluLFxuICAgICAgcHJpbWFyeVRpY2tDb3VudCA/PyAwLFxuICAgICAgdGhpcy5yZXZlcnNlXG4gICAgKTtcbiAgICB0aGlzLnNjYWxlLm5pY2UgPSBmYWxzZTtcbiAgICB0aGlzLnNjYWxlLmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLnNjYWxlLnVwZGF0ZSgpO1xuICAgIHJldHVybiB0aWNrcztcbiAgfVxufTtcbk51bWJlckF4aXMuY2xhc3NOYW1lID0gXCJOdW1iZXJBeGlzXCI7XG5OdW1iZXJBeGlzLnR5cGUgPSBcIm51bWJlclwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIExFU1NfVEhBTihcIm1heFwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIE51bWJlckF4aXMucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBHUkVBVEVSX1RIQU4oXCJtaW5cIikpKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBOdW1iZXJBeGlzLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvbG9nQXhpcy50c1xudmFyIE5PTl9aRVJPX05VTUJFUiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9PSAwLCBcImEgbm9uLXplcm8gbnVtYmVyXCIpO1xudmFyIExvZ0F4aXMgPSBjbGFzcyBleHRlbmRzIE51bWJlckF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIG5ldyBMb2dTY2FsZSgpKTtcbiAgICB0aGlzLm1pbiA9IE5hTjtcbiAgICB0aGlzLm1heCA9IE5hTjtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZXh0ZW50OiBleHRlbnQyLCBjbGlwcGVkIH0gPSBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KTtcbiAgICBjb25zdCBpc0ludmVydGVkID0gZXh0ZW50MlswXSA+IGV4dGVudDJbMV07XG4gICAgY29uc3QgY3Jvc3Nlc1plcm8gPSBleHRlbnQyWzBdIDwgMCAmJiBleHRlbnQyWzFdID4gMDtcbiAgICBjb25zdCBoYXNaZXJvRXh0ZW50ID0gZXh0ZW50MlswXSA9PT0gMCAmJiBleHRlbnQyWzFdID09PSAwO1xuICAgIGNvbnN0IGludmFsaWREb21haW4gPSBpc0ludmVydGVkIHx8IGNyb3NzZXNaZXJvIHx8IGhhc1plcm9FeHRlbnQ7XG4gICAgaWYgKGludmFsaWREb21haW4pIHtcbiAgICAgIGlmIChjcm9zc2VzWmVybykge1xuICAgICAgICBMb2dnZXIud2FybihcbiAgICAgICAgICBgdGhlIGRhdGEgZG9tYWluIGNyb3NzZXMgemVybywgdGhlIGNoYXJ0IGRhdGEgY2Fubm90IGJlIHJlbmRlcmVkLiBTZWUgbG9nIGF4aXMgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1plcm9FeHRlbnQpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oYHRoZSBkYXRhIGRvbWFpbiBoYXMgMCBleHRlbnQsIG5vIGRhdGEgaXMgcmVuZGVyZWQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRlbnQyWzBdID09PSAwKSB7XG4gICAgICBleHRlbnQyWzBdID0gMTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDJbMV0gPT09IDApIHtcbiAgICAgIGV4dGVudDJbMV0gPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tYWluOiBleHRlbnQyLCBjbGlwcGVkIH07XG4gIH1cbiAgc2V0IGJhc2UodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlLmJhc2UgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS5iYXNlO1xuICB9XG59O1xuTG9nQXhpcy5jbGFzc05hbWUgPSBcIkxvZ0F4aXNcIjtcbkxvZ0F4aXMudHlwZSA9IFwibG9nXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTiwgTk9OX1pFUk9fTlVNQkVSLCBMRVNTX1RIQU4oXCJtYXhcIikpKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBMb2dBeGlzLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTiwgTk9OX1pFUk9fTlVNQkVSLCBHUkVBVEVSX1RIQU4oXCJtaW5cIikpKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBMb2dBeGlzLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvdGltZUF4aXMudHNcbnZhciBUaW1lQXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IFRpbWVTY2FsZSgpKTtcbiAgICB0aGlzLm1pbiA9IHZvaWQgMDtcbiAgICB0aGlzLm1heCA9IHZvaWQgMDtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBsZXQgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBsZXQgY2xpcHBlZCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbWluID09PSBcIm51bWJlclwiKSB7XG4gICAgICBtaW4gPSBuZXcgRGF0ZShtaW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1heCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbWF4ID0gbmV3IERhdGUobWF4KTtcbiAgICB9XG4gICAgaWYgKGQubGVuZ3RoID4gMikge1xuICAgICAgZCA9IChleHRlbnQoZCkgPz8gWzAsIDFlM10pLm1hcCgoeCkgPT4gbmV3IERhdGUoeCkpO1xuICAgIH1cbiAgICBpZiAobWluIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1pbiA+IGRbMF0pO1xuICAgICAgZCA9IFttaW4sIGRbMV1dO1xuICAgIH1cbiAgICBpZiAobWF4IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1heCA8IGRbMV0pO1xuICAgICAgZCA9IFtkWzBdLCBtYXhdO1xuICAgIH1cbiAgICBpZiAoZFswXSA+IGRbMV0pIHtcbiAgICAgIGQgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tYWluOiBkLCBjbGlwcGVkIH07XG4gIH1cbiAgb25Gb3JtYXRDaGFuZ2UodGlja3MsIGZyYWN0aW9uRGlnaXRzLCBkb21haW4sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIHN1cGVyLm9uRm9ybWF0Q2hhbmdlKHRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgZG9tYWluLCBmb3JtYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3MsIGRvbWFpbiB9KTtcbiAgICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSB0aGlzLnNjYWxlLnRpY2tGb3JtYXQoeyB0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQ6IDEgfSk7XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxufTtcblRpbWVBeGlzLmNsYXNzTmFtZSA9IFwiVGltZUF4aXNcIjtcblRpbWVBeGlzLnR5cGUgPSBcInRpbWVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChEQVRFX09SX0RBVEVUSU1FX01TLCBMRVNTX1RIQU4oXCJtYXhcIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUaW1lQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKERBVEVfT1JfREFURVRJTUVfTVMsIEdSRUFURVJfVEhBTihcIm1pblwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRpbWVBeGlzLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvY29ybmVyLnRzXG52YXIgZHJhd0Nvcm5lciA9IChwYXRoLCB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfSwgY29ybmVyUmFkaXVzLCBtb3ZlKSA9PiB7XG4gIGlmIChtb3ZlKSB7XG4gICAgcGF0aC5tb3ZlVG8oeDAsIHkwKTtcbiAgfVxuICBpZiAoeDAgIT09IHgxIHx8IHkwICE9PSB5MSkge1xuICAgIGNvbnN0IHIwID0gTWF0aC5hdGFuMih5MCAtIGN5LCB4MCAtIGN4KTtcbiAgICBjb25zdCByMSA9IE1hdGguYXRhbjIoeTEgLSBjeSwgeDEgLSBjeCk7XG4gICAgcGF0aC5hcmMoY3gsIGN5LCBjb3JuZXJSYWRpdXMsIHIwLCByMSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5saW5lVG8oeDAsIHkwKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcmVjdC50c1xudmFyIGVwc2lsb24gPSAxZS02O1xudmFyIGNvcm5lckVkZ2VzID0gKGxlYWRpbmdFZGdlLCB0cmFpbGluZ0VkZ2UsIGxlYWRpbmdJbnNldCwgdHJhaWxpbmdJbnNldCwgY29ybmVyUmFkaXVzKSA9PiB7XG4gIGxldCBsZWFkaW5nQ2xpcHBlZCA9IGZhbHNlO1xuICBsZXQgdHJhaWxpbmdDbGlwcGVkID0gZmFsc2U7XG4gIGxldCBsZWFkaW5nMCA9IHRyYWlsaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSBsZWFkaW5nSW5zZXQgKiogMiwgMCkpO1xuICBsZXQgbGVhZGluZzEgPSAwO1xuICBsZXQgdHJhaWxpbmcwID0gMDtcbiAgbGV0IHRyYWlsaW5nMSA9IGxlYWRpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtIHRyYWlsaW5nSW5zZXQgKiogMiwgMCkpO1xuICBpZiAobGVhZGluZzAgPiBsZWFkaW5nRWRnZSkge1xuICAgIGxlYWRpbmdDbGlwcGVkID0gdHJ1ZTtcbiAgICBsZWFkaW5nMCA9IGxlYWRpbmdFZGdlO1xuICAgIGxlYWRpbmcxID0gbGVhZGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gKHRyYWlsaW5nSW5zZXQgLSBsZWFkaW5nRWRnZSkgKiogMikpO1xuICB9IGVsc2UgaWYgKGxlYWRpbmcwIDwgZXBzaWxvbikge1xuICAgIGxlYWRpbmcwID0gMDtcbiAgfVxuICBpZiAodHJhaWxpbmcxID4gdHJhaWxpbmdFZGdlKSB7XG4gICAgdHJhaWxpbmdDbGlwcGVkID0gdHJ1ZTtcbiAgICB0cmFpbGluZzAgPSB0cmFpbGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gKGxlYWRpbmdJbnNldCAtIHRyYWlsaW5nRWRnZSkgKiogMikpO1xuICAgIHRyYWlsaW5nMSA9IHRyYWlsaW5nRWRnZTtcbiAgfSBlbHNlIGlmICh0cmFpbGluZzEgPCBlcHNpbG9uKSB7XG4gICAgdHJhaWxpbmcxID0gMDtcbiAgfVxuICByZXR1cm4geyBsZWFkaW5nMCwgbGVhZGluZzEsIHRyYWlsaW5nMCwgdHJhaWxpbmcxLCBsZWFkaW5nQ2xpcHBlZCwgdHJhaWxpbmdDbGlwcGVkIH07XG59O1xudmFyIGluc2V0Q29ybmVyUmFkaXVzUmVjdCA9IChwYXRoLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpaSwgY2xpcEJCb3gpID0+IHtcbiAgbGV0IHtcbiAgICB0b3BMZWZ0OiB0b3BMZWZ0Q29ybmVyUmFkaXVzLFxuICAgIHRvcFJpZ2h0OiB0b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21SaWdodDogYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tTGVmdDogYm90dG9tTGVmdENvcm5lclJhZGl1c1xuICB9ID0gY29ybmVyUmFkaWk7XG4gIGNvbnN0IG1heFZlcnRpY2FsQ29ybmVyUmFkaXVzID0gTWF0aC5tYXgoXG4gICAgdG9wTGVmdENvcm5lclJhZGl1cyArIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMsXG4gICAgdG9wUmlnaHRDb3JuZXJSYWRpdXMgKyBib3R0b21SaWdodENvcm5lclJhZGl1c1xuICApO1xuICBjb25zdCBtYXhIb3Jpem9udGFsQ29ybmVyUmFkaXVzID0gTWF0aC5tYXgoXG4gICAgdG9wTGVmdENvcm5lclJhZGl1cyArIHRvcFJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgKyBib3R0b21SaWdodENvcm5lclJhZGl1c1xuICApO1xuICBpZiAobWF4VmVydGljYWxDb3JuZXJSYWRpdXMgPD0gMCAmJiBtYXhIb3Jpem9udGFsQ29ybmVyUmFkaXVzIDw9IDApIHtcbiAgICBpZiAoY2xpcEJCb3ggPT0gbnVsbCkge1xuICAgICAgcGF0aC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnJlY3QoY2xpcEJCb3gueCwgY2xpcEJCb3gueSwgY2xpcEJCb3gud2lkdGgsIGNsaXBCQm94LmhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChjbGlwQkJveCA9PSBudWxsICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IHRvcFJpZ2h0Q29ybmVyUmFkaXVzICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMpIHtcbiAgICBwYXRoLnJvdW5kUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0b3BMZWZ0Q29ybmVyUmFkaXVzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggKz0gd2lkdGg7XG4gICAgd2lkdGggPSBNYXRoLmFicyh3aWR0aCk7XG4gIH1cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ICs9IGhlaWdodDtcbiAgICBoZWlnaHQgPSBNYXRoLmFicyhoZWlnaHQpO1xuICB9XG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKVxuICAgIHJldHVybjtcbiAgaWYgKGNsaXBCQm94ID09IG51bGwpIHtcbiAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHgwID0gTWF0aC5tYXgoeCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbih4ICsgd2lkdGgsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heCh5LCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHkgKyBoZWlnaHQsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNsaXBCQm94ID0gbmV3IEJCb3goeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgfVxuICBjb25zdCBib3JkZXJTY2FsZSA9IE1hdGgubWF4KG1heFZlcnRpY2FsQ29ybmVyUmFkaXVzIC8gaGVpZ2h0LCBtYXhIb3Jpem9udGFsQ29ybmVyUmFkaXVzIC8gd2lkdGgsIDEpO1xuICBpZiAoYm9yZGVyU2NhbGUgPiAxKSB7XG4gICAgdG9wTGVmdENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICB0b3BSaWdodENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICBib3R0b21SaWdodENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIC89IGJvcmRlclNjYWxlO1xuICB9XG4gIGxldCBkcmF3VG9wTGVmdENvcm5lciA9IHRydWU7XG4gIGxldCBkcmF3VG9wUmlnaHRDb3JuZXIgPSB0cnVlO1xuICBsZXQgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IGRyYXdCb3R0b21MZWZ0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IHRvcExlZnRDb3JuZXI7XG4gIGxldCB0b3BSaWdodENvcm5lcjtcbiAgbGV0IGJvdHRvbVJpZ2h0Q29ybmVyO1xuICBsZXQgYm90dG9tTGVmdENvcm5lcjtcbiAgaWYgKGRyYXdUb3BMZWZ0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgTWF0aC5tYXgoeCArIHRvcExlZnRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC54LCAwKSxcbiAgICAgIE1hdGgubWF4KHkgKyB0b3BMZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueSwgMCksXG4gICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMudHJhaWxpbmcwLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCBjeCA9IHggKyB0b3BMZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIHRvcExlZnRDb3JuZXJSYWRpdXM7XG4gICAgdG9wTGVmdENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3VG9wUmlnaHRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBNYXRoLm1heCh5ICsgdG9wUmlnaHRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC55LCAwKSxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtICh4ICsgd2lkdGggLSB0b3BSaWdodENvcm5lclJhZGl1cyksIDApLFxuICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGlmIChub2Rlcy5sZWFkaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BMZWZ0Q29ybmVyID0gZmFsc2U7XG4gICAgaWYgKG5vZGVzLnRyYWlsaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdCb3R0b21SaWdodENvcm5lciA9IGZhbHNlO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMudHJhaWxpbmcwLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgY3ggPSB4ICsgd2lkdGggLSB0b3BSaWdodENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyB0b3BSaWdodENvcm5lclJhZGl1cztcbiAgICB0b3BSaWdodENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3Qm90dG9tUmlnaHRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBNYXRoLm1heChjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSAoeCArIHdpZHRoIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSAoeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICBib3R0b21SaWdodENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcFJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgaWYgKG5vZGVzLnRyYWlsaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdCb3R0b21MZWZ0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1pbihjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MCA9IE1hdGgubWluKGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbihjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMudHJhaWxpbmcwLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCBjeCA9IHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGJvdHRvbVJpZ2h0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21MZWZ0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgTWF0aC5tYXgoY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtICh5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdENvcm5lclJhZGl1cyksIDApLFxuICAgICAgTWF0aC5tYXgoeCArIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC54LCAwKSxcbiAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGlmIChub2Rlcy5sZWFkaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdCb3R0b21SaWdodENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGNvbnN0IHgwID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB5MCA9IE1hdGgubWluKGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heChjbGlwQkJveC54ICsgbm9kZXMudHJhaWxpbmcwLCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IGN4ID0geCArIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgY3kgPSB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdENvcm5lclJhZGl1cztcbiAgICBib3R0b21MZWZ0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgbGV0IGRpZE1vdmUgPSBmYWxzZTtcbiAgaWYgKGRyYXdUb3BMZWZ0Q29ybmVyICYmIHRvcExlZnRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgdG9wTGVmdENvcm5lciwgdG9wTGVmdENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBpZiAoZHJhd1RvcFJpZ2h0Q29ybmVyICYmIHRvcFJpZ2h0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIHRvcFJpZ2h0Q29ybmVyLCB0b3BSaWdodENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBpZiAoZHJhd0JvdHRvbVJpZ2h0Q29ybmVyICYmIGJvdHRvbVJpZ2h0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIGJvdHRvbVJpZ2h0Q29ybmVyLCBib3R0b21SaWdodENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBpZiAoZHJhd0JvdHRvbUxlZnRDb3JuZXIgJiYgYm90dG9tTGVmdENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCBib3R0b21MZWZ0Q29ybmVyLCBib3R0b21MZWZ0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIHBhdGguY2xvc2VQYXRoKCk7XG59O1xudmFyIFJlY3QgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuYm9yZGVyUGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMTA7XG4gICAgdGhpcy5oZWlnaHQgPSAxMDtcbiAgICB0aGlzLnRvcExlZnRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5jbGlwQkJveCA9IHZvaWQgMDtcbiAgICB0aGlzLmNyaXNwID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0VXBkYXRlUGF0aFN0cm9rZVdpZHRoID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmVmZmVjdGl2ZVN0cm9rZVdpZHRoID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmhpdHRlc3RlciA9IHN1cGVyLmlzUG9pbnRJblBhdGg7XG4gICAgdGhpcy5kaXN0YW5jZUNhbGN1bGF0b3IgPSBzdXBlci5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHJlY3RhbmdsZSdzIHdpZHRoIG9yIGhlaWdodCBpcyBsZXNzIHRoYW4gYSBwaXhlbFxuICAgICAqIGFuZCBjcmlzcCBtb2RlIGlzIG9uLCB0aGUgcmVjdGFuZ2xlIHdpbGwgc3RpbGwgZml0IGludG8gdGhlIHBpeGVsLFxuICAgICAqIGJ1dCB3aWxsIGJlIGxlc3Mgb3BhcXVlIHRvIG1ha2UgYW4gZWZmZWN0IG9mIGhvbGRpbmcgbGVzcyBzcGFjZS5cbiAgICAgKi9cbiAgICB0aGlzLm1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gMTtcbiAgfVxuICBzZXQgY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cykge1xuICAgIHRoaXMudG9wTGVmdENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICB0aGlzLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICAgIHRoaXMuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gICAgdGhpcy5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICB9XG4gIGlzRGlydHlQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggIT09IHRoaXMuc3Ryb2tlV2lkdGggfHwgQm9vbGVhbih0aGlzLnBhdGguaXNEaXJ0eSgpIHx8IHRoaXMuYm9yZGVyUGF0aC5pc0RpcnR5KCkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aCxcbiAgICAgIGJvcmRlclBhdGgsXG4gICAgICBjcmlzcCxcbiAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IHRvcExlZnQsXG4gICAgICB0b3BSaWdodENvcm5lclJhZGl1czogdG9wUmlnaHQsXG4gICAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogYm90dG9tUmlnaHQsXG4gICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiBib3R0b21MZWZ0XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHsgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCwgc3Ryb2tlV2lkdGgsIGNsaXBCQm94IH0gPSB0aGlzO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzLnBpeGVsUmF0aW8gPz8gMTtcbiAgICBjb25zdCBwaXhlbFNpemUgPSAxIC8gcGl4ZWxSYXRpbztcbiAgICBsZXQgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgYm9yZGVyUGF0aC5jbGVhcih0cnVlKTtcbiAgICBpZiAoY3Jpc3ApIHtcbiAgICAgIGlmICh3IDw9IHBpeGVsU2l6ZSkge1xuICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSAqPSB3IC8gcGl4ZWxTaXplO1xuICAgICAgfVxuICAgICAgaWYgKGggPD0gcGl4ZWxTaXplKSB7XG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ICo9IGggLyBwaXhlbFNpemU7XG4gICAgICB9XG4gICAgICB3ID0gdGhpcy5hbGlnbih4LCB3KTtcbiAgICAgIGggPSB0aGlzLmFsaWduKHksIGgpO1xuICAgICAgeCA9IHRoaXMuYWxpZ24oeCk7XG4gICAgICB5ID0gdGhpcy5hbGlnbih5KTtcbiAgICAgIGNsaXBCQm94ID0gY2xpcEJCb3ggIT0gbnVsbCA/IG5ldyBCQm94KFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LngpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LnkpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LngsIGNsaXBCQm94LndpZHRoKSxcbiAgICAgICAgdGhpcy5hbGlnbihjbGlwQkJveC55LCBjbGlwQkJveC5oZWlnaHQpXG4gICAgICApIDogdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgIGlmICh3IDwgcGl4ZWxTaXplKSB7XG4gICAgICAgIGNvbnN0IGx4ID0geCArIHBpeGVsU2l6ZSAvIDI7XG4gICAgICAgIGJvcmRlclBhdGgubW92ZVRvKGx4LCB5KTtcbiAgICAgICAgYm9yZGVyUGF0aC5saW5lVG8obHgsIHkgKyBoKTtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBwaXhlbFNpemU7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKGggPCBwaXhlbFNpemUpIHtcbiAgICAgICAgY29uc3QgbHkgPSB5ICsgcGl4ZWxTaXplIC8gMjtcbiAgICAgICAgYm9yZGVyUGF0aC5tb3ZlVG8oeCwgbHkpO1xuICAgICAgICBib3JkZXJQYXRoLmxpbmVUbyh4ICsgdywgbHkpO1xuICAgICAgICBzdHJva2VXaWR0aCA9IHBpeGVsU2l6ZTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlV2lkdGggPCB3ICYmIHN0cm9rZVdpZHRoIDwgaCkge1xuICAgICAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIHggKz0gaGFsZlN0cm9rZVdpZHRoO1xuICAgICAgICB5ICs9IGhhbGZTdHJva2VXaWR0aDtcbiAgICAgICAgdyAtPSBzdHJva2VXaWR0aDtcbiAgICAgICAgaCAtPSBzdHJva2VXaWR0aDtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRDbGlwQkJveCA9IGNsaXBCQm94Py5jbG9uZSgpLnNocmluayhoYWxmU3Ryb2tlV2lkdGgpO1xuICAgICAgICBjb25zdCBjb3JuZXJSYWRpaSA9IHtcbiAgICAgICAgICB0b3BMZWZ0OiB0b3BMZWZ0ID4gMCA/IHRvcExlZnQgLSBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgdG9wUmlnaHQ6IHRvcFJpZ2h0ID4gMCA/IHRvcFJpZ2h0IC0gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodCA+IDAgPyBib3R0b21SaWdodCAtIHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgICBib3R0b21MZWZ0OiBib3R0b21MZWZ0ID4gMCA/IGJvdHRvbUxlZnQgLSBzdHJva2VXaWR0aCA6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHcgPiAwICYmIGggPiAwICYmIChhZGp1c3RlZENsaXBCQm94ID09IG51bGwgfHwgYWRqdXN0ZWRDbGlwQkJveD8ud2lkdGggPiAwICYmIGFkanVzdGVkQ2xpcEJCb3g/LmhlaWdodCA+IDApKSB7XG4gICAgICAgICAgaW5zZXRDb3JuZXJSYWRpdXNSZWN0KHBhdGgsIHgsIHksIHcsIGgsIGNvcm5lclJhZGlpLCBhZGp1c3RlZENsaXBCQm94KTtcbiAgICAgICAgICBpbnNldENvcm5lclJhZGl1c1JlY3QoYm9yZGVyUGF0aCwgeCwgeSwgdywgaCwgY29ybmVyUmFkaWksIGFkanVzdGVkQ2xpcEJCb3gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdGhpcy5ib3JkZXJDbGlwUGF0aCA/PyBuZXcgRXh0ZW5kZWRQYXRoMkQoKTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICBib3JkZXJQYXRoLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvcm5lclJhZGlpID0geyB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQgfTtcbiAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICBpbnNldENvcm5lclJhZGl1c1JlY3QocGF0aCwgeCwgeSwgdywgaCwgY29ybmVyUmFkaWksIGNsaXBCQm94KTtcbiAgICB9XG4gICAgaWYgKFt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnRdLmV2ZXJ5KChyKSA9PiByID09PSAwKSkge1xuICAgICAgdGhpcy5oaXR0ZXN0ZXIgPSAoaGl0WCwgaGl0WSkgPT4ge1xuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoaGl0WCwgaGl0WSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKS5jb250YWluc1BvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZGlzdGFuY2VTcXVhcmVkID0gKGhpdFgsIGhpdFkpID0+IHRoaXMuZ2V0QkJveCgpLmRpc3RhbmNlU3F1YXJlZChoaXRYLCBoaXRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaXR0ZXN0ZXIgPSBzdXBlci5pc1BvaW50SW5QYXRoO1xuICAgICAgdGhpcy5kaXN0YW5jZUNhbGN1bGF0b3IgPSBzdXBlci5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50O1xuICAgIH1cbiAgICB0aGlzLmVmZmVjdGl2ZVN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5sYXN0VXBkYXRlUGF0aFN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5taWNyb1BpeGVsRWZmZWN0T3BhY2l0eSA9IG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5O1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2xpcEJCb3ggfSA9IHRoaXM7XG4gICAgcmV0dXJuIGNsaXBCQm94Py5jbG9uZSgpID8/IG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhpdHRlc3Rlcih4LCB5KTtcbiAgfVxuICBnZXQgbWlkUG9pbnQoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VDYWxjdWxhdG9yKHgsIHkpO1xuICB9XG4gIGFwcGx5RmlsbEFscGhhKGN0eCkge1xuICAgIGNvbnN0IHsgZmlsbE9wYWNpdHksIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5LCBvcGFjaXR5IH0gPSB0aGlzO1xuICAgIGN0eC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5ICogZmlsbE9wYWNpdHkgKiBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eTtcbiAgfVxuICByZW5kZXJTdHJva2UoY3R4KSB7XG4gICAgY29uc3QgeyBzdHJva2UsIGVmZmVjdGl2ZVN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgIGlmIChzdHJva2UgJiYgZWZmZWN0aXZlU3Ryb2tlV2lkdGgpIHtcbiAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBsaW5lQ2FwLFxuICAgICAgICBsaW5lSm9pbixcbiAgICAgICAgYm9yZGVyUGF0aCxcbiAgICAgICAgYm9yZGVyQ2xpcFBhdGgsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmIChib3JkZXJDbGlwUGF0aCkge1xuICAgICAgICBjdHguY2xpcChib3JkZXJDbGlwUGF0aC5nZXRQYXRoMkQoKSk7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gb3BhY2l0eSAqIHN0cm9rZU9wYWNpdHkgKiBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBlZmZlY3RpdmVTdHJva2VXaWR0aDtcbiAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZShib3JkZXJQYXRoLmdldFBhdGgyRCgpKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIH1cbiAgfVxufTtcblJlY3QuY2xhc3NOYW1lID0gXCJSZWN0XCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ0b3BMZWZ0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInRvcFJpZ2h0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiY2xpcEJCb3hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiY3Jpc3BcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2JhY2tncm91bmQvYmFja2dyb3VuZC50c1xudmFyIEJhY2tncm91bmQgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgekluZGV4ID0gMCAvKiBTRVJJRVNfQkFDS0dST1VORF9aSU5ERVggKi8sIGxheWVyID0gZmFsc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuekluZGV4ID0gekluZGV4O1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLnJlY3ROb2RlID0gbmV3IFJlY3QoKTtcbiAgICB0aGlzLnRleHROb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmZpbGwgPSBcIndoaXRlXCI7XG4gICAgdGhpcy5ub2RlID0gbmV3IEdyb3VwKHsgbmFtZTogXCJiYWNrZ3JvdW5kXCIsIHpJbmRleDogdGhpcy56SW5kZXgsIGxheWVyOiB0aGlzLmxheWVyIH0pO1xuICAgIHRoaXMubm9kZS5hcHBlbmQoW3RoaXMucmVjdE5vZGUsIHRoaXMudGV4dE5vZGVdKTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LnNjZW5lLmF0dGFjaE5vZGUodGhpcy5ub2RlKSxcbiAgICAgIGN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpXG4gICAgKTtcbiAgfVxuICBvbkxheW91dENvbXBsZXRlKGUpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGUuY2hhcnQ7XG4gICAgdGhpcy5yZWN0Tm9kZS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMucmVjdE5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiLCBcInZpc2libGVcIilcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwicmVjdE5vZGVcIiwgXCJmaWxsXCIpXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJpbWFnZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJ0ZXh0Tm9kZVwiKVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYmFja2dyb3VuZC9iYWNrZ3JvdW5kTW9kdWxlLnRzXG52YXIgQmFja2dyb3VuZE1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwiYmFja2dyb3VuZFwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJhY2tncm91bmQoY3R4KVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc3ByaXRlUmVuZGVyZXIudHNcbnZhciBTcHJpdGVSZW5kZXJlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vZmZzY3JlZW5DYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMub2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoY3R4ID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBRyBDaGFydHMgLSBpbnZhbGlkIDJkIGNvbnRleHRgKTtcbiAgICB0aGlzLnJlbmRlckN0eCA9IHtcbiAgICAgIGN0eCxcbiAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXG4gICAgICBmb3JjZVJlbmRlcjogdHJ1ZSxcbiAgICAgIHJlc2l6ZWQ6IGZhbHNlLFxuICAgICAgZGVidWdOb2Rlczoge31cbiAgICB9O1xuICB9XG4gIHJlc2l6ZSh7IHNwcml0ZVBpeGVsUmF0aW8sIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQgfSkge1xuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gTWF0aC5tYXgoc3ByaXRlV2lkdGgsIDApICogc3ByaXRlUGl4ZWxSYXRpbztcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChzcHJpdGVIZWlnaHQsIDApICogc3ByaXRlUGl4ZWxSYXRpbztcbiAgfVxuICByZW5kZXJTcHJpdGUobm9kZXMsIG9wdHMpIHtcbiAgICBub2RlcyA9IHRvSXRlcmFibGUobm9kZXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlckN0eCxcbiAgICAgIHJlbmRlckN0eDogeyBjdHggfSxcbiAgICAgIG9mZnNjcmVlbkNhbnZhc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiA9IDEsIHRyYW5zbGF0ZVggPSAwLCB0cmFuc2xhdGVZID0gMCB9ID0gb3B0cyA/PyB7fTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShzY2FsZTIsIDAsIDAsIHNjYWxlMiwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBub2RlLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICByZXR1cm4gb2Zmc2NyZWVuQ2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2tleW5hdlV0aWwudHNcbmZ1bmN0aW9uIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgYnV0dG9uLCB0eXBlLCBsaXN0ZW5lcikge1xuICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIGRlc3Ryb3lGbnMucHVzaCgoKSA9PiBidXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikpO1xufVxuZnVuY3Rpb24gYWRkRXNjYXBlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBlbGVtLCBvbkVzY2FwZSkge1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGVsZW0sIFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICBvbkVzY2FwZShldmVudCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNLZXkoZXZlbnQsIGtleSwgLi4ubW9yZWtleXMpIHtcbiAgcmV0dXJuICEoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgKGV2ZW50LmtleSA9PT0ga2V5IHx8IG1vcmVrZXlzLnNvbWUoKGFsdGtleSkgPT4gZXZlbnQua2V5ID09PSBhbHRrZXkpKTtcbn1cbmZ1bmN0aW9uIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIHNyYywgZHN0LCBrZXkpIHtcbiAgaWYgKCFkc3QpXG4gICAgcmV0dXJuO1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIHNyYywgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChtYXRjaGVzS2V5KGV2ZW50LCBrZXkpKSB7XG4gICAgICBkc3QuZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlua1RocmVlQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5LCBwcmV2LCBwcmV2S2V5KSB7XG4gIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIHByZXYsIHByZXZLZXkpO1xuICBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5KTtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKG1hdGNoZXNLZXkoZXZlbnQsIG5leHRLZXksIHByZXZLZXkpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59XG52YXIgUFJFVl9ORVhUX0tFWVMgPSB7XG4gIGhvcml6b250YWw6IHsgbmV4dEtleTogXCJBcnJvd1JpZ2h0XCIsIHByZXZLZXk6IFwiQXJyb3dMZWZ0XCIgfSxcbiAgdmVydGljYWw6IHsgbmV4dEtleTogXCJBcnJvd0Rvd25cIiwgcHJldktleTogXCJBcnJvd1VwXCIgfVxufTtcbmZ1bmN0aW9uIGluaXRUb29sYmFyS2V5TmF2KG9wdHMpIHtcbiAgY29uc3QgeyBvcmllbnRhdGlvbiwgdG9vbGJhciwgYnV0dG9ucywgb25Fc2NhcGUsIG9uRm9jdXMsIG9uQmx1ciB9ID0gb3B0cztcbiAgY29uc3QgeyBuZXh0S2V5LCBwcmV2S2V5IH0gPSBQUkVWX05FWFRfS0VZU1tvcmllbnRhdGlvbl07XG4gIGNvbnN0IGFyaWFIaWRkZW4gPSBidXR0b25zLmxlbmd0aCA9PT0gMDtcbiAgdG9vbGJhci5yb2xlID0gXCJ0b29sYmFyXCI7XG4gIHRvb2xiYXIuYXJpYU9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gIHRvb2xiYXIuYXJpYUhpZGRlbiA9IGFyaWFIaWRkZW4udG9TdHJpbmcoKTtcbiAgY29uc3Qgc2V0VGFiSW5kaWNlcyA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC50YXJnZXQgJiYgXCJ0YWJJbmRleFwiIGluIGV2ZW50LnRhcmdldCkge1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKChiKSA9PiBiLnRhYkluZGV4ID0gLTEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3lGbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJldiA9IGJ1dHRvbnNbaSAtIDFdO1xuICAgIGNvbnN0IGN1cnIgPSBidXR0b25zW2ldO1xuICAgIGNvbnN0IG5leHQgPSBidXR0b25zW2kgKyAxXTtcbiAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwiZm9jdXNcIiwgc2V0VGFiSW5kaWNlcyk7XG4gICAgaWYgKG9uRm9jdXMpXG4gICAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwiZm9jdXNcIiwgb25Gb2N1cyk7XG4gICAgaWYgKG9uQmx1cilcbiAgICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJibHVyXCIsIG9uQmx1cik7XG4gICAgaWYgKG9uRXNjYXBlKVxuICAgICAgYWRkRXNjYXBlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBvbkVzY2FwZSk7XG4gICAgbGlua1RocmVlQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBwcmV2LCBwcmV2S2V5LCBuZXh0LCBuZXh0S2V5KTtcbiAgICBjdXJyLnRhYkluZGV4ID0gaSA9PT0gMCA/IDAgOiAtMTtcbiAgfVxuICByZXR1cm4gZGVzdHJveUZucztcbn1cbmZ1bmN0aW9uIGluaXRNZW51S2V5TmF2KG9wdHMpIHtcbiAgY29uc3QgeyBvcmllbnRhdGlvbiwgbWVudSwgYnV0dG9ucywgb25Fc2NhcGUgfSA9IG9wdHM7XG4gIGNvbnN0IHsgbmV4dEtleSwgcHJldktleSB9ID0gUFJFVl9ORVhUX0tFWVNbb3JpZW50YXRpb25dO1xuICBtZW51LnJvbGUgPSBcIm1lbnVcIjtcbiAgbWVudS5hcmlhT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgY29uc3QgZGVzdHJveUZucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gYnV0dG9uc1soYnV0dG9ucy5sZW5ndGggKyBpIC0gMSkgJSBidXR0b25zLmxlbmd0aF07XG4gICAgY29uc3QgY3VyciA9IGJ1dHRvbnNbaV07XG4gICAgY29uc3QgbmV4dCA9IGJ1dHRvbnNbKGJ1dHRvbnMubGVuZ3RoICsgaSArIDEpICUgYnV0dG9ucy5sZW5ndGhdO1xuICAgIGlmIChvbkVzY2FwZSlcbiAgICAgIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3Vyciwgb25Fc2NhcGUpO1xuICAgIGxpbmtUaHJlZUJ1dHRvbnMoZGVzdHJveUZucywgY3VyciwgcHJldiwgcHJldktleSwgbmV4dCwgbmV4dEtleSk7XG4gICAgY3Vyci50YWJJbmRleCA9IC0xO1xuICB9XG4gIG1lbnUudGFiSW5kZXggPSAtMTtcbiAgaWYgKG9uRXNjYXBlKVxuICAgIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgbWVudSwgb25Fc2NhcGUpO1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIFwia2V5ZG93blwiLCAoZXYpID0+IHtcbiAgICBpZiAoZXYudGFyZ2V0ID09PSBtZW51ICYmIChldi5rZXkgPT09IG5leHRLZXkgfHwgZXYua2V5ID09PSBwcmV2S2V5KSkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGJ1dHRvbnNbMF0/LmZvY3VzKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRlc3Ryb3lGbnM7XG59XG5mdW5jdGlvbiBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXIoZWxlbWVudDIsIG9uY2xpY2spIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50Mi5hcmlhRGlzYWJsZWQgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25jbGljayhldmVudCk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2dyaWRMYXlvdXQudHNcbmZ1bmN0aW9uIGdyaWRMYXlvdXQoe1xuICBvcmllbnRhdGlvbixcbiAgYmJveGVzLFxuICBtYXhIZWlnaHQsXG4gIG1heFdpZHRoLFxuICBpdGVtUGFkZGluZ1kgPSAwLFxuICBpdGVtUGFkZGluZ1ggPSAwLFxuICBmb3JjZVJlc3VsdCA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGhvcml6b250YWwgPSBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IHByaW1hcnkgPSB7XG4gICAgbWF4OiBob3Jpem9udGFsID8gbWF4V2lkdGggOiBtYXhIZWlnaHQsXG4gICAgZm46IGhvcml6b250YWwgPyAoYikgPT4gYi53aWR0aCA6IChiKSA9PiBiLmhlaWdodCxcbiAgICBwYWRkaW5nOiBob3Jpem9udGFsID8gaXRlbVBhZGRpbmdYIDogaXRlbVBhZGRpbmdZXG4gIH07XG4gIGNvbnN0IHNlY29uZGFyeSA9IHtcbiAgICBtYXg6IGhvcml6b250YWwgPyBtYXhIZWlnaHQgOiBtYXhXaWR0aCxcbiAgICBmbjogaG9yaXpvbnRhbCA/IChiKSA9PiBiLmhlaWdodCA6IChiKSA9PiBiLndpZHRoLFxuICAgIHBhZGRpbmc6IGhvcml6b250YWwgPyBpdGVtUGFkZGluZ1kgOiBpdGVtUGFkZGluZ1hcbiAgfTtcbiAgbGV0IHByb2Nlc3NlZEJCb3hDb3VudCA9IDA7XG4gIGNvbnN0IHJhd1BhZ2VzID0gW107XG4gIHdoaWxlIChwcm9jZXNzZWRCQm94Q291bnQgPCBiYm94ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgdW5wcm9jZXNzZWRCQm94ZXMgPSBiYm94ZXMuc2xpY2UocHJvY2Vzc2VkQkJveENvdW50KTtcbiAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzQkJveGVzKHVucHJvY2Vzc2VkQkJveGVzLCBwcm9jZXNzZWRCQm94Q291bnQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NlZEJCb3hDb3VudCArPSByZXN1bHQucHJvY2Vzc2VkQkJveENvdW50O1xuICAgIHJhd1BhZ2VzLnB1c2gocmVzdWx0LnBhZ2VJbmRpY2VzKTtcbiAgfVxuICByZXR1cm4gYnVpbGRQYWdlcyhyYXdQYWdlcywgb3JpZW50YXRpb24sIGJib3hlcywgaXRlbVBhZGRpbmdZLCBpdGVtUGFkZGluZ1gpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0JCb3hlcyhiYm94ZXMsIGluZGV4T2Zmc2V0LCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KSB7XG4gIGNvbnN0IG1pbkd1ZXNzID0gMTtcbiAgbGV0IHN0YXJ0aW5nR3Vlc3MgPSBlc3RpbWF0ZVN0YXJ0aW5nR3Vlc3MoYmJveGVzLCBwcmltYXJ5KTtcbiAgaWYgKHN0YXJ0aW5nR3Vlc3MgPCBtaW5HdWVzcykge1xuICAgIGlmICghZm9yY2VSZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhcnRpbmdHdWVzcyA9IG1pbkd1ZXNzO1xuICB9XG4gIGxldCBndWVzcyA9IHN0YXJ0aW5nR3Vlc3M7XG4gIHdoaWxlIChndWVzcyA+PSBtaW5HdWVzcykge1xuICAgIGNvbnN0IHBhZ2VJbmRpY2VzID0gY2FsY3VsYXRlUGFnZShiYm94ZXMsIGluZGV4T2Zmc2V0LCBndWVzcywgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCk7XG4gICAgaWYgKHBhZ2VJbmRpY2VzID09IG51bGwgJiYgZ3Vlc3MgPD0gbWluR3Vlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhZ2VJbmRpY2VzID09IG51bGwpIHtcbiAgICAgIGd1ZXNzLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWdlSW5kaWNlcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKHBhZ2VJbmRpY2VzIDw9IG1pbkd1ZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGd1ZXNzID0gcGFnZUluZGljZXMgPCBndWVzcyAmJiBwYWdlSW5kaWNlcyA+IG1pbkd1ZXNzID8gcGFnZUluZGljZXMgOiBndWVzcztcbiAgICAgIGd1ZXNzLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcHJvY2Vzc2VkQkJveENvdW50ID0gcGFnZUluZGljZXMubGVuZ3RoICogcGFnZUluZGljZXNbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB7IHByb2Nlc3NlZEJCb3hDb3VudCwgcGFnZUluZGljZXMgfTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlUGFnZShiYm94ZXMsIGluZGV4T2Zmc2V0LCBwcmltYXJ5Q291bnQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzdW1TZWNvbmRhcnkgPSAwO1xuICBsZXQgY3VycmVudE1heFNlY29uZGFyeSA9IDA7XG4gIGxldCBjdXJyZW50UHJpbWFyeUluZGljZXMgPSBbXTtcbiAgY29uc3QgbWF4UHJpbWFyeVZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBiYm94SW5kZXggPSAwOyBiYm94SW5kZXggPCBiYm94ZXMubGVuZ3RoOyBiYm94SW5kZXgrKykge1xuICAgIGNvbnN0IHByaW1hcnlWYWx1ZUlkeCA9IChiYm94SW5kZXggKyBwcmltYXJ5Q291bnQpICUgcHJpbWFyeUNvdW50O1xuICAgIGlmIChwcmltYXJ5VmFsdWVJZHggPT09IDApIHtcbiAgICAgIHN1bVNlY29uZGFyeSArPSBjdXJyZW50TWF4U2Vjb25kYXJ5O1xuICAgICAgY3VycmVudE1heFNlY29uZGFyeSA9IDA7XG4gICAgICBpZiAoY3VycmVudFByaW1hcnlJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFByaW1hcnlJbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRQcmltYXJ5SW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBwcmltYXJ5VmFsdWUgPSBwcmltYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHByaW1hcnkucGFkZGluZztcbiAgICBtYXhQcmltYXJ5VmFsdWVzW3ByaW1hcnlWYWx1ZUlkeF0gPSBNYXRoLm1heChtYXhQcmltYXJ5VmFsdWVzW3ByaW1hcnlWYWx1ZUlkeF0gPz8gMCwgcHJpbWFyeVZhbHVlKTtcbiAgICBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gTWF0aC5tYXgoY3VycmVudE1heFNlY29uZGFyeSwgc2Vjb25kYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHNlY29uZGFyeS5wYWRkaW5nKTtcbiAgICBjb25zdCBjdXJyZW50U2Vjb25kYXJ5RGltZW5zaW9uID0gc3VtU2Vjb25kYXJ5ICsgY3VycmVudE1heFNlY29uZGFyeTtcbiAgICBjb25zdCByZXR1cm5SZXN1bHQgPSAhZm9yY2VSZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgaWYgKGN1cnJlbnRTZWNvbmRhcnlEaW1lbnNpb24gPiBzZWNvbmRhcnkubWF4ICYmIHJldHVyblJlc3VsdCkge1xuICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3Qgc3VtUHJpbWFyeSA9IG1heFByaW1hcnlWYWx1ZXMucmVkdWNlKChzdW0yLCBuZXh0KSA9PiBzdW0yICsgbmV4dCwgMCk7XG4gICAgaWYgKHN1bVByaW1hcnkgPiBwcmltYXJ5Lm1heCAmJiAhZm9yY2VSZXN1bHQpIHtcbiAgICAgIGlmIChtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aCA8IHByaW1hcnlDb3VudCkge1xuICAgICAgICByZXR1cm4gbWF4UHJpbWFyeVZhbHVlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQcmltYXJ5SW5kaWNlcy5wdXNoKGJib3hJbmRleCArIGluZGV4T2Zmc2V0KTtcbiAgfVxuICBpZiAoY3VycmVudFByaW1hcnlJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQucHVzaChjdXJyZW50UHJpbWFyeUluZGljZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID4gMCA/IHJlc3VsdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGFnZXMocmF3UGFnZXMsIG9yaWVudGF0aW9uLCBiYm94ZXMsIGl0ZW1QYWRkaW5nWSwgaXRlbVBhZGRpbmdYKSB7XG4gIGxldCBtYXhQYWdlV2lkdGggPSAwO1xuICBsZXQgbWF4UGFnZUhlaWdodCA9IDA7XG4gIGNvbnN0IHBhZ2VzID0gcmF3UGFnZXMubWFwKChpbmRpY2VzKSA9PiB7XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgaW5kaWNlcyA9IHRyYW5zcG9zZShpbmRpY2VzKTtcbiAgICB9XG4gICAgbGV0IGVuZEluZGV4ID0gMDtcbiAgICBjb25zdCBjb2x1bW5zID0gaW5kaWNlcy5tYXAoKGNvbEluZGljZXMpID0+IHtcbiAgICAgIGNvbnN0IGNvbEJCb3hlcyA9IGNvbEluZGljZXMubWFwKChiYm94SW5kZXgpID0+IHtcbiAgICAgICAgZW5kSW5kZXggPSBNYXRoLm1heChiYm94SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgcmV0dXJuIGJib3hlc1tiYm94SW5kZXhdO1xuICAgICAgfSk7XG4gICAgICBsZXQgY29sdW1uSGVpZ2h0ID0gMDtcbiAgICAgIGxldCBjb2x1bW5XaWR0aCA9IDA7XG4gICAgICBjb2xCQm94ZXMuZm9yRWFjaCgoYmJveCkgPT4ge1xuICAgICAgICBjb2x1bW5IZWlnaHQgKz0gYmJveC5oZWlnaHQgKyBpdGVtUGFkZGluZ1k7XG4gICAgICAgIGNvbHVtbldpZHRoID0gTWF0aC5tYXgoY29sdW1uV2lkdGgsIGJib3gud2lkdGggKyBpdGVtUGFkZGluZ1gpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRpY2VzOiBjb2xJbmRpY2VzLFxuICAgICAgICBiYm94ZXM6IGNvbEJCb3hlcyxcbiAgICAgICAgY29sdW1uSGVpZ2h0OiBNYXRoLmNlaWwoY29sdW1uSGVpZ2h0KSxcbiAgICAgICAgY29sdW1uV2lkdGg6IE1hdGguY2VpbChjb2x1bW5XaWR0aClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IHBhZ2VXaWR0aCA9IDA7XG4gICAgbGV0IHBhZ2VIZWlnaHQgPSAwO1xuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICBwYWdlV2lkdGggKz0gY29sdW1uLmNvbHVtbldpZHRoO1xuICAgICAgcGFnZUhlaWdodCA9IE1hdGgubWF4KHBhZ2VIZWlnaHQsIGNvbHVtbi5jb2x1bW5IZWlnaHQpO1xuICAgIH0pO1xuICAgIG1heFBhZ2VXaWR0aCA9IE1hdGgubWF4KHBhZ2VXaWR0aCwgbWF4UGFnZVdpZHRoKTtcbiAgICBtYXhQYWdlSGVpZ2h0ID0gTWF0aC5tYXgocGFnZUhlaWdodCwgbWF4UGFnZUhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbnMsXG4gICAgICBzdGFydEluZGV4OiBpbmRpY2VzWzBdWzBdLFxuICAgICAgZW5kSW5kZXgsXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7IHBhZ2VzLCBtYXhQYWdlV2lkdGgsIG1heFBhZ2VIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zcG9zZShkYXRhKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IF8gb2YgZGF0YVswXSkge1xuICAgIHJlc3VsdC5wdXNoKFtdKTtcbiAgfVxuICBkYXRhLmZvckVhY2goKGlubmVyRGF0YSwgZGF0YUlkeCkgPT4ge1xuICAgIGlubmVyRGF0YS5mb3JFYWNoKChpdGVtLCBpdGVtSWR4KSA9PiB7XG4gICAgICByZXN1bHRbaXRlbUlkeF1bZGF0YUlkeF0gPSBpdGVtO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlU3RhcnRpbmdHdWVzcyhiYm94ZXMsIHByaW1hcnkpIHtcbiAgY29uc3QgbiA9IGJib3hlcy5sZW5ndGg7XG4gIGxldCBwcmltYXJ5U3VtID0gMDtcbiAgZm9yIChsZXQgYmJveEluZGV4ID0gMDsgYmJveEluZGV4IDwgbjsgYmJveEluZGV4KyspIHtcbiAgICBwcmltYXJ5U3VtICs9IHByaW1hcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgcHJpbWFyeS5wYWRkaW5nO1xuICAgIGlmIChwcmltYXJ5U3VtID4gcHJpbWFyeS5tYXgpIHtcbiAgICAgIGNvbnN0IHJhdGlvMiA9IG4gLyBiYm94SW5kZXg7XG4gICAgICBpZiAocmF0aW8yIDwgMikge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4gLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYm94SW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9pbWFnZS50c1xudmFyIEltYWdlID0gY2xhc3MgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlSW1hZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlSW1hZ2UgPSBzb3VyY2VJbWFnZTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gIH1cbiAgdXBkYXRlQml0bWFwKG5ld0JpdG1hcCwgYml0bWFwUGl4ZWxSYXRpbywgeCwgeSkge1xuICAgIHRoaXMuc291cmNlSW1hZ2UgPSBuZXdCaXRtYXA7XG4gICAgdGhpcy53aWR0aCA9IG5ld0JpdG1hcC53aWR0aCAvIGJpdG1hcFBpeGVsUmF0aW87XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdCaXRtYXAuaGVpZ2h0IC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLnggPSB4IC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLnkgPSB5IC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCAzIC8qIE1BSk9SICovKTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCsrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IHRoaXMuc291cmNlSW1hZ2U7XG4gICAgaWYgKCFpbWFnZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4KTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kTWFya2VyTGFiZWwudHNcbnZhciBMZWdlbmRNYXJrZXJMYWJlbCA9IGNsYXNzIGV4dGVuZHMgR3JvdXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IG5hbWU6IFwibWFya2VyTGFiZWxHcm91cFwiIH0pO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuc3ltYm9sc0dyb3VwID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IFwibGVnZW5kLW1hcmtlckxhYmVsLXN5bWJvbHNcIlxuICAgIH0pO1xuICAgIHRoaXMuYml0bWFwID0gbmV3IEltYWdlKCk7XG4gICAgdGhpcy5iaXRtYXBEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IE5hTjtcbiAgICB0aGlzLl9tYXJrZXJzID0gW107XG4gICAgdGhpcy5fbGluZXMgPSBbXTtcbiAgICBjb25zdCB7IG1hcmtlcnMsIGxhYmVsLCBsaW5lcyB9ID0gdGhpcztcbiAgICBsYWJlbC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIGxhYmVsLmZvbnRTaXplID0gMTI7XG4gICAgbGFiZWwuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICAgIGxhYmVsLmZpbGwgPSBcImJsYWNrXCI7XG4gICAgbGFiZWwueSA9IDE7XG4gICAgdGhpcy51cGRhdGVTeW1ib2xzKG1hcmtlcnMsIGxpbmVzKTtcbiAgICB0aGlzLmFwcGVuZChhcmdzSXRlcmFibGUodGhpcy5zeW1ib2xzR3JvdXAsIGxhYmVsKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5wcm94eUJ1dHRvbj8ucmVtb3ZlKCk7XG4gIH1cbiAgZ2V0IG1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmtlcnM7XG4gIH1cbiAgZ2V0IGxpbmVzKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lcztcbiAgfVxuICB1cGRhdGVTeW1ib2xzKG1hcmtlcnMsIGxpbmVzKSB7XG4gICAgaWYgKGFycmF5c0VxdWFsKHRoaXMuX21hcmtlcnMsIG1hcmtlcnMpICYmIGFycmF5c0VxdWFsKHRoaXMuX2xpbmVzLCBsaW5lcykpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5iaXRtYXBEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fbWFya2VycyA9IG1hcmtlcnM7XG4gICAgdGhpcy5fbGluZXMgPSBsaW5lcztcbiAgICB0aGlzLnN5bWJvbHNHcm91cC5jbGVhcigpO1xuICAgIHRoaXMuc3ltYm9sc0dyb3VwLmFwcGVuZChbdGhpcy5iaXRtYXAsIC4uLm1hcmtlcnMsIC4uLmxpbmVzXSk7XG4gIH1cbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB0aGlzLnJlZnJlc2hWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICByZWZyZXNoVmlzaWJpbGl0aWVzKCkge1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmVuYWJsZWQgPyAxIDogMC41O1xuICAgIHRoaXMubGFiZWwub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB0aGlzLmJpdG1hcC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB0aGlzLnNldEJpdG1hcFZpc2liaWxpdHkoIXRoaXMuZW5hYmxlZCk7XG4gIH1cbiAgc2V0Qml0bWFwVmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgY29uc3QgeyBsaW5lcywgbWFya2VycyB9ID0gdGhpcztcbiAgICBbbGluZXMsIG1hcmtlcnNdLmZvckVhY2goKHNoYXBlcykgPT4gc2hhcGVzLmZvckVhY2goKHNoYXBlKSA9PiBzaGFwZS52aXNpYmxlID0gIXZpc2libGUpKTtcbiAgICB0aGlzLmJpdG1hcC52aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxuICAvLyBUaGUgQkJveCBvZiB0aGlzLmJpdG1hcCBpcyBgc3ByaXRlUGFkZGluZ2AgcGl4ZWxzIGJpZ2dlciBpbiBlYWNoIGRpcmVjdGlvbiB0aGFuIEJCb3ggb2YgdGhlIG1hcmtlcnMgYW5kIGxpbmVzLlxuICAvLyBUaGlzIHBhZGRpbmcgYWxsb3dzIHRoZSBTcHJpdGVSZW5kZXJlciB0byBkcmF3IGFudGlhbGlhc2luZyBwaXhlbHMgdGhhdCBjYW4gZXh0ZW5kIGJleW9uZCB0aGUgc2hhcGVzJyBib3VuZHMuXG4gIHVwZGF0ZShzcHJpdGVSZW5kZXJlciwgeyBzcHJpdGVBQVBhZGRpbmcsIHNwcml0ZVBpeGVsUmF0aW86IHNjYWxlMiB9LCBkaW1lbnNpb25Qcm9wcykge1xuICAgIGNvbnN0IHsgbWFya2VycywgbGluZXMgfSA9IHRoaXM7XG4gICAgbGV0IHNwcml0ZVggPSAwO1xuICAgIGxldCBzcHJpdGVZID0gMDtcbiAgICBsZXQgc2hpZnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgobWFya2Vycy5sZW5ndGgsIGxpbmVzLmxlbmd0aCk7IGkrKykge1xuICAgICAgY29uc3QgeyBsZW5ndGg6IGxlbmd0aDIsIHNwYWNpbmcgfSA9IGRpbWVuc2lvblByb3BzW2ldID8/IDA7XG4gICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJzW2ldO1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgY29uc3Qgc2l6ZSA9IG1hcmtlcj8uc2l6ZSA/PyAwO1xuICAgICAgbGV0IGxpbmVUb3AgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtYXJrZXJUb3AgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtYXJrZXJMZWZ0ID0gSW5maW5pdHk7XG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcmtlci5jb25zdHJ1Y3Rvci5jZW50ZXI7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IChzaXplICsgbWFya2VyLnN0cm9rZVdpZHRoKSAvIDI7XG4gICAgICAgIG1hcmtlci54ID0gKGNlbnRlci54IC0gMC41KSAqIHNpemUgKyBsZW5ndGgyIC8gMiArIHNoaWZ0O1xuICAgICAgICBtYXJrZXIueSA9IChjZW50ZXIueSAtIDAuNSkgKiBzaXplO1xuICAgICAgICBtYXJrZXJUb3AgPSBtYXJrZXIueSAtIHJhZGl1cztcbiAgICAgICAgbWFya2VyTGVmdCA9IG1hcmtlci54IC0gcmFkaXVzO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgbGluZS54MSA9IHNoaWZ0O1xuICAgICAgICBsaW5lLngyID0gc2hpZnQgKyBsZW5ndGgyO1xuICAgICAgICBsaW5lLnkxID0gMDtcbiAgICAgICAgbGluZS55MiA9IDA7XG4gICAgICAgIGxpbmUubWFya0RpcnR5VHJhbnNmb3JtKCk7XG4gICAgICAgIGxpbmVUb3AgPSAtbGluZS5zdHJva2VXaWR0aCAvIDI7XG4gICAgICB9XG4gICAgICBzaGlmdCArPSBzcGFjaW5nICsgTWF0aC5tYXgobGVuZ3RoMiwgc2l6ZSk7XG4gICAgICBzcHJpdGVYID0gTWF0aC5taW4oc3ByaXRlWCwgbGluZS54MSwgbGluZS54MiwgbWFya2VyTGVmdCk7XG4gICAgICBzcHJpdGVZID0gTWF0aC5taW4oc3ByaXRlWSwgbGluZVRvcCwgbWFya2VyVG9wKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFN5bWJvbFByb3BzID0gZGltZW5zaW9uUHJvcHMuYXQoLTEpO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gdGhpcy5saW5lcy5hdCgtMSk7XG4gICAgY29uc3QgbGFzdE1hcmtlciA9IHRoaXMubWFya2Vycy5hdCgtMSk7XG4gICAgY29uc3QgbGluZUVuZCA9IGxhc3RMaW5lID8gbGFzdExpbmUueDIgOiAtSW5maW5pdHk7XG4gICAgY29uc3QgbWFya2VyRW5kID0gKGxhc3RNYXJrZXI/LnggPz8gMCkgKyAobGFzdE1hcmtlcj8uc2l6ZSA/PyAwKSAvIDI7XG4gICAgdGhpcy5sYWJlbC54ID0gTWF0aC5tYXgobGluZUVuZCwgbWFya2VyRW5kKSArIChsYXN0U3ltYm9sUHJvcHM/LnNwYWNpbmcgPz8gMCk7XG4gICAgaWYgKHRoaXMuYml0bWFwRGlydHkpIHtcbiAgICAgIHRoaXMuc2V0Qml0bWFwVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICBjb25zdCB0cmFuc2xhdGVYID0gKHNwcml0ZUFBUGFkZGluZyArIHNwcml0ZVgpICogc2NhbGUyO1xuICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IChzcHJpdGVBQVBhZGRpbmcgLSBzcHJpdGVZKSAqIHNjYWxlMjtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IHNwcml0ZVJlbmRlcmVyLnJlbmRlclNwcml0ZSh0aGlzLnN5bWJvbHNHcm91cCwge1xuICAgICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgICB0cmFuc2xhdGVYOiBNYXRoLmZsb29yKHRyYW5zbGF0ZVgpLFxuICAgICAgICB0cmFuc2xhdGVZOiBNYXRoLmZsb29yKHRyYW5zbGF0ZVkpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYml0bWFwLnVwZGF0ZUJpdG1hcChzcHJpdGUsIHNjYWxlMiwgTWF0aC5jZWlsKC10cmFuc2xhdGVYKSwgTWF0aC5jZWlsKC10cmFuc2xhdGVZKSk7XG4gICAgICB0aGlzLmJpdG1hcERpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnJlZnJlc2hWaXNpYmlsaXRpZXMoKTtcbiAgICB9XG4gICAgaWYgKGRpbWVuc2lvblByb3BzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IHRoaXMuc3ltYm9sc0dyb3VwLmdldEJCb3goKTtcbiAgICBjb25zdCBjbGlwcGVkV2lkdGggPSBNYXRoLm1heChsYXN0TWFya2VyPy5zaXplID8/IDAsIGxhc3RTeW1ib2xQcm9wcz8ubGVuZ3RoID8/IDApO1xuICAgIGNvbnN0IGNsaXBSZWN0ID0gbmV3IEJCb3goYmJveC54ICsgY2xpcHBlZFdpZHRoIC8gMiwgYmJveC55LCBjbGlwcGVkV2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICB0aGlzLnN5bWJvbHNHcm91cC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoY2xpcFJlY3QpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgbGFiZWwsIGxpbmVzLCBtYXJrZXJzIH0gPSB0aGlzO1xuICAgIHJldHVybiBHcm91cC5jb21wdXRlQkJveChhcnJheXNJdGVyYWJsZShbbGFiZWxdLCBsaW5lcywgbWFya2VycyksIHsgc2tpcEludmlzaWJsZTogZmFsc2UgfSk7XG4gIH1cbn07XG5MZWdlbmRNYXJrZXJMYWJlbC5jbGFzc05hbWUgPSBcIk1hcmtlckxhYmVsXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiLCBcImZpbGxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLnRzXG52YXIgUGFnaW5hdGlvbkxhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvciA9IFwiYmxhY2tcIjtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEyO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG52YXIgUGFnaW5hdGlvbk1hcmtlclN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaXplID0gMTU7XG4gICAgdGhpcy5maWxsID0gdm9pZCAwO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJva2UgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xudmFyIFBhZ2luYXRpb25NYXJrZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNoYXBlID0gVHJpYW5nbGU7XG4gICAgdGhpcy5zaXplID0gMTU7XG4gICAgdGhpcy5wYWRkaW5nID0gODtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5tYXJrZXIgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQub25NYXJrZXJTaGFwZUNoYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXIucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXIucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG52YXIgUGFnaW5hdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjaGFydFVwZGF0ZUNhbGxiYWNrLCBwYWdlVXBkYXRlQ2FsbGJhY2ssIHJlZ2lvbk1hbmFnZXIsIGN1cnNvck1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVDYWxsYmFjayA9IGNoYXJ0VXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5wYWdlVXBkYXRlQ2FsbGJhY2sgPSBwYWdlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5yZWdpb25NYW5hZ2VyID0gcmVnaW9uTWFuYWdlcjtcbiAgICB0aGlzLmN1cnNvck1hbmFnZXIgPSBjdXJzb3JNYW5hZ2VyO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBQYWdpbmF0aW9uTWFya2VyKHRoaXMpO1xuICAgIHRoaXMuYWN0aXZlU3R5bGUgPSBuZXcgUGFnaW5hdGlvbk1hcmtlclN0eWxlKCk7XG4gICAgdGhpcy5pbmFjdGl2ZVN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3R5bGUgPSBuZXcgUGFnaW5hdGlvbk1hcmtlclN0eWxlKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBQYWdpbmF0aW9uTGFiZWwoKTtcbiAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJwYWdpbmF0aW9uXCIgfSk7XG4gICAgdGhpcy5sYWJlbE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMudG90YWxQYWdlcyA9IDA7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLm5leHRCdXR0b25EaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMucHJldmlvdXNCdXR0b25EaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX29yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIHRoaXMuX25leHRCdXR0b24gPSBuZXcgVHJpYW5nbGUoKTtcbiAgICB0aGlzLl9wcmV2aW91c0J1dHRvbiA9IG5ldyBUcmlhbmdsZSgpO1xuICAgIHRoaXMubGFiZWxOb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgZm9udEZhbWlseTogXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCIsXG4gICAgICB5OiAxXG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hcHBlbmQoW3RoaXMubmV4dEJ1dHRvbiwgdGhpcy5wcmV2aW91c0J1dHRvbiwgdGhpcy5sYWJlbE5vZGVdKTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwicGFnaW5hdGlvblwiLCB0aGlzLmdyb3VwKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vblBhZ2luYXRpb25DbGljayhldmVudCkpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uUGFnaW5hdGlvbk1vdXNlTW92ZShldmVudCkpXG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlTWFya2VycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gIH1cbiAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9XG4gIHVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmVuYWJsZWQgJiYgdGhpcy52aXNpYmxlO1xuICB9XG4gIHNldCBvcmllbnRhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX29yaWVudGF0aW9uID0gdmFsdWU7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImhvcml6b250YWxcIjoge1xuICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnJvdGF0aW9uID0gLU1hdGguUEkgLyAyO1xuICAgICAgICB0aGlzLm5leHRCdXR0b24ucm90YXRpb24gPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbi5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubmV4dEJ1dHRvbi5yb3RhdGlvbiA9IE1hdGguUEk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb247XG4gIH1cbiAgc2V0IG5leHRCdXR0b24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbmV4dEJ1dHRvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQ2hpbGQodGhpcy5fbmV4dEJ1dHRvbik7XG4gICAgICB0aGlzLl9uZXh0QnV0dG9uID0gdmFsdWU7XG4gICAgICB0aGlzLmdyb3VwLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG5leHRCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRCdXR0b247XG4gIH1cbiAgc2V0IHByZXZpb3VzQnV0dG9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzQnV0dG9uICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVDaGlsZCh0aGlzLl9wcmV2aW91c0J1dHRvbik7XG4gICAgICB0aGlzLl9wcmV2aW91c0J1dHRvbiA9IHZhbHVlO1xuICAgICAgdGhpcy5ncm91cC5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGdldCBwcmV2aW91c0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNCdXR0b247XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucygpO1xuICAgIHRoaXMuZW5hYmxlT3JEaXNhYmxlQnV0dG9ucygpO1xuICB9XG4gIHVwZGF0ZVBvc2l0aW9ucygpIHtcbiAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25YO1xuICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy50cmFuc2xhdGlvblk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFBvc2l0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVOZXh0QnV0dG9uUG9zaXRpb24oKTtcbiAgfVxuICB1cGRhdGVMYWJlbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgc2l6ZTogbWFya2VyU2l6ZSwgcGFkZGluZzogbWFya2VyUGFkZGluZyB9ID0gdGhpcy5tYXJrZXI7XG4gICAgdGhpcy5uZXh0QnV0dG9uLnNpemUgPSBtYXJrZXJTaXplO1xuICAgIHRoaXMucHJldmlvdXNCdXR0b24uc2l6ZSA9IG1hcmtlclNpemU7XG4gICAgdGhpcy5sYWJlbE5vZGUueCA9IG1hcmtlclNpemUgLyAyICsgbWFya2VyUGFkZGluZztcbiAgfVxuICB1cGRhdGVOZXh0QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgY29uc3QgbGFiZWxCQm94ID0gdGhpcy5sYWJlbE5vZGUuZ2V0QkJveCgpO1xuICAgIHRoaXMubmV4dEJ1dHRvbi50cmFuc2xhdGlvblggPSBsYWJlbEJCb3gueCArIGxhYmVsQkJveC53aWR0aCArIHRoaXMubWFya2VyLnNpemUgLyAyICsgdGhpcy5tYXJrZXIucGFkZGluZztcbiAgfVxuICB1cGRhdGVMYWJlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50UGFnZSxcbiAgICAgIHRvdGFsUGFnZXM6IHBhZ2VzLFxuICAgICAgbGFiZWxOb2RlLFxuICAgICAgbGFiZWw6IHsgY29sb3IsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxhYmVsTm9kZS50ZXh0ID0gYCR7Y3VycmVudFBhZ2UgKyAxfSAvICR7cGFnZXN9YDtcbiAgICBsYWJlbE5vZGUuZmlsbCA9IGNvbG9yO1xuICAgIGxhYmVsTm9kZS5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgbGFiZWxOb2RlLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgIGxhYmVsTm9kZS5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgIGxhYmVsTm9kZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgfVxuICB1cGRhdGVNYXJrZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5leHRCdXR0b24sXG4gICAgICBwcmV2aW91c0J1dHRvbixcbiAgICAgIG5leHRCdXR0b25EaXNhYmxlZCxcbiAgICAgIHByZXZpb3VzQnV0dG9uRGlzYWJsZWQsXG4gICAgICBhY3RpdmVTdHlsZSxcbiAgICAgIGluYWN0aXZlU3R5bGUsXG4gICAgICBoaWdobGlnaHRTdHlsZSxcbiAgICAgIGhpZ2hsaWdodEFjdGl2ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1dHRvblN0eWxlID0gKGJ1dHRvbiwgZGlzYWJsZWQpID0+IHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gaW5hY3RpdmVTdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uID09PSBoaWdobGlnaHRBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGl2ZVN0eWxlO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVNYXJrZXIobmV4dEJ1dHRvbiwgYnV0dG9uU3R5bGUoXCJuZXh0XCIsIG5leHRCdXR0b25EaXNhYmxlZCkpO1xuICAgIHRoaXMudXBkYXRlTWFya2VyKHByZXZpb3VzQnV0dG9uLCBidXR0b25TdHlsZShcInByZXZpb3VzXCIsIHByZXZpb3VzQnV0dG9uRGlzYWJsZWQpKTtcbiAgfVxuICB1cGRhdGVNYXJrZXIobWFya2VyLCBzdHlsZSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpcy5tYXJrZXI7XG4gICAgbWFya2VyLnNpemUgPSBzaXplO1xuICAgIG1hcmtlci5maWxsID0gc3R5bGUuZmlsbDtcbiAgICBtYXJrZXIuZmlsbE9wYWNpdHkgPSBzdHlsZS5maWxsT3BhY2l0eSA/PyAxO1xuICAgIG1hcmtlci5zdHJva2UgPSBzdHlsZS5zdHJva2U7XG4gICAgbWFya2VyLnN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGg7XG4gICAgbWFya2VyLnN0cm9rZU9wYWNpdHkgPSBzdHlsZS5zdHJva2VPcGFjaXR5O1xuICB9XG4gIGVuYWJsZU9yRGlzYWJsZUJ1dHRvbnMoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50UGFnZSwgdG90YWxQYWdlcyB9ID0gdGhpcztcbiAgICBjb25zdCB6ZXJvUGFnZXNUb0Rpc3BsYXkgPSB0b3RhbFBhZ2VzID09PSAwO1xuICAgIGNvbnN0IG9uTGFzdFBhZ2UgPSBjdXJyZW50UGFnZSA9PT0gdG90YWxQYWdlcyAtIDE7XG4gICAgY29uc3Qgb25GaXJzdFBhZ2UgPSBjdXJyZW50UGFnZSA9PT0gMDtcbiAgICB0aGlzLm5leHRCdXR0b25EaXNhYmxlZCA9IG9uTGFzdFBhZ2UgfHwgemVyb1BhZ2VzVG9EaXNwbGF5O1xuICAgIHRoaXMucHJldmlvdXNCdXR0b25EaXNhYmxlZCA9IG9uRmlyc3RQYWdlIHx8IHplcm9QYWdlc1RvRGlzcGxheTtcbiAgfVxuICBuZXh0QnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgcmV0dXJuICF0aGlzLm5leHRCdXR0b25EaXNhYmxlZCAmJiB0aGlzLm5leHRCdXR0b24uY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgfVxuICBwcmV2aW91c0J1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHJldHVybiAhdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkICYmIHRoaXMucHJldmlvdXNCdXR0b24uY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgfVxuICBjbGlja05leHQoKSB7XG4gICAgdGhpcy5pbmNyZW1lbnRQYWdlKCk7XG4gICAgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkKCk7XG4gIH1cbiAgY2xpY2tQcmV2aW91cygpIHtcbiAgICB0aGlzLmRlY3JlbWVudFBhZ2UoKTtcbiAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgfVxuICBzZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBwYWdlTnVtYmVyID0gY2xhbXAoMCwgcGFnZU51bWJlciwgdGhpcy50b3RhbFBhZ2VzIC0gMSk7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgIT09IHBhZ2VOdW1iZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlTnVtYmVyO1xuICAgICAgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIG9uUGFnaW5hdGlvbkNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLm5leHRCdXR0b25Db250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmNsaWNrTmV4dCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91c0J1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY2xpY2tQcmV2aW91cygpO1xuICAgIH1cbiAgfVxuICBvblBhZ2luYXRpb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGlmICh0aGlzLm5leHRCdXR0b25Db250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsIFwicG9pbnRlclwiKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gXCJuZXh0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzQnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkLCBcInBvaW50ZXJcIik7XG4gICAgICB0aGlzLmhpZ2hsaWdodEFjdGl2ZSA9IFwicHJldmlvdXNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2soNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIG9uUGFnaW5hdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy5wYWdlVXBkYXRlQ2FsbGJhY2sodGhpcy5jdXJyZW50UGFnZSk7XG4gIH1cbiAgaW5jcmVtZW50UGFnZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gTWF0aC5taW4odGhpcy5jdXJyZW50UGFnZSArIDEsIHRoaXMudG90YWxQYWdlcyAtIDEpO1xuICB9XG4gIGRlY3JlbWVudFBhZ2UoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IE1hdGgubWF4KHRoaXMuY3VycmVudFBhZ2UgLSAxLCAwKTtcbiAgfVxuICBvbk1hcmtlclNoYXBlQ2hhbmdlKCkge1xuICAgIGNvbnN0IE1hcmtlcjIgPSBnZXRNYXJrZXIodGhpcy5tYXJrZXIuc2hhcGUgfHwgVHJpYW5nbGUpO1xuICAgIHRoaXMucHJldmlvdXNCdXR0b24gPSBuZXcgTWFya2VyMigpO1xuICAgIHRoaXMubmV4dEJ1dHRvbiA9IG5ldyBNYXJrZXIyKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMoKTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2soNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIGF0dGFjaFBhZ2luYXRpb24obm9kZSkge1xuICAgIG5vZGUuYXBwZW5kKHRoaXMuZ3JvdXApO1xuICB9XG4gIGdldEJCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAuZ2V0QkJveCh0cnVlKTtcbiAgfVxuICBjb21wdXRlQ1NTQm91bmRzKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLl9wcmV2aW91c0J1dHRvbi5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuX25leHRCdXR0b24uY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgIHJldHVybiB7IHByZXYsIG5leHQgfTtcbiAgfVxufTtcblBhZ2luYXRpb24uY2xhc3NOYW1lID0gXCJQYWdpbmF0aW9uXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJhY3RpdmVTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImluYWN0aXZlU3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJoaWdobGlnaHRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmQudHNcbnZhciBMZWdlbmRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWF4TGVuZ3RoID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gICAgdGhpcy5mb250U3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcIm1heExlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIDIpO1xudmFyIExlZ2VuZE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2l6ZSA9IDE1O1xuICAgIHRoaXMucGFkZGluZyA9IDg7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQucGFyZW50Py5vbk1hcmtlclNoYXBlQ2hhbmdlKCkpXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBMZWdlbmRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xudmFyIExlZ2VuZEl0ZW0gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhZGRpbmdYID0gMTY7XG4gICAgdGhpcy5wYWRkaW5nWSA9IDg7XG4gICAgdGhpcy5zaG93U2VyaWVzU3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgTGVnZW5kTWFya2VyKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMZWdlbmRMYWJlbCgpO1xuICAgIHRoaXMubGluZSA9IG5ldyBMZWdlbmRMaW5lKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwicGFkZGluZ1hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJwYWRkaW5nWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJzaG93U2VyaWVzU3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJsaW5lXCIsIDIpO1xudmFyIExlZ2VuZExpc3RlbmVycyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaXN0ZW5lcnMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1DbGlja1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaXN0ZW5lcnMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1Eb3VibGVDbGlja1wiLCAyKTtcbnZhciBJRF9MRUdFTkRfVklTSUJJTElUWSA9IFwibGVnZW5kLXZpc2liaWxpdHlcIjtcbnZhciBJRF9MRUdFTkRfT1RIRVJfU0VSSUVTID0gXCJsZWdlbmQtb3RoZXItc2VyaWVzXCI7XG52YXIgTGVnZW5kID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcImxlZ2VuZFwiLCBsYXllcjogdHJ1ZSwgekluZGV4OiAxMyAvKiBMRUdFTkRfWklOREVYICovIH0pO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmdyb3VwLFxuICAgICAgTGVnZW5kTWFya2VyTGFiZWxcbiAgICApO1xuICAgIHRoaXMuc3ByaXRlUmVuZGVyZXIgPSBuZXcgU3ByaXRlUmVuZGVyZXIoKTtcbiAgICB0aGlzLm9sZFNpemUgPSBbMCwgMF07XG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIHRoaXMubWF4UGFnZVNpemUgPSBbMCwgMF07XG4gICAgLyoqIEl0ZW0gaW5kZXggdG8gdHJhY2sgb24gcmUtcGFnaW5hdGlvbiwgc28gY3VycmVudCBwYWdlIHVwZGF0ZXMgYXBwcm9wcmlhdGVseS4gKi9cbiAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gMDtcbiAgICB0aGlzLnRydW5jYXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9kYXRhID0gW107XG4gICAgdGhpcy50b2dnbGVTZXJpZXMgPSB0cnVlO1xuICAgIHRoaXMuaXRlbSA9IG5ldyBMZWdlbmRJdGVtKCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGVnZW5kTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgICB0aGlzLnNwYWNpbmcgPSAyMDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnNpemUgPSBbMCwgMF07XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5pdGVtLm1hcmtlci5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMucGFnaW5hdGlvbiA9IG5ldyBQYWdpbmF0aW9uKFxuICAgICAgKHR5cGUpID0+IGN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSh0eXBlKSxcbiAgICAgIChwYWdlKSA9PiB0aGlzLnVwZGF0ZVBhZ2VOdW1iZXIocGFnZSksXG4gICAgICBjdHgucmVnaW9uTWFuYWdlcixcbiAgICAgIGN0eC5jdXJzb3JNYW5hZ2VyXG4gICAgKTtcbiAgICB0aGlzLnBhZ2luYXRpb24uYXR0YWNoUGFnaW5hdGlvbih0aGlzLmdyb3VwKTtcbiAgICBjdHguY29udGV4dE1lbnVSZWdpc3RyeS5yZWdpc3RlckRlZmF1bHRBY3Rpb24oe1xuICAgICAgaWQ6IElEX0xFR0VORF9WSVNJQklMSVRZLFxuICAgICAgdHlwZTogXCJsZWdlbmRcIixcbiAgICAgIGxhYmVsOiBcImNvbnRleHRNZW51VG9nZ2xlU2VyaWVzVmlzaWJpbGl0eVwiLFxuICAgICAgYWN0aW9uOiAocGFyYW1zKSA9PiB0aGlzLmNvbnRleHRUb2dnbGVWaXNpYmlsaXR5KHBhcmFtcylcbiAgICB9KTtcbiAgICBjdHguY29udGV4dE1lbnVSZWdpc3RyeS5yZWdpc3RlckRlZmF1bHRBY3Rpb24oe1xuICAgICAgaWQ6IElEX0xFR0VORF9PVEhFUl9TRVJJRVMsXG4gICAgICB0eXBlOiBcImxlZ2VuZFwiLFxuICAgICAgbGFiZWw6IFwiY29udGV4dE1lbnVUb2dnbGVPdGhlclNlcmllc1wiLFxuICAgICAgYWN0aW9uOiAocGFyYW1zKSA9PiB0aGlzLmNvbnRleHRUb2dnbGVPdGhlclNlcmllcyhwYXJhbXMpXG4gICAgfSk7XG4gICAgY29uc3QgeyBEZWZhdWx0OiBEZWZhdWx0MiwgQW5pbWF0aW9uOiBBbmltYXRpb24yLCBDb250ZXh0TWVudSB9ID0gSW50ZXJhY3Rpb25TdGF0ZTtcbiAgICBjb25zdCBhbmltYXRpb25TdGF0ZSA9IERlZmF1bHQyIHwgQW5pbWF0aW9uMjtcbiAgICBjb25zdCBjb250ZXh0TWVudVN0YXRlID0gRGVmYXVsdDIgfCBBbmltYXRpb24yIHwgQ29udGV4dE1lbnU7XG4gICAgY29uc3QgcmVnaW9uID0gY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwibGVnZW5kXCIsIHRoaXMuZ3JvdXApO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHRoaXMuY2hlY2tDb250ZXh0Q2xpY2soZSksIGNvbnRleHRNZW51U3RhdGUpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMuY2hlY2tMZWdlbmRDbGljayhlKSwgYW5pbWF0aW9uU3RhdGUpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKGUpID0+IHRoaXMuY2hlY2tMZWdlbmREb3VibGVDbGljayhlKSwgYW5pbWF0aW9uU3RhdGUpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGUpID0+IHRoaXMuaGFuZGxlTGVnZW5kTW91c2VNb3ZlKGUpLCBhbmltYXRpb25TdGF0ZSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlRXhpdCgpLCBhbmltYXRpb25TdGF0ZSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJlbnRlclwiLCAoZSkgPT4gdGhpcy5oYW5kbGVMZWdlbmRNb3VzZUVudGVyKGUpLCBhbmltYXRpb25TdGF0ZSksXG4gICAgICBjdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcInN0YXJ0LWxheW91dFwiLCAoZSkgPT4gdGhpcy5wb3NpdGlvbkxlZ2VuZChlKSksXG4gICAgICBjdHgubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsICgpID0+IHRoaXMub25Mb2NhbGVDaGFuZ2VkKCkpLFxuICAgICAgKCkgPT4gdGhpcy5ncm91cC5wYXJlbnQ/LnJlbW92ZUNoaWxkKHRoaXMuZ3JvdXApXG4gICAgKTtcbiAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhciA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5Q29udGFpbmVyKHtcbiAgICAgIHR5cGU6IFwidG9vbGJhclwiLFxuICAgICAgaWQ6IGAke3RoaXMuaWR9LXRvb2xiYXJgLFxuICAgICAgY2xhc3NMaXN0OiBbXCJhZy1jaGFydHMtcHJveHktbGVnZW5kLXRvb2xiYXJcIl0sXG4gICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kXCIgfSxcbiAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICBhcmlhSGlkZGVuOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24gPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUNvbnRhaW5lcih7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBpZDogYCR7dGhpcy5pZH0tcGFnaW5hdGlvbmAsXG4gICAgICBjbGFzc0xpc3Q6IFtcImFnLWNoYXJ0cy1wcm94eS1sZWdlbmQtcGFnaW5hdGlvblwiXSxcbiAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRQYWdpbmF0aW9uXCIgfSxcbiAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICBhcmlhSGlkZGVuOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0IGRhdGEodmFsdWUpIHtcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBgJHt0aGlzLmlkfS10b29sYmFyYCk7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGAke3RoaXMuaWR9LXBhZ2luYXRpb25gKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgICB0aGlzLnBhZ2luYXRpb24uZGVzdHJveSgpO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5jbGVhcigpO1xuICB9XG4gIGluaXRMZWdlbmRJdGVtVG9vbGJhcigpIHtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIGkpID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLnByb3h5QnV0dG9uID8/IChtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIGlkOiBgYWctY2hhcnRzLWxlZ2VuZC1pdGVtLSR7aX1gLFxuICAgICAgICB0ZXh0Q29udGVudDogdGhpcy5nZXRJdGVtQXJpYVRleHQoaSksXG4gICAgICAgIHBhcmVudDogdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIsXG4gICAgICAgIGZvY3VzYWJsZTogbWFya2VyTGFiZWwsXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBkYXR1bSBmcm9tIHRoZSBub2RlIHJhdGhlciB0aGFuIGZyb20gdGhlIG1ldGhvZCBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIFRoZSBtZXRob2QgcGFyYW1ldGVyIGBkYXR1bWAgZ2V0cyBkZXN0cm95ZWQgd2hlbiB0aGUgZGF0YSBpcyByZWZyZXNoZWRcbiAgICAgICAgLy8gdXNpbmcgU2VyaWVzLmdldExlZ2VuZERhdGEoKS4gQnV0IHRoZSBzY2VuZSBub2RlIHdpbGwgc3RheSB0aGUgc2FtZS5cbiAgICAgICAgb25jbGljazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZG9DbGljayhtYXJrZXJMYWJlbC5kYXR1bSk7XG4gICAgICAgICAgbWFya2VyTGFiZWwucHJveHlCdXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmdldEl0ZW1BcmlhVGV4dChpLCAhbWFya2VyTGFiZWwuZGF0dW0uZW5hYmxlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uYmx1cjogKCkgPT4gdGhpcy5oYW5kbGVMZWdlbmRNb3VzZUV4aXQoKSxcbiAgICAgICAgb25mb2N1czogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IG1hcmtlckxhYmVsPy5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBtYWtlS2V5Ym9hcmRQb2ludGVyRXZlbnQodGhpcy5jdHguZm9jdXNJbmRpY2F0b3IsIHsgYm91bmRzLCBzaG93Rm9jdXNCb3g6IHRydWUgfSk7XG4gICAgICAgICAgdGhpcy5kb0hvdmVyKGV2ZW50LCBtYXJrZXJMYWJlbC5kYXR1bSk7XG4gICAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnNldFBhZ2UobWFya2VyTGFiZWwucGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzLml0ZW1TZWxlY3Rpb24ubm9kZXMoKS5tYXAoKG1hcmtlckxhYmVsKSA9PiBtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbikuZmlsdGVyKChidXR0b24pID0+ICEhYnV0dG9uKTtcbiAgICBpbml0VG9vbGJhcktleU5hdih7XG4gICAgICBvcmllbnRhdGlvbjogdGhpcy5nZXRPcmllbnRhdGlvbigpLFxuICAgICAgYnV0dG9ucyxcbiAgICAgIHRvb2xiYXI6IHRoaXMucHJveHlMZWdlbmRUb29sYmFyXG4gICAgfSk7XG4gIH1cbiAgb25NYXJrZXJTaGFwZUNoYW5nZSgpIHtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uY2xlYXIoKTtcbiAgICB0aGlzLmdyb3VwLm1hcmtEaXJ0eSh0aGlzLmdyb3VwLCAyIC8qIE1JTk9SICovKTtcbiAgfVxuICBnZXRPcmllbnRhdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcmllbnRhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbjtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcbiAgICB9XG4gIH1cbiAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XG4gICAgdGhpcy5ncm91cC52aXNpYmxlID0gdGhpcy5lbmFibGVkICYmIHRoaXMudmlzaWJsZSAmJiB0aGlzLmRhdGEubGVuZ3RoID4gMDtcbiAgfVxuICBhdHRhY2hMZWdlbmQoc2NlbmUpIHtcbiAgICBzY2VuZS5hcHBlbmRDaGlsZCh0aGlzLmdyb3VwKTtcbiAgfVxuICBnZXRJdGVtTGFiZWwoZGF0dW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBmb3JtYXR0ZXIgfSA9IHRoaXMuaXRlbS5sYWJlbDtcbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwge1xuICAgICAgICBpdGVtSWQ6IGRhdHVtLml0ZW1JZCxcbiAgICAgICAgdmFsdWU6IGRhdHVtLmxhYmVsLnRleHQsXG4gICAgICAgIHNlcmllc0lkOiBkYXR1bS5zZXJpZXNJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYXR1bS5sYWJlbC50ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIGlzIGdpdmVuIHRoZSBkZXNpcmVkIHNpemUgb2YgdGhlIGxlZ2VuZCwgd2hpY2ggb25seSBzZXJ2ZXMgYXMgYSBoaW50LlxuICAgKiBUaGUgdmVydGljYWxseSBvcmllbnRlZCBsZWdlbmQgd2lsbCB0YWtlIGFzIG11Y2ggaG9yaXpvbnRhbCBzcGFjZSBhcyBuZWVkZWQsIGJ1dCB3aWxsXG4gICAqIHJlc3BlY3QgdGhlIGhlaWdodCBjb25zdHJhaW50cywgYW5kIHRoZSBob3Jpem9udGFsIGxlZ2VuZCB3aWxsIHRha2UgYXMgbXVjaCB2ZXJ0aWNhbFxuICAgKiBzcGFjZSBhcyBuZWVkZWQgaW4gYW4gYXR0ZW1wdCBub3QgdG8gZXhjZWVkIHRoZSBnaXZlbiB3aWR0aC5cbiAgICogQWZ0ZXIgdGhlIGxheW91dCBpcyBkb25lLCB0aGUge0BsaW5rIHNpemV9IHdpbGwgY29udGFpbiB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGxlZ2VuZC5cbiAgICogSWYgdGhlIGFjdHVhbCBzaXplIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgYWN0dWFsIHNpemUsIHRoZSBsZWdlbmQgd2lsbCBmaXJlXG4gICAqIHRoZSAnbGF5b3V0Q2hhbmdlJyBldmVudCB0byBjb21tdW5pY2F0ZSB0aGF0IGFub3RoZXIgbGF5b3V0IGlzIG5lZWRlZCwgYW5kIHRoZSBhYm92ZVxuICAgKiBwcm9jZXNzIHNob3VsZCBiZSByZXBlYXRlZC5cbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHRcbiAgICovXG4gIGNhbGNMYXlvdXQod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZGRpbmdYLFxuICAgICAgcGFkZGluZ1ksXG4gICAgICBsYWJlbCxcbiAgICAgIG1heFdpZHRoLFxuICAgICAgbGFiZWw6IHsgbWF4TGVuZ3RoID0gSW5maW5pdHksIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfVxuICAgIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgZGF0YSA9IFsuLi50aGlzLmRhdGFdO1xuICAgIGlmICh0aGlzLnJldmVyc2VPcmRlcikge1xuICAgICAgZGF0YS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5VG9vbGJhck5lZWRzVXBkYXRlID0gdGhpcy5pdGVtU2VsZWN0aW9uLm5vZGVzKCkubGVuZ3RoID09PSAwO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi51cGRhdGUoZGF0YSk7XG4gICAgaWYgKHByb3h5VG9vbGJhck5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLmluaXRMZWdlbmRJdGVtVG9vbGJhcigpO1xuICAgIH1cbiAgICBjb25zdCBiYm94ZXMgPSBbXTtcbiAgICBjb25zdCBmb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZyhsYWJlbCk7XG4gICAgY29uc3QgaXRlbU1heFdpZHRoUGVyY2VudGFnZSA9IDAuODtcbiAgICBjb25zdCBtYXhJdGVtV2lkdGggPSBtYXhXaWR0aCA/PyB3aWR0aCAqIGl0ZW1NYXhXaWR0aFBlcmNlbnRhZ2U7XG4gICAgY29uc3Qgc3ByaXRlRGltcyA9IHRoaXMuY2FsY3VsYXRlU3ByaXRlRGltZW5zaW9ucygpO1xuICAgIHRoaXMuc3ByaXRlUmVuZGVyZXIucmVzaXplKHNwcml0ZURpbXMpO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgZGF0dW0pID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgbWFya2VyTGFiZWwuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgY29uc3QgcGFkZGVkU3ltYm9sV2lkdGggPSB0aGlzLnVwZGF0ZU1hcmtlckxhYmVsKG1hcmtlckxhYmVsLCBkYXR1bSwgc3ByaXRlRGltcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdHVtLml0ZW1JZCA/PyBkYXR1bS5pZDtcbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0SXRlbUxhYmVsKGRhdHVtKTtcbiAgICAgIGNvbnN0IHRleHQgPSAobGFiZWxUZXh0ID8/IFwiPHVua25vd24+XCIpLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpO1xuICAgICAgbWFya2VyTGFiZWwudGV4dCA9IHRoaXMudHJ1bmNhdGUodGV4dCwgbWF4TGVuZ3RoLCBtYXhJdGVtV2lkdGgsIHBhZGRlZFN5bWJvbFdpZHRoLCBmb250LCBpZCk7XG4gICAgICBiYm94ZXMucHVzaChtYXJrZXJMYWJlbC5nZXRCQm94KCkpO1xuICAgIH0pO1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMSwgd2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGgubWF4KDEsIGhlaWdodCk7XG4gICAgaWYgKCFpc0Zpbml0ZSh3aWR0aCkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5vbGRTaXplO1xuICAgIHNpemVbMF0gPSB3aWR0aDtcbiAgICBzaXplWzFdID0gaGVpZ2h0O1xuICAgIGlmIChzaXplWzBdICE9PSBvbGRTaXplWzBdIHx8IHNpemVbMV0gIT09IG9sZFNpemVbMV0pIHtcbiAgICAgIG9sZFNpemVbMF0gPSBzaXplWzBdO1xuICAgICAgb2xkU2l6ZVsxXSA9IHNpemVbMV07XG4gICAgfVxuICAgIGNvbnN0IHsgcGFnZXMsIG1heFBhZ2VIZWlnaHQsIG1heFBhZ2VXaWR0aCB9ID0gdGhpcy51cGRhdGVQYWdpbmF0aW9uKGJib3hlcywgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgb2xkUGFnZXMgPSB0aGlzLnBhZ2VzO1xuICAgIHRoaXMucGFnZXMgPSBwYWdlcztcbiAgICB0aGlzLm1heFBhZ2VTaXplID0gW21heFBhZ2VXaWR0aCAtIHBhZGRpbmdYLCBtYXhQYWdlSGVpZ2h0IC0gcGFkZGluZ1ldO1xuICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSB0aGlzLnBhZ2luYXRpb24uY3VycmVudFBhZ2U7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbcGFnZU51bWJlcl07XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoIDwgMSB8fCAhcGFnZSkge1xuICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm4geyBvbGRQYWdlcyB9O1xuICAgIH1cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKHBhZ2VOdW1iZXIpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcmV0dXJuIHsgb2xkUGFnZXMgfTtcbiAgfVxuICBjYWxjU3ltYm9sc0VuYWJsZWQoc3ltYm9sKSB7XG4gICAgY29uc3QgeyBzaG93U2VyaWVzU3Ryb2tlLCBtYXJrZXIgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBtYXJrZXJFbmFibGVkID0gISFtYXJrZXIuZW5hYmxlZCB8fCAhc2hvd1Nlcmllc1N0cm9rZSB8fCAoc3ltYm9sLm1hcmtlci5lbmFibGVkID8/IHRydWUpO1xuICAgIGNvbnN0IGxpbmVFbmFibGVkID0gISEoc3ltYm9sLmxpbmUgJiYgc2hvd1Nlcmllc1N0cm9rZSk7XG4gICAgcmV0dXJuIHsgbWFya2VyRW5hYmxlZCwgbGluZUVuYWJsZWQgfTtcbiAgfVxuICBjYWxjU3ltYm9sc0xlbmd0aHMoc3ltYm9sKSB7XG4gICAgY29uc3QgeyBtYXJrZXIsIGxpbmUgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCB7IG1hcmtlckVuYWJsZWQsIGxpbmVFbmFibGVkIH0gPSB0aGlzLmNhbGNTeW1ib2xzRW5hYmxlZChzeW1ib2wpO1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGg6IG1hcmtlclN0cm9rZVdpZHRoIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlcyhzeW1ib2wpO1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGg6IGxpbmVTdHJva2VXaWR0aCB9ID0gbGluZUVuYWJsZWQgPyB0aGlzLmdldExpbmVTdHlsZXMoc3ltYm9sKSA6IHsgc3Ryb2tlV2lkdGg6IDAgfTtcbiAgICBjb25zdCBtYXJrZXJMZW5ndGggPSBtYXJrZXJFbmFibGVkID8gbWFya2VyLnNpemUgOiAwO1xuICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lRW5hYmxlZCA/IGxpbmUubGVuZ3RoID8/IDI1IDogMDtcbiAgICByZXR1cm4geyBtYXJrZXJMZW5ndGgsIG1hcmtlclN0cm9rZVdpZHRoLCBsaW5lTGVuZ3RoLCBsaW5lU3Ryb2tlV2lkdGggfTtcbiAgfVxuICBjYWxjdWxhdGVTcHJpdGVEaW1lbnNpb25zKCkge1xuICAgIGxldCBzcHJpdGVBQVBhZGRpbmcgPSAwO1xuICAgIGxldCBzcHJpdGVXaWR0aCA9IDA7XG4gICAgbGV0IHNwcml0ZUhlaWdodCA9IDA7XG4gICAgbGV0IG1hcmtlcldpZHRoID0gMDtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgoXywgZGF0dW0pID0+IHtcbiAgICAgIGRhdHVtLnN5bWJvbHMuZm9yRWFjaCgoc3ltYm9sKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWFya2VyTGVuZ3RoLCBtYXJrZXJTdHJva2VXaWR0aCwgbGluZUxlbmd0aCwgbGluZVN0cm9rZVdpZHRoIH0gPSB0aGlzLmNhbGNTeW1ib2xzTGVuZ3RocyhzeW1ib2wpO1xuICAgICAgICBjb25zdCBtYXJrZXJUb3RhbExlbmd0aCA9IG1hcmtlckxlbmd0aCArIG1hcmtlclN0cm9rZVdpZHRoO1xuICAgICAgICBtYXJrZXJXaWR0aCA9IE1hdGgubWF4KG1hcmtlcldpZHRoLCBsaW5lTGVuZ3RoLCBtYXJrZXJMZW5ndGgpO1xuICAgICAgICBzcHJpdGVXaWR0aCA9IE1hdGgubWF4KHNwcml0ZVdpZHRoLCBsaW5lTGVuZ3RoLCBtYXJrZXJUb3RhbExlbmd0aCk7XG4gICAgICAgIHNwcml0ZUhlaWdodCA9IE1hdGgubWF4KHNwcml0ZUhlaWdodCwgbGluZVN0cm9rZVdpZHRoLCBtYXJrZXJUb3RhbExlbmd0aCk7XG4gICAgICAgIHNwcml0ZUFBUGFkZGluZyA9IE1hdGgubWF4KHNwcml0ZUFBUGFkZGluZywgbWFya2VyU3Ryb2tlV2lkdGggKyAwLjUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3ByaXRlV2lkdGggKz0gc3ByaXRlQUFQYWRkaW5nICogMjtcbiAgICBzcHJpdGVIZWlnaHQgKz0gc3ByaXRlQUFQYWRkaW5nICogMjtcbiAgICBjb25zdCBzcHJpdGVQaXhlbFJhdGlvID0gZ2V0V2luZG93KCkuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICByZXR1cm4geyBzcHJpdGVQaXhlbFJhdGlvLCBzcHJpdGVBQVBhZGRpbmcsIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQsIG1hcmtlcldpZHRoIH07XG4gIH1cbiAgdXBkYXRlTWFya2VyTGFiZWwobWFya2VyTGFiZWwsIGRhdHVtLCBzcHJpdGVEaW1zKSB7XG4gICAgY29uc3QgeyBtYXJrZXI6IGl0ZW1NYXJrZXIsIHBhZGRpbmdYIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgeyBtYXJrZXJXaWR0aCB9ID0gc3ByaXRlRGltcztcbiAgICBjb25zdCBkaW1lbnNpb25Qcm9wcyA9IFtdO1xuICAgIGxldCBwYWRkZWRTeW1ib2xXaWR0aCA9IHBhZGRpbmdYO1xuICAgIGlmIChtYXJrZXJMYWJlbC5tYXJrZXJzLmxlbmd0aCAhPT0gZGF0dW0uc3ltYm9scy5sZW5ndGggJiYgbWFya2VyTGFiZWwubGluZXMubGVuZ3RoICE9PSBkYXR1bS5zeW1ib2xzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuICAgICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICAgIGRhdHVtLnN5bWJvbHMuZm9yRWFjaCgoc3ltYm9sKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2hhcGU6IG1hcmtlclNoYXBlID0gc3ltYm9sLm1hcmtlci5zaGFwZSB9ID0gaXRlbU1hcmtlcjtcbiAgICAgICAgY29uc3QgTWFya2VyQ3RyID0gZ2V0TWFya2VyKG1hcmtlclNoYXBlKTtcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZSgpKTtcbiAgICAgICAgbWFya2Vycy5wdXNoKG5ldyBNYXJrZXJDdHIoKSk7XG4gICAgICB9KTtcbiAgICAgIG1hcmtlckxhYmVsLnVwZGF0ZVN5bWJvbHMobWFya2VycywgbGluZXMpO1xuICAgIH1cbiAgICBkYXR1bS5zeW1ib2xzLmZvckVhY2goKHN5bWJvbCwgaSkgPT4ge1xuICAgICAgY29uc3Qgc3BhY2luZyA9IHN5bWJvbC5tYXJrZXIucGFkZGluZyA/PyBpdGVtTWFya2VyLnBhZGRpbmc7XG4gICAgICBjb25zdCB7IG1hcmtlckVuYWJsZWQsIGxpbmVFbmFibGVkIH0gPSB0aGlzLmNhbGNTeW1ib2xzRW5hYmxlZChzeW1ib2wpO1xuICAgICAgbWFya2VyTGFiZWwubWFya2Vyc1tpXS5zaXplID0gbWFya2VyRW5hYmxlZCB8fCAhbGluZUVuYWJsZWQgPyBpdGVtTWFya2VyLnNpemUgOiAwO1xuICAgICAgZGltZW5zaW9uUHJvcHMucHVzaCh7IGxlbmd0aDogbWFya2VyV2lkdGgsIHNwYWNpbmcgfSk7XG4gICAgICBpZiAobWFya2VyRW5hYmxlZCB8fCBsaW5lRW5hYmxlZCkge1xuICAgICAgICBwYWRkZWRTeW1ib2xXaWR0aCArPSBzcGFjaW5nICsgbWFya2VyV2lkdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJMYWJlbC5tYXJrZXJzW2ldO1xuICAgICAgY29uc3QgbGluZSA9IG1hcmtlckxhYmVsLmxpbmVzW2ldO1xuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICBjb25zdCB7IHN0cm9rZVdpZHRoLCBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5IH0gPSB0aGlzLmdldE1hcmtlclN0eWxlcyhzeW1ib2wpO1xuICAgICAgICBtYXJrZXIuZmlsbCA9IGZpbGw7XG4gICAgICAgIG1hcmtlci5zdHJva2UgPSBzdHJva2U7XG4gICAgICAgIG1hcmtlci5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgICBtYXJrZXIuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eTtcbiAgICAgICAgbWFya2VyLnN0cm9rZU9wYWNpdHkgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgY29uc3QgbGluZVN0eWxlcyA9IHRoaXMuZ2V0TGluZVN0eWxlcyhzeW1ib2wpO1xuICAgICAgICBsaW5lLnN0cm9rZSA9IGxpbmVTdHlsZXMuc3Ryb2tlO1xuICAgICAgICBsaW5lLnN0cm9rZU9wYWNpdHkgPSBsaW5lU3R5bGVzLnN0cm9rZU9wYWNpdHk7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSBsaW5lU3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgICAgICBsaW5lLmxpbmVEYXNoID0gbGluZVN0eWxlcy5saW5lRGFzaDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtYXJrZXJMYWJlbC51cGRhdGUodGhpcy5zcHJpdGVSZW5kZXJlciwgc3ByaXRlRGltcywgZGltZW5zaW9uUHJvcHMpO1xuICAgIHJldHVybiBwYWRkZWRTeW1ib2xXaWR0aDtcbiAgfVxuICB0cnVuY2F0ZSh0ZXh0LCBtYXhDaGFyTGVuZ3RoLCBtYXhJdGVtV2lkdGgsIHBhZGRlZE1hcmtlcldpZHRoLCBmb250LCBpZCkge1xuICAgIGxldCBhZGRFbGxpcHNpcyA9IGZhbHNlO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IG1heENoYXJMZW5ndGgpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXhDaGFyTGVuZ3RoKTtcbiAgICAgIGFkZEVsbGlwc2lzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBUZXh0V3JhcHBlci50cnVuY2F0ZUxpbmUodGV4dCwgbWVhc3VyZXIsIG1heEl0ZW1XaWR0aCAtIHBhZGRlZE1hcmtlcldpZHRoLCBhZGRFbGxpcHNpcyk7XG4gICAgaWYgKHJlc3VsdC5lbmRzV2l0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKSkge1xuICAgICAgdGhpcy50cnVuY2F0ZWRJdGVtcy5hZGQoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRydW5jYXRlZEl0ZW1zLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdXBkYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcbiAgICBjb25zdCB0cmFja2luZ0luZGV4ID0gTWF0aC5taW4odGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCwgYmJveGVzLmxlbmd0aCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgY29uc3QgeyBwYWdlcywgbWF4UGFnZUhlaWdodCwgbWF4UGFnZVdpZHRoLCBwYWdpbmF0aW9uQkJveCwgcGFnaW5hdGlvblZlcnRpY2FsIH0gPSB0aGlzLmNhbGN1bGF0ZVBhZ2luYXRpb24oXG4gICAgICBiYm94ZXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgICk7XG4gICAgY29uc3QgbmV3Q3VycmVudFBhZ2UgPSBwYWdlcy5maW5kSW5kZXgoKHApID0+IHAuZW5kSW5kZXggPj0gdHJhY2tpbmdJbmRleCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRQYWdlID0gY2xhbXAoMCwgbmV3Q3VycmVudFBhZ2UsIHBhZ2VzLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IHsgcGFkZGluZ1g6IGl0ZW1QYWRkaW5nWCwgcGFkZGluZ1k6IGl0ZW1QYWRkaW5nWSB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IHBhZ2luYXRpb25Db21wb25lbnRQYWRkaW5nID0gODtcbiAgICBjb25zdCBsZWdlbmRJdGVtc1dpZHRoID0gbWF4UGFnZVdpZHRoIC0gaXRlbVBhZGRpbmdYO1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1zSGVpZ2h0ID0gbWF4UGFnZUhlaWdodCAtIGl0ZW1QYWRkaW5nWTtcbiAgICBsZXQgcGFnaW5hdGlvblggPSAwO1xuICAgIGxldCBwYWdpbmF0aW9uWSA9IC1wYWdpbmF0aW9uQkJveC55IC0gdGhpcy5pdGVtLm1hcmtlci5zaXplIC8gMjtcbiAgICBpZiAocGFnaW5hdGlvblZlcnRpY2FsKSB7XG4gICAgICBwYWdpbmF0aW9uWSArPSBsZWdlbmRJdGVtc0hlaWdodCArIHBhZ2luYXRpb25Db21wb25lbnRQYWRkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdpbmF0aW9uWCArPSAtcGFnaW5hdGlvbkJCb3gueCArIGxlZ2VuZEl0ZW1zV2lkdGggKyBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZztcbiAgICAgIHBhZ2luYXRpb25ZICs9IChsZWdlbmRJdGVtc0hlaWdodCAtIHBhZ2luYXRpb25CQm94LmhlaWdodCkgLyAyO1xuICAgIH1cbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25YID0gcGFnaW5hdGlvblg7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWSA9IHBhZ2luYXRpb25ZO1xuICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlTWFya2VycygpO1xuICAgIGxldCBwYWdlSW5kZXggPSAwO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgXywgbm9kZUluZGV4KSA9PiB7XG4gICAgICBpZiAobm9kZUluZGV4ID4gKHBhZ2VzW3BhZ2VJbmRleF0/LmVuZEluZGV4ID8/IEluZmluaXR5KSkge1xuICAgICAgICBwYWdlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIG1hcmtlckxhYmVsLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF4UGFnZUhlaWdodCxcbiAgICAgIG1heFBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VzXG4gICAgfTtcbiAgfVxuICB1cGRhdGVJdGVtUHJveHlCdXR0b25zKCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCkgPT4ge1xuICAgICAgY29uc3QgYmJveCA9IG1hcmtlckxhYmVsLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKT8uY2xvbmUoKTtcbiAgICAgIGJib3gudHJhbnNsYXRlKHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YLCB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSk7XG4gICAgICBzZXRFbGVtZW50QkJveChtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbiwgYmJveCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFnaW5hdGlvblByb3h5QnV0dG9ucyhvbGRQYWdlcykge1xuICAgIHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uLnN0eWxlLmRpc3BsYXkgPSB0aGlzLnBhZ2luYXRpb24udmlzaWJsZSA/IFwiYWJzb2x1dGVcIiA6IFwibm9uZVwiO1xuICAgIGNvbnN0IG9sZE5lZWRzQnV0dG9ucyA9IChvbGRQYWdlcz8ubGVuZ3RoID8/IHRoaXMucGFnZXMubGVuZ3RoKSA+IDE7XG4gICAgY29uc3QgbmV3TmVlZHNCdXR0b25zID0gdGhpcy5wYWdlcy5sZW5ndGggPiAxO1xuICAgIGlmIChvbGROZWVkc0J1dHRvbnMgIT09IG5ld05lZWRzQnV0dG9ucykge1xuICAgICAgaWYgKG5ld05lZWRzQnV0dG9ucykge1xuICAgICAgICB0aGlzLnByb3h5UHJldkJ1dHRvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBpZDogYCR7dGhpcy5pZH0tcHJldi1wYWdlYCxcbiAgICAgICAgICB0ZXh0Q29udGVudDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRQYWdlUHJldmlvdXNcIiB9LFxuICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgIHBhcmVudDogdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24sXG4gICAgICAgICAgZm9jdXNhYmxlOiB0aGlzLnBhZ2luYXRpb24ucHJldmlvdXNCdXR0b24sXG4gICAgICAgICAgb25jbGljazogKCkgPT4gdGhpcy5wYWdpbmF0aW9uLmNsaWNrUHJldmlvdXMoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm94eU5leHRCdXR0b24gPz8gKHRoaXMucHJveHlOZXh0QnV0dG9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1uZXh0LXBhZ2VgLFxuICAgICAgICAgIHRleHRDb250ZW50OiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2VOZXh0XCIgfSxcbiAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uLFxuICAgICAgICAgIGZvY3VzYWJsZTogdGhpcy5wYWdpbmF0aW9uLm5leHRCdXR0b24sXG4gICAgICAgICAgb25jbGljazogKCkgPT4gdGhpcy5wYWdpbmF0aW9uLmNsaWNrTmV4dCgpXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJveHlOZXh0QnV0dG9uPy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5wcm94eVByZXZCdXR0b24/LnJlbW92ZSgpO1xuICAgICAgICBbdGhpcy5wcm94eU5leHRCdXR0b24sIHRoaXMucHJveHlQcmV2QnV0dG9uXSA9IFt2b2lkIDAsIHZvaWQgMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgcHJldiwgbmV4dCB9ID0gdGhpcy5wYWdpbmF0aW9uLmNvbXB1dGVDU1NCb3VuZHMoKTtcbiAgICBzZXRFbGVtZW50QkJveCh0aGlzLnByb3h5UHJldkJ1dHRvbiwgcHJldik7XG4gICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eU5leHRCdXR0b24sIG5leHQpO1xuICB9XG4gIGNhbGN1bGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeyBwYWRkaW5nWDogaXRlbVBhZGRpbmdYLCBwYWRkaW5nWTogaXRlbVBhZGRpbmdZIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmdldE9yaWVudGF0aW9uKCk7XG4gICAgY29uc3QgcGFnaW5hdGlvblZlcnRpY2FsID0gW1wibGVmdFwiLCBcInJpZ2h0XCJdLmluY2x1ZGVzKHRoaXMucG9zaXRpb24pO1xuICAgIGxldCBwYWdpbmF0aW9uQkJveCA9IHRoaXMucGFnaW5hdGlvbi5nZXRCQm94KCk7XG4gICAgbGV0IGxhc3RQYXNzUGFnaW5hdGlvbkJCb3ggPSBuZXcgQkJveCgwLCAwLCAwLCAwKTtcbiAgICBsZXQgcGFnZXMgPSBbXTtcbiAgICBsZXQgbWF4UGFnZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4UGFnZUhlaWdodCA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBzdGFibGVPdXRwdXQgPSAoYmJveCkgPT4ge1xuICAgICAgcmV0dXJuIGJib3gud2lkdGggPT09IHBhZ2luYXRpb25CQm94LndpZHRoICYmIGJib3guaGVpZ2h0ID09PSBwYWdpbmF0aW9uQkJveC5oZWlnaHQ7XG4gICAgfTtcbiAgICBjb25zdCBmb3JjZVJlc3VsdCA9IHRoaXMubWF4V2lkdGggIT09IHZvaWQgMCAmJiB0aGlzLm1heEhlaWdodCAhPT0gdm9pZCAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChjb3VudCsrID4gMTApIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXCJ1bmFibGUgdG8gZmluZCBzdGFibGUgbGVnZW5kIGxheW91dC5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFnaW5hdGlvbkJCb3ggPSBsYXN0UGFzc1BhZ2luYXRpb25CQm94O1xuICAgICAgY29uc3QgbWF4V2lkdGggPSB3aWR0aCAtIChwYWdpbmF0aW9uVmVydGljYWwgPyAwIDogcGFnaW5hdGlvbkJCb3gud2lkdGgpO1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gaGVpZ2h0IC0gKHBhZ2luYXRpb25WZXJ0aWNhbCA/IHBhZ2luYXRpb25CQm94LmhlaWdodCA6IDApO1xuICAgICAgY29uc3QgbGF5b3V0ID0gZ3JpZExheW91dCh7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBiYm94ZXMsXG4gICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIGl0ZW1QYWRkaW5nWSxcbiAgICAgICAgaXRlbVBhZGRpbmdYLFxuICAgICAgICBmb3JjZVJlc3VsdFxuICAgICAgfSk7XG4gICAgICBwYWdlcyA9IGxheW91dD8ucGFnZXMgPz8gW107XG4gICAgICBtYXhQYWdlV2lkdGggPSBsYXlvdXQ/Lm1heFBhZ2VXaWR0aCA/PyAwO1xuICAgICAgbWF4UGFnZUhlaWdodCA9IGxheW91dD8ubWF4UGFnZUhlaWdodCA/PyAwO1xuICAgICAgY29uc3QgdG90YWxQYWdlcyA9IHBhZ2VzLmxlbmd0aDtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi52aXNpYmxlID0gdG90YWxQYWdlcyA+IDE7XG4gICAgICB0aGlzLnBhZ2luYXRpb24udG90YWxQYWdlcyA9IHRvdGFsUGFnZXM7XG4gICAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgICBsYXN0UGFzc1BhZ2luYXRpb25CQm94ID0gdGhpcy5wYWdpbmF0aW9uLmdldEJCb3goKTtcbiAgICAgIGlmICghdGhpcy5wYWdpbmF0aW9uLnZpc2libGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXN0YWJsZU91dHB1dChsYXN0UGFzc1BhZ2luYXRpb25CQm94KSk7XG4gICAgcmV0dXJuIHsgbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0LCBwYWdlcywgcGFnaW5hdGlvbkJCb3gsIHBhZ2luYXRpb25WZXJ0aWNhbCB9O1xuICB9XG4gIHVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyID0gMCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW06IHsgcGFkZGluZ1kgfSxcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBwYWdlc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChwYWdlcy5sZW5ndGggPCAxIHx8ICFwYWdlc1twYWdlTnVtYmVyXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbHVtbnMsIHN0YXJ0SW5kZXg6IHZpc2libGVTdGFydCwgZW5kSW5kZXg6IHZpc2libGVFbmQgfSA9IHBhZ2VzW3BhZ2VOdW1iZXJdO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgY29uc3QgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgICBjb25zdCByb3dDb3VudCA9IGNvbHVtbnNbMF0uaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKSA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNvbHVtbnNbMF0uYmJveGVzWzBdLmhlaWdodCArIHBhZGRpbmdZO1xuICAgIGNvbnN0IHJvd1N1bUNvbHVtbldpZHRocyA9IFtdO1xuICAgIGl0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIGkpID0+IHtcbiAgICAgIGlmIChpIDwgdmlzaWJsZVN0YXJ0IHx8IGkgPiB2aXNpYmxlRW5kKSB7XG4gICAgICAgIG1hcmtlckxhYmVsLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZUluZGV4ID0gaSAtIHZpc2libGVTdGFydDtcbiAgICAgIGxldCBjb2x1bW5JbmRleDtcbiAgICAgIGxldCByb3dJbmRleDtcbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbHVtbkluZGV4ID0gcGFnZUluZGV4ICUgY29sdW1uQ291bnQ7XG4gICAgICAgIHJvd0luZGV4ID0gTWF0aC5mbG9vcihwYWdlSW5kZXggLyBjb2x1bW5Db3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW5JbmRleCA9IE1hdGguZmxvb3IocGFnZUluZGV4IC8gcm93Q291bnQpO1xuICAgICAgICByb3dJbmRleCA9IHBhZ2VJbmRleCAlIHJvd0NvdW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTGFiZWwudmlzaWJsZSA9IHRydWU7XG4gICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2NvbHVtbkluZGV4XTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHkgPSBNYXRoLmZsb29yKGl0ZW1IZWlnaHQgKiByb3dJbmRleCk7XG4gICAgICB4ID0gTWF0aC5mbG9vcihyb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID8/IDApO1xuICAgICAgcm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA9IChyb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID8/IDApICsgY29sdW1uLmNvbHVtbldpZHRoO1xuICAgICAgbWFya2VyTGFiZWwudHJhbnNsYXRpb25YID0geDtcbiAgICAgIG1hcmtlckxhYmVsLnRyYW5zbGF0aW9uWSA9IHk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFnZU51bWJlcihwYWdlTnVtYmVyKSB7XG4gICAgY29uc3QgeyBwYWdlcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSBwYWdlc1twYWdlTnVtYmVyXTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChwYWdlTnVtYmVyID09PSBwYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gZW5kSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSBNYXRoLmZsb29yKChzdGFydEluZGV4ICsgZW5kSW5kZXgpIC8gMik7XG4gICAgfVxuICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlTWFya2VycygpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKHBhZ2VOdW1iZXIpO1xuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWw6IHsgY29sb3IgfVxuICAgIH0gPSB0aGlzLml0ZW07XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBkYXR1bSkgPT4ge1xuICAgICAgbWFya2VyTGFiZWwuc2V0RW5hYmxlZChkYXR1bS5lbmFibGVkKTtcbiAgICAgIG1hcmtlckxhYmVsLmNvbG9yID0gY29sb3I7XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0TWVudSgpO1xuICB9XG4gIHVwZGF0ZUNvbnRleHRNZW51KCkge1xuICAgIGNvbnN0IHsgdG9nZ2xlU2VyaWVzIH0gPSB0aGlzO1xuICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuc2V0QWN0aW9uVmlzaWJsaXR5KElEX0xFR0VORF9WSVNJQklMSVRZLCB0b2dnbGVTZXJpZXMpO1xuICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuc2V0QWN0aW9uVmlzaWJsaXR5KElEX0xFR0VORF9PVEhFUl9TRVJJRVMsIHRvZ2dsZVNlcmllcyk7XG4gIH1cbiAgZ2V0TGluZVN0eWxlcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgc3Ryb2tlLCBzdHJva2VPcGFjaXR5ID0gMSwgc3Ryb2tlV2lkdGgsIGxpbmVEYXNoIH0gPSBkYXR1bS5saW5lID8/IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGggPSBNYXRoLm1pbigyLCBzdHJva2VXaWR0aCA/PyAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLml0ZW0ubGluZS5zdHJva2VXaWR0aCA/PyBkZWZhdWx0TGluZVN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2hcbiAgICB9O1xuICB9XG4gIGdldE1hcmtlclN0eWxlcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5ID0gMSwgZmlsbE9wYWNpdHkgPSAxLCBzdHJva2VXaWR0aCB9ID0gZGF0dW0ubWFya2VyO1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGggPSBNYXRoLm1pbigyLCBzdHJva2VXaWR0aCA/PyAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLml0ZW0ubWFya2VyLnN0cm9rZVdpZHRoID8/IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGhcbiAgICB9O1xuICB9XG4gIGdldERhdHVtRm9yUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHZpc2libGVDaGlsZEJCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNsb3Nlc3RMZWZ0VG9wID0geyBkaXN0OiBJbmZpbml0eSwgZGF0dW06IHZvaWQgMCB9O1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5ncm91cC5jaGlsZHJlbikge1xuICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgTGVnZW5kTWFya2VyTGFiZWwpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNoaWxkQkJveCA9IGNoaWxkLmdldEJCb3goKS5jbG9uZSgpO1xuICAgICAgY2hpbGRCQm94Lmdyb3codGhpcy5pdGVtLnBhZGRpbmdYIC8gMiwgXCJob3Jpem9udGFsXCIpO1xuICAgICAgY2hpbGRCQm94Lmdyb3codGhpcy5pdGVtLnBhZGRpbmdZIC8gMiwgXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgIGlmIChjaGlsZEJCb3guY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgICByZXR1cm4gY2hpbGQuZGF0dW07XG4gICAgICB9XG4gICAgICBjb25zdCBkaXN0WCA9IHggLSBjaGlsZEJCb3gueCAtIHRoaXMuaXRlbS5wYWRkaW5nWCAvIDI7XG4gICAgICBjb25zdCBkaXN0WSA9IHkgLSBjaGlsZEJCb3gueSAtIHRoaXMuaXRlbS5wYWRkaW5nWSAvIDI7XG4gICAgICBjb25zdCBkaXN0ID0gZGlzdFggKiogMiArIGRpc3RZICoqIDI7XG4gICAgICBjb25zdCB0b1RoZUxlZnRUb3AgPSBkaXN0WCA+PSAwICYmIGRpc3RZID49IDA7XG4gICAgICBpZiAodG9UaGVMZWZ0VG9wICYmIGRpc3QgPCBjbG9zZXN0TGVmdFRvcC5kaXN0KSB7XG4gICAgICAgIGNsb3Nlc3RMZWZ0VG9wLmRpc3QgPSBkaXN0O1xuICAgICAgICBjbG9zZXN0TGVmdFRvcC5kYXR1bSA9IGNoaWxkLmRhdHVtO1xuICAgICAgfVxuICAgICAgdmlzaWJsZUNoaWxkQkJveGVzLnB1c2goY2hpbGRCQm94KTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUJCb3ggPSBCQm94Lm1lcmdlKHZpc2libGVDaGlsZEJCb3hlcyk7XG4gICAgaWYgKCFwYWdlQkJveC5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0TGVmdFRvcC5kYXR1bTtcbiAgfVxuICBjb21wdXRlUGFnZWRCQm94KCkge1xuICAgIGxldCBhY3R1YWxCQm94ID0gdGhpcy5ncm91cC5nZXRCQm94KCk7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybiBhY3R1YWxCQm94O1xuICAgIH1cbiAgICBjb25zdCBbbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0XSA9IHRoaXMubWF4UGFnZVNpemU7XG4gICAgYWN0dWFsQkJveCA9IGFjdHVhbEJCb3guY2xvbmUoKTtcbiAgICBhY3R1YWxCQm94LmhlaWdodCA9IE1hdGgubWF4KG1heFBhZ2VIZWlnaHQsIGFjdHVhbEJCb3guaGVpZ2h0KTtcbiAgICBhY3R1YWxCQm94LndpZHRoID0gTWF0aC5tYXgobWF4UGFnZVdpZHRoLCBhY3R1YWxCQm94LndpZHRoKTtcbiAgICByZXR1cm4gYWN0dWFsQkJveDtcbiAgfVxuICBjb250ZXh0VG9nZ2xlVmlzaWJpbGl0eShwYXJhbXMpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZGF0YS5maW5kKCh2KSA9PiB2Lml0ZW1JZCA9PT0gcGFyYW1zLml0ZW1JZCk7XG4gICAgdGhpcy5kb0NsaWNrKGRhdHVtKTtcbiAgfVxuICBjb250ZXh0VG9nZ2xlT3RoZXJTZXJpZXMocGFyYW1zKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmRhdGEuZmluZCgodikgPT4gdi5pdGVtSWQgPT09IHBhcmFtcy5pdGVtSWQpO1xuICAgIHRoaXMuZG9Eb3VibGVDbGljayhkYXR1bSk7XG4gIH1cbiAgY2hlY2tDb250ZXh0Q2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCBsZWdlbmRJdGVtID0gdGhpcy5nZXREYXR1bUZvclBvaW50KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIGlmICh0aGlzLnByZXZlbnRIaWRpbmdBbGwgJiYgdGhpcy5jb250ZXh0TWVudURhdHVtPy5lbmFibGVkICYmIHRoaXMuZ2V0VmlzaWJsZUl0ZW1Db3VudCgpIDw9IDEpIHtcbiAgICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzYWJsZUFjdGlvbihJRF9MRUdFTkRfVklTSUJJTElUWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZW5hYmxlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICB9XG4gICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNwYXRjaENvbnRleHQoXCJsZWdlbmRcIiwgZXZlbnQsIHsgbGVnZW5kSXRlbSB9KTtcbiAgfVxuICBjaGVja0xlZ2VuZENsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgaWYgKHRoaXMuZG9DbGljayhkYXR1bSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGdldFZpc2libGVJdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmNoYXJ0U2VydmljZS5zZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRMZWdlbmREYXRhKFwiY2F0ZWdvcnlcIikpLmZpbHRlcigoZCkgPT4gZC5lbmFibGVkKS5sZW5ndGg7XG4gIH1cbiAgZG9DbGljayhkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RlbmVyczogeyBsZWdlbmRJdGVtQ2xpY2sgfSxcbiAgICAgIGN0eDogeyBjaGFydFNlcnZpY2UsIGhpZ2hsaWdodE1hbmFnZXIgfSxcbiAgICAgIHByZXZlbnRIaWRpbmdBbGwsXG4gICAgICB0b2dnbGVTZXJpZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRhdHVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIGl0ZW1JZCwgZW5hYmxlZCB9ID0gZGF0dW07XG4gICAgY29uc3Qgc2VyaWVzID0gY2hhcnRTZXJ2aWNlLnNlcmllcy5maW5kKChzKSA9PiBzLmlkID09PSBpZCk7XG4gICAgaWYgKCFzZXJpZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5ld0VuYWJsZWQgPSBlbmFibGVkO1xuICAgIGlmICh0b2dnbGVTZXJpZXMpIHtcbiAgICAgIG5ld0VuYWJsZWQgPSAhZW5hYmxlZDtcbiAgICAgIGlmIChwcmV2ZW50SGlkaW5nQWxsICYmICFuZXdFbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IG51bVZpc2libGVJdGVtcyA9IHRoaXMuZ2V0VmlzaWJsZUl0ZW1Db3VudCgpO1xuICAgICAgICBpZiAobnVtVmlzaWJsZUl0ZW1zIDwgMikge1xuICAgICAgICAgIG5ld0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0dXMgPSBuZXdFbmFibGVkID8gXCJhcmlhQW5ub3VuY2VWaXNpYmxlXCIgOiBcImFyaWFBbm5vdW5jZUhpZGRlblwiO1xuICAgICAgdGhpcy5jdHguYXJpYUFubm91bmNlbWVudFNlcnZpY2UuYW5ub3VuY2VWYWx1ZShzdGF0dXMpO1xuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIubGVnZW5kSXRlbUNsaWNrKHNlcmllcywgaXRlbUlkLCBuZXdFbmFibGVkLCBkYXR1bS5sZWdlbmRJdGVtTmFtZSk7XG4gICAgfVxuICAgIGlmIChuZXdFbmFibGVkKSB7XG4gICAgICBoaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCB7XG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBkYXR1bTogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDIgLyogUFJPQ0VTU19EQVRBICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIGxlZ2VuZEl0ZW1DbGljaz8uKHsgdHlwZTogXCJjbGlja1wiLCBlbmFibGVkOiBuZXdFbmFibGVkLCBpdGVtSWQsIHNlcmllc0lkOiBzZXJpZXMuaWQgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2hlY2tMZWdlbmREb3VibGVDbGljayhldmVudCkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXREYXR1bUZvclBvaW50KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIGlmICh0aGlzLmRvRG91YmxlQ2xpY2soZGF0dW0pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBkb0RvdWJsZUNsaWNrKGRhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdGVuZXJzOiB7IGxlZ2VuZEl0ZW1Eb3VibGVDbGljayB9LFxuICAgICAgY3R4OiB7IGNoYXJ0U2VydmljZSB9LFxuICAgICAgdG9nZ2xlU2VyaWVzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGNoYXJ0U2VydmljZS5tb2RlID09PSBcImludGVncmF0ZWRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWRhdHVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIGl0ZW1JZCwgc2VyaWVzSWQgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHNlcmllcyA9IGNoYXJ0U2VydmljZS5zZXJpZXMuZmluZCgocykgPT4gcy5pZCA9PT0gaWQpO1xuICAgIGlmICghc2VyaWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0b2dnbGVTZXJpZXMpIHtcbiAgICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBjaGFydFNlcnZpY2Uuc2VyaWVzLmZsYXRNYXAoKHMpID0+IHMuZ2V0TGVnZW5kRGF0YShcImNhdGVnb3J5XCIpKTtcbiAgICAgIGNvbnN0IG51bVZpc2libGVJdGVtcyA9IGxlZ2VuZERhdGEuZmlsdGVyKChkKSA9PiBkLmVuYWJsZWQpLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNsaWNrZWRJdGVtID0gbGVnZW5kRGF0YS5maW5kKChkKSA9PiBkLml0ZW1JZCA9PT0gaXRlbUlkICYmIGQuc2VyaWVzSWQgPT09IHNlcmllc0lkKTtcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmxlZ2VuZEl0ZW1Eb3VibGVDbGljayhcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGNsaWNrZWRJdGVtPy5lbmFibGVkID8/IGZhbHNlLFxuICAgICAgICBudW1WaXNpYmxlSXRlbXMsXG4gICAgICAgIGNsaWNrZWRJdGVtPy5sZWdlbmRJdGVtTmFtZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoMiAvKiBQUk9DRVNTX0RBVEEgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUgfSk7XG4gICAgbGVnZW5kSXRlbURvdWJsZUNsaWNrPy4oeyB0eXBlOiBcImRibGNsaWNrXCIsIGVuYWJsZWQ6IHRydWUsIGl0ZW1JZCwgc2VyaWVzSWQ6IHNlcmllcy5pZCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBoYW5kbGVMZWdlbmRNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgdGhpcy5kb0hvdmVyKGV2ZW50LCBkYXR1bSk7XG4gIH1cbiAgZG9Ib3ZlcihldmVudCwgZGF0dW0pIHtcbiAgICBjb25zdCB7IHRvZ2dsZVNlcmllcywgbGlzdGVuZXJzIH0gPSB0aGlzO1xuICAgIGlmIChldmVudCA9PT0gdm9pZCAwIHx8IGRhdHVtID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzID0gZGF0dW0gPyB0aGlzLmN0eC5jaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGRhdHVtPy5pZCkgOiB2b2lkIDA7XG4gICAgaWYgKGRhdHVtICYmIHRoaXMudHJ1bmNhdGVkSXRlbXMuaGFzKGRhdHVtLml0ZW1JZCA/PyBkYXR1bS5pZCkpIHtcbiAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICB7IG9mZnNldFgsIG9mZnNldFksIGxhc3RQb2ludGVyRXZlbnQ6IGV2ZW50LCBzaG93QXJyb3c6IGZhbHNlIH0sXG4gICAgICAgIHRvVG9vbHRpcEh0bWwoeyBjb250ZW50OiB0aGlzLmdldEl0ZW1MYWJlbChkYXR1bSkgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgfVxuICAgIGlmICh0b2dnbGVTZXJpZXMgfHwgbGlzdGVuZXJzLmxlZ2VuZEl0ZW1DbGljayAhPSBudWxsIHx8IGxpc3RlbmVycy5sZWdlbmRJdGVtRG91YmxlQ2xpY2sgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0dW0/LmVuYWJsZWQgJiYgc2VyaWVzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCh7XG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgaXRlbUlkOiBkYXR1bT8uaXRlbUlkLFxuICAgICAgICBkYXR1bTogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHQoKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTGVnZW5kTW91c2VFeGl0KCkge1xuICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgdGhpcy51cGRhdGVIaWdobGlnaHQoKTtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHQoZGF0dW0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSA9PT0gMTYgLyogRGVmYXVsdCAqLykge1xuICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZGF0dW0pO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IDEgLyogQW5pbWF0aW9uICovKSB7XG4gICAgICB0aGlzLnBlbmRpbmdIaWdobGlnaHREYXR1bSA9IGRhdHVtO1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5vbkJhdGNoU3RvcCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIHRoaXMucGVuZGluZ0hpZ2hsaWdodERhdHVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVMZWdlbmRNb3VzZUVudGVyKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlZCxcbiAgICAgIHRvZ2dsZVNlcmllcyxcbiAgICAgIGxpc3RlbmVyczogeyBsZWdlbmRJdGVtQ2xpY2s6IGNsaWNrTGlzdGVuZXIsIGxlZ2VuZEl0ZW1Eb3VibGVDbGljazogZGJsY2xpY2tMaXN0ZW5lciB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgaWYgKGVuYWJsZWQgJiYgZGF0dW0gIT09IHZvaWQgMCAmJiAodG9nZ2xlU2VyaWVzIHx8IGNsaWNrTGlzdGVuZXIgIT0gbnVsbCB8fCBkYmxjbGlja0xpc3RlbmVyICE9IG51bGwpKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkLCBcInBvaW50ZXJcIik7XG4gICAgfVxuICB9XG4gIG9uTG9jYWxlQ2hhbmdlZCgpIHtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgoeyBwcm94eUJ1dHRvbiB9LCBfLCBpKSA9PiB7XG4gICAgICBpZiAocHJveHlCdXR0b24gIT0gbnVsbCkge1xuICAgICAgICBwcm94eUJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMuZ2V0SXRlbUFyaWFUZXh0KGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldEl0ZW1BcmlhVGV4dChub2RlSW5kZXgsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZGF0YVtub2RlSW5kZXhdO1xuICAgIGNvbnN0IGxhYmVsID0gZGF0dW0gJiYgdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pO1xuICAgIGVuYWJsZWQgPz8gKGVuYWJsZWQgPSBkYXR1bS5lbmFibGVkKTtcbiAgICBjb25zdCBsbSA9IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXI7XG4gICAgaWYgKG5vZGVJbmRleCA+PSAwICYmIGxhYmVsKSB7XG4gICAgICBjb25zdCBpbmRleCA9IG5vZGVJbmRleCArIDE7XG4gICAgICBjb25zdCBjb3VudCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICBjb25zdCBwYXJ0MSA9IGxtLnQoXCJhcmlhTGFiZWxMZWdlbmRJdGVtXCIsIHsgbGFiZWwsIGluZGV4LCBjb3VudCB9KTtcbiAgICAgIGNvbnN0IHBhcnQyID0gbG0udChlbmFibGVkID8gXCJhcmlhQW5ub3VuY2VWaXNpYmxlXCIgOiBcImFyaWFBbm5vdW5jZUhpZGRlblwiKTtcbiAgICAgIHJldHVybiBbcGFydDEsIHBhcnQyXS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbG0udChcImFyaWFMYWJlbExlZ2VuZEl0ZW1Vbmtub3duXCIpO1xuICB9XG4gIHBvc2l0aW9uTGVnZW5kKGN0eCkge1xuICAgIGNvbnN0IHsgc2hyaW5rUmVjdCB9ID0gY3R4O1xuICAgIGNvbnN0IG5ld1Nocmlua1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCk7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IC4uLmN0eCwgc2hyaW5rUmVjdDogbmV3U2hyaW5rUmVjdCB9O1xuICAgIH1cbiAgICBjb25zdCBbbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodF0gPSB0aGlzLmNhbGN1bGF0ZUxlZ2VuZERpbWVuc2lvbnMoc2hyaW5rUmVjdCk7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25ZID0gMDtcbiAgICBjb25zdCB7IG9sZFBhZ2VzIH0gPSB0aGlzLmNhbGNMYXlvdXQobGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodCk7XG4gICAgY29uc3QgbGVnZW5kQkJveCA9IHRoaXMuY29tcHV0ZVBhZ2VkQkJveCgpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbiA9ICgpID0+IHtcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICByZXR1cm4gc2hyaW5rUmVjdC5oZWlnaHQgLSBsZWdlbmRCQm94LmhlaWdodDtcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHNocmlua1JlY3Qud2lkdGggLSBsZWdlbmRCQm94LndpZHRoO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgY29uc3QgbGVnZW5kUGFkZGluZyA9IHRoaXMuc3BhY2luZztcbiAgICAgIGxldCB0cmFuc2xhdGlvblg7XG4gICAgICBsZXQgdHJhbnNsYXRpb25ZO1xuICAgICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIHRyYW5zbGF0aW9uWCA9IChzaHJpbmtSZWN0LndpZHRoIC0gbGVnZW5kQkJveC53aWR0aCkgLyAyO1xuICAgICAgICAgIHRyYW5zbGF0aW9uWSA9IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbigpO1xuICAgICAgICAgIG5ld1Nocmlua1JlY3Quc2hyaW5rKGxlZ2VuZEJCb3guaGVpZ2h0ICsgbGVnZW5kUGFkZGluZywgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRyYW5zbGF0aW9uWCA9IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbigpO1xuICAgICAgICAgIHRyYW5zbGF0aW9uWSA9IChzaHJpbmtSZWN0LmhlaWdodCAtIGxlZ2VuZEJCb3guaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgbmV3U2hyaW5rUmVjdC5zaHJpbmsobGVnZW5kQkJveC53aWR0aCArIGxlZ2VuZFBhZGRpbmcsIHRoaXMucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKC1sZWdlbmRCQm94LnggKyBzaHJpbmtSZWN0LnggKyB0cmFuc2xhdGlvblgpO1xuICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKC1sZWdlbmRCQm94LnkgKyBzaHJpbmtSZWN0LnkgKyB0cmFuc2xhdGlvblkpO1xuICAgICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIuYXJpYU9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlSXRlbVByb3h5QnV0dG9ucygpO1xuICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvblByb3h5QnV0dG9ucyhvbGRQYWdlcyk7XG4gICAgcmV0dXJuIHsgLi4uY3R4LCBzaHJpbmtSZWN0OiBuZXdTaHJpbmtSZWN0IH07XG4gIH1cbiAgY2FsY3VsYXRlTGVnZW5kRGltZW5zaW9ucyhzaHJpbmtSZWN0KSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzaHJpbmtSZWN0O1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3QgbWF4Q29lZmZpY2llbnQgPSAwLjU7XG4gICAgY29uc3QgbWluSGVpZ2h0Q29lZmZpY2llbnQgPSAwLjI7XG4gICAgY29uc3QgbWluV2lkdGhDb2VmZmljaWVudCA9IDAuMjU7XG4gICAgbGV0IGxlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIGNvbnN0IGhlaWdodENvZWZmaWNpZW50ID0gYXNwZWN0UmF0aW8gPCAxID8gTWF0aC5taW4obWF4Q29lZmZpY2llbnQsIG1pbkhlaWdodENvZWZmaWNpZW50ICogKDEgLyBhc3BlY3RSYXRpbykpIDogbWluSGVpZ2h0Q29lZmZpY2llbnQ7XG4gICAgICAgIGxlZ2VuZFdpZHRoID0gdGhpcy5tYXhXaWR0aCA/IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHdpZHRoKSA6IHdpZHRoO1xuICAgICAgICBsZWdlbmRIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQpIDogTWF0aC5yb3VuZChoZWlnaHQgKiBoZWlnaHRDb2VmZmljaWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3Qgd2lkdGhDb2VmZmljaWVudCA9IGFzcGVjdFJhdGlvID4gMSA/IE1hdGgubWluKG1heENvZWZmaWNpZW50LCBtaW5XaWR0aENvZWZmaWNpZW50ICogYXNwZWN0UmF0aW8pIDogbWluV2lkdGhDb2VmZmljaWVudDtcbiAgICAgICAgbGVnZW5kV2lkdGggPSB0aGlzLm1heFdpZHRoID8gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgd2lkdGgpIDogTWF0aC5yb3VuZCh3aWR0aCAqIHdpZHRoQ29lZmZpY2llbnQpO1xuICAgICAgICBsZWdlbmRIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQpIDogaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gW2xlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHRdO1xuICB9XG59O1xuTGVnZW5kLmNsYXNzTmFtZSA9IFwiTGVnZW5kXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJ0b2dnbGVTZXJpZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInBhZ2luYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIml0ZW1cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcImxpc3RlbmVyc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC51cGRhdGVHcm91cFZpc2liaWxpdHkoKSksXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElPTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwibWF4SGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJyZXZlcnNlT3JkZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0sIFwiYW4gb3JpZW50YXRpb25cIiksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInByZXZlbnRIaWRpbmdBbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xlZ2VuZE1vZHVsZS50c1xudmFyIENvbW11bml0eUxlZ2VuZE1vZHVsZSA9IHtcbiAgdHlwZTogXCJsZWdlbmRcIixcbiAgb3B0aW9uc0tleTogXCJsZWdlbmRcIixcbiAgaWRlbnRpZmllcjogXCJjYXRlZ29yeVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTGVnZW5kKGN0eCksXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sb2NhbGUvbG9jYWxlLnRzXG52YXIgTG9jYWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMubG9jYWxlVGV4dCA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQuY3R4LmxvY2FsZU1hbmFnZXIuc2V0TG9jYWxlVGV4dCh0YXJnZXQubG9jYWxlVGV4dCk7XG4gIH0pLFxuICBWYWxpZGF0ZShQTEFJTl9PQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExvY2FsZS5wcm90b3R5cGUsIFwibG9jYWxlVGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQuY3R4LmxvY2FsZU1hbmFnZXIuc2V0TG9jYWxlVGV4dEZvcm1hdHRlcih0YXJnZXQuZ2V0TG9jYWxlVGV4dCk7XG4gIH0pLFxuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTG9jYWxlLnByb3RvdHlwZSwgXCJnZXRMb2NhbGVUZXh0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sb2NhbGUvbG9jYWxlTW9kdWxlLnRzXG52YXIgTG9jYWxlTW9kdWxlID0ge1xuICB0eXBlOiBcInJvb3RcIixcbiAgb3B0aW9uc0tleTogXCJsb2NhbGVcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBMb2NhbGUoY3R4KVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL3NoYXBlcy9yYW5nZUhhbmRsZS50c1xudmFyIFJhbmdlSGFuZGxlID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnpJbmRleCA9IDM7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMud2lkdGggPSA4O1xuICAgIHRoaXMuaGVpZ2h0ID0gMTY7XG4gICAgdGhpcy5ncmlwTGluZUdhcCA9IDI7XG4gICAgdGhpcy5ncmlwTGluZUxlbmd0aCA9IDg7XG4gIH1cbiAgc2V0Q2VudGVyKHgsIHkpIHtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gICAgdGhpcy5jZW50ZXJYID0geDtcbiAgICB0aGlzLmNlbnRlclkgPSB5O1xuICB9XG4gIHN0YXRpYyBhbGlnbihtaW5IYW5kbGUsIG1heEhhbmRsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluLCBtYXgpIHtcbiAgICBjb25zdCBoYW5kbGVQaXhlbEFsaWduID0gbWluSGFuZGxlLnN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBtaW5IYW5kbGVYID0gbWluSGFuZGxlLmFsaWduKHggKyB3aWR0aCAqIG1pbikgKyBoYW5kbGVQaXhlbEFsaWduO1xuICAgIGNvbnN0IG1heEhhbmRsZVggPSBtaW5IYW5kbGVYICsgbWluSGFuZGxlLmFsaWduKHggKyB3aWR0aCAqIG1pbiwgd2lkdGggKiAobWF4IC0gbWluKSkgLSAyICogaGFuZGxlUGl4ZWxBbGlnbjtcbiAgICBjb25zdCBoYW5kbGVZID0gbWluSGFuZGxlLmFsaWduKHkgKyBoZWlnaHQgLyAyKSArIGhhbmRsZVBpeGVsQWxpZ247XG4gICAgbWluSGFuZGxlLnNldENlbnRlcihtaW5IYW5kbGVYLCBoYW5kbGVZKTtcbiAgICBtYXhIYW5kbGUuc2V0Q2VudGVyKG1heEhhbmRsZVgsIGhhbmRsZVkpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcbiAgICBjb25zdCB4ID0gY2VudGVyWCAtIHdpZHRoIC8gMjtcbiAgICBjb25zdCB5ID0gY2VudGVyWSAtIGhlaWdodCAvIDI7XG4gICAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiBiYm94LmNvbnRhaW5zUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHBhdGgsIHN0cm9rZVdpZHRoLCBncmlwTGluZUdhcCwgZ3JpcExpbmVMZW5ndGggfSA9IHRoaXM7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXM/LnBpeGVsUmF0aW8gPz8gMTtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgY29uc3QgaGFsZldpZHRoID0gTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAvIDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgcGF0aC5tb3ZlVG8oY2VudGVyWCAtIGhhbGZXaWR0aCwgY2VudGVyWSAtIGhhbGZIZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggKyBoYWxmV2lkdGgsIGNlbnRlclkgLSBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYICsgaGFsZldpZHRoLCBjZW50ZXJZICsgaGFsZkhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCAtIGhhbGZXaWR0aCwgY2VudGVyWSArIGhhbGZIZWlnaHQpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgY29uc3QgZHggPSBNYXRoLmZsb29yKChncmlwTGluZUdhcCArIHN0cm9rZVdpZHRoKSAvIDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgY29uc3QgZHkgPSBNYXRoLmZsb29yKGdyaXBMaW5lTGVuZ3RoIC8gMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBwYXRoLm1vdmVUbyhjZW50ZXJYIC0gZHgsIGNlbnRlclkgLSBkeSk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCAtIGR4LCBjZW50ZXJZICsgZHkpO1xuICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBkeCwgY2VudGVyWSAtIGR5KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYICsgZHgsIGNlbnRlclkgKyBkeSk7XG4gIH1cbn07XG5SYW5nZUhhbmRsZS5jbGFzc05hbWUgPSBcIlJhbmdlSGFuZGxlXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCB0eXBlOiBcInBhdGhcIiB9KVxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCB0eXBlOiBcInBhdGhcIiB9KVxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcImdyaXBMaW5lR2FwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiZ3JpcExpbmVMZW5ndGhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9zaGFwZXMvcmFuZ2VNYXNrLnRzXG52YXIgUmFuZ2VNYXNrID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnpJbmRleCA9IDI7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAyMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLm1pbiA9IDA7XG4gICAgdGhpcy5tYXggPSAxO1xuICB9XG4gIGxheW91dCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgdXBkYXRlKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5taW4gPSBpc05hTihtaW4pID8gdGhpcy5taW4gOiBtaW47XG4gICAgdGhpcy5tYXggPSBpc05hTihtYXgpID8gdGhpcy5tYXggOiBtYXg7XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCBtaW5YID0geCArIHdpZHRoICogbWluO1xuICAgIGNvbnN0IG1heFggPSB4ICsgd2lkdGggKiBtYXg7XG4gICAgcmV0dXJuIG5ldyBCQm94KG1pblgsIHksIG1heFggLSBtaW5YLCBoZWlnaHQpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW4sIG1heCwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3QgcGl4ZWxBbGlnbiA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgY29uc3QgYXggPSB0aGlzLmFsaWduKHgpICsgcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBheSA9IHRoaXMuYWxpZ24oeSkgKyBwaXhlbEFsaWduO1xuICAgIGNvbnN0IGF4dyA9IGF4ICsgdGhpcy5hbGlnbih4LCB3aWR0aCkgLSAyICogcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBheWggPSBheSArIHRoaXMuYWxpZ24oeSwgaGVpZ2h0KSAtIDIgKiBwaXhlbEFsaWduO1xuICAgIHBhdGgubW92ZVRvKGF4LCBheSk7XG4gICAgcGF0aC5saW5lVG8oYXh3LCBheSk7XG4gICAgcGF0aC5saW5lVG8oYXh3LCBheWgpO1xuICAgIHBhdGgubGluZVRvKGF4LCBheWgpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgY29uc3QgbWluWCA9IHRoaXMuYWxpZ24oeCArIHdpZHRoICogbWluKSArIHBpeGVsQWxpZ247XG4gICAgY29uc3QgbWF4WCA9IG1pblggKyB0aGlzLmFsaWduKHggKyB3aWR0aCAqIG1pbiwgd2lkdGggKiAobWF4IC0gbWluKSkgLSAyICogcGl4ZWxBbGlnbjtcbiAgICBwYXRoLm1vdmVUbyhtaW5YLCBheSk7XG4gICAgcGF0aC5saW5lVG8obWluWCwgYXloKTtcbiAgICBwYXRoLmxpbmVUbyhtYXhYLCBheWgpO1xuICAgIHBhdGgubGluZVRvKG1heFgsIGF5KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuUmFuZ2VNYXNrLmNsYXNzTmFtZSA9IFwiUmFuZ2VNYXNrXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9zaGFwZXMvcmFuZ2VTZWxlY3Rvci50c1xudmFyIFJhbmdlU2VsZWN0b3IgPSBjbGFzcyBleHRlbmRzIEdyb3VwIHtcbiAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICBzdXBlcih7IG5hbWU6IFwicmFuZ2VTZWxlY3Rvckdyb3VwXCIsIGxheWVyOiB0cnVlLCB6SW5kZXg6IDE0IC8qIE5BVklHQVRPUl9aSU5ERVggKi8gfSk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAyMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLmxPZmZzZXQgPSAwO1xuICAgIHRoaXMuck9mZnNldCA9IDA7XG4gICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSB0cnVlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBHcm91cCh7IG5hbWU6IFwibmF2aWdhdG9yLWJhY2tncm91bmRcIiB9KTtcbiAgICB0aGlzLmJhY2tncm91bmQuekluZGV4ID0gMTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZCk7XG4gICAgdGhpcy5hcHBlbmQoY2hpbGRyZW4pO1xuICB9XG4gIGxheW91dCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsT2Zmc2V0LCByT2Zmc2V0KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmxPZmZzZXQgPSBsT2Zmc2V0O1xuICAgIHRoaXMuck9mZnNldCA9IHJPZmZzZXQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLnRyYW5zbGF0aW9uWCA9IHg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLnRyYW5zbGF0aW9uWSA9IHk7XG4gIH1cbiAgdXBkYXRlQmFja2dyb3VuZChvbGRHcm91cCwgbmV3R3JvdXApIHtcbiAgICBpZiAob2xkR3JvdXAgIT0gbnVsbCkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kLnJlbW92ZUNoaWxkKG9sZEdyb3VwKTtcbiAgICB9XG4gICAgaWYgKG5ld0dyb3VwICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZC5hcHBlbmRDaGlsZChuZXdHcm91cCk7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgbE9mZnNldCwgck9mZnNldCB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEJCb3goeCAtIGxPZmZzZXQsIHksIHdpZHRoICsgKGxPZmZzZXQgKyByT2Zmc2V0KSwgaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL25hdmlnYXRvci50c1xudmFyIE5hdmlnYXRvciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLm1pbmlDaGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1hc2sgPSBuZXcgUmFuZ2VNYXNrKCk7XG4gICAgdGhpcy5taW5IYW5kbGUgPSBuZXcgUmFuZ2VIYW5kbGUoKTtcbiAgICB0aGlzLm1heEhhbmRsZSA9IG5ldyBSYW5nZUhhbmRsZSgpO1xuICAgIHRoaXMubWFza1Zpc2libGVSYW5nZSA9IHtcbiAgICAgIGlkOiBcIm5hdmlnYXRvci1tYXNrLXZpc2libGUtcmFuZ2VcIixcbiAgICAgIGdldEJCb3g6ICgpID0+IHRoaXMubWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpLFxuICAgICAgY29tcHV0ZVRyYW5zZm9ybWVkQkJveDogKCkgPT4gdGhpcy5tYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KClcbiAgICB9O1xuICAgIHRoaXMuaGVpZ2h0ID0gMzA7XG4gICAgdGhpcy5zcGFjaW5nID0gMTA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMucmFuZ2VTZWxlY3RvciA9IG5ldyBSYW5nZVNlbGVjdG9yKFt0aGlzLm1hc2ssIHRoaXMubWluSGFuZGxlLCB0aGlzLm1heEhhbmRsZV0pO1xuICAgIHRoaXMuX21pbiA9IDA7XG4gICAgdGhpcy5fbWF4ID0gMTtcbiAgICB0aGlzLm1pblJhbmdlID0gMWUtMztcbiAgICBjb25zdCByZWdpb24gPSBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJuYXZpZ2F0b3JcIiwgdGhpcy5yYW5nZVNlbGVjdG9yKTtcbiAgICBjb25zdCBkcmFnU3RhdGVzID0gMTYgLyogRGVmYXVsdCAqLyB8IDEgLyogQW5pbWF0aW9uICovIHwgOCAvKiBab29tRHJhZyAqLztcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5zY2VuZS5hdHRhY2hOb2RlKHRoaXMucmFuZ2VTZWxlY3RvciksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZy1zdGFydFwiLCAoZXZlbnQpID0+IHRoaXMub25EcmFnU3RhcnQoZXZlbnQpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWdcIiwgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZyhldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZy1lbmRcIiwgKCkgPT4gdGhpcy5vbkRyYWdFbmQoKSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoZXZlbnQpID0+IHRoaXMub25MZWF2ZShldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgdGhpcy5jdHgubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsICgpID0+IHRoaXMudXBkYXRlWm9vbSgpKSxcbiAgICAgIGN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsIChldmVudCkgPT4gdGhpcy5vblpvb21DaGFuZ2UoZXZlbnQpKVxuICAgICk7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIgPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUNvbnRhaW5lcih7XG4gICAgICB0eXBlOiBcInRvb2xiYXJcIixcbiAgICAgIGlkOiBgbmF2aWdhdG9yLXRvb2xiYXJgLFxuICAgICAgY2xhc3NMaXN0OiBbXCJhZy1jaGFydHMtcHJveHktbmF2aWdhdG9yLXRvb2xiYXJcIl0sXG4gICAgICBhcmlhT3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxOYXZpZ2F0b3JcIiB9XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHMgPSBbXG4gICAgICB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICBpZDogXCJhZy1jaGFydHMtbmF2aWdhdG9yLW1pblwiLFxuICAgICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yTWluaW11bVwiIH0sXG4gICAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIHBhcmVudDogdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsXG4gICAgICAgIGZvY3VzYWJsZTogdGhpcy5taW5IYW5kbGUsXG4gICAgICAgIG9uY2hhbmdlOiAoZXYpID0+IHRoaXMub25NaW5TbGlkZXJDaGFuZ2UoZXYpXG4gICAgICB9KSxcbiAgICAgIHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgIHR5cGU6IFwic2xpZGVyXCIsXG4gICAgICAgIGlkOiBcImFnLWNoYXJ0cy1uYXZpZ2F0b3ItcGFuXCIsXG4gICAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxOYXZpZ2F0b3JSYW5nZVwiIH0sXG4gICAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIHBhcmVudDogdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsXG4gICAgICAgIGZvY3VzYWJsZTogdGhpcy5tYXNrVmlzaWJsZVJhbmdlLFxuICAgICAgICBvbmNoYW5nZTogKGV2KSA9PiB0aGlzLm9uUGFuU2xpZGVyQ2hhbmdlKGV2KVxuICAgICAgfSksXG4gICAgICB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICBpZDogXCJhZy1jaGFydHMtbmF2aWdhdG9yLW1heFwiLFxuICAgICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yTWF4aW11bVwiIH0sXG4gICAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIHBhcmVudDogdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsXG4gICAgICAgIGZvY3VzYWJsZTogdGhpcy5tYXhIYW5kbGUsXG4gICAgICAgIG9uY2hhbmdlOiAoZXYpID0+IHRoaXMub25NYXhTbGlkZXJDaGFuZ2UoZXYpXG4gICAgICB9KVxuICAgIF07XG4gICAgaW5pdFRvb2xiYXJLZXlOYXYoe1xuICAgICAgb3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICAgIHRvb2xiYXI6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgYnV0dG9uczogdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzXG4gICAgfSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goKCkgPT4ge1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzLmZvckVhY2goKGUpID0+IGUucmVtb3ZlKCkpO1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQmFja2dyb3VuZChvbGRHcm91cCwgbmV3R3JvdXApIHtcbiAgICB0aGlzLnJhbmdlU2VsZWN0b3I/LnVwZGF0ZUJhY2tncm91bmQob2xkR3JvdXAsIG5ld0dyb3VwKTtcbiAgfVxuICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XG4gICAgY29uc3QgeyBlbmFibGVkIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnJhbmdlU2VsZWN0b3IgPT0gbnVsbCB8fCBlbmFibGVkID09PSB0aGlzLnJhbmdlU2VsZWN0b3IudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJhbmdlU2VsZWN0b3IudmlzaWJsZSA9IGVuYWJsZWQ7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIuYXJpYUhpZGRlbiA9ICghZW5hYmxlZCkudG9TdHJpbmcoKTtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGVab29tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJuYXZpZ2F0b3JcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBzaHJpbmtSZWN0IH0gPSBjdHg7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgY29uc3QgbmF2aWdhdG9yVG90YWxIZWlnaHQgPSB0aGlzLmhlaWdodCArIHRoaXMuc3BhY2luZztcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKG5hdmlnYXRvclRvdGFsSGVpZ2h0LCBcImJvdHRvbVwiKTtcbiAgICAgIHRoaXMueSA9IHNocmlua1JlY3QueSArIHNocmlua1JlY3QuaGVpZ2h0ICsgdGhpcy5zcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5jdHgsIHNocmlua1JlY3QgfTtcbiAgfVxuICBhc3luYyBwZXJmb3JtQ2FydGVzaWFuTGF5b3V0KG9wdHMpIHtcbiAgICBjb25zdCB7IHgsIHdpZHRoIH0gPSBvcHRzLnNlcmllc1JlY3Q7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgY29uc3QgeyB5LCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgICB0aGlzLmxheW91dE5vZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgfVxuICBvbkhvdmVyKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBtYXNrLCBtaW5IYW5kbGUsIG1heEhhbmRsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGlmIChtaW5IYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSB8fCBtYXhIYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IoXCJuYXZpZ2F0b3JcIiwgXCJldy1yZXNpemVcIik7XG4gICAgfSBlbHNlIGlmIChtYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCkuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IoXCJuYXZpZ2F0b3JcIiwgXCJncmFiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihcIm5hdmlnYXRvclwiKTtcbiAgICB9XG4gIH1cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG1hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB3aWR0aCwgX21pbjogbWluIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgaWYgKG1pbkhhbmRsZS56SW5kZXggPCBtYXhIYW5kbGUuekluZGV4KSB7XG4gICAgICBpZiAobWF4SGFuZGxlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWF4XCI7XG4gICAgICB9IGVsc2UgaWYgKG1pbkhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcIm1pblwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluSGFuZGxlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcIm1pblwiO1xuICAgIH0gZWxzZSBpZiAobWF4SGFuZGxlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcIm1heFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIG1hc2suY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nID0gXCJwYW5cIjtcbiAgICAgIHRoaXMucGFuU3RhcnQgPSAob2Zmc2V0WCAtIHgpIC8gd2lkdGggLSBtaW47XG4gICAgfVxuICAgIGlmICh0aGlzLmRyYWdnaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmZpcmVab29tUGFuU3RhcnRFdmVudChcIm5hdmlnYXRvclwiKTtcbiAgICB9XG4gIH1cbiAgb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZHJhZ2dpbmcsIG1pblJhbmdlLCBwYW5TdGFydCwgeCwgd2lkdGggfSA9IHRoaXM7XG4gICAgbGV0IHsgX21pbjogbWluLCBfbWF4OiBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBvZmZzZXRYIH0gPSBldmVudDtcbiAgICBjb25zdCByYXRpbzIgPSAob2Zmc2V0WCAtIHgpIC8gd2lkdGg7XG4gICAgaWYgKGRyYWdnaW5nID09PSBcIm1pblwiKSB7XG4gICAgICBtaW4gPSBjbGFtcCgwLCByYXRpbzIsIG1heCAtIG1pblJhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGRyYWdnaW5nID09PSBcIm1heFwiKSB7XG4gICAgICBtYXggPSBjbGFtcChtaW4gKyBtaW5SYW5nZSwgcmF0aW8yLCAxKTtcbiAgICB9IGVsc2UgaWYgKGRyYWdnaW5nID09PSBcInBhblwiICYmIHBhblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNwYW4gPSBtYXggLSBtaW47XG4gICAgICBtaW4gPSBjbGFtcCgwLCByYXRpbzIgLSBwYW5TdGFydCwgMSAtIHNwYW4pO1xuICAgICAgbWF4ID0gbWluICsgc3BhbjtcbiAgICB9XG4gICAgdGhpcy5fbWluID0gbWluO1xuICAgIHRoaXMuX21heCA9IG1heDtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBvbkRyYWdFbmQoKSB7XG4gICAgdGhpcy5kcmFnZ2luZyA9IHZvaWQgMDtcbiAgfVxuICBvbkxlYXZlKF9ldmVudCkge1xuICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIpO1xuICB9XG4gIG9uWm9vbUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHsgeCB9ID0gZXZlbnQ7XG4gICAgaWYgKCF4KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX21pbiA9IHgubWluO1xuICAgIHRoaXMuX21heCA9IHgubWF4O1xuICAgIHRoaXMudXBkYXRlTm9kZXMoeC5taW4sIHgubWF4KTtcbiAgICB0aGlzLnNldFBhblNsaWRlclZhbHVlKHgubWluLCB4Lm1heCk7XG4gICAgdGhpcy5zZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMF0sIHgubWluKTtcbiAgICB0aGlzLnNldFNsaWRlclJhdGlvKHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1syXSwgeC5tYXgpO1xuICB9XG4gIG9uUGFuU2xpZGVyQ2hhbmdlKF9ldmVudCkge1xuICAgIGNvbnN0IHJhdGlvMiA9IHRoaXMuZ2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzFdKTtcbiAgICBjb25zdCBzcGFuID0gdGhpcy5fbWF4IC0gdGhpcy5fbWluO1xuICAgIHRoaXMuX21pbiA9IGNsYW1wKDAsIHJhdGlvMiwgMSAtIHNwYW4pO1xuICAgIHRoaXMuX21heCA9IHRoaXMuX21pbiArIHNwYW47XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgb25NaW5TbGlkZXJDaGFuZ2UoX2V2ZW50KSB7XG4gICAgY29uc3Qgc2xpZGVyID0gdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzBdO1xuICAgIHRoaXMuX21pbiA9IHRoaXMuc2V0U2xpZGVyUmF0aW9DbGFtcGVkKHNsaWRlciwgMCwgdGhpcy5fbWF4IC0gdGhpcy5taW5SYW5nZSk7XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgb25NYXhTbGlkZXJDaGFuZ2UoX2V2ZW50KSB7XG4gICAgY29uc3Qgc2xpZGVyID0gdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzJdO1xuICAgIHRoaXMuX21heCA9IHRoaXMuc2V0U2xpZGVyUmF0aW9DbGFtcGVkKHNsaWRlciwgdGhpcy5fbWluICsgdGhpcy5taW5SYW5nZSwgMSk7XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgc2V0UGFuU2xpZGVyVmFsdWUobWluLCBtYXgpIHtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMV0udmFsdWUgPSBgJHtNYXRoLnJvdW5kKG1pbiAqIDEwMCl9YDtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMV0uYXJpYVZhbHVlVGV4dCA9IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFWYWx1ZVBhblJhbmdlXCIsIHsgbWluLCBtYXggfSk7XG4gIH1cbiAgc2V0U2xpZGVyUmF0aW9DbGFtcGVkKHNsaWRlciwgY2xhbXBNaW4sIGNsYW1wTWF4KSB7XG4gICAgY29uc3QgcmF0aW8yID0gdGhpcy5nZXRTbGlkZXJSYXRpbyhzbGlkZXIpO1xuICAgIGNvbnN0IGNsYW1wZWRSYXRpbyA9IGNsYW1wKGNsYW1wTWluLCByYXRpbzIsIGNsYW1wTWF4KTtcbiAgICBpZiAoY2xhbXBlZFJhdGlvICE9PSByYXRpbzIpIHtcbiAgICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8oc2xpZGVyLCBjbGFtcGVkUmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXBlZFJhdGlvO1xuICB9XG4gIHNldFNsaWRlclJhdGlvKHNsaWRlciwgcmF0aW8yKSB7XG4gICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKHJhdGlvMiAqIDEwMCk7XG4gICAgc2xpZGVyLnZhbHVlID0gYCR7dmFsdWV9YDtcbiAgICBzbGlkZXIuYXJpYVZhbHVlVGV4dCA9IGZvcm1hdFBlcmNlbnRhZ2UodmFsdWUpO1xuICB9XG4gIGdldFNsaWRlclJhdGlvKHNsaWRlcikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHNsaWRlci52YWx1ZSkgLyAxMDA7XG4gIH1cbiAgbGF5b3V0Tm9kZXMoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHsgcmFuZ2VTZWxlY3RvciwgbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGUsIF9taW46IG1pbiwgX21heDogbWF4IH0gPSB0aGlzO1xuICAgIHJhbmdlU2VsZWN0b3IubGF5b3V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbkhhbmRsZS53aWR0aCAvIDIsIG1heEhhbmRsZS53aWR0aCAvIDIpO1xuICAgIG1hc2subGF5b3V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIFJhbmdlSGFuZGxlLmFsaWduKG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW4sIG1heCk7XG4gICAgaWYgKG1pbiArIChtYXggLSBtaW4pIC8gMiA8IDAuNSkge1xuICAgICAgbWluSGFuZGxlLnpJbmRleCA9IDM7XG4gICAgICBtYXhIYW5kbGUuekluZGV4ID0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluSGFuZGxlLnpJbmRleCA9IDQ7XG4gICAgICBtYXhIYW5kbGUuekluZGV4ID0gMztcbiAgICB9XG4gICAgW21pbkhhbmRsZSwgdGhpcy5tYXNrVmlzaWJsZVJhbmdlLCBtYXhIYW5kbGVdLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBiYm94ID0gbm9kZS5nZXRCQm94KCk7XG4gICAgICBjb25zdCB0Ym94ID0geyB4OiBiYm94LnggLSB4LCB5OiBiYm94LnkgLSB5LCBoZWlnaHQ6IGJib3guaGVpZ2h0LCB3aWR0aDogYmJveC53aWR0aCB9O1xuICAgICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzW2luZGV4XSwgdGJveCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTm9kZXMobWluLCBtYXgpIHtcbiAgICB0aGlzLm1hc2sudXBkYXRlKG1pbiwgbWF4KTtcbiAgfVxuICB1cGRhdGVab29tKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgX21pbjogbWluLCBfbWF4OiBtYXggfSA9IHRoaXM7XG4gICAgaWYgKG1pbiA9PSBudWxsIHx8IG1heCA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdhcm5PbkNvbmZsaWN0ID0gKHN0YXRlSWQpID0+IHtcbiAgICAgIGlmICh0aGlzLm1pbiA9PSBudWxsICYmIHRoaXMubWF4ID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgYENvdWxkIG5vdCBhcHBseSBbbmF2aWdhdG9yLm1pbl0gb3IgW25hdmlnYXRvci5tYXhdIGFzIFske3N0YXRlSWR9XSBoYXMgbW9kaWZpZWQgdGhlIGluaXRpYWwgem9vbSBzdGF0ZS5gXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJuYXZpZ2F0b3JcIiwgeyB4OiB7IG1pbiwgbWF4IH0gfSwgZmFsc2UsIHdhcm5PbkNvbmZsaWN0KTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJtaW5pQ2hhcnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKSxcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0LnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpKVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUobWluKSB7XG4gICAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgICB9XG4gIH0pLFxuICBWYWxpZGF0ZShBTkQoUkFUSU8sIExFU1NfVEhBTihcIm1heFwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKG1heCkge1xuICAgICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgICAgdGhpcy51cGRhdGVab29tKCk7XG4gICAgfVxuICB9KSxcbiAgVmFsaWRhdGUoQU5EKFJBVElPLCBHUkVBVEVSX1RIQU4oXCJtaW5cIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL25hdmlnYXRvck1vZHVsZS50c1xudmFyIE5hdmlnYXRvck1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwibmF2aWdhdG9yXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBOYXZpZ2F0b3IoY3R4KSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIG5hdmlnYXRvcjoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBoZWlnaHQ6IDMwLFxuICAgICAgbWFzazoge1xuICAgICAgICBmaWxsOiBcIiM5OTk5OTlcIixcbiAgICAgICAgc3Ryb2tlOiBcIiM5OTk5OTlcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjJcbiAgICAgIH0sXG4gICAgICBtaW5IYW5kbGU6IHtcbiAgICAgICAgZmlsbDogXCIjZjJmMmYyXCIsXG4gICAgICAgIHN0cm9rZTogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICB3aWR0aDogOSxcbiAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgZ3JpcExpbmVHYXA6IDEsXG4gICAgICAgIGdyaXBMaW5lTGVuZ3RoOiA4XG4gICAgICB9LFxuICAgICAgbWF4SGFuZGxlOiB7XG4gICAgICAgIGZpbGw6IFwiI2YyZjJmMlwiLFxuICAgICAgICBzdHJva2U6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgd2lkdGg6IDksXG4gICAgICAgIGhlaWdodDogMTYsXG4gICAgICAgIGdyaXBMaW5lR2FwOiAxLFxuICAgICAgICBncmlwTGluZUxlbmd0aDogOFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL3RoZW1lLnRzXG5mdW5jdGlvbiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeSh7IHRha2VDb2xvcnMgfSkge1xuICBjb25zdCB7XG4gICAgZmlsbHM6IFtmaWxsXSxcbiAgICBzdHJva2VzOiBbc3Ryb2tlXVxuICB9ID0gdGFrZUNvbG9ycygxKTtcbiAgcmV0dXJuIHsgZmlsbCwgc3Ryb2tlIH07XG59XG5mdW5jdGlvbiBtYXJrZXJQYWxldHRlRmFjdG9yeShwYXJhbXMpIHtcbiAgcmV0dXJuIHsgbWFya2VyOiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeShwYXJhbXMpIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9jb25zdGFudHMudHNcbnZhciBGT05UX1NJWkUgPSAvKiBAX19QVVJFX18gKi8gKChGT05UX1NJWkUyKSA9PiB7XG4gIEZPTlRfU0laRTJbRk9OVF9TSVpFMltcIlNNQUxMXCJdID0gMTJdID0gXCJTTUFMTFwiO1xuICBGT05UX1NJWkUyW0ZPTlRfU0laRTJbXCJNRURJVU1cIl0gPSAxM10gPSBcIk1FRElVTVwiO1xuICBGT05UX1NJWkUyW0ZPTlRfU0laRTJbXCJMQVJHRVwiXSA9IDE3XSA9IFwiTEFSR0VcIjtcbiAgcmV0dXJuIEZPTlRfU0laRTI7XG59KShGT05UX1NJWkUgfHwge30pO1xudmFyIEZPTlRfV0VJR0hUMiA9IC8qIEBfX1BVUkVfXyAqLyAoKEZPTlRfV0VJR0hUMykgPT4ge1xuICBGT05UX1dFSUdIVDNbXCJOT1JNQUxcIl0gPSBcIm5vcm1hbFwiO1xuICBGT05UX1dFSUdIVDNbXCJCT0xEXCJdID0gXCJib2xkXCI7XG4gIEZPTlRfV0VJR0hUM1tcIkJPTERFUlwiXSA9IFwiYm9sZGVyXCI7XG4gIEZPTlRfV0VJR0hUM1tcIkxJR0hURVJcIl0gPSBcImxpZ2h0ZXJcIjtcbiAgcmV0dXJuIEZPTlRfV0VJR0hUMztcbn0pKEZPTlRfV0VJR0hUMiB8fCB7fSk7XG52YXIgUE9TSVRJT04yID0gLyogQF9fUFVSRV9fICovICgoUE9TSVRJT04zKSA9PiB7XG4gIFBPU0lUSU9OM1tcIlRPUFwiXSA9IFwidG9wXCI7XG4gIFBPU0lUSU9OM1tcIlJJR0hUXCJdID0gXCJyaWdodFwiO1xuICBQT1NJVElPTjNbXCJCT1RUT01cIl0gPSBcImJvdHRvbVwiO1xuICBQT1NJVElPTjNbXCJMRUZUXCJdID0gXCJsZWZ0XCI7XG4gIHJldHVybiBQT1NJVElPTjM7XG59KShQT1NJVElPTjIgfHwge30pO1xudmFyIENBUlRFU0lBTl9BWElTX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChDQVJURVNJQU5fQVhJU19UWVBFMikgPT4ge1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIkNBVEVHT1JZXCJdID0gXCJjYXRlZ29yeVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIk9SRElOQUxfVElNRVwiXSA9IFwib3JkaW5hbC10aW1lXCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiTlVNQkVSXCJdID0gXCJudW1iZXJcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJUSU1FXCJdID0gXCJ0aW1lXCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiTE9HXCJdID0gXCJsb2dcIjtcbiAgcmV0dXJuIENBUlRFU0lBTl9BWElTX1RZUEUyO1xufSkoQ0FSVEVTSUFOX0FYSVNfVFlQRSB8fCB7fSk7XG52YXIgUE9MQVJfQVhJU19UWVBFID0gLyogQF9fUFVSRV9fICovICgoUE9MQVJfQVhJU19UWVBFMikgPT4ge1xuICBQT0xBUl9BWElTX1RZUEUyW1wiQU5HTEVfQ0FURUdPUllcIl0gPSBcImFuZ2xlLWNhdGVnb3J5XCI7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJBTkdMRV9OVU1CRVJcIl0gPSBcImFuZ2xlLW51bWJlclwiO1xuICBQT0xBUl9BWElTX1RZUEUyW1wiUkFESVVTX0NBVEVHT1JZXCJdID0gXCJyYWRpdXMtY2F0ZWdvcnlcIjtcbiAgUE9MQVJfQVhJU19UWVBFMltcIlJBRElVU19OVU1CRVJcIl0gPSBcInJhZGl1cy1udW1iZXJcIjtcbiAgcmV0dXJuIFBPTEFSX0FYSVNfVFlQRTI7XG59KShQT0xBUl9BWElTX1RZUEUgfHwge30pO1xudmFyIFBPTEFSX0FYSVNfU0hBUEUgPSAvKiBAX19QVVJFX18gKi8gKChQT0xBUl9BWElTX1NIQVBFMikgPT4ge1xuICBQT0xBUl9BWElTX1NIQVBFMltcIkNJUkNMRVwiXSA9IFwiY2lyY2xlXCI7XG4gIFBPTEFSX0FYSVNfU0hBUEUyW1wiUE9MWUdPTlwiXSA9IFwicG9seWdvblwiO1xuICByZXR1cm4gUE9MQVJfQVhJU19TSEFQRTI7XG59KShQT0xBUl9BWElTX1NIQVBFIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3N5bWJvbHMudHNcbnZhciBJU19EQVJLX1RIRU1FID0gU3ltYm9sKFwiaXMtZGFyay10aGVtZVwiKTtcbnZhciBERUZBVUxUX0ZPTlRfRkFNSUxZID0gU3ltYm9sKFwiZGVmYXVsdC1mb250XCIpO1xudmFyIERFRkFVTFRfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1sYWJlbC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWludmVydGVkLWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1pbnNpZGUtc2VyaWVzLWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtbXV0ZWQtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtYXhpcy1ncmlkLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0FYSVNfTElORV9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWF4aXMtbGluZS1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWNyb3NzLWxpbmVzLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1iYWNrZ3JvdW5kLWNvbG91clwiKTtcbnZhciBERUZBVUxUX1NIQURPV19DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LXNoYWRvdy1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9DT0xPVVJTID0gU3ltYm9sKFwiZGVmYXVsdC1jb2xvdXJzXCIpO1xudmFyIERFRkFVTFRfUEFERElORyA9IFN5bWJvbChcImRlZmF1bHQtcGFkZGluZ1wiKTtcbnZhciBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFID0gU3ltYm9sKFwiZGVmYXVsdC1jYXB0aW9uLWxheW91dC1zdHlsZVwiKTtcbnZhciBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UID0gU3ltYm9sKFwiZGVmYXVsdC1jYXB0aW9uLWFsaWdubWVudFwiKTtcbnZhciBQQUxFVFRFX1VQX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtdXAtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfRE9XTl9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWRvd24tc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfVVBfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtdXAtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0RPV05fRklMTCA9IFN5bWJvbChcInBhbGV0dGUtZG93bi1maWxsXCIpO1xudmFyIFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLW5ldXRyYWwtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfTkVVVFJBTF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1uZXV0cmFsLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfVVBfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtdXAtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfQUxUX0RPV05fU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtZG93bi1zdHJva2VcIik7XG52YXIgUEFMRVRURV9BTFRfVVBfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtYWx0LXVwLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfRE9XTl9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtZG93bi1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtZ3JheS1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1ncmF5LXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LXBvbGFyLXNlcmllcy1zdHJva2VcIik7XG52YXIgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSA9IFN5bWJvbChcbiAgXCJkZWZhdWx0LWRpdmVyZ2luZy1zZXJpZXMtY29sb3VyLXJhbmdlXCJcbik7XG52YXIgREVGQVVMVF9ISUVSQVJDSFlfRklMTFMgPSBTeW1ib2woXCJkZWZhdWx0LWhpZXJhcmNoeS1maWxsc1wiKTtcbnZhciBERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTID0gU3ltYm9sKFwiZGVmYXVsdC1oaWVyYXJjaHktc3Ryb2tlc1wiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0LWFubm90YXRpb24tY29sb3JcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1iYWNrZ3JvdW5kLWZpbGxcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLWhhbmRsZS1maWxsXCIpO1xudmFyIERFRkFVTFRfVEVYVEJPWF9GSUxMID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0Ym94LWZpbGxcIik7XG52YXIgREVGQVVMVF9URVhUQk9YX1NUUk9LRSA9IFN5bWJvbChcImRlZmF1bHQtdGV4dGJveC1zdHJva2VcIik7XG52YXIgREVGQVVMVF9URVhUQk9YX0NPTE9SID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0Ym94LWNvbG9yXCIpO1xudmFyIERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiA9IFN5bWJvbChcImRlZmF1bHQtdG9vbGJhci1wb3NpdGlvblwiKTtcbnZhciBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgPSBTeW1ib2woXCJkZWZhdWx0LWdyaWRsaW5lLWVuYWJsZWRcIik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9wYXRoTW90aW9uLnRzXG5mdW5jdGlvbiBwYXRoTW90aW9uKGdyb3VwSWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBwYXRocywgZm5zKSB7XG4gIGNvbnN0IHsgYWRkUGhhc2VGbiwgdXBkYXRlUGhhc2VGbiwgcmVtb3ZlUGhhc2VGbiB9ID0gZm5zO1xuICBjb25zdCBhbmltYXRlID0gKHBoYXNlLCBwYXRoLCB1cGRhdGVGbikgPT4ge1xuICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1fJHtwYXRoLmlkfV8ke3BoYXNlfWAsXG4gICAgICBncm91cElkLFxuICAgICAgZnJvbTogMCxcbiAgICAgIHRvOiAxLFxuICAgICAgZWFzZTogZWFzZU91dCxcbiAgICAgIGNvbGxhcHNhYmxlOiBmYWxzZSxcbiAgICAgIG9uVXBkYXRlKHJhdGlvMiwgcHJlSW5pdCkge1xuICAgICAgICBpZiAocHJlSW5pdCAmJiBwaGFzZSAhPT0gXCJyZW1vdmVkXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXRoLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICAgIHVwZGF0ZUZuKHJhdGlvMiwgcGF0aCk7XG4gICAgICAgIHBhdGguY2hlY2tQYXRoRGlydHkoKTtcbiAgICAgIH0sXG4gICAgICBvblN0b3AoKSB7XG4gICAgICAgIGlmIChwaGFzZSAhPT0gXCJhZGRlZFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF0aC5wYXRoLmNsZWFyKHRydWUpO1xuICAgICAgICB1cGRhdGVGbigxLCBwYXRoKTtcbiAgICAgICAgcGF0aC5jaGVja1BhdGhEaXJ0eSgpO1xuICAgICAgfSxcbiAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3BoYXNlXVxuICAgIH0pO1xuICB9O1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAoIWFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgIGFuaW1hdGUoXCJyZW1vdmVkXCIsIHBhdGgsIHJlbW92ZVBoYXNlRm4pO1xuICAgICAgYW5pbWF0ZShcInVwZGF0ZWRcIiwgcGF0aCwgdXBkYXRlUGhhc2VGbik7XG4gICAgfVxuICAgIGFuaW1hdGUoXCJhZGRlZFwiLCBwYXRoLCBhZGRQaGFzZUZuKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Nhbml0aXplLnRzXG52YXIgZWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodGV4dCkge1xuICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRleHQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBlbGVtZW50ID8/IChlbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSBTdHJpbmcodGV4dCk7XG4gIHJldHVybiBlbGVtZW50LmlubmVySFRNTDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0xhYmVsVXRpbC50c1xuZnVuY3Rpb24gc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubGFiZWxTZWxlY3Rpb25zKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICBpZCxcbiAgICBzdWJJZCxcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIGxhYmVsU2VsZWN0aW9ucyxcbiAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICB7IHBoYXNlOiBcInRyYWlsaW5nXCIgfVxuICApO1xufVxuZnVuY3Rpb24gc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmxhYmVsU2VsZWN0aW9ucykge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgc3ViSWQsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBsYWJlbFNlbGVjdGlvbnMsXG4gICAgeyBvcGFjaXR5OiAxIH0sXG4gICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgeyBwaGFzZTogXCJyZW1vdmVcIiB9XG4gICk7XG59XG5mdW5jdGlvbiByZXNldExhYmVsRm4oX25vZGUpIHtcbiAgcmV0dXJuIHsgb3BhY2l0eTogMSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2NoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzLnRzXG52YXIgQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLl9kaXJ0eSA9IDMgLyogTUFKT1IgKi87XG4gIH1cbiAgbWFya0RpcnR5KF9zb3VyY2UsIHR5cGUgPSAxIC8qIFRSSVZJQUwgKi8pIHtcbiAgICBpZiAodGhpcy5fZGlydHkgPCB0eXBlKSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IHR5cGU7XG4gICAgfVxuICB9XG4gIG1hcmtDbGVhbihfb3B0cykge1xuICAgIHRoaXMuX2RpcnR5ID0gMCAvKiBOT05FICovO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5ID4gMCAvKiBOT05FICovO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9kcm9wU2hhZG93LnRzXG52YXIgRHJvcFNoYWRvdyA9IGNsYXNzIGV4dGVuZHMgQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5jb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwLjUpXCI7XG4gICAgdGhpcy54T2Zmc2V0ID0gMDtcbiAgICB0aGlzLnlPZmZzZXQgPSAwO1xuICAgIHRoaXMuYmx1ciA9IDU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwieE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJ5T2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcImJsdXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNNYXJrZXIudHNcbnZhciBNQVJLRVJfU0hBUEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlKSA9PiBpc01hcmtlclNoYXBlKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiBPYmplY3QuY3JlYXRlKHZhbHVlLnByb3RvdHlwZSkgaW5zdGFuY2VvZiBNYXJrZXIsXG4gIGBhIG1hcmtlciBzaGFwZSBrZXl3b3JkIHN1Y2ggYXMgJ2NpcmNsZScsICdkaWFtb25kJyBvciAnc3F1YXJlJyBvciBhbiBvYmplY3QgZXh0ZW5kaW5nIHRoZSBNYXJrZXIgY2xhc3NgXG4pO1xudmFyIFNlcmllc01hcmtlciA9IGNsYXNzIGV4dGVuZHMgQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zaGFwZSA9IENpcmNsZTtcbiAgICB0aGlzLnNpemUgPSA2O1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gIH1cbiAgZ2V0U3R5bGUoKSB7XG4gICAgY29uc3QgeyBzaXplLCBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH07XG4gIH1cbiAgZ2V0RGlhbWV0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSArIHRoaXMuc3Ryb2tlV2lkdGg7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1BUktFUl9TSEFQRSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNUb29sdGlwLnRzXG52YXIgU2VyaWVzVG9vbHRpcEludGVyYWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzVG9vbHRpcEludGVyYWN0aW9uLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIFNlcmllc1Rvb2x0aXAgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBuZXcgU2VyaWVzVG9vbHRpcEludGVyYWN0aW9uKCk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBUb29sdGlwUG9zaXRpb24oKTtcbiAgICB0aGlzLnJhbmdlID0gdm9pZCAwO1xuICB9XG4gIHRvVG9vbHRpcEh0bWwoZGVmYXVsdHMsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdG9Ub29sdGlwSHRtbCh0aGlzLnJlbmRlcmVyKHBhcmFtcyksIGRlZmF1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvVG9vbHRpcEh0bWwoZGVmYXVsdHMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJzaG93QXJyb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJpbnRlcmFjdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJBQ1RJT05fUkFOR0UsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2ludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnRzXG52YXIgSU5URVJQT0xBVElPTl9UWVBFID0gVU5JT04oW1wibGluZWFyXCIsIFwic21vb3RoXCIsIFwic3RlcFwiXSwgXCJhIGxpbmUgc3R5bGVcIik7XG52YXIgSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OID0gVU5JT04oW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xudmFyIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJsaW5lYXJcIjtcbiAgICB0aGlzLnRlbnNpb24gPSAxO1xuICAgIHRoaXMucG9zaXRpb24gPSBcImVuZFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJQT0xBVElPTl9UWVBFKVxuXSwgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0ZW5zaW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OKVxuXSwgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgQXJlYVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMueE5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5maWxsID0gXCIjYzE2MDY4XCI7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2UgPSBcIiM4NzQzNDlcIjtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gbmV3IEludGVycG9sYXRpb25Qcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMubWFya2VyID0gbmV3IFNlcmllc01hcmtlcigpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIHRoaXMuY29ubmVjdE1pc3NpbmdEYXRhID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRUb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbnRlcnBvbGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ubmVjdE1pc3NpbmdEYXRhXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2Jlemllci50c1xuZnVuY3Rpb24gZXZhbHVhdGVCZXppZXIocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiogMyAqIHAwICsgMyAqICgxIC0gdCkgKiogMiAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICsgdCAqKiAyICogcDIgKyB0ICoqIDMgKiBwMztcbn1cbmZ1bmN0aW9uIHNvbHZlQmV6aWVyKHAwLCBwMSwgcDIsIHAzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPD0gTWF0aC5taW4ocDAsIHAzKSkge1xuICAgIHJldHVybiBwMCA8IHAzID8gMCA6IDE7XG4gIH0gZWxzZSBpZiAodmFsdWUgPj0gTWF0aC5tYXgocDAsIHAzKSkge1xuICAgIHJldHVybiBwMCA8IHAzID8gMSA6IDA7XG4gIH1cbiAgbGV0IHQwID0gMDtcbiAgbGV0IHQxID0gMTtcbiAgbGV0IHQgPSBOYU47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgdCA9ICh0MCArIHQxKSAvIDI7XG4gICAgY29uc3QgY3VydmVWYWx1ZSA9ICgxIC0gdCkgKiogMyAqIHAwICsgMyAqICgxIC0gdCkgKiogMiAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogdCAqKiAyICogcDIgKyB0ICoqIDMgKiBwMztcbiAgICBpZiAoY3VydmVWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICB0MCA9IHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQxID0gdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBzcGxpdEJlemllcihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgdCkge1xuICBjb25zdCB4MDEgPSAoMSAtIHQpICogcDB4ICsgdCAqIHAxeDtcbiAgY29uc3QgeTAxID0gKDEgLSB0KSAqIHAweSArIHQgKiBwMXk7XG4gIGNvbnN0IHgxMiA9ICgxIC0gdCkgKiBwMXggKyB0ICogcDJ4O1xuICBjb25zdCB5MTIgPSAoMSAtIHQpICogcDF5ICsgdCAqIHAyeTtcbiAgY29uc3QgeDIzID0gKDEgLSB0KSAqIHAyeCArIHQgKiBwM3g7XG4gIGNvbnN0IHkyMyA9ICgxIC0gdCkgKiBwMnkgKyB0ICogcDN5O1xuICBjb25zdCB4MDEyID0gKDEgLSB0KSAqIHgwMSArIHQgKiB4MTI7XG4gIGNvbnN0IHkwMTIgPSAoMSAtIHQpICogeTAxICsgdCAqIHkxMjtcbiAgY29uc3QgeDEyMyA9ICgxIC0gdCkgKiB4MTIgKyB0ICogeDIzO1xuICBjb25zdCB5MTIzID0gKDEgLSB0KSAqIHkxMiArIHQgKiB5MjM7XG4gIGNvbnN0IHgwMTIzID0gKDEgLSB0KSAqIHgwMTIgKyB0ICogeDEyMztcbiAgY29uc3QgeTAxMjMgPSAoMSAtIHQpICogeTAxMiArIHQgKiB5MTIzO1xuICByZXR1cm4gW1xuICAgIFtcbiAgICAgIHsgeDogcDB4LCB5OiBwMHkgfSxcbiAgICAgIHsgeDogeDAxLCB5OiB5MDEgfSxcbiAgICAgIHsgeDogeDAxMiwgeTogeTAxMiB9LFxuICAgICAgeyB4OiB4MDEyMywgeTogeTAxMjMgfVxuICAgIF0sXG4gICAgW1xuICAgICAgeyB4OiB4MDEyMywgeTogeTAxMjMgfSxcbiAgICAgIHsgeDogeDEyMywgeTogeTEyMyB9LFxuICAgICAgeyB4OiB4MjMsIHk6IHkyMyB9LFxuICAgICAgeyB4OiBwM3gsIHk6IHAzeSB9XG4gICAgXVxuICBdO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVJbnRlcnBvbGF0aW9uLnRzXG5mdW5jdGlvbiBzcGFuUmFuZ2Uoc3Bhbikge1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB4OiBzcGFuLngwLCB5OiBzcGFuLnkwIH0sXG4gICAgICAgIHsgeDogc3Bhbi54MSwgeTogc3Bhbi55MSB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB4OiBzcGFuLmNwMHgsIHk6IHNwYW4uY3AweSB9LFxuICAgICAgICB7IHg6IHNwYW4uY3AzeCwgeTogc3Bhbi5jcDN5IH1cbiAgICAgIF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2VTcGFuKHNwYW4pIHtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogc3Bhbi54MSxcbiAgICAgICAgeTA6IHNwYW4ueTEsXG4gICAgICAgIHgxOiBzcGFuLngwLFxuICAgICAgICB5MTogc3Bhbi55MFxuICAgICAgfTtcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgY3AweDogc3Bhbi5jcDN4LFxuICAgICAgICBjcDB5OiBzcGFuLmNwM3ksXG4gICAgICAgIGNwMXg6IHNwYW4uY3AyeCxcbiAgICAgICAgY3AxeTogc3Bhbi5jcDJ5LFxuICAgICAgICBjcDJ4OiBzcGFuLmNwMXgsXG4gICAgICAgIGNwMnk6IHNwYW4uY3AxeSxcbiAgICAgICAgY3AzeDogc3Bhbi5jcDB4LFxuICAgICAgICBjcDN5OiBzcGFuLmNwMHlcbiAgICAgIH07XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RlcFwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogc3Bhbi54MSxcbiAgICAgICAgeTA6IHNwYW4ueTEsXG4gICAgICAgIHgxOiBzcGFuLngwLFxuICAgICAgICB5MTogc3Bhbi55MCxcbiAgICAgICAgc3RlcFg6IHNwYW4uc3RlcFhcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxhcHNlU3BhblRvUG9pbnQoc3BhbiwgcG9pbnQpIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogeCxcbiAgICAgICAgeTA6IHksXG4gICAgICAgIHgxOiB4LFxuICAgICAgICB5MTogeVxuICAgICAgfTtcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdGVwXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiB4LFxuICAgICAgICB5MDogeSxcbiAgICAgICAgeDE6IHgsXG4gICAgICAgIHkxOiB5LFxuICAgICAgICBzdGVwWDogeFxuICAgICAgfTtcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgY3AweDogeCxcbiAgICAgICAgY3AweTogeSxcbiAgICAgICAgY3AxeDogeCxcbiAgICAgICAgY3AxeTogeSxcbiAgICAgICAgY3AyeDogeCxcbiAgICAgICAgY3AyeTogeSxcbiAgICAgICAgY3AzeDogeCxcbiAgICAgICAgY3AzeTogeVxuICAgICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzY2FsZVNwYW4oc3BhbiwgbmV4dFN0YXJ0LCBuZXh0RW5kKSB7XG4gIGNvbnN0IFtwcmV2U3RhcnQsIHByZXZFbmRdID0gc3BhblJhbmdlKHNwYW4pO1xuICBjb25zdCB3aWR0aFNjYWxlID0gcHJldkVuZC54ICE9PSBwcmV2U3RhcnQueCA/IChuZXh0RW5kLnggLSBuZXh0U3RhcnQueCkgLyAocHJldkVuZC54IC0gcHJldlN0YXJ0LngpIDogMDtcbiAgY29uc3QgaGVpZ2h0U2NhbGUgPSBwcmV2RW5kLnkgIT09IHByZXZTdGFydC55ID8gKG5leHRFbmQueSAtIG5leHRTdGFydC55KSAvIChwcmV2RW5kLnkgLSBwcmV2U3RhcnQueSkgOiAwO1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiBuZXh0U3RhcnQueCxcbiAgICAgICAgeTA6IG5leHRTdGFydC55LFxuICAgICAgICB4MTogbmV4dEVuZC54LFxuICAgICAgICB5MTogbmV4dEVuZC55XG4gICAgICB9O1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICBjcDB4OiBuZXh0U3RhcnQueCxcbiAgICAgICAgY3AweTogbmV4dFN0YXJ0LnksXG4gICAgICAgIGNwMXg6IG5leHRFbmQueCAtIChzcGFuLmNwMnggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlLFxuICAgICAgICBjcDF5OiBuZXh0RW5kLnkgLSAoc3Bhbi5jcDJ5IC0gcHJldlN0YXJ0LnkpICogaGVpZ2h0U2NhbGUsXG4gICAgICAgIGNwMng6IG5leHRFbmQueCAtIChzcGFuLmNwMXggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlLFxuICAgICAgICBjcDJ5OiBuZXh0RW5kLnkgLSAoc3Bhbi5jcDF5IC0gcHJldlN0YXJ0LnkpICogaGVpZ2h0U2NhbGUsXG4gICAgICAgIGNwM3g6IG5leHRFbmQueCxcbiAgICAgICAgY3AzeTogbmV4dEVuZC55XG4gICAgICB9O1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0ZXBcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IG5leHRTdGFydC54LFxuICAgICAgICB5MDogbmV4dFN0YXJ0LnksXG4gICAgICAgIHgxOiBuZXh0RW5kLngsXG4gICAgICAgIHkxOiBuZXh0RW5kLnksXG4gICAgICAgIHN0ZXBYOiBuZXh0RW5kLnggLSAoc3Bhbi5zdGVwWCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGVcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNldE1vdmVUbyhzcGFuLCBtb3ZlVG8pIHtcbiAgcmV0dXJuIHNwYW4ubW92ZVRvICE9PSBtb3ZlVG8gPyB7IC4uLnNwYW4sIG1vdmVUbyB9IDogc3Bhbjtcbn1cbmZ1bmN0aW9uIHNwbGl0U3BhbkF0WChzcGFuLCB4KSB7XG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9IHNwYW5SYW5nZShzcGFuKTtcbiAgbGV0IHgwO1xuICBsZXQgeTA7XG4gIGxldCB4MTtcbiAgbGV0IHkxO1xuICBpZiAoc3RhcnQueCA8IGVuZC54KSB7XG4gICAgeDAgPSBzdGFydC54O1xuICAgIHkwID0gc3RhcnQueTtcbiAgICB4MSA9IGVuZC54O1xuICAgIHkxID0gZW5kLnk7XG4gIH0gZWxzZSB7XG4gICAgeDAgPSBlbmQueDtcbiAgICB5MCA9IGVuZC55O1xuICAgIHgxID0gc3RhcnQueDtcbiAgICB5MSA9IHN0YXJ0Lnk7XG4gIH1cbiAgaWYgKHggPCB4MCkge1xuICAgIHJldHVybiBbcmVzY2FsZVNwYW4oc3Bhbiwgc3RhcnQsIHN0YXJ0KSwgc2V0TW92ZVRvKHNwYW4sIGZhbHNlKV07XG4gIH0gZWxzZSBpZiAoeCA+IHgxKSB7XG4gICAgcmV0dXJuIFtzcGFuLCBzZXRNb3ZlVG8ocmVzY2FsZVNwYW4oc3BhbiwgZW5kLCBlbmQpLCBmYWxzZSldO1xuICB9XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOiB7XG4gICAgICBjb25zdCBtaWRZID0geTAgPT09IHkxID8geTAgOiAoeTEgLSB5MCkgLyAoeDEgLSB4MCkgKiAoeCAtIHgwKSArIHkwO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBcImxpbmVhclwiLCBtb3ZlVG86IHNwYW4ubW92ZVRvLCB4MCwgeTAsIHgxOiB4LCB5MTogbWlkWSB9LFxuICAgICAgICB7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbzogZmFsc2UsIHgwOiB4LCB5MDogbWlkWSwgeDEsIHkxIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBpZiAoeCA8IHNwYW4uc3RlcFgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG86IHNwYW4ubW92ZVRvLCB4MCwgeTAsIHgxOiB4LCB5MTogeTAsIHN0ZXBYOiB4IH0sXG4gICAgICAgICAgeyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvOiBmYWxzZSwgeDA6IHgsIHkwLCB4MSwgeTEsIHN0ZXBYOiBzcGFuLnN0ZXBYIH1cbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgeyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvOiBzcGFuLm1vdmVUbywgeDAsIHkwLCB4MTogeCwgeTEsIHN0ZXBYOiBzcGFuLnN0ZXBYIH0sXG4gICAgICAgICAgeyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvOiBmYWxzZSwgeDA6IHgsIHkwOiB5MSwgeDEsIHkxLCBzdGVwWDogeCB9XG4gICAgICAgIF07XG4gICAgICB9XG4gICAgY2FzZSBcImN1YmljXCI6IHtcbiAgICAgIGNvbnN0IHQgPSBzb2x2ZUJlemllcihzcGFuLmNwMHgsIHNwYW4uY3AxeCwgc3Bhbi5jcDJ4LCBzcGFuLmNwM3gsIHgpO1xuICAgICAgY29uc3QgW2EsIGJdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIHNwYW4uY3AweCxcbiAgICAgICAgc3Bhbi5jcDB5LFxuICAgICAgICBzcGFuLmNwMXgsXG4gICAgICAgIHNwYW4uY3AxeSxcbiAgICAgICAgc3Bhbi5jcDJ4LFxuICAgICAgICBzcGFuLmNwMnksXG4gICAgICAgIHNwYW4uY3AzeCxcbiAgICAgICAgc3Bhbi5jcDN5LFxuICAgICAgICB0XG4gICAgICApO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICAgIGNwMHg6IGFbMF0ueCxcbiAgICAgICAgICBjcDB5OiBhWzBdLnksXG4gICAgICAgICAgY3AxeDogYVsxXS54LFxuICAgICAgICAgIGNwMXk6IGFbMV0ueSxcbiAgICAgICAgICBjcDJ4OiBhWzJdLngsXG4gICAgICAgICAgY3AyeTogYVsyXS55LFxuICAgICAgICAgIGNwM3g6IGFbM10ueCxcbiAgICAgICAgICBjcDN5OiBhWzNdLnlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgICBtb3ZlVG86IGZhbHNlLFxuICAgICAgICAgIGNwMHg6IGJbMF0ueCxcbiAgICAgICAgICBjcDB5OiBiWzBdLnksXG4gICAgICAgICAgY3AxeDogYlsxXS54LFxuICAgICAgICAgIGNwMXk6IGJbMV0ueSxcbiAgICAgICAgICBjcDJ4OiBiWzJdLngsXG4gICAgICAgICAgY3AyeTogYlsyXS55LFxuICAgICAgICAgIGNwM3g6IGJbM10ueCxcbiAgICAgICAgICBjcDN5OiBiWzNdLnlcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBTcGFuWChzcGFuLCB4MCwgeDEpIHtcbiAgY29uc3QgeyBtb3ZlVG8gfSA9IHNwYW47XG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9IHNwYW5SYW5nZShzcGFuKTtcbiAgbGV0IHNwYW5YMDtcbiAgbGV0IHNwYW5ZMDtcbiAgbGV0IHNwYW5YMTtcbiAgbGV0IHNwYW5ZMTtcbiAgaWYgKHN0YXJ0LnggPCBlbmQueCkge1xuICAgIHNwYW5YMCA9IHN0YXJ0Lng7XG4gICAgc3BhblkwID0gc3RhcnQueTtcbiAgICBzcGFuWDEgPSBlbmQueDtcbiAgICBzcGFuWTEgPSBlbmQueTtcbiAgfSBlbHNlIHtcbiAgICBzcGFuWDAgPSBlbmQueDtcbiAgICBzcGFuWTAgPSBlbmQueTtcbiAgICBzcGFuWDEgPSBzdGFydC54O1xuICAgIHNwYW5ZMSA9IHN0YXJ0Lnk7XG4gIH1cbiAgaWYgKHgxIDwgc3BhblgwKSB7XG4gICAgcmV0dXJuIHJlc2NhbGVTcGFuKHNwYW4sIHN0YXJ0LCBzdGFydCk7XG4gIH0gZWxzZSBpZiAoeDAgPiBzcGFuWDEpIHtcbiAgICByZXR1cm4gcmVzY2FsZVNwYW4oc3BhbiwgZW5kLCBlbmQpO1xuICB9XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOiB7XG4gICAgICBjb25zdCBtID0gc3BhblkwID09PSBzcGFuWTEgPyB2b2lkIDAgOiAoc3BhblkxIC0gc3BhblkwKSAvIChzcGFuWDEgLSBzcGFuWDApO1xuICAgICAgY29uc3QgeTAgPSBtID09IG51bGwgPyBzcGFuWTAgOiBtICogKHgwIC0gc3BhblgwKSArIHNwYW5ZMDtcbiAgICAgIGNvbnN0IHkxID0gbSA9PSBudWxsID8gc3BhblkwIDogbSAqICh4MSAtIHNwYW5YMCkgKyBzcGFuWTA7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxpbmVhclwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxIH07XG4gICAgfVxuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBpZiAoeDEgPD0gc3Bhbi5zdGVwWCkge1xuICAgICAgICBjb25zdCB5ID0gc3Bhbi55MDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwOiB5LCB4MSwgeTE6IHksIHN0ZXBYOiB4MSB9O1xuICAgICAgfSBlbHNlIGlmICh4MCA+PSBzcGFuLnN0ZXBYKSB7XG4gICAgICAgIGNvbnN0IHkgPSBzcGFuLnkxO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTA6IHksIHgxLCB5MTogeSwgc3RlcFg6IHgwIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHkwLCB5MSwgc3RlcFggfSA9IHNwYW47XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJjdWJpY1wiOiB7XG4gICAgICBjb25zdCB0MCA9IHNvbHZlQmV6aWVyKHNwYW4uY3AweCwgc3Bhbi5jcDF4LCBzcGFuLmNwMngsIHNwYW4uY3AzeCwgeDApO1xuICAgICAgbGV0IFtfdW51c2VkLCBiZXppZXJdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIHNwYW4uY3AweCxcbiAgICAgICAgc3Bhbi5jcDB5LFxuICAgICAgICBzcGFuLmNwMXgsXG4gICAgICAgIHNwYW4uY3AxeSxcbiAgICAgICAgc3Bhbi5jcDJ4LFxuICAgICAgICBzcGFuLmNwMnksXG4gICAgICAgIHNwYW4uY3AzeCxcbiAgICAgICAgc3Bhbi5jcDN5LFxuICAgICAgICB0MFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQxID0gc29sdmVCZXppZXIoYmV6aWVyWzBdLngsIGJlemllclsxXS54LCBiZXppZXJbMl0ueCwgYmV6aWVyWzNdLngsIHgxKTtcbiAgICAgIFtiZXppZXIsIF91bnVzZWRdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIGJlemllclswXS54LFxuICAgICAgICBiZXppZXJbMF0ueSxcbiAgICAgICAgYmV6aWVyWzFdLngsXG4gICAgICAgIGJlemllclsxXS55LFxuICAgICAgICBiZXppZXJbMl0ueCxcbiAgICAgICAgYmV6aWVyWzJdLnksXG4gICAgICAgIGJlemllclszXS54LFxuICAgICAgICBiZXppZXJbM10ueSxcbiAgICAgICAgdDFcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbyxcbiAgICAgICAgY3AweDogYmV6aWVyWzBdLngsXG4gICAgICAgIGNwMHk6IGJlemllclswXS55LFxuICAgICAgICBjcDF4OiBiZXppZXJbMV0ueCxcbiAgICAgICAgY3AxeTogYmV6aWVyWzFdLnksXG4gICAgICAgIGNwMng6IGJlemllclsyXS54LFxuICAgICAgICBjcDJ5OiBiZXppZXJbMl0ueSxcbiAgICAgICAgY3AzeDogYmV6aWVyWzNdLngsXG4gICAgICAgIGNwM3k6IGJlemllclszXS55XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVTcGFucyhhLCBiLCByYXRpbzIpIHtcbiAgaWYgKGEudHlwZSA9PT0gXCJjdWJpY1wiICYmIGIudHlwZSA9PT0gXCJjdWJpY1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgIG1vdmVUbzogYS5tb3ZlVG8sXG4gICAgICBjcDB4OiAoYi5jcDB4IC0gYS5jcDB4KSAqIHJhdGlvMiArIGEuY3AweCxcbiAgICAgIGNwMHk6IChiLmNwMHkgLSBhLmNwMHkpICogcmF0aW8yICsgYS5jcDB5LFxuICAgICAgY3AxeDogKGIuY3AxeCAtIGEuY3AxeCkgKiByYXRpbzIgKyBhLmNwMXgsXG4gICAgICBjcDF5OiAoYi5jcDF5IC0gYS5jcDF5KSAqIHJhdGlvMiArIGEuY3AxeSxcbiAgICAgIGNwMng6IChiLmNwMnggLSBhLmNwMngpICogcmF0aW8yICsgYS5jcDJ4LFxuICAgICAgY3AyeTogKGIuY3AyeSAtIGEuY3AyeSkgKiByYXRpbzIgKyBhLmNwMnksXG4gICAgICBjcDN4OiAoYi5jcDN4IC0gYS5jcDN4KSAqIHJhdGlvMiArIGEuY3AzeCxcbiAgICAgIGNwM3k6IChiLmNwM3kgLSBhLmNwM3kpICogcmF0aW8yICsgYS5jcDN5XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhLnR5cGUgPT09IFwic3RlcFwiICYmIGIudHlwZSA9PT0gXCJzdGVwXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGVwXCIsXG4gICAgICBtb3ZlVG86IGEubW92ZVRvLFxuICAgICAgeDA6IChiLngwIC0gYS54MCkgKiByYXRpbzIgKyBhLngwLFxuICAgICAgeTA6IChiLnkwIC0gYS55MCkgKiByYXRpbzIgKyBhLnkwLFxuICAgICAgeDE6IChiLngxIC0gYS54MSkgKiByYXRpbzIgKyBhLngxLFxuICAgICAgeTE6IChiLnkxIC0gYS55MSkgKiByYXRpbzIgKyBhLnkxLFxuICAgICAgc3RlcFg6IChiLnN0ZXBYIC0gYS5zdGVwWCkgKiByYXRpbzIgKyBhLnN0ZXBYXG4gICAgfTtcbiAgfVxuICBjb25zdCBbYVN0YXJ0LCBhRW5kXSA9IHNwYW5SYW5nZShhKTtcbiAgY29uc3QgW2JTdGFydCwgYkVuZF0gPSBzcGFuUmFuZ2UoYik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICBtb3ZlVG86IGEubW92ZVRvLFxuICAgIHgwOiAoYlN0YXJ0LnggLSBhU3RhcnQueCkgKiByYXRpbzIgKyBhU3RhcnQueCxcbiAgICB5MDogKGJTdGFydC55IC0gYVN0YXJ0LnkpICogcmF0aW8yICsgYVN0YXJ0LnksXG4gICAgeDE6IChiRW5kLnggLSBhRW5kLngpICogcmF0aW8yICsgYUVuZC54LFxuICAgIHkxOiAoYkVuZC55IC0gYUVuZC55KSAqIHJhdGlvMiArIGFFbmQueVxuICB9O1xufVxuZnVuY3Rpb24gcGxvdFNwYW4ocGF0aCwgc3BhbiwgbW92ZVRvID0gc3Bhbi5tb3ZlVG8gPyAxIC8qIE1vdmVUbyAqLyA6IDAgLyogTm9uZSAqLykge1xuICBjb25zdCBbc3RhcnRdID0gc3BhblJhbmdlKHNwYW4pO1xuICBzd2l0Y2ggKG1vdmVUbykge1xuICAgIGNhc2UgMSAvKiBNb3ZlVG8gKi86XG4gICAgICBwYXRoLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMiAvKiBMaW5lVG8gKi86XG4gICAgICBwYXRoLmxpbmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcGF0aC5saW5lVG8oc3Bhbi54MSwgc3Bhbi55MSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKHNwYW4uY3AxeCwgc3Bhbi5jcDF5LCBzcGFuLmNwMngsIHNwYW4uY3AyeSwgc3Bhbi5jcDN4LCBzcGFuLmNwM3kpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHBhdGgubGluZVRvKHNwYW4uc3RlcFgsIHNwYW4ueTApO1xuICAgICAgcGF0aC5saW5lVG8oc3Bhbi5zdGVwWCwgc3Bhbi55MSk7XG4gICAgICBwYXRoLmxpbmVUbyhzcGFuLngxLCBzcGFuLnkxKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBsaW5lYXJQb2ludHMocG9pbnRzKSB7XG4gIGNvbnN0IHNwYW5zID0gW107XG4gIGxldCBpID0gMDtcbiAgbGV0IHgwID0gTmFOO1xuICBsZXQgeTAgPSBOYU47XG4gIGZvciAoY29uc3QgeyB4OiB4MSwgeTogeTEgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNvbnN0IG1vdmVUbyA9IGkgPT09IDE7XG4gICAgICBzcGFucy5wdXNoKHsgdHlwZTogXCJsaW5lYXJcIiwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSB9KTtcbiAgICB9XG4gICAgaSArPSAxO1xuICAgIHgwID0geDE7XG4gICAgeTAgPSB5MTtcbiAgfVxuICByZXR1cm4gc3BhbnM7XG59XG52YXIgbGluZVN0ZXBzID0ge1xuICBzdGFydDogMCxcbiAgbWlkZGxlOiAwLjUsXG4gIGVuZDogMVxufTtcbmZ1bmN0aW9uIHN0ZXBQb2ludHMocG9pbnRzLCBwb3NpdGlvbikge1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCB4MCA9IE5hTjtcbiAgbGV0IHkwID0gTmFOO1xuICBjb25zdCBwMCA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJudW1iZXJcIiA/IHBvc2l0aW9uIDogbGluZVN0ZXBzW3Bvc2l0aW9uXTtcbiAgZm9yIChjb25zdCB7IHg6IHgxLCB5OiB5MSB9IG9mIHBvaW50cykge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgY29uc3QgbW92ZVRvID0gaSA9PT0gMTtcbiAgICAgIGNvbnN0IHN0ZXBYID0geDAgKyAoeDEgLSB4MCkgKiBwMDtcbiAgICAgIHNwYW5zLnB1c2goeyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSwgc3RlcFggfSk7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgICB4MCA9IHgxO1xuICAgIHkwID0geTE7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxudmFyIGZsYXRuZXNzUmF0aW8gPSAwLjA1O1xuZnVuY3Rpb24gc21vb3RoUG9pbnRzKGlQb2ludHMsIHRlbnNpb24pIHtcbiAgY29uc3QgcG9pbnRzID0gQXJyYXkuaXNBcnJheShpUG9pbnRzKSA/IGlQb2ludHMgOiBBcnJheS5mcm9tKGlQb2ludHMpO1xuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgZ3JhZGllbnRzID0gcG9pbnRzLm1hcCgoYywgaSkgPT4ge1xuICAgIGNvbnN0IHAgPSBpID09PSAwID8gYyA6IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgbiA9IGkgPT09IHBvaW50cy5sZW5ndGggLSAxID8gYyA6IHBvaW50c1tpICsgMV07XG4gICAgY29uc3QgaXNUZXJtaW5hbFBvaW50ID0gaSA9PT0gMCB8fCBpID09PSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoTWF0aC5zaWduKHAueSAtIGMueSkgPT09IE1hdGguc2lnbihuLnkgLSBjLnkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCFpc1Rlcm1pbmFsUG9pbnQpIHtcbiAgICAgIGNvbnN0IHJhbmdlMyA9IE1hdGguYWJzKHAueSAtIG4ueSk7XG4gICAgICBjb25zdCBwcmV2UmF0aW8gPSBNYXRoLmFicyhjLnkgLSBwLnkpIC8gcmFuZ2UzO1xuICAgICAgY29uc3QgbmV4dFJhdGlvID0gTWF0aC5hYnMoYy55IC0gbi55KSAvIHJhbmdlMztcbiAgICAgIGlmIChwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbyB8fCAxIC0gcHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgbmV4dFJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgMSAtIG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKG4ueSAtIHAueSkgLyAobi54IC0gcC54KTtcbiAgfSk7XG4gIGlmIChncmFkaWVudHNbMV0gPT09IDApIHtcbiAgICBncmFkaWVudHNbMF0gKj0gMjtcbiAgfVxuICBpZiAoZ3JhZGllbnRzW2dyYWRpZW50cy5sZW5ndGggLSAyXSA9PT0gMCkge1xuICAgIGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMV0gKj0gMjtcbiAgfVxuICBjb25zdCBzcGFucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXYgPSBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IHByZXZNID0gZ3JhZGllbnRzW2kgLSAxXTtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbaV07XG4gICAgY29uc3QgY3VyTSA9IGdyYWRpZW50c1tpXTtcbiAgICBjb25zdCBkeCA9IGN1ci54IC0gcHJldi54O1xuICAgIGNvbnN0IGR5ID0gY3VyLnkgLSBwcmV2Lnk7XG4gICAgbGV0IGRjcDF4ID0gZHggKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMXkgPSBkeCAqIHByZXZNICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ4ID0gZHggKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMnkgPSBkeCAqIGN1ck0gKiB0ZW5zaW9uIC8gMztcbiAgICBpZiAoY3VyTSA9PT0gMCAmJiBNYXRoLmFicyhkY3AxeSkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGRjcDF4ICo9IE1hdGguYWJzKGR5IC8gZGNwMXkpO1xuICAgICAgZGNwMXkgPSBNYXRoLnNpZ24oZGNwMXkpICogTWF0aC5hYnMoZHkpO1xuICAgIH1cbiAgICBpZiAocHJldk0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMnkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AyeCAqPSBNYXRoLmFicyhkeSAvIGRjcDJ5KTtcbiAgICAgIGRjcDJ5ID0gTWF0aC5zaWduKGRjcDJ5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgc3BhbnMucHVzaCh7XG4gICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICBtb3ZlVG86IGkgPT09IDEsXG4gICAgICBjcDB4OiBwcmV2LngsXG4gICAgICBjcDB5OiBwcmV2LnksXG4gICAgICBjcDF4OiBwcmV2LnggKyBkY3AxeCxcbiAgICAgIGNwMXk6IHByZXYueSArIGRjcDF5LFxuICAgICAgY3AyeDogY3VyLnggLSBkY3AyeCxcbiAgICAgIGNwMnk6IGN1ci55IC0gZGNwMnksXG4gICAgICBjcDN4OiBjdXIueCxcbiAgICAgIGNwM3k6IGN1ci55XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL21hcmtlclV0aWwudHNcbmZ1bmN0aW9uIG1hcmtlckZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIHN0YXR1cywgLi4ubWFya2VyU2VsZWN0aW9ucykge1xuICBjb25zdCBwYXJhbXMgPSB7IHBoYXNlOiBzdGF0dXMgPyBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c10gOiBcInRyYWlsaW5nXCIgfTtcbiAgc3RhdGljRnJvbVRvTW90aW9uKGlkLCBcIm1hcmtlcnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9LCBwYXJhbXMpO1xuICBtYXJrZXJTZWxlY3Rpb25zLmZvckVhY2goKHMpID0+IHMuY2xlYW51cCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtlclNjYWxlSW5BbmltYXRpb24oeyBpZCB9LCBhbmltYXRpb25NYW5hZ2VyLCAuLi5tYXJrZXJTZWxlY3Rpb25zKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICBpZCxcbiAgICBcIm1hcmtlcnNcIixcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIG1hcmtlclNlbGVjdGlvbnMsXG4gICAgeyBzY2FsaW5nWDogMCwgc2NhbGluZ1k6IDAgfSxcbiAgICB7IHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9LFxuICAgIHsgcGhhc2U6IFwiaW5pdGlhbFwiIH1cbiAgKTtcbiAgbWFya2VyU2VsZWN0aW9ucy5mb3JFYWNoKChzKSA9PiBzLmNsZWFudXAoKSk7XG59XG5mdW5jdGlvbiBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24oeyBpZCwgbm9kZURhdGFEZXBlbmRlbmNpZXMgfSwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubWFya2VyU2VsZWN0aW9ucykge1xuICBjb25zdCBzZXJpZXNXaWR0aCA9IG5vZGVEYXRhRGVwZW5kZW5jaWVzLnNlcmllc1JlY3RXaWR0aDtcbiAgY29uc3QgZnJvbUZuID0gKF8sIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeCA9IGRhdHVtLm1pZFBvaW50Py54ID8/IHNlcmllc1dpZHRoO1xuICAgIGxldCBkZWxheSA9IGNsYW1wKDAsIGludmVyc2VFYXNlT3V0KHggLyBzZXJpZXNXaWR0aCksIDEpO1xuICAgIGlmIChpc05hTihkZWxheSkpIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2NhbGluZ1g6IDAsIHNjYWxpbmdZOiAwLCBkZWxheSwgZHVyYXRpb246IFFVSUNLX1RSQU5TSVRJT04sIHBoYXNlOiBcImluaXRpYWxcIiB9O1xuICB9O1xuICBjb25zdCB0b0ZuID0gKCkgPT4ge1xuICAgIHJldHVybiB7IHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9O1xuICB9O1xuICBmcm9tVG9Nb3Rpb24oaWQsIFwibWFya2Vyc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zLCB7IGZyb21GbiwgdG9GbiB9KTtcbn1cbmZ1bmN0aW9uIHJlc2V0TWFya2VyRm4oX25vZGUpIHtcbiAgcmV0dXJuIHsgb3BhY2l0eTogMSwgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH07XG59XG5mdW5jdGlvbiByZXNldE1hcmtlclBvc2l0aW9uRm4oX25vZGUsIGRhdHVtKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRpb25YOiBkYXR1bS5wb2ludD8ueCA/PyBOYU4sXG4gICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5wb2ludD8ueSA/PyBOYU5cbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVNYXJrZXJBbmltYXRpb24ocGFpck1hcCwgcGFyZW50U3RhdHVzKSB7XG4gIGNvbnN0IHJlYWRGaXJzdFBhaXIgPSAoeFZhbHVlLCB0eXBlKSA9PiB7XG4gICAgY29uc3QgdmFsID0gcGFpck1hcFt0eXBlXVt4VmFsdWVdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWxbMF0gOiB2YWw7XG4gIH07XG4gIGNvbnN0IG1hcmtlclN0YXR1cyA9IChkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHsgeFZhbHVlIH0gPSBkYXR1bTtcbiAgICBpZiAocGFpck1hcC5tb3ZlZFt4VmFsdWVdKSB7XG4gICAgICByZXR1cm4geyBwb2ludDogcmVhZEZpcnN0UGFpcih4VmFsdWUsIFwibW92ZWRcIiksIHN0YXR1czogXCJ1cGRhdGVkXCIgfTtcbiAgICB9IGVsc2UgaWYgKHBhaXJNYXAucmVtb3ZlZFt4VmFsdWVdKSB7XG4gICAgICByZXR1cm4geyBwb2ludDogcmVhZEZpcnN0UGFpcih4VmFsdWUsIFwicmVtb3ZlZFwiKSwgc3RhdHVzOiBcInJlbW92ZWRcIiB9O1xuICAgIH0gZWxzZSBpZiAocGFpck1hcC5hZGRlZFt4VmFsdWVdKSB7XG4gICAgICByZXR1cm4geyBwb2ludDogcmVhZEZpcnN0UGFpcih4VmFsdWUsIFwiYWRkZWRcIiksIHN0YXR1czogXCJhZGRlZFwiIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogXCJ1bmtub3duXCIgfTtcbiAgfTtcbiAgY29uc3QgZnJvbUZuID0gKG1hcmtlciwgZGF0dW0pID0+IHtcbiAgICBjb25zdCB7IHN0YXR1cywgcG9pbnQgfSA9IG1hcmtlclN0YXR1cyhkYXR1bSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm4geyBvcGFjaXR5OiAwIH07XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB0cmFuc2xhdGlvblg6IHBvaW50Py5mcm9tPy54ID8/IG1hcmtlci50cmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblk6IHBvaW50Py5mcm9tPy55ID8/IG1hcmtlci50cmFuc2xhdGlvblksXG4gICAgICBvcGFjaXR5OiBtYXJrZXIub3BhY2l0eSxcbiAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c11cbiAgICB9O1xuICAgIGlmIChwYXJlbnRTdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogcG9pbnQ/LnRvPy54LFxuICAgICAgICB0cmFuc2xhdGlvblk6IHBvaW50Py50bz8ueSxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbXCJhZGRlZFwiXVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICBkZWZhdWx0cy5vcGFjaXR5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9O1xuICBjb25zdCB0b0ZuID0gKF9tYXJrZXIsIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXMsIHBvaW50IH0gPSBtYXJrZXJTdGF0dXMoZGF0dW0pO1xuICAgIGlmIChzdGF0dXMgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCB9O1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS5wb2ludC54LFxuICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5wb2ludC55LFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c11cbiAgICB9O1xuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiIHx8IHBhcmVudFN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgICB0cmFuc2xhdGlvblg6IHBvaW50Py50bz8ueCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiBwb2ludD8udG8/LnksXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1wicmVtb3ZlZFwiXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9O1xuICByZXR1cm4geyBmcm9tRm4sIHRvRm4gfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyhzZXJpZXMsIHsgZGF0dW1JbmRleCB9KSB7XG4gIGNvbnN0IG5vZGVEYXRhID0gc2VyaWVzLmdldE5vZGVEYXRhKCk7XG4gIGlmIChub2RlRGF0YSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGRhdHVtID0gbm9kZURhdGFbZGF0dW1JbmRleF07XG4gIGlmIChkYXR1bSA9PT0gdm9pZCAwIHx8IGRhdHVtLnBvaW50ID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3Qgc2l6ZSA9IHNlcmllcy5nZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkuc2l6ZTtcbiAgY29uc3QgcmFkaXVzID0gc2l6ZSAvIDI7XG4gIGNvbnN0IHsgeCwgeSB9ID0gc2VyaWVzLmNvbnRlbnRHcm91cC5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoZGF0dW0ucG9pbnQueCAtIHJhZGl1cywgZGF0dW0ucG9pbnQueSAtIHJhZGl1cyk7XG4gIHJldHVybiBuZXcgQkJveCh4LCB5LCBzaXplLCBzaXplKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lUGxvdHRlci50c1xuZnVuY3Rpb24gcGxvdExpbmVhclBvaW50cyhwYXRoLCBwb2ludHMsIGNvbnRpbnVlUGF0aCkge1xuICBsZXQgZGlkTW92ZSA9IGNvbnRpbnVlUGF0aDtcbiAgZm9yIChjb25zdCB7IHgsIHkgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoZGlkTW92ZSkge1xuICAgICAgcGF0aC5saW5lVG8oeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgZGlkTW92ZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG52YXIgZmxhdG5lc3NSYXRpbzIgPSAwLjA1O1xuZnVuY3Rpb24gcGxvdFNtb290aFBvaW50cyhwYXRoLCBpUG9pbnRzLCB0ZW5zaW9uLCBjb250aW51ZVBhdGgpIHtcbiAgY29uc3QgcG9pbnRzID0gQXJyYXkuaXNBcnJheShpUG9pbnRzKSA/IGlQb2ludHMgOiBBcnJheS5mcm9tKGlQb2ludHMpO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGlmIChjb250aW51ZVBhdGgpIHtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICB9IGVsc2Uge1xuICAgIHBhdGgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gIH1cbiAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGdyYWRpZW50cyA9IHBvaW50cy5tYXAoKGMsIGkpID0+IHtcbiAgICBjb25zdCBwID0gaSA9PT0gMCA/IGMgOiBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IG4gPSBpID09PSBwb2ludHMubGVuZ3RoIC0gMSA/IGMgOiBwb2ludHNbaSArIDFdO1xuICAgIGNvbnN0IGlzVGVybWluYWxQb2ludCA9IGkgPT09IDAgfHwgaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKE1hdGguc2lnbihwLnkgLSBjLnkpID09PSBNYXRoLnNpZ24obi55IC0gYy55KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghaXNUZXJtaW5hbFBvaW50KSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBNYXRoLmFicyhwLnkgLSBuLnkpO1xuICAgICAgY29uc3QgcHJldlJhdGlvID0gTWF0aC5hYnMoYy55IC0gcC55KSAvIHJhbmdlMztcbiAgICAgIGNvbnN0IG5leHRSYXRpbyA9IE1hdGguYWJzKGMueSAtIG4ueSkgLyByYW5nZTM7XG4gICAgICBpZiAocHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8yIHx8IDEgLSBwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIgfHwgbmV4dFJhdGlvIDw9IGZsYXRuZXNzUmF0aW8yIHx8IDEgLSBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAobi55IC0gcC55KSAvIChuLnggLSBwLngpO1xuICB9KTtcbiAgaWYgKGdyYWRpZW50c1sxXSA9PT0gMCkge1xuICAgIGdyYWRpZW50c1swXSAqPSAyO1xuICB9XG4gIGlmIChncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDJdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzW2dyYWRpZW50cy5sZW5ndGggLSAxXSAqPSAyO1xuICB9XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcHJldiA9IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgcHJldk0gPSBncmFkaWVudHNbaSAtIDFdO1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tpXTtcbiAgICBjb25zdCBjdXJNID0gZ3JhZGllbnRzW2ldO1xuICAgIGNvbnN0IGR4ID0gY3VyLnggLSBwcmV2Lng7XG4gICAgY29uc3QgZHkgPSBjdXIueSAtIHByZXYueTtcbiAgICBsZXQgZGNwMXggPSBkeCAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AxeSA9IGR4ICogcHJldk0gKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMnggPSBkeCAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeSA9IGR4ICogY3VyTSAqIHRlbnNpb24gLyAzO1xuICAgIGlmIChjdXJNID09PSAwICYmIE1hdGguYWJzKGRjcDF5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMXggKj0gTWF0aC5hYnMoZHkgLyBkY3AxeSk7XG4gICAgICBkY3AxeSA9IE1hdGguc2lnbihkY3AxeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIGlmIChwcmV2TSA9PT0gMCAmJiBNYXRoLmFicyhkY3AyeSkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGRjcDJ4ICo9IE1hdGguYWJzKGR5IC8gZGNwMnkpO1xuICAgICAgZGNwMnkgPSBNYXRoLnNpZ24oZGNwMnkpICogTWF0aC5hYnMoZHkpO1xuICAgIH1cbiAgICBwYXRoLmN1YmljQ3VydmVUbyhwcmV2LnggKyBkY3AxeCwgcHJldi55ICsgZGNwMXksIGN1ci54IC0gZGNwMngsIGN1ci55IC0gZGNwMnksIGN1ci54LCBjdXIueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RTdGVwUG9pbnRzKHBhdGgsIHBvaW50cywgYWxpZ24sIGNvbnRpbnVlUGF0aCkge1xuICBsZXQgbGFzdFBvaW50O1xuICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgIGlmIChsYXN0UG9pbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uYWxBbGlnbiA9IGxhc3RQb2ludC54IDwgcG9pbnQueCA/IGFsaWduIDogMSAtIGFsaWduO1xuICAgICAgY29uc3QgeCA9IChwb2ludC54IC0gbGFzdFBvaW50LngpICogZGlyZWN0aW9uYWxBbGlnbiArIGxhc3RQb2ludC54O1xuICAgICAgcGF0aC5saW5lVG8oeCwgbGFzdFBvaW50Py55ID8/IHBvaW50LnkpO1xuICAgICAgcGF0aC5saW5lVG8oeCwgcG9pbnQueSk7XG4gICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRpbnVlUGF0aCkge1xuICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgIH1cbiAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3BhdGhVdGlsLnRzXG5mdW5jdGlvbiBtaW5NYXgobm9kZURhdGEpIHtcbiAgcmV0dXJuIG5vZGVEYXRhLnJlZHVjZShcbiAgICAoeyBtaW4sIG1heCB9LCBub2RlKSA9PiB7XG4gICAgICBpZiAobWluID09IG51bGwgfHwgbWluLnBvaW50LnggPiBub2RlLnBvaW50LngpIHtcbiAgICAgICAgbWluID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXggPT0gbnVsbCB8fCBtYXgucG9pbnQueCA8IG5vZGUucG9pbnQueCkge1xuICAgICAgICBtYXggPSBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWluLCBtYXggfTtcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25PbkxpbmUoYSwgYiwgdGFyZ2V0WCkge1xuICBjb25zdCBtID0gKGIueSAtIGEueSkgLyAoYi54IC0gYS54KTtcbiAgY29uc3QgeSA9ICh0YXJnZXRYIC0gYS54KSAqIG0gKyBhLnk7XG4gIHJldHVybiB7IHg6IHRhcmdldFgsIHkgfTtcbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUGF0aFBvaW50KHJlc3VsdHMsIHByb2Nlc3MsIHNraXAsIHByb2Nlc3NGbikge1xuICBsZXQgcHJldk1hcmtlcklkeCA9IC0xLCBuZXh0TWFya2VySWR4ID0gMDtcbiAgY29uc3QgdG9Qcm9jZXNzID0gW107XG4gIHdoaWxlIChuZXh0TWFya2VySWR4IDwgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICBpZiAocmVzdWx0c1tuZXh0TWFya2VySWR4XS5jaGFuZ2UgPT09IHByb2Nlc3MpIHtcbiAgICAgIHRvUHJvY2Vzcy5wdXNoKHJlc3VsdHNbbmV4dE1hcmtlcklkeF0pO1xuICAgICAgbmV4dE1hcmtlcklkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChyZXN1bHRzW25leHRNYXJrZXJJZHhdLmNoYW5nZSA9PT0gc2tpcCkge1xuICAgICAgbmV4dE1hcmtlcklkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b1Byb2Nlc3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJvY2Vzc0ZuKHRvUHJvY2VzcywgcHJldk1hcmtlcklkeCwgbmV4dE1hcmtlcklkeCk7XG4gICAgICB0b1Byb2Nlc3MubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcHJldk1hcmtlcklkeCA9IG5leHRNYXJrZXJJZHg7XG4gICAgbmV4dE1hcmtlcklkeCsrO1xuICB9XG4gIGlmICh0b1Byb2Nlc3MubGVuZ3RoID4gMCkge1xuICAgIHByb2Nlc3NGbih0b1Byb2Nlc3MsIHByZXZNYXJrZXJJZHgsIG5leHRNYXJrZXJJZHgpO1xuICB9XG59XG5mdW5jdGlvbiBiYWNrZmlsbFBhdGhQb2ludERhdGEocmVzdWx0LCBzcGxpdE1vZGUpIHtcbiAgYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0LCBcIm91dFwiLCBcImluXCIsICh0b1Byb2Nlc3MsIHNJZHgsIGVJZHgpID0+IHtcbiAgICBpZiAoc0lkeCA9PT0gLTEgJiYgcmVzdWx0W2VJZHhdKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IHJlc3VsdFtlSWR4XS5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKGVJZHggPT09IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3NJZHhdKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IHJlc3VsdFtzSWR4XS5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gXCJpbnRlcnNlY3RcIiAmJiByZXN1bHRbc0lkeF0/LmZyb20gJiYgcmVzdWx0W2VJZHhdPy5mcm9tKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IGludGVyc2VjdGlvbk9uTGluZShyZXN1bHRbc0lkeF0uZnJvbSwgcmVzdWx0W2VJZHhdLmZyb20sIGQuZnJvbS54KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gZC5mcm9tKTtcbiAgICB9XG4gIH0pO1xuICBiYWNrZmlsbFBhdGhQb2ludChyZXN1bHQsIFwiaW5cIiwgXCJvdXRcIiwgKHRvUHJvY2Vzcywgc0lkeCwgZUlkeCkgPT4ge1xuICAgIGlmIChzSWR4ID09PSAtMSAmJiByZXN1bHRbZUlkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSByZXN1bHRbZUlkeF0udG8pO1xuICAgIH0gZWxzZSBpZiAoZUlkeCA9PT0gcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc0lkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSByZXN1bHRbc0lkeF0udG8pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSBcImludGVyc2VjdFwiICYmIHJlc3VsdFtzSWR4XT8udG8gJiYgcmVzdWx0W2VJZHhdPy50bykge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IGludGVyc2VjdGlvbk9uTGluZShyZXN1bHRbc0lkeF0udG8sIHJlc3VsdFtlSWR4XS50bywgZC50by54KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSBkLnRvKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnQoZnJvbTIsIHRvLCByYXRpbzIpIHtcbiAgY29uc3QgeDEgPSBpc05hTihmcm9tMi54KSA/IHRvLnggOiBmcm9tMi54O1xuICBjb25zdCB5MSA9IGlzTmFOKGZyb20yLnkpID8gdG8ueSA6IGZyb20yLnk7XG4gIGNvbnN0IHhkID0gdG8ueCAtIGZyb20yLng7XG4gIGNvbnN0IHlkID0gdG8ueSAtIGZyb20yLnk7XG4gIGNvbnN0IHhyID0gaXNOYU4oeGQpID8gMCA6IHhkICogcmF0aW8yO1xuICBjb25zdCB5ciA9IGlzTmFOKHlkKSA/IDAgOiB5ZCAqIHJhdGlvMjtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhyLFxuICAgIHk6IHkxICsgeXJcbiAgfTtcbn1cbnZhciBsaW5lU3RlcHMyID0ge1xuICBzdGFydDogMCxcbiAgbWlkZGxlOiAwLjUsXG4gIGVuZDogMVxufTtcbmZ1bmN0aW9uIHBsb3RQYXRoKHBvaW50cywgcGF0aCwgaW50ZXJwb2xhdGlvbiwgY29udGludWVQYXRoID0gZmFsc2UpIHtcbiAgY29uc3QgeyBwYXRoOiBsaW5lUGF0aCB9ID0gcGF0aDtcbiAgaWYgKGludGVycG9sYXRpb24/LnR5cGUgPT09IFwic21vb3RoXCIpIHtcbiAgICBwbG90U21vb3RoUG9pbnRzKGxpbmVQYXRoLCBwb2ludHMsIGludGVycG9sYXRpb24udGVuc2lvbiA/PyAxLCBjb250aW51ZVBhdGgpO1xuICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24/LnR5cGUgPT09IFwic3RlcFwiKSB7XG4gICAgcGxvdFN0ZXBQb2ludHMobGluZVBhdGgsIHBvaW50cywgbGluZVN0ZXBzMltpbnRlcnBvbGF0aW9uLnBvc2l0aW9uID8/IFwiZW5kXCJdLCBjb250aW51ZVBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHBsb3RMaW5lYXJQb2ludHMobGluZVBhdGgsIHBvaW50cywgY29udGludWVQYXRoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3BsaXRQYWlyRGF0YShwYWlyRGF0YSwgcmF0aW9zKSB7XG4gIGxldCBwcmV2aW91c1RvO1xuICBsZXQgcG9pbnRzID0gdm9pZCAwO1xuICBjb25zdCBvdXQgPSBbXTtcbiAgY29uc3QgZmx1c2hDdXJyZW50ID0gKCkgPT4ge1xuICAgIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgb3V0LnB1c2gocG9pbnRzKTtcbiAgICAgIHBvaW50cyA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgZGF0YSBvZiBwYWlyRGF0YSkge1xuICAgIGNvbnN0IHsgZnJvbTogZnJvbTIsIHRvIH0gPSBkYXRhO1xuICAgIGNvbnN0IHJhdGlvMiA9IHJhdGlvc1tkYXRhLmNoYW5nZV07XG4gICAgaWYgKHJhdGlvMiA9PSBudWxsIHx8IGZyb20yID09IG51bGwgfHwgdG8gPT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHBvaW50ID0gY2FsY3VsYXRlUG9pbnQoZnJvbTIsIHRvLCByYXRpbzIpO1xuICAgIGlmIChkYXRhLm1vdmVUbyA9PT0gZmFsc2UpIHtcbiAgICAgIHBvaW50cyA/PyAocG9pbnRzID0gW10pO1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5tb3ZlVG8gPT09IHRydWUgfHwgIXByZXZpb3VzVG8pIHtcbiAgICAgIGZsdXNoQ3VycmVudCgpO1xuICAgICAgcG9pbnRzID0gW3BvaW50XTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzVG8pIHtcbiAgICAgIGNvbnN0IG1vdmVUb1JhdGlvID0gZGF0YS5tb3ZlVG8gPT09IFwiaW5cIiA/IHJhdGlvMiA6IDEgLSByYXRpbzI7XG4gICAgICBjb25zdCB7IHg6IG1pZFBvaW50WCwgeTogbWlkUG9pbnRZIH0gPSBjYWxjdWxhdGVQb2ludChwcmV2aW91c1RvLCBwb2ludCwgbW92ZVRvUmF0aW8pO1xuICAgICAgcG9pbnRzID8/IChwb2ludHMgPSBbXSk7XG4gICAgICBwb2ludHMucHVzaCh7IHg6IG1pZFBvaW50WCwgeTogbWlkUG9pbnRZIH0pO1xuICAgICAgZmx1c2hDdXJyZW50KCk7XG4gICAgICBwb2ludHMgPSBbcG9pbnRdO1xuICAgIH1cbiAgICBwcmV2aW91c1RvID0gcG9pbnQ7XG4gIH1cbiAgZmx1c2hDdXJyZW50KCk7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiByZW5kZXJQYXJ0aWFsUGF0aChwYWlyRGF0YSwgcmF0aW9zLCBwYXRoLCBpbnRlcnBvbGF0aW9uKSB7XG4gIHNwbGl0UGFpckRhdGEocGFpckRhdGEsIHJhdGlvcykuZm9yRWFjaCgocG9pbnRzKSA9PiB7XG4gICAgcGxvdFBhdGgocG9pbnRzLCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXRoU3dpcGVJbkFuaW1hdGlvbih7IGlkLCB2aXNpYmxlLCBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBhbmltYXRpb25NYW5hZ2VyLCAuLi5wYXRocykge1xuICBjb25zdCB7IHNlcmllc1JlY3RXaWR0aDogd2lkdGgsIHNlcmllc1JlY3RIZWlnaHQ6IGhlaWdodCB9ID0gbm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICBpZCxcbiAgICBcInBhdGhfcHJvcGVydGllc1wiLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgcGF0aHMsXG4gICAgeyBjbGlwWDogMCB9LFxuICAgIHsgY2xpcFg6IHdpZHRoIH0sXG4gICAge1xuICAgICAgcGhhc2U6IFwiaW5pdGlhbFwiLFxuICAgICAgc3RhcnQ6IHsgY2xpcE1vZGU6IFwibm9ybWFsXCIsIGNsaXBZOiBoZWlnaHQsIHZpc2libGUgfSxcbiAgICAgIGZpbmlzaDogeyBjbGlwTW9kZTogdm9pZCAwLCB2aXNpYmxlIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBwYXRoRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHBoYXNlID0gXCJhZGRcIiwgLi4uc2VsZWN0aW9uKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbiwgeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9LCB7IHBoYXNlIH0pO1xufVxuZnVuY3Rpb24gcGF0aEZhZGVPdXRBbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgLi4uc2VsZWN0aW9uKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbiwgeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9LCB7IHBoYXNlOiBcInJlbW92ZVwiIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSZXNldFBhdGhGbihvcHRzKSB7XG4gIHJldHVybiAoX25vZGUpID0+IHtcbiAgICByZXR1cm4geyB2aXNpYmxlOiBvcHRzLmdldFZpc2libGUoKSwgb3BhY2l0eTogb3B0cy5nZXRPcGFjaXR5KCksIGNsaXBTY2FsaW5nWDogMSwgY2xpcE1vZGU6IHZvaWQgMCB9O1xuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2xpcFBhdGgoeyBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBwYXRoKSB7XG4gIGNvbnN0IHRvRmluaXRlID0gKHZhbHVlKSA9PiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IDA7XG4gIHBhdGguY2xpcFggPSB0b0Zpbml0ZShub2RlRGF0YURlcGVuZGVuY2llcy5zZXJpZXNSZWN0V2lkdGgpO1xuICBwYXRoLmNsaXBZID0gdG9GaW5pdGUobm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdEhlaWdodCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhbGluZy50c1xuZnVuY3Rpb24gaXNDb250aW51b3VzU2NhbGluZyhzY2FsaW5nKSB7XG4gIHJldHVybiBzY2FsaW5nLnR5cGUgPT09IFwiY29udGludW91c1wiIHx8IHNjYWxpbmcudHlwZSA9PT0gXCJsb2dcIjtcbn1cbmZ1bmN0aW9uIGlzQ2F0ZWdvcnlTY2FsaW5nKHNjYWxpbmcpIHtcbiAgcmV0dXJuIHNjYWxpbmcudHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xufVxuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5kb21haW4ubGVuZ3RoID09PSBiLmRvbWFpbi5sZW5ndGggJiYgYS5yYW5nZS5sZW5ndGggPT09IGIucmFuZ2UubGVuZ3RoICYmIGEuZG9tYWluLmV2ZXJ5KCh2YWwsIGluZGV4KSA9PiB2YWwgPT09IGIuZG9tYWluW2luZGV4XSkgJiYgYS5yYW5nZS5ldmVyeSgodmFsLCBpbmRleCkgPT4gdmFsID09PSBiLnJhbmdlW2luZGV4XSk7XG59XG5mdW5jdGlvbiBhcmVTY2FsaW5nRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gdm9pZCAwIHx8IGIgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhICE9PSB2b2lkIDAgfHwgYiAhPT0gdm9pZCAwO1xuICB9XG4gIGlmIChpc0NvbnRpbnVvdXNTY2FsaW5nKGEpICYmIGlzQ29udGludW91c1NjYWxpbmcoYikpIHtcbiAgICByZXR1cm4gYS50eXBlID09PSBiLnR5cGUgJiYgYXJlRXF1YWwoYSwgYik7XG4gIH1cbiAgaWYgKGlzQ2F0ZWdvcnlTY2FsaW5nKGEpICYmIGlzQ2F0ZWdvcnlTY2FsaW5nKGIpKSB7XG4gICAgcmV0dXJuIGFyZUVxdWFsKGEsIGIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NhbGVWYWxpZChzY2FsZTIpIHtcbiAgaWYgKHNjYWxlMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFzY2FsZTIucmFuZ2UuZXZlcnkoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2NhbGUyLnR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgIHJldHVybiBzY2FsZTIuZG9tYWluLmV2ZXJ5KCh2KSA9PiB2ICE9IG51bGwpO1xuICB9XG4gIHJldHVybiBzY2FsZTIuZG9tYWluLmV2ZXJ5KCh2KSA9PiBOdW1iZXIuaXNGaW5pdGUodikgfHwgdiBpbnN0YW5jZW9mIERhdGUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVVdGlsLnRzXG5mdW5jdGlvbiogcGF0aFJhbmdlcyhwb2ludHMpIHtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAwO1xuICBmb3IgKGNvbnN0IHsgcG9pbnQgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAocG9pbnQubW92ZVRvKSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBzdGFydCA+PSAwID8geyBzdGFydCwgZW5kIH0gOiB2b2lkIDA7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgaWYgKHJhbmdlMyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHlpZWxkIHJhbmdlMztcbiAgICAgIH1cbiAgICB9XG4gICAgZW5kICs9IDE7XG4gIH1cbiAgaWYgKHN0YXJ0ICE9PSAtMSkge1xuICAgIHlpZWxkIHsgc3RhcnQsIGVuZCB9O1xuICB9XG59XG5mdW5jdGlvbiogcGF0aFJhbmdlUG9pbnRzKHBvaW50cywgeyBzdGFydCwgZW5kIH0pIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICB5aWVsZCBwb2ludHNbaV0ucG9pbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uKiBwYXRoUmFuZ2VQb2ludHNSZXZlcnNlKHBvaW50cywgeyBzdGFydCwgZW5kIH0pIHtcbiAgZm9yIChsZXQgaSA9IGVuZCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMSkge1xuICAgIHlpZWxkIHBvaW50c1tpXS5wb2ludDtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZWdyYXRlZENhdGVnb3J5TWF0Y2goYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChcImlkXCIgaW4gYSAmJiBcImlkXCIgaW4gYikge1xuICAgIHJldHVybiBhLmlkID09PSBiLmlkO1xuICB9XG4gIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHNjYWxlKHZhbCwgc2NhbGluZykge1xuICBpZiAoIXNjYWxpbmcpXG4gICAgcmV0dXJuIE5hTjtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICB2YWwgPSB2YWwuZ2V0VGltZSgpO1xuICB9XG4gIGlmIChzY2FsaW5nLnR5cGUgPT09IFwiY29udGludW91c1wiICYmIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb25zdCBkb21haW5SYXRpbyA9ICh2YWwgLSBzY2FsaW5nLmRvbWFpblswXSkgLyAoc2NhbGluZy5kb21haW5bMV0gLSBzY2FsaW5nLmRvbWFpblswXSk7XG4gICAgcmV0dXJuIGRvbWFpblJhdGlvICogKHNjYWxpbmcucmFuZ2VbMV0gLSBzY2FsaW5nLnJhbmdlWzBdKSArIHNjYWxpbmcucmFuZ2VbMF07XG4gIH1cbiAgaWYgKHNjYWxpbmcudHlwZSA9PT0gXCJsb2dcIiAmJiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcuY29udmVydCh2YWwpO1xuICB9XG4gIGNvbnN0IG1hdGNoaW5nSW5kZXggPSBzY2FsaW5nLmRvbWFpbi5maW5kSW5kZXgoKGQpID0+IGQgPT09IHZhbCk7XG4gIGlmIChtYXRjaGluZ0luZGV4ID49IDApIHtcbiAgICByZXR1cm4gc2NhbGluZy5yYW5nZVttYXRjaGluZ0luZGV4XTtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0ludGVncmF0ZWRJbmRleCA9IHNjYWxpbmcuZG9tYWluLmZpbmRJbmRleCgoZCkgPT4gaW50ZWdyYXRlZENhdGVnb3J5TWF0Y2godmFsLCBkKSk7XG4gIGlmIChtYXRjaGluZ0ludGVncmF0ZWRJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcucmFuZ2VbbWF0Y2hpbmdJbnRlZ3JhdGVkSW5kZXhdO1xuICB9XG4gIHJldHVybiBOYU47XG59XG5mdW5jdGlvbiBzY2FsZXNDaGFuZ2VkKG5ld0RhdGEsIG9sZERhdGEpIHtcbiAgcmV0dXJuICFhcmVTY2FsaW5nRXF1YWwobmV3RGF0YS5zY2FsZXMueCwgb2xkRGF0YS5zY2FsZXMueCkgfHwgIWFyZVNjYWxpbmdFcXVhbChuZXdEYXRhLnNjYWxlcy55LCBvbGREYXRhLnNjYWxlcy55KTtcbn1cbmZ1bmN0aW9uIGNsb3NlTWF0Y2goYSwgYikge1xuICBjb25zdCBhbiA9IE51bWJlcihhKTtcbiAgY29uc3QgYm4gPSBOdW1iZXIoYik7XG4gIGlmICghaXNOYU4oYW4pICYmICFpc05hTihibikpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYm4gLSBhbikgPCAwLjI1O1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTW92ZVRvKGZyb20yID0gZmFsc2UsIHRvID0gZmFsc2UpIHtcbiAgaWYgKGZyb20yID09PSB0bykge1xuICAgIHJldHVybiBCb29sZWFuKGZyb20yKTtcbiAgfVxuICByZXR1cm4gZnJvbTIgPyBcImluXCIgOiBcIm91dFwiO1xufVxuZnVuY3Rpb24gcGFpckNvbnRpbnVvdXNEYXRhKG5ld0RhdGEsIG9sZERhdGEsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJhY2tmaWxsU3BsaXRNb2RlID0gXCJpbnRlcnNlY3RcIiB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHJlc3VsdE1hcCA9IHtcbiAgICBhZGRlZDoge30sXG4gICAgbW92ZWQ6IHt9LFxuICAgIHJlbW92ZWQ6IHt9XG4gIH07XG4gIGNvbnN0IHBhaXJVcCA9IChmcm9tMiwgdG8sIHhWYWx1ZSwgY2hhbmdlID0gXCJtb3ZlXCIpID0+IHtcbiAgICBpZiAoZnJvbTIgJiYgKGlzTmFOKGZyb20yLnBvaW50LngpIHx8IGlzTmFOKGZyb20yLnBvaW50LnkpKSkge1xuICAgICAgZnJvbTIgPSB0bztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0UG9pbnQgPSB7XG4gICAgICBmcm9tOiBmcm9tMj8ucG9pbnQsXG4gICAgICB0bzogdG8/LnBvaW50LFxuICAgICAgbW92ZVRvOiBjYWxjdWxhdGVNb3ZlVG8oZnJvbTI/LnBvaW50Lm1vdmVUbywgdG8/LnBvaW50Lm1vdmVUbyksXG4gICAgICBjaGFuZ2VcbiAgICB9O1xuICAgIGlmIChjaGFuZ2UgPT09IFwibW92ZVwiKSB7XG4gICAgICByZXN1bHRNYXAubW92ZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xuICAgICAgb2xkSWR4Kys7XG4gICAgICBuZXdJZHgrKztcbiAgICB9IGVsc2UgaWYgKGNoYW5nZSA9PT0gXCJpblwiKSB7XG4gICAgICByZXN1bHRNYXAuYWRkZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xuICAgICAgbmV3SWR4Kys7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UgPT09IFwib3V0XCIpIHtcbiAgICAgIHJlc3VsdE1hcC5yZW1vdmVkW3hWYWx1ZV0gPSByZXN1bHRQb2ludDtcbiAgICAgIG9sZElkeCsrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChyZXN1bHRQb2ludCk7XG4gIH07XG4gIGNvbnN0IHsgbWluOiBtaW5Gcm9tTm9kZSwgbWF4OiBtYXhGcm9tTm9kZSB9ID0gbWluTWF4KG9sZERhdGEubm9kZURhdGEpO1xuICBjb25zdCB7IG1pbjogbWluVG9Ob2RlLCBtYXg6IG1heFRvTm9kZSB9ID0gbWluTWF4KG5ld0RhdGEubm9kZURhdGEpO1xuICBsZXQgb2xkSWR4ID0gMDtcbiAgbGV0IG5ld0lkeCA9IDA7XG4gIHdoaWxlIChvbGRJZHggPCBvbGREYXRhLm5vZGVEYXRhLmxlbmd0aCB8fCBuZXdJZHggPCBuZXdEYXRhLm5vZGVEYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGZyb20yID0gb2xkRGF0YS5ub2RlRGF0YVtvbGRJZHhdO1xuICAgIGNvbnN0IHRvID0gbmV3RGF0YS5ub2RlRGF0YVtuZXdJZHhdO1xuICAgIGNvbnN0IGZyb21TaGlmdGVkID0gZnJvbTIgPyBzY2FsZShmcm9tMi54VmFsdWUgPz8gTmFOLCBuZXdEYXRhLnNjYWxlcy54KSA6IHZvaWQgMDtcbiAgICBjb25zdCB0b1Vuc2hpZnRlZCA9IHRvID8gc2NhbGUodG8ueFZhbHVlID8/IE5hTiwgb2xkRGF0YS5zY2FsZXMueCkgOiB2b2lkIDA7XG4gICAgY29uc3QgTkEgPSB2b2lkIDA7XG4gICAgaWYgKGZyb21TaGlmdGVkICE9IG51bGwgJiYgY2xvc2VNYXRjaChmcm9tU2hpZnRlZCwgdG8/LnBvaW50LngpKSB7XG4gICAgICBwYWlyVXAoZnJvbTIsIHRvLCB0by54VmFsdWUsIFwibW92ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGZyb21TaGlmdGVkICE9IG51bGwgJiYgZnJvbVNoaWZ0ZWQgPCAobWluVG9Ob2RlPy5wb2ludC54ID8/IC1JbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChmcm9tMiwgTkEsIGZyb20yLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGZyb21TaGlmdGVkID4gKG1heFRvTm9kZT8ucG9pbnQueCA/PyBJbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChmcm9tMiwgTkEsIGZyb20yLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmICh0b1Vuc2hpZnRlZCAhPSBudWxsICYmIHRvVW5zaGlmdGVkIDwgKG1pbkZyb21Ob2RlPy5wb2ludC54ID8/IC1JbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2UgaWYgKHRvVW5zaGlmdGVkICE9IG51bGwgJiYgdG9VbnNoaWZ0ZWQgPiAobWF4RnJvbU5vZGU/LnBvaW50LnggPz8gSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGZyb21TaGlmdGVkIDwgdG8/LnBvaW50LngpIHtcbiAgICAgIHBhaXJVcChmcm9tMiwgTkEsIGZyb20yLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmICh0b1Vuc2hpZnRlZCAhPSBudWxsICYmIHRvVW5zaGlmdGVkIDwgZnJvbTI/LnBvaW50LngpIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2UgaWYgKGZyb20yKSB7XG4gICAgICBwYWlyVXAoZnJvbTIsIE5BLCBmcm9tMi54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAodG8pIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHByb2Nlc3MgcG9pbnRzXCIpO1xuICAgIH1cbiAgfVxuICBiYWNrZmlsbFBhdGhQb2ludERhdGEocmVzdWx0LCBiYWNrZmlsbFNwbGl0TW9kZSk7XG4gIHJldHVybiB7IHJlc3VsdCwgcmVzdWx0TWFwIH07XG59XG5mdW5jdGlvbiBwYWlyQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYWNrZmlsbFNwbGl0TW9kZSA9IFwiaW50ZXJzZWN0XCIsIG11bHRpRGF0dW0gPSBmYWxzZSB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHJlc3VsdE1hcFNpbmdsZSA9IHtcbiAgICBhZGRlZDoge30sXG4gICAgbW92ZWQ6IHt9LFxuICAgIHJlbW92ZWQ6IHt9XG4gIH07XG4gIGNvbnN0IHJlc3VsdE1hcE11bHRpID0ge1xuICAgIGFkZGVkOiB7fSxcbiAgICBtb3ZlZDoge30sXG4gICAgcmVtb3ZlZDoge31cbiAgfTtcbiAgY29uc3QgcG9pbnRSZXN1bHRNYXBwaW5nID0ge1xuICAgIGluOiBcImFkZGVkXCIsXG4gICAgbW92ZTogXCJtb3ZlZFwiLFxuICAgIG91dDogXCJyZW1vdmVkXCJcbiAgfTtcbiAgbGV0IHByZXZpb3VzUmVzdWx0UG9pbnQgPSB2b2lkIDA7XG4gIGxldCBwcmV2aW91c1hWYWx1ZSA9IHZvaWQgMDtcbiAgY29uc3QgYWRkVG9SZXN1bHRNYXAgPSAoeFZhbHVlLCBuZXdQb2ludCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0eXBlID0gcG9pbnRSZXN1bHRNYXBwaW5nW25ld1BvaW50LmNoYW5nZV07XG4gICAgaWYgKG11bHRpRGF0dW0pIHtcbiAgICAgIChfYSA9IHJlc3VsdE1hcE11bHRpW3R5cGVdKVt4VmFsdWVdID8/IChfYVt4VmFsdWVdID0gW10pO1xuICAgICAgcmVzdWx0TWFwTXVsdGlbdHlwZV1beFZhbHVlXS5wdXNoKG5ld1BvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0TWFwU2luZ2xlW3R5cGVdW3hWYWx1ZV0gPSBuZXdQb2ludDtcbiAgICB9XG4gICAgcHJldmlvdXNSZXN1bHRQb2ludCA9IG5ld1BvaW50O1xuICAgIHByZXZpb3VzWFZhbHVlID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoeFZhbHVlKTtcbiAgfTtcbiAgbGV0IG9sZEluZGV4ID0gMDtcbiAgbGV0IG5ld0luZGV4ID0gMDtcbiAgbGV0IGlzWFVub3JkZXJlZCA9IGZhbHNlO1xuICB3aGlsZSAob2xkSW5kZXggPCBvbGREYXRhLm5vZGVEYXRhLmxlbmd0aCB8fCBuZXdJbmRleCA8IG5ld0RhdGEubm9kZURhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgYmVmb3JlID0gb2xkRGF0YS5ub2RlRGF0YVtvbGRJbmRleF07XG4gICAgY29uc3QgYWZ0ZXIgPSBuZXdEYXRhLm5vZGVEYXRhW25ld0luZGV4XTtcbiAgICBjb25zdCBiWFZhbHVlID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoYmVmb3JlPy54VmFsdWUpO1xuICAgIGNvbnN0IGFYVmFsdWUgPSB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShhZnRlcj8ueFZhbHVlKTtcbiAgICBsZXQgcmVzdWx0UG9pbnQ7XG4gICAgaWYgKGJYVmFsdWUgPT09IGFYVmFsdWUpIHtcbiAgICAgIHJlc3VsdFBvaW50ID0ge1xuICAgICAgICBjaGFuZ2U6IFwibW92ZVwiLFxuICAgICAgICBtb3ZlVG86IGNhbGN1bGF0ZU1vdmVUbyhiZWZvcmUucG9pbnQubW92ZVRvID8/IGZhbHNlLCBhZnRlci5wb2ludC5tb3ZlVG8pLFxuICAgICAgICBmcm9tOiBiZWZvcmUucG9pbnQsXG4gICAgICAgIHRvOiBhZnRlci5wb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZT8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBvbGRJbmRleCsrO1xuICAgICAgbmV3SW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGRpZmYyPy5yZW1vdmVkLmhhcyhTdHJpbmcoYlhWYWx1ZSkpKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgY2hhbmdlOiBcIm91dFwiLFxuICAgICAgICBtb3ZlVG86IGJlZm9yZS5wb2ludC5tb3ZlVG8gPz8gZmFsc2UsXG4gICAgICAgIGZyb206IGJlZm9yZS5wb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZT8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBvbGRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoZGlmZjI/LmFkZGVkLmhhcyhTdHJpbmcoYVhWYWx1ZSkpKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgY2hhbmdlOiBcImluXCIsXG4gICAgICAgIG1vdmVUbzogYWZ0ZXIucG9pbnQubW92ZVRvID8/IGZhbHNlLFxuICAgICAgICB0bzogYWZ0ZXIucG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChhZnRlcj8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBuZXdJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAobXVsdGlEYXR1bSAmJiBwcmV2aW91c1Jlc3VsdFBvaW50ICYmIHByZXZpb3VzWFZhbHVlID09PSBiWFZhbHVlKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgLi4ucHJldmlvdXNSZXN1bHRQb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZT8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBvbGRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAobXVsdGlEYXR1bSAmJiBwcmV2aW91c1Jlc3VsdFBvaW50ICYmIHByZXZpb3VzWFZhbHVlID09PSBhWFZhbHVlKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgLi4ucHJldmlvdXNSZXN1bHRQb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGFmdGVyPy54VmFsdWUsIHJlc3VsdFBvaW50KTtcbiAgICAgIG5ld0luZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzWFVub3JkZXJlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocmVzdWx0UG9pbnQpO1xuICB9XG4gIGxldCBwcmV2aW91c1ggPSAtSW5maW5pdHk7XG4gIGlzWFVub3JkZXJlZCB8fCAoaXNYVW5vcmRlcmVkID0gcmVzdWx0LnNvbWUoKHBhdGhQb2ludCkgPT4ge1xuICAgIGNvbnN0IHsgY2hhbmdlOiBtYXJrZXIsIHRvOiB7IHggPSAtSW5maW5pdHkgfSA9IHt9IH0gPSBwYXRoUG9pbnQ7XG4gICAgaWYgKG1hcmtlciA9PT0gXCJvdXRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB1bm9yZGVyZWQgPSB4IDwgcHJldmlvdXNYO1xuICAgIHByZXZpb3VzWCA9IHg7XG4gICAgcmV0dXJuIHVub3JkZXJlZDtcbiAgfSkpO1xuICBpZiAoaXNYVW5vcmRlcmVkKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiB2b2lkIDAsIHJlc3VsdE1hcDogdm9pZCAwIH07XG4gIH1cbiAgYmFja2ZpbGxQYXRoUG9pbnREYXRhKHJlc3VsdCwgYmFja2ZpbGxTcGxpdE1vZGUpO1xuICByZXR1cm4geyByZXN1bHQsIHJlc3VsdE1hcDogbXVsdGlEYXR1bSA/IHJlc3VsdE1hcE11bHRpIDogcmVzdWx0TWFwU2luZ2xlIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVQYXRoU3RhdHVzKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhKSB7XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgY29uc3QgdmlzaWJsZSA9IChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIGRhdGEudmlzaWJsZTtcbiAgfTtcbiAgaWYgKCF2aXNpYmxlKG9sZERhdGEpICYmIHZpc2libGUobmV3RGF0YSkpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH0gZWxzZSBpZiAodmlzaWJsZShvbGREYXRhKSAmJiAhdmlzaWJsZShuZXdEYXRhKSkge1xuICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFpckRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYWlyRGF0YVtpXS5jaGFuZ2UgIT09IFwibW92ZVwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChwYWlyRGF0YVtpXS5mcm9tPy54ICE9PSBwYWlyRGF0YVtpXS50bz8ueClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAocGFpckRhdGFbaV0uZnJvbT8ueSAhPT0gcGFpckRhdGFbaV0udG8/LnkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKGkgPT09IHBhaXJEYXRhLmxlbmd0aCAtIDEpXG4gICAgICAgIHJldHVybiBcIm5vLW9wXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0dXM7XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKSB7XG4gIGNvbnN0IHBoYXNlID0gdmlzaWJsZVRvZ2dsZU1vZGUgPT09IFwibm9uZVwiID8gXCJ1cGRhdGVkXCIgOiBzdGF0dXM7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBmcm9tRm46IChfcGF0aCkgPT4ge1xuICAgICAgbGV0IG1peGluO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgICAgbWl4aW4gPSB7IGZpbmlzaDogeyB2aXNpYmxlOiBmYWxzZSB9IH07XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICAgIG1peGluID0geyBzdGFydDogeyB2aXNpYmxlOiB0cnVlIH0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1peGluID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4geyBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV0sIC4uLm1peGluIH07XG4gICAgfSxcbiAgICB0b0ZuOiAoX3BhdGgpID0+IHtcbiAgICAgIHJldHVybiB7IHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3BoYXNlXSB9O1xuICAgIH1cbiAgfTtcbiAgaWYgKHZpc2libGVUb2dnbGVNb2RlID09PSBcImZhZGVcIikge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tRm46IChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBzdGF0dXMgPT09IFwiYWRkZWRcIiA/IDAgOiBwYXRoLm9wYWNpdHk7XG4gICAgICAgIHJldHVybiB7IG9wYWNpdHksIC4uLnJlc3VsdC5mcm9tRm4ocGF0aCkgfTtcbiAgICAgIH0sXG4gICAgICB0b0ZuOiAocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gc3RhdHVzID09PSBcInJlbW92ZWRcIiA/IDAgOiAxO1xuICAgICAgICByZXR1cm4geyBvcGFjaXR5LCAuLi5yZXN1bHQudG9GbihwYXRoKSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSwgdmlzaWJsZVRvZ2dsZU1vZGUsIGludGVycG9sYXRpb24sIHJlbmRlcikge1xuICBjb25zdCBzdGF0dXMgPSBkZXRlcm1pbmVQYXRoU3RhdHVzKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhKTtcbiAgY29uc3QgcmVtb3ZlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHtcbiAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogMCwgb3V0OiByYXRpbzIgfSwgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiB7XG4gICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IHJhdGlvMiB9LCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfTtcbiAgY29uc3QgYWRkUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHtcbiAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogMSwgaW46IHJhdGlvMiB9LCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfTtcbiAgY29uc3QgcGF0aFByb3BlcnRpZXMgPSBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKTtcbiAgcmV0dXJuIHsgc3RhdHVzLCBwYXRoOiB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSwgcGF0aFByb3BlcnRpZXMgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBkaWZmMiwgaW50ZXJwb2xhdGlvbikge1xuICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSBuZXdEYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGNvbnN0IHdhc0NhdGVnb3J5QmFzZWQgPSBvbGREYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGlmIChpc0NhdGVnb3J5QmFzZWQgIT09IHdhc0NhdGVnb3J5QmFzZWQgfHwgIWlzU2NhbGVWYWxpZChuZXdEYXRhLnNjYWxlcy54KSB8fCAhaXNTY2FsZVZhbGlkKG9sZERhdGEuc2NhbGVzLngpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgcmVzdWx0OiBwYWlyRGF0YSwgcmVzdWx0TWFwOiBwYWlyTWFwIH0gPSBpc0NhdGVnb3J5QmFzZWQgPyBwYWlyQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyKSA6IHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhKTtcbiAgbGV0IHN0YXR1cyA9IFwidXBkYXRlZFwiO1xuICBpZiAob2xkRGF0YS52aXNpYmxlICYmICFuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIGlmICghb2xkRGF0YS52aXNpYmxlICYmIG5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgfVxuICBpZiAocGFpckRhdGEgPT09IHZvaWQgMCB8fCBwYWlyTWFwID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFzTW90aW9uID0gKGRpZmYyPy5jaGFuZ2VkID8/IHRydWUpIHx8IHNjYWxlc0NoYW5nZWQobmV3RGF0YSwgb2xkRGF0YSkgfHwgc3RhdHVzICE9PSBcInVwZGF0ZWRcIjtcbiAgY29uc3QgcGF0aEZucyA9IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSwgXCJmYWRlXCIsIGludGVycG9sYXRpb24sIHJlbmRlclBhcnRpYWxQYXRoKTtcbiAgY29uc3QgbWFya2VyID0gcHJlcGFyZU1hcmtlckFuaW1hdGlvbihwYWlyTWFwLCBzdGF0dXMpO1xuICByZXR1cm4geyAuLi5wYXRoRm5zLCBtYXJrZXIsIGhhc01vdGlvbiB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVJbnRlcnBvbGF0aW9uVXRpbC50c1xuZnVuY3Rpb24gY2xvc2VDbXAoYSwgYiwgZGVsdGEzID0gMWUtNikge1xuICBpZiAoYSA9PT0gYiB8fCAxIC0gTWF0aC5taW4oYSwgYikgLyBNYXRoLm1heChhLCBiKSA8IGRlbHRhMykge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5mdW5jdGlvbiBjbG9zZU1hdGNoMihhLCBiLCBkZWx0YTMpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhbiA9IE51bWJlcihhKTtcbiAgY29uc3QgYm4gPSBOdW1iZXIoYik7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoYW4pICYmIE51bWJlci5pc0Zpbml0ZShibikgJiYgY2xvc2VDbXAoYW4sIGJuLCBkZWx0YTMpID09PSAwO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtU3BhbnMoc3BhbkRhdGEsIHsgeDogeFNjYWxlLCB5OiB5U2NhbGUgfSkge1xuICBsZXQgcmFuZ2VTcGFuRGF0YTtcbiAgY29uc3QgaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucyA9IFtdO1xuICBsZXQgc2hpZnRlZFhTdGFydCA9IEluZmluaXR5O1xuICBsZXQgc2hpZnRlZFhFbmQgPSAtSW5maW5pdHk7XG4gIGZvciAoY29uc3Qgc3BhbkRhdHVtIG9mIHNwYW5EYXRhKSB7XG4gICAgY29uc3QgeDAgPSBzY2FsZShzcGFuRGF0dW0ueFZhbHVlMCwgeFNjYWxlKTtcbiAgICBjb25zdCB5MCA9IHNjYWxlKHNwYW5EYXR1bS55VmFsdWUwLCB5U2NhbGUpO1xuICAgIGNvbnN0IHgxID0gc2NhbGUoc3BhbkRhdHVtLnhWYWx1ZTEsIHhTY2FsZSk7XG4gICAgY29uc3QgeTEgPSBzY2FsZShzcGFuRGF0dW0ueVZhbHVlMSwgeVNjYWxlKTtcbiAgICBjb25zdCBzdGFydElzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHgwKTtcbiAgICBjb25zdCBlbmRJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSh4MSk7XG4gICAgaWYgKHN0YXJ0SXNGaW5pdGUgJiYgZW5kSXNGaW5pdGUgJiYgcmFuZ2VTcGFuRGF0YSA9PSBudWxsKSB7XG4gICAgICBjb25zdCB1bnNoaWZ0ZWQgPSBzcGFuRGF0dW0uc3BhbjtcbiAgICAgIGNvbnN0IHNoaWZ0ZWQgPSByZXNjYWxlU3Bhbih1bnNoaWZ0ZWQsIHsgeDogeDAsIHk6IHkwIH0sIHsgeDogeDEsIHk6IHkxIH0pO1xuICAgICAgY29uc3Qgc3BhblRyYW5zZm9ybSA9IHsgdW5zaGlmdGVkLCBzaGlmdGVkIH07XG4gICAgICBzaGlmdGVkWFN0YXJ0ID0gTWF0aC5taW4oc2hpZnRlZFhTdGFydCwgeDApO1xuICAgICAgc2hpZnRlZFhFbmQgPSBNYXRoLm1heChzaGlmdGVkWEVuZCwgeDEpO1xuICAgICAgaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucy5wdXNoKHNwYW5UcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRJc0Zpbml0ZSAmJiAhZW5kSXNGaW5pdGUgJiYgcmFuZ2VTcGFuRGF0YSA9PSBudWxsKSB7XG4gICAgICByYW5nZVNwYW5EYXRhID0gW3NwYW5EYXR1bV07XG4gICAgfSBlbHNlIGlmICghc3RhcnRJc0Zpbml0ZSAmJiAhZW5kSXNGaW5pdGUgJiYgcmFuZ2VTcGFuRGF0YSAhPSBudWxsKSB7XG4gICAgICBpZiAocmFuZ2VTcGFuRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHJhbmdlU3BhbkRhdGEucHVzaChzcGFuRGF0dW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0YXJ0SXNGaW5pdGUgJiYgZW5kSXNGaW5pdGUgJiYgcmFuZ2VTcGFuRGF0YSAhPSBudWxsKSB7XG4gICAgICByYW5nZVNwYW5EYXRhLnB1c2goc3BhbkRhdHVtKTtcbiAgICAgIGNvbnN0IHN0YXJ0U3BhbkRhdHVtID0gcmFuZ2VTcGFuRGF0YS5hdCgwKTtcbiAgICAgIGNvbnN0IGVuZFNwYW5EYXR1bSA9IHJhbmdlU3BhbkRhdGEuYXQoLTEpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtU3RhcnQgPSB7XG4gICAgICAgIHg6IHNjYWxlKHN0YXJ0U3BhbkRhdHVtLnhWYWx1ZTAsIHhTY2FsZSksXG4gICAgICAgIHk6IHNjYWxlKHN0YXJ0U3BhbkRhdHVtLnlWYWx1ZTAsIHlTY2FsZSlcbiAgICAgIH07XG4gICAgICBjb25zdCB0cmFuc2Zvcm1FbmQgPSB7XG4gICAgICAgIHg6IHNjYWxlKGVuZFNwYW5EYXR1bS54VmFsdWUxLCB4U2NhbGUpLFxuICAgICAgICB5OiBzY2FsZShlbmRTcGFuRGF0dW0ueVZhbHVlMSwgeVNjYWxlKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAodHJhbnNmb3JtRW5kLnggLSB0cmFuc2Zvcm1TdGFydC54KSAvIChyYW5nZVNwYW5EYXRhLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZVNwYW5EYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHsgc3BhbjogaW50ZXJwb2xhdGluZ1Vuc2hpZnRlZCwgeVZhbHVlMCwgeVZhbHVlMSB9ID0gcmFuZ2VTcGFuRGF0YVtpXTtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGluZ1NoaWZ0ZWQgPSByZXNjYWxlU3BhbihcbiAgICAgICAgICBpbnRlcnBvbGF0aW5nVW5zaGlmdGVkLFxuICAgICAgICAgIHsgeDogdHJhbnNmb3JtU3RhcnQueCArIHN0ZXAgKiAoaSArIDApLCB5OiBzY2FsZSh5VmFsdWUwLCB5U2NhbGUpIH0sXG4gICAgICAgICAgeyB4OiB0cmFuc2Zvcm1TdGFydC54ICsgc3RlcCAqIChpICsgMSksIHk6IHNjYWxlKHlWYWx1ZTEsIHlTY2FsZSkgfVxuICAgICAgICApO1xuICAgICAgICBpbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zLnB1c2goeyB1bnNoaWZ0ZWQ6IGludGVycG9sYXRpbmdVbnNoaWZ0ZWQsIHNoaWZ0ZWQ6IGludGVycG9sYXRpbmdTaGlmdGVkIH0pO1xuICAgICAgfVxuICAgICAgc2hpZnRlZFhTdGFydCA9IE1hdGgubWluKHNoaWZ0ZWRYU3RhcnQsIHRyYW5zZm9ybVN0YXJ0LngpO1xuICAgICAgc2hpZnRlZFhFbmQgPSBNYXRoLm1heChzaGlmdGVkWEVuZCwgdHJhbnNmb3JtRW5kLngpO1xuICAgICAgcmFuZ2VTcGFuRGF0YSA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydElzRmluaXRlICYmIGVuZElzRmluaXRlICYmIHJhbmdlU3BhbkRhdGEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgdW5zaGlmdGVkID0gc3BhbkRhdHVtLnNwYW47XG4gICAgICBjb25zdCBzaGlmdGVkID0gcmVzY2FsZVNwYW4odW5zaGlmdGVkLCB7IHg6IHgxLCB5OiB5MCB9LCB7IHg6IHgxLCB5OiB5MSB9KTtcbiAgICAgIGludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMucHVzaCh7IHVuc2hpZnRlZCwgc2hpZnRlZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VTcGFuRGF0YSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKHJhbmdlU3BhbkRhdGEgIT0gbnVsbCkge1xuICAgIGNvbnN0IHN0YXJ0U3BhbkRhdHVtID0gcmFuZ2VTcGFuRGF0YS5hdCgwKTtcbiAgICBjb25zdCB4ID0gc2NhbGUoc3RhcnRTcGFuRGF0dW0ueFZhbHVlMCwgeFNjYWxlKTtcbiAgICBmb3IgKGNvbnN0IHsgc3BhbjogaW50ZXJwb2xhdGluZ1Vuc2hpZnRlZCwgeVZhbHVlMCwgeVZhbHVlMSB9IG9mIHJhbmdlU3BhbkRhdGEpIHtcbiAgICAgIGNvbnN0IGludGVycG9sYXRpbmdTaGlmdGVkID0gcmVzY2FsZVNwYW4oXG4gICAgICAgIGludGVycG9sYXRpbmdVbnNoaWZ0ZWQsXG4gICAgICAgIHsgeCwgeTogc2NhbGUoeVZhbHVlMCwgeVNjYWxlKSB9LFxuICAgICAgICB7IHgsIHk6IHNjYWxlKHlWYWx1ZTEsIHlTY2FsZSkgfVxuICAgICAgKTtcbiAgICAgIGludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMucHVzaCh7IHVuc2hpZnRlZDogaW50ZXJwb2xhdGluZ1Vuc2hpZnRlZCwgc2hpZnRlZDogaW50ZXJwb2xhdGluZ1NoaWZ0ZWQgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNoaWZ0ZWRYUmFuZ2UgPSBbc2hpZnRlZFhTdGFydCwgc2hpZnRlZFhFbmRdO1xuICByZXR1cm4geyBpbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zLCBzaGlmdGVkWFJhbmdlIH07XG59XG5mdW5jdGlvbiBwYWlyVXBTcGFucyhuZXdEYXRhLCBvbGREYXRhLCBzcGxpdE1vZGUpIHtcbiAgY29uc3Qgb2xkU3BhbnMgPSB0cmFuc2Zvcm1TcGFucyhvbGREYXRhLmRhdGEsIG5ld0RhdGEuc2NhbGVzKTtcbiAgY29uc3QgbmV3U3BhbnMgPSB0cmFuc2Zvcm1TcGFucyhuZXdEYXRhLmRhdGEsIG9sZERhdGEuc2NhbGVzKTtcbiAgY29uc3QgW29sZFJhbmdlU3RhcnROZXdTY2FsZSwgb2xkUmFuZ2VFbmROZXdTY2FsZV0gPSBvbGRTcGFucy5zaGlmdGVkWFJhbmdlO1xuICBjb25zdCBbbmV3UmFuZ2VTdGFydE9sZFNjYWxlLCBuZXdSYW5nZUVuZE9sZFNjYWxlXSA9IG5ld1NwYW5zLnNoaWZ0ZWRYUmFuZ2U7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgY29uc3QgbW92ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBvbGRTcGFuRGF0dW0gb2Ygb2xkU3BhbnMuaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucykge1xuICAgIGNvbnN0IG9sZFNwYW5PbGRTY2FsZSA9IG9sZFNwYW5EYXR1bS51bnNoaWZ0ZWQ7XG4gICAgY29uc3Qgb2xkU3Bhbk5ld1NjYWxlID0gb2xkU3BhbkRhdHVtLnNoaWZ0ZWQ7XG4gICAgY29uc3QgW3sgeDogZnJvbVN0YXJ0T2xkU2NhbGUsIHk6IGZyb21TdGFydE9sZFNjYWxlWSB9LCB7IHg6IGZyb21FbmRPbGRTY2FsZSwgeTogZnJvbUVuZE9sZFNjYWxlWSB9XSA9IHNwYW5SYW5nZShvbGRTcGFuT2xkU2NhbGUpO1xuICAgIGxldCBoYXNDb3JyZXNwb25kaW5nU3BhbiA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgbmV3U3BhbkRhdHVtIG9mIG5ld1NwYW5zLmludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMpIHtcbiAgICAgIGNvbnN0IG5ld1NwYW5PbGRTY2FsZSA9IG5ld1NwYW5EYXR1bS5zaGlmdGVkO1xuICAgICAgY29uc3QgbmV3U3Bhbk5ld1NjYWxlID0gbmV3U3BhbkRhdHVtLnVuc2hpZnRlZDtcbiAgICAgIGNvbnN0IFt7IHg6IHRvU3RhcnRPbGRTY2FsZSB9LCB7IHg6IHRvRW5kT2xkU2NhbGUgfV0gPSBzcGFuUmFuZ2UobmV3U3Bhbk9sZFNjYWxlKTtcbiAgICAgIGlmIChjbG9zZUNtcChmcm9tU3RhcnRPbGRTY2FsZSwgdG9FbmRPbGRTY2FsZSkgIT09IC0xIHx8IGNsb3NlQ21wKGZyb21FbmRPbGRTY2FsZSwgdG9TdGFydE9sZFNjYWxlKSAhPT0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZU1hdGNoMihmcm9tU3RhcnRPbGRTY2FsZSwgdG9TdGFydE9sZFNjYWxlKSAmJiBjbG9zZU1hdGNoMihmcm9tRW5kT2xkU2NhbGUsIHRvRW5kT2xkU2NhbGUpKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW5PbGRTY2FsZSwgdG86IG9sZFNwYW5PbGRTY2FsZSB9KTtcbiAgICAgICAgbW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW5PbGRTY2FsZSwgdG86IG5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbVN0YXJ0T2xkU2NhbGUgPD0gdG9TdGFydE9sZFNjYWxlICYmIGZyb21FbmRPbGRTY2FsZSA+PSB0b0VuZE9sZFNjYWxlKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW5PbGRTY2FsZSwgdG86IG9sZFNwYW5PbGRTY2FsZSB9KTtcbiAgICAgICAgbW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW5PbGRTY2FsZSwgdG86IG9sZFNwYW5OZXdTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFt7IHg6IGZyb21TdGFydE5ld1NjYWxlIH0sIHsgeDogZnJvbUVuZE5ld1NjYWxlIH1dID0gc3BhblJhbmdlKG9sZFNwYW5OZXdTY2FsZSk7XG4gICAgICAgIGNvbnN0IFt7IHg6IHRvU3RhcnROZXdTY2FsZSB9LCB7IHg6IHRvRW5kTmV3U2NhbGUgfV0gPSBzcGFuUmFuZ2UobmV3U3Bhbk5ld1NjYWxlKTtcbiAgICAgICAgY29uc3QgeFJhbmdlU3RhcnRPbGRTY2FsZSA9IE1hdGgubWF4KGZyb21TdGFydE9sZFNjYWxlLCB0b1N0YXJ0T2xkU2NhbGUpO1xuICAgICAgICBjb25zdCB4UmFuZ2VFbmRPbGRTY2FsZSA9IE1hdGgubWluKGZyb21FbmRPbGRTY2FsZSwgdG9FbmRPbGRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUgPSBjbGlwU3Bhblgob2xkU3Bhbk9sZFNjYWxlLCB4UmFuZ2VTdGFydE9sZFNjYWxlLCB4UmFuZ2VFbmRPbGRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNsaXBwZWROZXdTcGFuT2xkU2NhbGUgPSBjbGlwU3BhblgobmV3U3Bhbk9sZFNjYWxlLCB4UmFuZ2VTdGFydE9sZFNjYWxlLCB4UmFuZ2VFbmRPbGRTY2FsZSk7XG4gICAgICAgIGNvbnN0IHhSYW5nZVN0YXJ0TmV3U2NhbGUgPSBNYXRoLm1heChmcm9tU3RhcnROZXdTY2FsZSwgdG9TdGFydE5ld1NjYWxlKTtcbiAgICAgICAgY29uc3QgeFJhbmdlRW5kTmV3U2NhbGUgPSBNYXRoLm1pbihmcm9tRW5kTmV3U2NhbGUsIHRvRW5kTmV3U2NhbGUpO1xuICAgICAgICBjb25zdCBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlID0gY2xpcFNwYW5YKG5ld1NwYW5OZXdTY2FsZSwgeFJhbmdlU3RhcnROZXdTY2FsZSwgeFJhbmdlRW5kTmV3U2NhbGUpO1xuICAgICAgICByZW1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5PbGRTY2FsZSB9KTtcbiAgICAgICAgbW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWROZXdTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgfVxuICAgICAgaGFzQ29ycmVzcG9uZGluZ1NwYW4gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzQ29ycmVzcG9uZGluZ1NwYW4pXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoY2xvc2VDbXAoZnJvbUVuZE9sZFNjYWxlLCBuZXdSYW5nZVN0YXJ0T2xkU2NhbGUpICE9PSAxKSB7XG4gICAgICByZW1vdmVkLnB1c2goe1xuICAgICAgICBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsXG4gICAgICAgIHRvOiByZXNjYWxlU3BhbihcbiAgICAgICAgICBvbGRTcGFuT2xkU2NhbGUsXG4gICAgICAgICAgeyB4OiBuZXdSYW5nZVN0YXJ0T2xkU2NhbGUsIHk6IGZyb21TdGFydE9sZFNjYWxlWSB9LFxuICAgICAgICAgIHsgeDogbmV3UmFuZ2VTdGFydE9sZFNjYWxlLCB5OiBmcm9tRW5kT2xkU2NhbGVZIH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjbG9zZUNtcChmcm9tU3RhcnRPbGRTY2FsZSwgbmV3UmFuZ2VFbmRPbGRTY2FsZSkgIT09IC0xKSB7XG4gICAgICByZW1vdmVkLnB1c2goe1xuICAgICAgICBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsXG4gICAgICAgIHRvOiByZXNjYWxlU3BhbihcbiAgICAgICAgICBvbGRTcGFuT2xkU2NhbGUsXG4gICAgICAgICAgeyB4OiBuZXdSYW5nZUVuZE9sZFNjYWxlLCB5OiBmcm9tU3RhcnRPbGRTY2FsZVkgfSxcbiAgICAgICAgICB7IHg6IG5ld1JhbmdlRW5kT2xkU2NhbGUsIHk6IGZyb21FbmRPbGRTY2FsZVkgfVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gMCAvKiBaZXJvICovKSB7XG4gICAgICBjb25zdCB5ID0gc2NhbGUoMCwgb2xkRGF0YS5zY2FsZXMueSk7XG4gICAgICByZW1vdmVkLnB1c2goe1xuICAgICAgICBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsXG4gICAgICAgIHRvOiByZXNjYWxlU3BhbihvbGRTcGFuT2xkU2NhbGUsIHsgeDogZnJvbVN0YXJ0T2xkU2NhbGUsIHkgfSwgeyB4OiBmcm9tRW5kT2xkU2NhbGUsIHkgfSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSAxIC8qIERpdmlkZSAqLykge1xuICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHNwbGl0U3BhbkF0WChvbGRTcGFuT2xkU2NhbGUsIChmcm9tU3RhcnRPbGRTY2FsZSArIGZyb21FbmRPbGRTY2FsZSkgLyAyKTtcbiAgICAgIHJlbW92ZWQucHVzaChcbiAgICAgICAgeyBmcm9tOiBsZWZ0LCB0bzogY29sbGFwc2VTcGFuVG9Qb2ludChsZWZ0LCB7IHg6IGZyb21TdGFydE9sZFNjYWxlLCB5OiBmcm9tU3RhcnRPbGRTY2FsZVkgfSkgfSxcbiAgICAgICAgeyBmcm9tOiByaWdodCwgdG86IGNvbGxhcHNlU3BhblRvUG9pbnQocmlnaHQsIHsgeDogZnJvbUVuZE9sZFNjYWxlLCB5OiBmcm9tRW5kT2xkU2NhbGVZIH0pIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGZvciAoY29uc3QgbmV3U3BhbkRhdHVtIG9mIG5ld0RhdGEuZGF0YSkge1xuICAgIGNvbnN0IG5ld1NwYW5OZXdTY2FsZSA9IG5ld1NwYW5EYXR1bS5zcGFuO1xuICAgIGNvbnN0IFt7IHg6IHRvU3RhcnROZXdTY2FsZSwgeTogdG9TdGFydE5ld1NjYWxlWSB9LCB7IHg6IHRvRW5kTmV3U2NhbGUsIHk6IHRvRW5kTmV3U2NhbGVZIH1dID0gc3BhblJhbmdlKG5ld1NwYW5OZXdTY2FsZSk7XG4gICAgbGV0IGhhc0NvcnJlc3BvbmRpbmdTcGFuID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBvbGRTcGFuRGF0dW0gb2Ygb2xkU3BhbnMuaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucykge1xuICAgICAgY29uc3Qgb2xkU3Bhbk5ld1NjYWxlID0gb2xkU3BhbkRhdHVtLnNoaWZ0ZWQ7XG4gICAgICBjb25zdCBbeyB4OiBmcm9tU3RhcnROZXdTY2FsZSB9LCB7IHg6IGZyb21FbmROZXdTY2FsZSB9XSA9IHNwYW5SYW5nZShvbGRTcGFuTmV3U2NhbGUpO1xuICAgICAgaWYgKGNsb3NlQ21wKGZyb21TdGFydE5ld1NjYWxlLCB0b0VuZE5ld1NjYWxlKSAhPT0gLTEgfHwgY2xvc2VDbXAoZnJvbUVuZE5ld1NjYWxlLCB0b1N0YXJ0TmV3U2NhbGUpICE9PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNsb3NlTWF0Y2gyKGZyb21TdGFydE5ld1NjYWxlLCB0b1N0YXJ0TmV3U2NhbGUpICYmIGNsb3NlTWF0Y2gyKGZyb21FbmROZXdTY2FsZSwgdG9FbmROZXdTY2FsZSkpIHtcbiAgICAgICAgYWRkZWQucHVzaCh7IGZyb206IG5ld1NwYW5OZXdTY2FsZSwgdG86IG5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbVN0YXJ0TmV3U2NhbGUgPD0gdG9TdGFydE5ld1NjYWxlICYmIGZyb21FbmROZXdTY2FsZSA+PSB0b0VuZE5ld1NjYWxlKSB7XG4gICAgICAgIGNvbnN0IGNsaXBwZWRPbGRTcGFuTmV3U2NhbGUgPSBjbGlwU3Bhblgob2xkU3Bhbk5ld1NjYWxlLCB0b1N0YXJ0TmV3U2NhbGUsIHRvRW5kTmV3U2NhbGUpO1xuICAgICAgICBhZGRlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5OZXdTY2FsZSwgdG86IG5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZGVkLnB1c2goeyBmcm9tOiBuZXdTcGFuTmV3U2NhbGUsIHRvOiBuZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICB9XG4gICAgICBoYXNDb3JyZXNwb25kaW5nU3BhbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChoYXNDb3JyZXNwb25kaW5nU3BhbilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChjbG9zZUNtcCh0b0VuZE5ld1NjYWxlLCBvbGRSYW5nZVN0YXJ0TmV3U2NhbGUpICE9PSAxKSB7XG4gICAgICBhZGRlZC5wdXNoKHtcbiAgICAgICAgZnJvbTogcmVzY2FsZVNwYW4oXG4gICAgICAgICAgbmV3U3Bhbk5ld1NjYWxlLFxuICAgICAgICAgIHsgeDogb2xkUmFuZ2VTdGFydE5ld1NjYWxlLCB5OiB0b1N0YXJ0TmV3U2NhbGVZIH0sXG4gICAgICAgICAgeyB4OiBvbGRSYW5nZVN0YXJ0TmV3U2NhbGUsIHk6IHRvRW5kTmV3U2NhbGVZIH1cbiAgICAgICAgKSxcbiAgICAgICAgdG86IG5ld1NwYW5OZXdTY2FsZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjbG9zZUNtcCh0b1N0YXJ0TmV3U2NhbGUsIG9sZFJhbmdlRW5kTmV3U2NhbGUpICE9PSAtMSkge1xuICAgICAgYWRkZWQucHVzaCh7XG4gICAgICAgIGZyb206IHJlc2NhbGVTcGFuKFxuICAgICAgICAgIG5ld1NwYW5OZXdTY2FsZSxcbiAgICAgICAgICB7IHg6IG9sZFJhbmdlRW5kTmV3U2NhbGUsIHk6IHRvU3RhcnROZXdTY2FsZVkgfSxcbiAgICAgICAgICB7IHg6IG9sZFJhbmdlRW5kTmV3U2NhbGUsIHk6IHRvRW5kTmV3U2NhbGVZIH1cbiAgICAgICAgKSxcbiAgICAgICAgdG86IG5ld1NwYW5OZXdTY2FsZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IDAgLyogWmVybyAqLykge1xuICAgICAgY29uc3QgeSA9IHNjYWxlKDAsIG5ld0RhdGEuc2NhbGVzLnkpO1xuICAgICAgYWRkZWQucHVzaCh7XG4gICAgICAgIGZyb206IHJlc2NhbGVTcGFuKG5ld1NwYW5OZXdTY2FsZSwgeyB4OiB0b1N0YXJ0TmV3U2NhbGUsIHkgfSwgeyB4OiB0b0VuZE5ld1NjYWxlLCB5IH0pLFxuICAgICAgICB0bzogbmV3U3Bhbk5ld1NjYWxlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gMSAvKiBEaXZpZGUgKi8pIHtcbiAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBzcGxpdFNwYW5BdFgobmV3U3Bhbk5ld1NjYWxlLCAodG9TdGFydE5ld1NjYWxlICsgdG9FbmROZXdTY2FsZSkgLyAyKTtcbiAgICAgIGFkZGVkLnB1c2goXG4gICAgICAgIHsgZnJvbTogY29sbGFwc2VTcGFuVG9Qb2ludChsZWZ0LCB7IHg6IHRvU3RhcnROZXdTY2FsZSwgeTogdG9TdGFydE5ld1NjYWxlWSB9KSwgdG86IG5ld1NwYW5OZXdTY2FsZSB9LFxuICAgICAgICB7IGZyb206IGNvbGxhcHNlU3BhblRvUG9pbnQocmlnaHQsIHsgeDogdG9FbmROZXdTY2FsZSwgeTogdG9FbmROZXdTY2FsZVkgfSksIHRvOiBuZXdTcGFuTmV3U2NhbGUgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgYWRkZWQsIG1vdmVkLCByZW1vdmVkIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVV0aWwudHNcbnZhciBBcmVhU2VyaWVzVGFnID0gLyogQF9fUFVSRV9fICovICgoQXJlYVNlcmllc1RhZzIpID0+IHtcbiAgQXJlYVNlcmllc1RhZzJbQXJlYVNlcmllc1RhZzJbXCJGaWxsXCJdID0gMF0gPSBcIkZpbGxcIjtcbiAgQXJlYVNlcmllc1RhZzJbQXJlYVNlcmllc1RhZzJbXCJTdHJva2VcIl0gPSAxXSA9IFwiU3Ryb2tlXCI7XG4gIEFyZWFTZXJpZXNUYWcyW0FyZWFTZXJpZXNUYWcyW1wiTWFya2VyXCJdID0gMl0gPSBcIk1hcmtlclwiO1xuICBBcmVhU2VyaWVzVGFnMltBcmVhU2VyaWVzVGFnMltcIkxhYmVsXCJdID0gM10gPSBcIkxhYmVsXCI7XG4gIHJldHVybiBBcmVhU2VyaWVzVGFnMjtcbn0pKEFyZWFTZXJpZXNUYWcgfHwge30pO1xuZnVuY3Rpb24gcGxvdFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMsIHBoYW50b21TcGFucykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgc3BhbiA9IHNwYW5zW2ldO1xuICAgIGNvbnN0IHBoYW50b21TcGFuID0gcGhhbnRvbVNwYW5zW2ldO1xuICAgIHBsb3RTcGFuKHBhdGgucGF0aCwgaW50ZXJwb2xhdGVTcGFucyhzcGFuLmZyb20sIHNwYW4udG8sIHJhdGlvMiksIDEgLyogTW92ZVRvICovKTtcbiAgICBwbG90U3BhbihwYXRoLnBhdGgsIHJldmVyc2VTcGFuKGludGVycG9sYXRlU3BhbnMocGhhbnRvbVNwYW4uZnJvbSwgcGhhbnRvbVNwYW4udG8sIHJhdGlvMikpLCAyIC8qIExpbmVUbyAqLyk7XG4gICAgcGF0aC5wYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb25GbnMoc3RhdHVzLCBzcGFucywgcGhhbnRvbVNwYW5zLCB2aXNpYmxlVG9nZ2xlTW9kZSkge1xuICBjb25zdCByZW1vdmVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMucmVtb3ZlZCwgcGhhbnRvbVNwYW5zLnJlbW92ZWQpO1xuICBjb25zdCB1cGRhdGVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMubW92ZWQsIHBoYW50b21TcGFucy5tb3ZlZCk7XG4gIGNvbnN0IGFkZFBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90U3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5hZGRlZCwgcGhhbnRvbVNwYW5zLmFkZGVkKTtcbiAgY29uc3QgcGF0aFByb3BlcnRpZXMgPSBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKTtcbiAgcmV0dXJuIHsgc3RhdHVzLCBwYXRoOiB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSwgcGF0aFByb3BlcnRpZXMgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBkaWZmMikge1xuICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSBuZXdEYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGNvbnN0IHdhc0NhdGVnb3J5QmFzZWQgPSBvbGREYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGlmIChpc0NhdGVnb3J5QmFzZWQgIT09IHdhc0NhdGVnb3J5QmFzZWQgfHwgIWlzU2NhbGVWYWxpZChuZXdEYXRhLnNjYWxlcy54KSB8fCAhaXNTY2FsZVZhbGlkKG9sZERhdGEuc2NhbGVzLngpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgaWYgKG9sZERhdGEudmlzaWJsZSAmJiAhbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gIH0gZWxzZSBpZiAoIW9sZERhdGEudmlzaWJsZSAmJiBuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH1cbiAgY29uc3Qgc3BhbnMgPSBwYWlyVXBTcGFucyhcbiAgICB7IHNjYWxlczogbmV3RGF0YS5zY2FsZXMsIGRhdGE6IG5ld0RhdGEuZmlsbERhdGEuc3BhbnMsIHZpc2libGU6IG5ld0RhdGEudmlzaWJsZSB9LFxuICAgIHsgc2NhbGVzOiBvbGREYXRhLnNjYWxlcywgZGF0YTogb2xkRGF0YS5maWxsRGF0YS5zcGFucywgdmlzaWJsZTogb2xkRGF0YS52aXNpYmxlIH0sXG4gICAgMCAvKiBaZXJvICovXG4gICk7XG4gIGNvbnN0IHBoYW50b21TcGFucyA9IHBhaXJVcFNwYW5zKFxuICAgIHsgc2NhbGVzOiBuZXdEYXRhLnNjYWxlcywgZGF0YTogbmV3RGF0YS5maWxsRGF0YS5waGFudG9tU3BhbnMsIHZpc2libGU6IG5ld0RhdGEudmlzaWJsZSB9LFxuICAgIHsgc2NhbGVzOiBvbGREYXRhLnNjYWxlcywgZGF0YTogb2xkRGF0YS5maWxsRGF0YS5waGFudG9tU3BhbnMsIHZpc2libGU6IG9sZERhdGEudmlzaWJsZSB9LFxuICAgIDAgLyogWmVybyAqL1xuICApO1xuICBjb25zdCBwcmVwYXJlTWFya2VyUGFpcnMgPSAoKSA9PiB7XG4gICAgaWYgKGlzQ2F0ZWdvcnlCYXNlZCkge1xuICAgICAgcmV0dXJuIHBhaXJDYXRlZ29yeURhdGEobmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIsIHsgYmFja2ZpbGxTcGxpdE1vZGU6IFwic3RhdGljXCIsIG11bHRpRGF0dW06IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYWlyQ29udGludW91c0RhdGEobmV3RGF0YSwgb2xkRGF0YSwgeyBiYWNrZmlsbFNwbGl0TW9kZTogXCJzdGF0aWNcIiB9KTtcbiAgfTtcbiAgY29uc3QgeyByZXN1bHRNYXA6IG1hcmtlclBhaXJNYXAgfSA9IHByZXBhcmVNYXJrZXJQYWlycygpO1xuICBpZiAobWFya2VyUGFpck1hcCA9PT0gdm9pZCAwKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc3RhY2tWaXNpYmxlID0gdHJ1ZTtcbiAgY29uc3QgZmFkZU1vZGUgPSBzdGFja1Zpc2libGUgPyBcIm5vbmVcIiA6IFwiZmFkZVwiO1xuICBjb25zdCBmaWxsID0gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uRm5zKHN0YXR1cywgc3BhbnMsIHBoYW50b21TcGFucywgZmFkZU1vZGUpO1xuICBjb25zdCBtYXJrZXIgPSBwcmVwYXJlTWFya2VyQW5pbWF0aW9uKG1hcmtlclBhaXJNYXAsIHN0YXR1cyk7XG4gIHJldHVybiB7IHN0YXR1cywgZmlsbCwgbWFya2VyIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllcy50c1xudmFyIEFyZWFTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXCJmaWxsXCIsIFwic3Ryb2tlXCJdLFxuICAgICAgcGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldDogWzAsIDFlM10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgcGlja01vZGVzOiBbMSAvKiBORUFSRVNUX0JZX01BSU5fQVhJU19GSVJTVCAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBwYXRoOiBidWlsZFJlc2V0UGF0aEZuKHsgZ2V0VmlzaWJsZTogKCkgPT4gdGhpcy52aXNpYmxlLCBnZXRPcGFjaXR5OiAoKSA9PiB0aGlzLmdldE9wYWNpdHkoKSB9KSxcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcbiAgICAgICAgbWFya2VyOiAobm9kZSwgZGF0dW0pID0+ICh7IC4uLnJlc2V0TWFya2VyRm4obm9kZSksIC4uLnJlc2V0TWFya2VyUG9zaXRpb25Gbihub2RlLCBkYXR1bSkgfSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgQXJlYVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEsIHZpc2libGUsIHNlcmllc0dyb3VwaW5nOiB7IGdyb3VwSW5kZXggPSB0aGlzLmlkLCBzdGFja0NvdW50ID0gMSB9ID0ge30gfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBjb25uZWN0TWlzc2luZ0RhdGEsIG5vcm1hbGl6ZWRUbyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjdXJyZW50SWRzID0ge1xuICAgICAgdmFsdWU6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlYCxcbiAgICAgIHZhbHVlczogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYCxcbiAgICAgIHN0YWNrOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZS1zdGFja2AsXG4gICAgICBtYXJrZXI6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy1tYXJrZXJgXG4gICAgfTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGlzRGVmaW5lZChub3JtYWxpemVkVG8pKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2gobm9ybWFsaXNlR3JvdXBUbyhPYmplY3QudmFsdWVzKGN1cnJlbnRJZHMpLCBub3JtYWxpemVkVG8sIFwicmFuZ2VcIikpO1xuICAgIH1cbiAgICBpZiAoIWlzQ29udGludW91c1ggJiYgYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbiA9IHsgaW52YWxpZFZhbHVlOiBudWxsIH07XG4gICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiBzdGFja0NvdW50ID4gMSkge1xuICAgICAgY29tbW9uLmludmFsaWRWYWx1ZSA9IDA7XG4gICAgfVxuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgY29tbW9uLmZvcmNlVmFsdWUgPSAwO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieFZhbHVlXCIgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZVJhd2AsIC4uLmNvbW1vbiB9KSxcbiAgICAgICAgLi4uZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgeVZhbHVlU3RhY2tgLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICBncm91cElkOiBjdXJyZW50SWRzLnN0YWNrXG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYHlWYWx1ZWAsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIGdyb3VwSWQ6IGN1cnJlbnRJZHMudmFsdWVcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93XCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWVFbmRgLFxuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgZ3JvdXBJZDogY3VycmVudElkcy52YWx1ZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZUN1bXVsYXRpdmVgLFxuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgZ3JvdXBJZDogY3VycmVudElkcy5tYXJrZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXSxcbiAgICAgIGdyb3VwQnlLZXlzOiB0cnVlLFxuICAgICAgZ3JvdXBCeURhdGE6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGF4ZXMgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IGtleURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IGtleXMgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcImtleVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5RXh0ZW50ID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlRW5kYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBpZiAoa2V5RGVmPy5kZWYudHlwZSA9PT0gXCJrZXlcIiAmJiBrZXlEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGtleXMpLCB4QXhpcyk7XG4gICAgfSBlbHNlIGlmICh5QXhpcyBpbnN0YW5jZW9mIExvZ0F4aXMgfHwgeUF4aXMgaW5zdGFuY2VvZiBUaW1lQXhpcykge1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeUV4dGVudCwgeUF4aXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXhlZFlFeHRlbnQgPSBbeUV4dGVudFswXSA+IDAgPyAwIDogeUV4dGVudFswXSwgeUV4dGVudFsxXSA8IDAgPyAwIDogeUV4dGVudFsxXV07XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChmaXhlZFlFeHRlbnQsIHlBeGlzKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBheGVzLCBkYXRhLCBwcm9jZXNzZWREYXRhOiB7IGRhdGE6IGdyb3VwZWREYXRhIH0gPSB7fSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF4QXhpcyB8fCAheUF4aXMgfHwgIWRhdGEgfHwgIWRhdGFNb2RlbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB5S2V5LFxuICAgICAgeEtleSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxhYmVsLFxuICAgICAgZmlsbDogc2VyaWVzRmlsbCxcbiAgICAgIHN0cm9rZTogc2VyaWVzU3Ryb2tlLFxuICAgICAgY29ubmVjdE1pc3NpbmdEYXRhXG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNjYWxlOiB4U2NhbGUgfSA9IHhBeGlzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHlTY2FsZSB9ID0geUF4aXM7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNZIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IGRlZnMgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzQnlJZHModGhpcywgW2B5VmFsdWVFbmRgLCBgeVZhbHVlUmF3YCwgYHlWYWx1ZUN1bXVsYXRpdmVgXSk7XG4gICAgY29uc3QgeVZhbHVlU3RhY2tJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBcInlWYWx1ZVN0YWNrXCIpO1xuICAgIGNvbnN0IGNyZWF0ZU1hcmtlckNvb3JkaW5hdGUgPSAoeERhdHVtLCB5RW5kLCByYXdZRGF0dW0pID0+IHtcbiAgICAgIGxldCBjdXJyWTtcbiAgICAgIGlmIChpc0RlZmluZWQodGhpcy5wcm9wZXJ0aWVzLm5vcm1hbGl6ZWRUbykgPyBpc0NvbnRpbnVvdXNZICYmIGlzQ29udGludW91cyhyYXdZRGF0dW0pIDogIWlzTmFOKHJhd1lEYXR1bSkpIHtcbiAgICAgICAgY3VyclkgPSB5RW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQsXG4gICAgICAgIHk6IHlTY2FsZS5jb252ZXJ0KGN1cnJZKSxcbiAgICAgICAgc2l6ZTogbWFya2VyLnNpemVcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpdGVtSWQgPSB5S2V5O1xuICAgIGNvbnN0IGxhYmVsRGF0YSA9IFtdO1xuICAgIGNvbnN0IG1hcmtlckRhdGEgPSBbXTtcbiAgICBjb25zdCB7IHZpc2libGVTYW1lU3RhY2tDb3VudCB9ID0gdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmdldFZpc2libGVQZWVyR3JvdXBJbmRleCh0aGlzKTtcbiAgICBsZXQgZGF0dW1JZHggPSAtMTtcbiAgICBncm91cGVkRGF0YT8uZm9yRWFjaCgoZGF0dW1Hcm91cCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlzLFxuICAgICAgICBrZXlzOiBbeERhdHVtXSxcbiAgICAgICAgZGF0dW06IGRhdHVtQXJyYXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzQXJyYXlcbiAgICAgIH0gPSBkYXR1bUdyb3VwO1xuICAgICAgdmFsdWVzQXJyYXkuZm9yRWFjaCgodmFsdWVzLCB2YWx1ZUlkeCkgPT4ge1xuICAgICAgICBkYXR1bUlkeCsrO1xuICAgICAgICBjb25zdCBzZXJpZXNEYXR1bSA9IGRhdHVtQXJyYXlbdmFsdWVJZHhdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzMiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNWYWx1ZXMoZGVmcywgeyBrZXlzLCB2YWx1ZXMgfSk7XG4gICAgICAgIGNvbnN0IHsgeVZhbHVlUmF3OiB5RGF0dW0sIHlWYWx1ZUN1bXVsYXRpdmUsIHlWYWx1ZUVuZCB9ID0gZGF0YVZhbHVlczI7XG4gICAgICAgIGNvbnN0IHZhbGlkUG9pbnQgPSBOdW1iZXIuaXNGaW5pdGUoeURhdHVtKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVNYXJrZXJDb29yZGluYXRlKHhEYXR1bSwgK3lWYWx1ZUN1bXVsYXRpdmUsIHlEYXR1bSk7XG4gICAgICAgIGlmICh2YWxpZFBvaW50ICYmIG1hcmtlcikge1xuICAgICAgICAgIG1hcmtlckRhdGEucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogZGF0dW1JZHgsXG4gICAgICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgICAgICBpdGVtSWQsXG4gICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgICBtaWRQb2ludDogeyB4OiBwb2ludC54LCB5OiBwb2ludC55IH0sXG4gICAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlWYWx1ZUVuZCxcbiAgICAgICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgeEtleSxcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgZmlsbDogbWFya2VyLmZpbGwgPz8gc2VyaWVzRmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSA/PyBzZXJpZXNTdHJva2UsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZFBvaW50ICYmIGxhYmVsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHlEYXR1bSxcbiAgICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgICB4TmFtZTogdGhpcy5wcm9wZXJ0aWVzLnhOYW1lLFxuICAgICAgICAgICAgICB5TmFtZTogdGhpcy5wcm9wZXJ0aWVzLnlOYW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgPyB2YWx1ZS50b0ZpeGVkKDIpIDogU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGFiZWxEYXRhLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IGRhdHVtSWR4LFxuICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgIHk6IHBvaW50LnksXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxUZXh0ID8ge1xuICAgICAgICAgICAgICB0ZXh0OiBsYWJlbFRleHQsXG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICBmaWxsOiBsYWJlbC5jb2xvclxuICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCB7IGludGVycG9sYXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBpbnRlcnBvbGF0ZVBvaW50cyA9IChwb2ludHMpID0+IHtcbiAgICAgIGxldCBzcGFucztcbiAgICAgIGNvbnN0IHBvaW50c0l0ZXIgPSBwb2ludHMubWFwKChwb2ludCkgPT4gcG9pbnQucG9pbnQpO1xuICAgICAgc3dpdGNoIChpbnRlcnBvbGF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgICAgIHNwYW5zID0gbGluZWFyUG9pbnRzKHBvaW50c0l0ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic21vb3RoXCI6XG4gICAgICAgICAgc3BhbnMgPSBzbW9vdGhQb2ludHMocG9pbnRzSXRlciwgaW50ZXJwb2xhdGlvbi50ZW5zaW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgICAgICBzcGFucyA9IHN0ZXBQb2ludHMocG9pbnRzSXRlciwgaW50ZXJwb2xhdGlvbi5wb3NpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhbnMubWFwKChzcGFuLCBpKSA9PiAoe1xuICAgICAgICBzcGFuLFxuICAgICAgICB4VmFsdWUwOiBwb2ludHNbaV0ueERhdHVtLFxuICAgICAgICB5VmFsdWUwOiBwb2ludHNbaV0ueURhdHVtLFxuICAgICAgICB4VmFsdWUxOiBwb2ludHNbaSArIDFdLnhEYXR1bSxcbiAgICAgICAgeVZhbHVlMTogcG9pbnRzW2kgKyAxXS55RGF0dW1cbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHNwYW5zRm9yUG9pbnRzID0gKHBvaW50cykgPT4ge1xuICAgICAgcmV0dXJuIHBvaW50cy5mbGF0TWFwKChwKSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHApID8gaW50ZXJwb2xhdGVQb2ludHMocCkgOiBuZXcgQXJyYXkocC5za2lwKS5maWxsKG51bGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkYXRhVmFsdWVzID0gZ3JvdXBlZERhdGE/LmZsYXRNYXAoKGRhdHVtR3JvdXApID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5czogW3hEYXR1bV0sXG4gICAgICAgIHZhbHVlczogdmFsdWVzQXJyYXlcbiAgICAgIH0gPSBkYXR1bUdyb3VwO1xuICAgICAgcmV0dXJuIHZhbHVlc0FycmF5Lm1hcCgodmFsdWVzKSA9PiAoeyB4RGF0dW0sIHZhbHVlcyB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlUG9pbnQgPSAoeERhdHVtLCB5RGF0dW0pID0+ICh7XG4gICAgICBwb2ludDoge1xuICAgICAgICB4OiB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldCxcbiAgICAgICAgeTogeVNjYWxlLmNvbnZlcnQoeURhdHVtKVxuICAgICAgfSxcbiAgICAgIHhEYXR1bSxcbiAgICAgIHlEYXR1bVxuICAgIH0pO1xuICAgIGNvbnN0IGdldFNlcmllc1NwYW5zID0gKGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgIGlmIChkYXRhVmFsdWVzID09IG51bGwpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVZhbHVlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7IHhEYXR1bSwgdmFsdWVzIH0gPSBkYXRhVmFsdWVzW2ldO1xuICAgICAgICBjb25zdCB5VmFsdWVTdGFjayA9IHZhbHVlc1t5VmFsdWVTdGFja0luZGV4XTtcbiAgICAgICAgY29uc3QgeURhdHVtID0geVZhbHVlU3RhY2tbaW5kZXhdO1xuICAgICAgICBjb25zdCB5RGF0dW1Jc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSh5RGF0dW0pO1xuICAgICAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmICF5RGF0dW1Jc0Zpbml0ZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGFzdFlWYWx1ZVN0YWNrID0gZGF0YVZhbHVlc1tpIC0gMV0/LnZhbHVlc1t5VmFsdWVTdGFja0luZGV4XTtcbiAgICAgICAgY29uc3QgbmV4dFlWYWx1ZVN0YWNrID0gZGF0YVZhbHVlc1tpICsgMV0/LnZhbHVlc1t5VmFsdWVTdGFja0luZGV4XTtcbiAgICAgICAgbGV0IHlWYWx1ZUVuZEJhY2t3YXJkcyA9IDA7XG4gICAgICAgIGxldCB5VmFsdWVFbmRGb3J3YXJkcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGluZGV4OyBqICs9IDEpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHlWYWx1ZVN0YWNrW2pdO1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0V2FzRmluaXRlID0gbGFzdFlWYWx1ZVN0YWNrID09IG51bGwgfHwgTnVtYmVyLmlzRmluaXRlKGxhc3RZVmFsdWVTdGFja1tqXSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0V2FzRmluaXRlID0gbmV4dFlWYWx1ZVN0YWNrID09IG51bGwgfHwgTnVtYmVyLmlzRmluaXRlKG5leHRZVmFsdWVTdGFja1tqXSk7XG4gICAgICAgICAgICBpZiAobGFzdFdhc0Zpbml0ZSkge1xuICAgICAgICAgICAgICB5VmFsdWVFbmRCYWNrd2FyZHMgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFdhc0Zpbml0ZSkge1xuICAgICAgICAgICAgICB5VmFsdWVFbmRGb3J3YXJkcyArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50cyA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghY29ubmVjdE1pc3NpbmdEYXRhICYmICh5VmFsdWVFbmRCYWNrd2FyZHMgIT09IHlWYWx1ZUVuZEZvcndhcmRzIHx8ICF5RGF0dW1Jc0Zpbml0ZSkpIHtcbiAgICAgICAgICBpZiAoIXlEYXR1bUlzRmluaXRlICYmIEFycmF5LmlzQXJyYXkoY3VycmVudFBvaW50cykgJiYgY3VycmVudFBvaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gPSB7IHNraXA6IDEgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRCYWNrd2FyZHMgPSBjcmVhdGVQb2ludCh4RGF0dW0sIHlWYWx1ZUVuZEJhY2t3YXJkcyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludEZvcndhcmRzID0gY3JlYXRlUG9pbnQoeERhdHVtLCB5VmFsdWVFbmRGb3J3YXJkcyk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSkge1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2gocG9pbnRCYWNrd2FyZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50cy5za2lwICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaCh5RGF0dW1Jc0Zpbml0ZSA/IFtwb2ludEZvcndhcmRzXSA6IHsgc2tpcDogMCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgeVZhbHVlRW5kID0gTWF0aC5tYXgoeVZhbHVlRW5kQmFja3dhcmRzLCB5VmFsdWVFbmRGb3J3YXJkcyk7XG4gICAgICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVQb2ludCh4RGF0dW0sIHlWYWx1ZUVuZCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFBvaW50cykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHMuc2tpcCArPSAxO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BvaW50XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwb2ludF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYW5zRm9yUG9pbnRzKHBvaW50cyk7XG4gICAgfTtcbiAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5zZXJpZXNHcm91cGluZz8uc3RhY2tJbmRleCA/PyAwO1xuICAgIGNvbnN0IGdldEF4aXNTcGFucyA9ICgpID0+IHtcbiAgICAgIGlmIChkYXRhVmFsdWVzID09IG51bGwpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IHlWYWx1ZVplcm9Qb2ludHMgPSBkYXRhVmFsdWVzLm1hcCgoeyB4RGF0dW0sIHZhbHVlcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHlWYWx1ZVN0YWNrID0gdmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBjb25zdCB5RGF0dW0gPSB5VmFsdWVTdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiAhTnVtYmVyLmlzRmluaXRlKHlEYXR1bSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9pbnQoeERhdHVtLCAwKTtcbiAgICAgIH0pLmZpbHRlcigoeCkgPT4geCAhPSBudWxsKTtcbiAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVBvaW50cyh5VmFsdWVaZXJvUG9pbnRzKTtcbiAgICB9O1xuICAgIGNvbnN0IGN1cnJlbnRTZXJpZXNTcGFucyA9IGdldFNlcmllc1NwYW5zKHN0YWNrSW5kZXgpO1xuICAgIGNvbnN0IHBoYW50b21TcGFucyA9IGN1cnJlbnRTZXJpZXNTcGFucy5tYXAoKCkgPT4gbnVsbCk7XG4gICAgZm9yIChsZXQgaiA9IHN0YWNrSW5kZXggLSAxOyBqID49IC0xOyBqIC09IDEpIHtcbiAgICAgIGxldCBzcGFucztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGhhbnRvbVNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChwaGFudG9tU3BhbnNbaV0gIT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3BhbnMgPz8gKHNwYW5zID0gaiAhPT0gLTEgPyBnZXRTZXJpZXNTcGFucyhqKSA6IGdldEF4aXNTcGFucygpKTtcbiAgICAgICAgcGhhbnRvbVNwYW5zW2ldID0gc3BhbnNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbGxTcGFucyA9IGN1cnJlbnRTZXJpZXNTcGFucy5tYXAoKHNwYW4sIGluZGV4KSA9PiBzcGFuID8/IHBoYW50b21TcGFuc1tpbmRleF0pO1xuICAgIGNvbnN0IHN0cm9rZVNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLmZpbHRlcigoc3BhbikgPT4gc3BhbiAhPSBudWxsKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgaXRlbUlkLFxuICAgICAgZmlsbERhdGE6IHsgaXRlbUlkLCBzcGFuczogZmlsbFNwYW5zLCBwaGFudG9tU3BhbnMgfSxcbiAgICAgIHN0cm9rZURhdGE6IHsgaXRlbUlkLCBzcGFuczogc3Ryb2tlU3BhbnMgfSxcbiAgICAgIGxhYmVsRGF0YSxcbiAgICAgIG5vZGVEYXRhOiBtYXJrZXJEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSxcbiAgICAgIHN0YWNrVmlzaWJsZTogdmlzaWJsZVNhbWVTdGFja0NvdW50ID4gMFxuICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG9wYWNpdHksIHZpc2libGUsIGFuaW1hdGlvbkVuYWJsZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgW2ZpbGwsIHN0cm9rZV0gPSBvcHRzLnBhdGhzO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpO1xuICAgIHN0cm9rZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRhZzogMSAvKiBTdHJva2UgKi8sXG4gICAgICBmaWxsOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogc3Ryb2tlLmxpbmVDYXAgPSBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXQsXG4gICAgICBvcGFjaXR5LFxuICAgICAgdmlzaWJsZVxuICAgIH0pO1xuICAgIGZpbGwuc2V0UHJvcGVydGllcyh7XG4gICAgICB0YWc6IDAgLyogRmlsbCAqLyxcbiAgICAgIHN0cm9rZTogdm9pZCAwLFxuICAgICAgbGluZUpvaW46IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqLyxcbiAgICAgIGZpbGw6IHRoaXMucHJvcGVydGllcy5maWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICBmaWxsU2hhZG93OiB0aGlzLnByb3BlcnRpZXMuc2hhZG93LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGU6IHZpc2libGUgfHwgYW5pbWF0aW9uRW5hYmxlZCxcbiAgICAgIHN0cm9rZVdpZHRoXG4gICAgfSk7XG4gICAgdXBkYXRlQ2xpcFBhdGgodGhpcywgc3Ryb2tlKTtcbiAgICB1cGRhdGVDbGlwUGF0aCh0aGlzLCBmaWxsKTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRocyhvcHRzKSB7XG4gICAgdGhpcy51cGRhdGVBcmVhUGF0aHMob3B0cy5wYXRocywgb3B0cy5jb250ZXh0RGF0YSk7XG4gIH1cbiAgdXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIHRoaXMudXBkYXRlRmlsbFBhdGgocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB0aGlzLnVwZGF0ZVN0cm9rZVBhdGgocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgfVxuICB1cGRhdGVGaWxsUGF0aChwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IHNwYW5zLCBwaGFudG9tU3BhbnMgfSA9IGNvbnRleHREYXRhLmZpbGxEYXRhO1xuICAgIGNvbnN0IFtmaWxsXSA9IHBhdGhzO1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gZmlsbDtcbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHsgc3BhbiB9ID0gc3BhbnNbaV07XG4gICAgICBjb25zdCBwaGFudG9tU3BhbiA9IHBoYW50b21TcGFuc1tpXS5zcGFuO1xuICAgICAgcGxvdFNwYW4ocGF0aCwgc3BhbiwgMSAvKiBNb3ZlVG8gKi8pO1xuICAgICAgcGxvdFNwYW4ocGF0aCwgcmV2ZXJzZVNwYW4ocGhhbnRvbVNwYW4pLCAyIC8qIExpbmVUbyAqLyk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBmaWxsLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgdXBkYXRlU3Ryb2tlUGF0aChwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IHNwYW5zIH0gPSBjb250ZXh0RGF0YS5zdHJva2VEYXRhO1xuICAgIGNvbnN0IFssIHN0cm9rZV0gPSBwYXRocztcbiAgICBjb25zdCB7IHBhdGggfSA9IHN0cm9rZTtcbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGZvciAoY29uc3QgeyBzcGFuIH0gb2Ygc3BhbnMpIHtcbiAgICAgIHBsb3RTcGFuKHBhdGgsIHNwYW4pO1xuICAgIH1cbiAgICBzdHJva2UuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5lbmFibGVkID8gbm9kZURhdGEgOiBbXSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBtYXJrZXIsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBoaWdobGlnaHRTdHlsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUuaXRlbSwgbWFya2VyLmdldFN0eWxlKCksIHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlT3BhY2l0eVxuICAgIH0pO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5IH0sIGJhc2VTdHlsZSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWxEYXRhLCBsYWJlbFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICByZXR1cm4gbGFiZWxTZWxlY3Rpb24udXBkYXRlKGxhYmVsRGF0YSwgKHRleHQpID0+IHtcbiAgICAgIHRleHQudGFnID0gMyAvKiBMYWJlbCAqLztcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgZW5hYmxlZDogbGFiZWxFbmFibGVkLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHgsIHksIGxhYmVsIH0gPSBkYXR1bTtcbiAgICAgIGlmIChsYWJlbCAmJiBsYWJlbEVuYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gbGFiZWwudGV4dEFsaWduO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcbiAgICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgICAgdGV4dC54ID0geDtcbiAgICAgICAgdGV4dC55ID0geSAtIDEwO1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBheGVzLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB4TmFtZSwgeU5hbWUsIHRvb2x0aXAsIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgeUtleSwgeFZhbHVlLCB5VmFsdWUsIGRhdHVtLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhKHhBeGlzICYmIHlBeGlzICYmIGlzRmluaXRlTnVtYmVyKHlWYWx1ZSkpIHx8ICFkYXRhTW9kZWwpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHlOYW1lKTtcbiAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyBcIjogXCIgKyB5U3RyaW5nKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogdGhpcy5wcm9wZXJ0aWVzLmZpbGwgfSwgbWFya2VyLmdldFN0eWxlKCksIHtcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGhcbiAgICB9KTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogZmFsc2UgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHNlcmllc0lkXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF0aGlzLnByb3BlcnRpZXMuc2hvd0luTGVnZW5kIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB5S2V5LFxuICAgICAgeU5hbWUsXG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIG1hcmtlcixcbiAgICAgIHZpc2libGUsXG4gICAgICBsZWdlbmRJdGVtTmFtZVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgdXNlQXJlYUZpbGwgPSAhbWFya2VyLmVuYWJsZWQgfHwgbWFya2VyLmZpbGwgPT09IHZvaWQgMDtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsZWdlbmRJdGVtTmFtZSA/PyB5TmFtZSA/PyB5S2V5XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogdXNlQXJlYUZpbGwgPyBmaWxsIDogbWFya2VyLmZpbGwsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB1c2VBcmVhRmlsbCA/IGZpbGxPcGFjaXR5IDogbWFya2VyLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IDAsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IG1hcmtlci5lbmFibGVkIHx8IHN0cm9rZVdpZHRoIDw9IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGxpbmVEYXNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBwYXRoU3dpcGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5wYXRocyk7XG4gICAgcmVzZXRNb3Rpb24oW21hcmtlclNlbGVjdGlvbl0sIHJlc2V0TWFya2VyUG9zaXRpb25Gbik7XG4gICAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBzdXBlci5hbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGNvbnRleHREYXRhLCBwYXRocywgcHJldmlvdXNDb250ZXh0RGF0YSB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCBbZmlsbCwgc3Ryb2tlXSA9IHBhdGhzO1xuICAgIGlmIChmaWxsID09IG51bGwgJiYgc3Ryb2tlID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXNldE1hcmtlckFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICB0aGlzLnJlc2V0TGFiZWxBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFBhdGhBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBza2lwID0gKCkgPT4ge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9O1xuICAgIGlmIChjb250ZXh0RGF0YSA9PSBudWxsIHx8IHByZXZpb3VzQ29udGV4dERhdGEgPT0gbnVsbCkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRlZFwiLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgICAgcGF0aEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImZpbGxfcGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkXCIsIGZpbGwpO1xuICAgICAgcGF0aEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInN0cm9rZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBcInRyYWlsaW5nXCIsIHN0cm9rZSk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbihjb250ZXh0RGF0YSwgcHJldmlvdXNDb250ZXh0RGF0YSwgdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmKTtcbiAgICBpZiAoZm5zID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZucy5zdGF0dXMgPT09IFwibm8tb3BcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgdm9pZCAwLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImZpbGxfcGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtmaWxsXSwgZm5zLmZpbGwucGF0aFByb3BlcnRpZXMpO1xuICAgIHBhdGhNb3Rpb24odGhpcy5pZCwgXCJmaWxsX3BhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtmaWxsXSwgZm5zLmZpbGwucGF0aCk7XG4gICAgdGhpcy51cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgcGF0aEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInN0cm9rZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBcInRyYWlsaW5nXCIsIHN0cm9rZSk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKCk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pIHtcbiAgICBjb25zdCB7IHhLZXksIHlLZXkgfSA9IGRhdHVtO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHsgZGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiB0cnVlIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkFyZWFTZXJpZXMuY2xhc3NOYW1lID0gXCJBcmVhU2VyaWVzXCI7XG5BcmVhU2VyaWVzLnR5cGUgPSBcImFyZWFcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhU2VyaWVzTW9kdWxlLnRzXG52YXIgQXJlYVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImFyZWFcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEFyZWFTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBub2RlQ2xpY2tSYW5nZTogXCJuZWFyZXN0XCIsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICAgIGJsdXI6IDVcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB1c2VycyBzaG91bGRuJ3Qgc3BlY2lmeSBhbGwgb3B0aW9ucywgYnV0IHdlIGhhdmUgdG8gZm9yIHRoZW1pbmcgdG8gd29ya1xuICAgICAgICB0ZW5zaW9uOiAxLFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIlxuICAgICAgfSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICAgIHNpemU6IDcsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSBtYXJrZXJQYWxldHRlRmFjdG9yeShwYXJhbXMpO1xuICAgIHJldHVybiB7IGZpbGw6IG1hcmtlci5maWxsLCBzdHJva2U6IG1hcmtlci5zdHJva2UsIG1hcmtlciB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3F1YWR0cmVlVXRpbC50c1xuZnVuY3Rpb24qIGNoaWxkcmVuSXRlcihwYXJlbnQpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIHBhcmVudC5jaGlsZHJlbikge1xuICAgIHlpZWxkIG5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlKHF1YWR0cmVlLCBoaXRUZXN0ZXJzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBoaXRUZXN0ZXJzKSB7XG4gICAgY29uc3QgZGF0dW0gPSBub2RlLmRhdHVtO1xuICAgIGlmIChkYXR1bSA9PT0gdm9pZCAwKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoXCJ1bmRlZmluZWQgZGF0dW1cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1YWR0cmVlLmFkZFZhbHVlKG5vZGUsIGRhdHVtKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRRdWFkdHJlZU1hdGNoKHNlcmllcywgcG9pbnQpIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBzZXJpZXMuY29udGVudEdyb3VwLnRyYW5zZm9ybVBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICBjb25zdCB7IG5lYXJlc3QsIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMyB9ID0gc2VyaWVzLmdldFF1YWRUcmVlKCkuZmluZCh4LCB5KTtcbiAgaWYgKG5lYXJlc3QgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IGRhdHVtOiBuZWFyZXN0LnZhbHVlLCBkaXN0YW5jZTogTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZDMpIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hYnN0cmFjdEJhclNlcmllcy50c1xudmFyIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInZlcnRpY2FsXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShESVJFQ1RJT04pXG5dLCBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCAyKTtcbnZhciBBYnN0cmFjdEJhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgYmFycyB3aXRoaW4gZWFjaCBncm91cC5cbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwU2NhbGUgPSBuZXcgQmFuZFNjYWxlKCk7XG4gICAgdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCA9IHZvaWQgMDtcbiAgICB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4geyBpbm5lcjogMC4zLCBvdXRlcjogMC4xNSB9O1xuICB9XG4gIHNob3VsZEZsaXBYWSgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNWZXJ0aWNhbCgpO1xuICB9XG4gIGlzVmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5kaXJlY3Rpb24gPT09IFwidmVydGljYWxcIjtcbiAgfVxuICBnZXRCYXJEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkRmxpcFhZKCkgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgfVxuICBnZXRDYXRlZ29yeURpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRGbGlwWFkoKSA/IFwieVwiIC8qIFkgKi8gOiBcInhcIiAvKiBYICovO1xuICB9XG4gIGdldFZhbHVlQXhpcygpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldEJhckRpcmVjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgfVxuICBnZXRDYXRlZ29yeUF4aXMoKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgfVxuICB1cGRhdGVHcm91cFNjYWxlKHhBeGlzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZ3JvdXBTY2FsZSxcbiAgICAgIHNtYWxsZXN0RGF0YUludGVydmFsLFxuICAgICAgY3R4OiB7IHNlcmllc1N0YXRlTWFuYWdlciB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeEJhbmRXaWR0aCA9IENvbnRpbnVvdXNTY2FsZS5pcyh4U2NhbGUpID8geFNjYWxlLmNhbGNCYW5kd2lkdGgoc21hbGxlc3REYXRhSW50ZXJ2YWwpIDogeFNjYWxlLmJhbmR3aWR0aDtcbiAgICBjb25zdCBkb21haW4gPSBbXTtcbiAgICBjb25zdCB7IGluZGV4OiBncm91cEluZGV4LCB2aXNpYmxlR3JvdXBDb3VudCB9ID0gc2VyaWVzU3RhdGVNYW5hZ2VyLmdldFZpc2libGVQZWVyR3JvdXBJbmRleCh0aGlzKTtcbiAgICBmb3IgKGxldCBncm91cElkeCA9IDA7IGdyb3VwSWR4IDwgdmlzaWJsZUdyb3VwQ291bnQ7IGdyb3VwSWR4KyspIHtcbiAgICAgIGRvbWFpbi5wdXNoKFN0cmluZyhncm91cElkeCkpO1xuICAgIH1cbiAgICBncm91cFNjYWxlLmRvbWFpbiA9IGRvbWFpbjtcbiAgICBncm91cFNjYWxlLnJhbmdlID0gWzAsIHhCYW5kV2lkdGggPz8gMF07XG4gICAgaWYgKHhBeGlzIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICBncm91cFNjYWxlLnBhZGRpbmdJbm5lciA9IHhBeGlzLmdyb3VwUGFkZGluZ0lubmVyO1xuICAgIH0gZWxzZSBpZiAoeEF4aXMgaW5zdGFuY2VvZiBHcm91cGVkQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICBncm91cFNjYWxlLnBhZGRpbmcgPSAwLjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwU2NhbGUucGFkZGluZyA9IDA7XG4gICAgfVxuICAgIGdyb3VwU2NhbGUucm91bmQgPSBncm91cFNjYWxlLnBhZGRpbmcgIT09IDA7XG4gICAgY29uc3QgYmFyV2lkdGggPSBncm91cFNjYWxlLmJhbmR3aWR0aCA+PSAxID8gKFxuICAgICAgLy8gUGl4ZWwtcm91bmRlZCB2YWx1ZSBmb3IgbG93LXZvbHVtZSBiYXIgY2hhcnRzLlxuICAgICAgZ3JvdXBTY2FsZS5iYW5kd2lkdGhcbiAgICApIDogKFxuICAgICAgLy8gSGFuZGxlIGhpZ2gtdm9sdW1lIGJhciBjaGFydHMgZ3JhY2VmdWxseS5cbiAgICAgIGdyb3VwU2NhbGUucmF3QmFuZHdpZHRoXG4gICAgKTtcbiAgICByZXR1cm4geyBiYXJXaWR0aCwgZ3JvdXBJbmRleCB9O1xuICB9XG4gIHJlc29sdmVLZXlEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuZ2V0QmFyRGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgcmV0dXJuIFwieVwiIC8qIFkgKi87XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ4XCIgLyogWCAqLztcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuICBpbml0UXVhZFRyZWUocXVhZHRyZWUpIHtcbiAgICBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZShxdWFkdHJlZSwgdGhpcy5kYXR1bU5vZGVzSXRlcigpKTtcbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIHJldHVybiBmaW5kUXVhZHRyZWVNYXRjaCh0aGlzLCBwb2ludCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEJhclNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcImluc2lkZVwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUExBQ0VNRU5UKVxuXSwgQmFyU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbnZhciBCYXJTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbCA9IFwiI2MxNjA2OFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmNyaXNwID0gdm9pZCAwO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEJhclNlcmllc0xhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0YWNrR3JvdXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRUb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY3Jpc3BcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclV0aWwudHNcbmZ1bmN0aW9uIHVwZGF0ZVJlY3QocmVjdCwgY29uZmlnKSB7XG4gIHJlY3QuY3Jpc3AgPSBjb25maWcuY3Jpc3AgPz8gdHJ1ZTtcbiAgcmVjdC5maWxsID0gY29uZmlnLmZpbGw7XG4gIHJlY3Quc3Ryb2tlID0gY29uZmlnLnN0cm9rZTtcbiAgcmVjdC5zdHJva2VXaWR0aCA9IGNvbmZpZy5zdHJva2VXaWR0aDtcbiAgcmVjdC5maWxsT3BhY2l0eSA9IGNvbmZpZy5maWxsT3BhY2l0eTtcbiAgcmVjdC5zdHJva2VPcGFjaXR5ID0gY29uZmlnLnN0cm9rZU9wYWNpdHk7XG4gIHJlY3QubGluZURhc2ggPSBjb25maWcubGluZURhc2g7XG4gIHJlY3QubGluZURhc2hPZmZzZXQgPSBjb25maWcubGluZURhc2hPZmZzZXQ7XG4gIHJlY3QuZmlsbFNoYWRvdyA9IGNvbmZpZy5maWxsU2hhZG93O1xuICByZWN0LnRvcExlZnRDb3JuZXJSYWRpdXMgPSBjb25maWcudG9wTGVmdENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gY29uZmlnLnRvcFJpZ2h0Q29ybmVyUmFkaXVzICE9PSBmYWxzZSA/IGNvbmZpZy5jb3JuZXJSYWRpdXMgPz8gMCA6IDA7XG4gIHJlY3QuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBjb25maWcuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gY29uZmlnLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC52aXNpYmxlID0gY29uZmlnLnZpc2libGUgPz8gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RDb25maWcoe1xuICBkYXR1bSxcbiAgaXNIaWdobGlnaHRlZCxcbiAgc3R5bGUsXG4gIGhpZ2hsaWdodFN0eWxlLFxuICBpdGVtU3R5bGVyLFxuICBzZXJpZXNJZCxcbiAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfSxcbiAgLi4ub3B0c1xufSkge1xuICBjb25zdCB7XG4gICAgZmlsbCxcbiAgICBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldCxcbiAgICBjb3JuZXJSYWRpdXMgPSAwXG4gIH0gPSBtZXJnZURlZmF1bHRzKGlzSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUsIHN0eWxlKTtcbiAgbGV0IGZvcm1hdDtcbiAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgZGF0dW06IGRhdHVtLmRhdHVtLFxuICAgICAgeEtleTogZGF0dW0ueEtleSxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICBoaWdobGlnaHRlZDogaXNIaWdobGlnaHRlZCxcbiAgICAgIHNlcmllc0lkLFxuICAgICAgLi4ub3B0c1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IGZvcm1hdD8uZmlsbE9wYWNpdHkgPz8gZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBmb3JtYXQ/LnN0cm9rZSA/PyBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IGZvcm1hdD8uc3Ryb2tlV2lkdGggPz8gc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2g6IGZvcm1hdD8ubGluZURhc2ggPz8gbGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQ6IGZvcm1hdD8ubGluZURhc2hPZmZzZXQgPz8gbGluZURhc2hPZmZzZXQsXG4gICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXMsXG4gICAgdG9wTGVmdENvcm5lclJhZGl1czogc3R5bGUudG9wTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodENvcm5lclJhZGl1czogc3R5bGUudG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IHN0eWxlLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IHN0eWxlLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMsXG4gICAgZmlsbFNoYWRvdzogc3R5bGUuZmlsbFNoYWRvd1xuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tDcmlzcChzY2FsZTIsIHZpc2libGVSYW5nZSwgc21hbGxlc3REYXRhSW50ZXJ2YWwsIGxhcmdlc3REYXRhSW50ZXJ2YWwpIHtcbiAgaWYgKHZpc2libGVSYW5nZSAhPSBudWxsKSB7XG4gICAgY29uc3QgW3Zpc2libGVNaW4sIHZpc2libGVNYXhdID0gdmlzaWJsZVJhbmdlO1xuICAgIGNvbnN0IGlzWm9vbWVkID0gdmlzaWJsZU1pbiAhPT0gMCB8fCB2aXNpYmxlTWF4ICE9PSAxO1xuICAgIGlmIChpc1pvb21lZClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICBjb25zdCBzcGFjaW5nID0gc2NhbGUyLmNhbGNCYW5kd2lkdGgobGFyZ2VzdERhdGFJbnRlcnZhbCkgLSBzY2FsZTIuY2FsY0JhbmR3aWR0aChzbWFsbGVzdERhdGFJbnRlcnZhbCk7XG4gICAgaWYgKHNwYWNpbmcgPiAwICYmIHNwYWNpbmcgPCAxKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIGlzRGF0dW1OZWdhdGl2ZSA9IChkYXR1bSkgPT4ge1xuICByZXR1cm4gaXNOZWdhdGl2ZShkYXR1bS55VmFsdWUgPz8gMCk7XG59O1xuZnVuY3Rpb24gY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbihpc1ZlcnRpY2FsLCBheGVzLCBtb2RlKSB7XG4gIGNvbnN0IHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfSA9IGdldFN0YXJ0aW5nVmFsdWVzKGlzVmVydGljYWwsIGF4ZXMpO1xuICBjb25zdCBjYWxjdWxhdGUgPSAoZGF0dW0sIHByZXZEYXR1bSkgPT4ge1xuICAgIGxldCB4ID0gaXNWZXJ0aWNhbCA/IGRhdHVtLnggOiBzdGFydGluZ1g7XG4gICAgbGV0IHkgPSBpc1ZlcnRpY2FsID8gc3RhcnRpbmdZIDogZGF0dW0ueTtcbiAgICBsZXQgd2lkdGggPSBpc1ZlcnRpY2FsID8gZGF0dW0ud2lkdGggOiAwO1xuICAgIGxldCBoZWlnaHQgPSBpc1ZlcnRpY2FsID8gMCA6IGRhdHVtLmhlaWdodDtcbiAgICBjb25zdCB7IG9wYWNpdHkgfSA9IGRhdHVtO1xuICAgIGlmIChwcmV2RGF0dW0gJiYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSkge1xuICAgICAgKHsgeCwgeSB9ID0gcHJldkRhdHVtKTtcbiAgICAgIHdpZHRoID0gaXNWZXJ0aWNhbCA/IHByZXZEYXR1bS53aWR0aCA6IDA7XG4gICAgICBoZWlnaHQgPSBpc1ZlcnRpY2FsID8gMCA6IHByZXZEYXR1bS5oZWlnaHQ7XG4gICAgICBpZiAoaXNWZXJ0aWNhbCAmJiAhaXNEYXR1bU5lZ2F0aXZlKHByZXZEYXR1bSkpIHtcbiAgICAgICAgeSArPSBwcmV2RGF0dW0uaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmICghaXNWZXJ0aWNhbCAmJiBpc0RhdHVtTmVnYXRpdmUocHJldkRhdHVtKSkge1xuICAgICAgICB4ICs9IHByZXZEYXR1bS53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNsaXBCQm94O1xuICAgIGlmIChkYXR1bS5jbGlwQkJveCA9PSBudWxsKSB7XG4gICAgICBjbGlwQkJveCA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKGlzRGF0dW1OZWdhdGl2ZShkYXR1bSkpIHtcbiAgICAgIGNsaXBCQm94ID0gaXNWZXJ0aWNhbCA/IG5ldyBCQm94KHgsIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHQpIDogbmV3IEJCb3goeCAtIHdpZHRoLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpcEJCb3ggPSBuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2xpcEJCb3gsIG9wYWNpdHkgfTtcbiAgfTtcbiAgcmV0dXJuIHsgaXNWZXJ0aWNhbCwgY2FsY3VsYXRlLCBtb2RlIH07XG59XG5mdW5jdGlvbiBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb24oaXNWZXJ0aWNhbCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIGlzVmVydGljYWwsXG4gICAgY2FsY3VsYXRlOiAoZGF0dW0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGlzVmVydGljYWwgPyBkYXR1bS54IDogZGF0dW0ueCArIGRhdHVtLndpZHRoIC8gMixcbiAgICAgICAgeTogaXNWZXJ0aWNhbCA/IGRhdHVtLnkgKyBkYXR1bS5oZWlnaHQgLyAyIDogZGF0dW0ueSxcbiAgICAgICAgd2lkdGg6IGlzVmVydGljYWwgPyBkYXR1bS53aWR0aCA6IDAsXG4gICAgICAgIGhlaWdodDogaXNWZXJ0aWNhbCA/IDAgOiBkYXR1bS5oZWlnaHQsXG4gICAgICAgIGNsaXBCQm94OiBkYXR1bS5jbGlwQkJveCxcbiAgICAgICAgb3BhY2l0eTogZGF0dW0ub3BhY2l0eVxuICAgICAgfTtcbiAgICB9LFxuICAgIG1vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoaW5pdFBvcykge1xuICBjb25zdCBpc1JlbW92ZWQgPSAoZGF0dW0pID0+IGRhdHVtID09IG51bGwgfHwgaXNOYU4oZGF0dW0ueCkgfHwgaXNOYU4oZGF0dW0ueSk7XG4gIGNvbnN0IGZyb21GbiA9IChyZWN0LCBkYXR1bSwgc3RhdHVzKSA9PiB7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1cGRhdGVkXCIgJiYgaXNSZW1vdmVkKGRhdHVtKSkge1xuICAgICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiICYmIGlzUmVtb3ZlZChyZWN0LnByZXZpb3VzRGF0dW0pKSB7XG4gICAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gICAgfVxuICAgIGxldCBzb3VyY2U7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmIHJlY3QucHJldmlvdXNEYXR1bSA9PSBudWxsICYmIGluaXRQb3MubW9kZSA9PT0gXCJmYWRlXCIpIHtcbiAgICAgIHNvdXJjZSA9IHsgLi4ucmVzZXRCYXJTZWxlY3Rpb25zRm4ocmVjdCwgZGF0dW0pLCBvcGFjaXR5OiAwIH07XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwidW5rbm93blwiIHx8IHN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICBzb3VyY2UgPSBpbml0UG9zLmNhbGN1bGF0ZShkYXR1bSwgcmVjdC5wcmV2aW91c0RhdHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0ge1xuICAgICAgICB4OiByZWN0LngsXG4gICAgICAgIHk6IHJlY3QueSxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIGNsaXBCQm94OiByZWN0LmNsaXBCQm94LFxuICAgICAgICBvcGFjaXR5OiByZWN0Lm9wYWNpdHlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBoYXNlID0gTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdO1xuICAgIHJldHVybiB7IC4uLnNvdXJjZSwgcGhhc2UgfTtcbiAgfTtcbiAgY29uc3QgdG9GbiA9IChyZWN0LCBkYXR1bSwgc3RhdHVzKSA9PiB7XG4gICAgbGV0IHNvdXJjZTtcbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiAmJiByZWN0LmRhdHVtID09IG51bGwgJiYgaW5pdFBvcy5tb2RlID09PSBcImZhZGVcIikge1xuICAgICAgc291cmNlID0geyAuLi5yZXNldEJhclNlbGVjdGlvbnNGbihyZWN0LCBkYXR1bSksIG9wYWNpdHk6IDAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgaXNSZW1vdmVkKGRhdHVtKSkge1xuICAgICAgc291cmNlID0gaW5pdFBvcy5jYWxjdWxhdGUoZGF0dW0sIHJlY3QucHJldmlvdXNEYXR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgeDogZGF0dW0ueCxcbiAgICAgICAgeTogZGF0dW0ueSxcbiAgICAgICAgd2lkdGg6IGRhdHVtLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRhdHVtLmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IGRhdHVtLmNsaXBCQm94LFxuICAgICAgICBvcGFjaXR5OiBkYXR1bS5vcGFjaXR5XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9O1xuICByZXR1cm4geyB0b0ZuLCBmcm9tRm4gfTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0aW5nVmFsdWVzKGlzVmVydGljYWwsIGF4ZXMpIHtcbiAgY29uc3QgYXhpcyA9IGF4ZXNbaXNWZXJ0aWNhbCA/IFwieVwiIC8qIFkgKi8gOiBcInhcIiAvKiBYICovXTtcbiAgbGV0IHN0YXJ0aW5nWCA9IEluZmluaXR5O1xuICBsZXQgc3RhcnRpbmdZID0gMDtcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuIHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfTtcbiAgfVxuICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgIHN0YXJ0aW5nWSA9IGF4aXMuc2NhbGUuY29udmVydChDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkgPyAwIDogTWF0aC5tYXgoLi4uYXhpcy5yYW5nZSkpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0aW5nWCA9IGF4aXMuc2NhbGUuY29udmVydChDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkgPyAwIDogTWF0aC5taW4oLi4uYXhpcy5yYW5nZSkpO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0aW5nWCwgc3RhcnRpbmdZIH07XG59XG5mdW5jdGlvbiByZXNldEJhclNlbGVjdGlvbnNGbihfbm9kZSwgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGlwQkJveCwgb3BhY2l0eSB9KSB7XG4gIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGNsaXBCQm94LCBvcGFjaXR5IH07XG59XG5mdW5jdGlvbiBjb21wdXRlQmFyRm9jdXNCb3VuZHMoZGF0dW0sIGJhckdyb3VwLCBzZXJpZXNSZWN0KSB7XG4gIGlmIChkYXR1bSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZGF0dW07XG4gIHJldHVybiBiYXJHcm91cC5pbnZlcnNlVHJhbnNmb3JtQkJveChuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSkuY2xpcChzZXJpZXNSZWN0KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9sYWJlbFV0aWwudHNcbmZ1bmN0aW9uIHVwZGF0ZUxhYmVsTm9kZSh0ZXh0Tm9kZSwgbGFiZWwsIGxhYmVsRGF0dW0pIHtcbiAgaWYgKGxhYmVsLmVuYWJsZWQgJiYgbGFiZWxEYXR1bSkge1xuICAgIGNvbnN0IHsgeCwgeSwgdGV4dCwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUgfSA9IGxhYmVsRGF0dW07XG4gICAgY29uc3QgeyBjb2xvcjogZmlsbCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9ID0gbGFiZWw7XG4gICAgdGV4dE5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB0ZXh0LFxuICAgICAgZmlsbCxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Tm9kZS52aXNpYmxlID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdExhYmVsUGxhY2VtZW50KHtcbiAgaXNQb3NpdGl2ZSxcbiAgaXNWZXJ0aWNhbCxcbiAgcGxhY2VtZW50LFxuICBwYWRkaW5nID0gMCxcbiAgcmVjdFxufSkge1xuICBsZXQgeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICBsZXQgeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcbiAgbGV0IHRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gIGxldCB0ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICB5ID0gaXNQb3NpdGl2ZSA/IHJlY3QueSArIHJlY3QuaGVpZ2h0ICsgcGFkZGluZyA6IHJlY3QueSAtIHBhZGRpbmc7XG4gICAgICAgIHRleHRCYXNlbGluZSA9IGlzUG9zaXRpdmUgPyBcInRvcFwiIDogXCJib3R0b21cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBpc1Bvc2l0aXZlID8gcmVjdC54IC0gcGFkZGluZyA6IHJlY3QueCArIHJlY3Qud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICB0ZXh0QWxpZ24gPSBpc1Bvc2l0aXZlID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwib3V0c2lkZVwiOlxuICAgIGNhc2UgXCJlbmRcIjoge1xuICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgeSA9IGlzUG9zaXRpdmUgPyByZWN0LnkgLSBwYWRkaW5nIDogcmVjdC55ICsgcmVjdC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSBpc1Bvc2l0aXZlID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gaXNQb3NpdGl2ZSA/IHJlY3QueCArIHJlY3Qud2lkdGggKyBwYWRkaW5nIDogcmVjdC54IC0gcGFkZGluZztcbiAgICAgICAgdGV4dEFsaWduID0gaXNQb3NpdGl2ZSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgeCwgeSwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJTZXJpZXMudHNcbnZhciBCYXJTZXJpZXMgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0QmFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbMyAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtdLFxuICAgICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHM6IHRydWUsXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnM6IHRydWUsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgQmFyU2VyaWVzUHJvcGVydGllcygpO1xuICB9XG4gIGNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnlGaWx0ZXJLZXkgIT0gbnVsbCAmJiAodGhpcy5zZXJpZXNHcm91cGluZyA9PSBudWxsIHx8IHRoaXMuc2VyaWVzR3JvdXBpbmcuc3RhY2tJbmRleCA9PT0gMCk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXRoaXMuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNlcmllc0dyb3VwaW5nOiB7IGdyb3VwSW5kZXggPSB0aGlzLmlkIH0gPSB7fSwgZGF0YSA9IFtdIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeUZpbHRlcktleSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuZ2V0VmFsdWVBeGlzKCk/LnNjYWxlO1xuICAgIGNvbnN0IHsgaXNDb250aW51b3VzWCwgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3Qgc3RhY2tHcm91cE5hbWUgPSBgYmFyLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlc2A7XG4gICAgY29uc3Qgc3RhY2tHcm91cFRyYWlsaW5nTmFtZSA9IGAke3N0YWNrR3JvdXBOYW1lfS10cmFpbGluZ2A7XG4gICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihub3JtYWxpemVkVG8pKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIG5vcm1hbGlzZUdyb3VwVG8oW3N0YWNrR3JvdXBOYW1lLCBzdGFja0dyb3VwVHJhaWxpbmdOYW1lXSwgTWF0aC5hYnMobm9ybWFsaXplZFRvKSwgXCJyYW5nZVwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCB2aXNpYmxlUHJvcHMgPSB0aGlzLnZpc2libGUgPyB7fSA6IHsgZm9yY2VWYWx1ZTogMCB9O1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICBrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhWYWx1ZVwiIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWUtcmF3YCwgaW52YWxpZFZhbHVlOiBudWxsLCAuLi52aXNpYmxlUHJvcHMgfSksXG4gICAgICAgIC4uLnRoaXMuY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkgPyBbXG4gICAgICAgICAgdmFsdWVQcm9wZXJ0eSh5RmlsdGVyS2V5LCB5U2NhbGVUeXBlLCB7XG4gICAgICAgICAgICBpZDogYHlGaWx0ZXJWYWx1ZWAsXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWU6IG51bGwsXG4gICAgICAgICAgICAuLi52aXNpYmxlUHJvcHNcbiAgICAgICAgICB9KVxuICAgICAgICBdIDogW10sXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwibm9ybWFsXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWUtZW5kYCxcbiAgICAgICAgICAgIHJhbmdlSWQ6IGB5VmFsdWUtcmFuZ2VgLFxuICAgICAgICAgICAgaW52YWxpZFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgbWlzc2luZ1ZhbHVlOiAwLFxuICAgICAgICAgICAgZ3JvdXBJZDogc3RhY2tHcm91cE5hbWUsXG4gICAgICAgICAgICBzZXBhcmF0ZU5lZ2F0aXZlOiB0cnVlLFxuICAgICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwidHJhaWxpbmdcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZS1zdGFydGAsXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWU6IG51bGwsXG4gICAgICAgICAgICBtaXNzaW5nVmFsdWU6IDAsXG4gICAgICAgICAgICBncm91cElkOiBzdGFja0dyb3VwVHJhaWxpbmdOYW1lLFxuICAgICAgICAgICAgc2VwYXJhdGVOZWdhdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnZpc2libGVQcm9wc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5pc0NvbnRpbnVvdXNYID8gW1NNQUxMRVNUX0tFWV9JTlRFUlZBTCwgTEFSR0VTVF9LRVlfSU5URVJWQUxdIDogW10sXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF0sXG4gICAgICBncm91cEJ5S2V5czogdHJ1ZSxcbiAgICAgIGdyb3VwQnlEYXRhOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwgPSBwcm9jZXNzZWREYXRhLnJlZHVjZWQ/LnNtYWxsZXN0S2V5SW50ZXJ2YWw7XG4gICAgdGhpcy5sYXJnZXN0RGF0YUludGVydmFsID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkPy5sYXJnZXN0S2V5SW50ZXJ2YWw7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIHNtYWxsZXN0RGF0YUludGVydmFsIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgY2F0ZWdvcnlBeGlzID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKTtcbiAgICBjb25zdCB2YWx1ZUF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xuICAgIGNvbnN0IGtleURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IGtleXMgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcImtleVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBsZXQgeUV4dGVudCA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZS1lbmRgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlGaWx0ZXJFeHRlbnQgPSB0aGlzLmNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpID8gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeUZpbHRlclZhbHVlYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBpZiAoeUZpbHRlckV4dGVudCAhPSBudWxsKSB7XG4gICAgICB5RXh0ZW50ID0gW01hdGgubWluKHlFeHRlbnRbMF0sIHlGaWx0ZXJFeHRlbnRbMF0pLCBNYXRoLm1heCh5RXh0ZW50WzFdLCB5RmlsdGVyRXh0ZW50WzFdKV07XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09IHRoaXMuZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKSkge1xuICAgICAgaWYgKGtleURlZj8uZGVmLnR5cGUgPT09IFwia2V5XCIgJiYga2V5RGVmLmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjYWxlUGFkZGluZyA9IGlzRmluaXRlTnVtYmVyKHNtYWxsZXN0RGF0YUludGVydmFsKSA/IHNtYWxsZXN0RGF0YUludGVydmFsICogMC41IDogMDtcbiAgICAgIGNvbnN0IGtleXNFeHRlbnQgPSBleHRlbnQoa2V5cykgPz8gW05hTiwgTmFOXTtcbiAgICAgIGNvbnN0IGQwID0ga2V5c0V4dGVudFswXSArIC1zY2FsZVBhZGRpbmc7XG4gICAgICBjb25zdCBkMSA9IGtleXNFeHRlbnRbMV0gKyBzY2FsZVBhZGRpbmc7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChbZDAsIGQxXSwgY2F0ZWdvcnlBeGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0VmFsdWVBeGlzKCkgaW5zdGFuY2VvZiBMb2dBeGlzKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RXh0ZW50LCB2YWx1ZUF4aXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXhlZFlFeHRlbnQgPSBbTWF0aC5taW4oMCwgeUV4dGVudFswXSksIE1hdGgubWF4KDAsIHlFeHRlbnRbMV0pXTtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGZpeGVkWUV4dGVudCwgdmFsdWVBeGlzKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAheEF4aXMgfHwgIXlBeGlzIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBjb3JuZXJSYWRpdXMsIGxlZ2VuZEl0ZW1OYW1lLCBsYWJlbCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHlSZXZlcnNlZCA9IHlBeGlzLmlzUmV2ZXJzZWQoKTtcbiAgICBjb25zdCB7IGJhcldpZHRoLCBncm91cEluZGV4IH0gPSB0aGlzLnVwZGF0ZUdyb3VwU2NhbGUoeEF4aXMpO1xuICAgIGNvbnN0IGJhck9mZnNldCA9IENvbnRpbnVvdXNTY2FsZS5pcyh4U2NhbGUpID8gYmFyV2lkdGggKiAtMC41IDogMDtcbiAgICBjb25zdCB4SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IHlSYXdJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlLXJhd2ApO1xuICAgIGNvbnN0IHlGaWx0ZXJJbmRleCA9IHRoaXMuY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHlTdGFydEluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtc3RhcnRgKTtcbiAgICBjb25zdCB5RW5kSW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1lbmRgKTtcbiAgICBjb25zdCB5UmFuZ2VJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlLXJhbmdlYCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IG5vZGVEYXR1bSA9ICh7XG4gICAgICBkYXR1bSxcbiAgICAgIHZhbHVlSW5kZXgsXG4gICAgICB4VmFsdWUsXG4gICAgICB5VmFsdWUsXG4gICAgICBjdW11bGF0aXZlVmFsdWUsXG4gICAgICBwaGFudG9tLFxuICAgICAgY3VyclksXG4gICAgICBwcmV2WSxcbiAgICAgIGlzUG9zaXRpdmUsXG4gICAgICB5UmFuZ2UsXG4gICAgICBsYWJlbFRleHQsXG4gICAgICBjcm9zc1NjYWxlID0gMVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4VmFsdWUpO1xuICAgICAgY29uc3QgaXNVcHdhcmQgPSBpc1Bvc2l0aXZlICE9PSB5UmV2ZXJzZWQ7XG4gICAgICBjb25zdCBiYXJYID0geCArIGdyb3VwU2NhbGUuY29udmVydChTdHJpbmcoZ3JvdXBJbmRleCkpICsgYmFyT2Zmc2V0O1xuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KGN1cnJZKTtcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSB5U2NhbGUuY29udmVydChwcmV2WSk7XG4gICAgICBjb25zdCBiYXJBbG9uZ1ggPSB0aGlzLmdldEJhckRpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovO1xuICAgICAgY29uc3QgYmJveEhlaWdodCA9IHlTY2FsZS5jb252ZXJ0KHlSYW5nZSk7XG4gICAgICBjb25zdCBiYm94Qm90dG9tID0geVNjYWxlLmNvbnZlcnQoMCk7XG4gICAgICBjb25zdCB4T2Zmc2V0ID0gYmFyV2lkdGggKiAwLjUgKiAoMSAtIGNyb3NzU2NhbGUpO1xuICAgICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgeDogYmFyQWxvbmdYID8gTWF0aC5taW4oeSwgYm90dG9tWSkgOiBiYXJYICsgeE9mZnNldCxcbiAgICAgICAgeTogYmFyQWxvbmdYID8gYmFyWCArIHhPZmZzZXQgOiBNYXRoLm1pbih5LCBib3R0b21ZKSxcbiAgICAgICAgd2lkdGg6IGJhckFsb25nWCA/IE1hdGguYWJzKGJvdHRvbVkgLSB5KSA6IGJhcldpZHRoICogY3Jvc3NTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiBiYXJBbG9uZ1ggPyBiYXJXaWR0aCAqIGNyb3NzU2NhbGUgOiBNYXRoLmFicyhib3R0b21ZIC0geSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjbGlwQkJveCA9IG5ldyBCQm94KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICBjb25zdCBiYXJSZWN0ID0ge1xuICAgICAgICB4OiBiYXJBbG9uZ1ggPyBNYXRoLm1pbihiYm94Qm90dG9tLCBiYm94SGVpZ2h0KSA6IGJhclggKyB4T2Zmc2V0LFxuICAgICAgICB5OiBiYXJBbG9uZ1ggPyBiYXJYICsgeE9mZnNldCA6IE1hdGgubWluKGJib3hCb3R0b20sIGJib3hIZWlnaHQpLFxuICAgICAgICB3aWR0aDogYmFyQWxvbmdYID8gTWF0aC5hYnMoYmJveEJvdHRvbSAtIGJib3hIZWlnaHQpIDogYmFyV2lkdGggKiBjcm9zc1NjYWxlLFxuICAgICAgICBoZWlnaHQ6IGJhckFsb25nWCA/IGJhcldpZHRoICogY3Jvc3NTY2FsZSA6IE1hdGguYWJzKGJib3hCb3R0b20gLSBiYm94SGVpZ2h0KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9udFN0eWxlOiBsYWJlbEZvbnRTdHlsZSxcbiAgICAgICAgZm9udFdlaWdodDogbGFiZWxGb250V2VpZ2h0LFxuICAgICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogbGFiZWxGb250RmFtaWx5LFxuICAgICAgICBjb2xvcjogbGFiZWxDb2xvcixcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gbGFiZWw7XG4gICAgICBjb25zdCBsZW5ndGhSYXRpb011bHRpcGxpZXIgPSB0aGlzLnNob3VsZEZsaXBYWSgpID8gcmVjdC5oZWlnaHQgOiByZWN0LndpZHRoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHBoYW50b20gPyBjcmVhdGVEYXR1bUlkKHlLZXksIHBoYW50b20pIDogeUtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgIGN1bXVsYXRpdmVWYWx1ZSxcbiAgICAgICAgcGhhbnRvbSxcbiAgICAgICAgeFZhbHVlLFxuICAgICAgICB5VmFsdWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGNhcERlZmF1bHRzOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyLFxuICAgICAgICAgIGxlbmd0aE1heDogbGVuZ3RoUmF0aW9NdWx0aXBsaWVyXG4gICAgICAgIH0sXG4gICAgICAgIHg6IGJhclJlY3QueCxcbiAgICAgICAgeTogYmFyUmVjdC55LFxuICAgICAgICB3aWR0aDogYmFyUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBiYXJSZWN0LmhlaWdodCxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiB9LFxuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IGJhckFsb25nWCAhPT0gaXNVcHdhcmQsXG4gICAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiBpc1Vwd2FyZCxcbiAgICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IGJhckFsb25nWCA9PT0gaXNVcHdhcmQsXG4gICAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6ICFpc1Vwd2FyZCxcbiAgICAgICAgY2xpcEJCb3gsXG4gICAgICAgIGxhYmVsOiBsYWJlbFRleHQgIT0gbnVsbCA/IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFRleHQsXG4gICAgICAgICAgZmlsbDogbGFiZWxDb2xvcixcbiAgICAgICAgICBmb250U3R5bGU6IGxhYmVsRm9udFN0eWxlLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsRm9udFdlaWdodCxcbiAgICAgICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBsYWJlbEZvbnRGYW1pbHksXG4gICAgICAgICAgLi4uYWRqdXN0TGFiZWxQbGFjZW1lbnQoe1xuICAgICAgICAgICAgaXNQb3NpdGl2ZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6ICFiYXJBbG9uZ1gsXG4gICAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgICByZWN0XG4gICAgICAgICAgfSlcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgbWlzc2luZzogeVZhbHVlID09IG51bGwsXG4gICAgICAgIGZvY3VzYWJsZTogIXBoYW50b21cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB7IGdyb3VwU2NhbGUsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgY29uc3QgcGhhbnRvbU5vZGVzID0gW107XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBbXTtcbiAgICBwcm9jZXNzZWREYXRhPy5kYXRhLmZvckVhY2goKHsga2V5cywgZGF0dW06IHNlcmllc0RhdHVtLCB2YWx1ZXMsIGFnZ1ZhbHVlcyB9KSA9PiB7XG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIHZhbHVlSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeFZhbHVlID0ga2V5c1t4SW5kZXhdO1xuICAgICAgICBjb25zdCB5UmF3VmFsdWUgPSB2YWx1ZVt5UmF3SW5kZXhdO1xuICAgICAgICBjb25zdCB5U3RhcnQgPSBOdW1iZXIodmFsdWVbeVN0YXJ0SW5kZXhdKTtcbiAgICAgICAgY29uc3QgeUZpbHRlclZhbHVlID0geUZpbHRlckluZGV4ICE9IG51bGwgPyBOdW1iZXIodmFsdWVbeUZpbHRlckluZGV4XSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHlFbmQgPSBOdW1iZXIodmFsdWVbeUVuZEluZGV4XSk7XG4gICAgICAgIGNvbnN0IGlzUG9zaXRpdmUgPSB5UmF3VmFsdWUgPj0gMCAmJiAhT2JqZWN0LmlzKHlSYXdWYWx1ZSwgLTApO1xuICAgICAgICBjb25zdCB5UmFuZ2UgPSBhZ2dWYWx1ZXM/Llt5UmFuZ2VJbmRleF1baXNQb3NpdGl2ZSA/IDEgOiAwXSA/PyAwO1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh5RW5kKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh5RmlsdGVyVmFsdWUgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKHlGaWx0ZXJWYWx1ZSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsYWJlbFRleHQgPSB5UmF3VmFsdWUgIT0gbnVsbCA/IHRoaXMuZ2V0TGFiZWxUZXh0KFxuICAgICAgICAgIHRoaXMucHJvcGVydGllcy5sYWJlbCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW1bdmFsdWVJbmRleF0sXG4gICAgICAgICAgICB2YWx1ZTogeUZpbHRlclZhbHVlID8/IHlSYXdWYWx1ZSxcbiAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgeE5hbWUsXG4gICAgICAgICAgICB5TmFtZSxcbiAgICAgICAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgICAgICAgfSxcbiAgICAgICAgICAodikgPT4gaXNGaW5pdGVOdW1iZXIodikgPyB2LnRvRml4ZWQoMikgOiBTdHJpbmcodilcbiAgICAgICAgKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgaW5zZXQgPSB5RmlsdGVyVmFsdWUgIT0gbnVsbCAmJiB5RmlsdGVyVmFsdWUgPiB5UmF3VmFsdWU7XG4gICAgICAgIGNvbnN0IG5vZGVEYXRhID0gbm9kZURhdHVtKHtcbiAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW1bdmFsdWVJbmRleF0sXG4gICAgICAgICAgdmFsdWVJbmRleCxcbiAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgeVZhbHVlOiB5RmlsdGVyVmFsdWUgPz8geVJhd1ZhbHVlLFxuICAgICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogeUZpbHRlclZhbHVlID8/IHlFbmQsXG4gICAgICAgICAgcGhhbnRvbTogZmFsc2UsXG4gICAgICAgICAgY3Vyclk6IHlGaWx0ZXJWYWx1ZSAhPSBudWxsID8geVN0YXJ0ICsgeUZpbHRlclZhbHVlIDogeUVuZCxcbiAgICAgICAgICBwcmV2WTogeVN0YXJ0LFxuICAgICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgICAgeVJhbmdlOiBNYXRoLm1heCh5U3RhcnQgKyAoeUZpbHRlclZhbHVlID8/IC1JbmZpbml0eSksIHlSYW5nZSksXG4gICAgICAgICAgbGFiZWxUZXh0LFxuICAgICAgICAgIGNyb3NzU2NhbGU6IGluc2V0ID8gMC42IDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgbGFiZWxzLnB1c2gobm9kZURhdGEpO1xuICAgICAgICBpZiAoeUZpbHRlclZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBwaGFudG9tTm9kZURhdGEgPSBub2RlRGF0dW0oe1xuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtW3ZhbHVlSW5kZXhdLFxuICAgICAgICAgICAgdmFsdWVJbmRleCxcbiAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgIHlWYWx1ZTogeUZpbHRlclZhbHVlLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RmlsdGVyVmFsdWUsXG4gICAgICAgICAgICBwaGFudG9tOiB0cnVlLFxuICAgICAgICAgICAgY3Vyclk6IHlFbmQsXG4gICAgICAgICAgICBwcmV2WTogeVN0YXJ0LFxuICAgICAgICAgICAgaXNQb3NpdGl2ZSxcbiAgICAgICAgICAgIHlSYW5nZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogdm9pZCAwLFxuICAgICAgICAgICAgY3Jvc3NTY2FsZTogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGhhbnRvbU5vZGVzLnB1c2gocGhhbnRvbU5vZGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhOiBwaGFudG9tTm9kZXMubGVuZ3RoID4gMCA/IFsuLi5waGFudG9tTm9kZXMsIC4uLm5vZGVzXSA6IG5vZGVzLFxuICAgICAgbGFiZWxEYXRhOiBsYWJlbHMsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgUmVjdCgpO1xuICB9XG4gIGdldEhpZ2hsaWdodERhdGEobm9kZURhdGEsIGhpZ2hsaWdodGVkSXRlbSkge1xuICAgIGNvbnN0IGhpZ2hsaWdodEl0ZW0gPSBub2RlRGF0YS5maW5kKFxuICAgICAgKG5vZGVEYXR1bSkgPT4gbm9kZURhdHVtLmRhdHVtID09PSBoaWdobGlnaHRlZEl0ZW0uZGF0dW0gJiYgIW5vZGVEYXR1bS5waGFudG9tXG4gICAgKTtcbiAgICByZXR1cm4gaGlnaGxpZ2h0SXRlbSAhPSBudWxsID8gW2hpZ2hsaWdodEl0ZW1dIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5kYXR1bVNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBvcHRzLm5vZGVEYXRhLFxuICAgICAgdm9pZCAwLFxuICAgICAgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLnhWYWx1ZSwgZGF0dW0udmFsdWVJbmRleCwgZGF0dW0ucGhhbnRvbSlcbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtTm9kZXMob3B0cykge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB5S2V5LFxuICAgICAgc3RhY2tHcm91cCxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBpdGVtU3R5bGVyLFxuICAgICAgc2hhZG93LFxuICAgICAgaGlnaGxpZ2h0U3R5bGU6IHsgaXRlbTogaXRlbUhpZ2hsaWdodFN0eWxlIH1cbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IGNyaXNwID0gdGhpcy5wcm9wZXJ0aWVzLmNyaXNwID8/IGNoZWNrQ3Jpc3AoeEF4aXM/LnNjYWxlLCB4QXhpcz8udmlzaWJsZVJhbmdlLCB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsLCB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwpO1xuICAgIGNvbnN0IGNhdGVnb3J5QWxvbmdYID0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovO1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBmaWxsU2hhZG93OiBzaGFkb3csXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChzdHJva2VXaWR0aCksXG4gICAgICBmaWxsT3BhY2l0eTogMCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDBcbiAgICB9O1xuICAgIGNvbnN0IHJlY3RQYXJhbXMgPSB7XG4gICAgICBkYXR1bTogdm9pZCAwLFxuICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgaXNIaWdobGlnaHRlZDogb3B0cy5pc0hpZ2hsaWdodCxcbiAgICAgIGhpZ2hsaWdodFN0eWxlOiBpdGVtSGlnaGxpZ2h0U3R5bGUsXG4gICAgICB5S2V5LFxuICAgICAgc3R5bGUsXG4gICAgICBpdGVtU3R5bGVyLFxuICAgICAgc3RhY2tHcm91cFxuICAgIH07XG4gICAgb3B0cy5kYXR1bVNlbGVjdGlvbi5lYWNoKChyZWN0LCBkYXR1bSkgPT4ge1xuICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eSAqIChkYXR1bS5waGFudG9tID8gMC4yIDogMSk7XG4gICAgICBzdHlsZS5zdHJva2VPcGFjaXR5ID0gc3Ryb2tlT3BhY2l0eSAqIChkYXR1bS5waGFudG9tID8gMC4yIDogMSk7XG4gICAgICBzdHlsZS5jb3JuZXJSYWRpdXMgPSBkYXR1bS5jb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS50b3BMZWZ0Q29ybmVyUmFkaXVzID0gZGF0dW0udG9wTGVmdENvcm5lclJhZGl1cztcbiAgICAgIHN0eWxlLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gZGF0dW0udG9wUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGRhdHVtLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IGRhdHVtLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2aXNpYmxlID0gY2F0ZWdvcnlBbG9uZ1ggPyAoZGF0dW0uY2xpcEJCb3g/LndpZHRoID8/IGRhdHVtLndpZHRoKSA+IDAgOiAoZGF0dW0uY2xpcEJCb3g/LmhlaWdodCA/PyBkYXR1bS5oZWlnaHQpID4gMDtcbiAgICAgIHJlY3RQYXJhbXMuZGF0dW0gPSBkYXR1bTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGdldFJlY3RDb25maWcocmVjdFBhcmFtcyk7XG4gICAgICBjb25maWcuY3Jpc3AgPSBjcmlzcDtcbiAgICAgIGNvbmZpZy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgIHVwZGF0ZVJlY3QocmVjdCwgY29uZmlnKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKSA/IG9wdHMubGFiZWxEYXRhIDogW107XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKGRhdGEsICh0ZXh0KSA9PiB7XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0Tm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHVwZGF0ZUxhYmVsTm9kZSh0ZXh0Tm9kZSwgdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLCBkYXR1bS5sYWJlbCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgdG9vbHRpcCwgaXRlbVN0eWxlciwgc3RhY2tHcm91cCwgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHhWYWx1ZSwgeVZhbHVlLCBkYXR1bSwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeFN0cmluZyA9IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSk7XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwoeU5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoeFN0cmluZyArIFwiOiBcIiArIHlTdHJpbmcpO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgc3RhY2tHcm91cCxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChzdHJva2VXaWR0aCksXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgY29ybmVyUmFkaXVzOiB0aGlzLnByb3BlcnRpZXMuY29ybmVyUmFkaXVzLFxuICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCA/PyBbXSxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gZm9ybWF0Py5maWxsID8/IGZpbGw7XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgc3RhY2tHcm91cCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgICAgLi4udGhpcy5nZXRNb2R1bGVUb29sdGlwUGFyYW1zKClcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgc2hvd0luTGVnZW5kIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIiB8fCAhdGhpcy5kYXRhPy5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXNob3dJbkxlZ2VuZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHlLZXksIHlOYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgbGVnZW5kSXRlbU5hbWUsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDogeyB0ZXh0OiBsZWdlbmRJdGVtTmFtZSA/PyB5TmFtZSA/PyB5S2V5IH0sXG4gICAgICAgIHN5bWJvbHM6IFt7IG1hcmtlcjogeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9IH1dLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zIH0pIHtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odGhpcy5pc1ZlcnRpY2FsKCksIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcIm5vZGVzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIFtkYXR1bVNlbGVjdGlvbl0sIGZucyk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucywgcHJldmlvdXNDb250ZXh0RGF0YSB9ID0gZGF0YTtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgY29uc3QgZGF0YURpZmYgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgY29uc3QgbW9kZSA9IHByZXZpb3VzQ29udGV4dERhdGEgPT0gbnVsbCA/IFwiZmFkZVwiIDogXCJub3JtYWxcIjtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odGhpcy5pc1ZlcnRpY2FsKCksIHRoaXMuYXhlcywgbW9kZSkpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2RhdHVtU2VsZWN0aW9uXSxcbiAgICAgIGZucyxcbiAgICAgIChfLCBkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUsIGRhdHVtLnZhbHVlSW5kZXgsIGRhdHVtLnBoYW50b20pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIGNvbnN0IGhhc01vdGlvbiA9IGRhdGFEaWZmPy5jaGFuZ2VkID8/IHRydWU7XG4gICAgaWYgKGhhc01vdGlvbikge1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMoeyBkYXR1bUluZGV4LCBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCBkYXR1bUJveCA9IHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YVtkYXR1bUluZGV4XS5jbGlwQkJveDtcbiAgICByZXR1cm4gY29tcHV0ZUJhckZvY3VzQm91bmRzKGRhdHVtQm94LCB0aGlzLmNvbnRlbnRHcm91cCwgc2VyaWVzUmVjdCk7XG4gIH1cbn07XG5CYXJTZXJpZXMuY2xhc3NOYW1lID0gXCJCYXJTZXJpZXNcIjtcbkJhclNlcmllcy50eXBlID0gXCJiYXJcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJTZXJpZXNNb2R1bGUudHNcbnZhciBCYXJTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJiYXJcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJhclNlcmllcyhjdHgpLFxuICBzdGFja2FibGU6IHRydWUsXG4gIGdyb3VwYWJsZTogdHJ1ZSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9XG4gIF0sXG4gIHN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvbjogKHNlcmllcykgPT4gc2VyaWVzPy5kaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBkaXJlY3Rpb246IFwidmVydGljYWxcIixcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gICAgICAgIHBsYWNlbWVudDogXCJpbnNpZGVcIlxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgICAgeE9mZnNldDogMyxcbiAgICAgICAgeU9mZnNldDogMyxcbiAgICAgICAgYmx1cjogNVxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAwLjNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9jb2xvclNjYWxlLnRzXG52YXIgY29udmVydENvbG9yU3RyaW5nVG9Pa2xjaGEgPSAodikgPT4ge1xuICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21TdHJpbmcodik7XG4gIGNvbnN0IFtsLCBjLCBoXSA9IENvbG9yLlJHQnRvT0tMQ0goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIHJldHVybiB7IGwsIGMsIGgsIGE6IGNvbG9yLmEgfTtcbn07XG52YXIgZGVsdGEgPSAxZS02O1xudmFyIGlzQWNocm9tYXRpYyA9ICh4KSA9PiB4LmMgPCBkZWx0YSB8fCB4LmwgPCBkZWx0YSB8fCB4LmwgPiAxIC0gZGVsdGE7XG52YXIgaW50ZXJwb2xhdGVPa2xjaCA9ICh4LCB5LCBkKSA9PiB7XG4gIGQgPSBjbGFtcCgwLCBkLCAxKTtcbiAgbGV0IGg7XG4gIGlmIChpc0FjaHJvbWF0aWMoeCkpIHtcbiAgICBoID0geS5oO1xuICB9IGVsc2UgaWYgKGlzQWNocm9tYXRpYyh5KSkge1xuICAgIGggPSB4Lmg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeEggPSB4Lmg7XG4gICAgbGV0IHlIID0geS5oO1xuICAgIGNvbnN0IGRlbHRhSCA9IHkuaCAtIHguaDtcbiAgICBpZiAoZGVsdGFIID4gMTgwKSB7XG4gICAgICB5SCAtPSAzNjA7XG4gICAgfSBlbHNlIGlmIChkZWx0YUggPCAtMTgwKSB7XG4gICAgICB5SCArPSAzNjA7XG4gICAgfVxuICAgIGggPSB4SCAqICgxIC0gZCkgKyB5SCAqIGQ7XG4gIH1cbiAgY29uc3QgYyA9IHguYyAqICgxIC0gZCkgKyB5LmMgKiBkO1xuICBjb25zdCBsID0geC5sICogKDEgLSBkKSArIHkubCAqIGQ7XG4gIGNvbnN0IGEgPSB4LmEgKiAoMSAtIGQpICsgeS5hICogZDtcbiAgcmV0dXJuIENvbG9yLmZyb21PS0xDSChsLCBjLCBoLCBhKTtcbn07XG52YXIgQ29sb3JTY2FsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50eXBlID0gXCJjb2xvclwiO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5yYW5nZSA9IFtcInJlZFwiLCBcImJsdWVcIl07XG4gICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvT2tsY2hhKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgeyBkb21haW4sIHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJgY29sb3JEb21haW5gIHNob3VsZCBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzLlwiKTtcbiAgICAgIGlmIChkb21haW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvbWFpbi5wdXNoKDAsIDEpO1xuICAgICAgfSBlbHNlIGlmIChkb21haW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGRvbWFpbi5wdXNoKGRvbWFpblswXSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRvbWFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYSA9IGRvbWFpbltpIC0gMV07XG4gICAgICBjb25zdCBiID0gZG9tYWluW2ldO1xuICAgICAgaWYgKGEgPj0gYikge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXCJgY29sb3JEb21haW5gIHZhbHVlcyBzaG91bGQgYmUgc3VwcGxpZWQgaW4gYXNjZW5kaW5nIG9yZGVyLlwiKTtcbiAgICAgICAgZG9tYWluLnNvcnQoKGEyLCBiMikgPT4gYTIgLSBiMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFuZ2UzLmxlbmd0aCA8IGRvbWFpbi5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSByYW5nZTMubGVuZ3RoOyBpIDwgZG9tYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJhbmdlMy5wdXNoKHJhbmdlMy5sZW5ndGggPiAwID8gcmFuZ2UzWzBdIDogXCJibGFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvT2tsY2hhKTtcbiAgfVxuICBjb252ZXJ0KHgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCB7IGRvbWFpbiwgcmFuZ2U6IHJhbmdlMywgcGFyc2VkUmFuZ2UgfSA9IHRoaXM7XG4gICAgY29uc3QgZDAgPSBkb21haW5bMF07XG4gICAgY29uc3QgZDEgPSBkb21haW4uYXQoLTEpO1xuICAgIGNvbnN0IHIwID0gcmFuZ2UzWzBdO1xuICAgIGNvbnN0IHIxID0gcmFuZ2UzW3JhbmdlMy5sZW5ndGggLSAxXTtcbiAgICBpZiAoeCA8PSBkMCkge1xuICAgICAgcmV0dXJuIHIwO1xuICAgIH1cbiAgICBpZiAoeCA+PSBkMSkge1xuICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IHE7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHQgPSAoeCAtIGQwKSAvIChkMSAtIGQwKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gKHJhbmdlMy5sZW5ndGggLSAxKTtcbiAgICAgIGluZGV4ID0gcmFuZ2UzLmxlbmd0aCA8PSAyID8gMCA6IE1hdGgubWluKE1hdGguZmxvb3IodCAqIChyYW5nZTMubGVuZ3RoIC0gMSkpLCByYW5nZTMubGVuZ3RoIC0gMik7XG4gICAgICBxID0gKHQgLSBpbmRleCAqIHN0ZXApIC8gc3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgZG9tYWluLmxlbmd0aCAtIDI7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKHggPCBkb21haW5baW5kZXggKyAxXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gZG9tYWluW2luZGV4XTtcbiAgICAgIGNvbnN0IGIgPSBkb21haW5baW5kZXggKyAxXTtcbiAgICAgIHEgPSAoeCAtIGEpIC8gKGIgLSBhKTtcbiAgICB9XG4gICAgY29uc3QgYzAgPSBwYXJzZWRSYW5nZVtpbmRleF07XG4gICAgY29uc3QgYzEgPSBwYXJzZWRSYW5nZVtpbmRleCArIDFdO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZU9rbGNoKGMwLCBjMSwgcSkudG9SZ2JhU3RyaW5nKCk7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAoIXRoaXMuaW52YWxpZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcIkV4cGVjdGVkIHVwZGF0ZSB0byBub3QgaW52YWxpZGF0ZSBzY2FsZVwiKTtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIENvbG9yU2NhbGUucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgQ29sb3JTY2FsZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYnViYmxlU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEJ1YmJsZVNlcmllc01hcmtlciA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTWFya2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1heFNpemUgPSAzMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcIm1heFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbnZhciBCdWJibGVTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJ0b3BcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExBQkVMX1BMQUNFTUVOVClcbl0sIEJ1YmJsZVNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgMik7XG52YXIgQnViYmxlU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvclJhbmdlID0gW1wiI2ZmZmYwMFwiLCBcIiMwMGZmMDBcIiwgXCIjMDAwMGZmXCJdO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQnViYmxlU2VyaWVzTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIC8vIE5vIHZhbGlkYXRpb24uIE5vdCBhIHBhcnQgb2YgdGhlIG9wdGlvbnMgY29udHJhY3QuXG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgQnViYmxlU2VyaWVzTWFya2VyKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yRG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JSYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNoYXBlXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2l6ZVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIubWF4U2l6ZVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibWF4U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZG9tYWluXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbFwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsT3BhY2l0eVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVdpZHRoXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlT3BhY2l0eVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuaXRlbVN0eWxlclwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllcy50c1xudmFyIEJ1YmJsZVNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5zaXplS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2l6ZUtleTtcbiAgfVxufTtcbnZhciBCdWJibGVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIE5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUICovLFxuICAgICAgICAzIC8qIE5FQVJFU1RfTk9ERSAqLyxcbiAgICAgICAgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICAgXSxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXSxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxuICAgICAgICBtYXJrZXI6IHJlc2V0TWFya2VyRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLk5vZGVFdmVudCA9IEJ1YmJsZVNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgQnViYmxlU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuc2l6ZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCB0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGNvbG9yU2NhbGVUeXBlID0gdGhpcy5jb2xvclNjYWxlLnR5cGU7XG4gICAgY29uc3Qgc2l6ZVNjYWxlVHlwZSA9IHRoaXMuc2l6ZVNjYWxlLnR5cGU7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSwgY29sb3JEb21haW4sIGNvbG9yUmFuZ2UsIGNvbG9yS2V5LCBtYXJrZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCB0aGlzLmRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieEtleS1yYXdcIiB9KSxcbiAgICAgICAga2V5UHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogXCJ5S2V5LXJhd1wiIH0pLFxuICAgICAgICAuLi5sYWJlbEtleSA/IFtrZXlQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbEtleS1yYXdgIH0pXSA6IFtdLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IGB4VmFsdWVgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHNpemVLZXksIHNpemVTY2FsZVR5cGUsIHsgaWQ6IGBzaXplVmFsdWVgIH0pLFxuICAgICAgICAuLi5jb2xvcktleSA/IFt2YWx1ZVByb3BlcnR5KGNvbG9yS2V5LCBjb2xvclNjYWxlVHlwZSwgeyBpZDogYGNvbG9yVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICAuLi5sYWJlbEtleSA/IFt2YWx1ZVByb3BlcnR5KGxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGxhYmVsVmFsdWVgIH0pXSA6IFtdXG4gICAgICBdXG4gICAgfSk7XG4gICAgY29uc3Qgc2l6ZUtleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2l6ZVZhbHVlYCk7XG4gICAgY29uc3QgcHJvY2Vzc2VkU2l6ZSA9IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tzaXplS2V5SWR4XSA/PyBbXTtcbiAgICB0aGlzLnNpemVTY2FsZS5kb21haW4gPSBtYXJrZXIuZG9tYWluID8gbWFya2VyLmRvbWFpbiA6IHByb2Nlc3NlZFNpemU7XG4gICAgaWYgKGNvbG9yS2V5KSB7XG4gICAgICBjb25zdCBjb2xvcktleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLmRvbWFpbiA9IGNvbG9yRG9tYWluID8/IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tjb2xvcktleUlkeF0gPz8gW107XG4gICAgICB0aGlzLmNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBpZCA9IGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IGB4VmFsdWVgIDogYHlWYWx1ZWA7XG4gICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRhdGFEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgZGF0YURlZj8uZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gZG9tYWluO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGRvbWFpbiksIGF4aXMpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBjb2xvclNjYWxlLCBzaXplU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSwgeE5hbWUsIHlOYW1lLCBzaXplTmFtZSwgbGFiZWxOYW1lLCBsYWJlbCwgY29sb3JLZXksIG1hcmtlciwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG1hcmtlclNoYXBlID0gZ2V0TWFya2VyKG1hcmtlci5zaGFwZSk7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQgfSA9IGxhYmVsO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCEoZGF0YU1vZGVsICYmIHByb2Nlc3NlZERhdGEgJiYgdmlzaWJsZSAmJiB4QXhpcyAmJiB5QXhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeERhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IHlEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVgKTtcbiAgICBjb25zdCBzaXplRGF0YUlkeCA9IHNpemVLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNpemVWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgY29sb3JEYXRhSWR4ID0gY29sb3JLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IGxhYmVsRGF0YUlkeCA9IGxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsYWJlbFZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBzaXplU2NhbGUucmFuZ2UgPSBbbWFya2VyLnNpemUsIG1hcmtlci5tYXhTaXplXTtcbiAgICBjb25zdCBmb250ID0gbGFiZWwuZ2V0Rm9udCgpO1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250IH0pO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZXMsIGRhdHVtIH0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhID8/IFtdKSB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeERhdGFJZHhdO1xuICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldDtcbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5RGF0dW0pICsgeU9mZnNldDtcbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxhYmVsLCB7XG4gICAgICAgIHZhbHVlOiBsYWJlbEtleSA/IHZhbHVlc1tsYWJlbERhdGFJZHhdIDogeURhdHVtLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgc2l6ZUtleSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgc2l6ZU5hbWUsXG4gICAgICAgIGxhYmVsTmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzaXplID0gdGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KFN0cmluZyhsYWJlbFRleHQpKTtcbiAgICAgIGNvbnN0IG1hcmtlclNpemUgPSBzaXplS2V5ID8gc2l6ZVNjYWxlLmNvbnZlcnQodmFsdWVzW3NpemVEYXRhSWR4XSkgOiBtYXJrZXIuc2l6ZTtcbiAgICAgIGNvbnN0IGZpbGwgPSBjb2xvcktleSA/IGNvbG9yU2NhbGUuY29udmVydCh2YWx1ZXNbY29sb3JEYXRhSWR4XSkgOiB2b2lkIDA7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgIHNpemVWYWx1ZTogdmFsdWVzW3NpemVEYXRhSWR4XSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgc2l6ZTogbWFya2VyU2l6ZSB9LFxuICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXG4gICAgICAgIGZpbGwsXG4gICAgICAgIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCwgLi4uc2l6ZSB9LFxuICAgICAgICBtYXJrZXI6IG1hcmtlclNoYXBlLFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHROb2RlRGF0YT8ubGFiZWxEYXRhID8/IFtdO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5lbmFibGVkID8gbm9kZURhdGEgOiBbXTtcbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIGRhdGEsXG4gICAgICB2b2lkIDAsXG4gICAgICAoZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoW2RhdHVtLnhWYWx1ZSwgZGF0dW0ueVZhbHVlLCBkYXR1bS5sYWJlbC50ZXh0XSlcbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sXG4gICAgICBtYXJrZXIuZ2V0U3R5bGUoKVxuICAgICk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0geyBzaXplLCBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfTtcbiAgICB0aGlzLnNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9LCBiYXNlU3R5bGUpO1xuICAgIH0pO1xuICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5tYXJrZXIubWFya0NsZWFuKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCBwbGFjZWRMYWJlbHMgPSB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZCA/IHRoaXMuY2hhcnQ/LnBsYWNlTGFiZWxzKCkuZ2V0KHRoaXMpID8/IFtdIDogW107XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgcGxhY2VkTGFiZWxzLm1hcCgodikgPT4gKHtcbiAgICAgICAgLi4udi5kYXR1bSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICB4OiB2LngsXG4gICAgICAgICAgeTogdi55LFxuICAgICAgICAgIHNpemU6IHYuZGF0dW0ucG9pbnQuc2l6ZVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICB0ZXh0LnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xuICAgICAgdGV4dC5maWxsID0gbGFiZWwuY29sb3I7XG4gICAgICB0ZXh0LnggPSBkYXR1bS5wb2ludD8ueCA/PyAwO1xuICAgICAgdGV4dC55ID0gZGF0dW0ucG9pbnQ/LnkgPz8gMDtcbiAgICAgIHRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgICAgdGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICAgIHRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICAgIHRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCB4TmFtZSwgeU5hbWUsIHNpemVOYW1lLCBsYWJlbE5hbWUsIG1hcmtlciwgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlID8/IHlOYW1lO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICB7IGZpbGw6IG5vZGVEYXR1bS5maWxsLCBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChtYXJrZXIuc3Ryb2tlV2lkdGgpIH0sXG4gICAgICBtYXJrZXIuZ2V0U3R5bGUoKVxuICAgICk7XG4gICAgY29uc3QgeyBmaWxsOiBjb2xvciA9IFwiZ3JheVwiIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCBoaWdobGlnaHRlZDogZmFsc2UsIHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5IH0sXG4gICAgICBiYXNlU3R5bGVcbiAgICApO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdHVtLFxuICAgICAgeFZhbHVlLFxuICAgICAgeVZhbHVlLFxuICAgICAgc2l6ZVZhbHVlLFxuICAgICAgbGFiZWw6IHsgdGV4dDogbGFiZWxUZXh0IH0sXG4gICAgICBpdGVtSWRcbiAgICB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHhTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHNhbml0aXplSHRtbCh5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpKTtcbiAgICBsZXQgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbCh4TmFtZSA/PyB4S2V5KX08L2I+OiAke3hTdHJpbmd9PGJyPjxiPiR7c2FuaXRpemVIdG1sKHlOYW1lID8/IHlLZXkpfTwvYj46ICR7eVN0cmluZ31gO1xuICAgIGlmIChzaXplS2V5KSB7XG4gICAgICBjb250ZW50ICs9IGA8YnI+PGI+JHtzYW5pdGl6ZUh0bWwoc2l6ZU5hbWUgPz8gc2l6ZUtleSl9PC9iPjogJHtzYW5pdGl6ZUh0bWwoU3RyaW5nKHNpemVWYWx1ZSkpfWA7XG4gICAgfVxuICAgIGlmIChsYWJlbEtleSkge1xuICAgICAgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbChsYWJlbE5hbWUgPz8gbGFiZWxLZXkpfTwvYj46ICR7c2FuaXRpemVIdG1sKGxhYmVsVGV4dCl9PGJyPmAgKyBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAgeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB4S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHNpemVLZXksXG4gICAgICAgIHNpemVOYW1lLFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgbGFiZWxOYW1lLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKCkge1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgdGl0bGUsIG1hcmtlciwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2hhcGUsIGZpbGwsIHN0cm9rZSwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoIH0gPSBtYXJrZXI7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB0aXRsZSA/PyB5TmFtZSA/PyB5S2V5XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgIGZpbGw6IGZpbGwgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggPz8gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uIH0pIHtcbiAgICBtYXJrZXJTY2FsZUluQW5pbWF0aW9uKHRoaXMsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKCk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pIHtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwge1xuICAgICAgZGF0dW0sXG4gICAgICB4S2V5LFxuICAgICAgeUtleSxcbiAgICAgIHNpemVLZXksXG4gICAgICBsYWJlbEtleSxcbiAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkJ1YmJsZVNlcmllcy5jbGFzc05hbWUgPSBcIkJ1YmJsZVNlcmllc1wiO1xuQnViYmxlU2VyaWVzLnR5cGUgPSBcImJ1YmJsZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllc01vZHVsZS50c1xudmFyIEJ1YmJsZVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImJ1YmJsZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQnViYmxlU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICBzaXplOiA3LFxuICAgICAgbWF4U2l6ZTogMzAsXG4gICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgdG9vbHRpcDogeyBwb3NpdGlvbjogeyB0eXBlOiBcIm5vZGVcIiB9IH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmFyZWFQbG90ID0gZmFsc2U7XG4gICAgdGhpcy5hZ2dyZWdhdGlvbiA9IFwic3VtXCI7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFyZWFQbG90XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImJpbnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJjb3VudFwiLCBcInN1bVwiLCBcIm1lYW5cIl0sIFwiYSBoaXN0b2dyYW0gYWdncmVnYXRpb25cIikpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhZ2dyZWdhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYmluQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaGlzdG9ncmFtU2VyaWVzLnRzXG52YXIgZGVmYXVsdEJpbkNvdW50ID0gMTA7XG52YXIgSGlzdG9ncmFtU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFszIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIGRhdHVtOiByZXNldEJhclNlbGVjdGlvbnNGbixcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVkQmlucyA9IFtdO1xuICB9XG4gIC8vIER1cmluZyBwcm9jZXNzRGF0YSBwaGFzZSwgdXNlZCB0byB1bmlmeSBkaWZmZXJlbnQgd2F5cyBvZiB0aGUgdXNlciBzcGVjaWZ5aW5nXG4gIC8vIHRoZSBiaW5zLiBSZXR1cm5zIGJpbnMgaW4gZm9ybWF0W1ttaW4xLCBtYXgxXSwgW21pbjIsIG1heDJdLCAuLi4gXS5cbiAgZGVyaXZlQmlucyh4RG9tYWluKSB7XG4gICAgY29uc3QgYmluU3RhcnRzID0gY3JlYXRlVGlja3MoeERvbWFpblswXSwgeERvbWFpblsxXSwgZGVmYXVsdEJpbkNvdW50KTtcbiAgICBjb25zdCBiaW5TaXplID0gdGlja1N0ZXAoeERvbWFpblswXSwgeERvbWFpblsxXSwgZGVmYXVsdEJpbkNvdW50KTtcbiAgICBjb25zdCBbZmlyc3RCaW5FbmRdID0gYmluU3RhcnRzO1xuICAgIGNvbnN0IGV4cGFuZFN0YXJ0VG9CaW4gPSAobikgPT4gW24sIG4gKyBiaW5TaXplXTtcbiAgICByZXR1cm4gW1tmaXJzdEJpbkVuZCAtIGJpblNpemUsIGZpcnN0QmluRW5kXSwgLi4uYmluU3RhcnRzLm1hcChleHBhbmRTdGFydFRvQmluKV07XG4gIH1cbiAgY2FsY3VsYXRlTmljZUJpbnMoZG9tYWluLCBiaW5Db3VudCkge1xuICAgIGNvbnN0IHN0YXJ0R3Vlc3MgPSBNYXRoLmZsb29yKGRvbWFpblswXSk7XG4gICAgY29uc3Qgc3RvcCA9IGRvbWFpblsxXTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGJpbkNvdW50IHx8IDE7XG4gICAgY29uc3QgeyBzdGFydCwgYmluU2l6ZSB9ID0gdGhpcy5jYWxjdWxhdGVOaWNlU3RhcnQoc3RhcnRHdWVzcywgc3RvcCwgc2VnbWVudHMpO1xuICAgIHJldHVybiB0aGlzLmdldEJpbnMoc3RhcnQsIHN0b3AsIGJpblNpemUsIHNlZ21lbnRzKTtcbiAgfVxuICBnZXRCaW5zKHN0YXJ0LCBzdG9wLCBzdGVwLCBjb3VudCkge1xuICAgIGNvbnN0IGJpbnMgPSBbXTtcbiAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmNhbGN1bGF0ZVByZWNpc2lvbihzdGVwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLnJvdW5kKChzdGFydCArIGkgKiBzdGVwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICBsZXQgYiA9IE1hdGgucm91bmQoKHN0YXJ0ICsgKGkgKyAxKSAqIHN0ZXApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgIGlmIChpID09PSBjb3VudCAtIDEpIHtcbiAgICAgICAgYiA9IE1hdGgubWF4KGIsIHN0b3ApO1xuICAgICAgfVxuICAgICAgYmluc1tpXSA9IFthLCBiXTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbnM7XG4gIH1cbiAgY2FsY3VsYXRlUHJlY2lzaW9uKHN0ZXApIHtcbiAgICBsZXQgcHJlY2lzaW9uID0gMTA7XG4gICAgaWYgKGlzRmluaXRlKHN0ZXApICYmIHN0ZXAgPiAwKSB7XG4gICAgICB3aGlsZSAoc3RlcCA8IDEpIHtcbiAgICAgICAgcHJlY2lzaW9uICo9IDEwO1xuICAgICAgICBzdGVwICo9IDEwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlY2lzaW9uO1xuICB9XG4gIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBzZWdtZW50cykge1xuICAgIGNvbnN0IGJpblNpemUgPSBNYXRoLmFicyhiIC0gYSkgLyBzZWdtZW50cztcbiAgICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChiaW5TaXplKSk7XG4gICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoYSAvIG1hZ25pdHVkZSkgKiBtYWduaXR1ZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgYmluU2l6ZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgdGhpcy5wcm9jZXNzZWREYXRhID0gdm9pZCAwO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBhcmVhUGxvdCwgYWdncmVnYXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB5U2NhbGUsIHhTY2FsZSB9KTtcbiAgICBjb25zdCBwcm9wcyA9IFtrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlKSwgU09SVF9ET01BSU5fR1JPVVBTXTtcbiAgICBpZiAoeUtleSkge1xuICAgICAgbGV0IGFnZ1Byb3AgPSBncm91cENvdW50KFwiZ3JvdXBBZ2dcIik7XG4gICAgICBpZiAoYWdncmVnYXRpb24gPT09IFwiY291bnRcIikge1xuICAgICAgfSBlbHNlIGlmIChhZ2dyZWdhdGlvbiA9PT0gXCJzdW1cIikge1xuICAgICAgICBhZ2dQcm9wID0gZ3JvdXBTdW0oXCJncm91cEFnZ1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoYWdncmVnYXRpb24gPT09IFwibWVhblwiKSB7XG4gICAgICAgIGFnZ1Byb3AgPSBncm91cEF2ZXJhZ2UoXCJncm91cEFnZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmVhUGxvdCkge1xuICAgICAgICBhZ2dQcm9wID0gYXJlYShcImdyb3VwQWdnXCIsIGFnZ1Byb3ApO1xuICAgICAgfVxuICAgICAgcHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaW52YWxpZFZhbHVlOiB2b2lkIDAgfSksIGFnZ1Byb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYWdnUHJvcCA9IGdyb3VwQ291bnQoXCJncm91cEFnZ1wiKTtcbiAgICAgIGlmIChhcmVhUGxvdCkge1xuICAgICAgICBhZ2dQcm9wID0gYXJlYShcImdyb3VwQWdnXCIsIGFnZ1Byb3ApO1xuICAgICAgfVxuICAgICAgcHJvcHMucHVzaChhZ2dQcm9wKTtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBCeUZuID0gKGRhdGFTZXQpID0+IHtcbiAgICAgIGNvbnN0IHhFeHRlbnQgPSBmaXhOdW1lcmljRXh0ZW50KGRhdGFTZXQuZG9tYWluLmtleXNbMF0pO1xuICAgICAgaWYgKHhFeHRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRhdGFTZXQuZG9tYWluLmdyb3VwcyA9IFtdO1xuICAgICAgICByZXR1cm4gKCkgPT4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBiaW5zID0gaXNOdW1iZXIodGhpcy5wcm9wZXJ0aWVzLmJpbkNvdW50KSA/IHRoaXMuY2FsY3VsYXRlTmljZUJpbnMoeEV4dGVudCwgdGhpcy5wcm9wZXJ0aWVzLmJpbkNvdW50KSA6IHRoaXMucHJvcGVydGllcy5iaW5zID8/IHRoaXMuZGVyaXZlQmlucyh4RXh0ZW50KTtcbiAgICAgIGNvbnN0IGJpbkNvdW50ID0gYmlucy5sZW5ndGg7XG4gICAgICB0aGlzLmNhbGN1bGF0ZWRCaW5zID0gWy4uLmJpbnNdO1xuICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHhWYWx1ZSA9IGl0ZW0ua2V5c1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEJpbiA9IGJpbnNbaV07XG4gICAgICAgICAgaWYgKHhWYWx1ZSA+PSBuZXh0QmluWzBdICYmIHhWYWx1ZSA8IG5leHRCaW5bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0QmluO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gYmluQ291bnQgLSAxICYmIHhWYWx1ZSA8PSBuZXh0QmluWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEJpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGlmICghdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcbiAgICAgIHByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEsIGZhbHNlKSk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgdGhpcy5kYXRhLCB7IHByb3BzLCBncm91cEJ5Rm4gfSk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgIXRoaXMuY2FsY3VsYXRlZEJpbnMubGVuZ3RoKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHlEb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGBncm91cEFnZ2AsIFwiYWdncmVnYXRlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHhEb21haW5NaW4gPSB0aGlzLmNhbGN1bGF0ZWRCaW5zPy5bMF1bMF07XG4gICAgY29uc3QgeERvbWFpbk1heCA9IHRoaXMuY2FsY3VsYXRlZEJpbnM/LlsodGhpcy5jYWxjdWxhdGVkQmlucz8ubGVuZ3RoID8/IDApIC0gMV1bMV07XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoW3hEb21haW5NaW4sIHhEb21haW5NYXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeURvbWFpbik7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgYXhlcyxcbiAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNjYWxlOiB4U2NhbGUgfSA9IHhBeGlzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHlTY2FsZSB9ID0geUF4aXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIGNvcm5lclJhZGl1cyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdHRlcjogbGFiZWxGb3JtYXR0ZXIgPSAocGFyYW1zKSA9PiBTdHJpbmcocGFyYW1zLnZhbHVlKSxcbiAgICAgIGZvbnRTdHlsZTogbGFiZWxGb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0OiBsYWJlbEZvbnRXZWlnaHQsXG4gICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IGxhYmVsRm9udEZhbWlseSxcbiAgICAgIGNvbG9yOiBsYWJlbENvbG9yXG4gICAgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpdGVtSWQ6IHRoaXMucHJvcGVydGllcy55S2V5ID8/IHRoaXMuaWQsXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgYW5pbWF0aW9uVmFsaWQ6IHRydWUsXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8ICFwcm9jZXNzZWREYXRhIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gXCJncm91cGVkXCIpXG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGEuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWdnVmFsdWVzOiBbW25lZ2F0aXZlQWdnLCBwb3NpdGl2ZUFnZ11dID0gW1swLCAwXV0sXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBkYXR1bTogeyBsZW5ndGg6IGZyZXF1ZW5jeSB9LFxuICAgICAgICBrZXlzOiBkb21haW4sXG4gICAgICAgIGtleXM6IFt4RG9tYWluTWluLCB4RG9tYWluTWF4XVxuICAgICAgfSA9IGdyb3VwO1xuICAgICAgY29uc3QgeE1pblB4ID0geFNjYWxlLmNvbnZlcnQoeERvbWFpbk1pbik7XG4gICAgICBjb25zdCB4TWF4UHggPSB4U2NhbGUuY29udmVydCh4RG9tYWluTWF4KTtcbiAgICAgIGNvbnN0IHRvdGFsID0gbmVnYXRpdmVBZ2cgKyBwb3NpdGl2ZUFnZztcbiAgICAgIGNvbnN0IHlaZXJvUHggPSB5U2NhbGUuY29udmVydCgwKTtcbiAgICAgIGNvbnN0IHlNYXhQeCA9IHlTY2FsZS5jb252ZXJ0KHRvdGFsKTtcbiAgICAgIGNvbnN0IHcgPSBNYXRoLmFicyh4TWF4UHggLSB4TWluUHgpO1xuICAgICAgY29uc3QgaCA9IE1hdGguYWJzKHlNYXhQeCAtIHlaZXJvUHgpO1xuICAgICAgY29uc3QgeCA9IE1hdGgubWluKHhNaW5QeCwgeE1heFB4KTtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbih5WmVyb1B4LCB5TWF4UHgpO1xuICAgICAgbGV0IHNlbGVjdGlvbkRhdHVtTGFiZWwgPSB2b2lkIDA7XG4gICAgICBpZiAodG90YWwgIT09IDApIHtcbiAgICAgICAgc2VsZWN0aW9uRGF0dW1MYWJlbCA9IHtcbiAgICAgICAgICB0ZXh0OiBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWxGb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0b3RhbCxcbiAgICAgICAgICAgIGRhdHVtLFxuICAgICAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgIHhOYW1lLFxuICAgICAgICAgICAgeU5hbWVcbiAgICAgICAgICB9KSA/PyBTdHJpbmcodG90YWwpLFxuICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWxGb250U3R5bGUsXG4gICAgICAgICAgZm9udFdlaWdodDogbGFiZWxGb250V2VpZ2h0LFxuICAgICAgICAgIGZvbnRTaXplOiBsYWJlbEZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsRm9udEZhbWlseSxcbiAgICAgICAgICBmaWxsOiBsYWJlbENvbG9yLFxuICAgICAgICAgIHg6IHggKyB3IC8gMixcbiAgICAgICAgICB5OiB5ICsgaCAvIDJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGVNaWRQb2ludCA9IHtcbiAgICAgICAgeDogeCArIHcgLyAyLFxuICAgICAgICB5OiB5ICsgaCAvIDJcbiAgICAgIH07XG4gICAgICBjb25zdCB5QXhpc1JldmVyc2VkID0geUF4aXMuaXNSZXZlcnNlZCgpO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIC8vIHJlcXVpcmVkIGJ5IFNlcmllc05vZGVEYXR1bSwgYnV0IG1pZ2h0IG5vdCBtYWtlIHNlbnNlIGhlcmVcbiAgICAgICAgLy8gc2luY2UgZWFjaCBzZWxlY3Rpb24gaXMgYW4gYWdncmVnYXRpb24gb2YgbXVsdGlwbGUgZGF0YS5cbiAgICAgICAgYWdncmVnYXRlZFZhbHVlOiB0b3RhbCxcbiAgICAgICAgZnJlcXVlbmN5LFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHhWYWx1ZTogeE1pblB4LFxuICAgICAgICB5VmFsdWU6IHlNYXhQeCxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgbWlkUG9pbnQ6IG5vZGVNaWRQb2ludCxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6ICF5QXhpc1JldmVyc2VkLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1czogIXlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiB5QXhpc1JldmVyc2VkLFxuICAgICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiB5QXhpc1JldmVyc2VkLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgbGFiZWw6IHNlbGVjdGlvbkRhdHVtTGFiZWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG5vZGVEYXRhLnNvcnQoKGEsIGIpID0+IGEueCAtIGIueCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0KCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIGRhdHVtU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBkYXR1bVNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBub2RlRGF0YSxcbiAgICAgIChyZWN0KSA9PiB7XG4gICAgICAgIHJlY3QudGFnID0gMCAvKiBCaW4gKi87XG4gICAgICAgIHJlY3QuY3Jpc3AgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0uZG9tYWluLmpvaW4oXCJfXCIpXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bU5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGlzSGlnaGxpZ2h0OiBpc0RhdHVtSGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3Qge1xuICAgICAgZmlsbE9wYWNpdHk6IHNlcmllc0ZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBzaGFkb3csXG4gICAgICBoaWdobGlnaHRTdHlsZToge1xuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgZmlsbDogaGlnaGxpZ2h0ZWRGaWxsLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBoaWdobGlnaHRGaWxsT3BhY2l0eSA9IHNlcmllc0ZpbGxPcGFjaXR5LFxuICAgICAgICAgIHN0cm9rZTogaGlnaGxpZ2h0ZWRTdHJva2UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGhpZ2hsaWdodGVkRGF0dW1TdHJva2VXaWR0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBvcHRzLmRhdHVtU2VsZWN0aW9uLmVhY2goKHJlY3QsIGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgICAgICBib3R0b21SaWdodENvcm5lclJhZGl1cyxcbiAgICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1c1xuICAgICAgfSA9IGRhdHVtO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBpc0RhdHVtSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoICE9PSB2b2lkIDAgPyBoaWdobGlnaHRlZERhdHVtU3Ryb2tlV2lkdGggOiBkYXR1bS5zdHJva2VXaWR0aDtcbiAgICAgIGNvbnN0IGZpbGxPcGFjaXR5ID0gaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0RmlsbE9wYWNpdHkgOiBzZXJpZXNGaWxsT3BhY2l0eTtcbiAgICAgIHJlY3QuZmlsbCA9IChpc0RhdHVtSGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRlZEZpbGwgOiB2b2lkIDApID8/IGRhdHVtLmZpbGw7XG4gICAgICByZWN0LnN0cm9rZSA9IChpc0RhdHVtSGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRlZFN0cm9rZSA6IHZvaWQgMCkgPz8gZGF0dW0uc3Ryb2tlO1xuICAgICAgcmVjdC5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5O1xuICAgICAgcmVjdC5zdHJva2VPcGFjaXR5ID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgIHJlY3Quc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHJlY3QubGluZURhc2ggPSBsaW5lRGFzaDtcbiAgICAgIHJlY3QubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIHJlY3QudG9wTGVmdENvcm5lclJhZGl1cyA9IHRvcExlZnRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC50b3BSaWdodENvcm5lclJhZGl1cyA9IHRvcFJpZ2h0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBib3R0b21SaWdodENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QuZmlsbFNoYWRvdyA9IHNoYWRvdztcbiAgICAgIHJlY3QuekluZGV4ID0gaXNEYXR1bUhpZ2hsaWdodGVkID8gU2VyaWVzLmhpZ2hsaWdodGVkWkluZGV4IDogaW5kZXg7XG4gICAgICByZWN0LnZpc2libGUgPSBkYXR1bS5oZWlnaHQgPiAwO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgcmV0dXJuIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZShsYWJlbERhdGEsICh0ZXh0KSA9PiB7XG4gICAgICB0ZXh0LnRhZyA9IDEgLyogTGFiZWwgKi87XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgbGFiZWxFbmFibGVkID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0ubGFiZWw7XG4gICAgICBpZiAobGFiZWwgJiYgbGFiZWxFbmFibGVkKSB7XG4gICAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICAgIHRleHQueCA9IGxhYmVsLng7XG4gICAgICAgIHRleHQueSA9IGxhYmVsLnk7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQuZmlsbCA9IGxhYmVsLmZpbGw7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpbml0UXVhZFRyZWUocXVhZHRyZWUpIHtcbiAgICBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZShxdWFkdHJlZSwgY2hpbGRyZW5JdGVyKHRoaXMuY29udGVudEdyb3VwLmNoaWxkcmVuWzBdKSk7XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gZmluZFF1YWR0cmVlTWF0Y2godGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbDogY29sb3IsIGFnZ3JlZ2F0aW9uLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3Qge1xuICAgICAgYWdncmVnYXRlZFZhbHVlLFxuICAgICAgZnJlcXVlbmN5LFxuICAgICAgZG9tYWluOiBbcmFuZ2VNaW4sIHJhbmdlTWF4XSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgdGl0bGUgPSBgJHtzYW5pdGl6ZUh0bWwoeE5hbWUgPz8geEtleSl9OiAke3hBeGlzLmZvcm1hdERhdHVtKHJhbmdlTWluKX0gLSAke3hBeGlzLmZvcm1hdERhdHVtKHJhbmdlTWF4KX1gO1xuICAgIGxldCBjb250ZW50ID0geUtleSA/IGA8Yj4ke3Nhbml0aXplSHRtbCh5TmFtZSA/PyB5S2V5KX0gKCR7YWdncmVnYXRpb259KTwvYj46ICR7eUF4aXMuZm9ybWF0RGF0dW0oYWdncmVnYXRlZFZhbHVlKX08YnI+YCA6IFwiXCI7XG4gICAgY29udGVudCArPSBgPGI+RnJlcXVlbmN5PC9iPjogJHtmcmVxdWVuY3l9YDtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoZGVmYXVsdHMsIHtcbiAgICAgIGRhdHVtOiB7XG4gICAgICAgIGRhdGE6IG5vZGVEYXR1bS5kYXR1bSxcbiAgICAgICAgYWdncmVnYXRlZFZhbHVlOiBub2RlRGF0dW0uYWdncmVnYXRlZFZhbHVlLFxuICAgICAgICBkb21haW46IG5vZGVEYXR1bS5kb21haW4sXG4gICAgICAgIGZyZXF1ZW5jeTogbm9kZURhdHVtLmZyZXF1ZW5jeVxuICAgICAgfSxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIHhLZXksXG4gICAgICB4TmFtZSxcbiAgICAgIHlLZXksXG4gICAgICB5TmFtZSxcbiAgICAgIGNvbG9yLFxuICAgICAgdGl0bGUsXG4gICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgIH0pO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGggfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeU5hbWUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB4S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB5TmFtZSA/PyB4S2V5ID8/IFwiRnJlcXVlbmN5XCJcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBmaWxsOiBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiB9KSB7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRydWUsIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImRhdHVtc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbZGF0dW1TZWxlY3Rpb25dLCBmbnMpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZjtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odHJ1ZSwgdGhpcy5heGVzLCBcIm5vcm1hbFwiKSk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwiZGF0dW1zXCIsXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2RhdGEuZGF0dW1TZWxlY3Rpb25dLFxuICAgICAgZm5zLFxuICAgICAgKF8sIGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLmRvbWFpbiksXG4gICAgICBkYXRhRGlmZlxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgZGF0YS5sYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyh7IGRhdHVtSW5kZXgsIHNlcmllc1JlY3QgfSkge1xuICAgIHJldHVybiBjb21wdXRlQmFyRm9jdXNCb3VuZHModGhpcy5jb250ZXh0Tm9kZURhdGE/Lm5vZGVEYXRhW2RhdHVtSW5kZXhdLCB0aGlzLmNvbnRlbnRHcm91cCwgc2VyaWVzUmVjdCk7XG4gIH1cbn07XG5IaXN0b2dyYW1TZXJpZXMuY2xhc3NOYW1lID0gXCJIaXN0b2dyYW1TZXJpZXNcIjtcbkhpc3RvZ3JhbVNlcmllcy50eXBlID0gXCJoaXN0b2dyYW1cIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXNNb2R1bGUudHNcbnZhciBIaXN0b2dyYW1TZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJoaXN0b2dyYW1cIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEhpc3RvZ3JhbVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgICB4T2Zmc2V0OiAzLFxuICAgICAgICB5T2Zmc2V0OiAzLFxuICAgICAgICBibHVyOiA1XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogKHsgdGFrZUNvbG9ycyB9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsbHM6IFtmaWxsXSxcbiAgICAgIHN0cm9rZXM6IFtzdHJva2VdXG4gICAgfSA9IHRha2VDb2xvcnMoMSk7XG4gICAgcmV0dXJuIHsgZmlsbCwgc3Ryb2tlIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBMaW5lU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdHJva2UgPSBcIiM4NzQzNDlcIjtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gbmV3IEludGVycG9sYXRpb25Qcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgU2VyaWVzTWFya2VyKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgdGhpcy5jb25uZWN0TWlzc2luZ0RhdGEgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3RhY2tHcm91cFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRUb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW50ZXJwb2xhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ubmVjdE1pc3NpbmdEYXRhXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXMudHNcbnZhciBMaW5lU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgcGlja01vZGVzOiBbXG4gICAgICAgIDIgLyogTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1QgKi8sXG4gICAgICAgIDMgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldFZpc2libGU6ICgpID0+IHRoaXMudmlzaWJsZSwgZ2V0T3BhY2l0eTogKCkgPT4gdGhpcy5nZXRPcGFjaXR5KCkgfSksXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXG4gICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoeyAuLi5yZXNldE1hcmtlckZuKG5vZGUpLCAuLi5yZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IExpbmVTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhLCB2aXNpYmxlLCBzZXJpZXNHcm91cGluZzogeyBncm91cEluZGV4ID0gdGhpcy5pZCwgc3RhY2tDb3VudCA9IDEgfSA9IHt9IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgY29ubmVjdE1pc3NpbmdEYXRhLCBub3JtYWxpemVkVG8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgaXNDb250aW51b3VzWCwgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgY29tbW9uID0geyBpbnZhbGlkVmFsdWU6IG51bGwgfTtcbiAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmIHN0YWNrQ291bnQgPiAxKSB7XG4gICAgICBjb21tb24uaW52YWxpZFZhbHVlID0gMDtcbiAgICB9XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICBjb21tb24uZm9yY2VWYWx1ZSA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgaWYgKCFpc0NvbnRpbnVvdXNYKSB7XG4gICAgICBwcm9wcy5wdXNoKGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieEtleVwiIH0pKTtcbiAgICB9XG4gICAgcHJvcHMucHVzaChcbiAgICAgIHZhbHVlUHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4VmFsdWVcIiB9KSxcbiAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICBpZDogYHlWYWx1ZVJhd2AsXG4gICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgaW52YWxpZFZhbHVlOiB2b2lkIDBcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAoc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIGNvbnN0IGlkcyA9IFtcbiAgICAgICAgYGxpbmUtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYCxcbiAgICAgICAgYGxpbmUtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzLXRyYWlsaW5nYCxcbiAgICAgICAgYGxpbmUtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzLW1hcmtlcmBcbiAgICAgIF07XG4gICAgICBwcm9wcy5wdXNoKFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvd1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlRW5kYCxcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIGdyb3VwSWQ6IGlkc1swXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvdy10cmFpbGluZ1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlU3RhcnRgLFxuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgZ3JvdXBJZDogaWRzWzFdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwibm9ybWFsXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWVDdW11bGF0aXZlYCxcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIGdyb3VwSWQ6IGlkc1syXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmaW5lZChub3JtYWxpemVkVG8pKSB7XG4gICAgICAgIHByb3BzLnB1c2gobm9ybWFsaXNlR3JvdXBUbyhbaWRzWzBdLCBpZHNbMV0sIGlkc1syXV0sIG5vcm1hbGl6ZWRUbywgXCJyYW5nZVwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBwcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oaXNDb250aW51b3VzWCA/IFtcInhWYWx1ZVwiXSA6IHZvaWQgMCkpO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgICBwcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwgeyBwcm9wcyB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3QgeERlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHhWYWx1ZWAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgICBpZiAoeERlZj8uZGVmLnR5cGUgPT09IFwidmFsdWVcIiAmJiB4RGVmLmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGRvbWFpbiksIHhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHRoaXMuc2VyaWVzR3JvdXBpbmc/LnN0YWNrQ291bnQgPz8gMTtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IHN0YWNrQ291bnQgPiAxID8gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlRW5kYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKSA6IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZVJhd2AsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChkb21haW4sIHlBeGlzKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGF4ZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBtYXJrZXIsIGxhYmVsLCBjb25uZWN0TWlzc2luZ0RhdGEsIGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3Qgc3RhY2tlZCA9ICh0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0NvdW50ID8/IDEpID4gMTtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBjb25zdCBzaXplID0gbWFya2VyLmVuYWJsZWQgPyBtYXJrZXIuc2l6ZSA6IDA7XG4gICAgY29uc3QgeElkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlUmF3YCk7XG4gICAgY29uc3QgeUN1bXVsYXRpdmVJZHggPSBzdGFja2VkID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVDdW11bGF0aXZlYCkgOiB5SWR4O1xuICAgIGNvbnN0IHlFbmRJZHggPSBzdGFja2VkID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVFbmRgKSA6IHZvaWQgMDtcbiAgICBsZXQgbW92ZVRvID0gdHJ1ZTtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGE/LmZvckVhY2goKHsgZGF0dW0sIHZhbHVlcyB9KSA9PiB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeElkeF07XG4gICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeUlkeF07XG4gICAgICBjb25zdCB5Q3VtdWxhdGl2ZURhdHVtID0gdmFsdWVzW3lDdW11bGF0aXZlSWR4XTtcbiAgICAgIGNvbnN0IHlFbmREYXR1bSA9IHlFbmRJZHggIT0gbnVsbCA/IHZhbHVlc1t5RW5kSWR4XSA6IHZvaWQgMDtcbiAgICAgIGlmICh5RGF0dW0gPT0gbnVsbCkge1xuICAgICAgICBtb3ZlVG8gfHwgKG1vdmVUbyA9ICFjb25uZWN0TWlzc2luZ0RhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgbW92ZVRvIHx8IChtb3ZlVG8gPSAhY29ubmVjdE1pc3NpbmdEYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlDdW11bGF0aXZlRGF0dW0pICsgeU9mZnNldDtcbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgeyB2YWx1ZTogeURhdHVtLCBkYXR1bSwgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBsZWdlbmRJdGVtTmFtZSB9LFxuICAgICAgICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSA/IHZhbHVlLnRvRml4ZWQoMikgOiBTdHJpbmcodmFsdWUpXG4gICAgICApO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIHBvaW50OiB7IHgsIHksIG1vdmVUbywgc2l6ZSB9LFxuICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXG4gICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogeUVuZERhdHVtLFxuICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgIGNhcERlZmF1bHRzOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyOiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmdldERpYW1ldGVyKCksXG4gICAgICAgICAgbGVuZ3RoTWF4OiBJbmZpbml0eVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogbGFiZWxUZXh0ID8ge1xuICAgICAgICAgIHRleHQ6IGxhYmVsVGV4dCxcbiAgICAgICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcbiAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxuICAgICAgICAgIGZvbnRTaXplOiBsYWJlbC5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgZmlsbDogbGFiZWwuY29sb3JcbiAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBtb3ZlVG8gPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoczogW2xpbmVOb2RlXSxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlLFxuICAgICAgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0gPSBvcHRzO1xuICAgIGxpbmVOb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogdm9pZCAwLFxuICAgICAgbGluZUpvaW46IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqLyxcbiAgICAgIG9wYWNpdHksXG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldFxuICAgIH0pO1xuICAgIGlmICghYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgbGluZU5vZGUudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIGxpbmVOb2RlKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGxldCB7IG5vZGVEYXRhIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgc2hhcGUsIGVuYWJsZWQgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgbm9kZURhdGEgPSBzaGFwZSAmJiBlbmFibGVkID8gbm9kZURhdGEgOiBbXTtcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHZvaWQgMCwgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLnhWYWx1ZSkpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbWFya2VyLCBoaWdobGlnaHRTdHlsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUuaXRlbSwgbWFya2VyLmdldFN0eWxlKCksIHtcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eVxuICAgIH0pO1xuICAgIGNvbnN0IGFwcGx5VHJhbnNsYXRpb24gPSB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5IH0sIGJhc2VTdHlsZSwgeyBhcHBseVRyYW5zbGF0aW9uIH0pO1xuICAgIH0pO1xuICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIG1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLmlzTGFiZWxFbmFibGVkKCkgPyBvcHRzLmxhYmVsRGF0YSA6IFtdKTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGNvbG9yIH0gPSB0aGlzLnByb3BlcnRpZXMubGFiZWw7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBwb2ludCwgbGFiZWwgfSA9IGRhdHVtO1xuICAgICAgaWYgKGRhdHVtICYmIGxhYmVsICYmIGVuYWJsZWQpIHtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBsYWJlbC50ZXh0QWxpZ247XG4gICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0LnggPSBwb2ludC54O1xuICAgICAgICB0ZXh0LnkgPSBwb2ludC55IC0gMTA7XG4gICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0LnZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBzdHJva2VXaWR0aCwgbWFya2VyLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXR1bSwgeFZhbHVlLCB5VmFsdWUsIGl0ZW1JZCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHRoaXMucHJvcGVydGllcy50aXRsZSA/PyB5TmFtZSk7XG4gICAgY29uc3QgY29udGVudCA9IHNhbml0aXplSHRtbCh4U3RyaW5nICsgXCI6IFwiICsgeVN0cmluZyk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyh7IGZpbGw6IG1hcmtlci5zdHJva2UgfSwgbWFya2VyLmdldFN0eWxlKCksIHsgc3Ryb2tlV2lkdGggfSk7XG4gICAgY29uc3QgeyBmaWxsOiBjb2xvciB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgeEtleSwgeUtleSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlIH0sXG4gICAgICBiYXNlU3R5bGVcbiAgICApO1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgLi4udGhpcy5nZXRNb2R1bGVUb29sdGlwUGFyYW1zKClcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGlmICghKHRoaXMuZGF0YT8ubGVuZ3RoICYmIHRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgJiYgbGVnZW5kVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHlLZXksIHlOYW1lLCBzdHJva2UsIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoLCBsaW5lRGFzaCwgdGl0bGUsIG1hcmtlciwgdmlzaWJsZSwgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjb2xvcjAgPSBcInJnYmEoMCwgMCwgMCwgMClcIjtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsZWdlbmRJdGVtTmFtZSA/PyB0aXRsZSA/PyB5TmFtZSA/PyB5S2V5XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogbWFya2VyLmZpbGwgPz8gY29sb3IwLFxuICAgICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlID8/IGNvbG9yMCxcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IG1hcmtlci5maWxsT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgZW5hYmxlZDogbWFya2VyLmVuYWJsZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlID8/IGNvbG9yMCxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGxpbmVEYXNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRocyhvcHRzKSB7XG4gICAgdGhpcy51cGRhdGVMaW5lUGF0aHMob3B0cy5wYXRocywgb3B0cy5jb250ZXh0RGF0YSk7XG4gIH1cbiAgdXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgaW50ZXJwb2xhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgbm9kZURhdGEgfSA9IGNvbnRleHREYXRhO1xuICAgIGNvbnN0IFtsaW5lTm9kZV0gPSBwYXRocztcbiAgICBsaW5lTm9kZS5wYXRoLmNsZWFyKHRydWUpO1xuICAgIGZvciAoY29uc3QgcmFuZ2UzIG9mIHBhdGhSYW5nZXMobm9kZURhdGEpKSB7XG4gICAgICBwbG90UGF0aChwYXRoUmFuZ2VQb2ludHMobm9kZURhdGEsIHJhbmdlMyksIGxpbmVOb2RlLCBpbnRlcnBvbGF0aW9uKTtcbiAgICB9XG4gICAgbGluZU5vZGUuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucywgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBwYXRoU3dpcGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5wYXRocyk7XG4gICAgcmVzZXRNb3Rpb24oW21hcmtlclNlbGVjdGlvbl0sIHJlc2V0TWFya2VyUG9zaXRpb25Gbik7XG4gICAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBzdXBlci5hbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb246IG1hcmtlclNlbGVjdGlvbnMsXG4gICAgICBsYWJlbFNlbGVjdGlvbjogbGFiZWxTZWxlY3Rpb25zLFxuICAgICAgYW5ub3RhdGlvblNlbGVjdGlvbnMsXG4gICAgICBjb250ZXh0RGF0YSxcbiAgICAgIHBhdGhzLFxuICAgICAgcHJldmlvdXNDb250ZXh0RGF0YVxuICAgIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IFtwYXRoXSA9IHBhdGhzO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXAgPSAoKSA9PiB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH07XG4gICAgaWYgKGNvbnRleHREYXRhID09IG51bGwgfHwgcHJldmlvdXNDb250ZXh0RGF0YSA9PSBudWxsKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZGVkXCIsIG1hcmtlclNlbGVjdGlvbnMpO1xuICAgICAgcGF0aEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInBhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZFwiLCBwYXRoKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9ucyk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uKFxuICAgICAgY29udGV4dERhdGEsXG4gICAgICBwcmV2aW91c0NvbnRleHREYXRhLFxuICAgICAgdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLmludGVycG9sYXRpb25cbiAgICApO1xuICAgIGlmIChmbnMgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZm5zLnN0YXR1cyA9PT0gXCJuby1vcFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCB2b2lkIDAsIG1hcmtlclNlbGVjdGlvbnMpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcInBhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBbcGF0aF0sIGZucy5wYXRoUHJvcGVydGllcyk7XG4gICAgcGF0aE1vdGlvbih0aGlzLmlkLCBcInBhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtwYXRoXSwgZm5zLnBhdGgpO1xuICAgIGlmIChmbnMuaGFzTW90aW9uKSB7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbnMpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAxLCBvdXRlcjogMC4xIH07XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwgeyBkYXR1bSwgeEtleSwgeUtleSwgaGlnaGxpZ2h0ZWQ6IHRydWUgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuTGluZVNlcmllcy5jbGFzc05hbWUgPSBcIkxpbmVTZXJpZXNcIjtcbkxpbmVTZXJpZXMudHlwZSA9IFwibGluZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXNNb2R1bGUudHNcbnZhciBMaW5lU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwibGluZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTGluZVNlcmllcyhjdHgpLFxuICBzdGFja2FibGU6IHRydWUsXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdXNlcnMgc2hvdWxkbid0IHNwZWNpZnkgYWxsIG9wdGlvbnMsIGJ1dCB3ZSBoYXZlIHRvIGZvciB0aGVtaW5nIHRvIHdvcmtcbiAgICAgICAgdGVuc2lvbjogMSxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCJcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICAgIHNpemU6IDcsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgZXJyb3JCYXI6IHtcbiAgICAgICAgY2FwOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW86IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gbWFya2VyUGFsZXR0ZUZhY3RvcnkocGFyYW1zKTtcbiAgICByZXR1cm4geyBzdHJva2U6IG1hcmtlci5maWxsLCBtYXJrZXIgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9zY2F0dGVyU2VyaWVzUHJvcGVydGllcy50c1xudmFyIFNjYXR0ZXJTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJ0b3BcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExBQkVMX1BMQUNFTUVOVClcbl0sIFNjYXR0ZXJTZXJpZXNMYWJlbC5wcm90b3R5cGUsIFwicGxhY2VtZW50XCIsIDIpO1xudmFyIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yUmFuZ2UgPSBbXCIjZmZmZjAwXCIsIFwiIzAwZmYwMFwiLCBcIiMwMDAwZmZcIl07XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBTY2F0dGVyU2VyaWVzTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIC8vIE5vIHZhbGlkYXRpb24uIE5vdCBhIHBhcnQgb2YgdGhlIG9wdGlvbnMgY29udHJhY3QuXG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgU2VyaWVzTWFya2VyKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvckRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNoYXBlXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNpemVcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbE9wYWNpdHlcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VXaWR0aFwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VPcGFjaXR5XCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuaXRlbVN0eWxlclwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXMudHNcbnZhciBTY2F0dGVyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVCAqLyxcbiAgICAgICAgMyAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgbWFya2VyOiByZXNldE1hcmtlckZuLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCB0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGNvbG9yU2NhbGVUeXBlID0gdGhpcy5jb2xvclNjYWxlLnR5cGU7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSwgY29sb3JLZXksIGNvbG9yRG9tYWluLCBjb2xvclJhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgdGhpcy5kYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICBrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhLZXktcmF3XCIgfSksXG4gICAgICAgIGtleVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IFwieUtleS1yYXdcIiB9KSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBba2V5UHJvcGVydHkobGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgbGFiZWxLZXktcmF3YCB9KV0gOiBbXSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBgeFZhbHVlYCB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlYCB9KSxcbiAgICAgICAgLi4uY29sb3JLZXkgPyBbdmFsdWVQcm9wZXJ0eShjb2xvcktleSwgY29sb3JTY2FsZVR5cGUsIHsgaWQ6IGBjb2xvclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBbdmFsdWVQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbFZhbHVlYCB9KV0gOiBbXVxuICAgICAgXVxuICAgIH0pO1xuICAgIGlmIChjb2xvcktleSkge1xuICAgICAgY29uc3QgY29sb3JLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5kb21haW4gPSBjb2xvckRvbWFpbiA/PyBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdID8/IFtdO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgaWQgPSBkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8gPyBgeFZhbHVlYCA6IGB5VmFsdWVgO1xuICAgIGNvbnN0IGRhdGFEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGlkKTtcbiAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGlkLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGlmIChkYXRhRGVmPy5kZWYudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIGRhdGFEZWY/LmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChkb21haW4pLCBheGlzKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgY29sb3JTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5LCBjb2xvcktleSwgeE5hbWUsIHlOYW1lLCBsYWJlbE5hbWUsIG1hcmtlciwgbGFiZWwsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHBsYWNlbWVudCB9ID0gbGFiZWw7XG4gICAgY29uc3QgbWFya2VyU2hhcGUgPSBnZXRNYXJrZXIobWFya2VyLnNoYXBlKTtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghKGRhdGFNb2RlbCAmJiBwcm9jZXNzZWREYXRhICYmIHZpc2libGUgJiYgeEF4aXMgJiYgeUF4aXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlYCk7XG4gICAgY29uc3QgY29sb3JEYXRhSWR4ID0gY29sb3JLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IGxhYmVsRGF0YUlkeCA9IGxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsYWJlbFZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBjb25zdCBmb250ID0gbGFiZWwuZ2V0Rm9udCgpO1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250IH0pO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZXMsIGRhdHVtIH0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhID8/IFtdKSB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeERhdGFJZHhdO1xuICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldDtcbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5RGF0dW0pICsgeU9mZnNldDtcbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxhYmVsLCB7XG4gICAgICAgIHZhbHVlOiBsYWJlbEtleSA/IHZhbHVlc1tsYWJlbERhdGFJZHhdIDogeURhdHVtLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgbGFiZWxOYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNpemUgPSB0ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQobGFiZWxUZXh0KTtcbiAgICAgIGNvbnN0IGZpbGwgPSBjb2xvcktleSA/IGNvbG9yU2NhbGUuY29udmVydCh2YWx1ZXNbY29sb3JEYXRhSWR4XSkgOiB2b2lkIDA7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgIGNhcERlZmF1bHRzOiB7IGxlbmd0aFJhdGlvTXVsdGlwbGllcjogbWFya2VyLmdldERpYW1ldGVyKCksIGxlbmd0aE1heDogSW5maW5pdHkgfSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgc2l6ZTogbWFya2VyLnNpemUgfSxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgICBmaWxsLFxuICAgICAgICBsYWJlbDogeyB0ZXh0OiBsYWJlbFRleHQsIC4uLnNpemUgfSxcbiAgICAgICAgbWFya2VyOiBtYXJrZXJTaGFwZSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Tm9kZURhdGE/LmxhYmVsRGF0YSA/PyBbXTtcbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5lbmFibGVkID8gbm9kZURhdGEgOiBbXSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSwgbWFya2VyLCBoaWdobGlnaHRTdHlsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUuaXRlbSwgbWFya2VyLmdldFN0eWxlKCkpO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5LCBsYWJlbEtleSB9LCBiYXNlU3R5bGUpO1xuICAgIH0pO1xuICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIG1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHBsYWNlZExhYmVscyA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKSA/IHRoaXMuY2hhcnQ/LnBsYWNlTGFiZWxzKCkuZ2V0KHRoaXMpID8/IFtdIDogW107XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgcGxhY2VkTGFiZWxzLm1hcCgoeyBkYXR1bSwgeCwgeSB9KSA9PiAoe1xuICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgc2l6ZTogZGF0dW0ucG9pbnQuc2l6ZSB9LFxuICAgICAgICBwbGFjZW1lbnQ6IFwidG9wXCJcbiAgICAgIH0pKSxcbiAgICAgICh0ZXh0KSA9PiB7XG4gICAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICB0ZXh0LnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xuICAgICAgdGV4dC5maWxsID0gbGFiZWwuY29sb3I7XG4gICAgICB0ZXh0LnggPSBkYXR1bS5wb2ludD8ueCA/PyAwO1xuICAgICAgdGV4dC55ID0gZGF0dW0ucG9pbnQ/LnkgPz8gMDtcbiAgICAgIHRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgICAgdGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICAgIHRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICAgIHRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5LCB4TmFtZSwgeU5hbWUsIGxhYmVsTmFtZSwgdGl0bGUgPSB5TmFtZSwgbWFya2VyLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXR1bSwgeFZhbHVlLCB5VmFsdWUsIGxhYmVsLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgeyBmaWxsOiBub2RlRGF0dW0uZmlsbCwgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgobWFya2VyLnN0cm9rZVdpZHRoKSB9LFxuICAgICAgbWFya2VyLmdldFN0eWxlKClcbiAgICApO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgPSBcImdyYXlcIiB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlLCB4S2V5LCB5S2V5LCBsYWJlbEtleSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICBjb25zdCB4U3RyaW5nID0gc2FuaXRpemVIdG1sKHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKSk7XG4gICAgbGV0IGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwoeE5hbWUgPz8geEtleSl9PC9iPjogJHt4U3RyaW5nfTxicj48Yj4ke3Nhbml0aXplSHRtbCh5TmFtZSA/PyB5S2V5KX08L2I+OiAke3lTdHJpbmd9YDtcbiAgICBpZiAobGFiZWxLZXkpIHtcbiAgICAgIGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwobGFiZWxOYW1lID8/IGxhYmVsS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChsYWJlbC50ZXh0KX08YnI+YCArIGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIGxhYmVsTmFtZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgLi4udGhpcy5nZXRNb2R1bGVUb29sdGlwUGFyYW1zKClcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIHRpdGxlLCBtYXJrZXIsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoIH0gPSBtYXJrZXI7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB0aXRsZSA/PyB5TmFtZSA/PyB5S2V5XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogbWFya2VyLmZpbGwgPz8gZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHN0cm9rZSA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8/IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zIH0gPSBkYXRhO1xuICAgIG1hcmtlclNjYWxlSW5BbmltYXRpb24odGhpcywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7IGRhdHVtLCB4S2V5LCB5S2V5LCBsYWJlbEtleSwgaGlnaGxpZ2h0ZWQ6IHRydWUgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuU2NhdHRlclNlcmllcy5jbGFzc05hbWUgPSBcIlNjYXR0ZXJTZXJpZXNcIjtcblNjYXR0ZXJTZXJpZXMudHlwZSA9IFwic2NhdHRlclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXNNb2R1bGUudHNcbnZhciBTY2F0dGVyU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwic2NhdHRlclwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgU2NhdHRlclNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgc2l6ZTogNyxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2VjdG9yQm94LnRzXG52YXIgU2VjdG9yQm94ID0gY2xhc3MgX1NlY3RvckJveCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBlbmRBbmdsZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXM7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IF9TZWN0b3JCb3goc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gIH1cbiAgW2ludGVycG9sYXRlXShvdGhlciwgZCkge1xuICAgIHJldHVybiBuZXcgX1NlY3RvckJveChcbiAgICAgIHRoaXMuc3RhcnRBbmdsZSAqICgxIC0gZCkgKyBvdGhlci5zdGFydEFuZ2xlICogZCxcbiAgICAgIHRoaXMuZW5kQW5nbGUgKiAoMSAtIGQpICsgb3RoZXIuZW5kQW5nbGUgKiBkLFxuICAgICAgdGhpcy5pbm5lclJhZGl1cyAqICgxIC0gZCkgKyBvdGhlci5pbm5lclJhZGl1cyAqIGQsXG4gICAgICB0aGlzLm91dGVyUmFkaXVzICogKDEgLSBkKSArIG90aGVyLm91dGVyUmFkaXVzICogZFxuICAgICk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvc2VjdG9yLnRzXG5mdW5jdGlvbiBzZWN0b3JCb3goeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0pIHtcbiAgbGV0IHgwID0gSW5maW5pdHk7XG4gIGxldCB5MCA9IEluZmluaXR5O1xuICBsZXQgeDEgPSAtSW5maW5pdHk7XG4gIGxldCB5MSA9IC1JbmZpbml0eTtcbiAgY29uc3QgYWRkUG9pbnQgPSAoeCwgeSkgPT4ge1xuICAgIHgwID0gTWF0aC5taW4oeCwgeDApO1xuICAgIHkwID0gTWF0aC5taW4oeSwgeTApO1xuICAgIHgxID0gTWF0aC5tYXgoeCwgeDEpO1xuICAgIHkxID0gTWF0aC5tYXgoeSwgeTEpO1xuICB9O1xuICBhZGRQb2ludChpbm5lclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBpbm5lclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcbiAgYWRkUG9pbnQoaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIGlubmVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcbiAgYWRkUG9pbnQob3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSk7XG4gIGFkZFBvaW50KG91dGVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCBvdXRlclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSk7XG4gIGlmIChpc0JldHdlZW5BbmdsZXMoMCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgYWRkUG9pbnQob3V0ZXJSYWRpdXMsIDApO1xuICB9XG4gIGlmIChpc0JldHdlZW5BbmdsZXMoTWF0aC5QSSAqIDAuNSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgYWRkUG9pbnQoMCwgb3V0ZXJSYWRpdXMpO1xuICB9XG4gIGlmIChpc0JldHdlZW5BbmdsZXMoTWF0aC5QSSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgYWRkUG9pbnQoLW91dGVyUmFkaXVzLCAwKTtcbiAgfVxuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKE1hdGguUEkgKiAxLjUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KDAsIC1vdXRlclJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCQm94KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG59XG5mdW5jdGlvbiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yKSB7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcbiAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHNlY3RvcjtcbiAgaWYgKHNlY3Rvci5zdGFydEFuZ2xlID09PSBzZWN0b3IuZW5kQW5nbGUgfHwgcmFkaXVzIDwgTWF0aC5taW4oaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSB8fCByYWRpdXMgPiBNYXRoLm1heChpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBub3JtYWxpemVBbmdsZTE4MChzZWN0b3Iuc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGVuZEFuZ2xlID0gbm9ybWFsaXplQW5nbGUxODAoc2VjdG9yLmVuZEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgcmV0dXJuIHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSA/IGFuZ2xlMiA8PSBlbmRBbmdsZSAmJiBhbmdsZTIgPj0gc3RhcnRBbmdsZSA6IGFuZ2xlMiA8PSBlbmRBbmdsZSAmJiBhbmdsZTIgPj0gLU1hdGguUEkgfHwgYW5nbGUyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUyIDw9IE1hdGguUEk7XG59XG5mdW5jdGlvbiBsaW5lQ29sbGlkZXNTZWN0b3IobGluZSwgc2VjdG9yKSB7XG4gIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gc2VjdG9yO1xuICBjb25zdCBvdXRlclN0YXJ0ID0geyB4OiBvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCB5OiBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpIH07XG4gIGNvbnN0IG91dGVyRW5kID0geyB4OiBvdXRlclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgeTogb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkgfTtcbiAgY29uc3QgaW5uZXJTdGFydCA9IGlubmVyUmFkaXVzID09PSAwID8geyB4OiAwLCB5OiAwIH0gOiB7IHg6IGlubmVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IGlubmVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkgfTtcbiAgY29uc3QgaW5uZXJFbmQgPSBpbm5lclJhZGl1cyA9PT0gMCA/IHsgeDogMCwgeTogMCB9IDogeyB4OiBpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgeTogaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkgfTtcbiAgcmV0dXJuIHNlZ21lbnRJbnRlcnNlY3Rpb24oXG4gICAgbGluZS5zdGFydC54LFxuICAgIGxpbmUuc3RhcnQueSxcbiAgICBsaW5lLmVuZC54LFxuICAgIGxpbmUuZW5kLnksXG4gICAgb3V0ZXJTdGFydC54LFxuICAgIG91dGVyU3RhcnQueSxcbiAgICBpbm5lclN0YXJ0LngsXG4gICAgaW5uZXJTdGFydC55XG4gICkgfHwgc2VnbWVudEludGVyc2VjdGlvbihcbiAgICBsaW5lLnN0YXJ0LngsXG4gICAgbGluZS5zdGFydC55LFxuICAgIGxpbmUuZW5kLngsXG4gICAgbGluZS5lbmQueSxcbiAgICBvdXRlckVuZC54LFxuICAgIG91dGVyRW5kLnksXG4gICAgaW5uZXJFbmQueCxcbiAgICBpbm5lckVuZC55XG4gICkgfHwgYXJjSW50ZXJzZWN0aW9ucyhcbiAgICAwLFxuICAgIDAsXG4gICAgb3V0ZXJSYWRpdXMsXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSxcbiAgICB0cnVlLFxuICAgIGxpbmUuc3RhcnQueCxcbiAgICBsaW5lLnN0YXJ0LnksXG4gICAgbGluZS5lbmQueCxcbiAgICBsaW5lLmVuZC55XG4gICk7XG59XG5mdW5jdGlvbiBib3hDb2xsaWRlc1NlY3Rvcihib3gsIHNlY3Rvcikge1xuICBjb25zdCB0b3BMZWZ0ID0geyB4OiBib3gueCwgeTogYm94LnkgfTtcbiAgY29uc3QgdG9wUmlnaHQgPSB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSB9O1xuICBjb25zdCBib3R0b21MZWZ0ID0geyB4OiBib3gueCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH07XG4gIGNvbnN0IGJvdHRvbVJpZ2h0ID0geyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH07XG4gIHJldHVybiBsaW5lQ29sbGlkZXNTZWN0b3IoeyBzdGFydDogdG9wTGVmdCwgZW5kOiB0b3BSaWdodCB9LCBzZWN0b3IpIHx8IGxpbmVDb2xsaWRlc1NlY3Rvcih7IHN0YXJ0OiBib3R0b21MZWZ0LCBlbmQ6IGJvdHRvbVJpZ2h0IH0sIHNlY3Rvcik7XG59XG5mdW5jdGlvbiByYWRpaVNjYWxpbmdGYWN0b3Iociwgc3dlZXAsIGEsIGIpIHtcbiAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMClcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgZnMxID0gTWF0aC5hc2luKE1hdGguYWJzKDEgKiBhKSAvIChyICsgMSAqIGEpKSArIE1hdGguYXNpbihNYXRoLmFicygxICogYikgLyAociArIDEgKiBiKSkgLSBzd2VlcDtcbiAgaWYgKGZzMSA8IDApXG4gICAgcmV0dXJuIDE7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHMgPSAoc3RhcnQgKyBlbmQpIC8gMjtcbiAgICBjb25zdCBmcyA9IE1hdGguYXNpbihNYXRoLmFicyhzICogYSkgLyAociArIHMgKiBhKSkgKyBNYXRoLmFzaW4oTWF0aC5hYnMocyAqIGIpIC8gKHIgKyBzICogYikpIC0gc3dlZXA7XG4gICAgaWYgKGZzIDwgMCkge1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG52YXIgZGVsdGEyID0gMWUtNjtcbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlKGFuZ2xlMiwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpIHtcbiAgaWYgKGFuZ2xlQmV0d2VlbihhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSA8IGRlbHRhMikge1xuICAgIHJldHVybiByZWxhdGl2ZVRvU3RhcnRBbmdsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUyIC0gcmVsYXRpdmVUb1N0YXJ0QW5nbGUpICsgcmVsYXRpdmVUb1N0YXJ0QW5nbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlcyhzdGFydEFuZ2xlLCBlbmRBbmdsZSwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUgPSAwKSB7XG4gIGNvbnN0IGZ1bGxQaWUgPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID49IDIgKiBNYXRoLlBJO1xuICBjb25zdCBzd2VlcEFuZ2xlID0gZnVsbFBpZSA/IDIgKiBNYXRoLlBJIDogbm9ybWFsaXplQW5nbGUzNjAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgc3RhcnRBbmdsZSA9IGNsb2Nrd2lzZUFuZ2xlKHN0YXJ0QW5nbGUsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKTtcbiAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZTtcbiAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfTtcbn1cbmZ1bmN0aW9uIGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbGlwQW5nbGUpIHtcbiAgY29uc3Qgc2luQSA9IE1hdGguc2luKGNsaXBBbmdsZSk7XG4gIGNvbnN0IGNvc0EgPSBNYXRoLmNvcyhjbGlwQW5nbGUpO1xuICBjb25zdCBjID0gY3ggKiogMiArIGN5ICoqIDIgLSByICoqIDI7XG4gIGxldCBwMHggPSBOYU47XG4gIGxldCBwMHkgPSBOYU47XG4gIGxldCBwMXggPSBOYU47XG4gIGxldCBwMXkgPSBOYU47XG4gIGlmIChjb3NBID4gMC41KSB7XG4gICAgY29uc3QgdGFuQSA9IHNpbkEgLyBjb3NBO1xuICAgIGNvbnN0IGEgPSAxICsgdGFuQSAqKiAyO1xuICAgIGNvbnN0IGIgPSAtMiAqIChjeCArIGN5ICogdGFuQSk7XG4gICAgY29uc3QgZCA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBpZiAoZCA8IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeDAgPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB4MSA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIHAweCA9IHgwO1xuICAgIHAweSA9IHgwICogdGFuQTtcbiAgICBwMXggPSB4MTtcbiAgICBwMXkgPSB4MSAqIHRhbkE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY290QSA9IGNvc0EgLyBzaW5BO1xuICAgIGNvbnN0IGEgPSAxICsgY290QSAqKiAyO1xuICAgIGNvbnN0IGIgPSAtMiAqIChjeSArIGN4ICogY290QSk7XG4gICAgY29uc3QgZCA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBpZiAoZCA8IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeTAgPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB5MSA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIHAweCA9IHkwICogY290QTtcbiAgICBwMHkgPSB5MDtcbiAgICBwMXggPSB5MSAqIGNvdEE7XG4gICAgcDF5ID0geTE7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXNlZFggPSBjb3NBO1xuICBjb25zdCBub3JtYWxpc2VkWSA9IHNpbkE7XG4gIGNvbnN0IHAwRG90Tm9ybWFsaXplZCA9IHAweCAqIG5vcm1hbGlzZWRYICsgcDB5ICogbm9ybWFsaXNlZFk7XG4gIGNvbnN0IHAxRG90Tm9ybWFsaXplZCA9IHAxeCAqIG5vcm1hbGlzZWRYICsgcDF5ICogbm9ybWFsaXNlZFk7XG4gIGNvbnN0IGEwID0gcDBEb3ROb3JtYWxpemVkID4gMCA/IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIocDB5IC0gY3ksIHAweCAtIGN4KSwgc3RhcnRBbmdsZSkgOiBOYU47XG4gIGNvbnN0IGExID0gcDFEb3ROb3JtYWxpemVkID4gMCA/IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIocDF5IC0gY3ksIHAxeCAtIGN4KSwgc3RhcnRBbmdsZSkgOiBOYU47XG4gIGlmIChhMCA+PSBzdGFydEFuZ2xlICYmIGEwIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGEwO1xuICB9IGVsc2UgaWYgKGExID49IHN0YXJ0QW5nbGUgJiYgYTEgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNpcmNsZVIpIHtcbiAgY29uc3QgZCA9IE1hdGguaHlwb3QoY3gsIGN5KTtcbiAgY29uc3QgZDEgPSAoZCAqKiAyIC0gciAqKiAyICsgY2lyY2xlUiAqKiAyKSAvICgyICogZCk7XG4gIGNvbnN0IGQyID0gZCAtIGQxO1xuICBjb25zdCB0aGV0YSA9IE1hdGguYXRhbjIoY3ksIGN4KTtcbiAgY29uc3QgZGVsdGFUaGV0YSA9IE1hdGguYWNvcygtZDIgLyByKTtcbiAgY29uc3QgYTAgPSBjbG9ja3dpc2VBbmdsZSh0aGV0YSArIGRlbHRhVGhldGEsIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBhMSA9IGNsb2Nrd2lzZUFuZ2xlKHRoZXRhIC0gZGVsdGFUaGV0YSwgc3RhcnRBbmdsZSk7XG4gIGlmIChhMCA+PSBzdGFydEFuZ2xlICYmIGEwIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGEwO1xuICB9IGVsc2UgaWYgKGExID49IHN0YXJ0QW5nbGUgJiYgYTEgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTE7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc2VjdG9yLnRzXG52YXIgQXJjID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjeCwgY3ksIHIsIGEwLCBhMSkge1xuICAgIHRoaXMuY3ggPSBjeDtcbiAgICB0aGlzLmN5ID0gY3k7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmEwID0gYTA7XG4gICAgdGhpcy5hMSA9IGExO1xuICAgIGlmICh0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGhpcy5hMCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuYTEpO1xuICB9XG4gIHBvaW50QXQoYSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLmN4ICsgdGhpcy5yICogTWF0aC5jb3MoYSksXG4gICAgICB5OiB0aGlzLmN5ICsgdGhpcy5yICogTWF0aC5zaW4oYSlcbiAgICB9O1xuICB9XG4gIGNsaXBTdGFydChhKSB7XG4gICAgaWYgKGEgPT0gbnVsbCB8fCAhdGhpcy5pc1ZhbGlkKCkgfHwgYSA8IHRoaXMuYTApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hMCA9IGE7XG4gICAgaWYgKE51bWJlci5pc05hTihhKSB8fCB0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxuICBjbGlwRW5kKGEpIHtcbiAgICBpZiAoYSA9PSBudWxsIHx8ICF0aGlzLmlzVmFsaWQoKSB8fCBhID4gdGhpcy5hMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmExID0gYTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGEpIHx8IHRoaXMuYTAgPj0gdGhpcy5hMSkge1xuICAgICAgdGhpcy5hMCA9IE5hTjtcbiAgICAgIHRoaXMuYTEgPSBOYU47XG4gICAgfVxuICB9XG59O1xudmFyIFNlY3RvciA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSAxMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gMjA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgdGhpcy5jbGlwU2VjdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuY29uY2VudHJpY0VkZ2VJbnNldCA9IDA7XG4gICAgdGhpcy5yYWRpYWxFZGdlSW5zZXQgPSAwO1xuICAgIHRoaXMuc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5lbmRPdXRlckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5zdGFydElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmVuZElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgfVxuICBzZXQgaW5zZXQodmFsdWUpIHtcbiAgICB0aGlzLmNvbmNlbnRyaWNFZGdlSW5zZXQgPSB2YWx1ZTtcbiAgICB0aGlzLnJhZGlhbEVkZ2VJbnNldCA9IHZhbHVlO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgICB0aGlzLmVuZE91dGVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5zdGFydElubmVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5lbmRJbm5lckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBzZWN0b3JCb3godGhpcykudHJhbnNsYXRlKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZKTtcbiAgfVxuICBub3JtYWxpemVkUmFkaWkoKSB7XG4gICAgY29uc3QgeyBjb25jZW50cmljRWRnZUluc2V0IH0gPSB0aGlzO1xuICAgIGxldCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcztcbiAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID4gMCA/IGlubmVyUmFkaXVzICsgY29uY2VudHJpY0VkZ2VJbnNldCA6IDA7XG4gICAgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAtIGNvbmNlbnRyaWNFZGdlSW5zZXQsIDApO1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICB9XG4gIG5vcm1hbGl6ZWRDbGlwU2VjdG9yKCkge1xuICAgIGNvbnN0IHsgY2xpcFNlY3RvciB9ID0gdGhpcztcbiAgICBpZiAoY2xpcFNlY3RvciA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlcyh0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUpO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLm5vcm1hbGl6ZWRSYWRpaSgpO1xuICAgIGNvbnN0IGNsaXBBbmdsZXMgPSBjbG9ja3dpc2VBbmdsZXMoY2xpcFNlY3Rvci5zdGFydEFuZ2xlLCBjbGlwU2VjdG9yLmVuZEFuZ2xlLCBzdGFydEFuZ2xlKTtcbiAgICByZXR1cm4gbmV3IFNlY3RvckJveChcbiAgICAgIE1hdGgubWF4KHN0YXJ0QW5nbGUsIGNsaXBBbmdsZXMuc3RhcnRBbmdsZSksXG4gICAgICBNYXRoLm1pbihlbmRBbmdsZSwgY2xpcEFuZ2xlcy5lbmRBbmdsZSksXG4gICAgICBNYXRoLm1heChpbm5lclJhZGl1cywgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyksXG4gICAgICBNYXRoLm1pbihvdXRlclJhZGl1cywgY2xpcFNlY3Rvci5vdXRlclJhZGl1cylcbiAgICApO1xuICB9XG4gIGdldEFuZ2xlT2Zmc2V0KHJhZGl1cykge1xuICAgIHJldHVybiByYWRpdXMgPiAwID8gdGhpcy5yYWRpYWxFZGdlSW5zZXQgLyByYWRpdXMgOiAwO1xuICB9XG4gIGFyYyhyLCBhbmdsZVN3ZWVwLCBhMCwgYTEsIG91dGVyQXJjLCBpbm5lckFyYywgc3RhcnQsIGlubmVyKSB7XG4gICAgaWYgKHIgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBjbG9ja3dpc2VBbmdsZXModGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlKTtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5ub3JtYWxpemVkUmFkaWkoKTtcbiAgICBjb25zdCBjbGlwU2VjdG9yID0gdGhpcy5ub3JtYWxpemVkQ2xpcFNlY3RvcigpO1xuICAgIGlmIChpbm5lciAmJiBpbm5lclJhZGl1cyA8PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlubmVyQW5nbGVPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KGlubmVyUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFuZ2xlT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlclJhZGl1cyk7XG4gICAgY29uc3QgYW5nbGVPZmZzZXQgPSBpbm5lciA/IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJSYWRpdXMgKyByKSA6IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJSYWRpdXMgLSByKTtcbiAgICBjb25zdCBhbmdsZTIgPSBzdGFydCA/IHN0YXJ0QW5nbGUgKyBhbmdsZU9mZnNldCArIGFuZ2xlU3dlZXAgOiBlbmRBbmdsZSAtIGFuZ2xlT2Zmc2V0IC0gYW5nbGVTd2VlcDtcbiAgICBjb25zdCByYWRpdXMgPSBpbm5lciA/IGlubmVyUmFkaXVzICsgciA6IG91dGVyUmFkaXVzIC0gcjtcbiAgICBjb25zdCBjeCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlMik7XG4gICAgY29uc3QgY3kgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZTIpO1xuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRlbHRhMyA9IDFlLTY7XG4gICAgICBpZiAoIXN0YXJ0ICYmICEoYW5nbGUyID49IHN0YXJ0QW5nbGUgLSBkZWx0YTMgJiYgYW5nbGUyIDw9IGNsaXBTZWN0b3IuZW5kQW5nbGUgLSBkZWx0YTMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoc3RhcnQgJiYgIShhbmdsZTIgPj0gY2xpcFNlY3Rvci5zdGFydEFuZ2xlICsgZGVsdGEzICYmIGFuZ2xlMiA8PSBlbmRBbmdsZSAtIGRlbHRhMykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChpbm5lciAmJiAhKHJhZGl1cyA+PSBjbGlwU2VjdG9yLmlubmVyUmFkaXVzIC0gZGVsdGEzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFpbm5lciAmJiAhKHJhZGl1cyA8PSBjbGlwU2VjdG9yLm91dGVyUmFkaXVzICsgZGVsdGEzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcmMgPSBuZXcgQXJjKGN4LCBjeSwgciwgYTAsIGExKTtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgYXJjLmNsaXBTdGFydChcbiAgICAgICAgICBhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3IuZW5kQW5nbGUgLSBpbm5lckFuZ2xlT2Zmc2V0KVxuICAgICAgICApO1xuICAgICAgICBhcmMuY2xpcEVuZChcbiAgICAgICAgICBhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSArIGlubmVyQW5nbGVPZmZzZXQpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmMuY2xpcFN0YXJ0KFxuICAgICAgICAgIGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5zdGFydEFuZ2xlICsgb3V0ZXJBbmdsZU9mZnNldClcbiAgICAgICAgKTtcbiAgICAgICAgYXJjLmNsaXBFbmQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmVuZEFuZ2xlIC0gb3V0ZXJBbmdsZU9mZnNldCkpO1xuICAgICAgfVxuICAgICAgbGV0IGNpcmNsZUNsaXBTdGFydDtcbiAgICAgIGxldCBjaXJjbGVDbGlwRW5kO1xuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIGNpcmNsZUNsaXBTdGFydCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKTtcbiAgICAgICAgY2lyY2xlQ2xpcEVuZCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpcmNsZUNsaXBTdGFydCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKTtcbiAgICAgICAgY2lyY2xlQ2xpcEVuZCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIGFyYy5jbGlwU3RhcnQoY2lyY2xlQ2xpcFN0YXJ0KTtcbiAgICAgIGFyYy5jbGlwRW5kKGNpcmNsZUNsaXBFbmQpO1xuICAgICAgaWYgKGNpcmNsZUNsaXBTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdChjaXJjbGVDbGlwU3RhcnQpO1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBjbG9ja3dpc2VBbmdsZShNYXRoLmF0YW4yKHkyLCB4MiksIHN0YXJ0QW5nbGUpO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBpbm5lckFyYz8uY2xpcFN0YXJ0KHRoZXRhMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ZXJBcmMuY2xpcEVuZCh0aGV0YTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2lyY2xlQ2xpcEVuZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdChjaXJjbGVDbGlwRW5kKTtcbiAgICAgICAgY29uc3QgdGhldGEyID0gY2xvY2t3aXNlQW5nbGUoTWF0aC5hdGFuMih5MiwgeDIpLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgb3V0ZXJBcmMuY2xpcFN0YXJ0KHRoZXRhMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5uZXJBcmM/LmNsaXBFbmQodGhldGEyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gYXJjLnBvaW50QXQoKGFyYy5hMCArIGFyYy5hMSkgLyAyKTtcbiAgICAgIGlmICghaXNQb2ludEluU2VjdG9yKHgyLCB5MiwgY2xpcFNlY3RvcikpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5IH0gPSBhcmMucG9pbnRBdChzdGFydCA9PT0gaW5uZXIgPyBhcmMuYTAgOiBhcmMuYTEpO1xuICAgIGNvbnN0IHRoZXRhID0gY2xvY2t3aXNlQW5nbGUoTWF0aC5hdGFuMih5LCB4KSwgc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgcmFkaWFsQXJjID0gaW5uZXIgPyBpbm5lckFyYyA6IG91dGVyQXJjO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgcmFkaWFsQXJjPy5jbGlwU3RhcnQodGhldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWRpYWxBcmM/LmNsaXBFbmQodGhldGEpO1xuICAgIH1cbiAgICByZXR1cm4gYXJjO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgZGVsdGEzID0gMWUtNjtcbiAgICBjb25zdCB7IHBhdGgsIGNlbnRlclgsIGNlbnRlclksIGNvbmNlbnRyaWNFZGdlSW5zZXQsIHJhZGlhbEVkZ2VJbnNldCB9ID0gdGhpcztcbiAgICBsZXQgeyBzdGFydE91dGVyQ29ybmVyUmFkaXVzLCBlbmRPdXRlckNvcm5lclJhZGl1cywgc3RhcnRJbm5lckNvcm5lclJhZGl1cywgZW5kSW5uZXJDb3JuZXJSYWRpdXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gY2xvY2t3aXNlQW5nbGVzKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcFNlY3RvciA9IHRoaXMubm9ybWFsaXplZENsaXBTZWN0b3IoKTtcbiAgICBjb25zdCBzd2VlcEFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgIGNvbnN0IGZ1bGxQaWUgPSBzd2VlcEFuZ2xlID49IDIgKiBNYXRoLlBJIC0gZGVsdGEzO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPT09IDAgJiYgb3V0ZXJSYWRpdXMgPT09IDAgfHwgaW5uZXJSYWRpdXMgPiBvdXRlclJhZGl1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoKGNsaXBTZWN0b3I/LnN0YXJ0QW5nbGUgPz8gc3RhcnRBbmdsZSkgPT09IChjbGlwU2VjdG9yPy5lbmRBbmdsZSA/PyBlbmRBbmdsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZ1bGxQaWUgJiYgdGhpcy5jbGlwU2VjdG9yID09IG51bGwgJiYgc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9PT0gMCAmJiBlbmRPdXRlckNvcm5lclJhZGl1cyA9PT0gMCAmJiBzdGFydElubmVyQ29ybmVyUmFkaXVzID09PSAwICYmIGVuZElubmVyQ29ybmVyUmFkaXVzID09PSAwKSB7XG4gICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgY2VudGVyWSArIG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgIGlmIChpbm5lclJhZGl1cyA+IGNvbmNlbnRyaWNFZGdlSW5zZXQpIHtcbiAgICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCBjZW50ZXJZICsgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cywgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2xpcFNlY3RvciA9PSBudWxsICYmIE1hdGguYWJzKGlubmVyUmFkaXVzIC0gb3V0ZXJSYWRpdXMpIDwgMWUtNikge1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5uZXJBbmdsZU9mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQW5nbGVPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KG91dGVyUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFuZ2xlRXhjZWVkZWQgPSBzd2VlcEFuZ2xlIDwgMiAqIG91dGVyQW5nbGVPZmZzZXQ7XG4gICAgaWYgKG91dGVyQW5nbGVFeGNlZWRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoYXNJbm5lclN3ZWVwID0gKGNsaXBTZWN0b3I/LmlubmVyUmFkaXVzID8/IGlubmVyUmFkaXVzKSA+IGNvbmNlbnRyaWNFZGdlSW5zZXQ7XG4gICAgY29uc3QgaW5uZXJBbmdsZUV4Y2VlZGVkID0gaW5uZXJSYWRpdXMgPCBjb25jZW50cmljRWRnZUluc2V0IHx8IHN3ZWVwQW5nbGUgPCAyICogaW5uZXJBbmdsZU9mZnNldDtcbiAgICBjb25zdCByYWRpYWxMZW5ndGggPSBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG1heFJhZGlhbExlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBjb25zdCBpbml0aWFsU2NhbGluZ0ZhY3RvciA9IG1heFJhZGlhbExlbmd0aCA+IDAgPyBNYXRoLm1pbihyYWRpYWxMZW5ndGggLyBtYXhSYWRpYWxMZW5ndGgsIDEpIDogMTtcbiAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgY29uc3Qgb3V0ZXJTY2FsaW5nRmFjdG9yID0gcmFkaWlTY2FsaW5nRmFjdG9yKFxuICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICBzd2VlcEFuZ2xlIC0gMiAqIG91dGVyQW5nbGVPZmZzZXQsXG4gICAgICAtc3RhcnRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIC1lbmRPdXRlckNvcm5lclJhZGl1c1xuICAgICk7XG4gICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyAqPSBvdXRlclNjYWxpbmdGYWN0b3I7XG4gICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKj0gb3V0ZXJTY2FsaW5nRmFjdG9yO1xuICAgIGlmICghaW5uZXJBbmdsZUV4Y2VlZGVkICYmIGhhc0lubmVyU3dlZXApIHtcbiAgICAgIGNvbnN0IGlubmVyU2NhbGluZ0ZhY3RvciA9IHJhZGlpU2NhbGluZ0ZhY3RvcihcbiAgICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICAgIHN3ZWVwQW5nbGUgLSAyICogaW5uZXJBbmdsZU9mZnNldCxcbiAgICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXNcbiAgICAgICk7XG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzICo9IGlubmVyU2NhbGluZ0ZhY3RvcjtcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzICo9IGlubmVyU2NhbGluZ0ZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gICAgfVxuICAgIGNvbnN0IG1heENvbWJpbmVkUmFkaWFsTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICsgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICsgZW5kSW5uZXJDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGNvbnN0IGVkZ2VzU2NhbGluZ0ZhY3RvciA9IG1heENvbWJpbmVkUmFkaWFsTGVuZ3RoID4gMCA/IE1hdGgubWluKHJhZGlhbExlbmd0aCAvIG1heENvbWJpbmVkUmFkaWFsTGVuZ3RoLCAxKSA6IDE7XG4gICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIGVuZElubmVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBsZXQgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSAwO1xuICAgIGxldCBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSAwO1xuICAgIGNvbnN0IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA9IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgLyAob3V0ZXJSYWRpdXMgLSBzdGFydE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCBlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID0gZW5kT3V0ZXJDb3JuZXJSYWRpdXMgLyAob3V0ZXJSYWRpdXMgLSBlbmRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgaWYgKHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA+PSAwICYmIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA8IDEgLSBkZWx0YTMpIHtcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gc3dlZXBBbmdsZSAvIDI7XG4gICAgICBjb25zdCBtYXhTdGFydE91dGVyQ29ybmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLyAoMSAvIE1hdGguc2luKHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwKSArIDEpO1xuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IE1hdGgubWluKG1heFN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIH1cbiAgICBpZiAoZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA+PSAwICYmIGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPCAxIC0gZGVsdGEzKSB7XG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IHN3ZWVwQW5nbGUgLyAyO1xuICAgICAgY29uc3QgbWF4RW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAvICgxIC8gTWF0aC5zaW4oZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwKSArIDEpO1xuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihtYXhFbmRPdXRlckNvcm5lclJhZGl1cywgZW5kT3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgLyAoaW5uZXJSYWRpdXMgKyBzdGFydElubmVyQ29ybmVyUmFkaXVzKVxuICAgICk7XG4gICAgY29uc3QgZW5kSW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKGVuZElubmVyQ29ybmVyUmFkaXVzIC8gKGlubmVyUmFkaXVzICsgZW5kSW5uZXJDb3JuZXJSYWRpdXMpKTtcbiAgICBjb25zdCBvdXRlckFyY1JhZGl1cyA9IGNsaXBTZWN0b3I/Lm91dGVyUmFkaXVzID8/IG91dGVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyQXJjUmFkaXVzT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlckFyY1JhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBcmMgPSBuZXcgQXJjKFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvdXRlckFyY1JhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUgKyBvdXRlckFyY1JhZGl1c09mZnNldCxcbiAgICAgIGVuZEFuZ2xlIC0gb3V0ZXJBcmNSYWRpdXNPZmZzZXRcbiAgICApO1xuICAgIGNvbnN0IGlubmVyQXJjUmFkaXVzID0gY2xpcFNlY3Rvcj8uaW5uZXJSYWRpdXMgPz8gaW5uZXJSYWRpdXM7XG4gICAgY29uc3QgaW5uZXJBcmNSYWRpdXNPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KGlubmVyQXJjUmFkaXVzKTtcbiAgICBjb25zdCBpbm5lckFyYyA9IGhhc0lubmVyU3dlZXAgPyBuZXcgQXJjKDAsIDAsIGlubmVyQXJjUmFkaXVzLCBzdGFydEFuZ2xlICsgaW5uZXJBcmNSYWRpdXNPZmZzZXQsIGVuZEFuZ2xlIC0gaW5uZXJBcmNSYWRpdXNPZmZzZXQpIDogdm9pZCAwO1xuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIG91dGVyQXJjLmNsaXBTdGFydChjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpO1xuICAgICAgb3V0ZXJBcmMuY2xpcEVuZChjbGlwU2VjdG9yLmVuZEFuZ2xlKTtcbiAgICAgIGlubmVyQXJjPy5jbGlwU3RhcnQoY2xpcFNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgICAgIGlubmVyQXJjPy5jbGlwRW5kKGNsaXBTZWN0b3IuZW5kQW5nbGUpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydE91dGVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBzdGFydEFuZ2xlIC0gTWF0aC5QSSAqIDAuNSxcbiAgICAgIHN0YXJ0QW5nbGUgKyBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICB0cnVlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGNvbnN0IGVuZE91dGVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIGVuZEFuZ2xlIC0gZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgZW5kQW5nbGUgKyBNYXRoLlBJICogMC41LFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGNvbnN0IGVuZElubmVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIGVuZEFuZ2xlICsgTWF0aC5QSSAqIDAuNSxcbiAgICAgIGVuZEFuZ2xlICsgTWF0aC5QSSAtIGVuZElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICBmYWxzZSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbnN0IHN0YXJ0SW5uZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIHN0YXJ0QW5nbGUgKyBNYXRoLlBJICsgc3RhcnRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBzdGFydEFuZ2xlICsgTWF0aC5QSSAqIDEuNSxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICB0cnVlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgaWYgKGlubmVyQW5nbGVFeGNlZWRlZCkge1xuICAgICAgY29uc3QgeCA9IHN3ZWVwQW5nbGUgPCBNYXRoLlBJICogMC41ID8gcmFkaWFsRWRnZUluc2V0ICogKDEgKyBNYXRoLmNvcyhzd2VlcEFuZ2xlKSkgLyBNYXRoLnNpbihzd2VlcEFuZ2xlKSA6IE5hTjtcbiAgICAgIGxldCByO1xuICAgICAgaWYgKHggPiAwICYmIHggPCBvdXRlclJhZGl1cykge1xuICAgICAgICByID0gTWF0aC5tYXgoTWF0aC5oeXBvdChyYWRpYWxFZGdlSW5zZXQsIHgpLCBpbm5lclJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gcmFkaWFsRWRnZUluc2V0O1xuICAgICAgfVxuICAgICAgciA9IE1hdGgubWF4KHIsIGlubmVyUmFkaXVzKTtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHN3ZWVwQW5nbGUgKiAwLjU7XG4gICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgciAqIE1hdGguY29zKG1pZEFuZ2xlKSwgY2VudGVyWSArIHIgKiBNYXRoLnNpbihtaWRBbmdsZSkpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRJbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlIHx8IGlubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZSAvIDI7XG4gICAgICBjb25zdCBjeCA9IGlubmVyUmFkaXVzICogTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgICAgY29uc3QgY3kgPSBpbm5lclJhZGl1cyAqIE1hdGguc2luKG1pZEFuZ2xlKTtcbiAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5KTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0T3V0ZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gc3RhcnRPdXRlckFyYztcbiAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgIH1cbiAgICBpZiAob3V0ZXJBcmMuaXNWYWxpZCgpKSB7XG4gICAgICBjb25zdCB7IHIsIGEwLCBhMSB9ID0gb3V0ZXJBcmM7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByLCBhMCwgYTEpO1xuICAgIH1cbiAgICBpZiAoZW5kT3V0ZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gZW5kT3V0ZXJBcmM7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICB9XG4gICAgaWYgKCFpbm5lckFuZ2xlRXhjZWVkZWQpIHtcbiAgICAgIGlmIChlbmRJbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IGVuZElubmVyQXJjO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgciwgYTAsIGExIH0gPSBpbm5lckFyYztcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgciwgYTEsIGEwLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydElubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gc3RhcnRJbm5lckFyYztcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5jbGlwU2VjdG9yID8/IHRoaXM7XG4gICAgcmV0dXJuIGlzUG9pbnRJblNlY3Rvcihwb2ludC54IC0gdGhpcy5jZW50ZXJYLCBwb2ludC55IC0gdGhpcy5jZW50ZXJZLCB7XG4gICAgICBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5taW4oaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heChpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpXG4gICAgfSk7XG4gIH1cbn07XG5TZWN0b3IuY2xhc3NOYW1lID0gXCJTZWN0b3JcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNlbnRlclhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNsaXBTZWN0b3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjb25jZW50cmljRWRnZUluc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwicmFkaWFsRWRnZUluc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwic3RhcnRPdXRlckNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZE91dGVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwic3RhcnRJbm5lckNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZElubmVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZGVmYXVsdENvbG9ycy50c1xudmFyIERFRkFVTFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBPUkFOR0U6IFwiI2ZmYTAzYVwiLFxuICBHUkVFTjogXCIjNDU5ZDU1XCIsXG4gIENZQU46IFwiIzM0YmZlMVwiLFxuICBZRUxMT1c6IFwiI2UxY2MwMFwiLFxuICBWSU9MRVQ6IFwiIzk2NjljYlwiLFxuICBHUkFZOiBcIiNiNWI1YjVcIixcbiAgTUFHRU5UQTogXCIjYmQ1YWE3XCIsXG4gIEJST1dOOiBcIiM4YTYyMjRcIixcbiAgUkVEOiBcIiNlZjU0NTJcIlxufTtcbnZhciBERUZBVUxUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzJiNWM5NVwiLFxuICBPUkFOR0U6IFwiI2NjNmYxMFwiLFxuICBHUkVFTjogXCIjMWU2NTJlXCIsXG4gIENZQU46IFwiIzE4ODU5ZVwiLFxuICBZRUxMT1c6IFwiI2E2OTQwMFwiLFxuICBWSU9MRVQ6IFwiIzYwM2M4OFwiLFxuICBHUkFZOiBcIiM1NzU3NTdcIixcbiAgTUFHRU5UQTogXCIjN2QyZjZkXCIsXG4gIEJST1dOOiBcIiM0ZjM1MDhcIixcbiAgUkVEOiBcIiNhODI1MjlcIlxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0U2VyaWVzUHJvcGVydGllcy50c1xudmFyIERvbnV0VGl0bGUgPSBjbGFzcyBleHRlbmRzIENhcHRpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hvd0luTGVnZW5kID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgRG9udXRUaXRsZS5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xudmFyIERvbnV0SW5uZXJMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc3BhY2luZyA9IDI7XG4gIH1cbiAgc2V0KHByb3BlcnRpZXMsIF9yZXNldCkge1xuICAgIHJldHVybiBzdXBlci5zZXQocHJvcGVydGllcyk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBEb251dElubmVyTGFiZWwucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dElubmVyTGFiZWwucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG52YXIgRG9udXRJbm5lckNpcmNsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbCA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIERvbnV0SW5uZXJDaXJjbGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0SW5uZXJDaXJjbGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xudmFyIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5vZmZzZXQgPSAzO1xuICAgIHRoaXMubWluQW5nbGUgPSAwO1xuICAgIHRoaXMubWluU3BhY2luZyA9IDQ7XG4gICAgdGhpcy5tYXhDb2xsaXNpb25PZmZzZXQgPSA1MDtcbiAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pbkFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWF4Q29sbGlzaW9uT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJhdm9pZENvbGxpc2lvbnNcIiwgMik7XG52YXIgRG9udXRTZXJpZXNTZWN0b3JMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucG9zaXRpb25PZmZzZXQgPSAwO1xuICAgIHRoaXMucG9zaXRpb25SYXRpbyA9IDAuNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0U2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblJhdGlvXCIsIDIpO1xudmFyIERvbnV0U2VyaWVzQ2FsbG91dExpbmUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxlbmd0aCA9IDEwO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbnZhciBEb251dFNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xuICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXNPZmZzZXQgPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXNSYXRpbyA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zZWN0b3JTcGFjaW5nID0gMDtcbiAgICB0aGlzLmlubmVyTGFiZWxzID0gbmV3IFByb3BlcnRpZXNBcnJheShEb251dElubmVyTGFiZWwpO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgRG9udXRUaXRsZSgpO1xuICAgIHRoaXMuaW5uZXJDaXJjbGUgPSBuZXcgRG9udXRJbm5lckNpcmNsZSgpO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbCA9IG5ldyBEb251dFNlcmllc0NhbGxvdXRMYWJlbCgpO1xuICAgIHRoaXMuc2VjdG9yTGFiZWwgPSBuZXcgRG9udXRTZXJpZXNTZWN0b3JMYWJlbCgpO1xuICAgIHRoaXMuY2FsbG91dExpbmUgPSBuZXcgRG9udXRTZXJpZXNDYWxsb3V0TGluZSgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gIH1cbiAgaXNWYWxpZCgpIHtcbiAgICBjb25zdCBzdXBlcklzVmFsaWQgPSBzdXBlci5pc1ZhbGlkKCk7XG4gICAgaWYgKHRoaXMuaW5uZXJSYWRpdXNSYXRpbyA9PSBudWxsICYmIHRoaXMuaW5uZXJSYWRpdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICBcIkVpdGhlciBhbiBbaW5uZXJSYWRpdXNSYXRpb10gb3IgYW4gW2lubmVyUmFkaXVzT2Zmc2V0XSBtdXN0IGJlIHNldCB0byByZW5kZXIgYSBkb251dCBzZXJpZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlcklzVmFsaWQ7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWF4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c09mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1JhdGlvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvclNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1RfQVJSQVkpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyTGFiZWxzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJDaXJjbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVVdGlsLnRzXG5mdW5jdGlvbiBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKGluaXRpYWxMb2FkLCByb3RhdGlvbkRlZ3JlZXMsIHNjYWxlRm4sIG9sZFNjYWxlRm4pIHtcbiAgY29uc3Qgc2NhbGUyID0gW3NjYWxlRm4uY29udmVydCgwKSwgc2NhbGVGbi5jb252ZXJ0KDEpXTtcbiAgY29uc3Qgb2xkU2NhbGUgPSBbb2xkU2NhbGVGbi5jb252ZXJ0KDApLCBvbGRTY2FsZUZuLmNvbnZlcnQoMSldO1xuICBjb25zdCByb3RhdGlvbiA9IE1hdGguUEkgLyAtMiArIHRvUmFkaWFucyhyb3RhdGlvbkRlZ3JlZXMpO1xuICBjb25zdCBwaGFzZSA9IGluaXRpYWxMb2FkID8gXCJpbml0aWFsXCIgOiBcInVwZGF0ZVwiO1xuICBjb25zdCBzY2FsZVRvTmV3UmFkaXVzID0gKHsgcmFkaXVzIH0pID0+IHtcbiAgICByZXR1cm4geyBpbm5lclJhZGl1czogc2NhbGUyWzBdLCBvdXRlclJhZGl1czogc2NhbGUyWzBdICsgKHNjYWxlMlsxXSAtIHNjYWxlMlswXSkgKiByYWRpdXMgfTtcbiAgfTtcbiAgY29uc3Qgc2NhbGVUb09sZFJhZGl1cyA9ICh7IHJhZGl1cyB9KSA9PiB7XG4gICAgcmV0dXJuIHsgaW5uZXJSYWRpdXM6IG9sZFNjYWxlWzBdLCBvdXRlclJhZGl1czogb2xkU2NhbGVbMF0gKyAob2xkU2NhbGVbMV0gLSBvbGRTY2FsZVswXSkgKiByYWRpdXMgfTtcbiAgfTtcbiAgY29uc3QgZnJvbUZuID0gKHNlY3QsIGRhdHVtLCBzdGF0dXMsIHsgcHJldkZyb21Qcm9wcyB9KSA9PiB7XG4gICAgbGV0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gc2VjdDtcbiAgICBsZXQgeyBmaWxsLCBzdHJva2UgfSA9IGRhdHVtLnNlY3RvckZvcm1hdDtcbiAgICBpZiAoc3RhdHVzID09PSBcInVua25vd25cIiB8fCBzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiAhcHJldkZyb21Qcm9wcykge1xuICAgICAgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgICAgZW5kQW5nbGUgPSByb3RhdGlvbjtcbiAgICAgIGlubmVyUmFkaXVzID0gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgJiYgcHJldkZyb21Qcm9wcykge1xuICAgICAgc3RhcnRBbmdsZSA9IHByZXZGcm9tUHJvcHMuZW5kQW5nbGUgPz8gcm90YXRpb247XG4gICAgICBlbmRBbmdsZSA9IHByZXZGcm9tUHJvcHMuZW5kQW5nbGUgPz8gcm90YXRpb247XG4gICAgICBpbm5lclJhZGl1cyA9IHByZXZGcm9tUHJvcHMuaW5uZXJSYWRpdXMgPz8gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IHByZXZGcm9tUHJvcHMub3V0ZXJSYWRpdXMgPz8gZGF0dW0ub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiAhaW5pdGlhbExvYWQpIHtcbiAgICAgIGNvbnN0IHJhZGlpID0gc2NhbGVUb09sZFJhZGl1cyhkYXR1bSk7XG4gICAgICBpbm5lclJhZGl1cyA9IHJhZGlpLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSByYWRpaS5vdXRlclJhZGl1cztcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1cGRhdGVkXCIpIHtcbiAgICAgIGZpbGwgPSBzZWN0LmZpbGwgPz8gZmlsbDtcbiAgICAgIHN0cm9rZSA9IHNlY3Quc3Ryb2tlID8/IHN0cm9rZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZmlsbCwgc3Ryb2tlLCBwaGFzZSB9O1xuICB9O1xuICBjb25zdCB0b0ZuID0gKF9zZWN0LCBkYXR1bSwgc3RhdHVzLCB7IHByZXZMaXZlIH0pID0+IHtcbiAgICBsZXQgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICBjb25zdCB7IHN0cm9rZSwgZmlsbCB9ID0gZGF0dW0uc2VjdG9yRm9ybWF0O1xuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiICYmIHByZXZMaXZlKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcHJldkxpdmUuZGF0dW0/LmVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBwcmV2TGl2ZS5kYXR1bT8uZW5kQW5nbGU7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiICYmICFwcmV2TGl2ZSkge1xuICAgICAgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgICAgZW5kQW5nbGUgPSByb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgIGNvbnN0IHJhZGlpID0gc2NhbGVUb05ld1JhZGl1cyhkYXR1bSk7XG4gICAgICBpbm5lclJhZGl1cyA9IHJhZGlpLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSByYWRpaS5vdXRlclJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgc3Ryb2tlLCBmaWxsIH07XG4gIH07XG4gIGNvbnN0IGlubmVyQ2lyY2xlRnJvbUZuID0gKG5vZGUsIF8pID0+IHtcbiAgICByZXR1cm4geyBzaXplOiBub2RlLnByZXZpb3VzRGF0dW0/LnJhZGl1cyA/PyBub2RlLnNpemUgPz8gMCwgcGhhc2UgfTtcbiAgfTtcbiAgY29uc3QgaW5uZXJDaXJjbGVUb0ZuID0gKF8sIGRhdHVtKSA9PiB7XG4gICAgcmV0dXJuIHsgc2l6ZTogZGF0dW0ucmFkaXVzID8/IDAgfTtcbiAgfTtcbiAgcmV0dXJuIHsgbm9kZXM6IHsgdG9GbiwgZnJvbUZuIH0sIGlubmVyQ2lyY2xlOiB7IGZyb21GbjogaW5uZXJDaXJjbGVGcm9tRm4sIHRvRm46IGlubmVyQ2lyY2xlVG9GbiB9IH07XG59XG5mdW5jdGlvbiByZXNldFBpZVNlbGVjdGlvbnNGbihfbm9kZSwgZGF0dW0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydEFuZ2xlOiBkYXR1bS5zdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlOiBkYXR1bS5lbmRBbmdsZSxcbiAgICBpbm5lclJhZGl1czogZGF0dW0uaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXM6IGRhdHVtLm91dGVyUmFkaXVzLFxuICAgIGZpbGw6IGRhdHVtLnNlY3RvckZvcm1hdC5maWxsLFxuICAgIHN0cm9rZTogZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZVxuICB9O1xufVxuZnVuY3Rpb24gcGlja0J5TWF0Y2hpbmdBbmdsZShzZXJpZXMsIHBvaW50KSB7XG4gIGNvbnN0IGR5ID0gcG9pbnQueSAtIHNlcmllcy5jZW50ZXJZO1xuICBjb25zdCBkeCA9IHBvaW50LnggLSBzZXJpZXMuY2VudGVyWDtcbiAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICBjb25zdCBzZWN0b3JzID0gc2VyaWVzLmdldEl0ZW1Ob2RlcygpO1xuICBmb3IgKGNvbnN0IHNlY3RvciBvZiBzZWN0b3JzKSB7XG4gICAgaWYgKHNlY3Rvci5kYXR1bS5taXNzaW5nID09PSB0cnVlKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhhbmdsZTIsIHNlY3Rvci5zdGFydEFuZ2xlLCBzZWN0b3IuZW5kQW5nbGUpKSB7XG4gICAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgbGV0IGRpc3RhbmNlMyA9IDA7XG4gICAgICBpZiAocmFkaXVzIDwgc2VjdG9yLmlubmVyUmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlMyA9IHNlY3Rvci5pbm5lclJhZGl1cyAtIHJhZGl1cztcbiAgICAgIH0gZWxzZSBpZiAocmFkaXVzID4gc2VjdG9yLm91dGVyUmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlMyA9IHJhZGl1cyAtIHNlY3Rvci5vdXRlclJhZGl1cztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdHVtOiBzZWN0b3IuZGF0dW0sIGRpc3RhbmNlOiBkaXN0YW5jZTMgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BvbGFyU2VyaWVzLnRzXG52YXIgUG9sYXJTZXJpZXMgPSBjbGFzcyBleHRlbmRzIERhdGFNb2RlbFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1c2VMYWJlbExheWVyID0gZmFsc2UsXG4gICAgcGlja01vZGVzID0gWzMgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICBjYW5IYXZlQXhlcyA9IGZhbHNlLFxuICAgIGFuaW1hdGlvblJlc2V0Rm5zLFxuICAgIC4uLm9wdHNcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICB1c2VMYWJlbExheWVyLFxuICAgICAgcGlja01vZGVzLFxuICAgICAgY29udGVudEdyb3VwVmlydHVhbDogZmFsc2UsXG4gICAgICBkaXJlY3Rpb25LZXlzOiB7XG4gICAgICAgIFtcInhcIiAvKiBYICovXTogW1wiYW5nbGVLZXlcIl0sXG4gICAgICAgIFtcInlcIiAvKiBZICovXTogW1wicmFkaXVzS2V5XCJdXG4gICAgICB9LFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IHtcbiAgICAgICAgW1wieFwiIC8qIFggKi9dOiBbXCJhbmdsZU5hbWVcIl0sXG4gICAgICAgIFtcInlcIiAvKiBZICovXTogW1wicmFkaXVzTmFtZVwiXVxuICAgICAgfSxcbiAgICAgIGNhbkhhdmVBeGVzXG4gICAgfSk7XG4gICAgdGhpcy5pdGVtR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoKSk7XG4gICAgdGhpcy5ub2RlRGF0YSA9IFtdO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLml0ZW1Hcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMubGFiZWxHcm91cCxcbiAgICAgICgpID0+IHRoaXMubGFiZWxGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5oaWdobGlnaHRHcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKVxuICAgICk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmhpZ2hsaWdodExhYmVsLFxuICAgICAgKCkgPT4gdGhpcy5sYWJlbEZhY3RvcnkoKVxuICAgICk7XG4gICAgLyoqXG4gICAgICogVGhlIGNlbnRlciBvZiB0aGUgcG9sYXIgc2VyaWVzIChmb3IgZXhhbXBsZSwgdGhlIGNlbnRlciBvZiBhIHBpZSkuXG4gICAgICogSWYgdGhlIHBvbGFyIGNoYXJ0IGhhcyBtdWx0aXBsZSBzZXJpZXMsIGFsbCBvZiB0aGVtIHdpbGwgaGF2ZSB0aGVpclxuICAgICAqIGNlbnRlciBzZXQgdG8gdGhlIHNhbWUgdmFsdWUgYXMgYSByZXN1bHQgb2YgdGhlIHBvbGFyIGNoYXJ0IGxheW91dC5cbiAgICAgKiBUaGUgY2VudGVyIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9zZWQgdG8gYmUgc2V0IGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHRoaXMuY2VudGVyWCA9IDA7XG4gICAgdGhpcy5jZW50ZXJZID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSByYWRpdXMgdGhlIHNlcmllcyBjYW4gdXNlLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgc2V0IGF1dG9tYXRpY2FsbHkgYXMgYSByZXN1bHQgb2YgdGhlIHBvbGFyIGNoYXJ0IGxheW91dFxuICAgICAqIGFuZCBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgc2V0IGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gMDtcbiAgICB0aGlzLml0ZW1Hcm91cC56SW5kZXhTdWJPcmRlciA9IFsoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyLCAxXTtcbiAgICB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zID0gYW5pbWF0aW9uUmVzZXRGbnM7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXG4gICAgICBcImVtcHR5XCIsXG4gICAgICB7XG4gICAgICAgIGVtcHR5OiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgdXBkYXRlRGF0YTogXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgY2xlYXI6IFwiY2xlYXJpbmdcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcbiAgICAgICAgICBoaWdobGlnaHRNYXJrZXJzOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKGRhdGEpLFxuICAgICAgICAgIHJlc2l6ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICBjbGVhcmluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKCkgPT4gdGhpcy5jaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKClcbiAgICApO1xuICB9XG4gIGdldEl0ZW1Ob2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtR3JvdXAuY2hpbGRyZW47XG4gIH1cbiAgZ2V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZURhdGE7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfVxuICB9XG4gIGxhYmVsRmFjdG9yeSgpIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgZ2V0SW5uZXJSYWRpdXMoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb21wdXRlTGFiZWxzQkJveChfb3B0aW9ucywgX3Nlcmllc1JlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXNldEFsbEFuaW1hdGlvbigpIHtcbiAgICBjb25zdCB7IGl0ZW0sIGxhYmVsIH0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmVzZXRNb3Rpb24oW3RoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb25dLCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5sYWJlbFNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbl0sIGxhYmVsKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKCk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHQoX2RhdGEpIHtcbiAgICBjb25zdCB7IGl0ZW0sIGxhYmVsIH0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5oaWdobGlnaHRTZWxlY3Rpb25dLCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbl0sIGxhYmVsKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhfZGF0YSkge1xuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShfZGF0YSkge1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRpb25UcmFuc2l0aW9uQ2xlYXIoKSB7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiY2xlYXJcIiwgdGhpcy5nZXRBbmltYXRpb25EYXRhKCkpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiB7IHNlcmllc1JlY3QgfTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXROb2RlRGF0YSgpPy5bb3B0cy5kYXR1bUluZGV4XTtcbiAgICBpZiAoZGF0dW0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbVNlbGVjdGlvbi5zZWxlY3QoKG5vZGUpID0+IG5vZGUgaW5zdGFuY2VvZiBQYXRoICYmIG5vZGUuZGF0dW0gPT09IGRhdHVtKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0U2VyaWVzLnRzXG52YXIgRG9udXRTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIFNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMuYW5nbGVLZXkgPSBzZXJpZXMucHJvcGVydGllcy5hbmdsZUtleTtcbiAgICB0aGlzLnJhZGl1c0tleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnJhZGl1c0tleTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleTtcbiAgICB0aGlzLnNlY3RvckxhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXk7XG4gIH1cbn07XG52YXIgRG9udXRTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFBvbGFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMyAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7IGl0ZW06IHJlc2V0UGllU2VsZWN0aW9uc0ZuLCBsYWJlbDogcmVzZXRMYWJlbEZuIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgRG9udXRTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5yYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKCkpO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLnBoYW50b21Hcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJwaWVDYWxsb3V0TGFiZWxzXCIgfSkpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbihcbiAgICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAsXG4gICAgICBHcm91cFxuICAgICk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyB0aGUgYmFja2dyb3VuZCBncmFwaGljcy5cbiAgICB0aGlzLmJhY2tncm91bmRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYmFja2dyb3VuZGAsXG4gICAgICAgIGxheWVyOiB0cnVlLFxuICAgICAgICB6SW5kZXg6IDAgLyogU0VSSUVTX0JBQ0tHUk9VTkRfWklOREVYICovXG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gQUctNjE5MyBJZiB0aGUgc3VtIG9mIGFsbCBkYXR1bXMgaXMgMCwgdGhlbiB3ZSdsbCBkcmF3IDEgb3IgMiByaW5ncyB0byByZXByZXNlbnQgdGhlIGVtcHR5IHNlcmllcy5cbiAgICB0aGlzLnplcm9zdW1SaW5nc0dyb3VwID0gdGhpcy5iYWNrZ3JvdW5kR3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0temVyb3N1bVJpbmdzYCB9KSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nID0gdGhpcy56ZXJvc3VtUmluZ3NHcm91cC5hcHBlbmRDaGlsZChuZXcgQ2lyY2xlKCkpO1xuICAgIHRoaXMuemVyb3N1bUlubmVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IENpcmNsZSgpKTtcbiAgICB0aGlzLmlubmVyTGFiZWxzR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImlubmVyTGFiZWxzXCIgfSkpO1xuICAgIHRoaXMuaW5uZXJDaXJjbGVHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LWlubmVyQ2lyY2xlYCB9KSk7XG4gICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5pbm5lckxhYmVsc0dyb3VwLCBUZXh0KTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaW5uZXJDaXJjbGVHcm91cCxcbiAgICAgIENpcmNsZVxuICAgICk7XG4gICAgLy8gV2hlbiBhIHVzZXIgdG9nZ2xlcyBhIHNlcmllcyBpdGVtIChlLmcuIGZyb20gdGhlIGxlZ2VuZCksIGl0cyBib29sZWFuIHN0YXRlIGlzIHJlY29yZGVkIGhlcmUuXG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IFtdO1xuICAgIHRoaXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBEb251dFNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmFuZ2xlU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluID0gWzAsIDFdO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5yYW5nZSA9IFstTWF0aC5QSSwgTWF0aC5QSV0ubWFwKChhbmdsZTIpID0+IGFuZ2xlMiArIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cC5vcGFjaXR5ID0gMC4yO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwLnpJbmRleFN1Yk9yZGVyID0gWygpID0+IHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIsIDBdO1xuICB9XG4gIGdldCBjYWxsb3V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IHRoaXMubm9kZURhdGE7XG4gIH1cbiAgYWRkQ2hhcnRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyPy5hZGRMaXN0ZW5lcihcImxlZ2VuZC1pdGVtLWNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1DbGljayhldmVudCkpXG4gICAgKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudmlzaWJsZSAmJiAodGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5sZW5ndGggPT09IDAgfHwgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5zb21lKCh2aXNpYmxlKSA9PiB2aXNpYmxlKSk7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWN0b3IoKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYW5nbGVTY2FsZS5kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJhZGl1c1NjYWxlLmRvbWFpbjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgZGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpc2libGUsIHNlcmllc0l0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIGFuZ2xlRmlsdGVyS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgZXh0cmFLZXlQcm9wcyA9IFtdO1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbUtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbEtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbEtleWAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXNTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgY29uc3QgYW5nbGVTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgaWYgKHJhZGl1c0tleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICByYW5nZWRWYWx1ZVByb3BlcnR5KHJhZGl1c0tleSwge1xuICAgICAgICAgIGlkOiBcInJhZGl1c1ZhbHVlXCIsXG4gICAgICAgICAgbWluOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsXG4gICAgICAgICAgbWF4OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4XG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHJhZGl1c0tleSwgcmFkaXVzU2NhbGVUeXBlLCB7IGlkOiBgcmFkaXVzUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcInJhZGl1c1ZhbHVlXCIsIFswLCAxXSwgMSwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlRmlsdGVyS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGBhbmdsZUZpbHRlclZhbHVlYCxcbiAgICAgICAgICBvbmx5UG9zaXRpdmU6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVGaWx0ZXJSYXdgIH0pLFxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVGaWx0ZXJWYWx1ZVwiLCBbMCwgMV0sIDAsIDApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEgJiYgZXh0cmFLZXlQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgZGF0YSA9IGRhdGEubWFwKChkLCBpZHgpID0+IHZpc2libGUgJiYgc2VyaWVzSXRlbUVuYWJsZWRbaWR4XSA/IGQgOiB7IC4uLmQsIFthbmdsZUtleV06IDAgfSk7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICAuLi5leHRyYUtleVByb3BzLFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlVmFsdWVgLCBvbmx5UG9zaXRpdmU6IHRydWUgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVWYWx1ZVwiLCBbMCwgMV0sIDAsIDApLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCB2YWx1ZURlZiBvZiB0aGlzLnByb2Nlc3NlZERhdGE/LmRlZnM/LnZhbHVlcyA/PyBbXSkge1xuICAgICAgY29uc3QgeyBpZCwgbWlzc2luZywgcHJvcGVydHkgfSA9IHZhbHVlRGVmO1xuICAgICAgY29uc3QgbWlzc0NvdW50ID0gZ2V0TWlzc0NvdW50KHRoaXMsIG1pc3NpbmcpO1xuICAgICAgaWYgKGlkICE9PSBcImFuZ2xlUmF3XCIgJiYgbWlzc0NvdW50ID4gMCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYG5vIHZhbHVlIHdhcyBmb3VuZCBmb3IgdGhlIGtleSAnJHtTdHJpbmcocHJvcGVydHkpfScgb24gJHttaXNzQ291bnR9IGRhdGEgZWxlbWVudCR7bWlzc0NvdW50ID4gMSA/IFwic1wiIDogXCJcIn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgYXN5bmMgbWF5YmVSZWZyZXNoTm9kZURhdGEoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGVEYXRhUmVmcmVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhID0gW10sIHBoYW50b21Ob2RlRGF0YSB9ID0gYXdhaXQgdGhpcy5jcmVhdGVOb2RlRGF0YSgpID8/IHt9O1xuICAgIHRoaXMubm9kZURhdGEgPSBub2RlRGF0YTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHBoYW50b21Ob2RlRGF0YTtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlO1xuICB9XG4gIGdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCkge1xuICAgIGNvbnN0IGFuZ2xlSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVZhbHVlYCk7XG4gICAgY29uc3QgYW5nbGVSYXdJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlUmF3YCk7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVyUmF3SWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgcmFkaXVzVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjYWxsb3V0TGFiZWxWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzZWN0b3JMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgYW5nbGVJZHgsXG4gICAgICBhbmdsZVJhd0lkeCxcbiAgICAgIGFuZ2xlRmlsdGVySWR4LFxuICAgICAgYW5nbGVGaWx0ZXJSYXdJZHgsXG4gICAgICByYWRpdXNJZHgsXG4gICAgICByYWRpdXNSYXdJZHgsXG4gICAgICBjYWxsb3V0TGFiZWxJZHgsXG4gICAgICBzZWN0b3JMYWJlbElkeCxcbiAgICAgIGxlZ2VuZEl0ZW1JZHhcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGFuZ2xlU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGlvbiwgaW5uZXJSYWRpdXNSYXRpbyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnZpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy56ZXJvc3VtSW5uZXJSaW5nLnZpc2libGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHsgaXRlbUlkOiBzZXJpZXNJZCwgbm9kZURhdGE6IFtdLCBsYWJlbERhdGE6IFtdIH07XG4gICAgfVxuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gXCJ1bmdyb3VwZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XG4gICAgY29uc3QgdXNlRmlsdGVyQW5nbGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCAmJiBwcm9jZXNzZWREYXRhLmRhdGEuc29tZSgoeyB2YWx1ZXMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlc1thbmdsZUZpbHRlclJhd0lkeF0gPiB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgIH0pO1xuICAgIGxldCBjdXJyZW50U3RhcnQgPSAwO1xuICAgIGxldCBzdW0yID0gMDtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHBoYW50b21Ob2RlcyA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgPyBbXSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGEuZm9yRWFjaCgoZ3JvdXAsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtLCB2YWx1ZXMgfSA9IGdyb3VwO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdXNlRmlsdGVyQW5nbGVzID8gdmFsdWVzW2FuZ2xlRmlsdGVySWR4XSA6IHZhbHVlc1thbmdsZUlkeF07XG4gICAgICBjb25zdCBjcm9zc0ZpbHRlclNjYWxlID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCAmJiAhdXNlRmlsdGVyQW5nbGVzID8gTWF0aC5zcXJ0KHZhbHVlc1thbmdsZUZpbHRlclJhd0lkeF0gLyB2YWx1ZXNbYW5nbGVSYXdJZHhdKSA6IDE7XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY3VycmVudFN0YXJ0ID0gY3VycmVudFZhbHVlO1xuICAgICAgc3VtMiArPSBjdXJyZW50VmFsdWU7XG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHNwYW4gPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3BhbiAvIDI7XG4gICAgICBjb25zdCBhbmdsZVZhbHVlID0gdmFsdWVzW2FuZ2xlUmF3SWR4XTtcbiAgICAgIGNvbnN0IHJhZGl1c1JhdyA9IHJhZGl1c0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c0lkeF0gPz8gMSA6IDE7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNSYXcgKiBjcm9zc0ZpbHRlclNjYWxlO1xuICAgICAgY29uc3QgcmFkaXVzVmFsdWUgPSByYWRpdXNSYXdJZHggIT0gbnVsbCA/IHZhbHVlc1tyYWRpdXNSYXdJZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3QgbGVnZW5kSXRlbVZhbHVlID0gbGVnZW5kSXRlbUlkeCAhPSBudWxsID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9kZUxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIHNwYW4sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW2NhbGxvdXRMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIHNlY3RvckxhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2VjdG9yTGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWVcbiAgICAgICk7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIGl0ZW1JZDogaW5kZXgsXG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGluZGV4LFxuICAgICAgICBhbmdsZVZhbHVlLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgbWlkQ29zOiBNYXRoLmNvcyhtaWRBbmdsZSksXG4gICAgICAgIG1pZFNpbjogTWF0aC5zaW4obWlkQW5nbGUpLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChyYWRpdXMpLCAwKSxcbiAgICAgICAgc2VjdG9yRm9ybWF0LFxuICAgICAgICByYWRpdXNWYWx1ZSxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlLFxuICAgICAgICBlbmFibGVkOiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgZm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICAuLi5ub2RlTGFiZWxzXG4gICAgICB9O1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIGlmIChwaGFudG9tTm9kZXMgIT0gbnVsbCkge1xuICAgICAgICBwaGFudG9tTm9kZXMucHVzaCh7XG4gICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICByYWRpdXM6IDEsXG4gICAgICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgxKSwgMCksXG4gICAgICAgICAgZm9jdXNhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcudmlzaWJsZSA9IHN1bTIgPT09IDA7XG4gICAgdGhpcy56ZXJvc3VtSW5uZXJSaW5nLnZpc2libGUgPSBzdW0yID09PSAwICYmIGlubmVyUmFkaXVzUmF0aW8gIT0gbnVsbCAmJiBpbm5lclJhZGl1c1JhdGlvICE9PSAxICYmIGlubmVyUmFkaXVzUmF0aW8gPiAwO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHNlcmllc0lkLFxuICAgICAgbm9kZURhdGE6IG5vZGVzLFxuICAgICAgbGFiZWxEYXRhOiBub2RlcyxcbiAgICAgIHBoYW50b21Ob2RlRGF0YTogcGhhbnRvbU5vZGVzXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbHMoZGF0dW0sIG1pZEFuZ2xlLCBzcGFuLCBza2lwRGlzYWJsZWQsIGNhbGxvdXRMYWJlbFZhbHVlLCBzZWN0b3JMYWJlbFZhbHVlLCBsZWdlbmRJdGVtVmFsdWUpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgc2VjdG9yTGFiZWwsIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IGNhbGxvdXRMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZWN0b3JMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgc2VjdG9yTGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSA6IHZvaWQgMDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbEtleSAmJiAhc2VjdG9yTGFiZWxLZXkgJiYgIWxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxGb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlS2V5OiB0aGlzLnByb3BlcnRpZXMuYW5nbGVLZXksXG4gICAgICBhbmdsZU5hbWU6IHRoaXMucHJvcGVydGllcy5hbmdsZU5hbWUsXG4gICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICByYWRpdXNOYW1lOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTmFtZSxcbiAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSxcbiAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSxcbiAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsTmFtZSxcbiAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoY2FsbG91dExhYmVsS2V5ICYmIHNwYW4gPiB0b1JhZGlhbnMoY2FsbG91dExhYmVsLm1pbkFuZ2xlKSkge1xuICAgICAgcmVzdWx0LmNhbGxvdXRMYWJlbCA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSxcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoY2FsbG91dExhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IGNhbGxvdXRMYWJlbFZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBjb2xsaXNpb25UZXh0QWxpZ246IHZvaWQgMCxcbiAgICAgICAgY29sbGlzaW9uT2Zmc2V0WTogMCxcbiAgICAgICAgYm94OiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmVzdWx0LnNlY3RvckxhYmVsID0ge1xuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChzZWN0b3JMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBzZWN0b3JMYWJlbFZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1WYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQubGVnZW5kSXRlbSA9IHsga2V5OiBsZWdlbmRJdGVtS2V5LCB0ZXh0OiBsZWdlbmRJdGVtVmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSB7XG4gICAgY29uc3QgcXVhZHJhbnRUZXh0T3B0cyA9IFtcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImxlZnRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwicmlnaHRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH1cbiAgICBdO1xuICAgIGNvbnN0IG1pZEFuZ2xlMTgwID0gbm9ybWFsaXplQW5nbGUxODAobWlkQW5nbGUpO1xuICAgIGNvbnN0IHF1YWRyYW50U3RhcnQgPSAtMC43NSAqIE1hdGguUEk7XG4gICAgY29uc3QgcXVhZHJhbnRPZmZzZXQgPSBtaWRBbmdsZTE4MCAtIHF1YWRyYW50U3RhcnQ7XG4gICAgY29uc3QgcXVhZHJhbnQgPSBNYXRoLmZsb29yKHF1YWRyYW50T2Zmc2V0IC8gKE1hdGguUEkgLyAyKSk7XG4gICAgY29uc3QgcXVhZHJhbnRJbmRleCA9IG1vZChxdWFkcmFudCwgcXVhZHJhbnRUZXh0T3B0cy5sZW5ndGgpO1xuICAgIHJldHVybiBxdWFkcmFudFRleHRPcHRzW3F1YWRyYW50SW5kZXhdO1xuICB9XG4gIGdldFNlY3RvckZvcm1hdChkYXR1bSwgZm9ybWF0SW5kZXgsIGhpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja0NhY2hlIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXksIGZpbGxzLCBzdHJva2VzLCBpdGVtU3R5bGVyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgZGVmYXVsdFN0cm9rZSA9IHN0cm9rZXNbZm9ybWF0SW5kZXggJSBzdHJva2VzLmxlbmd0aF07XG4gICAgY29uc3QgeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBjb3JuZXJSYWRpdXMgfSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICBoaWdobGlnaHRlZCAmJiB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSxcbiAgICAgIHtcbiAgICAgICAgZmlsbDogZmlsbHMubGVuZ3RoID4gMCA/IGZpbGxzW2Zvcm1hdEluZGV4ICUgZmlsbHMubGVuZ3RoXSA6IHZvaWQgMCxcbiAgICAgICAgc3Ryb2tlOiBkZWZhdWx0U3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKVxuICAgICAgfSxcbiAgICAgIHRoaXMucHJvcGVydGllc1xuICAgICk7XG4gICAgbGV0IGZvcm1hdDtcbiAgICBpZiAoaXRlbVN0eWxlcikge1xuICAgICAgZm9ybWF0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGl0ZW1TdHlsZXIsIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGFuZ2xlS2V5LFxuICAgICAgICByYWRpdXNLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXksXG4gICAgICAgIGZpbGwsXG4gICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBsaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgaGlnaGxpZ2h0ZWQsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGw6IGZvcm1hdD8uZmlsbCA/PyBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IGZvcm1hdD8uZmlsbE9wYWNpdHkgPz8gZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IGZvcm1hdD8uc3Ryb2tlID8/IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBmb3JtYXQ/LnN0cm9rZVdpZHRoID8/IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBmb3JtYXQ/LmxpbmVEYXNoT2Zmc2V0ID8/IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXNcbiAgICB9O1xuICB9XG4gIGdldElubmVyUmFkaXVzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXNSYXRpbyA9IDEsIGlubmVyUmFkaXVzT2Zmc2V0ID0gMCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzICogaW5uZXJSYWRpdXNSYXRpbyArIGlubmVyUmFkaXVzT2Zmc2V0O1xuICAgIGlmIChpbm5lclJhZGl1cyA9PT0gcmFkaXVzIHx8IGlubmVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBpbm5lclJhZGl1cztcbiAgfVxuICBnZXRPdXRlclJhZGl1cygpIHtcbiAgICBjb25zdCB7IG91dGVyUmFkaXVzUmF0aW8sIG91dGVyUmFkaXVzT2Zmc2V0IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmFkaXVzICogb3V0ZXJSYWRpdXNSYXRpbyArIG91dGVyUmFkaXVzT2Zmc2V0LCAwKTtcbiAgfVxuICB1cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpIHtcbiAgICBjb25zdCBuZXdSYW5nZSA9IFt0aGlzLmdldElubmVyUmFkaXVzKCksIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKV07XG4gICAgdGhpcy5yYWRpdXNTY2FsZS5yYW5nZSA9IG5ld1JhbmdlO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IG5ld1JhbmdlO1xuICAgIH1cbiAgICBjb25zdCBzZXRSYWRpaSA9IChkKSA9PiAoe1xuICAgICAgLi4uZCxcbiAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChkLnJhZGl1cyksIDApXG4gICAgfSk7XG4gICAgdGhpcy5ub2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKHNldFJhZGlpKTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHRoaXMucGhhbnRvbU5vZGVEYXRhPy5tYXAoc2V0UmFkaWkpO1xuICB9XG4gIGdldFRpdGxlVHJhbnNsYXRpb25ZKCkge1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5yYWRpdXNTY2FsZS5yYW5nZVsxXSk7XG4gICAgaWYgKG91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy5zcGFjaW5nID8/IDA7XG4gICAgY29uc3QgdGl0bGVPZmZzZXQgPSAyICsgc3BhY2luZztcbiAgICBjb25zdCBkeSA9IE1hdGgubWF4KDAsIC1vdXRlclJhZGl1cyk7XG4gICAgcmV0dXJuIC1vdXRlclJhZGl1cyAtIHRpdGxlT2Zmc2V0IC0gZHk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzID0ge1xuICAgICAgc2VyaWVzUmVjdFdpZHRoOiBzZXJpZXNSZWN0Py53aWR0aCxcbiAgICAgIHNlcmllc1JlY3RIZWlnaHQ6IHNlcmllc1JlY3Q/LmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcmVzaXplID0ganNvbkRpZmYodGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcywgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMpICE9IG51bGw7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdOb2RlRGF0YURlcGVuZGVuY2llcztcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlVGl0bGVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICBjb25zdCB0aXRsZUJveCA9IHRpdGxlLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgdGl0bGUubm9kZS52aXNpYmxlID0gdGl0bGUuZW5hYmxlZCAmJiBpc0Zpbml0ZShkeSkgJiYgIXRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyh0aXRsZUJveCwgMCwgZHkpO1xuICAgICAgdGl0bGUubm9kZS50cmFuc2xhdGlvblkgPSBpc0Zpbml0ZShkeSkgPyBkeSA6IDA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2lyY2xlIG9mIFt0aGlzLnplcm9zdW1Jbm5lclJpbmcsIHRoaXMuemVyb3N1bU91dGVyUmluZ10pIHtcbiAgICAgIGNpcmNsZS5maWxsT3BhY2l0eSA9IDA7XG4gICAgICBjaXJjbGUuc3Ryb2tlID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbC5jb2xvcjtcbiAgICAgIGNpcmNsZS5zdHJva2VXaWR0aCA9IDE7XG4gICAgICBjaXJjbGUuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTm9kZU1pZFBvaW50KCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVOb2RlcyhzZXJpZXNSZWN0KTtcbiAgfVxuICB1cGRhdGVUaXRsZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgb2xkVGl0bGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRUaXRsZSAhPT0gdGl0bGUpIHtcbiAgICAgIGlmIChvbGRUaXRsZSkge1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LnJlbW92ZUNoaWxkKG9sZFRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIHRpdGxlLm5vZGUudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5hcHBlbmRDaGlsZCh0aXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2xkVGl0bGUgPSB0aXRsZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZU1pZFBvaW50KCkge1xuICAgIGNvbnN0IHNldE1pZFBvaW50ID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGQuaW5uZXJSYWRpdXMgKyAoZC5vdXRlclJhZGl1cyAtIGQuaW5uZXJSYWRpdXMpIC8gMjtcbiAgICAgIGQubWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IGQubWlkQ29zICogTWF0aC5tYXgoMCwgcmFkaXVzKSxcbiAgICAgICAgeTogZC5taWRTaW4gKiBNYXRoLm1heCgwLCByYWRpdXMpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub2RlRGF0YS5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YT8uZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZUdyb3VwU2VsZWN0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVJbm5lckNpcmNsZVNlbGVjdGlvbigpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUdyb3VwU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICBwaGFudG9tU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBsYWJlbFNlbGVjdGlvbixcbiAgICAgIGlubmVyTGFiZWxzU2VsZWN0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWROb2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKChkYXR1bSkgPT4gKHtcbiAgICAgIC4uLmRhdHVtLFxuICAgICAgLy8gQWxsb3cgbXV0YWJsZSBzZWN0b3JGb3JtYXQsIHNvIGZvcm1hdHRlZCBzZWN0b3Igc3R5bGVzIGNhbiBiZSB1cGRhdGVkIGFuZCB2YXJpZWRcbiAgICAgIC8vIGJldHdlZW4gbm9ybWFsIGFuZCBoaWdobGlnaHRlZCBjYXNlcy5cbiAgICAgIHNlY3RvckZvcm1hdDogeyAuLi5kYXR1bS5zZWN0b3JGb3JtYXQgfVxuICAgIH0pKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoc2VsZWN0aW9uLCBub2RlRGF0YSkgPT4ge1xuICAgICAgc2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSkpO1xuICAgICAgaWYgKHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZShpdGVtU2VsZWN0aW9uLCB0aGlzLm5vZGVEYXRhKTtcbiAgICB1cGRhdGUoaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICB1cGRhdGUocGhhbnRvbVNlbGVjdGlvbiwgdGhpcy5waGFudG9tTm9kZURhdGEgPz8gW10pO1xuICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5jYWxsb3V0Tm9kZURhdGEsIChncm91cCkgPT4ge1xuICAgICAgY29uc3QgbGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICBsaW5lLnRhZyA9IDAgLyogQ2FsbG91dCAqLztcbiAgICAgIGxpbmUucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgICB0ZXh0LnRhZyA9IDEgLyogTGFiZWwgKi87XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9KTtcbiAgICBsYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5ub2RlRGF0YSk7XG4gICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24udXBkYXRlKGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICAgIGlubmVyTGFiZWxzU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLnByb3BlcnRpZXMuaW5uZXJMYWJlbHMsIChub2RlKSA9PiB7XG4gICAgICBub2RlLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlSW5uZXJDaXJjbGVTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgeyBpbm5lckNpcmNsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGxldCByYWRpdXMgPSAwO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gdGhpcy5nZXRJbm5lclJhZGl1cygpO1xuICAgIGlmIChpbm5lclJhZGl1cyA+IDApIHtcbiAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IE1hdGgubWluKGlubmVyUmFkaXVzLCB0aGlzLmdldE91dGVyUmFkaXVzKCkpO1xuICAgICAgY29uc3QgYW50aUFsaWFzaW5nUGFkZGluZyA9IDE7XG4gICAgICByYWRpdXMgPSBNYXRoLmNlaWwoY2lyY2xlUmFkaXVzICogMiArIGFudGlBbGlhc2luZ1BhZGRpbmcpO1xuICAgIH1cbiAgICBjb25zdCBkYXR1bXMgPSBpbm5lckNpcmNsZSA/IFt7IHJhZGl1cyB9XSA6IFtdO1xuICAgIHRoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb24udXBkYXRlKGRhdHVtcyk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTm9kZXMoc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0dW0gPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmluZGV4T2YodHJ1ZSkgPj0gMDtcbiAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwudmlzaWJsZSA9IGlzVmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgfVxuICAgIHRoaXMuY29udGVudEdyb3VwLm9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLmVhY2goKG5vZGUsIHsgcmFkaXVzIH0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIGZpbGw6IHRoaXMucHJvcGVydGllcy5pbm5lckNpcmNsZT8uZmlsbCxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmlubmVyQ2lyY2xlPy5maWxsT3BhY2l0eSxcbiAgICAgICAgc2l6ZTogcmFkaXVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBhbmltYXRpb25EaXNhYmxlZCA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yRm4gPSAoc2VjdG9yLCBkYXR1bSwgX2luZGV4LCBpc0RhdHVtSGlnaGxpZ2h0ZWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLmRhdHVtLCBkYXR1bS5pdGVtSWQsIGlzRGF0dW1IaWdobGlnaHRlZCk7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICBpZiAoYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLnN0YXJ0QW5nbGUgPSBkYXR1bS5zdGFydEFuZ2xlO1xuICAgICAgICBzZWN0b3IuZW5kQW5nbGUgPSBkYXR1bS5lbmRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmlubmVyUmFkaXVzID0gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICAgIHNlY3Rvci5vdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGF0dW1IaWdobGlnaHRlZCB8fCBhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3IuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgICBzZWN0b3Iuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIH1cbiAgICAgIHNlY3Rvci5zdHJva2VXaWR0aCA9IGZvcm1hdC5zdHJva2VXaWR0aDtcbiAgICAgIHNlY3Rvci5maWxsT3BhY2l0eSA9IGZvcm1hdC5maWxsT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5zdHJva2VPcGFjaXR5ID0gZm9ybWF0LnN0cm9rZU9wYWNpdHk7XG4gICAgICBzZWN0b3IubGluZURhc2ggPSBmb3JtYXQubGluZURhc2g7XG4gICAgICBzZWN0b3IubGluZURhc2hPZmZzZXQgPSBmb3JtYXQubGluZURhc2hPZmZzZXQ7XG4gICAgICBzZWN0b3IuY29ybmVyUmFkaXVzID0gZm9ybWF0LmNvcm5lclJhZGl1cztcbiAgICAgIHNlY3Rvci5maWxsU2hhZG93ID0gdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdztcbiAgICAgIGNvbnN0IGluc2V0ID0gTWF0aC5tYXgoXG4gICAgICAgICh0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyArIChmb3JtYXQuc3Ryb2tlICE9IG51bGwgPyBmb3JtYXQuc3Ryb2tlV2lkdGggOiAwKSkgLyAyLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgc2VjdG9yLmluc2V0ID0gaW5zZXQ7XG4gICAgICBzZWN0b3IubGluZUpvaW4gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyA+PSAwIHx8IGluc2V0ID4gMCA/IFwibWl0ZXJcIiA6IFwicm91bmRcIjtcbiAgICB9O1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXR1bS5pdGVtSWQgPT09IGhpZ2hsaWdodGVkRGF0dW0/Lml0ZW1JZCkge1xuICAgICAgICBub2RlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExpbmVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCk7XG4gICAgdGhpcy51cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVJbm5lckxhYmVsTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVplcm9zdW1SaW5ncygpO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGluZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IGNhbGxvdXRTdHJva2VXaWR0aCA9IGNhbGxvdXRMaW5lLnN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IGNhbGxvdXRDb2xvcnMgPSBjYWxsb3V0TGluZS5jb2xvcnMgPz8gdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQgfSA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWw7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMCAvKiBDYWxsb3V0ICovKS5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGF0dW0gPSBsaW5lLmRhdHVtO1xuICAgICAgY29uc3QgeyBjYWxsb3V0TGFiZWw6IGxhYmVsLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICBpZiAobGFiZWw/LnRleHQgJiYgIWxhYmVsLmhpZGRlbiAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBsaW5lLnZpc2libGUgPSB0cnVlO1xuICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gY2FsbG91dFN0cm9rZVdpZHRoO1xuICAgICAgICBsaW5lLnN0cm9rZSA9IGNhbGxvdXRDb2xvcnNbaW5kZXggJSBjYWxsb3V0Q29sb3JzLmxlbmd0aF07XG4gICAgICAgIGxpbmUuZmlsbCA9IHZvaWQgMDtcbiAgICAgICAgY29uc3QgeDEgPSBkYXR1bS5taWRDb3MgKiBvdXRlclJhZGl1cztcbiAgICAgICAgY29uc3QgeTEgPSBkYXR1bS5taWRTaW4gKiBvdXRlclJhZGl1cztcbiAgICAgICAgbGV0IHgyID0gZGF0dW0ubWlkQ29zICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGxldCB5MiA9IGRhdHVtLm1pZFNpbiAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBjb25zdCBpc01vdmVkID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDA7XG4gICAgICAgIGlmIChpc01vdmVkICYmIGxhYmVsLmJveCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgYm94ID0gbGFiZWwuYm94O1xuICAgICAgICAgIGxldCBjeCA9IHgyO1xuICAgICAgICAgIGxldCBjeSA9IHkyO1xuICAgICAgICAgIGlmICh4MiA8IGJveC54KSB7XG4gICAgICAgICAgICBjeCA9IGJveC54O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeDIgPiBib3gueCArIGJveC53aWR0aCkge1xuICAgICAgICAgICAgY3ggPSBib3gueCArIGJveC53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkyIDwgYm94LnkpIHtcbiAgICAgICAgICAgIGN5ID0gYm94Lnk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5MiA+IGJveC55ICsgYm94LmhlaWdodCkge1xuICAgICAgICAgICAgY3kgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGR4ID0gY3ggLSB4MjtcbiAgICAgICAgICBjb25zdCBkeSA9IGN5IC0geTI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoMiA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuICAgICAgICAgIGNvbnN0IHBhZGRlZExlbmd0aCA9IGxlbmd0aDIgLSBvZmZzZXQ0O1xuICAgICAgICAgIGlmIChwYWRkZWRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB4MiA9IHgyICsgZHggKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgICAgeTIgPSB5MiArIGR5ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZS54MSA9IHgxO1xuICAgICAgICBsaW5lLnkxID0geTE7XG4gICAgICAgIGxpbmUueDIgPSB4MjtcbiAgICAgICAgbGluZS55MiA9IHkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TGFiZWxPdmVyZmxvdyh0ZXh0LCBib3gsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBzZXJpZXNMZWZ0ID0gc2VyaWVzUmVjdC54IC0gdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1JpZ2h0ID0gc2VyaWVzUmVjdC54ICsgc2VyaWVzUmVjdC53aWR0aCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgY29uc3Qgc2VyaWVzQm90dG9tID0gc2VyaWVzUmVjdC55ICsgc2VyaWVzUmVjdC5oZWlnaHQgLSB0aGlzLmNlbnRlclk7XG4gICAgY29uc3QgZXJyUHggPSAxO1xuICAgIGxldCB2aXNpYmxlVGV4dFBhcnQgPSAxO1xuICAgIGlmIChib3gueCArIGVyclB4IDwgc2VyaWVzTGVmdCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKGJveC54ICsgYm94LndpZHRoIC0gc2VyaWVzTGVmdCkgLyBib3gud2lkdGg7XG4gICAgfSBlbHNlIGlmIChib3gueCArIGJveC53aWR0aCAtIGVyclB4ID4gc2VyaWVzUmlnaHQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChzZXJpZXNSaWdodCAtIGJveC54KSAvIGJveC53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgaGFzVmVydGljYWxPdmVyZmxvdyA9IGJveC55ICsgZXJyUHggPCBzZXJpZXNUb3AgfHwgYm94LnkgKyBib3guaGVpZ2h0IC0gZXJyUHggPiBzZXJpZXNCb3R0b207XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHZpc2libGVUZXh0UGFydCA9PT0gMSA/IHRleHQubGVuZ3RoIDogTWF0aC5mbG9vcih0ZXh0Lmxlbmd0aCAqIHZpc2libGVUZXh0UGFydCkgLSAxO1xuICAgIGNvbnN0IGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgPSB0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94KTtcbiAgICByZXR1cm4geyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93LCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93IH07XG4gIH1cbiAgYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gsIGR4ID0gMCwgZHkgPSAwKSB7XG4gICAgY29uc3QgeyBzdXJyb3VuZGluZ1JhZGl1cyB9ID0gdGhpcztcbiAgICBpZiAoc3Vycm91bmRpbmdSYWRpdXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgeyB4OiBib3gueCArIGR4LCB5OiBib3gueSArIGR5IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoICsgZHgsIHk6IGJveC55ICsgZHkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGggKyBkeCwgeTogYm94LnkgKyBib3guaGVpZ2h0ICsgZHkgfSxcbiAgICAgIHsgeDogYm94LnggKyBkeCwgeTogYm94LnkgKyBib3guaGVpZ2h0ICsgZHkgfVxuICAgIF07XG4gICAgY29uc3Qgc3VyMiA9IHN1cnJvdW5kaW5nUmFkaXVzICoqIDI7XG4gICAgcmV0dXJuIGNvcm5lcnMuc29tZSgoY29ybmVyKSA9PiBjb3JuZXIueCAqKiAyICsgY29ybmVyLnkgKiogMiA+IHN1cjIpO1xuICB9XG4gIGNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICByZXR1cm4gIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgZnVsbERhdGEgPSB0aGlzLmNhbGxvdXROb2RlRGF0YTtcbiAgICBjb25zdCBkYXRhID0gZnVsbERhdGEuZmlsdGVyKCh0KSA9PiAhc2hvdWxkU2tpcCh0KSk7XG4gICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSB2b2lkIDA7XG4gICAgICBsYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gMDtcbiAgICB9KTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zIDwgMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgcmlnaHRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPj0gMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgdG9wTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luIDwgMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBib3R0b21MYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPj0gMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBnZXRUZXh0QkJveCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEJCb3guemVyby5jbG9uZSgpO1xuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMaW5lLmxlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbjtcbiAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcbiAgICAgIHJldHVybiBUZXh0LmNvbXB1dGVCQm94KGxhYmVsLnRleHQsIHgsIHksIHtcbiAgICAgICAgZm9udDogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uID0gKGxhYmVsLCBuZXh0LCBkaXJlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGdldFRleHRCQm94KGxhYmVsKS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IG90aGVyID0gZ2V0VGV4dEJCb3gobmV4dCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBjb2xsaWRlc09yQmVoaW5kID0gYm94LnggPCBvdGhlci54ICsgb3RoZXIud2lkdGggJiYgYm94LnggKyBib3gud2lkdGggPiBvdGhlci54ICYmIChkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSA8IG90aGVyLnkgKyBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgPiBvdGhlci55KTtcbiAgICAgIGlmIChjb2xsaWRlc09yQmVoaW5kKSB7XG4gICAgICAgIGNvbnN0IGR5ID0gZGlyZWN0aW9uID09PSBcInRvLXRvcFwiID8gYm94LnkgLSBvdGhlci55IC0gb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0IC0gb3RoZXIueTtcbiAgICAgICAgbmV4dC5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IGR5O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRZQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IG1pZExhYmVsID0gbGFiZWxzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYS5taWRTaW4pIC0gTWF0aC5hYnMoYi5taWRTaW4pKVswXTtcbiAgICAgIGNvbnN0IG1pZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWlkTGFiZWwpO1xuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpICsgMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLXRvcFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCArIDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpIC0gMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLWJvdHRvbVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWENvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlZID0gZGF0YS5zb21lKChkYXR1bSkgPT4gZGF0dW0uY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDApO1xuICAgICAgY29uc3QgYm94ZXMgPSBsYWJlbHMubWFwKChsYWJlbCkgPT4gZ2V0VGV4dEJCb3gobGFiZWwpKTtcbiAgICAgIGNvbnN0IHBhZGRlZEJveGVzID0gYm94ZXMubWFwKChib3gpID0+IGJveC5jbG9uZSgpLmdyb3cobWluU3BhY2luZyAvIDIpKTtcbiAgICAgIGxldCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZEJveGVzLmxlbmd0aCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHBhZGRlZEJveGVzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsYWJlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBvdGhlciA9IHBhZGRlZEJveGVzW2pdO1xuICAgICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KG90aGVyKSkge1xuICAgICAgICAgICAgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY3RvcnMgPSBmdWxsRGF0YS5tYXAoKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlU2VjdG9ycyA9IGJveGVzLnNvbWUoKGJveCkgPT4ge1xuICAgICAgICByZXR1cm4gc2VjdG9ycy5zb21lKChzZWN0b3IpID0+IGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSAmJiAhbGFiZWxzQ29sbGlkZVNlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFiZWxzLmZpbHRlcigoZCkgPT4gZC5jYWxsb3V0TGFiZWwudGV4dEFsaWduID09PSBcImNlbnRlclwiKS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZC5jYWxsb3V0TGFiZWw7XG4gICAgICAgIGlmIChkLm1pZENvcyA8IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZC5taWRDb3MgPiAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKGxlZnRMYWJlbHMpO1xuICAgIGF2b2lkWUNvbGxpc2lvbnMocmlnaHRMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnModG9wTGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKGJvdHRvbUxhYmVscyk7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgY29sb3IgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCB0ZW1wVGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDEgLyogTGFiZWwgKi8pLmZvckVhY2goKHRleHQpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRleHQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoZGF0dW0ucmFkaXVzKTtcbiAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoMCwgcmFkaXVzKTtcbiAgICAgIGlmICghbGFiZWw/LnRleHQgfHwgb3V0ZXJSYWRpdXMgPT09IDAgfHwgbGFiZWwuaGlkZGVuKSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgYWxpZ24gPSB7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH07XG4gICAgICB0ZW1wVGV4dE5vZGUudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZW1wVGV4dE5vZGUueCA9IHg7XG4gICAgICB0ZW1wVGV4dE5vZGUueSA9IHk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRBbGlnbihhbGlnbik7XG4gICAgICBjb25zdCBib3ggPSB0ZW1wVGV4dE5vZGUuZ2V0QkJveCgpO1xuICAgICAgbGV0IGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIGxldCB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KGxhYmVsLnRleHQsIGJveCwgc2VyaWVzUmVjdCk7XG4gICAgICAgIGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dC5sZW5ndGggPT09IHRleHRMZW5ndGggPyBsYWJlbC50ZXh0IDogYCR7bGFiZWwudGV4dC5zdWJzdHJpbmcoMCwgdGV4dExlbmd0aCl9XFx1MjAyNmA7XG4gICAgICAgIHZpc2libGUgPSAhaGFzVmVydGljYWxPdmVyZmxvdztcbiAgICAgIH1cbiAgICAgIHRleHQudGV4dCA9IGRpc3BsYXlUZXh0O1xuICAgICAgdGV4dC54ID0geDtcbiAgICAgIHRleHQueSA9IHk7XG4gICAgICB0ZXh0LnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0LnNldEFsaWduKGFsaWduKTtcbiAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgdGV4dC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjb21wdXRlTGFiZWxzQkJveChvcHRpb25zLCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWF4Q29sbGlzaW9uT2Zmc2V0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUoZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKTtcbiAgICBjb25zdCB0ZXh0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICBsZXQgdGl0bGVCb3g7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICh0aXRsZT8udGV4dCAmJiB0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIGlmIChpc0Zpbml0ZShkeSkpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gdGl0bGUudGV4dDtcbiAgICAgICAgdGV4dC54ID0gMDtcbiAgICAgICAgdGV4dC55ID0gZHk7XG4gICAgICAgIHRleHQuc2V0Rm9udCh0aXRsZSk7XG4gICAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJib3R0b21cIixcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRpdGxlQm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICAgIHRleHRCb3hlcy5wdXNoKHRpdGxlQm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jYWxsb3V0Tm9kZURhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKCFsYWJlbCB8fCBkYXR1bS5vdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGV4dC54ID0geDtcbiAgICAgIHRleHQueSA9IHk7XG4gICAgICB0ZXh0LnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0LnNldEFsaWduKHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgIGxhYmVsLmJveCA9IGJveDtcbiAgICAgIGlmIChNYXRoLmFicyhsYWJlbC5jb2xsaXNpb25PZmZzZXRZKSA+IG1heENvbGxpc2lvbk9mZnNldCkge1xuICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGl0bGVCb3gpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgICAgICBjb25zdCB0aXRsZUNsZWFuQXJlYSA9IG5ldyBCQm94KFxuICAgICAgICAgIHRpdGxlQm94LnggLSBtaW5TcGFjaW5nLFxuICAgICAgICAgIHNlcmllc1RvcCxcbiAgICAgICAgICB0aXRsZUJveC53aWR0aCArIDIgKiBtaW5TcGFjaW5nLFxuICAgICAgICAgIHRpdGxlQm94LnkgKyB0aXRsZUJveC5oZWlnaHQgKyBtaW5TcGFjaW5nIC0gc2VyaWVzVG9wXG4gICAgICAgICk7XG4gICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KHRpdGxlQ2xlYW5BcmVhKSkge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5oaWRlV2hlbk5lY2Vzc2FyeSkge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhcbiAgICAgICAgICBsYWJlbC50ZXh0LFxuICAgICAgICAgIGJveCxcbiAgICAgICAgICBzZXJpZXNSZWN0XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGlzVG9vU2hvcnQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA+IDIgJiYgdGV4dExlbmd0aCA8IDI7XG4gICAgICAgIGlmIChoYXNWZXJ0aWNhbE92ZXJmbG93IHx8IGlzVG9vU2hvcnQgfHwgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdykge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRleHRCb3hlcy5wdXNoKGJveCk7XG4gICAgfSk7XG4gICAgaWYgKHRleHRCb3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQkJveC5tZXJnZSh0ZXh0Qm94ZXMpO1xuICB9XG4gIHVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3QgeyBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBwb3NpdGlvbk9mZnNldCwgcG9zaXRpb25SYXRpbywgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbDtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JMYWJlbCA9ICh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgbGV0IGlzVGV4dFZpc2libGUgPSBmYWxzZTtcbiAgICAgIGlmIChzZWN0b3JMYWJlbCAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGlubmVyUmFkaXVzICogKDEgLSBwb3NpdGlvblJhdGlvKSArIG91dGVyUmFkaXVzICogcG9zaXRpb25SYXRpbyArIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0ID0gc2VjdG9yTGFiZWwudGV4dDtcbiAgICAgICAgdGV4dC54ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICAgIHRleHQueSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzO1xuICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgY29uc3QgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICAgIFtiYm94LngsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueSArIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICBbYmJveC54LCBiYm94LnkgKyBiYm94LmhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gZGF0dW07XG4gICAgICAgIGNvbnN0IHNlY3RvckJvdW5kcyA9IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgICBpZiAoY29ybmVycy5ldmVyeSgoW3gsIHldKSA9PiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yQm91bmRzKSkpIHtcbiAgICAgICAgICBpc1RleHRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dC52aXNpYmxlID0gaXNUZXh0VmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgfVxuICB1cGRhdGVJbm5lckxhYmVsTm9kZXMoKSB7XG4gICAgY29uc3QgdGV4dEJCb3hlcyA9IFtdO1xuICAgIGNvbnN0IG1hcmdpbnMgPSBbXTtcbiAgICB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGNvbG9yIH0gPSBkYXR1bTtcbiAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB0ZXh0LnRleHQgPSBkYXR1bS50ZXh0O1xuICAgICAgdGV4dC54ID0gMDtcbiAgICAgIHRleHQueSA9IDA7XG4gICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICB0ZXh0QkJveGVzLnB1c2godGV4dC5nZXRCQm94KCkpO1xuICAgICAgbWFyZ2lucy5wdXNoKGRhdHVtLnNwYWNpbmcpO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldE1hcmdpblRvcCA9IChpbmRleCkgPT4gaW5kZXggPT09IDAgPyAwIDogbWFyZ2luc1tpbmRleF07XG4gICAgY29uc3QgZ2V0TWFyZ2luQm90dG9tID0gKGluZGV4KSA9PiBpbmRleCA9PT0gbWFyZ2lucy5sZW5ndGggLSAxID8gMCA6IG1hcmdpbnNbaW5kZXhdO1xuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdGV4dEJCb3hlcy5yZWR1Y2UoKHN1bTIsIGJib3gsIGkpID0+IHtcbiAgICAgIHJldHVybiBzdW0yICsgYmJveC5oZWlnaHQgKyBnZXRNYXJnaW5Ub3AoaSkgKyBnZXRNYXJnaW5Cb3R0b20oaSk7XG4gICAgfSwgMCk7XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IE1hdGgubWF4KC4uLnRleHRCQm94ZXMubWFwKChiYm94KSA9PiBiYm94LndpZHRoKSk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLmdldElubmVyUmFkaXVzKCk7XG4gICAgY29uc3QgbGFiZWxSYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3codG90YWxXaWR0aCAvIDIsIDIpICsgTWF0aC5wb3codG90YWxIZWlnaHQgLyAyLCAyKSk7XG4gICAgY29uc3QgbGFiZWxzVmlzaWJsZSA9IGxhYmVsUmFkaXVzIDw9IChpbm5lclJhZGl1cyA+IDAgPyBpbm5lclJhZGl1cyA6IHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSk7XG4gICAgY29uc3QgdGV4dEJvdHRvbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgcHJldiA9IC10b3RhbEhlaWdodCAvIDI7IGkgPCB0ZXh0QkJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYm94ID0gdGV4dEJCb3hlc1tpXTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGJib3guaGVpZ2h0ICsgcHJldiArIGdldE1hcmdpblRvcChpKTtcbiAgICAgIHRleHRCb3R0b21zLnB1c2goYm90dG9tKTtcbiAgICAgIHByZXYgPSBib3R0b20gKyBnZXRNYXJnaW5Cb3R0b20oaSk7XG4gICAgfVxuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24uZWFjaCgodGV4dCwgX2RhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgdGV4dC55ID0gdGV4dEJvdHRvbXNbaW5kZXhdO1xuICAgICAgdGV4dC52aXNpYmxlID0gbGFiZWxzVmlzaWJsZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVaZXJvc3VtUmluZ3MoKSB7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnNpemUgPSB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIHRoaXMuemVyb3N1bUlubmVyUmluZy5zaXplID0gdGhpcy5nZXRJbm5lclJhZGl1cygpICogMjtcbiAgfVxuICBnZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIGNhbGxvdXRMYWJlbCwgbGVnZW5kSXRlbSB9ID0gbm9kZURhdHVtO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlZ2VuZEl0ZW0udGV4dDtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGNhbGxvdXRMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gY2FsbG91dExhYmVsLnRleHQ7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHNlY3RvckxhYmVsLnRleHQ7XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIHBpY2tCeU1hdGNoaW5nQW5nbGUodGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZVZhbHVlLFxuICAgICAgc2VjdG9yRm9ybWF0OiB7IGZpbGw6IGNvbG9yIH0sXG4gICAgICBpdGVtSWRcbiAgICB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHRoaXMucHJvcGVydGllcy50aXRsZT8udGV4dCk7XG4gICAgY29uc3QgY29udGVudCA9IGlzRmluaXRlTnVtYmVyKGFuZ2xlVmFsdWUpID8gdG9GaXhlZChhbmdsZVZhbHVlKSA6IFN0cmluZyhhbmdsZVZhbHVlKTtcbiAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pO1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAge1xuICAgICAgICB0aXRsZTogdGl0bGUgPz8gbGFiZWxUZXh0LFxuICAgICAgICBjb250ZW50OiB0aXRsZSAmJiBsYWJlbFRleHQgPyBgJHtsYWJlbFRleHR9OiAke2NvbnRlbnR9YCA6IGNvbnRlbnQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGFuZ2xlS2V5OiB0aGlzLnByb3BlcnRpZXMuYW5nbGVLZXksXG4gICAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgICByYWRpdXNOYW1lOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTmFtZSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGE/LmRhdGEubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFsZWdlbmRJdGVtS2V5ICYmICghY2FsbG91dExhYmVsS2V5IHx8IGNhbGxvdXRMYWJlbEtleSA9PT0gYW5nbGVLZXkpICYmICghc2VjdG9yTGFiZWxLZXkgfHwgc2VjdG9yTGFiZWxLZXkgPT09IGFuZ2xlS2V5KSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbElkeCwgc2VjdG9yTGFiZWxJZHgsIGxlZ2VuZEl0ZW1JZHggfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB0aXRsZVRleHQgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNob3dJbkxlZ2VuZCAmJiB0aGlzLnByb3BlcnRpZXMudGl0bGUudGV4dDtcbiAgICBjb25zdCBsZWdlbmREYXRhID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gcHJvY2Vzc2VkRGF0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnN0IGxhYmVsUGFydHMgPSBbXTtcbiAgICAgIGlmICh0aXRsZVRleHQpIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKHRpdGxlVGV4dCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscyhcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNhbGxvdXRMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW2NhbGxvdXRMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIHNlY3RvckxhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2VjdG9yTGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsYWJlbHMubGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMubGVnZW5kSXRlbS50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGxhYmVsUGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgbGVnZW5kRGF0YS5wdXNoKHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUgJiYgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGFiZWxQYXJ0cy5qb2luKFwiIC0gXCIpXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgZmlsbDogc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgICAgICAgICAgIHN0cm9rZTogc2VjdG9yRm9ybWF0LnN0cm9rZSxcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lOiBsZWdlbmRJdGVtS2V5ICE9IG51bGwgPyBkYXR1bVtsZWdlbmRJdGVtS2V5XSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmREYXRhO1xuICB9XG4gIG9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcywgbGVnZW5kSXRlbU5hbWUgfSA9IGV2ZW50O1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpO1xuICAgIH0gZWxzZSBpZiAobGVnZW5kSXRlbU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy50b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpIHtcbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2l0ZW1JZF0gPSBlbmFibGVkO1xuICAgIGlmICh0aGlzLm5vZGVEYXRhW2l0ZW1JZF0pIHtcbiAgICAgIHRoaXMubm9kZURhdGFbaXRlbUlkXS5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICB9XG4gIHRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5IHx8ICF0aGlzLmRhdGFNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5kYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApO1xuICAgIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGF0YS5mb3JFYWNoKCh7IHZhbHVlcyB9LCBkYXR1bUl0ZW1JZCkgPT4ge1xuICAgICAgaWYgKHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA9PT0gbGVnZW5kSXRlbU5hbWUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGRhdHVtSXRlbUlkLCBlbmFibGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICB0aGlzLnJhZGl1c1NjYWxlLFxuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLml0ZW1TZWxlY3Rpb24sIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLCB0aGlzLnBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJpbm5lclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHByb2Nlc3NlZERhdGEsIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZGF0YURpZmYgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmO1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBjb25zdCBzdXBwb3J0ZWREaWZmID0gKGRhdGFEaWZmPy5tb3ZlZC5zaXplID8/IDApID09PSAwO1xuICAgIGNvbnN0IGhhc0tleXMgPSAocHJvY2Vzc2VkRGF0YT8uZGVmcy5rZXlzLmxlbmd0aCA/PyAwKSA+IDA7XG4gICAgY29uc3QgaGFzVW5pcXVlS2V5cyA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMgPz8gdHJ1ZTtcbiAgICBpZiAoIXN1cHBvcnRlZERpZmYgfHwgIWhhc0tleXMgfHwgIWhhc1VuaXF1ZUtleXMpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIHByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2l0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSksXG4gICAgICBkYXRhRGlmZlxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIGBpbm5lckNpcmNsZWAsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uXSwgZm5zLmlubmVyQ2lyY2xlKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eSgpIHtcbiAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbiwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIHByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2l0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSlcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJpbm5lclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGdldERhdHVtSWRGcm9tRGF0YShkYXR1bSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bbGVnZW5kSXRlbUtleV07XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtjYWxsb3V0TGFiZWxLZXldO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtzZWN0b3JMYWJlbEtleV07XG4gICAgfVxuICB9XG4gIGdldERhdHVtSWQoZGF0dW0pIHtcbiAgICBjb25zdCB7IGluZGV4IH0gPSBkYXR1bTtcbiAgICBjb25zdCBkYXR1bUlkID0gdGhpcy5nZXREYXR1bUlkRnJvbURhdGEoZGF0dW0uZGF0dW0pO1xuICAgIHJldHVybiBkYXR1bUlkICE9IG51bGwgPyBTdHJpbmcoZGF0dW1JZCkgOiBgJHtpbmRleH1gO1xuICB9XG4gIG9uRGF0YUNoYW5nZSgpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNlcmllc0l0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBkYXRhPy5tYXAoKF8sIGluZGV4KSA9PiBzZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0gPz8gdHJ1ZSkgPz8gW107XG4gIH1cbn07XG5Eb251dFNlcmllcy5jbGFzc05hbWUgPSBcIkRvbnV0U2VyaWVzXCI7XG5Eb251dFNlcmllcy50eXBlID0gXCJkb251dFwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRUaGVtZS50c1xudmFyIGRvbnV0VGhlbWUgPSB7XG4gIHNlcmllczoge1xuICAgIHRpdGxlOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTQsXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLFxuICAgICAgc3BhY2luZzogNVxuICAgIH0sXG4gICAgY2FsbG91dExhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgIG9mZnNldDogMyxcbiAgICAgIG1pbkFuZ2xlOiAwXG4gICAgfSxcbiAgICBzZWN0b3JMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxuICAgICAgcG9zaXRpb25PZmZzZXQ6IDAsXG4gICAgICBwb3NpdGlvblJhdGlvOiAwLjVcbiAgICB9LFxuICAgIGNhbGxvdXRMaW5lOiB7XG4gICAgICBsZW5ndGg6IDEwLFxuICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICB9LFxuICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgbGluZURhc2g6IFswXSxcbiAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzZWN0b3JTcGFjaW5nOiAxLFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgeE9mZnNldDogMyxcbiAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICBibHVyOiA1XG4gICAgfSxcbiAgICBpbm5lckxhYmVsczoge1xuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgIHNwYWNpbmc6IDJcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVUaGVtZS50c1xudmFyIHBpZVRoZW1lID0ge1xuICBzZXJpZXM6IHtcbiAgICB0aXRsZToge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgICAgIHNwYWNpbmc6IDVcbiAgICB9LFxuICAgIGNhbGxvdXRMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICBvZmZzZXQ6IDMsXG4gICAgICBtaW5BbmdsZTogMFxuICAgIH0sXG4gICAgc2VjdG9yTGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgICAgIHBvc2l0aW9uT2Zmc2V0OiAwLFxuICAgICAgcG9zaXRpb25SYXRpbzogMC41XG4gICAgfSxcbiAgICBjYWxsb3V0TGluZToge1xuICAgICAgbGVuZ3RoOiAxMCxcbiAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgfSxcbiAgICBmaWxsT3BhY2l0eTogMSxcbiAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgc2VjdG9yU3BhY2luZzogMSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICB5T2Zmc2V0OiAzLFxuICAgICAgYmx1cjogNVxuICAgIH1cbiAgfVxufTtcbnZhciBwaWVQYWxldHRlRmFjdG9yeSA9ICh7IHRha2VDb2xvcnMsIGNvbG9yc0NvdW50IH0pID0+IHtcbiAgY29uc3QgeyBmaWxscywgc3Ryb2tlcyB9ID0gdGFrZUNvbG9ycyhjb2xvcnNDb3VudCk7XG4gIHJldHVybiB7IGZpbGxzLCBzdHJva2VzLCBjYWxsb3V0TGluZTogeyBjb2xvcnM6IHN0cm9rZXMgfSB9O1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0U2VyaWVzTW9kdWxlLnRzXG52YXIgRG9udXRTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLFxuICBpZGVudGlmaWVyOiBcImRvbnV0XCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBEb251dFNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICB0aGVtZVRlbXBsYXRlOiBkb251dFRoZW1lLFxuICBwYWxldHRlRmFjdG9yeTogcGllUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgUGllVGl0bGUgPSBjbGFzcyBleHRlbmRzIENhcHRpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hvd0luTGVnZW5kID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgUGllVGl0bGUucHJvdG90eXBlLCBcInNob3dJbkxlZ2VuZFwiLCAyKTtcbnZhciBQaWVTZXJpZXNDYWxsb3V0TGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm9mZnNldCA9IDM7XG4gICAgdGhpcy5taW5BbmdsZSA9IDA7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gNDtcbiAgICB0aGlzLm1heENvbGxpc2lvbk9mZnNldCA9IDUwO1xuICAgIHRoaXMuYXZvaWRDb2xsaXNpb25zID0gdHJ1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5BbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWF4Q29sbGlzaW9uT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xudmFyIFBpZVNlcmllc1NlY3RvckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgdGhpcy5wb3NpdGlvblJhdGlvID0gMC41O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25SYXRpb1wiLCAyKTtcbnZhciBQaWVTZXJpZXNDYWxsb3V0TGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGVuZ3RoID0gMTA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xudmFyIFBpZVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xuICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXNPZmZzZXQgPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXNSYXRpbyA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zZWN0b3JTcGFjaW5nID0gMDtcbiAgICB0aGlzLnRpdGxlID0gbmV3IFBpZVRpdGxlKCk7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsID0gbmV3IFBpZVNlcmllc0NhbGxvdXRMYWJlbCgpO1xuICAgIHRoaXMuc2VjdG9yTGFiZWwgPSBuZXcgUGllU2VyaWVzU2VjdG9yTGFiZWwoKTtcbiAgICB0aGlzLmNhbGxvdXRMaW5lID0gbmV3IFBpZVNlcmllc0NhbGxvdXRMaW5lKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlRmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c05hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWF4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1LZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c09mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVTZXJpZXMudHNcbnZhciBQaWVTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIFNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMuYW5nbGVLZXkgPSBzZXJpZXMucHJvcGVydGllcy5hbmdsZUtleTtcbiAgICB0aGlzLnJhZGl1c0tleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnJhZGl1c0tleTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleTtcbiAgICB0aGlzLnNlY3RvckxhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXk7XG4gIH1cbn07XG52YXIgUGllU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBQb2xhclNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIHBpY2tNb2RlczogWzMgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIHVzZUxhYmVsTGF5ZXI6IHRydWUsXG4gICAgICBhbmltYXRpb25SZXNldEZuczogeyBpdGVtOiByZXNldFBpZVNlbGVjdGlvbnNGbiwgbGFiZWw6IHJlc2V0TGFiZWxGbiB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFBpZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5waGFudG9tR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoKSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMucGhhbnRvbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcInBpZUNhbGxvdXRMYWJlbHNcIiB9KSk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKFxuICAgICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCxcbiAgICAgIEdyb3VwXG4gICAgKTtcbiAgICAvLyBUaGUgZ3JvdXAgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBiYWNrZ3JvdW5kIGdyYXBoaWNzLlxuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwID0gdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1iYWNrZ3JvdW5kYCxcbiAgICAgICAgbGF5ZXI6IHRydWUsXG4gICAgICAgIHpJbmRleDogMCAvKiBTRVJJRVNfQkFDS0dST1VORF9aSU5ERVggKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICAvLyBBRy02MTkzIElmIHRoZSBzdW0gb2YgYWxsIGRhdHVtcyBpcyAwLCB0aGVuIHdlJ2xsIGRyYXcgMSBvciAyIHJpbmdzIHRvIHJlcHJlc2VudCB0aGUgZW1wdHkgc2VyaWVzLlxuICAgIHRoaXMuemVyb3N1bVJpbmdzR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS16ZXJvc3VtUmluZ3NgIH0pKTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBDaXJjbGUoKSk7XG4gICAgLy8gV2hlbiBhIHVzZXIgdG9nZ2xlcyBhIHNlcmllcyBpdGVtIChlLmcuIGZyb20gdGhlIGxlZ2VuZCksIGl0cyBib29sZWFuIHN0YXRlIGlzIHJlY29yZGVkIGhlcmUuXG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IFtdO1xuICAgIHRoaXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBQaWVTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5hbmdsZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5hbmdsZVNjYWxlLmRvbWFpbiA9IFswLCAxXTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUucmFuZ2UgPSBbLU1hdGguUEksIE1hdGguUEldLm1hcCgoYW5nbGUyKSA9PiBhbmdsZTIgKyBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy5waGFudG9tR3JvdXAub3BhY2l0eSA9IDAuMjtcbiAgICB0aGlzLnBoYW50b21Hcm91cC56SW5kZXhTdWJPcmRlciA9IFsoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyLCAwXTtcbiAgfVxuICBnZXQgY2FsbG91dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyB0aGlzLm5vZGVEYXRhO1xuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlcj8uYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKVxuICAgICk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpc2libGUgJiYgKHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQubGVuZ3RoID09PSAwIHx8IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuc29tZSgodmlzaWJsZSkgPT4gdmlzaWJsZSkpO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIGNvbnN0IHNlY3RvciA9IG5ldyBTZWN0b3IoKTtcbiAgICBzZWN0b3IubWl0ZXJMaW1pdCA9IDFlOTtcbiAgICByZXR1cm4gc2VjdG9yO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZVNjYWxlLmRvbWFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmFkaXVzU2NhbGUuZG9tYWluO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgYW5nbGVGaWx0ZXJLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCBleHRyYUtleVByb3BzID0gW107XG4gICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsS2V5YCB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1c1NjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBjb25zdCBhbmdsZVNjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBpZiAocmFkaXVzS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIHJhbmdlZFZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCB7XG4gICAgICAgICAgaWQ6IFwicmFkaXVzVmFsdWVcIixcbiAgICAgICAgICBtaW46IHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCxcbiAgICAgICAgICBtYXg6IHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXhcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCByYWRpdXNTY2FsZVR5cGUsIHsgaWQ6IGByYWRpdXNSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwicmFkaXVzVmFsdWVcIiwgWzAsIDFdLCAxLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXgpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1WYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoYW5nbGVGaWx0ZXJLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYGFuZ2xlRmlsdGVyVmFsdWVgLFxuICAgICAgICAgIG9ubHlQb3NpdGl2ZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZUZpbHRlclJhd2AgfSksXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZUZpbHRlclZhbHVlXCIsIFswLCAxXSwgMCwgMClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyAmJiBleHRyYUtleVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICBkYXRhID0gZGF0YS5tYXAoKGQsIGlkeCkgPT4gdmlzaWJsZSAmJiBzZXJpZXNJdGVtRW5hYmxlZFtpZHhdID8gZCA6IHsgLi4uZCwgW2FuZ2xlS2V5XTogMCB9KTtcbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIC4uLmV4dHJhS2V5UHJvcHMsXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVWYWx1ZWAsIG9ubHlQb3NpdGl2ZTogdHJ1ZSB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVJhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZVZhbHVlXCIsIFswLCAxXSwgMCwgMCksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlRGVmIG9mIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGVmcz8udmFsdWVzID8/IFtdKSB7XG4gICAgICBjb25zdCB7IGlkLCBtaXNzaW5nLCBwcm9wZXJ0eSB9ID0gdmFsdWVEZWY7XG4gICAgICBjb25zdCBtaXNzQ291bnQgPSBnZXRNaXNzQ291bnQodGhpcywgbWlzc2luZyk7XG4gICAgICBpZiAoaWQgIT09IFwiYW5nbGVSYXdcIiAmJiBtaXNzQ291bnQgPiAwKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgbm8gdmFsdWUgd2FzIGZvdW5kIGZvciB0aGUga2V5ICcke1N0cmluZyhwcm9wZXJ0eSl9JyBvbiAke21pc3NDb3VudH0gZGF0YSBlbGVtZW50JHttaXNzQ291bnQgPiAxID8gXCJzXCIgOiBcIlwifWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBhc3luYyBtYXliZVJlZnJlc2hOb2RlRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZURhdGEgPSBbXSwgcGhhbnRvbU5vZGVEYXRhIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCkgPz8ge307XG4gICAgdGhpcy5ub2RlRGF0YSA9IG5vZGVEYXRhO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gcGhhbnRvbU5vZGVEYXRhO1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gIH1cbiAgZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKSB7XG4gICAgY29uc3QgYW5nbGVJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlVmFsdWVgKTtcbiAgICBjb25zdCBhbmdsZVJhd0lkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVSYXdgKTtcbiAgICBjb25zdCBhbmdsZUZpbHRlcklkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c1Jhd0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1Jhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNhbGxvdXRMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNlY3RvckxhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH07XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYW5nbGVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS50eXBlICE9PSBcInVuZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB1c2VGaWx0ZXJBbmdsZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmIHByb2Nlc3NlZERhdGEuZGF0YS5zb21lKCh7IHZhbHVlcyB9KSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSA+IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgfSk7XG4gICAgbGV0IGN1cnJlbnRTdGFydCA9IDA7XG4gICAgbGV0IHN1bTIgPSAwO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcGhhbnRvbU5vZGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCA/IFtdIDogdm9pZCAwO1xuICAgIHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKChncm91cCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gZ3JvdXA7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB1c2VGaWx0ZXJBbmdsZXMgPyB2YWx1ZXNbYW5nbGVGaWx0ZXJJZHhdIDogdmFsdWVzW2FuZ2xlSWR4XTtcbiAgICAgIGNvbnN0IGNyb3NzRmlsdGVyU2NhbGUgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmICF1c2VGaWx0ZXJBbmdsZXMgPyBNYXRoLnNxcnQodmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSAvIHZhbHVlc1thbmdsZVJhd0lkeF0pIDogMTtcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjdXJyZW50U3RhcnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzdW0yICs9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIGNvbnN0IGVuZEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY29uc3Qgc3BhbiA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzcGFuIC8gMjtcbiAgICAgIGNvbnN0IGFuZ2xlVmFsdWUgPSB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgICAgY29uc3QgcmFkaXVzUmF3ID0gcmFkaXVzSWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzSWR4XSA/PyAxIDogMTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1JhdyAqIGNyb3NzRmlsdGVyU2NhbGU7XG4gICAgICBjb25zdCByYWRpdXNWYWx1ZSA9IHJhZGl1c1Jhd0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c1Jhd0lkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBsZWdlbmRJdGVtVmFsdWUgPSBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBub2RlTGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgc3BhbixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBtaWRDb3M6IE1hdGguY29zKG1pZEFuZ2xlKSxcbiAgICAgICAgbWlkU2luOiBNYXRoLnNpbihtaWRBbmdsZSksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICByYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KHJhZGl1cyksIDApLFxuICAgICAgICBzZWN0b3JGb3JtYXQsXG4gICAgICAgIHJhZGl1c1ZhbHVlLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWUsXG4gICAgICAgIGVuYWJsZWQ6IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICAuLi5ub2RlTGFiZWxzXG4gICAgICB9O1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIGlmIChwaGFudG9tTm9kZXMgIT0gbnVsbCkge1xuICAgICAgICBwaGFudG9tTm9kZXMucHVzaCh7XG4gICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICByYWRpdXM6IDEsXG4gICAgICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgxKSwgMClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnZpc2libGUgPSBzdW0yID09PSAwO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHNlcmllc0lkLFxuICAgICAgbm9kZURhdGE6IG5vZGVzLFxuICAgICAgbGFiZWxEYXRhOiBub2RlcyxcbiAgICAgIHBoYW50b21Ob2RlRGF0YTogcGhhbnRvbU5vZGVzXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbHMoZGF0dW0sIG1pZEFuZ2xlLCBzcGFuLCBza2lwRGlzYWJsZWQsIGNhbGxvdXRMYWJlbFZhbHVlLCBzZWN0b3JMYWJlbFZhbHVlLCBsZWdlbmRJdGVtVmFsdWUpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgc2VjdG9yTGFiZWwsIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IGNhbGxvdXRMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZWN0b3JMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgc2VjdG9yTGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSA6IHZvaWQgMDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbEtleSAmJiAhc2VjdG9yTGFiZWxLZXkgJiYgIWxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxGb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlS2V5OiB0aGlzLnByb3BlcnRpZXMuYW5nbGVLZXksXG4gICAgICBhbmdsZU5hbWU6IHRoaXMucHJvcGVydGllcy5hbmdsZU5hbWUsXG4gICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICByYWRpdXNOYW1lOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTmFtZSxcbiAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSxcbiAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSxcbiAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsTmFtZSxcbiAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoY2FsbG91dExhYmVsS2V5ICYmIHNwYW4gPiB0b1JhZGlhbnMoY2FsbG91dExhYmVsLm1pbkFuZ2xlKSkge1xuICAgICAgcmVzdWx0LmNhbGxvdXRMYWJlbCA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSxcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoY2FsbG91dExhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IGNhbGxvdXRMYWJlbFZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBjb2xsaXNpb25UZXh0QWxpZ246IHZvaWQgMCxcbiAgICAgICAgY29sbGlzaW9uT2Zmc2V0WTogMCxcbiAgICAgICAgYm94OiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmVzdWx0LnNlY3RvckxhYmVsID0ge1xuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChzZWN0b3JMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBzZWN0b3JMYWJlbFZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1WYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQubGVnZW5kSXRlbSA9IHsga2V5OiBsZWdlbmRJdGVtS2V5LCB0ZXh0OiBsZWdlbmRJdGVtVmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSB7XG4gICAgY29uc3QgcXVhZHJhbnRUZXh0T3B0cyA9IFtcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImxlZnRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwicmlnaHRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH1cbiAgICBdO1xuICAgIGNvbnN0IG1pZEFuZ2xlMTgwID0gbm9ybWFsaXplQW5nbGUxODAobWlkQW5nbGUpO1xuICAgIGNvbnN0IHF1YWRyYW50U3RhcnQgPSAtMC43NSAqIE1hdGguUEk7XG4gICAgY29uc3QgcXVhZHJhbnRPZmZzZXQgPSBtaWRBbmdsZTE4MCAtIHF1YWRyYW50U3RhcnQ7XG4gICAgY29uc3QgcXVhZHJhbnQgPSBNYXRoLmZsb29yKHF1YWRyYW50T2Zmc2V0IC8gKE1hdGguUEkgLyAyKSk7XG4gICAgY29uc3QgcXVhZHJhbnRJbmRleCA9IG1vZChxdWFkcmFudCwgcXVhZHJhbnRUZXh0T3B0cy5sZW5ndGgpO1xuICAgIHJldHVybiBxdWFkcmFudFRleHRPcHRzW3F1YWRyYW50SW5kZXhdO1xuICB9XG4gIGdldFNlY3RvckZvcm1hdChkYXR1bSwgZm9ybWF0SW5kZXgsIGhpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja0NhY2hlIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXksIGZpbGxzLCBzdHJva2VzLCBpdGVtU3R5bGVyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgZGVmYXVsdFN0cm9rZSA9IHN0cm9rZXNbZm9ybWF0SW5kZXggJSBzdHJva2VzLmxlbmd0aF07XG4gICAgY29uc3QgeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBjb3JuZXJSYWRpdXMgfSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICBoaWdobGlnaHRlZCAmJiB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSxcbiAgICAgIHtcbiAgICAgICAgZmlsbDogZmlsbHMubGVuZ3RoID4gMCA/IGZpbGxzW2Zvcm1hdEluZGV4ICUgZmlsbHMubGVuZ3RoXSA6IHZvaWQgMCxcbiAgICAgICAgc3Ryb2tlOiBkZWZhdWx0U3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKVxuICAgICAgfSxcbiAgICAgIHRoaXMucHJvcGVydGllc1xuICAgICk7XG4gICAgbGV0IGZvcm1hdDtcbiAgICBpZiAoaXRlbVN0eWxlcikge1xuICAgICAgZm9ybWF0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGl0ZW1TdHlsZXIsIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGFuZ2xlS2V5LFxuICAgICAgICByYWRpdXNLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXksXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICBsaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgaGlnaGxpZ2h0ZWQsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGw6IGZvcm1hdD8uZmlsbCA/PyBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IGZvcm1hdD8uZmlsbE9wYWNpdHkgPz8gZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IGZvcm1hdD8uc3Ryb2tlID8/IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBmb3JtYXQ/LnN0cm9rZVdpZHRoID8/IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBmb3JtYXQ/LmxpbmVEYXNoT2Zmc2V0ID8/IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXNcbiAgICB9O1xuICB9XG4gIGdldE91dGVyUmFkaXVzKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJhZGl1cyAqIHRoaXMucHJvcGVydGllcy5vdXRlclJhZGl1c1JhdGlvICsgdGhpcy5wcm9wZXJ0aWVzLm91dGVyUmFkaXVzT2Zmc2V0LCAwKTtcbiAgfVxuICB1cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpIHtcbiAgICBjb25zdCBuZXdSYW5nZSA9IFswLCB0aGlzLmdldE91dGVyUmFkaXVzKCldO1xuICAgIHRoaXMucmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgc2V0UmFkaWkgPSAoZCkgPT4gKHtcbiAgICAgIC4uLmQsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoZC5yYWRpdXMpLCAwKVxuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcChzZXRSYWRpaSk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB0aGlzLnBoYW50b21Ob2RlRGF0YT8ubWFwKHNldFJhZGlpKTtcbiAgfVxuICBnZXRUaXRsZVRyYW5zbGF0aW9uWSgpIHtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMucmFkaXVzU2NhbGUucmFuZ2VbMV0pO1xuICAgIGlmIChvdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc3BhY2luZyA/PyAwO1xuICAgIGNvbnN0IHRpdGxlT2Zmc2V0ID0gMiArIHNwYWNpbmc7XG4gICAgY29uc3QgZHkgPSBNYXRoLm1heCgwLCAtb3V0ZXJSYWRpdXMpO1xuICAgIHJldHVybiAtb3V0ZXJSYWRpdXMgLSB0aXRsZU9mZnNldCAtIGR5O1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IHtcbiAgICAgIHNlcmllc1JlY3RXaWR0aDogc2VyaWVzUmVjdD8ud2lkdGgsXG4gICAgICBzZXJpZXNSZWN0SGVpZ2h0OiBzZXJpZXNSZWN0Py5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSk7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIH1cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZS5ub2RlLmdldEJCb3goKTtcbiAgICAgIHRpdGxlLm5vZGUudmlzaWJsZSA9IHRpdGxlLmVuYWJsZWQgJiYgaXNGaW5pdGUoZHkpICYmICF0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXModGl0bGVCb3gsIDAsIGR5KTtcbiAgICAgIHRpdGxlLm5vZGUudHJhbnNsYXRpb25ZID0gaXNGaW5pdGUoZHkpID8gZHkgOiAwO1xuICAgIH1cbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuZmlsbE9wYWNpdHkgPSAwO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2UgPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLmNvbG9yO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMudXBkYXRlTm9kZU1pZFBvaW50KCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVOb2RlcyhzZXJpZXNSZWN0KTtcbiAgfVxuICB1cGRhdGVUaXRsZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgb2xkVGl0bGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRUaXRsZSAhPT0gdGl0bGUpIHtcbiAgICAgIGlmIChvbGRUaXRsZSkge1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LnJlbW92ZUNoaWxkKG9sZFRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIHRpdGxlLm5vZGUudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5hcHBlbmRDaGlsZCh0aXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2xkVGl0bGUgPSB0aXRsZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZU1pZFBvaW50KCkge1xuICAgIGNvbnN0IHNldE1pZFBvaW50ID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGQuaW5uZXJSYWRpdXMgKyAoZC5vdXRlclJhZGl1cyAtIGQuaW5uZXJSYWRpdXMpIC8gMjtcbiAgICAgIGQubWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IGQubWlkQ29zICogTWF0aC5tYXgoMCwgcmFkaXVzKSxcbiAgICAgICAgeTogZC5taWRTaW4gKiBNYXRoLm1heCgwLCByYWRpdXMpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub2RlRGF0YS5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YT8uZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZUdyb3VwU2VsZWN0aW9uKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlR3JvdXBTZWxlY3Rpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXRlbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgIHBoYW50b21TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGxhYmVsU2VsZWN0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWROb2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKChkYXR1bSkgPT4gKHtcbiAgICAgIC4uLmRhdHVtLFxuICAgICAgLy8gQWxsb3cgbXV0YWJsZSBzZWN0b3JGb3JtYXQsIHNvIGZvcm1hdHRlZCBzZWN0b3Igc3R5bGVzIGNhbiBiZSB1cGRhdGVkIGFuZCB2YXJpZWRcbiAgICAgIC8vIGJldHdlZW4gbm9ybWFsIGFuZCBoaWdobGlnaHRlZCBjYXNlcy5cbiAgICAgIHNlY3RvckZvcm1hdDogeyAuLi5kYXR1bS5zZWN0b3JGb3JtYXQgfVxuICAgIH0pKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoc2VsZWN0aW9uLCBub2RlRGF0YSkgPT4ge1xuICAgICAgc2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSkpO1xuICAgICAgaWYgKHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZShpdGVtU2VsZWN0aW9uLCB0aGlzLm5vZGVEYXRhKTtcbiAgICB1cGRhdGUoaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICB1cGRhdGUocGhhbnRvbVNlbGVjdGlvbiwgdGhpcy5waGFudG9tTm9kZURhdGEgPz8gW10pO1xuICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5jYWxsb3V0Tm9kZURhdGEsIChncm91cCkgPT4ge1xuICAgICAgY29uc3QgbGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICBsaW5lLnRhZyA9IDAgLyogQ2FsbG91dCAqLztcbiAgICAgIGxpbmUucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgICB0ZXh0LnRhZyA9IDEgLyogTGFiZWwgKi87XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9KTtcbiAgICBsYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5ub2RlRGF0YSk7XG4gICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24udXBkYXRlKGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5pbmRleE9mKHRydWUpID49IDA7XG4gICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlICYmIGhpZ2hsaWdodGVkRGF0dW0/LnNlcmllcyA9PT0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRHcm91cC5vcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGlzYWJsZWQgPSB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckZuID0gKHNlY3RvciwgZGF0dW0sIF9pbmRleCwgaXNEYXR1bUhpZ2hsaWdodGVkKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bS5kYXR1bSwgZGF0dW0uaXRlbUlkLCBpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgaWYgKGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5zdGFydEFuZ2xlID0gZGF0dW0uc3RhcnRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmVuZEFuZ2xlID0gZGF0dW0uZW5kQW5nbGU7XG4gICAgICAgIHNlY3Rvci5pbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgICBzZWN0b3Iub3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICAgIH1cbiAgICAgIGlmIChpc0RhdHVtSGlnaGxpZ2h0ZWQgfHwgYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgICAgc2VjdG9yLnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICB9XG4gICAgICBzZWN0b3Iuc3Ryb2tlV2lkdGggPSBmb3JtYXQuc3Ryb2tlV2lkdGg7XG4gICAgICBzZWN0b3IuZmlsbE9wYWNpdHkgPSBmb3JtYXQuZmlsbE9wYWNpdHk7XG4gICAgICBzZWN0b3Iuc3Ryb2tlT3BhY2l0eSA9IGZvcm1hdC5zdHJva2VPcGFjaXR5O1xuICAgICAgc2VjdG9yLmxpbmVEYXNoID0gZm9ybWF0LmxpbmVEYXNoO1xuICAgICAgc2VjdG9yLmxpbmVEYXNoT2Zmc2V0ID0gZm9ybWF0LmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgc2VjdG9yLmNvcm5lclJhZGl1cyA9IGZvcm1hdC5jb3JuZXJSYWRpdXM7XG4gICAgICBzZWN0b3IuZmlsbFNoYWRvdyA9IHRoaXMucHJvcGVydGllcy5zaGFkb3c7XG4gICAgICBjb25zdCBpbnNldCA9IE1hdGgubWF4KFxuICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgKyAoZm9ybWF0LnN0cm9rZSAhPSBudWxsID8gZm9ybWF0LnN0cm9rZVdpZHRoIDogMCkpIC8gMixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIHNlY3Rvci5pbnNldCA9IGluc2V0O1xuICAgICAgc2VjdG9yLmxpbmVKb2luID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgPj0gMCB8fCBpbnNldCA+IDAgPyBcIm1pdGVyXCIgOiBcInJvdW5kXCI7XG4gICAgfTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIHRydWUpO1xuICAgICAgaWYgKGRhdHVtLml0ZW1JZCA9PT0gaGlnaGxpZ2h0ZWREYXR1bT8uaXRlbUlkKSB7XG4gICAgICAgIG5vZGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGluZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KTtcbiAgICB0aGlzLnVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVplcm9zdW1SaW5ncygpO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGluZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IGNhbGxvdXRTdHJva2VXaWR0aCA9IGNhbGxvdXRMaW5lLnN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IGNhbGxvdXRDb2xvcnMgPSBjYWxsb3V0TGluZS5jb2xvcnMgPz8gdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQgfSA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWw7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMCAvKiBDYWxsb3V0ICovKS5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGF0dW0gPSBsaW5lLmRhdHVtO1xuICAgICAgY29uc3QgeyBjYWxsb3V0TGFiZWw6IGxhYmVsLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICBpZiAobGFiZWw/LnRleHQgJiYgIWxhYmVsLmhpZGRlbiAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBsaW5lLnZpc2libGUgPSB0cnVlO1xuICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gY2FsbG91dFN0cm9rZVdpZHRoO1xuICAgICAgICBsaW5lLnN0cm9rZSA9IGNhbGxvdXRDb2xvcnNbaW5kZXggJSBjYWxsb3V0Q29sb3JzLmxlbmd0aF07XG4gICAgICAgIGxpbmUuZmlsbCA9IHZvaWQgMDtcbiAgICAgICAgY29uc3QgeDEgPSBkYXR1bS5taWRDb3MgKiBvdXRlclJhZGl1cztcbiAgICAgICAgY29uc3QgeTEgPSBkYXR1bS5taWRTaW4gKiBvdXRlclJhZGl1cztcbiAgICAgICAgbGV0IHgyID0gZGF0dW0ubWlkQ29zICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGxldCB5MiA9IGRhdHVtLm1pZFNpbiAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBjb25zdCBpc01vdmVkID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDA7XG4gICAgICAgIGlmIChpc01vdmVkICYmIGxhYmVsLmJveCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgYm94ID0gbGFiZWwuYm94O1xuICAgICAgICAgIGxldCBjeCA9IHgyO1xuICAgICAgICAgIGxldCBjeSA9IHkyO1xuICAgICAgICAgIGlmICh4MiA8IGJveC54KSB7XG4gICAgICAgICAgICBjeCA9IGJveC54O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeDIgPiBib3gueCArIGJveC53aWR0aCkge1xuICAgICAgICAgICAgY3ggPSBib3gueCArIGJveC53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkyIDwgYm94LnkpIHtcbiAgICAgICAgICAgIGN5ID0gYm94Lnk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5MiA+IGJveC55ICsgYm94LmhlaWdodCkge1xuICAgICAgICAgICAgY3kgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGR4ID0gY3ggLSB4MjtcbiAgICAgICAgICBjb25zdCBkeSA9IGN5IC0geTI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoMiA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuICAgICAgICAgIGNvbnN0IHBhZGRlZExlbmd0aCA9IGxlbmd0aDIgLSBvZmZzZXQ0O1xuICAgICAgICAgIGlmIChwYWRkZWRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB4MiA9IHgyICsgZHggKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgICAgeTIgPSB5MiArIGR5ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZS54MSA9IHgxO1xuICAgICAgICBsaW5lLnkxID0geTE7XG4gICAgICAgIGxpbmUueDIgPSB4MjtcbiAgICAgICAgbGluZS55MiA9IHkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TGFiZWxPdmVyZmxvdyh0ZXh0LCBib3gsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBzZXJpZXNMZWZ0ID0gc2VyaWVzUmVjdC54IC0gdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1JpZ2h0ID0gc2VyaWVzUmVjdC54ICsgc2VyaWVzUmVjdC53aWR0aCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgY29uc3Qgc2VyaWVzQm90dG9tID0gc2VyaWVzUmVjdC55ICsgc2VyaWVzUmVjdC5oZWlnaHQgLSB0aGlzLmNlbnRlclk7XG4gICAgY29uc3QgZXJyUHggPSAxO1xuICAgIGxldCB2aXNpYmxlVGV4dFBhcnQgPSAxO1xuICAgIGlmIChib3gueCArIGVyclB4IDwgc2VyaWVzTGVmdCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKGJveC54ICsgYm94LndpZHRoIC0gc2VyaWVzTGVmdCkgLyBib3gud2lkdGg7XG4gICAgfSBlbHNlIGlmIChib3gueCArIGJveC53aWR0aCAtIGVyclB4ID4gc2VyaWVzUmlnaHQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChzZXJpZXNSaWdodCAtIGJveC54KSAvIGJveC53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgaGFzVmVydGljYWxPdmVyZmxvdyA9IGJveC55ICsgZXJyUHggPCBzZXJpZXNUb3AgfHwgYm94LnkgKyBib3guaGVpZ2h0IC0gZXJyUHggPiBzZXJpZXNCb3R0b207XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHZpc2libGVUZXh0UGFydCA9PT0gMSA/IHRleHQubGVuZ3RoIDogTWF0aC5mbG9vcih0ZXh0Lmxlbmd0aCAqIHZpc2libGVUZXh0UGFydCkgLSAxO1xuICAgIGNvbnN0IGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgPSB0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94KTtcbiAgICByZXR1cm4geyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93LCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93IH07XG4gIH1cbiAgYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gsIGR4ID0gMCwgZHkgPSAwKSB7XG4gICAgY29uc3QgeyBzdXJyb3VuZGluZ1JhZGl1cyB9ID0gdGhpcztcbiAgICBpZiAoc3Vycm91bmRpbmdSYWRpdXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgeyB4OiBib3gueCArIGR4LCB5OiBib3gueSArIGR5IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoICsgZHgsIHk6IGJveC55ICsgZHkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGggKyBkeCwgeTogYm94LnkgKyBib3guaGVpZ2h0ICsgZHkgfSxcbiAgICAgIHsgeDogYm94LnggKyBkeCwgeTogYm94LnkgKyBib3guaGVpZ2h0ICsgZHkgfVxuICAgIF07XG4gICAgY29uc3Qgc3VyMiA9IHN1cnJvdW5kaW5nUmFkaXVzICoqIDI7XG4gICAgcmV0dXJuIGNvcm5lcnMuc29tZSgoY29ybmVyKSA9PiBjb3JuZXIueCAqKiAyICsgY29ybmVyLnkgKiogMiA+IHN1cjIpO1xuICB9XG4gIGNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICByZXR1cm4gIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgZnVsbERhdGEgPSB0aGlzLmNhbGxvdXROb2RlRGF0YTtcbiAgICBjb25zdCBkYXRhID0gZnVsbERhdGEuZmlsdGVyKCh0KSA9PiAhc2hvdWxkU2tpcCh0KSk7XG4gICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSB2b2lkIDA7XG4gICAgICBsYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gMDtcbiAgICB9KTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zIDwgMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgcmlnaHRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPj0gMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgdG9wTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luIDwgMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBib3R0b21MYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPj0gMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBnZXRUZXh0QkJveCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEJCb3guemVyby5jbG9uZSgpO1xuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMaW5lLmxlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbjtcbiAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcbiAgICAgIHJldHVybiBUZXh0LmNvbXB1dGVCQm94KGxhYmVsLnRleHQsIHgsIHksIHtcbiAgICAgICAgZm9udDogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uID0gKGxhYmVsLCBuZXh0LCBkaXJlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGdldFRleHRCQm94KGxhYmVsKS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IG90aGVyID0gZ2V0VGV4dEJCb3gobmV4dCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBjb2xsaWRlc09yQmVoaW5kID0gYm94LnggPCBvdGhlci54ICsgb3RoZXIud2lkdGggJiYgYm94LnggKyBib3gud2lkdGggPiBvdGhlci54ICYmIChkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSA8IG90aGVyLnkgKyBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgPiBvdGhlci55KTtcbiAgICAgIGlmIChjb2xsaWRlc09yQmVoaW5kKSB7XG4gICAgICAgIGNvbnN0IGR5ID0gZGlyZWN0aW9uID09PSBcInRvLXRvcFwiID8gYm94LnkgLSBvdGhlci55IC0gb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0IC0gb3RoZXIueTtcbiAgICAgICAgbmV4dC5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IGR5O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRZQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IG1pZExhYmVsID0gbGFiZWxzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYS5taWRTaW4pIC0gTWF0aC5hYnMoYi5taWRTaW4pKVswXTtcbiAgICAgIGNvbnN0IG1pZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWlkTGFiZWwpO1xuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpICsgMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLXRvcFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCArIDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpIC0gMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLWJvdHRvbVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWENvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlZID0gZGF0YS5zb21lKChkYXR1bSkgPT4gZGF0dW0uY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDApO1xuICAgICAgY29uc3QgYm94ZXMgPSBsYWJlbHMubWFwKChsYWJlbCkgPT4gZ2V0VGV4dEJCb3gobGFiZWwpKTtcbiAgICAgIGNvbnN0IHBhZGRlZEJveGVzID0gYm94ZXMubWFwKChib3gpID0+IGJveC5jbG9uZSgpLmdyb3cobWluU3BhY2luZyAvIDIpKTtcbiAgICAgIGxldCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZEJveGVzLmxlbmd0aCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHBhZGRlZEJveGVzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsYWJlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBvdGhlciA9IHBhZGRlZEJveGVzW2pdO1xuICAgICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KG90aGVyKSkge1xuICAgICAgICAgICAgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY3RvcnMgPSBmdWxsRGF0YS5tYXAoKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlU2VjdG9ycyA9IGJveGVzLnNvbWUoKGJveCkgPT4ge1xuICAgICAgICByZXR1cm4gc2VjdG9ycy5zb21lKChzZWN0b3IpID0+IGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSAmJiAhbGFiZWxzQ29sbGlkZVNlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFiZWxzLmZpbHRlcigoZCkgPT4gZC5jYWxsb3V0TGFiZWwudGV4dEFsaWduID09PSBcImNlbnRlclwiKS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZC5jYWxsb3V0TGFiZWw7XG4gICAgICAgIGlmIChkLm1pZENvcyA8IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZC5taWRDb3MgPiAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKGxlZnRMYWJlbHMpO1xuICAgIGF2b2lkWUNvbGxpc2lvbnMocmlnaHRMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnModG9wTGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKGJvdHRvbUxhYmVscyk7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgY29sb3IgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCB0ZW1wVGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDEgLyogTGFiZWwgKi8pLmZvckVhY2goKHRleHQpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRleHQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoZGF0dW0ucmFkaXVzKTtcbiAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoMCwgcmFkaXVzKTtcbiAgICAgIGlmICghbGFiZWw/LnRleHQgfHwgb3V0ZXJSYWRpdXMgPT09IDAgfHwgbGFiZWwuaGlkZGVuKSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgYWxpZ24gPSB7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH07XG4gICAgICB0ZW1wVGV4dE5vZGUudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZW1wVGV4dE5vZGUueCA9IHg7XG4gICAgICB0ZW1wVGV4dE5vZGUueSA9IHk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRBbGlnbihhbGlnbik7XG4gICAgICBjb25zdCBib3ggPSB0ZW1wVGV4dE5vZGUuZ2V0QkJveCgpO1xuICAgICAgbGV0IGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIGxldCB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KGxhYmVsLnRleHQsIGJveCwgc2VyaWVzUmVjdCk7XG4gICAgICAgIGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dC5sZW5ndGggPT09IHRleHRMZW5ndGggPyBsYWJlbC50ZXh0IDogYCR7bGFiZWwudGV4dC5zdWJzdHJpbmcoMCwgdGV4dExlbmd0aCl9XFx1MjAyNmA7XG4gICAgICAgIHZpc2libGUgPSAhaGFzVmVydGljYWxPdmVyZmxvdztcbiAgICAgIH1cbiAgICAgIHRleHQudGV4dCA9IGRpc3BsYXlUZXh0O1xuICAgICAgdGV4dC54ID0geDtcbiAgICAgIHRleHQueSA9IHk7XG4gICAgICB0ZXh0LnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0LnNldEFsaWduKGFsaWduKTtcbiAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgdGV4dC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjb21wdXRlTGFiZWxzQkJveChvcHRpb25zLCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWF4Q29sbGlzaW9uT2Zmc2V0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUoZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKTtcbiAgICBjb25zdCB0ZXh0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICBsZXQgdGl0bGVCb3g7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICh0aXRsZT8udGV4dCAmJiB0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIGlmIChpc0Zpbml0ZShkeSkpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gdGl0bGUudGV4dDtcbiAgICAgICAgdGV4dC54ID0gMDtcbiAgICAgICAgdGV4dC55ID0gZHk7XG4gICAgICAgIHRleHQuc2V0Rm9udCh0aXRsZSk7XG4gICAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJib3R0b21cIixcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRpdGxlQm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICAgIHRleHRCb3hlcy5wdXNoKHRpdGxlQm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jYWxsb3V0Tm9kZURhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKCFsYWJlbCB8fCBkYXR1bS5vdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGV4dC54ID0geDtcbiAgICAgIHRleHQueSA9IHk7XG4gICAgICB0ZXh0LnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0LnNldEFsaWduKHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgIGxhYmVsLmJveCA9IGJveDtcbiAgICAgIGlmIChNYXRoLmFicyhsYWJlbC5jb2xsaXNpb25PZmZzZXRZKSA+IG1heENvbGxpc2lvbk9mZnNldCkge1xuICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGl0bGVCb3gpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgICAgICBjb25zdCB0aXRsZUNsZWFuQXJlYSA9IG5ldyBCQm94KFxuICAgICAgICAgIHRpdGxlQm94LnggLSBtaW5TcGFjaW5nLFxuICAgICAgICAgIHNlcmllc1RvcCxcbiAgICAgICAgICB0aXRsZUJveC53aWR0aCArIDIgKiBtaW5TcGFjaW5nLFxuICAgICAgICAgIHRpdGxlQm94LnkgKyB0aXRsZUJveC5oZWlnaHQgKyBtaW5TcGFjaW5nIC0gc2VyaWVzVG9wXG4gICAgICAgICk7XG4gICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KHRpdGxlQ2xlYW5BcmVhKSkge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5oaWRlV2hlbk5lY2Vzc2FyeSkge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhcbiAgICAgICAgICBsYWJlbC50ZXh0LFxuICAgICAgICAgIGJveCxcbiAgICAgICAgICBzZXJpZXNSZWN0XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGlzVG9vU2hvcnQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA+IDIgJiYgdGV4dExlbmd0aCA8IDI7XG4gICAgICAgIGlmIChoYXNWZXJ0aWNhbE92ZXJmbG93IHx8IGlzVG9vU2hvcnQgfHwgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdykge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRleHRCb3hlcy5wdXNoKGJveCk7XG4gICAgfSk7XG4gICAgaWYgKHRleHRCb3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQkJveC5tZXJnZSh0ZXh0Qm94ZXMpO1xuICB9XG4gIHVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3QgeyBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBwb3NpdGlvbk9mZnNldCwgcG9zaXRpb25SYXRpbywgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbDtcbiAgICBjb25zdCBpc0RvbnV0ID0gaW5uZXJSYWRpdXMgPiAwO1xuICAgIGNvbnN0IHNpbmdsZVZpc2libGVTZWN0b3IgPSB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmZpbHRlcihCb29sZWFuKS5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yTGFiZWwgPSAodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gZGF0dW07XG4gICAgICBsZXQgaXNUZXh0VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHNlY3RvckxhYmVsICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gaW5uZXJSYWRpdXMgKiAoMSAtIHBvc2l0aW9uUmF0aW8pICsgb3V0ZXJSYWRpdXMgKiBwb3NpdGlvblJhdGlvICsgcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0LnRleHQgPSBzZWN0b3JMYWJlbC50ZXh0O1xuICAgICAgICBjb25zdCBzaG91bGRQdXRUZXh0SW5DZW50ZXIgPSAhaXNEb251dCAmJiBzaW5nbGVWaXNpYmxlU2VjdG9yO1xuICAgICAgICBpZiAoc2hvdWxkUHV0VGV4dEluQ2VudGVyKSB7XG4gICAgICAgICAgdGV4dC54ID0gMDtcbiAgICAgICAgICB0ZXh0LnkgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQueCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgICAgIHRleHQueSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICBjb25zdCBiYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICAgICAgW2Jib3gueCwgYmJveC55XSxcbiAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55XSxcbiAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55ICsgYmJveC5oZWlnaHRdLFxuICAgICAgICAgIFtiYm94LngsIGJib3gueSArIGJib3guaGVpZ2h0XVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzZWN0b3JCb3VuZHMgPSB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgICAgICAgaWYgKGNvcm5lcnMuZXZlcnkoKFt4LCB5XSkgPT4gaXNQb2ludEluU2VjdG9yKHgsIHksIHNlY3RvckJvdW5kcykpKSB7XG4gICAgICAgICAgaXNUZXh0VmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRleHQudmlzaWJsZSA9IGlzVGV4dFZpc2libGU7XG4gICAgfTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gIH1cbiAgdXBkYXRlWmVyb3N1bVJpbmdzKCkge1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zaXplID0gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgfVxuICBnZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIGNhbGxvdXRMYWJlbCwgbGVnZW5kSXRlbSB9ID0gbm9kZURhdHVtO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlZ2VuZEl0ZW0udGV4dDtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGNhbGxvdXRMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gY2FsbG91dExhYmVsLnRleHQ7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHNlY3RvckxhYmVsLnRleHQ7XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIHBpY2tCeU1hdGNoaW5nQW5nbGUodGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZVZhbHVlLFxuICAgICAgc2VjdG9yRm9ybWF0OiB7IGZpbGw6IGNvbG9yIH0sXG4gICAgICBpdGVtSWRcbiAgICB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHRoaXMucHJvcGVydGllcy50aXRsZT8udGV4dCk7XG4gICAgY29uc3QgY29udGVudCA9IGlzRmluaXRlTnVtYmVyKGFuZ2xlVmFsdWUpID8gdG9GaXhlZChhbmdsZVZhbHVlKSA6IFN0cmluZyhhbmdsZVZhbHVlKTtcbiAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pO1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAge1xuICAgICAgICB0aXRsZTogdGl0bGUgPz8gbGFiZWxUZXh0LFxuICAgICAgICBjb250ZW50OiB0aXRsZSAmJiBsYWJlbFRleHQgPyBgJHtsYWJlbFRleHR9OiAke2NvbnRlbnR9YCA6IGNvbnRlbnQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGFuZ2xlS2V5OiB0aGlzLnByb3BlcnRpZXMuYW5nbGVLZXksXG4gICAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgICByYWRpdXNOYW1lOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTmFtZSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGE/LmRhdGEubGVuZ3RoIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFsZWdlbmRJdGVtS2V5ICYmICghY2FsbG91dExhYmVsS2V5IHx8IGNhbGxvdXRMYWJlbEtleSA9PT0gYW5nbGVLZXkpICYmICghc2VjdG9yTGFiZWxLZXkgfHwgc2VjdG9yTGFiZWxLZXkgPT09IGFuZ2xlS2V5KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbElkeCwgc2VjdG9yTGFiZWxJZHgsIGxlZ2VuZEl0ZW1JZHggfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB0aXRsZVRleHQgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNob3dJbkxlZ2VuZCAmJiB0aGlzLnByb3BlcnRpZXMudGl0bGUudGV4dDtcbiAgICBjb25zdCBsZWdlbmREYXRhID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gcHJvY2Vzc2VkRGF0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnN0IGxhYmVsUGFydHMgPSBbXTtcbiAgICAgIGlmICh0aXRsZVRleHQpIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKHRpdGxlVGV4dCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscyhcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNhbGxvdXRMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW2NhbGxvdXRMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIHNlY3RvckxhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2VjdG9yTGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsYWJlbHMubGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMubGVnZW5kSXRlbS50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGxhYmVsUGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgbGVnZW5kRGF0YS5wdXNoKHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUgJiYgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGFiZWxQYXJ0cy5qb2luKFwiIC0gXCIpXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgZmlsbDogc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgICAgICAgICAgIHN0cm9rZTogc2VjdG9yRm9ybWF0LnN0cm9rZSxcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lOiBsZWdlbmRJdGVtS2V5ICE9IG51bGwgPyBkYXR1bVtsZWdlbmRJdGVtS2V5XSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmREYXRhO1xuICB9XG4gIG9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcywgbGVnZW5kSXRlbU5hbWUgfSA9IGV2ZW50O1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpO1xuICAgIH0gZWxzZSBpZiAobGVnZW5kSXRlbU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy50b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpIHtcbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2l0ZW1JZF0gPSBlbmFibGVkO1xuICAgIGlmICh0aGlzLm5vZGVEYXRhW2l0ZW1JZF0pIHtcbiAgICAgIHRoaXMubm9kZURhdGFbaXRlbUlkXS5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICB9XG4gIHRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5IHx8ICF0aGlzLmRhdGFNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5kYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApO1xuICAgIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGF0YS5mb3JFYWNoKCh7IHZhbHVlcyB9LCBkYXR1bUl0ZW1JZCkgPT4ge1xuICAgICAgaWYgKHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA9PT0gbGVnZW5kSXRlbU5hbWUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGRhdHVtSXRlbUlkLCBlbmFibGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICB0aGlzLnJhZGl1c1NjYWxlLFxuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLml0ZW1TZWxlY3Rpb24sIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLCB0aGlzLnBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeSgpIHtcbiAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbiwgcHJvY2Vzc2VkRGF0YSwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoZGF0YURpZmY/Lm1vdmVkLnNpemUgPz8gMCkgPT09IDA7XG4gICAgY29uc3QgaGFzS2V5cyA9IChwcm9jZXNzZWREYXRhPy5kZWZzLmtleXMubGVuZ3RoID8/IDApID4gMDtcbiAgICBjb25zdCBoYXNVbmlxdWVLZXlzID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyA/PyB0cnVlO1xuICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtsZWdlbmRJdGVtS2V5XTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2NhbGxvdXRMYWJlbEtleV07XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW3NlY3RvckxhYmVsS2V5XTtcbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1JZChkYXR1bSkge1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IGRhdHVtO1xuICAgIGNvbnN0IGRhdHVtSWQgPSB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShkYXR1bS5kYXR1bSk7XG4gICAgcmV0dXJuIGRhdHVtSWQgIT0gbnVsbCA/IFN0cmluZyhkYXR1bUlkKSA6IGAke2luZGV4fWA7XG4gIH1cbiAgb25EYXRhQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IGRhdGE/Lm1hcCgoXywgaW5kZXgpID0+IHNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSA/PyB0cnVlKSA/PyBbXTtcbiAgfVxufTtcblBpZVNlcmllcy5jbGFzc05hbWUgPSBcIlBpZVNlcmllc1wiO1xuUGllU2VyaWVzLnR5cGUgPSBcInBpZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllU2VyaWVzTW9kdWxlLnRzXG52YXIgUGllU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSxcbiAgaWRlbnRpZmllcjogXCJwaWVcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IFBpZVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICB0aGVtZVRlbXBsYXRlOiBwaWVUaGVtZSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHBpZVBhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sYmFyL3Rvb2xiYXJQcm9wZXJ0aWVzLnRzXG52YXIgVG9vbGJhckdyb3VwUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihvbkNoYW5nZSwgb25CdXR0b25zQ2hhbmdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9uQ2hhbmdlID0gb25DaGFuZ2U7XG4gICAgdGhpcy5vbkJ1dHRvbnNDaGFuZ2UgPSBvbkJ1dHRvbnNDaGFuZ2U7XG4gICAgdGhpcy5hbGlnbiA9IFwic3RhcnRcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJ0b3BcIiAvKiBUb3AgKi87XG4gICAgdGhpcy5zaXplID0gXCJub3JtYWxcIjtcbiAgICB0aGlzLmJ1dHRvbk92ZXJyaWRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYnV0dG9uQ29uZmlndXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnV0dG9ucz8ubWFwKChidXR0b24pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gYnV0dG9uLmlkID8/IGJ1dHRvbi52YWx1ZTtcbiAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IHRoaXMuYnV0dG9uT3ZlcnJpZGVzLmdldChpZCk7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVzICE9IG51bGwgPyB7IC4uLmJ1dHRvbiwgLi4ub3ZlcnJpZGVzIH0gOiBidXR0b247XG4gICAgfSkgPz8gW107XG4gIH1cbiAgYnV0dG9uc0NoYW5nZWQoY29uZmlndXJhdGlvbk9ubHkpIHtcbiAgICB0aGlzLm9uQnV0dG9uc0NoYW5nZSh0aGlzLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCksIGNvbmZpZ3VyYXRpb25Pbmx5KTtcbiAgfVxuICBvdmVycmlkZUJ1dHRvbkNvbmZpZ3VyYXRpb24oaWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgb3ZlcnJpZGVzID0gdGhpcy5idXR0b25PdmVycmlkZXMuZ2V0KGlkKTtcbiAgICBpZiAob3ZlcnJpZGVzID09IG51bGwpIHtcbiAgICAgIG92ZXJyaWRlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5idXR0b25PdmVycmlkZXMuc2V0KGlkLCBvdmVycmlkZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG92ZXJyaWRlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnV0dG9uc0NoYW5nZWQodHJ1ZSk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0Lm9uQ2hhbmdlKHRhcmdldC5lbmFibGVkKTtcbiAgfSksXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShVTklPTihbLi4uVE9PTEJBUl9BTElHTk1FTlRTXSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcImFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShVTklPTihUT09MQkFSX1BPU0lUSU9OUyksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShVTklPTihbXCJzbWFsbFwiLCBcIm5vcm1hbFwiXSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgZm9yIChjb25zdCBidXR0b24gb2YgdGFyZ2V0LmJ1dHRvbnMgPz8gW10pIHtcbiAgICAgIGlmIChidXR0b24uaWNvbiAhPSBudWxsICYmIElDT05TX0xFR0FDWS5pbmNsdWRlcyhidXR0b24uaWNvbikpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGBJY29uICcke2J1dHRvbi5pY29ufScgaXMgZGVwcmVjYXRlZCwgdXNlIGFub3RoZXIgaWNvbiBpbnN0ZWFkLmApO1xuICAgICAgfVxuICAgICAgaWYgKGJ1dHRvbi5hcmlhTGFiZWwgPT09IFwidG9vbGJhckFubm90YXRpb25zQ29sb3JcIikge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYEFyaWEgbGFiZWwgJyR7YnV0dG9uLmFyaWFMYWJlbH0nIGlzIGRlcHJlY2F0ZWQsIHVzZSAndG9vbGJhckFubm90YXRpb25zTGluZUNvbG9yJyBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0LmJ1dHRvbnNDaGFuZ2VkKGZhbHNlKTtcbiAgfSksXG4gIFZhbGlkYXRlKEFSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJidXR0b25zXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sYmFyL3Rvb2xiYXJTdHlsZXMudHNcbnZhciBibG9jazIgPSBcImFnLWNoYXJ0cy10b29sYmFyXCI7XG52YXIgZWxlbWVudHMyID0ge1xuICBhbGlnbjogXCJhZy1jaGFydHMtdG9vbGJhcl9fYWxpZ25cIixcbiAgc2VjdGlvbjogXCJhZy1jaGFydHMtdG9vbGJhcl9fc2VjdGlvblwiLFxuICBidXR0b246IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvblwiLFxuICBpY29uOiBcImFnLWNoYXJ0cy10b29sYmFyX19pY29uXCIsXG4gIGxhYmVsOiBcImFnLWNoYXJ0cy10b29sYmFyX19sYWJlbFwiXG59O1xudmFyIG1vZGlmaWVyczIgPSB7XG4gIFtcInRvcFwiIC8qIFRvcCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLXRvcFwiLFxuICBbXCJyaWdodFwiIC8qIFJpZ2h0ICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tcmlnaHRcIixcbiAgW1wiYm90dG9tXCIgLyogQm90dG9tICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tYm90dG9tXCIsXG4gIFtcImxlZnRcIiAvKiBMZWZ0ICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tbGVmdFwiLFxuICBbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmdcIixcbiAgW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3BcIixcbiAgW1wiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b21cIixcbiAgc21hbGw6IFwiYWctY2hhcnRzLXRvb2xiYXItLXNtYWxsXCIsXG4gIG5vcm1hbDogXCJhZy1jaGFydHMtdG9vbGJhci0tbm9ybWFsXCIsXG4gIGhpZGRlbjogXCJhZy1jaGFydHMtdG9vbGJhci0taGlkZGVuXCIsXG4gIHByZXZlbnRGbGFzaDogXCJhZy1jaGFydHMtdG9vbGJhci0tcHJldmVudC1mbGFzaFwiLFxuICBmbG9hdGluZ0hpZGRlbjogXCJhZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctaGlkZGVuXCIsXG4gIGFsaWduOiB7XG4gICAgc3RhcnQ6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1zdGFydFwiLFxuICAgIGNlbnRlcjogXCJhZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlclwiLFxuICAgIGVuZDogXCJhZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZFwiXG4gIH0sXG4gIGJ1dHRvbjoge1xuICAgIGFjdGl2ZTogYGFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWFjdGl2ZWAsXG4gICAgaGlkZGVuVmFsdWU6IGBhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdmFsdWVgLFxuICAgIGhpZGRlblRvZ2dsZWQ6IGBhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZGAsXG4gICAgZmlsbFZpc2libGU6IGBhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maWxsLXZpc2libGVgXG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhci50c1xudmFyIFRvb2xiYXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNlcmllc1R5cGUgPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcInNlcmllc1R5cGVcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwic2VyaWVzVHlwZVwiKVxuICAgICk7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbnNcIilcbiAgICApO1xuICAgIHRoaXMuYW5ub3RhdGlvbk9wdGlvbnMgPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcImFubm90YXRpb25PcHRpb25zXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcImFubm90YXRpb25PcHRpb25zXCIpXG4gICAgKTtcbiAgICB0aGlzLnJhbmdlcyA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwicmFuZ2VzXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcInJhbmdlc1wiKVxuICAgICk7XG4gICAgdGhpcy56b29tID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJ6b29tXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcInpvb21cIilcbiAgICApO1xuICAgIHRoaXMuaG9yaXpvbnRhbFNwYWNpbmcgPSAxMDtcbiAgICB0aGlzLnZlcnRpY2FsU3BhY2luZyA9IDEwO1xuICAgIHRoaXMuZmxvYXRpbmdEZXRlY3Rpb25SYW5nZSA9IDM4O1xuICAgIHRoaXMucG9zaXRpb25zID0ge1xuICAgICAgW1widG9wXCIgLyogVG9wICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcInJpZ2h0XCIgLyogUmlnaHQgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiYm90dG9tXCIgLyogQm90dG9tICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImxlZnRcIiAvKiBMZWZ0ICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICB0aGlzLnBvc2l0aW9uQWxpZ25tZW50cyA9IHtcbiAgICAgIFtcInRvcFwiIC8qIFRvcCAqL106IHt9LFxuICAgICAgW1wicmlnaHRcIiAvKiBSaWdodCAqL106IHt9LFxuICAgICAgW1wiYm90dG9tXCIgLyogQm90dG9tICovXToge30sXG4gICAgICBbXCJsZWZ0XCIgLyogTGVmdCAqL106IHt9LFxuICAgICAgW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL106IHt9LFxuICAgICAgW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi9dOiB7fSxcbiAgICAgIFtcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXToge31cbiAgICB9O1xuICAgIHRoaXMuZ3JvdXBDYWxsZXJzID0ge1xuICAgICAgc2VyaWVzVHlwZTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIGFubm90YXRpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICByYW5nZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICB6b29tOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICB0aGlzLmdyb3VwQnV0dG9ucyA9IHtcbiAgICAgIHNlcmllc1R5cGU6IFtdLFxuICAgICAgYW5ub3RhdGlvbnM6IFtdLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IFtdLFxuICAgICAgcmFuZ2VzOiBbXSxcbiAgICAgIHpvb206IFtdXG4gICAgfTtcbiAgICB0aGlzLmFyaWFUb29sYmFycyA9IFtcbiAgICAgIHsgZ3JvdXBzOiBbXCJzZXJpZXNUeXBlXCIsIFwiYW5ub3RhdGlvbnNcIl0sIGRlc3Ryb3lGbnM6IFtdIH0sXG4gICAgICB7IGdyb3VwczogW1wiYW5ub3RhdGlvbk9wdGlvbnNcIl0sIGRlc3Ryb3lGbnM6IFtdIH0sXG4gICAgICB7IGdyb3VwczogW1wicmFuZ2VzXCJdLCBkZXN0cm95Rm5zOiBbXSB9LFxuICAgICAgeyBncm91cHM6IFtcInpvb21cIl0sIGRlc3Ryb3lGbnM6IFtdIH1cbiAgICBdO1xuICAgIHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLmdyb3VwUHJveGllZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYXNOZXdMb2NhbGUgPSB0cnVlO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXSA9IGN0eC5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYHRvb2xiYXItJHtwb3NpdGlvbn1gKTtcbiAgICAgIHRoaXMuZWxlbWVudHNbcG9zaXRpb25dLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgdGhpcy5yZW5kZXJUb29sYmFyKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJob3ZlclwiLCB0aGlzLm9uSG92ZXIuYmluZCh0aGlzKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCB0aGlzLm9uTGVhdmUuYmluZCh0aGlzKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImJ1dHRvbi10b2dnbGVkXCIsIHRoaXMub25CdXR0b25Ub2dnbGVkLmJpbmQodGhpcykpLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYnV0dG9uLXVwZGF0ZWRcIiwgdGhpcy5vbkJ1dHRvblVwZGF0ZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJncm91cC10b2dnbGVkXCIsIHRoaXMub25Hcm91cFRvZ2dsZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJmbG9hdGluZy1hbmNob3ItY2hhbmdlZFwiLCB0aGlzLm9uRmxvYXRpbmdBbmNob3JDaGFuZ2VkLmJpbmQodGhpcykpLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwicHJveHktZ3JvdXAtb3B0aW9uc1wiLCB0aGlzLm9uUHJveHlHcm91cE9wdGlvbnMuYmluZCh0aGlzKSksXG4gICAgICBjdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCB0aGlzLm9uTGF5b3V0Q29tcGxldGUuYmluZCh0aGlzKSksXG4gICAgICBjdHgubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5oYXNOZXdMb2NhbGUgPSB0cnVlO1xuICAgICAgfSksXG4gICAgICAoKSA9PiB0aGlzLmRlc3Ryb3lFbGVtZW50cygpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95RWxlbWVudHMoKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoYmxvY2syKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQyIG9mIE9iamVjdC5rZXlzKHRoaXMuZWxlbWVudHMpKSB7XG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYHRvb2xiYXItJHtlbGVtZW50Mn1gKTtcbiAgICB9XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVuYWJsZWQsXG4gICAgICBlbGVtZW50czogZWxlbWVudHMzLFxuICAgICAgZmxvYXRpbmdEZXRlY3Rpb25SYW5nZSxcbiAgICAgIGN0eDogeyBzY2VuZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WSxcbiAgICAgIHNvdXJjZUV2ZW50OiB7IHRhcmdldCB9XG4gICAgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgRmxvYXRpbmdCb3R0b20sIEZsb2F0aW5nVG9wIH0gPSBUb29sYmFyUG9zaXRpb247XG4gICAgaWYgKCFlbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGJvdHRvbSA9IGVsZW1lbnRzM1tGbG9hdGluZ0JvdHRvbV07XG4gICAgY29uc3QgdG9wID0gZWxlbWVudHMzW0Zsb2F0aW5nVG9wXTtcbiAgICBjb25zdCBib3R0b21EZXRlY3Rpb25ZID0gYm90dG9tLm9mZnNldFRvcCAtIGZsb2F0aW5nRGV0ZWN0aW9uUmFuZ2U7XG4gICAgY29uc3QgYm90dG9tVmlzaWJsZSA9IG9mZnNldFkgPiBib3R0b21EZXRlY3Rpb25ZICYmIG9mZnNldFkgPCBzY2VuZS5jYW52YXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgdGFyZ2V0ID09PSBib3R0b207XG4gICAgY29uc3QgdG9wRGV0ZWN0aW9uWSA9IHRvcC5vZmZzZXRUb3AgKyB0b3Aub2Zmc2V0SGVpZ2h0ICsgZmxvYXRpbmdEZXRlY3Rpb25SYW5nZTtcbiAgICBjb25zdCB0b3BWaXNpYmxlID0gb2Zmc2V0WSA+IDAgJiYgb2Zmc2V0WSA8IHRvcERldGVjdGlvblkgfHwgdGFyZ2V0ID09PSB0b3A7XG4gICAgdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKEZsb2F0aW5nQm90dG9tLCBib3R0b21WaXNpYmxlKTtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdUb3AsIHRvcFZpc2libGUpO1xuICB9XG4gIG9uTGVhdmUoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbmFibGVkLFxuICAgICAgY3R4OiB7IHNjZW5lIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0gPSBldmVudDtcbiAgICBjb25zdCB7IEZsb2F0aW5nQm90dG9tLCBGbG9hdGluZ1RvcCB9ID0gVG9vbGJhclBvc2l0aW9uO1xuICAgIGlmICghZW5hYmxlZCB8fCB0YXJnZXRFbGVtZW50ICE9PSBzY2VuZS5jYW52YXMuZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpc1RhcmdldEJ1dHRvbiA9IFRPT0xCQVJfR1JPVVBTLnNvbWUoXG4gICAgICAoZ3JvdXApID0+IHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXS5zb21lKChidXR0b24pID0+IGJ1dHRvbiA9PT0gcmVsYXRlZEVsZW1lbnQpXG4gICAgKTtcbiAgICBpZiAoaXNUYXJnZXRCdXR0b24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKEZsb2F0aW5nQm90dG9tLCBmYWxzZSk7XG4gICAgdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKEZsb2F0aW5nVG9wLCBmYWxzZSk7XG4gIH1cbiAgb25Hcm91cENoYW5nZWQoZ3JvdXApIHtcbiAgICBpZiAodGhpc1tncm91cF0gPT0gbnVsbCB8fCB0aGlzLmdyb3VwUHJveGllZC5oYXMoZ3JvdXApKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY3JlYXRlR3JvdXAoZ3JvdXApO1xuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgb25Hcm91cEJ1dHRvbnNDaGFuZ2VkKGdyb3VwLCBidXR0b25zLCBjb25maWd1cmF0aW9uT25seSkge1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8IHRoaXMuZ3JvdXBQcm94aWVkLmhhcyhncm91cCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNvbmZpZ3VyYXRpb25Pbmx5KSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1dHRvbk9wdGlvbnMgb2YgdGhpc1tncm91cF0uYnV0dG9uQ29uZmlndXJhdGlvbnMoKSkge1xuICAgICAgICB0aGlzLnJlZnJlc2hCdXR0b25Db250ZW50KGdyb3VwLCBidXR0b25PcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVHcm91cEJ1dHRvbnMoZ3JvdXAsIGJ1dHRvbnMpO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUoKSB7XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgdGhpcy5lbGVtZW50c1twb3NpdGlvbl0uY2xhc3NMaXN0LnJlbW92ZShtb2RpZmllcnMyLnByZXZlbnRGbGFzaCk7XG4gICAgfVxuICB9XG4gIG9uQnV0dG9uVXBkYXRlZChldmVudCkge1xuICAgIGNvbnN0IHsgdHlwZTogX3R5cGUsIGdyb3VwLCBpZCwgLi4ucGFyYW1zIH0gPSBldmVudDtcbiAgICB0aGlzW2dyb3VwXS5vdmVycmlkZUJ1dHRvbkNvbmZpZ3VyYXRpb24oaWQsIHsgLi4ucGFyYW1zIH0pO1xuICB9XG4gIHNldEJ1dHRvbkFjdGl2ZShidXR0b24sIGFjdGl2ZSkge1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVyczIuYnV0dG9uLmFjdGl2ZSwgYWN0aXZlKTtcbiAgfVxuICBvbkJ1dHRvblRvZ2dsZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGdyb3VwLCBpZCwgYWN0aXZlLCBlbmFibGVkLCB2aXNpYmxlIH0gPSBldmVudDtcbiAgICBpZiAodGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICBpZiAoYnV0dG9uLmRhdGFzZXQudG9vbGJhcklkICE9PSBgJHtpZH1gKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGJ1dHRvbi5hcmlhRGlzYWJsZWQgPSBgJHshZW5hYmxlZH1gO1xuICAgICAgc2V0VmlzaWJpbGl0eShidXR0b24sIG1vZGlmaWVyczIuYnV0dG9uLmhpZGRlblRvZ2dsZWQsICF2aXNpYmxlKTtcbiAgICAgIHRoaXMuc2V0QnV0dG9uQWN0aXZlKGJ1dHRvbiwgYWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgb25Hcm91cFRvZ2dsZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgdmlzaWJsZSB9ID0gZXZlbnQ7XG4gICAgdGhpcy50b2dnbGVHcm91cChjYWxsZXIsIGdyb3VwLCBhY3RpdmUsIHZpc2libGUpO1xuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgb25GbG9hdGluZ0FuY2hvckNoYW5nZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50czogZWxlbWVudHMzLFxuICAgICAgZ3JvdXBCdXR0b25zLFxuICAgICAgcG9zaXRpb25zLFxuICAgICAgaG9yaXpvbnRhbFNwYWNpbmcsXG4gICAgICB2ZXJ0aWNhbFNwYWNpbmcsXG4gICAgICBjdHg6IHsgZG9tTWFuYWdlciwgdG9vbGJhck1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZ3JvdXAsIGFuY2hvciB9ID0gZXZlbnQ7XG4gICAgaWYgKCFwb3NpdGlvbnNbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXS5oYXMoZ3JvdXApKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZWxlbWVudHMzW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL107XG4gICAgaWYgKGVsZW1lbnQyLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMyLmhpZGRlbikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9zaXRpb24gPSBhbmNob3IucG9zaXRpb24gPz8gXCJhYm92ZVwiO1xuICAgIGNvbnN0IHsgb2Zmc2V0V2lkdGg6IHdpZHRoLCBvZmZzZXRIZWlnaHQ6IGhlaWdodCB9ID0gZWxlbWVudDI7XG4gICAgbGV0IHRvcCA9IGFuY2hvci55IC0gaGVpZ2h0IC0gdmVydGljYWxTcGFjaW5nO1xuICAgIGxldCBsZWZ0ID0gYW5jaG9yLnggLSB3aWR0aCAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHRvcCA9IGFuY2hvci55IC0gaGVpZ2h0IC8gMjtcbiAgICAgIGxlZnQgPSBhbmNob3IueCArIGhvcml6b250YWxTcGFjaW5nO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiYWJvdmUtbGVmdFwiKSB7XG4gICAgICBsZWZ0ID0gYW5jaG9yLng7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBkb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRvcCA9IGNsYW1wKDAsIHRvcCwgY2FudmFzUmVjdC5oZWlnaHQgLSBoZWlnaHQpO1xuICAgIGxlZnQgPSBjbGFtcCgwLCBsZWZ0LCBjYW52YXNSZWN0LndpZHRoIC0gd2lkdGgpO1xuICAgIGVsZW1lbnQyLnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICAgIGNvbnN0IGdyb3VwQkJveCA9IG5ldyBCQm94KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZm9yIChjb25zdCBidXR0b24gb2YgZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgaWYgKGJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzMi5idXR0b24uaGlkZGVuVG9nZ2xlZCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcGFyZW50ID0gYnV0dG9uLm9mZnNldFBhcmVudDtcbiAgICAgIHRvb2xiYXJNYW5hZ2VyLmJ1dHRvbk1vdmVkKFxuICAgICAgICBncm91cCxcbiAgICAgICAgYnV0dG9uLmRhdGFzZXQudG9vbGJhcklkLFxuICAgICAgICBuZXcgQkJveChcbiAgICAgICAgICBidXR0b24ub2Zmc2V0TGVmdCArIChwYXJlbnQ/Lm9mZnNldExlZnQgPz8gMCksXG4gICAgICAgICAgYnV0dG9uLm9mZnNldFRvcCArIChwYXJlbnQ/Lm9mZnNldFRvcCA/PyAwKSxcbiAgICAgICAgICBidXR0b24ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgYnV0dG9uLm9mZnNldEhlaWdodFxuICAgICAgICApLFxuICAgICAgICBncm91cEJCb3hcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGJ1dHRvblJlY3QoYnV0dG9uLCBjYW52YXNSZWN0ID0gdGhpcy5jdHguZG9tTWFuYWdlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkge1xuICAgIGNvbnN0IGJ1dHRvblJlY3QgPSBidXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIG5ldyBCQm94KFxuICAgICAgYnV0dG9uUmVjdC5sZWZ0IC0gY2FudmFzUmVjdC5sZWZ0LFxuICAgICAgYnV0dG9uUmVjdC50b3AgLSBjYW52YXNSZWN0LnRvcCxcbiAgICAgIGJ1dHRvblJlY3Qud2lkdGgsXG4gICAgICBidXR0b25SZWN0LmhlaWdodFxuICAgICk7XG4gIH1cbiAgb25Qcm94eUdyb3VwT3B0aW9ucyhldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2FsbGVyLCBncm91cCwgb3B0aW9ucyB9ID0gZXZlbnQ7XG4gICAgdGhpcy5ncm91cFByb3hpZWQuc2V0KGdyb3VwLCBvcHRpb25zKTtcbiAgICB0aGlzW2dyb3VwXS5zZXQob3B0aW9ucyk7XG4gICAgdGhpcy50b2dnbGVHcm91cChjYWxsZXIsIGdyb3VwLCB2b2lkIDAsIG9wdGlvbnMuZW5hYmxlZCk7XG4gICAgdGhpcy5jcmVhdGVHcm91cChncm91cCwgb3B0aW9ucy5lbmFibGVkLCBvcHRpb25zLnBvc2l0aW9uKTtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNyZWF0ZUdyb3VwQnV0dG9ucyhncm91cCwgb3B0aW9ucy5idXR0b25zKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlR3JvdXAoZ3JvdXAsIGVuYWJsZWQsIHBvc2l0aW9uKSB7XG4gICAgZW5hYmxlZCA/PyAoZW5hYmxlZCA9IHRoaXNbZ3JvdXBdLmVuYWJsZWQpO1xuICAgIHBvc2l0aW9uID8/IChwb3NpdGlvbiA9IHRoaXNbZ3JvdXBdLnBvc2l0aW9uKTtcbiAgICBmb3IgKGNvbnN0IHBvcyBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgaWYgKGVuYWJsZWQgJiYgcG9zaXRpb24gPT09IHBvcykge1xuICAgICAgICB0aGlzLnBvc2l0aW9uc1twb3NdLmFkZChncm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uc1twb3NdLmRlbGV0ZShncm91cCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUdyb3VwQnV0dG9ucyhncm91cCwgYnV0dG9ucyA9IFtdKSB7XG4gICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICBidXR0b24ucmVtb3ZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGFyaWFUb29sYmFyID0gdGhpcy5nZXRBcmlhVG9vbGJhcihncm91cCk7XG4gICAgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdID0gW107XG4gICAgYXJpYVRvb2xiYXIuZGVzdHJveUZucy5mb3JFYWNoKChkKSA9PiBkKCkpO1xuICAgIGFyaWFUb29sYmFyLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICBpZiAoYnV0dG9ucy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBhbGlnbiwgcG9zaXRpb24gfSA9IHRoaXNbZ3JvdXBdO1xuICAgIGNvbnN0IGFsaWduRWxlbWVudCA9IHRoaXMucG9zaXRpb25BbGlnbm1lbnRzW3Bvc2l0aW9uXVthbGlnbl07XG4gICAgaWYgKCFhbGlnbkVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV4dFNlY3Rpb24gPSAoc2VjdGlvbjIpID0+IHtcbiAgICAgIGNvbnN0IGFsaWduRWxlbWVudENoaWxkcmVuID0gQXJyYXkuZnJvbShhbGlnbkVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgY29uc3QgZGF0YUdyb3VwID0gXCJkYXRhLWdyb3VwXCI7XG4gICAgICBjb25zdCBkYXRhU2VjdGlvbiA9IFwiZGF0YS1zZWN0aW9uXCI7XG4gICAgICBsZXQgc2VjdGlvbkVsZW1lbnQgPSBhbGlnbkVsZW1lbnRDaGlsZHJlbi5maW5kKChwcmV2U2VjdGlvbjIpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXZTZWN0aW9uMi5nZXRBdHRyaWJ1dGUoZGF0YUdyb3VwKSA9PT0gZ3JvdXAgJiYgcHJldlNlY3Rpb24yLmdldEF0dHJpYnV0ZShkYXRhU2VjdGlvbikgPT09IChzZWN0aW9uMiA/PyBcIlwiKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICBzZWN0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YUdyb3VwLCBncm91cCk7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LnNldEF0dHJpYnV0ZShkYXRhU2VjdGlvbiwgc2VjdGlvbjIgPz8gXCJcIik7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBUT09MQkFSX0dST1VQX09SREVSSU5HW2dyb3VwXTtcbiAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IGFsaWduRWxlbWVudENoaWxkcmVuLmZpbmQoKHByZXZTZWN0aW9uMikgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZHcm91cCA9IHByZXZTZWN0aW9uMi5nZXRBdHRyaWJ1dGUoZGF0YUdyb3VwKTtcbiAgICAgICAgICBjb25zdCBwcmV2R3JvdXBJbmRleCA9IFRPT0xCQVJfR1JPVVBfT1JERVJJTkdbcHJldkdyb3VwXTtcbiAgICAgICAgICByZXR1cm4gcHJldkdyb3VwSW5kZXggPiBncm91cEluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluc2VydEJlZm9yZUVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGFsaWduRWxlbWVudC5pbnNlcnRCZWZvcmUoc2VjdGlvbkVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsaWduRWxlbWVudC5hcHBlbmRDaGlsZChzZWN0aW9uRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goKCkgPT4gc2VjdGlvbkVsZW1lbnQucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgICAgc2VjdGlvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZChlbGVtZW50czIuc2VjdGlvbiwgbW9kaWZpZXJzMlt0aGlzW2dyb3VwXS5zaXplXSk7XG4gICAgICByZXR1cm4gc2VjdGlvbkVsZW1lbnQ7XG4gICAgfTtcbiAgICBsZXQgcHJldlNlY3Rpb24gPSBidXR0b25zLmF0KDApPy5zZWN0aW9uO1xuICAgIGxldCBzZWN0aW9uID0gbmV4dFNlY3Rpb24ocHJldlNlY3Rpb24pO1xuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBidXR0b25zKSB7XG4gICAgICBpZiAocHJldlNlY3Rpb24gIT09IG9wdGlvbnMuc2VjdGlvbikge1xuICAgICAgICBzZWN0aW9uID0gbmV4dFNlY3Rpb24ob3B0aW9ucy5zZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHByZXZTZWN0aW9uID0gb3B0aW9ucy5zZWN0aW9uO1xuICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b25FbGVtZW50KGdyb3VwLCBvcHRpb25zKTtcbiAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXS5wdXNoKGJ1dHRvbik7XG4gICAgfVxuICAgIGNvbnN0IG9uRXNjYXBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jdHgudG9vbGJhck1hbmFnZXIuY2FuY2VsKGdyb3VwKTtcbiAgICB9O1xuICAgIGxldCBvbkZvY3VzO1xuICAgIGxldCBvbkJsdXI7XG4gICAgaWYgKGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgIG9uRm9jdXMgPSAoKSA9PiB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMocG9zaXRpb24sIHRydWUpO1xuICAgICAgb25CbHVyID0gKCkgPT4gdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKHBvc2l0aW9uLCBmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5jb21wdXRlQXJpYU9yaWVudGF0aW9uKHRoaXNbZ3JvdXBdLnBvc2l0aW9uKTtcbiAgICBjb25zdCBhcmlhVG9vbGJhckJ1dHRvbnMgPSBhcmlhVG9vbGJhci5ncm91cHMubWFwKChnKSA9PiB0aGlzLmdyb3VwQnV0dG9uc1tnXSkuZmxhdCgpO1xuICAgIGFyaWFUb29sYmFyLmRlc3Ryb3lGbnMgPSBpbml0VG9vbGJhcktleU5hdih7XG4gICAgICBvcmllbnRhdGlvbixcbiAgICAgIHRvb2xiYXI6IGFsaWduRWxlbWVudCxcbiAgICAgIGJ1dHRvbnM6IGFyaWFUb29sYmFyQnV0dG9ucyxcbiAgICAgIG9uRXNjYXBlLFxuICAgICAgb25Gb2N1cyxcbiAgICAgIG9uQmx1clxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVG9vbGJhckFyaWFMYWJlbChncm91cCwgYWxpZ25FbGVtZW50KTtcbiAgfVxuICBjb21wdXRlQXJpYU9yaWVudGF0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogXCJob3Jpem9udGFsXCIsXG4gICAgICByaWdodDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYm90dG9tOiBcImhvcml6b250YWxcIixcbiAgICAgIGxlZnQ6IFwidmVydGljYWxcIixcbiAgICAgIGZsb2F0aW5nOiBcImhvcml6b250YWxcIixcbiAgICAgIFwiZmxvYXRpbmctdG9wXCI6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgXCJmbG9hdGluZy1ib3R0b21cIjogXCJob3Jpem9udGFsXCJcbiAgICB9W3Bvc2l0aW9uXTtcbiAgfVxuICB0b2dnbGVHcm91cChjYWxsZXIsIGdyb3VwLCBhY3RpdmUsIGVuYWJsZWQpIHtcbiAgICBpZiAoZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5ncm91cENhbGxlcnNbZ3JvdXBdLmFkZChjYWxsZXIpO1xuICAgIH0gZWxzZSBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZ3JvdXBDYWxsZXJzW2dyb3VwXS5kZWxldGUoY2FsbGVyKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2ZSAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgICAgdGhpcy5zZXRCdXR0b25BY3RpdmUoYnV0dG9uLCBhY3RpdmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcm9jZXNzUGVuZGluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBwZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cyA9ICh0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID8/IFtdKS5zbGljZSgpO1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgcGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMpIHtcbiAgICAgIHRoaXMub25CdXR0b25Ub2dnbGVkKGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cyA9IFtdO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm4gY3R4O1xuICAgIHRoaXMucmVmcmVzaE91dGVyTGF5b3V0KGN0eC5zaHJpbmtSZWN0KTtcbiAgICB0aGlzLnJlZnJlc2hMb2NhbGUoKTtcbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIGFzeW5jIHBlcmZvcm1DYXJ0ZXNpYW5MYXlvdXQob3B0cykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmVmcmVzaElubmVyTGF5b3V0KG9wdHMuc2VyaWVzUmVjdCk7XG4gIH1cbiAgcmVmcmVzaE91dGVyTGF5b3V0KHNocmlua1JlY3QpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRzOiBlbGVtZW50czMsIGhvcml6b250YWxTcGFjaW5nLCB2ZXJ0aWNhbFNwYWNpbmcgfSA9IHRoaXM7XG4gICAgaWYgKCFlbGVtZW50czMudG9wLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMyLmhpZGRlbikpIHtcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKGVsZW1lbnRzMy50b3Aub2Zmc2V0SGVpZ2h0ICsgdmVydGljYWxTcGFjaW5nLCBcInRvcFwiKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50czMucmlnaHQuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVyczIuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMzLnJpZ2h0Lm9mZnNldFdpZHRoICsgaG9yaXpvbnRhbFNwYWNpbmcsIFwicmlnaHRcIik7XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMzLmJvdHRvbS5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzMi5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czMuYm90dG9tLm9mZnNldEhlaWdodCArIHZlcnRpY2FsU3BhY2luZywgXCJib3R0b21cIik7XG4gICAgICBlbGVtZW50czMuYm90dG9tLnN0eWxlLnRvcCA9IGAke3Nocmlua1JlY3QueSArIHNocmlua1JlY3QuaGVpZ2h0ICsgdmVydGljYWxTcGFjaW5nfXB4YDtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50czMubGVmdC5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzMi5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czMubGVmdC5vZmZzZXRXaWR0aCArIGhvcml6b250YWxTcGFjaW5nLCBcImxlZnRcIik7XG4gICAgfVxuICB9XG4gIHJlZnJlc2hMb2NhbGUoKSB7XG4gICAgY29uc3QgeyBoYXNOZXdMb2NhbGUgfSA9IHRoaXM7XG4gICAgaWYgKCFoYXNOZXdMb2NhbGUpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBUT09MQkFSX0dST1VQUykge1xuICAgICAgY29uc3QgYnV0dG9ucyA9IHRoaXNbZ3JvdXBdLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IGJ1dHRvbk9wdGlvbnMgb2YgYnV0dG9ucykge1xuICAgICAgICB0aGlzLnJlZnJlc2hCdXR0b25Db250ZW50KGdyb3VwLCBidXR0b25PcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhckFyaWFMYWJlbChncm91cCk7XG4gICAgfVxuICAgIHRoaXMuaGFzTmV3TG9jYWxlID0gZmFsc2U7XG4gIH1cbiAgcmVmcmVzaElubmVyTGF5b3V0KHJlY3QpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRzOiBlbGVtZW50czMsIHZlcnRpY2FsU3BhY2luZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IEZsb2F0aW5nQm90dG9tLCBGbG9hdGluZ1RvcCB9ID0gVG9vbGJhclBvc2l0aW9uO1xuICAgIGVsZW1lbnRzMy50b3Auc3R5bGUudG9wID0gYCR7cmVjdC55IC0gZWxlbWVudHMzLnRvcC5vZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbFNwYWNpbmd9cHhgO1xuICAgIGVsZW1lbnRzMy50b3Auc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgZWxlbWVudHMzLnRvcC5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgIGVsZW1lbnRzMy5ib3R0b20uc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgZWxlbWVudHMzLmJvdHRvbS5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgIGVsZW1lbnRzMy5yaWdodC5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIGVsZW1lbnRzMy5yaWdodC5zdHlsZS5yaWdodCA9IGAwcHhgO1xuICAgIGVsZW1lbnRzMy5yaWdodC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGA7XG4gICAgZWxlbWVudHMzLmxlZnQuc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICBlbGVtZW50czMubGVmdC5zdHlsZS5sZWZ0ID0gYDBweGA7XG4gICAgZWxlbWVudHMzLmxlZnQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgIGVsZW1lbnRzM1tGbG9hdGluZ1RvcF0uc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICBlbGVtZW50czNbRmxvYXRpbmdCb3R0b21dLnN0eWxlLnRvcCA9IGAke3JlY3QueSArIHJlY3QuaGVpZ2h0IC0gZWxlbWVudHMzW0Zsb2F0aW5nQm90dG9tXS5vZmZzZXRIZWlnaHR9cHhgO1xuICB9XG4gIHJlZnJlc2hCdXR0b25Db250ZW50KGdyb3VwLCBidXR0b25PcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmJ1dHRvbklkKGJ1dHRvbk9wdGlvbnMpO1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuZ3JvdXBQcm94aWVkLmdldChncm91cCk/LmJ1dHRvbnM/LmZpbmQoKGIpID0+IHRoaXMuYnV0dG9uSWQoYikgPT09IGlkKSA/PyBidXR0b25PcHRpb25zO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLmZpbmQoKGIpID0+IGIuZ2V0QXR0cmlidXRlKFwiZGF0YS10b29sYmFyLWlkXCIpID09PSBpZCk7XG4gICAgaWYgKGVsZW1lbnQyID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVCdXR0b24oZWxlbWVudDIsIGJ1dHRvbik7XG4gIH1cbiAgdG9nZ2xlVmlzaWJpbGl0aWVzKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNHcm91cFZpc2libGUgPSAoZ3JvdXApID0+IHRoaXNbZ3JvdXBdLmVuYWJsZWQgJiYgdGhpcy5ncm91cENhbGxlcnNbZ3JvdXBdLnNpemUgPiAwO1xuICAgIGNvbnN0IGlzQnV0dG9uVmlzaWJsZSA9IChlbGVtZW50MikgPT4gKGJ1dHRvbikgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmJ1dHRvbklkKGJ1dHRvbik7XG4gICAgICByZXR1cm4gaWQgPT0gbnVsbCB8fCBpZCA9PT0gZWxlbWVudDIuZGF0YXNldC50b29sYmFySWQ7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy5lbmFibGVkICYmIEFycmF5LmZyb20odGhpcy5wb3NpdGlvbnNbcG9zaXRpb25dLnZhbHVlcygpKS5zb21lKGlzR3JvdXBWaXNpYmxlKTtcbiAgICAgIHNldFZpc2liaWxpdHkodGhpcy5lbGVtZW50c1twb3NpdGlvbl0sIG1vZGlmaWVyczIuaGlkZGVuLCAhdmlzaWJsZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgVE9PTEJBUl9HUk9VUFMpIHtcbiAgICAgIGlmICh0aGlzW2dyb3VwXSA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGdyb3VwVmlzaWJsZSA9IGlzR3JvdXBWaXNpYmxlKGdyb3VwKTtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgICBjb25zdCBidXR0b25WaXNpYmxlID0gZ3JvdXBWaXNpYmxlICYmIHRoaXNbZ3JvdXBdLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCkuc29tZShpc0J1dHRvblZpc2libGUoYnV0dG9uKSk7XG4gICAgICAgIHNldFZpc2liaWxpdHkoYnV0dG9uLCBtb2RpZmllcnMyLmJ1dHRvbi5oaWRkZW5WYWx1ZSwgIWJ1dHRvblZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKHBvc2l0aW9uLCB2aXNpYmxlKSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMzLCB2ZXJ0aWNhbFNwYWNpbmc6IHZlcnRpY2FsTWFyZ2luLCBwb3NpdGlvbkFsaWdubWVudHMgfSA9IHRoaXM7XG4gICAgY29uc3QgZWxlbWVudDIgPSBlbGVtZW50czNbcG9zaXRpb25dO1xuICAgIGNvbnN0IGFsaWdubWVudHMgPSBPYmplY3QudmFsdWVzKHBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl0pO1xuICAgIHNldFZpc2liaWxpdHkoZWxlbWVudDIsIG1vZGlmaWVyczIuZmxvYXRpbmdIaWRkZW4sICF2aXNpYmxlKTtcbiAgICBjb25zdCBkaXIgPSBwb3NpdGlvbiA9PT0gXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqLyA/IDEgOiAtMTtcbiAgICBmb3IgKGNvbnN0IGFsaWduIG9mIGFsaWdubWVudHMpIHtcbiAgICAgIGFsaWduLnN0eWxlLnRyYW5zZm9ybSA9IHZpc2libGUgJiYgYWxpZ24uc3R5bGUudHJhbnNmb3JtICE9PSBcIlwiID8gXCJ0cmFuc2xhdGVZKDApXCIgOiBgdHJhbnNsYXRlWSgkeyhlbGVtZW50Mi5vZmZzZXRIZWlnaHQgKyB2ZXJ0aWNhbE1hcmdpbikgKiBkaXJ9cHgpYDtcbiAgICB9XG4gIH1cbiAgcmVuZGVyVG9vbGJhcihwb3NpdGlvbiA9IFwidG9wXCIgLyogVG9wICovKSB7XG4gICAgY29uc3QgZWxlbWVudDIgPSB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXTtcbiAgICBlbGVtZW50Mi5jbGFzc0xpc3QuYWRkKGJsb2NrMiwgbW9kaWZpZXJzMltwb3NpdGlvbl0sIG1vZGlmaWVyczIucHJldmVudEZsYXNoKTtcbiAgICBpZiAoaXNBbmltYXRpbmdGbG9hdGluZ1Bvc2l0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgZWxlbWVudDIuY2xhc3NMaXN0LmFkZChtb2RpZmllcnMyLmZsb2F0aW5nSGlkZGVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhbGlnbiBvZiBUT09MQkFSX0FMSUdOTUVOVFMpIHtcbiAgICAgIGNvbnN0IGFsaWdubWVudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYWxpZ25tZW50RWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgIGFsaWdubWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChlbGVtZW50czIuYWxpZ24sIG1vZGlmaWVyczIuYWxpZ25bYWxpZ25dKTtcbiAgICAgIGFsaWdubWVudEVsZW1lbnQuZGF0YXNldC5wb2ludGVyQ2FwdHVyZSA9IFwiZXhjbHVzaXZlXCI7XG4gICAgICBlbGVtZW50Mi5hcHBlbmRDaGlsZChhbGlnbm1lbnRFbGVtZW50KTtcbiAgICAgIHRoaXMucG9zaXRpb25BbGlnbm1lbnRzW3Bvc2l0aW9uXVthbGlnbl0gPSBhbGlnbm1lbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICBjcmVhdGVCdXR0b25FbGVtZW50KGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnV0dG9uID0gY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChlbGVtZW50czIuYnV0dG9uKTtcbiAgICBidXR0b24uZGF0YXNldC50b29sYmFyR3JvdXAgPSBncm91cDtcbiAgICBidXR0b24udGFiSW5kZXggPSAtMTtcbiAgICBidXR0b24uZGF0YXNldC50b29sYmFySWQgPSB0aGlzLmJ1dHRvbklkKG9wdGlvbnMpO1xuICAgIGJ1dHRvbi5vbmNsaWNrID0gbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyKFxuICAgICAgYnV0dG9uLFxuICAgICAgdGhpcy5vbkJ1dHRvblByZXNzLmJpbmQodGhpcywgYnV0dG9uLCBncm91cCwgb3B0aW9ucy5pZCwgb3B0aW9ucy52YWx1ZSlcbiAgICApO1xuICAgIHRoaXMudXBkYXRlQnV0dG9uKGJ1dHRvbiwgb3B0aW9ucyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goKCkgPT4gYnV0dG9uLnJlbW92ZSgpKTtcbiAgICByZXR1cm4gYnV0dG9uO1xuICB9XG4gIGdldEFyaWFUb29sYmFyKGdyb3VwKSB7XG4gICAgZm9yIChjb25zdCBhcmlhVG9vbGJhciBvZiB0aGlzLmFyaWFUb29sYmFycykge1xuICAgICAgaWYgKGFyaWFUb29sYmFyLmdyb3Vwcy5pbmNsdWRlcyhncm91cCkpIHtcbiAgICAgICAgcmV0dXJuIGFyaWFUb29sYmFyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGNhbm5vdCBmaW5kIGFyaWEtdG9vbGJhciBvZiAnJHtncm91cH0nYCk7XG4gIH1cbiAgdXBkYXRlVG9vbGJhckFyaWFMYWJlbChncm91cCwgYWxpZ25FbGVtZW50KSB7XG4gICAgaWYgKCFhbGlnbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgYWxpZ24sIHBvc2l0aW9uIH0gPSB0aGlzW2dyb3VwXTtcbiAgICAgIGFsaWduRWxlbWVudCA9IHRoaXMucG9zaXRpb25BbGlnbm1lbnRzW3Bvc2l0aW9uXVthbGlnbl07XG4gICAgICBpZiAoIWFsaWduRWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB7XG4gICAgICBzZXJpZXNUeXBlOiBcImFyaWFMYWJlbEZpbmFuY2lhbENoYXJ0c1wiLFxuICAgICAgYW5ub3RhdGlvbnM6IFwiYXJpYUxhYmVsRmluYW5jaWFsQ2hhcnRzXCIsXG4gICAgICBhbm5vdGF0aW9uT3B0aW9uczogXCJhcmlhTGFiZWxBbm5vdGF0aW9uT3B0aW9uc1Rvb2xiYXJcIixcbiAgICAgIHJhbmdlczogXCJhcmlhTGFiZWxSYW5nZXNUb29sYmFyXCIsXG4gICAgICB6b29tOiBcImFyaWFMYWJlbFpvb21Ub29sYmFyXCJcbiAgICB9O1xuICAgIGFsaWduRWxlbWVudC5hcmlhTGFiZWwgPSB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQobWFwW2dyb3VwXSk7XG4gIH1cbiAgdXBkYXRlQnV0dG9uKGJ1dHRvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBkb21NYW5hZ2VyLCBsb2NhbGVNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAob3B0aW9ucy50b29sdGlwKSB7XG4gICAgICBjb25zdCB0b29sdGlwID0gbG9jYWxlTWFuYWdlci50KG9wdGlvbnMudG9vbHRpcCk7XG4gICAgICBidXR0b24udGl0bGUgPSB0b29sdGlwO1xuICAgIH1cbiAgICBsZXQgaW5uZXIgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmljb24gIT0gbnVsbCkge1xuICAgICAgaW5uZXIgPSBgPHNwYW4gY2xhc3M9XCIke2RvbU1hbmFnZXIuZ2V0SWNvbkNsYXNzTmFtZXMob3B0aW9ucy5pY29uKX0gJHtlbGVtZW50czIuaWNvbn1cIj48L3NwYW4+YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFiZWwgPSBsb2NhbGVNYW5hZ2VyLnQob3B0aW9ucy5sYWJlbCk7XG4gICAgICBpbm5lciA9IGAke2lubmVyfTxzcGFuIGNsYXNzPVwiJHtlbGVtZW50czIubGFiZWx9XCI+JHtsYWJlbH08L3NwYW4+YDtcbiAgICB9XG4gICAgYnV0dG9uLmlubmVySFRNTCA9IGlubmVyO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVyczIuYnV0dG9uLmZpbGxWaXNpYmxlLCBvcHRpb25zLmZpbGwgIT0gbnVsbCk7XG4gICAgYnV0dG9uLnN0eWxlLnNldFByb3BlcnR5KFwiLS1maWxsXCIsIG9wdGlvbnMuZmlsbCA/PyBudWxsKTtcbiAgICBjb25zdCBhcmlhTGFiZWwgPSBvcHRpb25zLmFyaWFMYWJlbCA/IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChvcHRpb25zLmFyaWFMYWJlbCkgOiB2b2lkIDA7XG4gICAgc2V0QXR0cmlidXRlKGJ1dHRvbiwgXCJhcmlhLWxhYmVsXCIsIGFyaWFMYWJlbCk7XG4gIH1cbiAgb25CdXR0b25QcmVzcyhidXR0b24sIGdyb3VwLCBpZCwgdmFsdWUpIHtcbiAgICB0aGlzLmN0eC50b29sYmFyTWFuYWdlci5wcmVzc0J1dHRvbihncm91cCwgdGhpcy5idXR0b25JZCh7IGlkLCB2YWx1ZSB9KSwgdmFsdWUsIHRoaXMuYnV0dG9uUmVjdChidXR0b24pKTtcbiAgfVxuICBidXR0b25JZChidXR0b24pIHtcbiAgICBjb25zdCB7IGlkLCB2YWx1ZSwgbGFiZWwgfSA9IGJ1dHRvbjtcbiAgICBpZiAoaWQgIT0gbnVsbClcbiAgICAgIHJldHVybiBpZDtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICByZXR1cm4gbGFiZWwgPz8gXCJcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQucHJvY2Vzc1BlbmRpbmdFdmVudHMoKTtcbiAgICB0YXJnZXQudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH0pLFxuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbGJhci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyTW9kdWxlLnRzXG52YXIgREFZID0gMWUzICogNjAgKiA2MCAqIDI0O1xudmFyIE1PTlRIID0gREFZICogMzA7XG52YXIgWUVBUiA9IERBWSAqIDM2NTtcbnZhciBzZXJpZXNUeXBlID0ge1xuICBlbmFibGVkOiBmYWxzZSxcbiAgcG9zaXRpb246IFwibGVmdFwiLFxuICBhbGlnbjogXCJzdGFydFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyU2VyaWVzVHlwZURyb3Bkb3duXCIsXG4gICAgICB2YWx1ZTogXCJ0eXBlXCJcbiAgICB9XG4gIF1cbn07XG52YXIgYW5ub3RhdGlvbnMgPSB7XG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGljb246IFwidHJlbmQtbGluZS1kcmF3aW5nXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xpbmVBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IFwibGluZS1tZW51XCIsXG4gICAgICBzZWN0aW9uOiBcImxpbmUtYW5ub3RhdGlvbnNcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJ0ZXh0LWFubm90YXRpb25cIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVGV4dEFubm90YXRpb25zXCIsXG4gICAgICB2YWx1ZTogXCJ0ZXh0LW1lbnVcIixcbiAgICAgIHNlY3Rpb246IFwidGV4dC1hbm5vdGF0aW9uc1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImRlbGV0ZVwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNDbGVhckFsbFwiLFxuICAgICAgdmFsdWU6IFwiY2xlYXJcIixcbiAgICAgIHNlY3Rpb246IFwidG9vbHNcIlxuICAgIH1cbiAgXVxufTtcbnZhciBhbm5vdGF0aW9uT3B0aW9ucyA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcG9zaXRpb246IFwiZmxvYXRpbmdcIixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGljb246IFwidGV4dC1hbm5vdGF0aW9uXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1RleHRDb2xvclwiLFxuICAgICAgdmFsdWU6IFwidGV4dC1jb2xvclwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImxpbmUtY29sb3JcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zTGluZUNvbG9yXCIsXG4gICAgICB2YWx1ZTogXCJsaW5lLWNvbG9yXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiZmlsbC1jb2xvclwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNGaWxsQ29sb3JcIixcbiAgICAgIHZhbHVlOiBcImZpbGwtY29sb3JcIlxuICAgIH0sXG4gICAge1xuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNUZXh0U2l6ZVwiLFxuICAgICAgdmFsdWU6IFwidGV4dC1zaXplXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwidW5sb2NrZWRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zTG9ja1wiLFxuICAgICAgdmFsdWU6IFwibG9ja1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImxvY2tlZFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNVbmxvY2tcIixcbiAgICAgIHZhbHVlOiBcInVubG9ja1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImRlbGV0ZVwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNEZWxldGVcIixcbiAgICAgIHZhbHVlOiBcImRlbGV0ZVwiXG4gICAgfVxuICBdXG59O1xudmFyIHJhbmdlcyA9IHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIHBvc2l0aW9uOiBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sXG4gIGFsaWduOiBcInN0YXJ0XCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2UxTW9udGhcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2UxTW9udGhBcmlhXCIsXG4gICAgICB2YWx1ZTogTU9OVEhcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTNNb250aHNcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2UzTW9udGhzQXJpYVwiLFxuICAgICAgdmFsdWU6IDMgKiBNT05USFxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlNk1vbnRoc1wiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTZNb250aHNBcmlhXCIsXG4gICAgICB2YWx1ZTogNiAqIE1PTlRIXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2VZZWFyVG9EYXRlXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlWWVhclRvRGF0ZUFyaWFcIixcbiAgICAgIHZhbHVlOiAoX3N0YXJ0LCBlbmQpID0+IFsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKGAke25ldyBEYXRlKGVuZCkuZ2V0RnVsbFllYXIoKX0tMDEtMDFgKSkuZ2V0VGltZSgpLCBlbmRdLFxuICAgICAgaWQ6IFwieWVhci10by1kYXRlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTFZZWFyXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlMVllYXJBcmlhXCIsXG4gICAgICB2YWx1ZTogWUVBUlxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlQWxsXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlQWxsQXJpYVwiLFxuICAgICAgdmFsdWU6IChzdGFydCwgZW5kKSA9PiBbc3RhcnQsIGVuZF0sXG4gICAgICBpZDogXCJhbGxcIlxuICAgIH1cbiAgXVxufTtcbnZhciB6b29tID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgYWxpZ246IFwiZW5kXCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICBpY29uOiBcInpvb20tb3V0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tWm9vbU91dFwiLFxuICAgICAgdmFsdWU6IFwiem9vbS1vdXRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJ6b29tLWluXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tWm9vbUluXCIsXG4gICAgICB2YWx1ZTogXCJ6b29tLWluXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLWxlZnRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5MZWZ0XCIsXG4gICAgICB2YWx1ZTogXCJwYW4tbGVmdFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1yaWdodFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVBhblJpZ2h0XCIsXG4gICAgICB2YWx1ZTogXCJwYW4tcmlnaHRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJwYW4tc3RhcnRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5TdGFydFwiLFxuICAgICAgdmFsdWU6IFwicGFuLXN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLWVuZFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVBhbkVuZFwiLFxuICAgICAgdmFsdWU6IFwicGFuLWVuZFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInJlc2V0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUmVzZXRcIixcbiAgICAgIHZhbHVlOiBcInJlc2V0XCJcbiAgICB9XG4gIF1cbn07XG52YXIgVG9vbGJhck1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwidG9vbGJhclwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgVG9vbGJhcihjdHgpLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNlcmllc1R5cGUsXG4gICAgICBhbm5vdGF0aW9ucyxcbiAgICAgIGFubm90YXRpb25PcHRpb25zLFxuICAgICAgcmFuZ2VzLFxuICAgICAgem9vbVxuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9yZWdpc3RlckluYnVpbHRNb2R1bGVzLnRzXG5mdW5jdGlvbiByZWdpc3RlckluYnVpbHRNb2R1bGVzKCkge1xuICBtb2R1bGVSZWdpc3RyeS5yZWdpc3RlcihcbiAgICBCYWNrZ3JvdW5kTW9kdWxlLFxuICAgIENvbW11bml0eUxlZ2VuZE1vZHVsZSxcbiAgICBMb2NhbGVNb2R1bGUsXG4gICAgTmF2aWdhdG9yTW9kdWxlLFxuICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgQXJlYVNlcmllc01vZHVsZSxcbiAgICBCYXJTZXJpZXNNb2R1bGUsXG4gICAgQnViYmxlU2VyaWVzTW9kdWxlLFxuICAgIExpbmVTZXJpZXNNb2R1bGUsXG4gICAgU2NhdHRlclNlcmllc01vZHVsZSxcbiAgICBEb251dFNlcmllc01vZHVsZSxcbiAgICBQaWVTZXJpZXNNb2R1bGUsXG4gICAgSGlzdG9ncmFtU2VyaWVzTW9kdWxlXG4gICk7XG4gIGZvciAoY29uc3QgQXhpc0NvbnN0cnVjdG9yIG9mIFtOdW1iZXJBeGlzLCBDYXRlZ29yeUF4aXMsIFRpbWVBeGlzLCBHcm91cGVkQ2F0ZWdvcnlBeGlzLCBMb2dBeGlzXSkge1xuICAgIGF4aXNSZWdpc3RyeS5yZWdpc3RlcihBeGlzQ29uc3RydWN0b3IudHlwZSwge1xuICAgICAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEF4aXNDb25zdHJ1Y3RvcihjdHgpLFxuICAgICAgaGlkZGVuOiBBeGlzQ29uc3RydWN0b3IgPT09IEdyb3VwZWRDYXRlZ29yeUF4aXNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3NldHVwTW9kdWxlcy50c1xuZnVuY3Rpb24gc2V0dXBNb2R1bGVzKCkge1xuICBmb3IgKGNvbnN0IG0gb2YgbW9kdWxlUmVnaXN0cnkubW9kdWxlcykge1xuICAgIGlmIChtLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIiAmJiAhdmVyaWZ5SWZNb2R1bGVFeHBlY3RlZChtKSkge1xuICAgICAgTG9nZ2VyLmVycm9yT25jZShcIlVuZXhwZWN0ZWQgZW50ZXJwcmlzZSBtb2R1bGUgcmVnaXN0ZXJlZDogXCIgKyBtLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcInJvb3RcIiAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIGZvciAoY29uc3QgY2hhcnRUeXBlMiBvZiBtLmNoYXJ0VHlwZXMpIHtcbiAgICAgICAgY2hhcnREZWZhdWx0cy5zZXQoY2hhcnRUeXBlMiwgbS50aGVtZVRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgaWYgKG0uY2hhcnRUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gTW9kdWxlIGRlZmluaXRpb24gZXJyb3I6ICR7bS5pZGVudGlmaWVyfWApO1xuICAgICAgfVxuICAgICAgc2VyaWVzUmVnaXN0cnkucmVnaXN0ZXIobS5pZGVudGlmaWVyLCBtKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJzZXJpZXMtb3B0aW9uXCIgJiYgbS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUyIG9mIG0uc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgc2VyaWVzUmVnaXN0cnkuc2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiwgbS50aGVtZVRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJheGlzLW9wdGlvblwiICYmIG0udGhlbWVUZW1wbGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBtLmF4aXNUeXBlcykge1xuICAgICAgICBjb25zdCBheGlzVHlwZVRoZW1lID0gYXhpc1JlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUpO1xuICAgICAgICBjb25zdCB0aGVtZSA9IG1lcmdlRGVmYXVsdHMobS50aGVtZVRlbXBsYXRlLCBheGlzVHlwZVRoZW1lKTtcbiAgICAgICAgYXhpc1JlZ2lzdHJ5LnNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJheGlzXCIpIHtcbiAgICAgIGF4aXNSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcImxlZ2VuZFwiKSB7XG4gICAgICBsZWdlbmRSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kdWxlUmVnaXN0cnkuaGFzRW50ZXJwcmlzZU1vZHVsZXMoKSkge1xuICAgIGNvbnN0IGV4cGVjdGVkQnV0VW51c2VkID0gZ2V0VW51c2VkRXhwZWN0ZWRNb2R1bGVzKCk7XG4gICAgaWYgKGV4cGVjdGVkQnV0VW51c2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIExvZ2dlci5lcnJvck9uY2UoXCJFbnRlcnByaXNlIG1vZHVsZXMgZXhwZWN0ZWQgYnV0IG5vdCByZWdpc3RlcmVkOiBcIiwgZXhwZWN0ZWRCdXRVbnVzZWQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mbG93UHJvcG9ydGlvbkNoYXJ0LnRzXG5mdW5jdGlvbiBpc0Zsb3dQcm9wb3J0aW9uKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzLnR5cGUgPT09IFwic2Fua2V5XCIgfHwgc2VyaWVzLnR5cGUgPT09IFwiY2hvcmRcIjtcbn1cbnZhciBGbG93UHJvcG9ydGlvbkNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXRhKCkge1xuICAgIGF3YWl0IHN1cGVyLnVwZGF0ZURhdGEoKTtcbiAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIGlmIChpc0Zsb3dQcm9wb3J0aW9uKHNlcmllcykpIHtcbiAgICAgICAgc2VyaWVzLnNldENoYXJ0Tm9kZXMobm9kZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgY29uc3Qgc2hyaW5rUmVjdCA9IGF3YWl0IHN1cGVyLnBlcmZvcm1MYXlvdXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBzZXJpZXNBcmVhOiB7IHBhZGRpbmcgfSxcbiAgICAgIHNlcmllc1Jvb3QsXG4gICAgICBhbm5vdGF0aW9uUm9vdCxcbiAgICAgIGhpZ2hsaWdodFJvb3RcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmdWxsU2VyaWVzUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmxlZnQsIFwibGVmdFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgXCJ0b3BcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5yaWdodCwgXCJyaWdodFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmJvdHRvbSwgXCJib3R0b21cIik7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gc2hyaW5rUmVjdDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBzaHJpbmtSZWN0O1xuICAgIGNvbnN0IHNlcmllc1Zpc2libGUgPSB0aGlzLnNlcmllcy5zb21lKChzKSA9PiBzLnZpc2libGUpO1xuICAgIHNlcmllc1Jvb3QudmlzaWJsZSA9IHNlcmllc1Zpc2libGU7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHNocmlua1JlY3QueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHNocmlua1JlY3QueSk7XG4gICAgICBncm91cC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoXG4gICAgICAgIG5ldyBCQm94KGZ1bGxTZXJpZXNSZWN0LngsIGZ1bGxTZXJpZXNSZWN0LnksIGZ1bGxTZXJpZXNSZWN0LndpZHRoLCBmdWxsU2VyaWVzUmVjdC5oZWlnaHQpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xuICAgICAgdHlwZTogXCJsYXlvdXQtY29tcGxldGVcIixcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB0aGlzLmN0eC5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLmN0eC5zY2VuZS5oZWlnaHQgfSxcbiAgICAgIGNsaXBTZXJpZXM6IGZhbHNlLFxuICAgICAgc2VyaWVzOiB7IHJlY3Q6IGZ1bGxTZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBzaHJpbmtSZWN0LCB2aXNpYmxlOiBzZXJpZXNWaXNpYmxlIH0sXG4gICAgICBheGVzOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiBzaHJpbmtSZWN0O1xuICB9XG59O1xuRmxvd1Byb3BvcnRpb25DaGFydC5jbGFzc05hbWUgPSBcIkZsb3dQcm9wb3J0aW9uQ2hhcnRcIjtcbkZsb3dQcm9wb3J0aW9uQ2hhcnQudHlwZSA9IFwiZmxvdy1wcm9wb3J0aW9uXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2hpZXJhcmNoeUNoYXJ0LnRzXG52YXIgSGllcmFyY2h5Q2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaGllcmFyY2h5XCI7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dCgpIHtcbiAgICBjb25zdCBzaHJpbmtSZWN0ID0gYXdhaXQgc3VwZXIucGVyZm9ybUxheW91dCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcmllc0FyZWE6IHsgcGFkZGluZyB9LFxuICAgICAgc2VyaWVzUm9vdCxcbiAgICAgIGFubm90YXRpb25Sb290LFxuICAgICAgaGlnaGxpZ2h0Um9vdFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZ1bGxTZXJpZXNSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcubGVmdCwgXCJsZWZ0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcudG9wLCBcInRvcFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCBcInJpZ2h0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcuYm90dG9tLCBcImJvdHRvbVwiKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzaHJpbmtSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHNocmlua1JlY3QueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHNocmlua1JlY3QueSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5zZXJpZXMubWFwKGFzeW5jIChzZXJpZXMpID0+IHtcbiAgICAgICAgYXdhaXQgc2VyaWVzLnVwZGF0ZSh7IHNlcmllc1JlY3Q6IHNocmlua1JlY3QgfSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gdGhpcy5zZXJpZXNbMF0udmlzaWJsZTtcbiAgICBzZXJpZXNSb290LnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShcbiAgICAgIG5ldyBCQm94KHNocmlua1JlY3QueCwgc2hyaW5rUmVjdC55LCBzaHJpbmtSZWN0LndpZHRoLCBzaHJpbmtSZWN0LmhlaWdodClcbiAgICApO1xuICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZSh7XG4gICAgICB0eXBlOiBcImxheW91dC1jb21wbGV0ZVwiLFxuICAgICAgY2hhcnQ6IHsgd2lkdGg6IHRoaXMuY3R4LnNjZW5lLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3R4LnNjZW5lLmhlaWdodCB9LFxuICAgICAgY2xpcFNlcmllczogZmFsc2UsXG4gICAgICBzZXJpZXM6IHsgcmVjdDogZnVsbFNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IHNocmlua1JlY3QsIHZpc2libGU6IHRydWUgfSxcbiAgICAgIGF4ZXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHNocmlua1JlY3Q7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIGNvbnN0IGNhcHRpb25UZXh0ID0gdGhpcy5nZXRDYXB0aW9uVGV4dCgpO1xuICAgIHJldHVybiBgaGllcmFyY2hpY2FsIGNoYXJ0LCAke2NhcHRpb25UZXh0fWA7XG4gIH1cbn07XG5IaWVyYXJjaHlDaGFydC5jbGFzc05hbWUgPSBcIkhpZXJhcmNoeUNoYXJ0XCI7XG5IaWVyYXJjaHlDaGFydC50eXBlID0gXCJoaWVyYXJjaHlcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9wb2xhckF4aXMudHNcbnZhciBQb2xhckF4aXMgPSBjbGFzcyBleHRlbmRzIEF4aXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hhcGUgPSBcInBvbHlnb25cIjtcbiAgICB0aGlzLmlubmVyUmFkaXVzUmF0aW8gPSAwO1xuICAgIHRoaXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nID0gMjA7XG4gIH1cbiAgY29tcHV0ZUxhYmVsc0JCb3goX29wdGlvbnMsIF9zZXJpZXNSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJwb2x5Z29uXCIsIFwiY2lyY2xlXCJdLCBcImEgcG9sYXIgYXhpcyBzaGFwZVwiKSlcbl0sIFBvbGFyQXhpcy5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBvbGFyQXhpcy5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNSYXRpb1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvcG9sYXJDaGFydC50c1xudmFyIFBvbGFyQ2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZyg0MCk7XG4gICAgdGhpcy5jdHguYXhpc01hbmFnZXIuYXhpc0dyb3VwLnpJbmRleCA9IDYgLyogQVhJU19GT1JFR1JPVU5EX1pJTkRFWCAqLztcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwicG9sYXJcIjtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KCkge1xuICAgIGNvbnN0IHNocmlua1JlY3QgPSBhd2FpdCBzdXBlci5wZXJmb3JtTGF5b3V0KCk7XG4gICAgY29uc3QgZnVsbFNlcmllc1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCk7XG4gICAgdGhpcy5jb21wdXRlU2VyaWVzUmVjdChzaHJpbmtSZWN0KTtcbiAgICBhd2FpdCB0aGlzLmNvbXB1dGVDaXJjbGUoc2hyaW5rUmVjdCk7XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IGF4aXMudXBkYXRlKCkpO1xuICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZSh7XG4gICAgICB0eXBlOiBcImxheW91dC1jb21wbGV0ZVwiLFxuICAgICAgY2hhcnQ6IHsgd2lkdGg6IHRoaXMuY3R4LnNjZW5lLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3R4LnNjZW5lLmhlaWdodCB9LFxuICAgICAgY2xpcFNlcmllczogZmFsc2UsXG4gICAgICBzZXJpZXM6IHsgcmVjdDogZnVsbFNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IHNocmlua1JlY3QsIHZpc2libGU6IHRydWUgfSxcbiAgICAgIGF4ZXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHNocmlua1JlY3Q7XG4gIH1cbiAgdXBkYXRlQXhlcyhjeCwgY3ksIHJhZGl1cykge1xuICAgIGNvbnN0IGFuZ2xlQXhpcyA9IHRoaXMuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyk7XG4gICAgY29uc3QgcmFkaXVzQXhpcyA9IHRoaXMuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLyk7XG4gICAgaWYgKCEoYW5nbGVBeGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzKSB8fCAhKHJhZGl1c0F4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuZ2xlU2NhbGUgPSBhbmdsZUF4aXMuc2NhbGU7XG4gICAgY29uc3QgYW5nbGVzID0gYW5nbGVTY2FsZS50aWNrcz8uKCkubWFwKCh2YWx1ZSkgPT4gYW5nbGVTY2FsZS5jb252ZXJ0KHZhbHVlKSk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXNSYXRpbyA9IHJhZGl1c0F4aXMuaW5uZXJSYWRpdXNSYXRpbztcbiAgICBhbmdsZUF4aXMuaW5uZXJSYWRpdXNSYXRpbyA9IGlubmVyUmFkaXVzUmF0aW87XG4gICAgYW5nbGVBeGlzLmNvbXB1dGVSYW5nZT8uKCk7XG4gICAgYW5nbGVBeGlzLmdyaWRMZW5ndGggPSByYWRpdXM7XG4gICAgcmFkaXVzQXhpcy5ncmlkQW5nbGVzID0gYW5nbGVzO1xuICAgIHJhZGl1c0F4aXMuZ3JpZFJhbmdlID0gYW5nbGVBeGlzLnJhbmdlO1xuICAgIHJhZGl1c0F4aXMucmFuZ2UgPSBbcmFkaXVzLCByYWRpdXMgKiBpbm5lclJhZGl1c1JhdGlvXTtcbiAgICBbYW5nbGVBeGlzLCByYWRpdXNBeGlzXS5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uLnggPSBjeDtcbiAgICAgIGF4aXMudHJhbnNsYXRpb24ueSA9IGN5O1xuICAgICAgYXhpcy5jYWxjdWxhdGVMYXlvdXQoKTtcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlU2VyaWVzUmVjdChzaHJpbmtSZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VyaWVzQXJlYTogeyBwYWRkaW5nIH1cbiAgICB9ID0gdGhpcztcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmxlZnQsIFwibGVmdFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgXCJ0b3BcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5yaWdodCwgXCJyaWdodFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmJvdHRvbSwgXCJib3R0b21cIik7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gc2hyaW5rUmVjdDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBzaHJpbmtSZWN0O1xuICB9XG4gIGFzeW5jIGNvbXB1dGVDaXJjbGUoc2VyaWVzQm94KSB7XG4gICAgY29uc3QgcG9sYXJTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHNlcmllcykgPT4ge1xuICAgICAgcmV0dXJuIHNlcmllcyBpbnN0YW5jZW9mIFBvbGFyU2VyaWVzO1xuICAgIH0pO1xuICAgIGNvbnN0IHBvbGFyQXhlcyA9IHRoaXMuYXhlcy5maWx0ZXIoKGF4aXMpID0+IHtcbiAgICAgIHJldHVybiBheGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzO1xuICAgIH0pO1xuICAgIGNvbnN0IHNldFNlcmllc0NpcmNsZSA9IChjeCwgY3ksIHIpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlQXhlcyhjeCwgY3ksIHIpO1xuICAgICAgcG9sYXJTZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICAgIHNlcmllcy5jZW50ZXJYID0gY3g7XG4gICAgICAgIHNlcmllcy5jZW50ZXJZID0gY3k7XG4gICAgICAgIHNlcmllcy5yYWRpdXMgPSByO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwaWVTZXJpZXMgPSBwb2xhclNlcmllcy5maWx0ZXIoKHMpID0+IHMudHlwZSA9PT0gXCJkb251dFwiIHx8IHMudHlwZSA9PT0gXCJwaWVcIik7XG4gICAgICBpZiAocGllU2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpaSA9IHBpZVNlcmllcy5tYXAoKHNlcmllcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gc2VyaWVzLmdldElubmVyUmFkaXVzKCk7XG4gICAgICAgICAgcmV0dXJuIHsgc2VyaWVzLCBpbm5lclJhZGl1cyB9O1xuICAgICAgICB9KS5zb3J0KChhLCBiKSA9PiBhLmlubmVyUmFkaXVzIC0gYi5pbm5lclJhZGl1cyk7XG4gICAgICAgIGlubmVyUmFkaWkuYXQoLTEpLnNlcmllcy5zdXJyb3VuZGluZ1JhZGl1cyA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lclJhZGlpLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGlubmVyUmFkaWlbaV0uc2VyaWVzLnN1cnJvdW5kaW5nUmFkaXVzID0gaW5uZXJSYWRpaVtpICsgMV0uaW5uZXJSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNlbnRlclggPSBzZXJpZXNCb3gueCArIHNlcmllc0JveC53aWR0aCAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNlcmllc0JveC55ICsgc2VyaWVzQm94LmhlaWdodCAvIDI7XG4gICAgY29uc3QgaW5pdGlhbFJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlcmllc0JveC53aWR0aCwgc2VyaWVzQm94LmhlaWdodCkgLyAyKTtcbiAgICBsZXQgcmFkaXVzID0gaW5pdGlhbFJhZGl1cztcbiAgICBzZXRTZXJpZXNDaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKTtcbiAgICBjb25zdCBzaGFrZSA9IGFzeW5jICh7IGhpZGVXaGVuTmVjZXNzYXJ5ID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBsYWJlbEJveGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBbLi4ucG9sYXJBeGVzLCAuLi5wb2xhclNlcmllc10pIHtcbiAgICAgICAgY29uc3QgYm94ID0gYXdhaXQgc2VyaWVzLmNvbXB1dGVMYWJlbHNCQm94KHsgaGlkZVdoZW5OZWNlc3NhcnkgfSwgc2VyaWVzQm94KTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxCb3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2V0U2VyaWVzQ2lyY2xlKGNlbnRlclgsIGNlbnRlclksIGluaXRpYWxSYWRpdXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbEJveCA9IEJCb3gubWVyZ2UobGFiZWxCb3hlcyk7XG4gICAgICBjb25zdCByZWZpbmVkID0gdGhpcy5yZWZpbmVDaXJjbGUobGFiZWxCb3gsIHJhZGl1cywgc2VyaWVzQm94KTtcbiAgICAgIHNldFNlcmllc0NpcmNsZShyZWZpbmVkLmNlbnRlclgsIHJlZmluZWQuY2VudGVyWSwgcmVmaW5lZC5yYWRpdXMpO1xuICAgICAgaWYgKHJlZmluZWQucmFkaXVzID09PSByYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmFkaXVzID0gcmVmaW5lZC5yYWRpdXM7XG4gICAgfTtcbiAgICBhd2FpdCBzaGFrZSgpO1xuICAgIGF3YWl0IHNoYWtlKCk7XG4gICAgYXdhaXQgc2hha2UoKTtcbiAgICBhd2FpdCBzaGFrZSh7IGhpZGVXaGVuTmVjZXNzYXJ5OiB0cnVlIH0pO1xuICAgIGF3YWl0IHNoYWtlKHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSk7XG4gICAgcmV0dXJuIHsgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZIH07XG4gIH1cbiAgcmVmaW5lQ2lyY2xlKGxhYmVsc0JveCwgcmFkaXVzLCBzZXJpZXNCb3gpIHtcbiAgICBjb25zdCBtaW5DaXJjbGVSYXRpbyA9IDAuNTtcbiAgICBjb25zdCBjaXJjbGVMZWZ0ID0gLXJhZGl1cztcbiAgICBjb25zdCBjaXJjbGVUb3AgPSAtcmFkaXVzO1xuICAgIGNvbnN0IGNpcmNsZVJpZ2h0ID0gcmFkaXVzO1xuICAgIGNvbnN0IGNpcmNsZUJvdHRvbSA9IHJhZGl1cztcbiAgICBsZXQgcGFkTGVmdCA9IE1hdGgubWF4KDAsIGNpcmNsZUxlZnQgLSBsYWJlbHNCb3gueCk7XG4gICAgbGV0IHBhZFRvcCA9IE1hdGgubWF4KDAsIGNpcmNsZVRvcCAtIGxhYmVsc0JveC55KTtcbiAgICBsZXQgcGFkUmlnaHQgPSBNYXRoLm1heCgwLCBsYWJlbHNCb3gueCArIGxhYmVsc0JveC53aWR0aCAtIGNpcmNsZVJpZ2h0KTtcbiAgICBsZXQgcGFkQm90dG9tID0gTWF0aC5tYXgoMCwgbGFiZWxzQm94LnkgKyBsYWJlbHNCb3guaGVpZ2h0IC0gY2lyY2xlQm90dG9tKTtcbiAgICBwYWRMZWZ0ID0gcGFkUmlnaHQgPSBNYXRoLm1heChwYWRMZWZ0LCBwYWRSaWdodCk7XG4gICAgcGFkVG9wID0gcGFkQm90dG9tID0gTWF0aC5tYXgocGFkVG9wLCBwYWRCb3R0b20pO1xuICAgIGNvbnN0IGF2YWlsQ2lyY2xlV2lkdGggPSBzZXJpZXNCb3gud2lkdGggLSBwYWRMZWZ0IC0gcGFkUmlnaHQ7XG4gICAgY29uc3QgYXZhaWxDaXJjbGVIZWlnaHQgPSBzZXJpZXNCb3guaGVpZ2h0IC0gcGFkVG9wIC0gcGFkQm90dG9tO1xuICAgIGxldCBuZXdSYWRpdXMgPSBNYXRoLm1pbihhdmFpbENpcmNsZVdpZHRoLCBhdmFpbENpcmNsZUhlaWdodCkgLyAyO1xuICAgIGNvbnN0IG1pbkhvcml6b250YWxSYWRpdXMgPSBtaW5DaXJjbGVSYXRpbyAqIHNlcmllc0JveC53aWR0aCAvIDI7XG4gICAgY29uc3QgbWluVmVydGljYWxSYWRpdXMgPSBtaW5DaXJjbGVSYXRpbyAqIHNlcmllc0JveC5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IG1pblJhZGl1cyA9IE1hdGgubWluKG1pbkhvcml6b250YWxSYWRpdXMsIG1pblZlcnRpY2FsUmFkaXVzKTtcbiAgICBpZiAobmV3UmFkaXVzIDwgbWluUmFkaXVzKSB7XG4gICAgICBuZXdSYWRpdXMgPSBtaW5SYWRpdXM7XG4gICAgICBjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IHBhZExlZnQgKyBwYWRSaWdodDtcbiAgICAgIGNvbnN0IHZlcnRpY2FsUGFkZGluZyA9IHBhZFRvcCArIHBhZEJvdHRvbTtcbiAgICAgIGlmICgyICogbmV3UmFkaXVzICsgdmVydGljYWxQYWRkaW5nID4gc2VyaWVzQm94LmhlaWdodCkge1xuICAgICAgICBjb25zdCBwYWRIZWlnaHQgPSBzZXJpZXNCb3guaGVpZ2h0IC0gMiAqIG5ld1JhZGl1cztcbiAgICAgICAgaWYgKE1hdGgubWluKHBhZFRvcCwgcGFkQm90dG9tKSAqIDIgPiBwYWRIZWlnaHQpIHtcbiAgICAgICAgICBwYWRUb3AgPSBwYWRIZWlnaHQgLyAyO1xuICAgICAgICAgIHBhZEJvdHRvbSA9IHBhZEhlaWdodCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGFkVG9wID4gcGFkQm90dG9tKSB7XG4gICAgICAgICAgcGFkVG9wID0gcGFkSGVpZ2h0IC0gcGFkQm90dG9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZEJvdHRvbSA9IHBhZEhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKDIgKiBuZXdSYWRpdXMgKyBob3Jpem9udGFsUGFkZGluZyA+IHNlcmllc0JveC53aWR0aCkge1xuICAgICAgICBjb25zdCBwYWRXaWR0aCA9IHNlcmllc0JveC53aWR0aCAtIDIgKiBuZXdSYWRpdXM7XG4gICAgICAgIGlmIChNYXRoLm1pbihwYWRMZWZ0LCBwYWRSaWdodCkgKiAyID4gcGFkV2lkdGgpIHtcbiAgICAgICAgICBwYWRMZWZ0ID0gcGFkV2lkdGggLyAyO1xuICAgICAgICAgIHBhZFJpZ2h0ID0gcGFkV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBhZExlZnQgPiBwYWRSaWdodCkge1xuICAgICAgICAgIHBhZExlZnQgPSBwYWRXaWR0aCAtIHBhZFJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZFJpZ2h0ID0gcGFkV2lkdGggLSBwYWRMZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gcGFkTGVmdCArIDIgKiBuZXdSYWRpdXMgKyBwYWRSaWdodDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBwYWRUb3AgKyAyICogbmV3UmFkaXVzICsgcGFkQm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXJYOiBzZXJpZXNCb3gueCArIChzZXJpZXNCb3gud2lkdGggLSBuZXdXaWR0aCkgLyAyICsgcGFkTGVmdCArIG5ld1JhZGl1cyxcbiAgICAgIGNlbnRlclk6IHNlcmllc0JveC55ICsgKHNlcmllc0JveC5oZWlnaHQgLSBuZXdIZWlnaHQpIC8gMiArIHBhZFRvcCArIG5ld1JhZGl1cyxcbiAgICAgIHJhZGl1czogbmV3UmFkaXVzXG4gICAgfTtcbiAgfVxufTtcblBvbGFyQ2hhcnQuY2xhc3NOYW1lID0gXCJQb2xhckNoYXJ0XCI7XG5Qb2xhckNoYXJ0LnR5cGUgPSBcInBvbGFyXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy90b3BvbG9neS9tZXJjYXRvclNjYWxlLnRzXG52YXIgcmFkc0luRGVnID0gTWF0aC5QSSAvIDE4MDtcbnZhciBsb25YID0gKGxvbikgPT4gbG9uICogcmFkc0luRGVnO1xudmFyIGxhdFkgPSAobGF0KSA9PiAtTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAqIDAuMjUgKyBsYXQgKiByYWRzSW5EZWcgKiAwLjUpKTtcbnZhciB4TG9uID0gKHgpID0+IHggLyByYWRzSW5EZWc7XG52YXIgeUxhdCA9ICh5KSA9PiAoTWF0aC5hdGFuKE1hdGguZXhwKC15KSkgLSBNYXRoLlBJICogMC4yNSkgLyAocmFkc0luRGVnICogMC41KTtcbnZhciBNZXJjYXRvclNjYWxlID0gY2xhc3MgX01lcmNhdG9yU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihkb21haW4sIHJhbmdlMykge1xuICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTM7XG4gICAgdGhpcy50eXBlID0gXCJtZXJjYXRvclwiO1xuICAgIHRoaXMuYm91bmRzID0gX01lcmNhdG9yU2NhbGUuYm91bmRzKGRvbWFpbik7XG4gIH1cbiAgc3RhdGljIGJvdW5kcyhkb21haW4pIHtcbiAgICBjb25zdCBbW2xvbjAsIGxhdDBdLCBbbG9uMSwgbGF0MV1dID0gZG9tYWluO1xuICAgIGNvbnN0IHgwID0gbG9uWChsb24wKTtcbiAgICBjb25zdCB5MCA9IGxhdFkobGF0MCk7XG4gICAgY29uc3QgeDEgPSBsb25YKGxvbjEpO1xuICAgIGNvbnN0IHkxID0gbGF0WShsYXQxKTtcbiAgICByZXR1cm4gbmV3IEJCb3goTWF0aC5taW4oeDAsIHgxKSwgTWF0aC5taW4oeTAsIHkxKSwgTWF0aC5hYnMoeDEgLSB4MCksIE1hdGguYWJzKHkxIC0geTApKTtcbiAgfVxuICBzdGF0aWMgZml4ZWRTY2FsZSgpIHtcbiAgICByZXR1cm4gbmV3IF9NZXJjYXRvclNjYWxlKFxuICAgICAgW1xuICAgICAgICBbeExvbigwKSwgeUxhdCgwKV0sXG4gICAgICAgIFt4TG9uKDEpLCB5TGF0KDEpXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMSwgMV1cbiAgICAgIF1cbiAgICApO1xuICB9XG4gIGNvbnZlcnQoW2xvbiwgbGF0XSkge1xuICAgIGNvbnN0IFtbeDAsIHkwXSwgW3gxLCB5MV1dID0gdGhpcy5yYW5nZTtcbiAgICBjb25zdCB4U2NhbGUgPSAoeDEgLSB4MCkgLyB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSAoeTEgLSB5MCkgLyB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIFsobG9uWChsb24pIC0gdGhpcy5ib3VuZHMueCkgKiB4U2NhbGUgKyB4MCwgKGxhdFkobGF0KSAtIHRoaXMuYm91bmRzLnkpICogeVNjYWxlICsgeTBdO1xuICB9XG4gIGludmVydChbeCwgeV0pIHtcbiAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IHRoaXMucmFuZ2U7XG4gICAgY29uc3QgeFNjYWxlID0gKHgxIC0geDApIC8gdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gKHkxIC0geTApIC8gdGhpcy5ib3VuZHMuaGVpZ2h0O1xuICAgIHJldHVybiBbeExvbigoeCAtIHgwKSAvIHhTY2FsZSArIHRoaXMuYm91bmRzLngpLCB5TGF0KCh5IC0geTApIC8geVNjYWxlICsgdGhpcy5ib3VuZHMueSldO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b3BvbG9neUNoYXJ0LnRzXG5mdW5jdGlvbiBpc1RvcG9sb2d5U2VyaWVzKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzLnR5cGUgPT09IFwibWFwLXNoYXBlXCIgfHwgc2VyaWVzLnR5cGUgPT09IFwibWFwLWxpbmVcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtbWFya2VyXCIgfHwgc2VyaWVzLnR5cGUgPT09IFwibWFwLXNoYXBlLWJhY2tncm91bmRcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCI7XG59XG52YXIgVG9wb2xvZ3lDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIHRoaXMueEF4aXMgPSBuZXcgTnVtYmVyQXhpcyh0aGlzLmdldE1vZHVsZUNvbnRleHQoKSk7XG4gICAgdGhpcy54QXhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy55QXhpcyA9IG5ldyBOdW1iZXJBeGlzKHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKTtcbiAgICB0aGlzLnlBeGlzLnBvc2l0aW9uID0gXCJsZWZ0XCI7XG4gICAgdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlQXhlcyhbdGhpcy54QXhpcywgdGhpcy55QXhpc10pO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJ0b3BvbG9neVwiO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdGEoKSB7XG4gICAgYXdhaXQgc3VwZXIudXBkYXRlRGF0YSgpO1xuICAgIGNvbnN0IHsgdG9wb2xvZ3kgfSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgaWYgKGlzVG9wb2xvZ3lTZXJpZXMoc2VyaWVzKSkge1xuICAgICAgICBzZXJpZXMuc2V0Q2hhcnRUb3BvbG9neSh0b3BvbG9neSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dCgpIHtcbiAgICBjb25zdCBzaHJpbmtSZWN0ID0gYXdhaXQgc3VwZXIucGVyZm9ybUxheW91dCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcmllc0FyZWE6IHsgcGFkZGluZyB9LFxuICAgICAgc2VyaWVzUm9vdCxcbiAgICAgIGFubm90YXRpb25Sb290LFxuICAgICAgaGlnaGxpZ2h0Um9vdFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZ1bGxTZXJpZXNSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcubGVmdCwgXCJsZWZ0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcudG9wLCBcInRvcFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCBcInJpZ2h0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcuYm90dG9tLCBcImJvdHRvbVwiKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzaHJpbmtSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgY29uc3QgbWFwU2VyaWVzID0gdGhpcy5zZXJpZXMuZmlsdGVyKGlzVG9wb2xvZ3lTZXJpZXMpO1xuICAgIGNvbnN0IGNvbWJpbmVkQmJveCA9IG1hcFNlcmllcy5yZWR1Y2UoKGNvbWJpbmVkLCBzZXJpZXMpID0+IHtcbiAgICAgIGlmICghc2VyaWVzLnZpc2libGUpXG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgIGNvbnN0IGJib3ggPSBzZXJpZXMudG9wb2xvZ3lCb3VuZHM7XG4gICAgICBpZiAoYmJveCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgICBpZiAoY29tYmluZWQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICBjb21iaW5lZC5tZXJnZShiYm94KTtcbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9LCB2b2lkIDApO1xuICAgIGxldCBzY2FsZTI7XG4gICAgaWYgKGNvbWJpbmVkQmJveCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IGxvbjAsIGxhdDAsIGxvbjEsIGxhdDEgfSA9IGNvbWJpbmVkQmJveDtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IFtcbiAgICAgICAgW2xvbjAsIGxhdDBdLFxuICAgICAgICBbbG9uMSwgbGF0MV1cbiAgICAgIF07XG4gICAgICBjb25zdCBib3VuZHMgPSBNZXJjYXRvclNjYWxlLmJvdW5kcyhkb21haW4pO1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzaHJpbmtSZWN0O1xuICAgICAgY29uc3Qgdmlld0JveFNjYWxlID0gTWF0aC5taW4od2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgY29uc3Qgdmlld0JveFdpZHRoID0gYm91bmRzLndpZHRoICogdmlld0JveFNjYWxlO1xuICAgICAgY29uc3Qgdmlld0JveEhlaWdodCA9IGJvdW5kcy5oZWlnaHQgKiB2aWV3Qm94U2NhbGU7XG4gICAgICBjb25zdCB2aWV3Qm94T3JpZ2luWCA9ICh3aWR0aCAtIHZpZXdCb3hXaWR0aCkgLyAyO1xuICAgICAgY29uc3Qgdmlld0JveE9yaWdpblkgPSAoaGVpZ2h0IC0gdmlld0JveEhlaWdodCkgLyAyO1xuICAgICAgY29uc3QgeDAgPSB2aWV3Qm94T3JpZ2luWDtcbiAgICAgIGNvbnN0IHkwID0gdmlld0JveE9yaWdpblk7XG4gICAgICBjb25zdCB4MSA9IHZpZXdCb3hPcmlnaW5YICsgdmlld0JveFdpZHRoO1xuICAgICAgY29uc3QgeTEgPSB2aWV3Qm94T3JpZ2luWSArIHZpZXdCb3hIZWlnaHQ7XG4gICAgICBjb25zdCB4Wm9vbSA9IHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmdldEF4aXNab29tKHRoaXMueEF4aXMuaWQpO1xuICAgICAgY29uc3QgeVpvb20gPSB0aGlzLmN0eC56b29tTWFuYWdlci5nZXRBeGlzWm9vbSh0aGlzLnlBeGlzLmlkKTtcbiAgICAgIGNvbnN0IHhTcGFuID0gKHgxIC0geDApIC8gKHhab29tLm1heCAtIHhab29tLm1pbik7XG4gICAgICBjb25zdCB4U3RhcnQgPSB4MCAtIHhTcGFuICogeFpvb20ubWluO1xuICAgICAgY29uc3QgeVNwYW4gPSAoeTEgLSB5MCkgLyAoMSAtIHlab29tLm1pbiAtICgxIC0geVpvb20ubWF4KSk7XG4gICAgICBjb25zdCB5U3RhcnQgPSB5MCAtIHlTcGFuICogKDEgLSB5Wm9vbS5tYXgpO1xuICAgICAgc2NhbGUyID0gbmV3IE1lcmNhdG9yU2NhbGUoZG9tYWluLCBbXG4gICAgICAgIFt4U3RhcnQsIHlTdGFydF0sXG4gICAgICAgIFt4U3RhcnQgKyB4U3BhbiwgeVN0YXJ0ICsgeVNwYW5dXG4gICAgICBdKTtcbiAgICB9XG4gICAgbWFwU2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnNjYWxlID0gc2NhbGUyO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlcmllc1Zpc2libGUgPSB0aGlzLnNlcmllcy5zb21lKChzKSA9PiBzLnZpc2libGUpO1xuICAgIHNlcmllc1Jvb3QudmlzaWJsZSA9IHNlcmllc1Zpc2libGU7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHNocmlua1JlY3QueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHNocmlua1JlY3QueSk7XG4gICAgICBncm91cC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoXG4gICAgICAgIG5ldyBCQm94KHNocmlua1JlY3QueCwgc2hyaW5rUmVjdC55LCBzaHJpbmtSZWN0LndpZHRoLCBzaHJpbmtSZWN0LmhlaWdodClcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZSh7XG4gICAgICB0eXBlOiBcImxheW91dC1jb21wbGV0ZVwiLFxuICAgICAgY2hhcnQ6IHsgd2lkdGg6IHRoaXMuY3R4LnNjZW5lLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3R4LnNjZW5lLmhlaWdodCB9LFxuICAgICAgY2xpcFNlcmllczogZmFsc2UsXG4gICAgICBzZXJpZXM6IHsgcmVjdDogZnVsbFNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IHNocmlua1JlY3QsIHZpc2libGU6IHNlcmllc1Zpc2libGUgfSxcbiAgICAgIGF4ZXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHNocmlua1JlY3Q7XG4gIH1cbn07XG5Ub3BvbG9neUNoYXJ0LmNsYXNzTmFtZSA9IFwiVG9wb2xvZ3lDaGFydFwiO1xuVG9wb2xvZ3lDaGFydC50eXBlID0gXCJ0b3BvbG9neVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvZW50ZXJwcmlzZU1vZHVsZS50c1xudmFyIGVudGVycHJpc2VNb2R1bGUgPSB7XG4gIGlzRW50ZXJwcmlzZTogZmFsc2Vcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvcHJpY2VWb2x1bWVQcmVzZXQudHNcbmZ1bmN0aW9uIGZyb21UaGVtZSh0aGVtZSwgY2IpIHtcbiAgaWYgKGlzT2JqZWN0KHRoZW1lKSkge1xuICAgIHJldHVybiBjYih0aGVtZSk7XG4gIH1cbn1cbnZhciBjaGFydFR5cGVzMiA9IFtcIm9obGNcIiwgXCJsaW5lXCIsIFwic3RlcC1saW5lXCIsIFwiaGxjXCIsIFwiaGlnaC1sb3dcIiwgXCJjYW5kbGVzdGlja1wiLCBcImhvbGxvdy1jYW5kbGVzdGlja1wiXTtcbmZ1bmN0aW9uIHByaWNlVm9sdW1lKG9wdHMsIGdldFRoZW1lKSB7XG4gIGNvbnN0IHtcbiAgICB4S2V5LFxuICAgIGRhdGVLZXkgPSB4S2V5ID8/IFwiZGF0ZVwiLFxuICAgIGhpZ2hLZXkgPSBcImhpZ2hcIixcbiAgICBvcGVuS2V5ID0gXCJvcGVuXCIsXG4gICAgbG93S2V5ID0gXCJsb3dcIixcbiAgICBjbG9zZUtleSA9IFwiY2xvc2VcIixcbiAgICB2b2x1bWVLZXkgPSBcInZvbHVtZVwiLFxuICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlMiA9IFwiY2FuZGxlc3RpY2tcIixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIgPSBmYWxzZSxcbiAgICB2b2x1bWUgPSB0cnVlLFxuICAgIHJhbmdlVG9vbGJhcixcbiAgICByYW5nZUJ1dHRvbnMgPSByYW5nZVRvb2xiYXIgPz8gdHJ1ZSxcbiAgICBzdGF0dXNCYXIgPSB0cnVlLFxuICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9uczIsXG4gICAgdG9vbGJhciA9IGFubm90YXRpb25zMiA/PyB0cnVlLFxuICAgIHpvb206IHpvb20yID0gdHJ1ZSxcbiAgICB0aGVtZSxcbiAgICBkYXRhLFxuICAgIC4uLnVudXNlZE9wdHNcbiAgfSA9IG9wdHM7XG4gIGlmICh4S2V5ICE9IG51bGwpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXCJQcm9wZXJ0eSBbeEtleV0gaXMgZGVwcmVjYXRlZCwgdXNlIFtkYXRlS2V5XSBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAocmFuZ2VUb29sYmFyICE9IG51bGwpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXCJQcm9wZXJ0eSBbcmFuZ2VUb29sYmFyXSBpcyBkZXByZWNhdGVkLCB1c2UgW3JhbmdlQnV0dG9uc10gaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKGFubm90YXRpb25zMiAhPSBudWxsKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFwiUHJvcGVydHkgW2Fubm90YXRpb25zXSBpcyBkZXByZWNhdGVkLCB1c2UgW3Rvb2xiYXJdIGluc3RlYWQuXCIpO1xuICB9XG4gIGNvbnN0IHByaWNlU2VyaWVzID0gY3JlYXRlUHJpY2VTZXJpZXModGhlbWUsIGNoYXJ0VHlwZTIsIGRhdGVLZXksIGhpZ2hLZXksIGxvd0tleSwgb3BlbktleSwgY2xvc2VLZXkpO1xuICBjb25zdCB2b2x1bWVTZXJpZXMgPSBjcmVhdGVWb2x1bWVTZXJpZXModGhlbWUsIGdldFRoZW1lLCBvcGVuS2V5LCBjbG9zZUtleSwgdm9sdW1lLCB2b2x1bWVLZXkpO1xuICBjb25zdCBtaW5pQ2hhcnQgPSB2b2x1bWUgPyB7XG4gICAgbWluaUNoYXJ0OiB7XG4gICAgICBlbmFibGVkOiBuYXZpZ2F0b3IyLFxuICAgICAgc2VyaWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICB4S2V5OiBkYXRlS2V5LFxuICAgICAgICAgIHlLZXk6IHZvbHVtZUtleSxcbiAgICAgICAgICBtYXJrZXI6IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3QgbmF2aWdhdG9yT3B0cyA9IHtcbiAgICBuYXZpZ2F0b3I6IHtcbiAgICAgIGVuYWJsZWQ6IG5hdmlnYXRvcjIsXG4gICAgICAuLi5taW5pQ2hhcnRcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXR1c0Jhck9wdHMgPSBzdGF0dXNCYXIgPyB7XG4gICAgc3RhdHVzQmFyOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZGF0YSxcbiAgICAgIGhpZ2hLZXksXG4gICAgICBvcGVuS2V5LFxuICAgICAgbG93S2V5LFxuICAgICAgY2xvc2VLZXksXG4gICAgICB2b2x1bWVLZXk6IHZvbHVtZSA/IHZvbHVtZUtleSA6IHZvaWQgMFxuICAgIH1cbiAgfSA6IG51bGw7XG4gIGNvbnN0IHpvb21PcHRzID0ge1xuICAgIHpvb206IHtcbiAgICAgIGVuYWJsZWQ6IHpvb20yLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgZW5hYmxlSW5kZXBlbmRlbnRBeGVzOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb25zdCB0b29sYmFyT3B0cyA9IHtcbiAgICBjaGFydFRvb2xiYXI6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgIHRvb2xiYXI6IHtcbiAgICAgIHNlcmllc1R5cGU6IHtcbiAgICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgICAgfSxcbiAgICAgIGFubm90YXRpb25PcHRpb25zOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRvb2xiYXJcbiAgICAgIH0sXG4gICAgICBhbm5vdGF0aW9uczoge1xuICAgICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgICB9LFxuICAgICAgcmFuZ2VzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHJhbmdlQnV0dG9uc1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgdm9sdW1lQXhpcyA9IHZvbHVtZSA/IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiLFxuICAgICAga2V5czogW3ZvbHVtZUtleV0sXG4gICAgICBsYWJlbDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgY3Jvc3NoYWlyOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBncmlkTGluZTogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgbmljZTogZmFsc2UsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBsYXlvdXRDb25zdHJhaW50czoge1xuICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IDIwLFxuICAgICAgICB1bml0OiBcInBlcmNlbnRhZ2VcIixcbiAgICAgICAgYWxpZ246IFwiZW5kXCJcbiAgICAgIH1cbiAgICB9XG4gIF0gOiBbXTtcbiAgcmV0dXJuIHtcbiAgICB0aGVtZTogdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiB7XG4gICAgICBiYXNlVGhlbWU6IFwiYWctZmluYW5jaWFsXCIsXG4gICAgICAuLi50aGVtZSA/PyB7fVxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgbGVnZW5kOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgc2VyaWVzOiBbLi4udm9sdW1lU2VyaWVzLCAuLi5wcmljZVNlcmllc10sXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiA2LFxuICAgICAgcmlnaHQ6IDgsXG4gICAgICBib3R0b206IDVcbiAgICB9LFxuICAgIGF4ZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgcG9zaXRpb246IFwicmlnaHRcIixcbiAgICAgICAga2V5czogW29wZW5LZXksIGNsb3NlS2V5LCBoaWdoS2V5LCBsb3dLZXldLFxuICAgICAgICBpbnRlcnZhbDoge1xuICAgICAgICAgIG1heFNwYWNpbmc6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5jb21tb24/LmF4ZXM/Lm51bWJlcj8uaW50ZXJ2YWw/Lm1heFNwYWNpbmcpID8/IDQ1XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZm9ybWF0OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uY29tbW9uPy5heGVzPy5udW1iZXI/LmxhYmVsPy5mb3JtYXQpID8/IFwiLjJmXCJcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBzbmFwOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGxheW91dENvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgc3RhY2tlZDogZmFsc2UsXG4gICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICB1bml0OiBcInBlcmNlbnRhZ2VcIixcbiAgICAgICAgICBhbGlnbjogXCJzdGFydFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAuLi52b2x1bWVBeGlzLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIm9yZGluYWwtdGltZVwiLFxuICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIixcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIGFubm90YXRpb25zOiB7XG4gICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgfSxcbiAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgZGF0YSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGl0bGVQYWRkaW5nOiA0LFxuICAgIC4uLm5hdmlnYXRvck9wdHMsXG4gICAgLi4uc3RhdHVzQmFyT3B0cyxcbiAgICAuLi56b29tT3B0cyxcbiAgICAuLi50b29sYmFyT3B0cyxcbiAgICAuLi51bnVzZWRPcHRzXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWb2x1bWVTZXJpZXModGhlbWUsIGdldFRoZW1lLCBvcGVuS2V5LCBjbG9zZUtleSwgdm9sdW1lLCB2b2x1bWVLZXkpIHtcbiAgaWYgKCF2b2x1bWUpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBiYXJTZXJpZXNGaWxsID0gZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmJhcj8uc2VyaWVzPy5maWxsKTtcbiAgY29uc3QgaXRlbVN0eWxlciA9IGJhclNlcmllc0ZpbGwgPyB7IGZpbGw6IGJhclNlcmllc0ZpbGwgfSA6IHtcbiAgICBpdGVtU3R5bGVyKHsgZGF0dW0gfSkge1xuICAgICAgY29uc3QgeyB1cCwgZG93biB9ID0gZ2V0VGhlbWUoKS5wYWxldHRlO1xuICAgICAgcmV0dXJuIHsgZmlsbDogZGF0dW1bb3BlbktleV0gPCBkYXR1bVtjbG9zZUtleV0gPyB1cD8uZmlsbCA6IGRvd24/LmZpbGwgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdHlwZTogXCJiYXJcIixcbiAgICAgIHhLZXk6IFwiZGF0ZVwiLFxuICAgICAgeUtleTogdm9sdW1lS2V5LFxuICAgICAgdG9vbHRpcDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGlnaGxpZ2h0OiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBmaWxsT3BhY2l0eTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmJhcj8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC41LFxuICAgICAgLi4uaXRlbVN0eWxlclxuICAgIH1cbiAgXTtcbn1cbnZhciBSQU5HRV9BUkVBX1RZUEUgPSBcInJhbmdlLWFyZWFcIjtcbmZ1bmN0aW9uIGNyZWF0ZVByaWNlU2VyaWVzKHRoZW1lLCBjaGFydFR5cGUyLCB4S2V5LCBoaWdoS2V5LCBsb3dLZXksIG9wZW5LZXksIGNsb3NlS2V5KSB7XG4gIGlmIChjaGFydFR5cGUyID09PSBSQU5HRV9BUkVBX1RZUEUpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7Y2hhcnRUeXBlMn0nIGlzIGRlcHJlY2F0ZWQsIHVzZSAnaGxjJyBjaGFydCB0eXBlIGluc3RlYWRgKTtcbiAgICBjaGFydFR5cGUyID0gXCJobGNcIjtcbiAgfVxuICBjb25zdCBrZXlzID0ge1xuICAgIHhLZXksXG4gICAgb3BlbktleSxcbiAgICBjbG9zZUtleSxcbiAgICBoaWdoS2V5LFxuICAgIGxvd0tleVxuICB9O1xuICBjb25zdCBzaW5nbGVLZXlzID0ge1xuICAgIHhLZXksXG4gICAgeUtleTogY2xvc2VLZXlcbiAgfTtcbiAgY29uc3QgY29tbW9uID0ge1xuICAgIHBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpczogdHJ1ZVxuICB9O1xuICBzd2l0Y2ggKGNoYXJ0VHlwZTIgPz8gXCJjYW5kbGVzdGlja1wiKSB7XG4gICAgY2FzZSBcIm9obGNcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIm9obGNcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5c1xuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLnNpbmdsZUtleXMsXG4gICAgICAgICAgc3Ryb2tlOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2UpID8/IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gICAgICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJzdGVwLWxpbmVcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgICAgICBzdHJva2U6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZSkgPz8gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5pbnRlcnBvbGF0aW9uKSA/PyB7XG4gICAgICAgICAgICB0eXBlOiBcInN0ZXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJobGNcIjpcbiAgICAgIGNvbnN0IHJhbmdlQXJlYUNvbG9ycyA9IGdldFRoZW1lQ29sb3JzKFJBTkdFX0FSRUFfVFlQRSwgdGhlbWUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFJBTkdFX0FSRUFfVFlQRSxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgeEtleSxcbiAgICAgICAgICB5SGlnaEtleTogaGlnaEtleSxcbiAgICAgICAgICB5TG93S2V5OiBjbG9zZUtleSxcbiAgICAgICAgICBmaWxsOiByYW5nZUFyZWFDb2xvcnMuZmlsbCA/PyBQQUxFVFRFX1VQX0ZJTEwsXG4gICAgICAgICAgc3Ryb2tlOiByYW5nZUFyZWFDb2xvcnMuc3Ryb2tlID8/IFBBTEVUVEVfVVBfU1RST0tFLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC4zLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5zdHJva2VXaWR0aCkgPz8gMlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogUkFOR0VfQVJFQV9UWVBFLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHlIaWdoS2V5OiBjbG9zZUtleSxcbiAgICAgICAgICB5TG93S2V5OiBsb3dLZXksXG4gICAgICAgICAgZmlsbDogcmFuZ2VBcmVhQ29sb3JzLmZpbGwgPz8gUEFMRVRURV9ET1dOX0ZJTEwsXG4gICAgICAgICAgc3Ryb2tlOiByYW5nZUFyZWFDb2xvcnMuc3Ryb2tlID8/IFBBTEVUVEVfRE9XTl9TVFJPS0UsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LmZpbGxPcGFjaXR5KSA/PyAwLjMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LnN0cm9rZVdpZHRoKSA/PyAyXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgICAgICBzdHJva2U6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZSkgPz8gUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZVdpZHRoKSA/PyAyLFxuICAgICAgICAgIG1hcmtlcjogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8ubWFya2VyKSA/PyB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiaGlnaC1sb3dcIjpcbiAgICAgIGNvbnN0IHJhbmdlQmFyQ29sb3JzID0gZ2V0VGhlbWVDb2xvcnMoXCJyYW5nZS1iYXJcIiwgdGhlbWUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwicmFuZ2UtYmFyXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIHhLZXksXG4gICAgICAgICAgeUhpZ2hLZXk6IGhpZ2hLZXksXG4gICAgICAgICAgeUxvd0tleTogbG93S2V5LFxuICAgICAgICAgIGZpbGw6IHJhbmdlQmFyQ29sb3JzLmZpbGwgPz8gUEFMRVRURV9ORVVUUkFMX0ZJTEwsXG4gICAgICAgICAgc3Ryb2tlOiByYW5nZUJhckNvbG9ycy5zdHJva2UgPz8gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICByYW5nZTogXCJuZWFyZXN0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImNhbmRsZXN0aWNrXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjYW5kbGVzdGlja1wiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImhvbGxvdy1jYW5kbGVzdGlja1wiOlxuICAgICAgY29uc3QgaXRlbSA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5jYW5kbGVzdGljaz8uc2VyaWVzPy5pdGVtKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgdXA6IHtcbiAgICAgICAgICAgICAgZmlsbDogaXRlbT8udXA/LmZpbGwgPz8gXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGRlZmF1bHQ6XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYHVua25vd24gY2hhcnQgdHlwZTogJHtjaGFydFR5cGUyfTsgZXhwZWN0ZWQgb25lIG9mOiAke2NoYXJ0VHlwZXMyLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLmtleXNcbiAgICAgICAgfVxuICAgICAgXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGhlbWVDb2xvcnMoc2VyaWVzVHlwZTIsIHRoZW1lKSB7XG4gIGNvbnN0IGZpbGwgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW3Nlcmllc1R5cGUyXT8uc2VyaWVzPy5maWxsKTtcbiAgY29uc3Qgc3Ryb2tlID0gZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltzZXJpZXNUeXBlMl0/LnNlcmllcz8uc3Ryb2tlKTtcbiAgcmV0dXJuIHsgZmlsbCwgc3Ryb2tlIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvcHJlc2V0cy50c1xudmFyIFBSRVNFVFMgPSB7XG4gIFwicHJpY2Utdm9sdW1lXCI6IHByaWNlVm9sdW1lXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3Byb2Nlc3NFbnRlcnByaXNlT3B0aW9ucy50c1xuZnVuY3Rpb24gcmVtb3ZlVXNlZEVudGVycHJpc2VPcHRpb25zKG9wdGlvbnMsIHNpbGVudCkge1xuICBjb25zdCB1c2VkT3B0aW9ucyA9IFtdO1xuICBjb25zdCBvcHRpb25zQ2hhcnRUeXBlID0gY2hhcnRUeXBlcy5nZXQob3B0aW9uc1R5cGUob3B0aW9ucykpO1xuICBmb3IgKGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0VHlwZXM6IG1vZHVsZUNoYXJ0VHlwZXMsXG4gICAgb3B0aW9uc0tleSxcbiAgICBvcHRpb25zSW5uZXJLZXksXG4gICAgaWRlbnRpZmllclxuICB9IG9mIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUykge1xuICAgIGlmIChvcHRpb25zQ2hhcnRUeXBlICE9PSBcInVua25vd25cIiAmJiAhbW9kdWxlQ2hhcnRUeXBlcy5pbmNsdWRlcyhvcHRpb25zQ2hhcnRUeXBlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlID09PSBcInJvb3RcIiB8fCB0eXBlID09PSBcImxlZ2VuZFwiKSB7XG4gICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbnNbb3B0aW9uc0tleV07XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIW9wdGlvbnNJbm5lcktleSkge1xuICAgICAgICB1c2VkT3B0aW9ucy5wdXNoKG9wdGlvbnNLZXkpO1xuICAgICAgICBkZWxldGUgb3B0aW9uc1tvcHRpb25zS2V5XTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uVmFsdWVbb3B0aW9uc0lubmVyS2V5XSkge1xuICAgICAgICB1c2VkT3B0aW9ucy5wdXNoKGAke29wdGlvbnNLZXl9LiR7b3B0aW9uc0lubmVyS2V5fWApO1xuICAgICAgICBkZWxldGUgb3B0aW9uVmFsdWVbb3B0aW9uc0lubmVyS2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYXhpc1wiKSB7XG4gICAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSB8fCAhb3B0aW9ucy5heGVzPy5zb21lKChheGlzKSA9PiBheGlzLnR5cGUgPT09IGlkZW50aWZpZXIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXNbdHlwZT0ke2lkZW50aWZpZXJ9XWApO1xuICAgICAgb3B0aW9ucy5heGVzID0gb3B0aW9ucy5heGVzLmZpbHRlcigoYXhpcykgPT4gYXhpcy50eXBlICE9PSBpZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYXhpcy1vcHRpb25cIikge1xuICAgICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykgfHwgIW9wdGlvbnMuYXhlcz8uc29tZSgoYXhpcykgPT4gYXhpc1tvcHRpb25zS2V5XSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgYXhpcy4ke29wdGlvbnNLZXl9YCk7XG4gICAgICBvcHRpb25zLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgICBpZiAoYXhpc1tvcHRpb25zS2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBheGlzW29wdGlvbnNLZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2VyaWVzXCIpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zZXJpZXM/LnNvbWUoKHNlcmllcykgPT4gc2VyaWVzLnR5cGUgPT09IGlkZW50aWZpZXIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYHNlcmllc1t0eXBlPSR7aWRlbnRpZmllcn1dYCk7XG4gICAgICBvcHRpb25zLnNlcmllcyA9IG9wdGlvbnMuc2VyaWVzLmZpbHRlcigoc2VyaWVzKSA9PiBzZXJpZXMudHlwZSAhPT0gaWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInNlcmllcy1vcHRpb25cIikge1xuICAgICAgaWYgKCFvcHRpb25zLnNlcmllcz8uc29tZSgoc2VyaWVzKSA9PiBzZXJpZXNbb3B0aW9uc0tleV0pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYHNlcmllcy4ke29wdGlvbnNLZXl9YCk7XG4gICAgICBvcHRpb25zLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgICAgaWYgKHNlcmllc1tvcHRpb25zS2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBzZXJpZXNbb3B0aW9uc0tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodXNlZE9wdGlvbnMubGVuZ3RoICYmICFzaWxlbnQpIHtcbiAgICBsZXQgZW50ZXJwcmlzZVBhY2thZ2VOYW1lID0gXCJhZy1jaGFydHMtZW50ZXJwcmlzZVwiO1xuICAgIGxldCBlbnRlcnByaXNlUmVmZXJlbmNlVXJsID0gXCJodHRwczovL2NoYXJ0cy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0L2luc3RhbGxhdGlvbi9cIjtcbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSBcImludGVncmF0ZWRcIikge1xuICAgICAgZW50ZXJwcmlzZVBhY2thZ2VOYW1lID0gXCJhZy1ncmlkLWNoYXJ0cy1lbnRlcnByaXNlJyBvciAnYWctZ3JpZC1lbnRlcnByaXNlL2NoYXJ0cy1lbnRlcnByaXNlXCI7XG4gICAgICBlbnRlcnByaXNlUmVmZXJlbmNlVXJsID0gXCJodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9pbnRlZ3JhdGVkLWNoYXJ0cy1pbnN0YWxsYXRpb24vXCI7XG4gICAgfVxuICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgIFtcbiAgICAgICAgYHVuYWJsZSB0byB1c2UgdGhlc2UgZW50ZXJwcmlzZSBmZWF0dXJlcyBhcyAnJHtlbnRlcnByaXNlUGFja2FnZU5hbWV9JyBoYXMgbm90IGJlZW4gbG9hZGVkOmAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIC4uLnVzZWRPcHRpb25zLFxuICAgICAgICBcIlwiLFxuICAgICAgICBgU2VlOiAke2VudGVycHJpc2VSZWZlcmVuY2VVcmx9YFxuICAgICAgXS5qb2luKFwiXFxuXCIpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3N0cmluZy51dGlsLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoID0gSW5maW5pdHkpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGgpfS4uLiAoKyR7dmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RofSBjaGFyYWN0ZXJzKWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92YWxpZGF0ZS50c1xudmFyIGRlc2NyaXB0aW9uU3ltYm9sID0gU3ltYm9sKFwiZGVzY3JpcHRpb25cIik7XG52YXIgcmVxdWlyZWRTeW1ib2wgPSBTeW1ib2woXCJyZXF1aXJlZFwiKTtcbmZ1bmN0aW9uIGlzVmFsaWQob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGgpIHtcbiAgY29uc3QgeyBlcnJvcnMgfSA9IHZhbGlkYXRlKG9wdGlvbnMsIG9wdGlvbnNEZWZzLCBwYXRoKTtcbiAgZm9yIChjb25zdCB7IG1lc3NhZ2UgfSBvZiBlcnJvcnMpIHtcbiAgICBMb2dnZXIud2FybihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZShwYXRoLCB2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gaXNTdHJpbmcodmFsaWRhdG9yT3JEZWZzKSA/IHZhbGlkYXRvck9yRGVmcyA6IHZhbGlkYXRvck9yRGVmc1tkZXNjcmlwdGlvblN5bWJvbF07XG4gIGNvbnN0IGV4cGVjdGluZyA9IGRlc2NyaXB0aW9uID8gYDsgZXhwZWN0aW5nICR7ZGVzY3JpcHRpb259YCA6IFwiXCI7XG4gIGNvbnN0IHByZWZpeCA9IHBhdGggPyBgT3B0aW9uIFxcYCR7cGF0aH1cXGBgIDogXCJWYWx1ZVwiO1xuICByZXR1cm4gYCR7cHJlZml4fSBjYW5ub3QgYmUgc2V0IHRvIFxcYCR7c3RyaW5naWZ5VmFsdWUodmFsdWUpfVxcYCR7ZXhwZWN0aW5nfSwgaWdub3JpbmcuYDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMsIG9wdGlvbnNEZWZzLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiBudWxsLFxuICAgICAgZXJyb3JzOiBbeyBwYXRoLCB2YWx1ZTogb3B0aW9ucywgbWVzc2FnZTogdmFsaWRhdGVNZXNzYWdlKHBhdGgsIG9wdGlvbnMsIFwiYW4gb2JqZWN0XCIpIH1dXG4gICAgfTtcbiAgfVxuICBjb25zdCBvcHRpb25zS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMob3B0aW9ucykpO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgdmFsaWQgPSB7fTtcbiAgZnVuY3Rpb24gZXh0ZW5kUGF0aChrZXkpIHtcbiAgICBpZiAoaXNBcnJheShvcHRpb25zRGVmcykpIHtcbiAgICAgIHJldHVybiBgJHtwYXRofVske2tleX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5O1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdG9yT3JEZWZzXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zRGVmcykpIHtcbiAgICBvcHRpb25zS2V5cy5kZWxldGUoa2V5KTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAoIXZhbGlkYXRvck9yRGVmc1tyZXF1aXJlZFN5bWJvbF0gJiYgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yT3JEZWZzKSkge1xuICAgICAgaWYgKHZhbGlkYXRvck9yRGVmcyh2YWx1ZSkpIHtcbiAgICAgICAgdmFsaWRba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnB1c2goeyBrZXksIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiB2YWxpZGF0ZU1lc3NhZ2UoZXh0ZW5kUGF0aChrZXkpLCB2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzKSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHZhbGlkYXRvck9yRGVmcywgZXh0ZW5kUGF0aChrZXkpKTtcbiAgICAgIHZhbGlkW2tleV0gPSBuZXN0ZWRSZXN1bHQudmFsaWQ7XG4gICAgICBlcnJvcnMucHVzaCguLi5uZXN0ZWRSZXN1bHQuZXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBwYXRoLFxuICAgICAgdW5rbm93bjogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGBVbmtub3duIG9wdGlvbiBcXGAke2V4dGVuZFBhdGgoa2V5KX1cXGAsIGlnbm9yaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4geyB2YWxpZCwgZXJyb3JzIH07XG59XG5mdW5jdGlvbiBhdHRhY2hEZXNjcmlwdGlvbih2YWxpZGF0b3IsIGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKCh2YWx1ZSkgPT4gdmFsaWRhdG9yKHZhbHVlKSwgeyBbZGVzY3JpcHRpb25TeW1ib2xdOiBkZXNjcmlwdGlvbiB9KTtcbn1cbnZhciBvciA9ICguLi52YWxpZGF0b3JzKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiB2YWxpZGF0b3JzLnNvbWUoKHZhbGlkYXRvcikgPT4gdmFsaWRhdG9yKHZhbHVlKSksXG4gIHZhbGlkYXRvcnMubWFwKCh2KSA9PiB2W2Rlc2NyaXB0aW9uU3ltYm9sXSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgb3IgXCIpXG4pO1xudmFyIGFycmF5ID0gYXR0YWNoRGVzY3JpcHRpb24oaXNBcnJheSwgXCJhbiBhcnJheVwiKTtcbnZhciBib29sZWFuID0gYXR0YWNoRGVzY3JpcHRpb24oaXNCb29sZWFuLCBcImEgYm9vbGVhblwiKTtcbnZhciBjYWxsYmFjayA9IGF0dGFjaERlc2NyaXB0aW9uKGlzRnVuY3Rpb24sIFwiYSBmdW5jdGlvblwiKTtcbnZhciBudW1iZXIgPSBhdHRhY2hEZXNjcmlwdGlvbihpc0Zpbml0ZU51bWJlciwgXCJhIG51bWJlclwiKTtcbnZhciBvYmplY3QgPSBhdHRhY2hEZXNjcmlwdGlvbihpc09iamVjdCwgXCJhbiBvYmplY3RcIik7XG52YXIgc3RyaW5nID0gYXR0YWNoRGVzY3JpcHRpb24oaXNTdHJpbmcsIFwiYSBzdHJpbmdcIik7XG52YXIgbnVtYmVyTWluID0gKG1pbiwgaW5jbHVzaXZlID0gdHJ1ZSkgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmICh2YWx1ZSA+IG1pbiB8fCBpbmNsdXNpdmUgJiYgdmFsdWUgPT09IG1pbiksXG4gIGBhIG51bWJlciBncmVhdGVyIHRoYW4gJHtpbmNsdXNpdmUgPyBcIm9yIGVxdWFsIHRvIFwiIDogXCJcIn0ke21pbn1gXG4pO1xudmFyIG51bWJlclJhbmdlID0gKG1pbiwgbWF4KSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heCxcbiAgYGEgbnVtYmVyIGJldHdlZW4gJHttaW59IGFuZCAke21heH0gaW5jbHVzaXZlYFxuKTtcbnZhciBwb3NpdGl2ZU51bWJlciA9IG51bWJlck1pbigwKTtcbnZhciBtaW5PbmVOdW1iZXIgPSBudW1iZXJNaW4oMSk7XG52YXIgcmF0aW8gPSBudW1iZXJSYW5nZSgwLCAxKTtcbnZhciBkZWdyZWUgPSBudW1iZXJSYW5nZSgwLCAzNjApO1xudmFyIGFycmF5T2YgPSAodmFsaWRhdG9yLCBkZXNjcmlwdGlvbikgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsaWRhdG9yKSxcbiAgZGVzY3JpcHRpb24gPz8gYCR7dmFsaWRhdG9yW2Rlc2NyaXB0aW9uU3ltYm9sXX0gYXJyYXlgXG4pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvY29yZU1vZHVsZXNUeXBlcy50c1xuZnVuY3Rpb24gcGFsZXR0ZVR5cGUocGFydGlhbCkge1xuICBpZiAocGFydGlhbD8udXAgfHwgcGFydGlhbD8uZG93biB8fCBwYXJ0aWFsPy5uZXV0cmFsKSB7XG4gICAgcmV0dXJuIFwidXNlci1mdWxsXCI7XG4gIH0gZWxzZSBpZiAocGFydGlhbD8uZmlsbHMgfHwgcGFydGlhbD8uc3Ryb2tlcykge1xuICAgIHJldHVybiBcInVzZXItaW5kZXhlZFwiO1xuICB9XG4gIHJldHVybiBcImluYnVpbHRcIjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2NoYXJ0VGhlbWUudHNcbnZhciBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCA9IFwid2hpdGVcIjtcbnZhciBDSEFSVF9UWVBFX0NPTkZJRyA9IHtcbiAgZ2V0IGNhcnRlc2lhbigpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5jYXJ0ZXNpYW5UeXBlcywgY29tbW9uT3B0aW9uczogW1wiem9vbVwiLCBcIm5hdmlnYXRvclwiXSB9O1xuICB9LFxuICBnZXQgcG9sYXIoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMucG9sYXJUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IGhpZXJhcmNoeSgpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5oaWVyYXJjaHlUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IHRvcG9sb2d5KCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLnRvcG9sb2d5VHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCBcImZsb3ctcHJvcG9ydGlvblwiKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmZsb3dQcm9wb3J0aW9uVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH1cbn07XG52YXIgQ0hBUlRfVFlQRV9TUEVDSUZJQ19DT01NT05fT1BUSU9OUyA9IE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpLnJlZHVjZSgociwgeyBjb21tb25PcHRpb25zIH0pID0+IHIuY29uY2F0KGNvbW1vbk9wdGlvbnMpLCBbXSk7XG52YXIgX0NoYXJ0VGhlbWUgPSBjbGFzcyBfQ2hhcnRUaGVtZSB7XG4gIHN0YXRpYyBnZXRBeGlzRGVmYXVsdHMob3ZlcnJpZGVEZWZhdWx0cykge1xuICAgIHJldHVybiBtZXJnZURlZmF1bHRzKG92ZXJyaWRlRGVmYXVsdHMsIHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIkF4aXMgVGl0bGVcIixcbiAgICAgICAgc3BhY2luZzogMjUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgICBmb250U2l6ZTogMTMgLyogTUVESVVNICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgICAgYXZvaWRDb2xsaXNpb25zOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZToge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0FYSVNfTElORV9DT0xPVVJcbiAgICAgIH0sXG4gICAgICB0aWNrOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0FYSVNfTElORV9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBncmlkTGluZToge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzdHlsZTogW3sgc3Ryb2tlOiBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIGxpbmVEYXNoOiBbXSB9XVxuICAgICAgfSxcbiAgICAgIGNyb3NzTGluZXM6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZpbGw6IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICAgICAgICBzdHJva2U6IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICAgICAgICBmaWxsT3BhY2l0eTogMC4xLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRDaGFydERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtaW5IZWlnaHQ6IDMwMCxcbiAgICAgIG1pbldpZHRoOiAzMDAsXG4gICAgICBiYWNrZ3JvdW5kOiB7IHZpc2libGU6IHRydWUsIGZpbGw6IERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIgfSxcbiAgICAgIHBhZGRpbmc6IHsgdG9wOiBERUZBVUxUX1BBRERJTkcsIHJpZ2h0OiBERUZBVUxUX1BBRERJTkcsIGJvdHRvbTogREVGQVVMVF9QQURESU5HLCBsZWZ0OiBERUZBVUxUX1BBRERJTkcgfSxcbiAgICAgIGtleWJvYXJkOiB7IGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIlRpdGxlXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgICBmb250U2l6ZTogMTcgLyogTEFSR0UgKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBzdWJ0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJTdWJ0aXRsZVwiLFxuICAgICAgICBzcGFjaW5nOiAyMCxcbiAgICAgICAgZm9udFNpemU6IDEzIC8qIE1FRElVTSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLFxuICAgICAgICB3cmFwcGluZzogXCJoeXBoZW5hdGVcIixcbiAgICAgICAgbGF5b3V0U3R5bGU6IERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsXG4gICAgICAgIHRleHRBbGlnbjogREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVFxuICAgICAgfSxcbiAgICAgIGZvb3Rub3RlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIkZvb3Rub3RlXCIsXG4gICAgICAgIHNwYWNpbmc6IDIwLFxuICAgICAgICBmb250U2l6ZTogMTMgLyogTUVESVVNICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogXCJyZ2IoMTQwLCAxNDAsIDE0MClcIixcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovLFxuICAgICAgICBzcGFjaW5nOiAzMCxcbiAgICAgICAgbGlzdGVuZXJzOiB7fSxcbiAgICAgICAgdG9nZ2xlU2VyaWVzOiB0cnVlLFxuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgcGFkZGluZ1g6IDE2LFxuICAgICAgICAgIHBhZGRpbmdZOiA4LFxuICAgICAgICAgIG1hcmtlcjogeyBzaXplOiAxNSwgcGFkZGluZzogOCB9LFxuICAgICAgICAgIHNob3dTZXJpZXNTdHJva2U6IHRydWUsXG4gICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBtYXJrZXI6IHsgc2l6ZTogMTIgfSxcbiAgICAgICAgICBhY3RpdmVTdHlsZTogeyBmaWxsOiBERUZBVUxUX0xBQkVMX0NPTE9VUiB9LFxuICAgICAgICAgIGluYWN0aXZlU3R5bGU6IHsgZmlsbDogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIgfSxcbiAgICAgICAgICBoaWdobGlnaHRTdHlsZTogeyBmaWxsOiBERUZBVUxUX0xBQkVMX0NPTE9VUiB9LFxuICAgICAgICAgIGxhYmVsOiB7IGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUiB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRhcmtUaGVtZTogSVNfREFSS19USEVNRSxcbiAgICAgICAgZGVsYXk6IDBcbiAgICAgIH0sXG4gICAgICBvdmVybGF5czogeyBkYXJrVGhlbWU6IElTX0RBUktfVEhFTUUgfSxcbiAgICAgIGxpc3RlbmVyczoge31cbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgb3ZlcnJpZGVzLCBwYWxldHRlIH0gPSBkZWVwQ2xvbmUob3B0aW9ucyk7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLmNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKHRoaXMuZ2V0RGVmYXVsdHMoKSk7XG4gICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgdGhpcy5tZXJnZU92ZXJyaWRlcyhkZWZhdWx0cywgb3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgY29uc3QgeyBmaWxscywgc3Ryb2tlcywgLi4ub3RoZXJDb2xvcnMgfSA9IHRoaXMuZ2V0RGVmYXVsdENvbG9ycygpO1xuICAgIHRoaXMucGFsZXR0ZSA9IG1lcmdlRGVmYXVsdHMocGFsZXR0ZSwge1xuICAgICAgZmlsbHM6IE9iamVjdC52YWx1ZXMoZmlsbHMpLFxuICAgICAgc3Ryb2tlczogT2JqZWN0LnZhbHVlcyhzdHJva2VzKSxcbiAgICAgIC4uLm90aGVyQ29sb3JzXG4gICAgfSk7XG4gICAgdGhpcy5wYWxldHRlVHlwZSA9IHBhbGV0dGVUeXBlKHBhbGV0dGUpO1xuICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmZyZWV6ZSh0aGlzLnRlbXBsYXRlVGhlbWUoZGVmYXVsdHMpKTtcbiAgfVxuICBtZXJnZU92ZXJyaWRlcyhkZWZhdWx0cywgb3ZlcnJpZGVzKSB7XG4gICAgZm9yIChjb25zdCB7IHNlcmllc1R5cGVzLCBjb21tb25PcHRpb25zIH0gb2YgT2JqZWN0LnZhbHVlcyhDSEFSVF9UWVBFX0NPTkZJRykpIHtcbiAgICAgIGNvbnN0IGNsZWFuZWRDb21tb24gPSB7IC4uLm92ZXJyaWRlcy5jb21tb24gfTtcbiAgICAgIGZvciAoY29uc3QgY29tbW9uS2V5IG9mIENIQVJUX1RZUEVfU1BFQ0lGSUNfQ09NTU9OX09QVElPTlMpIHtcbiAgICAgICAgaWYgKCFjb21tb25PcHRpb25zLmluY2x1ZGVzKGNvbW1vbktleSkpIHtcbiAgICAgICAgICBkZWxldGUgY2xlYW5lZENvbW1vbltjb21tb25LZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsZWFuZWRDb21tb24pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBzIG9mIHNlcmllc1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gcztcbiAgICAgICAgZGVmYXVsdHNbc2VyaWVzVHlwZTJdID0gbWVyZ2VEZWZhdWx0cyhjbGVhbmVkQ29tbW9uLCBkZWZhdWx0c1tzZXJpZXNUeXBlMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGFydFR5cGVzLnNlcmllc1R5cGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gcztcbiAgICAgIGlmIChvdmVycmlkZXNbc2VyaWVzVHlwZTJdKSB7XG4gICAgICAgIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSA9IG1lcmdlRGVmYXVsdHMob3ZlcnJpZGVzW3Nlcmllc1R5cGUyXSwgZGVmYXVsdHNbc2VyaWVzVHlwZTJdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVDaGFydENvbmZpZ1BlckNoYXJ0VHlwZShjb25maWcpIHtcbiAgICBmb3IgKGNvbnN0IFtuZXh0VHlwZSwgeyBzZXJpZXNUeXBlcyB9XSBvZiBPYmplY3QuZW50cmllcyhDSEFSVF9UWVBFX0NPTkZJRykpIHtcbiAgICAgIGNvbnN0IHR5cGVEZWZhdWx0cyA9IGNoYXJ0RGVmYXVsdHMuZ2V0KG5leHRUeXBlKTtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzVHlwZTIgb2Ygc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgY29uZmlnW3Nlcmllc1R5cGUyXSB8fCAoY29uZmlnW3Nlcmllc1R5cGUyXSA9IGRlZXBDbG9uZSh0eXBlRGVmYXVsdHMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBnZXREZWZhdWx0cygpIHtcbiAgICBjb25zdCBnZXRPdmVycmlkZXNCeVR5cGUgPSAoY2hhcnRUeXBlMiwgc2VyaWVzVHlwZXMpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgY29uc3QgY2hhcnRUeXBlRGVmYXVsdHMgPSB7XG4gICAgICAgIGF4ZXM6IHt9LFxuICAgICAgICAuLi5sZWdlbmRSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlcygpLFxuICAgICAgICAuLi50aGlzLmdldENoYXJ0RGVmYXVsdHMoKSxcbiAgICAgICAgLi4uY2hhcnREZWZhdWx0cy5nZXQoY2hhcnRUeXBlMilcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUyIG9mIHNlcmllc1R5cGVzKSB7XG4gICAgICAgIHJlc3VsdFtzZXJpZXNUeXBlMl0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICAgIHNlcmllc1JlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIpLFxuICAgICAgICAgIHJlc3VsdFtzZXJpZXNUeXBlMl0gPz8gZGVlcENsb25lKGNoYXJ0VHlwZURlZmF1bHRzKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCB7IGF4ZXMgfSA9IHJlc3VsdFtzZXJpZXNUeXBlMl07XG4gICAgICAgIGZvciAoY29uc3QgYXhpc1R5cGUgb2YgYXhpc1JlZ2lzdHJ5LmtleXMoKSkge1xuICAgICAgICAgIGF4ZXNbYXhpc1R5cGVdID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgICAgIGF4ZXNbYXhpc1R5cGVdLFxuICAgICAgICAgICAgYXhpc1JlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUpLFxuICAgICAgICAgICAgX0NoYXJ0VGhlbWUuY2FydGVzaWFuQXhpc0RlZmF1bHRbYXhpc1R5cGVdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBtZXJnZURlZmF1bHRzKFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwiY2FydGVzaWFuXCIsIGNoYXJ0VHlwZXMuY2FydGVzaWFuVHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwicG9sYXJcIiwgY2hhcnRUeXBlcy5wb2xhclR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImhpZXJhcmNoeVwiLCBjaGFydFR5cGVzLmhpZXJhcmNoeVR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcInRvcG9sb2d5XCIsIGNoYXJ0VHlwZXMudG9wb2xvZ3lUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJmbG93LXByb3BvcnRpb25cIiwgY2hhcnRUeXBlcy5mbG93UHJvcG9ydGlvblR5cGVzKVxuICAgICk7XG4gIH1cbiAgdGVtcGxhdGVUaGVtZSh0aGVtZVRlbXBsYXRlKSB7XG4gICAgY29uc3QgdGhlbWVJbnN0YW5jZSA9IGRlZXBDbG9uZSh0aGVtZVRlbXBsYXRlKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIGpzb25XYWxrKHRoZW1lSW5zdGFuY2UsIChub2RlKSA9PiB7XG4gICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzeW1ib2wgPSBub2RlW2ldO1xuICAgICAgICAgIGlmIChwYXJhbXMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIG5vZGVbaV0gPSBwYXJhbXMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG5vZGVbbmFtZV0gPSBwYXJhbXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVlcENsb25lKHRoZW1lSW5zdGFuY2UpO1xuICB9XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBERUZBVUxUX0ZJTExTLFxuICAgICAgc3Ryb2tlczogREVGQVVMVF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogREVGQVVMVF9GSUxMUy5SRUQsIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBERUZBVUxUX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBwYXJhbXMuc2V0KElTX0RBUktfVEhFTUUsIGZhbHNlKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRk9OVF9GQU1JTFksIFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTEFCRUxfQ09MT1VSLCBcInJnYig3MCwgNzAsIDcwKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSLCBcIndoaXRlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsIFwicmdiKDE0MCwgMTQwLCAxNDApXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcInJnYigyMjQsMjM0LDI0MSlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfTElORV9DT0xPVVIsIFwicmdiKDE5NSwgMTk1LCAxOTUpXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsIFwicmdiKDcwLCA3MCwgNzApXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUiwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9TSEFET1dfQ09MT1VSLCBcInJnYmEoMCwgMCwgMCwgMC41KVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIERFRkFVTFRfRklMTFMuT1JBTkdFLFxuICAgICAgREVGQVVMVF9GSUxMUy5ZRUxMT1csXG4gICAgICBERUZBVUxUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BBRERJTkcsIDIwKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsIFwiYmxvY2tcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULCBcImNlbnRlclwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTLCBbXCIjZmZmZmZmXCIsIFwiI2UwZTVlYVwiLCBcIiNjMWNjZDVcIiwgXCIjYTNiNGMxXCIsIFwiIzg1OWNhZFwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLCBbXCIjZmZmZmZmXCIsIFwiI2M1Y2JkMVwiLCBcIiNhNGIxYmRcIiwgXCIjODQ5OGE5XCIsIFwiIzY0ODA5NlwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0ZJTEwsIFwiI2ZhZmFmYVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsIFwiI2RkZGRkZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9DT0xPUiwgXCIjMDAwMDAwXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcInRvcFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgZmFsc2UpO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvcnMgPSB0aGlzLmdldERlZmF1bHRDb2xvcnMoKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfVVBfU1RST0tFLCB0aGlzLnBhbGV0dGUudXA/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLnVwLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX1VQX0ZJTEwsIHRoaXMucGFsZXR0ZS51cD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLnVwLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ET1dOX1NUUk9LRSwgdGhpcy5wYWxldHRlLmRvd24/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmRvd24uc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfRE9XTl9GSUxMLCB0aGlzLnBhbGV0dGUuZG93bj8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmRvd24uZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX05FVVRSQUxfU1RST0tFLCB0aGlzLnBhbGV0dGUubmV1dHJhbD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMubmV1dHJhbC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ORVVUUkFMX0ZJTEwsIHRoaXMucGFsZXR0ZS5uZXV0cmFsPy5maWxsID8/IGRlZmF1bHRDb2xvcnMubmV1dHJhbC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX1VQX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdFVwPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy51cC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfVVBfRklMTCwgdGhpcy5wYWxldHRlLmFsdFVwPy5maWxsID8/IGRlZmF1bHRDb2xvcnMudXAuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdERvd24/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmRvd24uc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX0RPV05fRklMTCwgdGhpcy5wYWxldHRlLmFsdERvd24/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5kb3duLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMLCB0aGlzLnBhbGV0dGUuYWx0TmV1dHJhbD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmFsdE5ldXRyYWwuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdE5ldXRyYWw/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmFsdE5ldXRyYWwuc3Ryb2tlKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuX0NoYXJ0VGhlbWUuY2FydGVzaWFuQXhpc0RlZmF1bHQgPSB7XG4gIFtcIm51bWJlclwiIC8qIE5VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgbGluZTogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJsb2dcIiAvKiBMT0cgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGJhc2U6IDEwLFxuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1wiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JvdXBQYWRkaW5nSW5uZXI6IDAuMSxcbiAgICBsYWJlbDogeyBhdXRvUm90YXRlOiB0cnVlIH0sXG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH0sXG4gICAgY3Jvc3NoYWlyOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcInRpbWVcIiAvKiBUSU1FICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHsgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH0gfSksXG4gIFtcIm9yZGluYWwtdGltZVwiIC8qIE9SRElOQUxfVElNRSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JvdXBQYWRkaW5nSW5uZXI6IDAsXG4gICAgbGFiZWw6IHsgYXV0b1JvdGF0ZTogZmFsc2UgfSxcbiAgICBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfVxuICB9KSxcbiAgW1wiYW5nbGUtY2F0ZWdvcnlcIiAvKiBBTkdMRV9DQVRFR09SWSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH1cbiAgfSksXG4gIFtcImFuZ2xlLW51bWJlclwiIC8qIEFOR0xFX05VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7IGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9IH0pLFxuICBbXCJyYWRpdXMtY2F0ZWdvcnlcIiAvKiBSQURJVVNfQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1wicmFkaXVzLW51bWJlclwiIC8qIFJBRElVU19OVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgXCJncm91cGVkLWNhdGVnb3J5XCI6IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgdGljazogeyBlbmFibGVkOiB0cnVlIH1cbiAgfSlcbn07XG52YXIgQ2hhcnRUaGVtZSA9IF9DaGFydFRoZW1lO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZGFya1RoZW1lLnRzXG52YXIgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCA9IFwiIzE5MjIzMlwiO1xudmFyIERFRkFVTFRfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIE9SQU5HRTogXCIjZmZhMDNhXCIsXG4gIEdSRUVOOiBcIiM0NTlkNTVcIixcbiAgQ1lBTjogXCIjMzRiZmUxXCIsXG4gIFlFTExPVzogXCIjZTFjYzAwXCIsXG4gIFZJT0xFVDogXCIjOTY2OWNiXCIsXG4gIEdSQVk6IFwiI2I1YjViNVwiLFxuICBNQUdFTlRBOiBcIiNiZDVhYTdcIixcbiAgQlJPV046IFwiIzhhNjIyNFwiLFxuICBSRUQ6IFwiI2VmNTQ1MlwiXG59O1xudmFyIERFRkFVTFRfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM3NGE4ZTZcIixcbiAgT1JBTkdFOiBcIiNmZmJlNzBcIixcbiAgR1JFRU46IFwiIzZjYjE3NlwiLFxuICBDWUFOOiBcIiM3NWQ0ZWZcIixcbiAgWUVMTE9XOiBcIiNmNmU1NTlcIixcbiAgVklPTEVUOiBcIiNhYTg2ZDhcIixcbiAgR1JBWTogXCIjYTFhMWExXCIsXG4gIE1BR0VOVEE6IFwiI2NlN2FiOVwiLFxuICBCUk9XTjogXCIjOTk3YjUyXCIsXG4gIFJFRDogXCIjZmY3ODcyXCJcbn07XG52YXIgRGFya1RoZW1lID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IERFRkFVTFRfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IERFRkFVTFRfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChJU19EQVJLX1RIRU1FLCB0cnVlKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0xBQkVMX0NPTE9VUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLCBcIiM3RDkxQTBcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIFwiIzU0NUE2RVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLCBcIndoaXRlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTLCBbXCIjMTkyODM0XCIsIFwiIzI1Mzc0NlwiLCBcIiMzMjQ4NTlcIiwgXCIjM2Y1OTZjXCIsIFwiIzRkNmE4MFwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLCBbXCIjMTkyODM0XCIsIFwiIzNiNTE2NFwiLCBcIiM0OTYyNzVcIiwgXCIjNTc3Mjg3XCIsIFwiIzY2ODM5OVwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIERFRkFVTFRfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfRklMTCwgXCIjMjgzMTNlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX1NUUk9LRSwgXCIjNGI1MjVkXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0NPTE9SLCBcIiNmZmZmZmZcIik7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9maW5hbmNpYWxEYXJrLnRzXG52YXIgRklOQU5DSUFMX0RBUktfRklMTFMgPSB7XG4gIEdSRUVOOiBcIiMwODk5ODFcIixcbiAgUkVEOiBcIiNGMjM2NDVcIixcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIEdSQVk6IFwiI0E5QTlBOVwiXG59O1xudmFyIEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMgPSB7XG4gIEdSRUVOOiBcIiMwODk5ODFcIixcbiAgUkVEOiBcIiNGMjM2NDVcIixcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIEdSQVk6IFwiIzkwOTA5MFwiXG59O1xudmFyIEZpbmFuY2lhbERhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLkZJTkFOQ0lBTF9EQVJLX0ZJTExTIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLkZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMgfSxcbiAgICAgIHVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUsXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCIjMzQzQTRFXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QQURESU5HLCAwKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsIFwib3ZlcmxheVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsIFwibGVmdFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiwgXCJib3R0b21cIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsIHRydWUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9maW5hbmNpYWxMaWdodC50c1xudmFyIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjQTlBOUE5XCJcbn07XG52YXIgRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEdSRUVOOiBcIiMwODk5ODFcIixcbiAgUkVEOiBcIiNGMjM2NDVcIixcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIEdSQVk6IFwiIzkwOTA5MFwiXG59O1xudmFyIEZpbmFuY2lhbExpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uRklOQU5DSUFMX0xJR0hUX0ZJTExTIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLkZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTIH0sXG4gICAgICB1cDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSRUVOLFxuICAgICAgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUsXG4gICAgICBGSU5BTkNJQUxfTElHSFRfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCIjRjJGM0YzXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QQURESU5HLCAwKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsIFwib3ZlcmxheVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsIFwibGVmdFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiwgXCJib3R0b21cIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsIHRydWUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9tYXRlcmlhbERhcmsudHNcbnZhciBNQVRFUklBTF9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiMyMTk2RjNcIixcbiAgT1JBTkdFOiBcIiNGRjk4MDBcIixcbiAgR1JFRU46IFwiIzRDQUY1MFwiLFxuICBDWUFOOiBcIiMwMEJDRDRcIixcbiAgWUVMTE9XOiBcIiNGRkVCM0JcIixcbiAgVklPTEVUOiBcIiM3RTU3QzJcIixcbiAgR1JBWTogXCIjOUU5RTlFXCIsXG4gIE1BR0VOVEE6IFwiI0YwNjI5MlwiLFxuICBCUk9XTjogXCIjNzk1NTQ4XCIsXG4gIFJFRDogXCIjRjQ0MzM2XCJcbn07XG52YXIgTUFURVJJQUxfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM5MENBRjlcIixcbiAgT1JBTkdFOiBcIiNGRkNDODBcIixcbiAgR1JFRU46IFwiI0E1RDZBN1wiLFxuICBDWUFOOiBcIiM4MERFRUFcIixcbiAgWUVMTE9XOiBcIiNGRkY5QzRcIixcbiAgVklPTEVUOiBcIiNCMzlEREJcIixcbiAgR1JBWTogXCIjRTBFMEUwXCIsXG4gIE1BR0VOVEE6IFwiI0Y0OEZCMVwiLFxuICBCUk9XTjogXCIjQTE4ODdGXCIsXG4gIFJFRDogXCIjRUY5QTlBXCJcbn07XG52YXIgTWF0ZXJpYWxEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogTUFURVJJQUxfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IE1BVEVSSUFMX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgTUFURVJJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL21hdGVyaWFsTGlnaHQudHNcbnZhciBNQVRFUklBTF9MSUdIVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjMjE5NkYzXCIsXG4gIE9SQU5HRTogXCIjRkY5ODAwXCIsXG4gIEdSRUVOOiBcIiM0Q0FGNTBcIixcbiAgQ1lBTjogXCIjMDBCQ0Q0XCIsXG4gIFlFTExPVzogXCIjRkZFQjNCXCIsXG4gIFZJT0xFVDogXCIjN0U1N0MyXCIsXG4gIEdSQVk6IFwiIzlFOUU5RVwiLFxuICBNQUdFTlRBOiBcIiNGMDYyOTJcIixcbiAgQlJPV046IFwiIzc5NTU0OFwiLFxuICBSRUQ6IFwiI0Y0NDMzNlwiXG59O1xudmFyIE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzE1NjVDMFwiLFxuICBPUkFOR0U6IFwiI0U2NTEwMFwiLFxuICBHUkVFTjogXCIjMkU3RDMyXCIsXG4gIENZQU46IFwiIzAwODM4RlwiLFxuICBZRUxMT1c6IFwiI0Y5QTgyNVwiLFxuICBWSU9MRVQ6IFwiIzQ1MjdBMFwiLFxuICBHUkFZOiBcIiM2MTYxNjFcIixcbiAgTUFHRU5UQTogXCIjQzIxODVCXCIsXG4gIEJST1dOOiBcIiM0RTM0MkVcIixcbiAgUkVEOiBcIiNCNzFDMUNcIlxufTtcbnZhciBNYXRlcmlhbExpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLFxuICAgICAgc3Ryb2tlczogTUFURVJJQUxfTElHSFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgTUFURVJJQUxfTElHSFRfRklMTFMuT1JBTkdFLFxuICAgICAgTUFURVJJQUxfTElHSFRfRklMTFMuWUVMTE9XLFxuICAgICAgTUFURVJJQUxfTElHSFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgTUFURVJJQUxfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvcG9seWNocm9tYURhcmsudHNcbnZhciBQT0xZQ0hST01BX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzQzNmZmNFwiLFxuICBQVVJQTEU6IFwiIzlhN2JmZlwiLFxuICBNQUdFTlRBOiBcIiNkMTY1ZDJcIixcbiAgUElOSzogXCIjZjA1OThiXCIsXG4gIFJFRDogXCIjZjQ3MzQ4XCIsXG4gIE9SQU5HRTogXCIjZjJhNjAyXCIsXG4gIFlFTExPVzogXCIjZTllMjAxXCIsXG4gIEdSRUVOOiBcIiMyMWI0NDhcIixcbiAgQ1lBTjogXCIjMDBiOWEyXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwYWVlNFwiLFxuICBHUkFZOiBcIiNiYmJiYmJcIlxufTtcbnZhciBQT0xZQ0hST01BX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNjY5OGZmXCIsXG4gIFBVUlBMRTogXCIjYzBhM2ZmXCIsXG4gIE1BR0VOVEE6IFwiI2ZjOGRmY1wiLFxuICBQSU5LOiBcIiNmZjgyYjFcIixcbiAgUkVEOiBcIiNmZjliNzBcIixcbiAgT1JBTkdFOiBcIiNmZmNmNGVcIixcbiAgWUVMTE9XOiBcIiNmZmZmNThcIixcbiAgR1JFRU46IFwiIzU4ZGQ3MFwiLFxuICBDWUFOOiBcIiM1MWUyYzlcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjNGZkN2ZmXCIsXG4gIEdSQVk6IFwiI2VlZWVlZVwiXG59O1xudmFyIFBvbHljaHJvbWFEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3BvbHljaHJvbWFMaWdodC50c1xudmFyIFBPTFlDSFJPTUFfTElHSFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzQzNmZmNFwiLFxuICBQVVJQTEU6IFwiIzlhN2JmZlwiLFxuICBNQUdFTlRBOiBcIiNkMTY1ZDJcIixcbiAgUElOSzogXCIjZjA1OThiXCIsXG4gIFJFRDogXCIjZjQ3MzQ4XCIsXG4gIE9SQU5HRTogXCIjZjJhNjAyXCIsXG4gIFlFTExPVzogXCIjZTllMjAxXCIsXG4gIEdSRUVOOiBcIiMyMWI0NDhcIixcbiAgQ1lBTjogXCIjMDBiOWEyXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwYWVlNFwiLFxuICBHUkFZOiBcIiNiYmJiYmJcIlxufTtcbnZhciBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzIzNDZjOVwiLFxuICBQVVJQTEU6IFwiIzc2NTNkNFwiLFxuICBNQUdFTlRBOiBcIiNhNzNkYTlcIixcbiAgUElOSzogXCIjYzMyZDY2XCIsXG4gIFJFRDogXCIjYzg0YjFjXCIsXG4gIE9SQU5HRTogXCIjYzg3ZjAwXCIsXG4gIFlFTExPVzogXCIjYzFiOTAwXCIsXG4gIEdSRUVOOiBcIiMwMDhjMWNcIixcbiAgQ1lBTjogXCIjMDA5MjdjXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwODdiYlwiLFxuICBHUkFZOiBcIiM4ODg4ODhcIlxufTtcbnZhciBQb2x5Y2hyb21hTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1BPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3NoZWV0c0RhcmsudHNcbnZhciBTSEVFVFNfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNDQ3MkM0XCIsXG4gIE9SQU5HRTogXCIjRUQ3RDMxXCIsXG4gIEdSQVk6IFwiI0E1QTVBNVwiLFxuICBZRUxMT1c6IFwiI0ZGQzAwMFwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM1QjlCRDVcIixcbiAgR1JFRU46IFwiIzcwQUQ0N1wiLFxuICBEQVJLX0dSQVk6IFwiIzdCN0I3QlwiLFxuICBEQVJLX0JMVUU6IFwiIzI2NDQ3OFwiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNjM2MzYzXCIsXG4gIERBUktfWUVMTE9XOiBcIiM5OTczMDBcIlxufTtcbnZhciBTSEVFVFNfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM2ODk5ZWVcIixcbiAgT1JBTkdFOiBcIiNmZmE1NWRcIixcbiAgR1JBWTogXCIjY2RjZGNkXCIsXG4gIFlFTExPVzogXCIjZmZlYTUzXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzgyYzNmZlwiLFxuICBHUkVFTjogXCIjOTZkNTZmXCIsXG4gIERBUktfR1JBWTogXCIjYTFhMWExXCIsXG4gIERBUktfQkxVRTogXCIjNDc2ODlmXCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM4Nzg3ODdcIixcbiAgREFSS19ZRUxMT1c6IFwiI2MwOTkzZFwiXG59O1xudmFyIFNoZWV0c0RhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLlNIRUVUU19EQVJLX0ZJTExTLCBSRUQ6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5TSEVFVFNfREFSS19TVFJPS0VTLCBSRUQ6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICB1cDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFNIRUVUU19EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgU0hFRVRTX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3NoZWV0c0xpZ2h0LnRzXG52YXIgU0hFRVRTX0xJR0hUX0ZJTExTID0ge1xuICBCTFVFOiBcIiM1MjgxZDVcIixcbiAgT1JBTkdFOiBcIiNmZjhkNDRcIixcbiAgR1JBWTogXCIjYjViNWI1XCIsXG4gIFlFTExPVzogXCIjZmZkMDJmXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzZhYWJlNlwiLFxuICBHUkVFTjogXCIjN2ZiZDU3XCIsXG4gIERBUktfR1JBWTogXCIjOGE4YThhXCIsXG4gIERBUktfQkxVRTogXCIjMzM1Mjg3XCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM3MTcxNzFcIixcbiAgREFSS19ZRUxMT1c6IFwiI2E5ODIyMFwiXG59O1xudmFyIFNIRUVUU19MSUdIVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMyMTRkOWJcIixcbiAgT1JBTkdFOiBcIiNjMjU2MDBcIixcbiAgR1JBWTogXCIjN2Y3ZjdmXCIsXG4gIFlFTExPVzogXCIjZDU5ODAwXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzM1NzVhY1wiLFxuICBHUkVFTjogXCIjNGI4NjFhXCIsXG4gIERBUktfR1JBWTogXCIjNTc1NzU3XCIsXG4gIERBUktfQkxVRTogXCIjMDYyMjUzXCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM0MTQxNDFcIixcbiAgREFSS19ZRUxMT1c6IFwiIzczNGYwMFwiXG59O1xudmFyIFNoZWV0c0xpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uU0hFRVRTX0xJR0hUX0ZJTExTLCBSRUQ6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uU0hFRVRTX0xJR0hUX1NUUk9LRVMsIFJFRDogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICB1cDogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSxcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgU0hFRVRTX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgU0hFRVRTX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy92aXZpZERhcmsudHNcbnZhciBWSVZJRF9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiMwMDgzZmZcIixcbiAgT1JBTkdFOiBcIiNmZjY2MDBcIixcbiAgR1JFRU46IFwiIzAwYWYwMFwiLFxuICBDWUFOOiBcIiMwMGNjZmZcIixcbiAgWUVMTE9XOiBcIiNmN2M3MDBcIixcbiAgVklPTEVUOiBcIiNhYzI2ZmZcIixcbiAgR1JBWTogXCIjYTdhN2I3XCIsXG4gIE1BR0VOVEE6IFwiI2U4MDBjNVwiLFxuICBCUk9XTjogXCIjYjU0MzAwXCIsXG4gIFJFRDogXCIjZmYwMDAwXCJcbn07XG52YXIgVklWSURfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM2N2I3ZmZcIixcbiAgT1JBTkdFOiBcIiNmZmMyNGRcIixcbiAgR1JFRU46IFwiIzVjYzg2ZlwiLFxuICBDWUFOOiBcIiM1NGViZmZcIixcbiAgVklPTEVUOiBcIiNmZmY2NTNcIixcbiAgWUVMTE9XOiBcIiNjMThhZmZcIixcbiAgR1JBWTogXCIjYWVhZWFlXCIsXG4gIE1BR0VOVEE6IFwiI2YwNzhkNFwiLFxuICBCUk9XTjogXCIjYmE4NDM4XCIsXG4gIFJFRDogXCIjZmY3MjZlXCJcbn07XG52YXIgVml2aWREYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogVklWSURfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFZJVklEX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuUkVELCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5PUkFOR0UsIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgVklWSURfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFZJVklEX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgVklWSURfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFZJVklEX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3ZpdmlkTGlnaHQudHNcbnZhciBWSVZJRF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjMDA4M2ZmXCIsXG4gIE9SQU5HRTogXCIjZmY2NjAwXCIsXG4gIEdSRUVOOiBcIiMwMGFmMDBcIixcbiAgQ1lBTjogXCIjMDBjY2ZmXCIsXG4gIFlFTExPVzogXCIjZjdjNzAwXCIsXG4gIFZJT0xFVDogXCIjYWMyNmZmXCIsXG4gIEdSQVk6IFwiI2E3YTdiN1wiLFxuICBNQUdFTlRBOiBcIiNlODAwYzVcIixcbiAgQlJPV046IFwiI2I1NDMwMFwiLFxuICBSRUQ6IFwiI2ZmMDAwMFwiXG59O1xudmFyIFZJVklEX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzBmNjhjMFwiLFxuICBPUkFOR0U6IFwiI2Q0NzEwMFwiLFxuICBHUkVFTjogXCIjMDA3OTIyXCIsXG4gIENZQU46IFwiIzAwOWFjMlwiLFxuICBWSU9MRVQ6IFwiI2JjYTQwMFwiLFxuICBZRUxMT1c6IFwiIzc1M2NhY1wiLFxuICBHUkFZOiBcIiM2NDY0NjRcIixcbiAgTUFHRU5UQTogXCIjOWIyNjg1XCIsXG4gIEJST1dOOiBcIiM2YzNiMDBcIixcbiAgUkVEOiBcIiNjYjAwMjFcIlxufTtcbnZhciBWaXZpZExpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFZJVklEX0ZJTExTLFxuICAgICAgc3Ryb2tlczogVklWSURfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFZJVklEX0ZJTExTLkdSRUVOLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogVklWSURfRklMTFMuUkVELCBzdHJva2U6IFZJVklEX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFZJVklEX0ZJTExTLkdSQVksIHN0cm9rZTogVklWSURfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBWSVZJRF9GSUxMUy5CTFVFLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBWSVZJRF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogVklWSURfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogVklWSURfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1ZJVklEX0ZJTExTLk9SQU5HRSwgVklWSURfRklMTFMuWUVMTE9XLCBWSVZJRF9GSUxMUy5HUkVFTl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBWSVZJRF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFZJVklEX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvdGhlbWVzLnRzXG52YXIgbGlnaHRUaGVtZSA9ICgpID0+IG5ldyBDaGFydFRoZW1lKCk7XG52YXIgZGFya1RoZW1lID0gKCkgPT4gbmV3IERhcmtUaGVtZSgpO1xudmFyIHRoZW1lcyA9IHtcbiAgLy8gZGFya1RoZW1lcyxcbiAgXCJhZy1kZWZhdWx0LWRhcmtcIjogZGFya1RoZW1lLFxuICBcImFnLXNoZWV0cy1kYXJrXCI6ICgpID0+IG5ldyBTaGVldHNEYXJrKCksXG4gIFwiYWctcG9seWNocm9tYS1kYXJrXCI6ICgpID0+IG5ldyBQb2x5Y2hyb21hRGFyaygpLFxuICBcImFnLXZpdmlkLWRhcmtcIjogKCkgPT4gbmV3IFZpdmlkRGFyaygpLFxuICBcImFnLW1hdGVyaWFsLWRhcmtcIjogKCkgPT4gbmV3IE1hdGVyaWFsRGFyaygpLFxuICBcImFnLWZpbmFuY2lhbC1kYXJrXCI6ICgpID0+IG5ldyBGaW5hbmNpYWxEYXJrKCksXG4gIC8vIGxpZ2h0VGhlbWVzLFxuICBudWxsOiBsaWdodFRoZW1lLFxuICB1bmRlZmluZWQ6IGxpZ2h0VGhlbWUsXG4gIFwiYWctZGVmYXVsdFwiOiBsaWdodFRoZW1lLFxuICBcImFnLXNoZWV0c1wiOiAoKSA9PiBuZXcgU2hlZXRzTGlnaHQoKSxcbiAgXCJhZy1wb2x5Y2hyb21hXCI6ICgpID0+IG5ldyBQb2x5Y2hyb21hTGlnaHQoKSxcbiAgXCJhZy12aXZpZFwiOiAoKSA9PiBuZXcgVml2aWRMaWdodCgpLFxuICBcImFnLW1hdGVyaWFsXCI6ICgpID0+IG5ldyBNYXRlcmlhbExpZ2h0KCksXG4gIFwiYWctZmluYW5jaWFsXCI6ICgpID0+IG5ldyBGaW5hbmNpYWxMaWdodCgpXG59O1xuZnVuY3Rpb24gZ2V0Q2hhcnRUaGVtZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDaGFydFRoZW1lKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHN0b2NrVGhlbWUgPSB0aGVtZXNbdmFsdWVdO1xuICAgIGlmIChzdG9ja1RoZW1lKSB7XG4gICAgICByZXR1cm4gc3RvY2tUaGVtZSgpO1xuICAgIH1cbiAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSB0aGVtZSBbJHt2YWx1ZX1dIGlzIGludmFsaWQsIHVzaW5nIFthZy1kZWZhdWx0XSBpbnN0ZWFkLmApO1xuICAgIHJldHVybiBsaWdodFRoZW1lKCk7XG4gIH1cbiAgaWYgKGlzVmFsaWQodmFsdWUsIHRoZW1lT3B0aW9uc0RlZiwgXCJ0aGVtZVwiKSkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFRoZW1lID0gcmVkdWNlVGhlbWVPcHRpb25zKHZhbHVlKTtcbiAgICBjb25zdCBiYXNlVGhlbWUgPSBmbGF0dGVuZWRUaGVtZS5iYXNlVGhlbWUgPyBnZXRDaGFydFRoZW1lKGZsYXR0ZW5lZFRoZW1lLmJhc2VUaGVtZSkgOiBsaWdodFRoZW1lKCk7XG4gICAgcmV0dXJuIG5ldyBiYXNlVGhlbWUuY29uc3RydWN0b3IoZmxhdHRlbmVkVGhlbWUpO1xuICB9XG4gIHJldHVybiBsaWdodFRoZW1lKCk7XG59XG5mdW5jdGlvbiByZWR1Y2VUaGVtZU9wdGlvbnMob3B0aW9ucykge1xuICBsZXQgbWF5YmVOZXN0ZWQgPSBvcHRpb25zO1xuICBsZXQgcGFsZXR0ZTtcbiAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gIHdoaWxlICh0eXBlb2YgbWF5YmVOZXN0ZWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBwYWxldHRlID8/IChwYWxldHRlID0gbWF5YmVOZXN0ZWQucGFsZXR0ZSk7XG4gICAgaWYgKG1heWJlTmVzdGVkLm92ZXJyaWRlcykge1xuICAgICAgb3ZlcnJpZGVzLnB1c2gobWF5YmVOZXN0ZWQub3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgbWF5YmVOZXN0ZWQgPSBtYXliZU5lc3RlZC5iYXNlVGhlbWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYXNlVGhlbWU6IG1heWJlTmVzdGVkLFxuICAgIG92ZXJyaWRlczogbWVyZ2VEZWZhdWx0cyguLi5vdmVycmlkZXMpLFxuICAgIHBhbGV0dGVcbiAgfTtcbn1cbnZhciB0aGVtZU9wdGlvbnNEZWYgPSB7XG4gIGJhc2VUaGVtZTogb3Ioc3RyaW5nLCBvYmplY3QpLFxuICBvdmVycmlkZXM6IG9iamVjdCxcbiAgcGFsZXR0ZToge1xuICAgIGZpbGxzOiBhcnJheU9mKHN0cmluZyksXG4gICAgc3Ryb2tlczogYXJyYXlPZihzdHJpbmcpLFxuICAgIHVwOiB7IGZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcgfSxcbiAgICBkb3duOiB7IGZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcgfSxcbiAgICBuZXV0cmFsOiB7IGZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvb3B0aW9uc01vZHVsZS50c1xudmFyIHVudGhlbWVkU2VyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wibWFwLXNoYXBlLWJhY2tncm91bmRcIiwgXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCJdKTtcbnZhciBDaGFydE9wdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHVzZXJPcHRpb25zLCBzcGVjaWFsT3ZlcnJpZGVzKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNsb25lT3B0aW9ucyA9IHsgc2hhbGxvdzogW1wiZGF0YVwiXSB9O1xuICAgIHVzZXJPcHRpb25zID0gZGVlcENsb25lKHVzZXJPcHRpb25zLCBjbG9uZU9wdGlvbnMpO1xuICAgIGNvbnN0IGNoYXJ0VHlwZTIgPSB0aGlzLm9wdGlvbnNUeXBlKHVzZXJPcHRpb25zKTtcbiAgICBpZiAoIWVudGVycHJpc2VNb2R1bGUuaXNFbnRlcnByaXNlKSB7XG4gICAgICByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnModXNlck9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucyA9IGRlZXBDbG9uZSh1c2VyT3B0aW9ucywgY2xvbmVPcHRpb25zKTtcbiAgICB0aGlzLnR5cGUgPSBzcGVjaWFsT3ZlcnJpZGVzPy50eXBlO1xuICAgIGlmICh0aGlzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJlc2V0T3B0aW9ucyA9IFBSRVNFVFNbdGhpcy50eXBlXT8uKG9wdGlvbnMsICgpID0+IHRoaXMuYWN0aXZlVGhlbWUpID8/IG9wdGlvbnM7XG4gICAgICB0aGlzLmRlYnVnKFwiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgLSBhcHBseWluZyBwcmVzZXRcIiwgb3B0aW9ucywgcHJlc2V0T3B0aW9ucyk7XG4gICAgICBvcHRpb25zID0gcHJlc2V0T3B0aW9ucztcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVUaGVtZSA9IGdldENoYXJ0VGhlbWUob3B0aW9ucy50aGVtZSk7XG4gICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMuYWN0aXZlVGhlbWUudGVtcGxhdGVUaGVtZShvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5zYW5pdHlDaGVja0FuZENsZWFudXAob3B0aW9ucyk7XG4gICAgdGhpcy5kZWZhdWx0QXhlcyA9IHRoaXMuZ2V0RGVmYXVsdEF4ZXMob3B0aW9ucyk7XG4gICAgdGhpcy5zcGVjaWFsT3ZlcnJpZGVzID0gdGhpcy5zcGVjaWFsT3ZlcnJpZGVzRGVmYXVsdHMoeyAuLi5zcGVjaWFsT3ZlcnJpZGVzIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGF4ZXM6IGF4ZXNUaGVtZXMgPSB7fSxcbiAgICAgIGFubm90YXRpb25zOiB7IGF4ZXNCdXR0b25zID0gbnVsbCwgLi4uYW5ub3RhdGlvbnNUaGVtZXMgfSA9IHt9LFxuICAgICAgc2VyaWVzOiBfLFxuICAgICAgLi4udGhlbWVEZWZhdWx0c1xuICAgIH0gPSB0aGlzLmdldFNlcmllc1RoZW1lQ29uZmlnKGNoYXJ0VHlwZTIpO1xuICAgIHRoaXMudXNlck9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICB0aGlzLnByb2Nlc3NlZE9wdGlvbnMgPSBkZWVwQ2xvbmUoXG4gICAgICBtZXJnZURlZmF1bHRzKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBheGVzQnV0dG9ucyAhPSBudWxsID8geyBhbm5vdGF0aW9uczogeyBheGVzQnV0dG9ucyB9IH0gOiB7fSxcbiAgICAgICAgdGhlbWVEZWZhdWx0cyxcbiAgICAgICAgdGhpcy5kZWZhdWx0QXhlc1xuICAgICAgKSxcbiAgICAgIGNsb25lT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5wcm9jZXNzQXhlc09wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zLCBheGVzVGhlbWVzKTtcbiAgICB0aGlzLnByb2Nlc3NTZXJpZXNPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgdGhpcy5wcm9jZXNzTWluaUNoYXJ0U2VyaWVzT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIHRoaXMuYW5ub3RhdGlvblRoZW1lcyA9IGFubm90YXRpb25zVGhlbWVzO1xuICAgIGlmICgoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpIHx8IGlzQWdQb2xhckNoYXJ0T3B0aW9uc1dpdGhTZXJpZXNCYXNlZExlZ2VuZCh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpKSAmJiB0aGlzLnByb2Nlc3NlZE9wdGlvbnMubGVnZW5kPy5lbmFibGVkID09IG51bGwpIHtcbiAgICAgIChfYSA9IHRoaXMucHJvY2Vzc2VkT3B0aW9ucykubGVnZW5kID8/IChfYS5sZWdlbmQgPSB7fSk7XG4gICAgICB0aGlzLnByb2Nlc3NlZE9wdGlvbnMubGVnZW5kLmVuYWJsZWQgPSB0aGlzLnByb2Nlc3NlZE9wdGlvbnMuc2VyaWVzLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlQ29uZmlndXJlZE9wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgICBpZiAoIWVudGVycHJpc2VNb2R1bGUuaXNFbnRlcnByaXNlKSB7XG4gICAgICByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzZWRPcHRpb25zID8/IHt9O1xuICB9XG4gIGRpZmZPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ganNvbkRpZmYob3B0aW9ucywgdGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgfVxuICBnZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXNUeXBlMikge1xuICAgIGNvbnN0IHRoZW1lQ29uZmlnID0gZGVlcENsb25lKHRoaXMuYWN0aXZlVGhlbWU/LmNvbmZpZ1tzZXJpZXNUeXBlMl0gPz8ge30pO1xuICAgIHRoaXMucmVtb3ZlTGVmdG92ZXJTeW1ib2xzKHRoZW1lQ29uZmlnKTtcbiAgICByZXR1cm4gdGhlbWVDb25maWc7XG4gIH1cbiAgZ2V0RGVmYXVsdEF4ZXMob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNUeXBlMiA9IHRoaXMub3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gICAgY29uc3QgYXhlc0RlZmF1bHRzID0gc2VyaWVzUmVnaXN0cnkuY2xvbmVEZWZhdWx0QXhlcyhvcHRpb25zVHlwZTIpO1xuICAgIGlmIChzZXJpZXNSZWdpc3RyeS5pc0RlZmF1bHRBeGlzU3dhcE5lZWRlZChvcHRpb25zKSkge1xuICAgICAgdGhpcy5zd2FwQXhlc1Bvc2l0aW9uKGF4ZXNEZWZhdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiBheGVzRGVmYXVsdHM7XG4gIH1cbiAgb3B0aW9uc1R5cGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnNlcmllcz8uWzBdPy50eXBlID8/IFwibGluZVwiO1xuICB9XG4gIHNhbml0eUNoZWNrQW5kQ2xlYW51cChvcHRpb25zKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmdzKG9wdGlvbnMpO1xuICAgIHRoaXMuYXhlc1R5cGVJbnRlZ3JpdHkob3B0aW9ucyk7XG4gICAgdGhpcy5zZXJpZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpO1xuICAgIHRoaXMuc29sb1Nlcmllc0ludGVncml0eShvcHRpb25zKTtcbiAgICB0aGlzLnJlbW92ZURpc2FibGVkT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnJlbW92ZUxlZnRvdmVyU3ltYm9scyhvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5zZXJpZXM/LnNvbWUoKHMpID0+IHMudHlwZSA9PT0gXCJidWxsZXRcIikgJiYgb3B0aW9ucy5zeW5jICE9IG51bGwgJiYgb3B0aW9ucy5zeW5jLmVuYWJsZWQgIT09IGZhbHNlKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJidWxsZXQgc2VyaWVzIGNhbm5vdCBiZSBzeW5jZWQsIGRpc2FibGluZyBzeW5jaHJvbml6YXRpb24uXCIpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuc3luYztcbiAgICB9XG4gIH1cbiAgc3dhcEF4ZXNQb3NpdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIGNvbnN0IFtheGlzMCwgYXhpczFdID0gb3B0aW9ucy5heGVzID8/IFtdO1xuICAgICAgb3B0aW9ucy5heGVzID0gW1xuICAgICAgICB7IC4uLmF4aXMwLCBwb3NpdGlvbjogYXhpczEucG9zaXRpb24gfSxcbiAgICAgICAgeyAuLi5heGlzMSwgcG9zaXRpb246IGF4aXMwLnBvc2l0aW9uIH1cbiAgICAgIF07XG4gICAgfVxuICB9XG4gIHByb2Nlc3NBeGVzT3B0aW9ucyhvcHRpb25zLCBheGVzVGhlbWVzKSB7XG4gICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykpXG4gICAgICByZXR1cm47XG4gICAgb3B0aW9ucy5heGVzID0gb3B0aW9ucy5heGVzLm1hcCgoYXhpcykgPT4ge1xuICAgICAgY29uc3QgeyBjcm9zc0xpbmVzOiBjcm9zc0xpbmVzVGhlbWUsIC4uLmF4aXNUaGVtZSB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgYXhlc1RoZW1lc1theGlzLnR5cGVdPy5bYXhpcy5wb3NpdGlvbl0sXG4gICAgICAgIGF4ZXNUaGVtZXNbYXhpcy50eXBlXVxuICAgICAgKTtcbiAgICAgIGlmIChheGlzLmNyb3NzTGluZXMpIHtcbiAgICAgICAgYXhpcy5jcm9zc0xpbmVzID0gbWVyZ2VBcnJheURlZmF1bHRzKGF4aXMuY3Jvc3NMaW5lcywgY3Jvc3NMaW5lc1RoZW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyaWRMaW5lU3R5bGUgPSBheGlzVGhlbWUuZ3JpZExpbmU/LnN0eWxlO1xuICAgICAgaWYgKGF4aXMuZ3JpZExpbmU/LnN0eWxlICYmIGdyaWRMaW5lU3R5bGU/Lmxlbmd0aCkge1xuICAgICAgICBheGlzLmdyaWRMaW5lLnN0eWxlID0gYXhpcy5ncmlkTGluZS5zdHlsZS5tYXAoXG4gICAgICAgICAgKHN0eWxlLCBpbmRleCkgPT4gc3R5bGUuc3Ryb2tlICE9IG51bGwgfHwgc3R5bGUubGluZURhc2ggIT0gbnVsbCA/IG1lcmdlRGVmYXVsdHMoc3R5bGUsIGdyaWRMaW5lU3R5bGUuYXQoaW5kZXggJSBncmlkTGluZVN0eWxlLmxlbmd0aCkpIDogc3R5bGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9wOiBfMSwgcmlnaHQ6IF8yLCBib3R0b206IF8zLCBsZWZ0OiBfNCwgLi4uYXhpc09wdGlvbnMgfSA9IG1lcmdlRGVmYXVsdHMoYXhpcywgYXhpc1RoZW1lKTtcbiAgICAgIHJldHVybiBheGlzT3B0aW9ucztcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzU2VyaWVzT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdFNlcmllc1R5cGUgPSB0aGlzLmdldERlZmF1bHRTZXJpZXNUeXBlKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRUb29sdGlwUG9zaXRpb24gPSB0aGlzLmdldFRvb2x0aXBQb3NpdGlvbkRlZmF1bHRzKG9wdGlvbnMpO1xuICAgIGNvbnN0IHVzZXJQYWxldHRlID0gaXNPYmplY3Qob3B0aW9ucy50aGVtZSkgPyBwYWxldHRlVHlwZShvcHRpb25zLnRoZW1lPy5wYWxldHRlKSA6IFwiaW5idWlsdFwiO1xuICAgIGNvbnN0IHBhbGV0dGVPcHRpb25zID0ge1xuICAgICAgY29sb3VySW5kZXg6IDAsXG4gICAgICB1c2VyUGFsZXR0ZVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc2VkU2VyaWVzID0gb3B0aW9ucy5zZXJpZXM/Lm1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMudHlwZSA/PyAoc2VyaWVzLnR5cGUgPSBkZWZhdWx0U2VyaWVzVHlwZSk7XG4gICAgICBjb25zdCB7IGlubmVyTGFiZWxzOiBpbm5lckxhYmVsc1RoZW1lLCAuLi5zZXJpZXNUaGVtZSB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXMudHlwZSkuc2VyaWVzID8/IHt9O1xuICAgICAgY29uc3Qgc2VyaWVzUGFsZXR0ZU9wdGlvbnMgPSB1bnRoZW1lZFNlcmllcy5oYXMoc2VyaWVzLnR5cGUpID8geyBjb2xvdXJJbmRleDogMCwgdXNlclBhbGV0dGUgfSA6IHBhbGV0dGVPcHRpb25zO1xuICAgICAgY29uc3QgcGFsZXR0ZSA9IHRoaXMuZ2V0U2VyaWVzUGFsZXR0ZShzZXJpZXMudHlwZSwgc2VyaWVzUGFsZXR0ZU9wdGlvbnMpO1xuICAgICAgY29uc3QgZGVmYXVsdFRvb2x0aXBSYW5nZSA9IHRoaXMuZ2V0VG9vbHRpcFJhbmdlRGVmYXVsdHMob3B0aW9ucywgc2VyaWVzLnR5cGUpO1xuICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcyksXG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgZGVmYXVsdFRvb2x0aXBQb3NpdGlvbixcbiAgICAgICAgZGVmYXVsdFRvb2x0aXBSYW5nZSxcbiAgICAgICAgc2VyaWVzVGhlbWUsXG4gICAgICAgIHBhbGV0dGUsXG4gICAgICAgIHsgdmlzaWJsZTogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgaWYgKHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMpIHtcbiAgICAgICAgc2VyaWVzT3B0aW9ucy5pbm5lckxhYmVscyA9IG1lcmdlQXJyYXlEZWZhdWx0cyhzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzLCBpbm5lckxhYmVsc1RoZW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRoZW1lLnRlbXBsYXRlVGhlbWUoc2VyaWVzT3B0aW9ucyk7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5zZXJpZXMgPSB0aGlzLnNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhwcm9jZXNzZWRTZXJpZXMgPz8gW10pO1xuICB9XG4gIHByb2Nlc3NNaW5pQ2hhcnRTZXJpZXNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBsZXQgbWluaUNoYXJ0U2VyaWVzID0gb3B0aW9ucy5uYXZpZ2F0b3I/Lm1pbmlDaGFydD8uc2VyaWVzO1xuICAgIGlmIChtaW5pQ2hhcnRTZXJpZXMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwYWxldHRlT3B0aW9ucyA9IHtcbiAgICAgIGNvbG91ckluZGV4OiAwLFxuICAgICAgdXNlclBhbGV0dGU6IGlzT2JqZWN0KG9wdGlvbnMudGhlbWUpID8gcGFsZXR0ZVR5cGUob3B0aW9ucy50aGVtZS5wYWxldHRlKSA6IFwiaW5idWlsdFwiXG4gICAgfTtcbiAgICBtaW5pQ2hhcnRTZXJpZXMgPSBtaW5pQ2hhcnRTZXJpZXMubWFwKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy50eXBlID8/IChzZXJpZXMudHlwZSA9IFwibGluZVwiKTtcbiAgICAgIGNvbnN0IHsgaW5uZXJMYWJlbHM6IF8sIC4uLnNlcmllc1RoZW1lIH0gPSB0aGlzLmdldFNlcmllc1RoZW1lQ29uZmlnKHNlcmllcy50eXBlKS5zZXJpZXMgPz8ge307XG4gICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoc2VyaWVzKSxcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBzZXJpZXNUaGVtZSxcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNQYWxldHRlKHNlcmllcy50eXBlLCBwYWxldHRlT3B0aW9ucylcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVUaGVtZS50ZW1wbGF0ZVRoZW1lKHNlcmllc09wdGlvbnMpO1xuICAgIH0pO1xuICAgIG9wdGlvbnMubmF2aWdhdG9yLm1pbmlDaGFydC5zZXJpZXMgPSB0aGlzLnNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhtaW5pQ2hhcnRTZXJpZXMpO1xuICB9XG4gIGdldFNlcmllc1BhbGV0dGUoc2VyaWVzVHlwZTIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYWxldHRlRmFjdG9yeSA9IHNlcmllc1JlZ2lzdHJ5LmdldFBhbGV0dGVGYWN0b3J5KHNlcmllc1R5cGUyKTtcbiAgICBjb25zdCB7IGNvbG91ckluZGV4OiBjb2xvdXJPZmZzZXQsIHVzZXJQYWxldHRlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZmlsbHMgPSBbXSwgc3Ryb2tlcyA9IFtdIH0gPSB0aGlzLmFjdGl2ZVRoZW1lLnBhbGV0dGU7XG4gICAgcmV0dXJuIHBhbGV0dGVGYWN0b3J5Py4oe1xuICAgICAgdXNlclBhbGV0dGUsXG4gICAgICBjb2xvcnNDb3VudDogTWF0aC5tYXgoZmlsbHMubGVuZ3RoLCBzdHJva2VzLmxlbmd0aCksXG4gICAgICB0aGVtZVRlbXBsYXRlUGFyYW1ldGVyczogdGhpcy5hY3RpdmVUaGVtZS5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSxcbiAgICAgIHBhbGV0dGU6IHRoaXMuYWN0aXZlVGhlbWUucGFsZXR0ZSxcbiAgICAgIHRha2VDb2xvcnMoY291bnQpIHtcbiAgICAgICAgb3B0aW9ucy5jb2xvdXJJbmRleCArPSBjb3VudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWxsczogY2lyY3VsYXJTbGljZUFycmF5KGZpbGxzLCBjb3VudCwgY29sb3VyT2Zmc2V0KSxcbiAgICAgICAgICBzdHJva2VzOiBjaXJjdWxhclNsaWNlQXJyYXkoc3Ryb2tlcywgY291bnQsIGNvbG91ck9mZnNldClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoc2VyaWVzKSB7XG4gICAgY29uc3QgZ3JvdXBhYmxlID0gc2VyaWVzUmVnaXN0cnkuaXNHcm91cGFibGUoc2VyaWVzLnR5cGUpO1xuICAgIGNvbnN0IHN0YWNrYWJsZSA9IHNlcmllc1JlZ2lzdHJ5LmlzU3RhY2thYmxlKHNlcmllcy50eXBlKTtcbiAgICBjb25zdCBzdGFja2VkQnlEZWZhdWx0ID0gc2VyaWVzUmVnaXN0cnkuaXNTdGFja2VkQnlEZWZhdWx0KHNlcmllcy50eXBlKTtcbiAgICBpZiAoc2VyaWVzLmdyb3VwZWQgJiYgIWdyb3VwYWJsZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGB1bnN1cHBvcnRlZCBncm91cGluZyBvZiBzZXJpZXMgdHlwZSBcIiR7c2VyaWVzLnR5cGV9XCIuYCk7XG4gICAgfVxuICAgIGlmICgoc2VyaWVzLnN0YWNrZWQgfHwgc2VyaWVzLnN0YWNrR3JvdXApICYmICFzdGFja2FibGUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgdW5zdXBwb3J0ZWQgc3RhY2tpbmcgb2Ygc2VyaWVzIHR5cGUgXCIke3Nlcmllcy50eXBlfVwiLmApO1xuICAgIH1cbiAgICBsZXQgeyBncm91cGVkLCBzdGFja2VkIH0gPSBzZXJpZXM7XG4gICAgc3RhY2tlZCA/PyAoc3RhY2tlZCA9IChzdGFja2VkQnlEZWZhdWx0IHx8IHNlcmllcy5zdGFja0dyb3VwICE9IG51bGwpICYmICEoZ3JvdXBhYmxlICYmIGdyb3VwZWQpKTtcbiAgICBncm91cGVkID8/IChncm91cGVkID0gdHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWNrZWQ6IHN0YWNrYWJsZSAmJiBzdGFja2VkLFxuICAgICAgZ3JvdXBlZDogZ3JvdXBhYmxlICYmIGdyb3VwZWQgJiYgIShzdGFja2FibGUgJiYgc3RhY2tlZClcbiAgICB9O1xuICB9XG4gIHNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhhbGxTZXJpZXMpIHtcbiAgICBjb25zdCBzZXJpZXNHcm91cHMgPSB0aGlzLmdldFNlcmllc0dyb3VwaW5nKGFsbFNlcmllcyk7XG4gICAgdGhpcy5kZWJ1ZyhcInNldFNlcmllc0dyb3VwaW5nT3B0aW9ucygpIC0gc2VyaWVzIGdyb3VwaW5nOiBcIiwgc2VyaWVzR3JvdXBzKTtcbiAgICBjb25zdCBncm91cElkeCA9IHt9O1xuICAgIGNvbnN0IGdyb3VwQ291bnQyID0gc2VyaWVzR3JvdXBzLnJlZHVjZSgoY291bnRNYXAsIHNlcmllc0dyb3VwKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc2VyaWVzR3JvdXAuZ3JvdXBUeXBlID09PSBcImRlZmF1bHRcIiAvKiBERUZBVUxUICovKSB7XG4gICAgICAgIHJldHVybiBjb3VudE1hcDtcbiAgICAgIH1cbiAgICAgIGNvdW50TWFwW19hID0gc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0gPz8gKGNvdW50TWFwW19hXSA9IDApO1xuICAgICAgY291bnRNYXBbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0gKz0gc2VyaWVzR3JvdXAuZ3JvdXBUeXBlID09PSBcInN0YWNrXCIgLyogU1RBQ0sgKi8gPyAxIDogc2VyaWVzR3JvdXAuc2VyaWVzLmxlbmd0aDtcbiAgICAgIHJldHVybiBjb3VudE1hcDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIHNlcmllc0dyb3Vwcy5mbGF0TWFwKChzZXJpZXNHcm91cCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgZ3JvdXBJZHhbX2EgPSBzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSA/PyAoZ3JvdXBJZHhbX2FdID0gMCk7XG4gICAgICBzd2l0Y2ggKHNlcmllc0dyb3VwLmdyb3VwVHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhY2tcIiAvKiBTVEFDSyAqLzpcbiAgICAgICAgICBjb25zdCBncm91cEluZGV4ID0gZ3JvdXBJZHhbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0rKztcbiAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAuc2VyaWVzLm1hcChcbiAgICAgICAgICAgIChzZXJpZXMsIHN0YWNrSW5kZXgpID0+IE9iamVjdC5hc3NpZ24oc2VyaWVzLCB7XG4gICAgICAgICAgICAgIHNlcmllc0dyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogc2VyaWVzR3JvdXAuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGdyb3VwQ291bnQ6IGdyb3VwQ291bnQyW3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdLFxuICAgICAgICAgICAgICAgIHN0YWNrSW5kZXgsXG4gICAgICAgICAgICAgICAgc3RhY2tDb3VudDogc2VyaWVzR3JvdXAuc2VyaWVzLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJncm91cFwiIC8qIEdST1VQICovOlxuICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5zZXJpZXMubWFwKFxuICAgICAgICAgICAgKHNlcmllcykgPT4gT2JqZWN0LmFzc2lnbihzZXJpZXMsIHtcbiAgICAgICAgICAgICAgc2VyaWVzR3JvdXBpbmc6IHtcbiAgICAgICAgICAgICAgICBncm91cElkOiBzZXJpZXNHcm91cC5ncm91cElkLFxuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSWR4W3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdKyssXG4gICAgICAgICAgICAgICAgZ3JvdXBDb3VudDogZ3JvdXBDb3VudDJbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0sXG4gICAgICAgICAgICAgICAgc3RhY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBzdGFja0NvdW50OiAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpZXNHcm91cC5zZXJpZXM7XG4gICAgfSkubWFwKCh7IHN0YWNrZWQ6IF8sIGdyb3VwZWQ6IF9fLCAuLi5zZXJpZXNPcHRpb25zIH0pID0+IHNlcmllc09wdGlvbnMpO1xuICB9XG4gIGdldFNlcmllc0dyb3VwSWQoc2VyaWVzKSB7XG4gICAgcmV0dXJuIFtzZXJpZXMudHlwZSwgc2VyaWVzLnhLZXksIHNlcmllcy5zdGFja2VkID8gc2VyaWVzLnN0YWNrR3JvdXAgPz8gXCJzdGFja2VkXCIgOiBcImdyb3VwZWRcIl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCItXCIpO1xuICB9XG4gIGdldFNlcmllc0dyb3VwaW5nKGFsbFNlcmllcykge1xuICAgIGNvbnN0IGdyb3VwTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICByZXR1cm4gYWxsU2VyaWVzLnJlZHVjZSgocmVzdWx0LCBzZXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gc2VyaWVzLnR5cGU7XG4gICAgICBpZiAoIXNlcmllcy5zdGFja2VkICYmICFzZXJpZXMuZ3JvdXBlZCkge1xuICAgICAgICByZXN1bHQucHVzaCh7IGdyb3VwVHlwZTogXCJkZWZhdWx0XCIgLyogREVGQVVMVCAqLywgc2VyaWVzVHlwZTogc2VyaWVzVHlwZTIsIHNlcmllczogW3Nlcmllc10sIGdyb3VwSWQ6IFwiX19kZWZhdWx0X19cIiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGdyb3VwSWQgPSB0aGlzLmdldFNlcmllc0dyb3VwSWQoc2VyaWVzKTtcbiAgICAgICAgaWYgKCFncm91cE1hcC5oYXMoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBjb25zdCBncm91cFR5cGUgPSBzZXJpZXMuc3RhY2tlZCA/IFwic3RhY2tcIiAvKiBTVEFDSyAqLyA6IFwiZ3JvdXBcIiAvKiBHUk9VUCAqLztcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSB7IGdyb3VwVHlwZSwgc2VyaWVzVHlwZTogc2VyaWVzVHlwZTIsIHNlcmllczogW10sIGdyb3VwSWQgfTtcbiAgICAgICAgICBncm91cE1hcC5zZXQoZ3JvdXBJZCwgcmVjb3JkKTtcbiAgICAgICAgICByZXN1bHQucHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwTWFwLmdldChncm91cElkKS5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZ2V0RGVmYXVsdFNlcmllc1R5cGUob3B0aW9ucykge1xuICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJsaW5lXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnUG9sYXJDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInBpZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwidHJlZW1hcFwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJtYXAtc2hhcGVcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwic2Fua2V5XCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhcnQgb3B0aW9ucyB0eXBlIGRldGVjdGVkLlwiKTtcbiAgfVxuICBnZXRUb29sdGlwUG9zaXRpb25EZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zLnRvb2x0aXA/LnBvc2l0aW9uO1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0IH0gPSBwb3NpdGlvbjtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoaXNTdHJpbmcodHlwZSkgJiYgaXNFbnVtVmFsdWUoQWdUb29sdGlwUG9zaXRpb25UeXBlLCB0eXBlKSkge1xuICAgICAgcmVzdWx0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoeE9mZnNldCkpIHtcbiAgICAgIHJlc3VsdC54T2Zmc2V0ID0geE9mZnNldDtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHlPZmZzZXQpKSB7XG4gICAgICByZXN1bHQueU9mZnNldCA9IHlPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB7IHRvb2x0aXA6IHsgcG9zaXRpb246IHJlc3VsdCB9IH07XG4gIH1cbiAgLy8gQUctMTE1OTEgU3VwcG9ydCBmb3IgbmV3IHNlcmllcy1zcGVjaWZpYyAmIGxlZ2FjeSBjaGFydC1nbG9iYWwgJ3Rvb2x0aXAucmFuZ2UnIG9wdGlvbnNcbiAgLy9cbiAgLy8gVGhlIGBjaGFydC5zZXJpZXNbXS50b29sdGlwLnJhbmdlYCBvcHRpb24gaXMgYSBiaXQgZGlmZmVyZW50IGZvciBsZWdhY3kgcmVhc29uLiBUaGlzIHVzZSB0byBiZVxuICAvLyBnbG9iYWwgb3B0aW9uIChgY2hhcnQudG9vbHRpcC5yYW5nZWApIHRoYXQgY291bGQgb3ZlcnJpZGUgdGhlIHRoZW1lLiBCdXQgbm93LCB0aGUgdG9vbHRpcCByYW5nZVxuICAvLyBvcHRpb24gaXMgc2VyaWVzLXNwZWNpZmljLlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSBiYWNrd2FyZCBjb21wYXRpYmxpdHksIHRoZSBgY2hhcnQudG9vbHRpcC5yYW5nZWAgdGhlbWUgZGVmYXVsdCBoYXMgYmVlbiBjaGFuZ2VkIGZyb21cbiAgLy8gJ25lYXJlc3QnIHRvIHVuZGVmaW5lZC5cbiAgZ2V0VG9vbHRpcFJhbmdlRGVmYXVsdHMob3B0aW9ucywgc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHRpcDoge1xuICAgICAgICByYW5nZTogb3B0aW9ucy50b29sdGlwPy5yYW5nZSA/PyBzZXJpZXNSZWdpc3RyeS5nZXRUb29sdGlwRGVmYXVscyhzZXJpZXNUeXBlMik/LnJhbmdlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXByZWNhdGVkQXJyYXlQcm9wcyA9IHsgeUtleXM6IFwieUtleVwiLCB5TmFtZXM6IFwieU5hbWVcIiB9O1xuICAgIE9iamVjdC5lbnRyaWVzKGRlcHJlY2F0ZWRBcnJheVByb3BzKS5mb3JFYWNoKChbb2xkUHJvcCwgbmV3UHJvcF0pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnNlcmllcz8uc29tZSgocykgPT4gc1tvbGRQcm9wXSAhPSBudWxsKSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYFByb3BlcnR5IFtzZXJpZXMuJHtvbGRQcm9wfV0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBbc2VyaWVzLiR7bmV3UHJvcH1dIGFuZCBtdWx0aXBsZSBzZXJpZXMgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXhlc1R5cGVJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIGlmIChcImF4ZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBheGVzID0gb3B0aW9ucy5heGVzID8/IFtdO1xuICAgICAgZm9yIChjb25zdCB7IHR5cGUgfSBvZiBheGVzKSB7XG4gICAgICAgIGlmICghaXNBeGlzT3B0aW9uVHlwZSh0eXBlKSkge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmF4ZXM7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGF4aXNSZWdpc3RyeS5wdWJsaWNLZXlzKCkuam9pbihcIiwgXCIpO1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShgdW5rbm93biBheGlzIHR5cGU6ICR7dHlwZX07IGV4cGVjdGVkIG9uZSBvZjogJHtleHBlY3RlZFR5cGVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNlcmllc1R5cGVJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXM/LmZpbHRlcigoeyB0eXBlIH0pID0+IHtcbiAgICAgIGlmICh0eXBlID09IG51bGwgfHwgaXNTZXJpZXNPcHRpb25UeXBlKHR5cGUpIHx8IGlzRW50ZXJwcmlzZVNlcmllc1R5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIGB1bmtub3duIHNlcmllcyB0eXBlOiAke3R5cGV9OyBleHBlY3RlZCBvbmUgb2Y6ICR7cHVibGljQ2hhcnRUeXBlcy5zZXJpZXNUeXBlcy5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBzb2xvU2VyaWVzSW50ZWdyaXR5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhbGxTZXJpZXMgPSBvcHRpb25zLnNlcmllcztcbiAgICBpZiAoYWxsU2VyaWVzICYmIGFsbFNlcmllcy5sZW5ndGggPiAxICYmIGFsbFNlcmllcy5zb21lKChzZXJpZXMpID0+IHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhzZXJpZXMudHlwZSkpKSB7XG4gICAgICBjb25zdCBtYWluU2VyaWVzVHlwZSA9IHRoaXMub3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gICAgICBpZiAoc2VyaWVzUmVnaXN0cnkuaXNTb2xvKG1haW5TZXJpZXNUeXBlKSkge1xuICAgICAgICBMb2dnZXIud2FybihcbiAgICAgICAgICBgc2VyaWVzWzBdIG9mIHR5cGUgJyR7bWFpblNlcmllc1R5cGV9JyBpcyBpbmNvbXBhdGlibGUgd2l0aCBvdGhlciBzZXJpZXMgdHlwZXMuIE9ubHkgcHJvY2Vzc2luZyBzZXJpZXNbMF1gXG4gICAgICAgICk7XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gYWxsU2VyaWVzLnNsaWNlKDAsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBzb2xvLCBub25Tb2xvIH0gPSBncm91cEJ5KFxuICAgICAgICAgIGFsbFNlcmllcyxcbiAgICAgICAgICAocykgPT4gc2VyaWVzUmVnaXN0cnkuaXNTb2xvKHMudHlwZSkgPyBcInNvbG9cIiA6IFwibm9uU29sb1wiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlamVjdHMgPSB1bmlxdWUoc29sby5tYXAoKHMpID0+IHMudHlwZSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgTG9nZ2VyLndhcm4oYFVuYWJsZSB0byBtaXggdGhlc2Ugc2VyaWVzIHR5cGVzIHdpdGggdGhlIGxlYWQgc2VyaWVzIHR5cGU6ICR7cmVqZWN0c31gKTtcbiAgICAgICAgb3B0aW9ucy5zZXJpZXMgPSBub25Tb2xvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmFibGVDb25maWd1cmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAganNvbldhbGsoXG4gICAgICB0aGlzLnVzZXJPcHRpb25zLFxuICAgICAgKHZpc2l0aW5nVXNlck9wdHMsIHZpc2l0aW5nTWVyZ2VkT3B0cykgPT4ge1xuICAgICAgICBpZiAodmlzaXRpbmdNZXJnZWRPcHRzICYmIFwiZW5hYmxlZFwiIGluIHZpc2l0aW5nTWVyZ2VkT3B0cyAmJiAhdmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lICYmIHZpc2l0aW5nVXNlck9wdHMuZW5hYmxlZCA9PSBudWxsKSB7XG4gICAgICAgICAgdmlzaXRpbmdNZXJnZWRPcHRzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCIsIFwidGhlbWVcIl0gfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGpzb25XYWxrKFxuICAgICAgb3B0aW9ucyxcbiAgICAgICh2aXNpdGluZ01lcmdlZE9wdHMpID0+IHtcbiAgICAgICAgaWYgKHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZSAhPSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiLCBcInRoZW1lXCJdIH1cbiAgICApO1xuICB9XG4gIHJlbW92ZURpc2FibGVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAganNvbldhbGsoXG4gICAgICBvcHRpb25zLFxuICAgICAgKG9wdGlvbnNOb2RlKSA9PiB7XG4gICAgICAgIGlmIChcImVuYWJsZWRcIiBpbiBvcHRpb25zTm9kZSAmJiBvcHRpb25zTm9kZS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnNOb2RlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZW5hYmxlZFwiKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc05vZGVba2V5XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiLCBcInRoZW1lXCJdIH1cbiAgICApO1xuICB9XG4gIHJlbW92ZUxlZnRvdmVyU3ltYm9scyhvcHRpb25zKSB7XG4gICAganNvbldhbGsoXG4gICAgICBvcHRpb25zLFxuICAgICAgKG9wdGlvbnNOb2RlKSA9PiB7XG4gICAgICAgIGlmICghb3B0aW9uc05vZGUgfHwgIWlzT2JqZWN0KG9wdGlvbnNOb2RlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNOb2RlKSkge1xuICAgICAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTm9kZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiXSB9XG4gICAgKTtcbiAgfVxuICBzcGVjaWFsT3ZlcnJpZGVzRGVmYXVsdHMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndpbmRvdyAhPSBudWxsKSB7XG4gICAgICBzZXRXaW5kb3cob3B0aW9ucy53aW5kb3cpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy53aW5kb3cgPSB3aW5kb3c7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLndpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAgIHNldERvY3VtZW50KG9wdGlvbnMuZG9jdW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aW5kb3cgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIHdpbmRvd1wiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGRvY3VtZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL2FnQ2hhcnRzLnRzXG52YXIgZGVidWcyID0gRGVidWcuY3JlYXRlKHRydWUsIFwib3B0c1wiKTtcbmZ1bmN0aW9uIGNoYXJ0VHlwZShvcHRpb25zKSB7XG4gIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwiY2FydGVzaWFuXCI7XG4gIH0gZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwicG9sYXJcIjtcbiAgfSBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwiaGllcmFyY2h5XCI7XG4gIH0gZWxzZSBpZiAoaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwidG9wb2xvZ3lcIjtcbiAgfSBlbHNlIGlmIChpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0IC0gdW5rbm93biB0eXBlIG9mIGNoYXJ0IGZvciBvcHRpb25zIHdpdGggdHlwZTogJHtvcHRpb25zLnR5cGV9YCk7XG59XG52YXIgQWdDaGFydHMgPSBjbGFzcyB7XG4gIHN0YXRpYyBsaWNlbnNlQ2hlY2sob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmxpY2Vuc2VDaGVja2VkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXIgPSBlbnRlcnByaXNlTW9kdWxlLmxpY2Vuc2VNYW5hZ2VyPy4ob3B0aW9ucyk7XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlcj8uc2V0TGljZW5zZUtleSh0aGlzLmxpY2Vuc2VLZXksIHRoaXMuZ3JpZENvbnRleHQpO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXI/LnZhbGlkYXRlTGljZW5zZSgpO1xuICAgIHRoaXMubGljZW5zZUNoZWNrZWQgPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBzZXRMaWNlbnNlS2V5KGxpY2Vuc2VLZXkpIHtcbiAgICB0aGlzLmxpY2Vuc2VLZXkgPSBsaWNlbnNlS2V5O1xuICB9XG4gIHN0YXRpYyBzZXRHcmlkQ29udGV4dChncmlkQ29udGV4dCkge1xuICAgIHRoaXMuZ3JpZENvbnRleHQgPSBncmlkQ29udGV4dDtcbiAgfVxuICBzdGF0aWMgZ2V0TGljZW5zZURldGFpbHMobGljZW5zZUtleSkge1xuICAgIHJldHVybiBlbnRlcnByaXNlTW9kdWxlLmxpY2Vuc2VNYW5hZ2VyPy4oe30pLmdldExpY2Vuc2VEZXRhaWxzKGxpY2Vuc2VLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgQWdDaGFydEluc3RhbmNlYCBmb3IgYSBET00gbm9kZSwgaWYgdGhlcmUgaXMgb25lLlxuICAgKi9cbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQyKSB7XG4gICAgcmV0dXJuIEFnQ2hhcnRzSW50ZXJuYWwuZ2V0SW5zdGFuY2UoZWxlbWVudDIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEFnQ2hhcnRJbnN0YW5jZWAgYmFzZWQgdXBvbiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgdGhpcy5saWNlbnNlQ2hlY2sob3B0aW9ucyk7XG4gICAgY29uc3QgY2hhcnQgPSBBZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKG9wdGlvbnMsIHZvaWQgMCwgdGhpcy5saWNlbnNlTWFuYWdlcik7XG4gICAgaWYgKGVudGVycHJpc2VNb2R1bGUuc3R5bGVzICE9IG51bGwpIHtcbiAgICAgIGNoYXJ0LmNoYXJ0LmN0eC5kb21NYW5hZ2VyLmFkZFN0eWxlcyhcImFnLWNoYXJ0cy1lbnRlcnByaXNlXCIsIGVudGVycHJpc2VNb2R1bGUuc3R5bGVzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGljZW5zZU1hbmFnZXI/LmlzRGlzcGxheVdhdGVybWFyaygpICYmIHRoaXMubGljZW5zZU1hbmFnZXIpIHtcbiAgICAgIGVudGVycHJpc2VNb2R1bGUuaW5qZWN0V2F0ZXJtYXJrPy4oY2hhcnQuY2hhcnQuY3R4LmRvbU1hbmFnZXIsIHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVGaW5hbmNpYWxDaGFydChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgIF90eXBlOiBcInByaWNlLXZvbHVtZVwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG59O1xuQWdDaGFydHMubGljZW5zZUNoZWNrZWQgPSBmYWxzZTtcbkFnQ2hhcnRzLmdyaWRDb250ZXh0ID0gZmFsc2U7XG52YXIgX0FnQ2hhcnRzSW50ZXJuYWwgPSBjbGFzcyBfQWdDaGFydHNJbnRlcm5hbCB7XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50Mikge1xuICAgIGNvbnN0IGNoYXJ0ID0gQ2hhcnQuZ2V0SW5zdGFuY2UoZWxlbWVudDIpO1xuICAgIHJldHVybiBjaGFydCA/IEFnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzLmdldChjaGFydCkgOiB2b2lkIDA7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpc2VNb2R1bGVzKCkge1xuICAgIGlmIChfQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZClcbiAgICAgIHJldHVybjtcbiAgICByZWdpc3RlckluYnVpbHRNb2R1bGVzKCk7XG4gICAgc2V0dXBNb2R1bGVzKCk7XG4gICAgX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVPclVwZGF0ZShvcHRpb25zLCBwcm94eSwgbGljZW5zZU1hbmFnZXIpIHtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlTW9kdWxlcygpO1xuICAgIGRlYnVnMihcIj4+PiBBZ0NoYXJ0cy5jcmVhdGVPclVwZGF0ZSgpIHVzZXIgb3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICBjb25zdCBkZWZhdWx0VHlwZSA9IHByb3h5Py5jaGFydC5jaGFydE9wdGlvbnMudHlwZTtcbiAgICBjb25zdCB7IF90eXBlID0gZGVmYXVsdFR5cGUsIC4uLm90aGVyT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBsZXQgbXV0YWJsZU9wdGlvbnMgPSBvdGhlck9wdGlvbnM7XG4gICAgaWYgKEFnQ2hhcnRzLm9wdGlvbnNNdXRhdGlvbkZuKSB7XG4gICAgICBtdXRhYmxlT3B0aW9ucyA9IEFnQ2hhcnRzLm9wdGlvbnNNdXRhdGlvbkZuKG11dGFibGVPcHRpb25zLCBfdHlwZSk7XG4gICAgICBkZWJ1ZzIoXCI+Pj4gQWdDaGFydHMuY3JlYXRlT3JVcGRhdGUoKSBNVVRBVEVEIHVzZXIgb3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgeyBvdmVycmlkZURldmljZVBpeGVsUmF0aW8sIGRvY3VtZW50OiBkb2N1bWVudDIsIHdpbmRvdzogdXNlcldpbmRvdywgLi4udXNlck9wdGlvbnMgfSA9IG11dGFibGVPcHRpb25zO1xuICAgIGNvbnN0IGNoYXJ0T3B0aW9ucyA9IG5ldyBDaGFydE9wdGlvbnModXNlck9wdGlvbnMsIHtcbiAgICAgIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIGRvY3VtZW50OiBkb2N1bWVudDIsXG4gICAgICB3aW5kb3c6IHVzZXJXaW5kb3csXG4gICAgICB0eXBlOiBfdHlwZVxuICAgIH0pO1xuICAgIGxldCBjaGFydCA9IHByb3h5Py5jaGFydDtcbiAgICBpZiAoY2hhcnQgPT0gbnVsbCB8fCBjaGFydFR5cGUodXNlck9wdGlvbnMpICE9PSBjaGFydFR5cGUoY2hhcnQ/LmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zKSkge1xuICAgICAgY2hhcnQgPSBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVDaGFydEluc3RhbmNlKGNoYXJ0T3B0aW9ucywgY2hhcnQpO1xuICAgIH1cbiAgICBpZiAocHJveHkgPT0gbnVsbCkge1xuICAgICAgcHJveHkgPSBuZXcgQWdDaGFydEluc3RhbmNlUHJveHkoY2hhcnQsIF9BZ0NoYXJ0c0ludGVybmFsLmNhbGxiYWNrQXBpLCBsaWNlbnNlTWFuYWdlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3h5LmNoYXJ0ID0gY2hhcnQ7XG4gICAgfVxuICAgIGlmIChkZWJ1ZzIuY2hlY2soKSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cuYWdDaGFydEluc3RhbmNlcyA/PyAod2luZG93LmFnQ2hhcnRJbnN0YW5jZXMgPSB7fSk7XG4gICAgICB3aW5kb3cuYWdDaGFydEluc3RhbmNlc1tjaGFydC5pZF0gPSBjaGFydDtcbiAgICB9XG4gICAgY2hhcnQucXVldWVkVXNlck9wdGlvbnMucHVzaCh1c2VyT3B0aW9ucyk7XG4gICAgY2hhcnQucmVxdWVzdEZhY3RvcnlVcGRhdGUoKGNoYXJ0UmVmKSA9PiB7XG4gICAgICBjaGFydFJlZi5hcHBseU9wdGlvbnMoY2hhcnRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHF1ZXVlSWR4ID0gY2hhcnRSZWYucXVldWVkVXNlck9wdGlvbnMuaW5kZXhPZih1c2VyT3B0aW9ucykgKyAxO1xuICAgICAgY2hhcnRSZWYucXVldWVkVXNlck9wdGlvbnMuc3BsaWNlKDAsIHF1ZXVlSWR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZVVzZXJEZWx0YShwcm94eSwgZGVsdGFPcHRpb25zKSB7XG4gICAgZGVsdGFPcHRpb25zID0gZGVlcENsb25lKGRlbHRhT3B0aW9ucywgeyBzaGFsbG93OiBbXCJkYXRhXCJdIH0pO1xuICAgIGpzb25XYWxrKFxuICAgICAgZGVsdGFPcHRpb25zLFxuICAgICAgKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIHsgW2tleV06IFN5bWJvbChcIlVOU0VUXCIpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiXSB9XG4gICAgKTtcbiAgICBjb25zdCB7IGNoYXJ0IH0gPSBwcm94eTtcbiAgICBjb25zdCBsYXN0VXBkYXRlT3B0aW9ucyA9IGNoYXJ0LmdldE9wdGlvbnMoKTtcbiAgICBjb25zdCB1c2VyT3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoZGVsdGFPcHRpb25zLCBsYXN0VXBkYXRlT3B0aW9ucyk7XG4gICAgZGVidWcyKFwiPj4+IEFnQ2hhcnRzLnVwZGF0ZVVzZXJEZWx0YSgpIHVzZXIgZGVsdGFcIiwgZGVsdGFPcHRpb25zKTtcbiAgICBkZWJ1ZzIoXCJBZ0NoYXJ0cy51cGRhdGVVc2VyRGVsdGEoKSAtIGJhc2Ugb3B0aW9uc1wiLCBsYXN0VXBkYXRlT3B0aW9ucyk7XG4gICAgX0FnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUodXNlck9wdGlvbnMsIHByb3h5KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ2hhcnRJbnN0YW5jZShvcHRpb25zLCBvbGRDaGFydCkge1xuICAgIGNvbnN0IHRyYW5zZmVyYWJsZVJlc291cmNlID0gb2xkQ2hhcnQ/LmRlc3Ryb3koeyBrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzOiB0cnVlIH0pO1xuICAgIGNvbnN0IENoYXJ0Q29uc3RydWN0b3IgPSBfQWdDaGFydHNJbnRlcm5hbC5nZXRDaGFydEJ5T3B0aW9ucyhvcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgQ2hhcnRDb25zdHJ1Y3RvcihvcHRpb25zLCB0cmFuc2ZlcmFibGVSZXNvdXJjZSk7XG4gIH1cbiAgc3RhdGljIGdldENoYXJ0QnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIENhcnRlc2lhbkNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIEhpZXJhcmNoeUNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gUG9sYXJDaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdUb3BvbG9neUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFRvcG9sb2d5Q2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBGbG93UHJvcG9ydGlvbkNoYXJ0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQUcgQ2hhcnRzIC0gY291bGRuJ3QgYXBwbHkgY29uZmlndXJhdGlvbiwgY2hlY2sgb3B0aW9ucyBhcmUgY29ycmVjdGx5IHN0cnVjdHVyZWQgYW5kIHNlcmllcyB0eXBlcyBhcmUgc3BlY2lmaWVkYFxuICAgICk7XG4gIH1cbn07XG5fQWdDaGFydHNJbnRlcm5hbC5jYXJldGFrZXIgPSBuZXcgTWVtZW50b0NhcmV0YWtlcihWRVJTSU9OKTtcbl9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkID0gZmFsc2U7XG5fQWdDaGFydHNJbnRlcm5hbC5jYWxsYmFja0FwaSA9IHtcbiAgY2FyZXRha2VyOiBfQWdDaGFydHNJbnRlcm5hbC5jYXJldGFrZXIsXG4gIGNyZWF0ZU9yVXBkYXRlKG9wdHMsIGNoYXJ0KSB7XG4gICAgcmV0dXJuIF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKG9wdHMsIGNoYXJ0KTtcbiAgfSxcbiAgdXBkYXRlVXNlckRlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpIHtcbiAgICByZXR1cm4gX0FnQ2hhcnRzSW50ZXJuYWwudXBkYXRlVXNlckRlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpO1xuICB9XG59O1xudmFyIEFnQ2hhcnRzSW50ZXJuYWwgPSBfQWdDaGFydHNJbnRlcm5hbDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvaW50ZWdyYXRlZC1jaGFydHMtc2NlbmUudHNcbnZhciBpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzLCB7XG4gIEFyYzogKCkgPT4gQXJjMixcbiAgQkJveDogKCkgPT4gQkJveCxcbiAgQmFuZFNjYWxlOiAoKSA9PiBCYW5kU2NhbGUsXG4gIENhcHRpb246ICgpID0+IENhcHRpb24sXG4gIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzOiAoKSA9PiBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyxcbiAgQ2lyY2xlOiAoKSA9PiBDaXJjbGUsXG4gIENvbnRpbnVvdXNTY2FsZTogKCkgPT4gQ29udGludW91c1NjYWxlLFxuICBEaWFtb25kOiAoKSA9PiBEaWFtb25kLFxuICBEcm9wU2hhZG93OiAoKSA9PiBEcm9wU2hhZG93LFxuICBFeHRlbmRlZFBhdGgyRDogKCkgPT4gRXh0ZW5kZWRQYXRoMkQsXG4gIEdyb3VwOiAoKSA9PiBHcm91cCxcbiAgSGRwaUNhbnZhczogKCkgPT4gSGRwaUNhbnZhcyxcbiAgSW1hZ2U6ICgpID0+IEltYWdlLFxuICBMYWJlbDogKCkgPT4gTGFiZWwsXG4gIExpbmU6ICgpID0+IExpbmUsXG4gIExpbmVhckdyYWRpZW50RmlsbDogKCkgPT4gTGluZWFyR3JhZGllbnRGaWxsLFxuICBMaW5lYXJTY2FsZTogKCkgPT4gTGluZWFyU2NhbGUsXG4gIE1hcmtlcjogKCkgPT4gTWFya2VyLFxuICBOb2RlOiAoKSA9PiBOb2RlLFxuICBPcmRpbmFsVGltZVNjYWxlOiAoKSA9PiBPcmRpbmFsVGltZVNjYWxlLFxuICBQYXRoOiAoKSA9PiBQYXRoLFxuICBQb2ludGVyRXZlbnRzOiAoKSA9PiBQb2ludGVyRXZlbnRzLFxuICBSYWRpYWxDb2x1bW5TaGFwZTogKCkgPT4gUmFkaWFsQ29sdW1uU2hhcGUsXG4gIFJlY3Q6ICgpID0+IFJlY3QsXG4gIFJlZHJhd1R5cGU6ICgpID0+IFJlZHJhd1R5cGUsXG4gIFNjZW5lOiAoKSA9PiBTY2VuZSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb246ICgpID0+IFNjZW5lQ2hhbmdlRGV0ZWN0aW9uLFxuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb246ICgpID0+IFNjZW5lUGF0aENoYW5nZURldGVjdGlvbixcbiAgU2VjdG9yOiAoKSA9PiBTZWN0b3IsXG4gIFNlY3RvckJveDogKCkgPT4gU2VjdG9yQm94LFxuICBTZWxlY3Rpb246ICgpID0+IFNlbGVjdGlvbixcbiAgU2hhcGU6ICgpID0+IFNoYXBlLFxuICBTcXVhcmU6ICgpID0+IFNxdWFyZSxcbiAgU3ZnUGF0aDogKCkgPT4gU3ZnUGF0aCxcbiAgVGV4dDogKCkgPT4gVGV4dCxcbiAgVG9vbHRpcDogKCkgPT4gVG9vbHRpcCxcbiAgVHJpYW5nbGU6ICgpID0+IFRyaWFuZ2xlLFxuICBkcmF3Q29ybmVyOiAoKSA9PiBkcmF3Q29ybmVyLFxuICBlYXNpbmc6ICgpID0+IGVhc2luZ19leHBvcnRzLFxuICBldmFsdWF0ZUJlemllcjogKCkgPT4gZXZhbHVhdGVCZXppZXIsXG4gIGdldEZvbnQ6ICgpID0+IGdldEZvbnQsXG4gIGdldE1hcmtlcjogKCkgPT4gZ2V0TWFya2VyLFxuICBnZXRSYWRpYWxDb2x1bW5XaWR0aDogKCkgPT4gZ2V0UmFkaWFsQ29sdW1uV2lkdGgsXG4gIG1vdGlvbjogKCkgPT4gbW90aW9uLFxuICBzZWN0b3JCb3g6ICgpID0+IHNlY3RvckJveCxcbiAgc29sdmVCZXppZXI6ICgpID0+IHNvbHZlQmV6aWVyLFxuICBzcGxpdEJlemllcjogKCkgPT4gc3BsaXRCZXppZXIsXG4gIHRvUmFkaWFuczogKCkgPT4gdG9SYWRpYW5zLFxuICB0b1Rvb2x0aXBIdG1sOiAoKSA9PiB0b1Rvb2x0aXBIdG1sXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvYXJjLnRzXG52YXIgQXJjMiA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMucmFkaXVzID0gMTA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgdGhpcy5jb3VudGVyQ2xvY2t3aXNlID0gZmFsc2U7XG4gICAgdGhpcy50eXBlID0gMCAvKiBPcGVuICovO1xuICAgIHRoaXMucmVzdG9yZU93blN0eWxlcygpO1xuICB9XG4gIGdldCBmdWxsUGllKCkge1xuICAgIHJldHVybiBpc0VxdWFsKG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMuc3RhcnRBbmdsZSksIG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMuZW5kQW5nbGUpKTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZLCB0aGlzLnJhZGl1cywgdGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlLCB0aGlzLmNvdW50ZXJDbG9ja3dpc2UpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IDEgLyogQ2hvcmQgKi8pIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IDIgLyogUm91bmQgKi8gJiYgIXRoaXMuZnVsbFBpZSkge1xuICAgICAgcGF0aC5saW5lVG8odGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclkpO1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIG5ldyBCQm94KHRoaXMuY2VudGVyWCAtIHRoaXMucmFkaXVzLCB0aGlzLmNlbnRlclkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgcmV0dXJuIHRoaXMudHlwZSAhPT0gMCAvKiBPcGVuICovICYmIGJib3guY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KSAmJiB0aGlzLnBhdGguaXNQb2ludEluUGF0aChwb2ludC54LCBwb2ludC55KTtcbiAgfVxufTtcbkFyYzIuY2xhc3NOYW1lID0gXCJBcmNcIjtcbkFyYzIuZGVmYXVsdFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIFNoYXBlLmRlZmF1bHRTdHlsZXMsIHtcbiAgbGluZVdpZHRoOiAxLFxuICBmaWxsU3R5bGU6IG51bGxcbn0pO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImNlbnRlclhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiY2VudGVyWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJjb3VudGVyQ2xvY2t3aXNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL2xpbmVhckdyYWRpZW50RmlsbC50c1xudmFyIExpbmVhckdyYWRpZW50RmlsbCA9IGNsYXNzIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gXCJ0by1yaWdodFwiO1xuICAgIHRoaXMuc3RvcHMgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWFzayA9IHZvaWQgMDtcbiAgfVxuICBnZXQgbWFzaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgfVxuICBzZXQgbWFzayhuZXdNYXNrKSB7XG4gICAgaWYgKHRoaXMuX21hc2sgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLl9tYXNrKTtcbiAgICB9XG4gICAgaWYgKG5ld01hc2sgIT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdNYXNrKTtcbiAgICB9XG4gICAgdGhpcy5fbWFzayA9IG5ld01hc2s7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFzaz8uaXNQb2ludEluUGF0aCh4LCB5KSA/PyBmYWxzZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrPy5nZXRCQm94KCk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgbWFzaywgc3RvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjdHgsIGRldmljZVBpeGVsUmF0aW8gfSA9IHJlbmRlckN0eDtcbiAgICBjb25zdCBwaXhlbExlbmd0aCA9IDEgLyBkZXZpY2VQaXhlbFJhdGlvO1xuICAgIGNvbnN0IG1hc2tCYm94ID0gbWFzaz8uY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgIGlmIChtYXNrID09IG51bGwgfHwgc3RvcHMgPT0gbnVsbCB8fCBtYXNrQmJveCA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChtYXNrLmRpcnR5UGF0aCkge1xuICAgICAgbWFzay51cGRhdGVQYXRoKCk7XG4gICAgICBtYXNrLmRpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5jbGlwKG1hc2sucGF0aC5nZXRQYXRoMkQoKSk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkZXZpY2VQaXhlbFJhdGlvLCAwLCAwLCBkZXZpY2VQaXhlbFJhdGlvLCAwLCAwKTtcbiAgICBjb25zdCB4MCA9IE1hdGguZmxvb3IobWFza0Jib3gueCk7XG4gICAgY29uc3QgeDEgPSBNYXRoLmNlaWwobWFza0Jib3gueCArIG1hc2tCYm94LndpZHRoKTtcbiAgICBjb25zdCB5MCA9IE1hdGguZmxvb3IobWFza0Jib3gueSk7XG4gICAgY29uc3QgeTEgPSBNYXRoLmNlaWwobWFza0Jib3gueSArIG1hc2tCYm94LmhlaWdodCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuZGlyZWN0aW9uID09PSBcInRvLXJpZ2h0XCIgfHwgdGhpcy5kaXJlY3Rpb24gPT09IFwidG8tbGVmdFwiO1xuICAgIGNvbnN0IHJldmVyc2VkID0gdGhpcy5kaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgfHwgdGhpcy5kaXJlY3Rpb24gPT09IFwidG8tbGVmdFwiO1xuICAgIGNvbnN0IGNvbG9yU2NhbGUgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICAgIGNvbnN0IFtpMCwgaTFdID0gaG9yaXpvbnRhbCA/IFt4MCwgeDFdIDogW3kwLCB5MV07XG4gICAgY29sb3JTY2FsZS5kb21haW4gPSBzdG9wcy5tYXAoKF8sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gaTAgKyAoaTEgLSBpMCkgKiBpbmRleCAvIChzdG9wcy5sZW5ndGggLSAxKTtcbiAgICB9KTtcbiAgICBjb2xvclNjYWxlLnJhbmdlID0gcmV2ZXJzZWQgPyBzdG9wcy5zbGljZSgpLnJldmVyc2UoKSA6IHN0b3BzO1xuICAgIGNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0geTEgLSB5MDtcbiAgICBjb25zdCB3aWR0aCA9IHgxIC0geDA7XG4gICAgc3dpdGNoICh0aGlzLmRpcmVjdGlvbikge1xuICAgICAgY2FzZSBcInRvLXJpZ2h0XCI6XG4gICAgICBjYXNlIFwidG8tbGVmdFwiOlxuICAgICAgICBmb3IgKGxldCB4ID0geDA7IHggPD0geDE7IHggKz0gcGl4ZWxMZW5ndGgpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JTY2FsZS5jb252ZXJ0KHgpO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5MCwgcGl4ZWxMZW5ndGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG8tYm90dG9tXCI6XG4gICAgICBjYXNlIFwidG8tdG9wXCI6XG4gICAgICAgIGZvciAobGV0IHkgPSB5MDsgeSA8PSB5MTsgeSArPSBwaXhlbExlbmd0aCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvclNjYWxlLmNvbnZlcnQoeSk7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHgwLCB5LCB3aWR0aCwgcGl4ZWxMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmVhckdyYWRpZW50RmlsbC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmVhckdyYWRpZW50RmlsbC5wcm90b3R5cGUsIFwic3RvcHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZWFyR3JhZGllbnRGaWxsLnByb3RvdHlwZSwgXCJfbWFza1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcmFkaWFsQ29sdW1uU2hhcGUudHNcbmZ1bmN0aW9uIHJvdGF0ZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydCh4ICoqIDIgKyB5ICoqIDIpO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBjb25zdCByb3RhdGVkID0gYW5nbGUyICsgcm90YXRpb247XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5jb3Mocm90YXRlZCkgKiByYWRpdXMsXG4gICAgeTogTWF0aC5zaW4ocm90YXRlZCkgKiByYWRpdXNcbiAgfTtcbn1cbnZhciBSYWRpYWxDb2x1bW5TaGFwZSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pc0JldmVsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sdW1uV2lkdGggPSAwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IDA7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5heGlzSW5uZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYXhpc091dGVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmlzUmFkaXVzQXhpc1JldmVyc2VkID0gZmFsc2U7XG4gIH1cbiAgc2V0IGNvcm5lclJhZGl1cyhfdmFsdWUpIHtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY29sdW1uV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgcmlnaHQgPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgdG9wID0gLW91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGJvdHRvbSA9IC1pbm5lclJhZGl1cztcbiAgICBsZXQgeDAgPSBJbmZpbml0eTtcbiAgICBsZXQgeTAgPSBJbmZpbml0eTtcbiAgICBsZXQgeDEgPSAtSW5maW5pdHk7XG4gICAgbGV0IHkxID0gLUluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHJvdGF0ZVBvaW50KGkgJSAyID09PSAwID8gbGVmdCA6IHJpZ2h0LCBpIDwgMiA/IHRvcCA6IGJvdHRvbSwgcm90YXRpb24pO1xuICAgICAgeDAgPSBNYXRoLm1pbih4LCB4MCk7XG4gICAgICB5MCA9IE1hdGgubWluKHksIHkwKTtcbiAgICAgIHgxID0gTWF0aC5tYXgoeCwgeDEpO1xuICAgICAgeTEgPSBNYXRoLm1heCh5LCB5MSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICB9XG4gIGdldFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgbWlkQW5nbGUgPSBhbmdsZUJldHdlZW4oc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIHJldHVybiBub3JtYWxpemVBbmdsZTM2MChzdGFydEFuZ2xlICsgbWlkQW5nbGUgLyAyICsgTWF0aC5QSSAvIDIpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBpc0JldmVsZWQgfSA9IHRoaXM7XG4gICAgaWYgKGlzQmV2ZWxlZCkge1xuICAgICAgdGhpcy51cGRhdGVCZXZlbGVkUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlY3Rhbmd1bGFyUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgdXBkYXRlUmVjdGFuZ3VsYXJQYXRoKCkge1xuICAgIGNvbnN0IHsgY29sdW1uV2lkdGgsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgcGF0aCB9ID0gdGhpcztcbiAgICBjb25zdCBsZWZ0ID0gLWNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgIFtsZWZ0LCBib3R0b21dLFxuICAgICAgW2xlZnQsIHRvcF0sXG4gICAgICBbcmlnaHQsIHRvcF0sXG4gICAgICBbcmlnaHQsIGJvdHRvbV1cbiAgICBdLm1hcCgoW3gsIHldKSA9PiByb3RhdGVQb2ludCh4LCB5LCByb3RhdGlvbikpO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgcGF0aC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xuICAgIHBhdGgubGluZVRvKHBvaW50c1syXS54LCBwb2ludHNbMl0ueSk7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzNdLngsIHBvaW50c1szXS55KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIHVwZGF0ZUJldmVsZWRQYXRoKCkge1xuICAgIGNvbnN0IHsgY29sdW1uV2lkdGgsIHBhdGgsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgYXhpc0lubmVyUmFkaXVzLCBheGlzT3V0ZXJSYWRpdXMsIGlzUmFkaXVzQXhpc1JldmVyc2VkIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzU3RhY2tCb3R0b20gPSBpc0VxdWFsKGlubmVyUmFkaXVzLCBheGlzSW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IHNpZGVSb3RhdGlvbiA9IE1hdGguYXNpbihjb2x1bW5XaWR0aCAvIDIgLyBpbm5lclJhZGl1cyk7XG4gICAgY29uc3QgcG9pbnRSb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCByb3RhdGUyID0gKHgsIHkpID0+IHJvdGF0ZVBvaW50KHgsIHksIHBvaW50Um90YXRpb24pO1xuICAgIGNvbnN0IGdldFRyaWFuZ2xlSHlwb3RlbnVzZSA9IChsZWcsIG90aGVyTGVnKSA9PiBNYXRoLnNxcnQobGVnICoqIDIgKyBvdGhlckxlZyAqKiAyKTtcbiAgICBjb25zdCBnZXRUcmlhbmdsZUxlZyA9IChoeXBvdGVudXNlLCBvdGhlckxlZykgPT4ge1xuICAgICAgaWYgKG90aGVyTGVnID4gaHlwb3RlbnVzZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoaHlwb3RlbnVzZSAqKiAyIC0gb3RoZXJMZWcgKiogMik7XG4gICAgfTtcbiAgICBjb25zdCBjb21wYXJlID0gKHZhbHVlLCBvdGhlclZhbHVlLCBsZXNzVGhhbikgPT4gbGVzc1RoYW4gPyB2YWx1ZSA8IG90aGVyVmFsdWUgOiB2YWx1ZSA+IG90aGVyVmFsdWU7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSA9IGlzU3RhY2tCb3R0b20gJiYgIWlzTmFOKHNpZGVSb3RhdGlvbikgJiYgc2lkZVJvdGF0aW9uIDwgTWF0aC5QSSAvIDY7XG4gICAgbGV0IGxlZnQgPSAtY29sdW1uV2lkdGggLyAyO1xuICAgIGxldCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzICogKHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUgPyBNYXRoLmNvcyhzaWRlUm90YXRpb24pIDogMSk7XG4gICAgY29uc3QgaGFzQm90dG9tSW50ZXJzZWN0aW9uID0gY29tcGFyZShcbiAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgIGdldFRyaWFuZ2xlSHlwb3RlbnVzZShpbm5lclJhZGl1cywgY29sdW1uV2lkdGggLyAyKSxcbiAgICAgICFpc1JhZGl1c0F4aXNSZXZlcnNlZFxuICAgICk7XG4gICAgaWYgKGhhc0JvdHRvbUludGVyc2VjdGlvbikge1xuICAgICAgY29uc3QgYm90dG9tSW50ZXJzZWN0aW9uWCA9IGdldFRyaWFuZ2xlTGVnKGF4aXNPdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuICAgICAgbGVmdCA9IC1ib3R0b21JbnRlcnNlY3Rpb25YO1xuICAgICAgcmlnaHQgPSBib3R0b21JbnRlcnNlY3Rpb25YO1xuICAgIH1cbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnRQdCA9IHJvdGF0ZTIobGVmdCwgYm90dG9tKTtcbiAgICBwYXRoLm1vdmVUbyhib3R0b21MZWZ0UHQueCwgYm90dG9tTGVmdFB0LnkpO1xuICAgIGNvbnN0IGlzRW1wdHkgPSBpc0VxdWFsKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gICAgY29uc3QgaGFzU2lkZUludGVyc2VjdGlvbiA9IGNvbXBhcmUoXG4gICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICBnZXRUcmlhbmdsZUh5cG90ZW51c2Uob3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoIC8gMiksXG4gICAgICAhaXNSYWRpdXNBeGlzUmV2ZXJzZWRcbiAgICApO1xuICAgIGlmIChpc0VtcHR5ICYmIHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUpIHtcbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoLXNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKHNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaGFzU2lkZUludGVyc2VjdGlvbikge1xuICAgICAgY29uc3Qgc2lkZUludGVyc2VjdGlvblkgPSAtZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBjb2x1bW5XaWR0aCAvIDIpO1xuICAgICAgY29uc3QgdG9wSW50ZXJzZWN0aW9uWCA9IGdldFRyaWFuZ2xlTGVnKGF4aXNPdXRlclJhZGl1cywgb3V0ZXJSYWRpdXMpO1xuICAgICAgaWYgKCFoYXNCb3R0b21JbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgdG9wTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBzaWRlSW50ZXJzZWN0aW9uWSk7XG4gICAgICAgIHBhdGgubGluZVRvKHRvcExlZnRQdC54LCB0b3BMZWZ0UHQueSk7XG4gICAgICB9XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgICBNYXRoLmF0YW4yKHNpZGVJbnRlcnNlY3Rpb25ZLCBsZWZ0KSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIE1hdGguYXRhbjIodG9wLCAtdG9wSW50ZXJzZWN0aW9uWCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGlmICghaXNFcXVhbCh0b3BJbnRlcnNlY3Rpb25YLCAwKSkge1xuICAgICAgICBjb25zdCB0b3BSaWdodEJldmVsUHQgPSByb3RhdGUyKHRvcEludGVyc2VjdGlvblgsIHRvcCk7XG4gICAgICAgIHBhdGgubGluZVRvKHRvcFJpZ2h0QmV2ZWxQdC54LCB0b3BSaWdodEJldmVsUHQueSk7XG4gICAgICB9XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgICBNYXRoLmF0YW4yKHRvcCwgdG9wSW50ZXJzZWN0aW9uWCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBNYXRoLmF0YW4yKHNpZGVJbnRlcnNlY3Rpb25ZLCByaWdodCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9wTGVmdFB0ID0gcm90YXRlMihsZWZ0LCB0b3ApO1xuICAgICAgY29uc3QgdG9wUmlnaHRQdCA9IHJvdGF0ZTIocmlnaHQsIHRvcCk7XG4gICAgICBwYXRoLmxpbmVUbyh0b3BMZWZ0UHQueCwgdG9wTGVmdFB0LnkpO1xuICAgICAgcGF0aC5saW5lVG8odG9wUmlnaHRQdC54LCB0b3BSaWdodFB0LnkpO1xuICAgIH1cbiAgICBjb25zdCBib3R0b21SaWdodFB0ID0gcm90YXRlMihyaWdodCwgYm90dG9tKTtcbiAgICBwYXRoLmxpbmVUbyhib3R0b21SaWdodFB0LngsIGJvdHRvbVJpZ2h0UHQueSk7XG4gICAgaWYgKHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUpIHtcbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoLXNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdGF0ZWRCb3R0b21MZWZ0UHQgPSByb3RhdGUyKGxlZnQsIGJvdHRvbSk7XG4gICAgICBwYXRoLmxpbmVUbyhyb3RhdGVkQm90dG9tTGVmdFB0LngsIHJvdGF0ZWRCb3R0b21MZWZ0UHQueSk7XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5SYWRpYWxDb2x1bW5TaGFwZS5jbGFzc05hbWUgPSBcIlJhZGlhbENvbHVtblNoYXBlXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImlzQmV2ZWxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiY29sdW1uV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImF4aXNJbm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiYXhpc091dGVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJpc1JhZGl1c0F4aXNSZXZlcnNlZFwiLCAyKTtcbmZ1bmN0aW9uIGdldFJhZGlhbENvbHVtbldpZHRoKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBheGlzT3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoUmF0aW8sIG1heENvbHVtbldpZHRoUmF0aW8pIHtcbiAgY29uc3Qgcm90YXRpb24gPSBhbmdsZUJldHdlZW4oc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICBjb25zdCBwYWQyID0gcm90YXRpb24gKiAoMSAtIGNvbHVtbldpZHRoUmF0aW8pIC8gMjtcbiAgc3RhcnRBbmdsZSArPSBwYWQyO1xuICBlbmRBbmdsZSAtPSBwYWQyO1xuICBpZiAocm90YXRpb24gPCAxZS0zKSB7XG4gICAgcmV0dXJuIDIgKiBheGlzT3V0ZXJSYWRpdXMgKiBtYXhDb2x1bW5XaWR0aFJhdGlvO1xuICB9XG4gIGlmIChyb3RhdGlvbiA+PSAyICogTWF0aC5QSSkge1xuICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHJvdGF0aW9uIC8gMjtcbiAgICBzdGFydEFuZ2xlID0gbWlkQW5nbGUgLSBNYXRoLlBJO1xuICAgIGVuZEFuZ2xlID0gbWlkQW5nbGUgKyBNYXRoLlBJO1xuICB9XG4gIGNvbnN0IHN0YXJ0WCA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBzdGFydFkgPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgY29uc3QgZW5kWCA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgY29uc3QgZW5kWSA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgY29uc3QgY29sV2lkdGggPSBNYXRoLmZsb29yKE1hdGguc3FydCgoc3RhcnRYIC0gZW5kWCkgKiogMiArIChzdGFydFkgLSBlbmRZKSAqKiAyKSk7XG4gIGNvbnN0IG1heFdpZHRoID0gMiAqIGF4aXNPdXRlclJhZGl1cyAqIG1heENvbHVtbldpZHRoUmF0aW87XG4gIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLm1pbihtYXhXaWR0aCwgY29sV2lkdGgpKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc3ZnUGF0aC50c1xudmFyIFN2Z1BhdGggPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW18sIGNvbW1hbmQsIHBhcmFtc1N0cmluZ10gb2YgZC5tYXRjaEFsbCgvKFtBLVpdKShbMC05LiBdKykvZykpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcmFtc1N0cmluZy5zcGxpdChcIiBcIikubWFwKE51bWJlcik7XG4gICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW2NvbW1hbmQsIHBhcmFtc10pO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSB9ID0gdGhpcztcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgbGV0IGxhc3RYID0geDtcbiAgICBsZXQgbGFzdFkgPSB5O1xuICAgIGZvciAoY29uc3QgW2NvbW1hbmQsIHBhcmFtc10gb2YgdGhpcy5jb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgcGF0aC5tb3ZlVG8oeCArIHBhcmFtc1swXSwgeSArIHBhcmFtc1sxXSk7XG4gICAgICAgICAgbGFzdFggPSB4ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgICAgICAgeCArIHBhcmFtc1swXSxcbiAgICAgICAgICAgIHkgKyBwYXJhbXNbMV0sXG4gICAgICAgICAgICB4ICsgcGFyYW1zWzJdLFxuICAgICAgICAgICAgeSArIHBhcmFtc1szXSxcbiAgICAgICAgICAgIHggKyBwYXJhbXNbNF0sXG4gICAgICAgICAgICB5ICsgcGFyYW1zWzVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsYXN0WCA9IHggKyBwYXJhbXNbNF07XG4gICAgICAgICAgbGFzdFkgPSB5ICsgcGFyYW1zWzVdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHBhdGgubGluZVRvKHggKyBwYXJhbXNbMF0sIGxhc3RZKTtcbiAgICAgICAgICBsYXN0WCA9IHkgKyBwYXJhbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcGF0aC5saW5lVG8oeCArIHBhcmFtc1swXSwgeSArIHBhcmFtc1sxXSk7XG4gICAgICAgICAgbGFzdFggPSB4ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGxhc3RZID0geSArIHBhcmFtc1sxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgeSArIHBhcmFtc1swXSk7XG4gICAgICAgICAgbGFzdFkgPSB5ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHRyYW5zbGF0ZSBjb21tYW5kICcke2NvbW1hbmR9JyB3aXRoICcke3BhcmFtcy5qb2luKFwiIFwiKX0nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU3ZnUGF0aC5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTdmdQYXRoLnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9pbnRlZ3JhdGVkLWNoYXJ0cy1zY2VuZS50c1xudmFyIG1vdGlvbiA9IHsgLi4uZnJvbVRvTW90aW9uX2V4cG9ydHMsIC4uLnJlc2V0TW90aW9uX2V4cG9ydHMgfTtcbnZhciBnZXRGb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvaW50ZWdyYXRlZC1jaGFydHMtdGhlbWUudHNcbnZhciBpbnRlZ3JhdGVkX2NoYXJ0c190aGVtZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbnRlZ3JhdGVkX2NoYXJ0c190aGVtZV9leHBvcnRzLCB7XG4gIENBUlRFU0lBTl9BWElTX1RZUEU6ICgpID0+IENBUlRFU0lBTl9BWElTX1RZUEUsXG4gIENoYXJ0VGhlbWU6ICgpID0+IENoYXJ0VGhlbWUsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEw6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUjogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLFxuICBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEw6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCxcbiAgREVGQVVMVF9BWElTX0dSSURfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsXG4gIERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUjogKCkgPT4gREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSLFxuICBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLFxuICBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UOiAoKSA9PiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULFxuICBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFOiAoKSA9PiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICBERUZBVUxUX0NPTE9VUlM6ICgpID0+IERFRkFVTFRfQ09MT1VSUyxcbiAgREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVI6ICgpID0+IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFOiAoKSA9PiBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLFxuICBERUZBVUxUX0ZPTlRfRkFNSUxZOiAoKSA9PiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQ6ICgpID0+IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCxcbiAgREVGQVVMVF9ISUVSQVJDSFlfRklMTFM6ICgpID0+IERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTLFxuICBERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTOiAoKSA9PiBERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLFxuICBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxuICBERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfTEFCRUxfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLFxuICBERUZBVUxUX1BBRERJTkc6ICgpID0+IERFRkFVTFRfUEFERElORyxcbiAgREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFOiAoKSA9PiBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsXG4gIERFRkFVTFRfU0hBRE9XX0NPTE9VUjogKCkgPT4gREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICBERUZBVUxUX1RFWFRCT1hfQ09MT1I6ICgpID0+IERFRkFVTFRfVEVYVEJPWF9DT0xPUixcbiAgREVGQVVMVF9URVhUQk9YX0ZJTEw6ICgpID0+IERFRkFVTFRfVEVYVEJPWF9GSUxMLFxuICBERUZBVUxUX1RFWFRCT1hfU1RST0tFOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfU1RST0tFLFxuICBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUjogKCkgPT4gREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IsXG4gIERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTjogKCkgPT4gREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLFxuICBGT05UX1NJWkU6ICgpID0+IEZPTlRfU0laRSxcbiAgRk9OVF9XRUlHSFQ6ICgpID0+IEZPTlRfV0VJR0hUMixcbiAgSVNfREFSS19USEVNRTogKCkgPT4gSVNfREFSS19USEVNRSxcbiAgUEFMRVRURV9BTFRfRE9XTl9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9ET1dOX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX0RPV05fU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSxcbiAgUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSxcbiAgUEFMRVRURV9BTFRfVVBfRklMTDogKCkgPT4gUEFMRVRURV9BTFRfVVBfRklMTCxcbiAgUEFMRVRURV9BTFRfVVBfU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9VUF9TVFJPS0UsXG4gIFBBTEVUVEVfRE9XTl9GSUxMOiAoKSA9PiBQQUxFVFRFX0RPV05fRklMTCxcbiAgUEFMRVRURV9ET1dOX1NUUk9LRTogKCkgPT4gUEFMRVRURV9ET1dOX1NUUk9LRSxcbiAgUEFMRVRURV9ORVVUUkFMX0ZJTEw6ICgpID0+IFBBTEVUVEVfTkVVVFJBTF9GSUxMLFxuICBQQUxFVFRFX05FVVRSQUxfU1RST0tFOiAoKSA9PiBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICBQQUxFVFRFX1VQX0ZJTEw6ICgpID0+IFBBTEVUVEVfVVBfRklMTCxcbiAgUEFMRVRURV9VUF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfVVBfU1RST0tFLFxuICBQT0xBUl9BWElTX1NIQVBFOiAoKSA9PiBQT0xBUl9BWElTX1NIQVBFLFxuICBQT0xBUl9BWElTX1RZUEU6ICgpID0+IFBPTEFSX0FYSVNfVFlQRSxcbiAgUE9TSVRJT046ICgpID0+IFBPU0lUSU9OMixcbiAgZ2V0Q2hhcnRUaGVtZTogKCkgPT4gZ2V0Q2hhcnRUaGVtZSxcbiAgbWFya2VyUGFsZXR0ZUZhY3Rvcnk6ICgpID0+IG1hcmtlclBhbGV0dGVGYWN0b3J5LFxuICBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeTogKCkgPT4gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnksXG4gIHRoZW1lczogKCkgPT4gdGhlbWVzMlxufSk7XG52YXIgdGhlbWVzMiA9IG1hcFZhbHVlcyhcbiAgdGhlbWVzLFxuICAodGhlbWVGYWN0b3J5KSA9PiB0aGVtZUZhY3Rvcnk/LigpXG4pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zcGFya2xpbmVzLXNjYWxlLnRzXG52YXIgc3BhcmtsaW5lc19zY2FsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChzcGFya2xpbmVzX3NjYWxlX2V4cG9ydHMsIHtcbiAgQmFuZFNjYWxlOiAoKSA9PiBCYW5kU2NhbGUsXG4gIENvbG9yU2NhbGU6ICgpID0+IENvbG9yU2NhbGUsXG4gIENvbnRpbnVvdXNTY2FsZTogKCkgPT4gQ29udGludW91c1NjYWxlLFxuICBJbnZhbGlkYXRpbmc6ICgpID0+IEludmFsaWRhdGluZyxcbiAgTGluZWFyU2NhbGU6ICgpID0+IExpbmVhclNjYWxlLFxuICBPcmRpbmFsVGltZVNjYWxlOiAoKSA9PiBPcmRpbmFsVGltZVNjYWxlLFxuICBUaW1lU2NhbGU6ICgpID0+IFRpbWVTY2FsZVxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NwYXJrbGluZXMtdXRpbC50c1xudmFyIHNwYXJrbGluZXNfdXRpbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzcGFya2xpbmVzX3V0aWxfZXhwb3J0cywge1xuICBDb2xvcjogKCkgPT4gQ29sb3IsXG4gIERlYnVnOiAoKSA9PiBEZWJ1ZyxcbiAgTG9nZ2VyOiAoKSA9PiBMb2dnZXIsXG4gIFBhZGRpbmc6ICgpID0+IFBhZGRpbmcsXG4gIFRpbWVJbnRlcnZhbDogKCkgPT4gVGltZUludGVydmFsLFxuICBWZWMyOiAoKSA9PiBWZWMyLFxuICBhbmdsZUJldHdlZW46ICgpID0+IGFuZ2xlQmV0d2VlbixcbiAgYW5nbGVEaWZmOiAoKSA9PiBhbmdsZURpZmYsXG4gIGFyZUFycmF5TnVtYmVyc0VxdWFsOiAoKSA9PiBhcmVBcnJheU51bWJlcnNFcXVhbCxcbiAgYmlmdXJjYXRlOiAoKSA9PiBiaWZ1cmNhdGUsXG4gIGNoZWNrRGF0dW06ICgpID0+IGNoZWNrRGF0dW0sXG4gIGNsYW1wOiAoKSA9PiBjbGFtcCxcbiAgY2xhbXBBcnJheTogKCkgPT4gY2xhbXBBcnJheSxcbiAgY291bnRGcmFjdGlvbkRpZ2l0czogKCkgPT4gY291bnRGcmFjdGlvbkRpZ2l0cyxcbiAgY3JlYXRlSWQ6ICgpID0+IGNyZWF0ZUlkLFxuICBkYXk6ICgpID0+IGRheSxcbiAgZGVlcENsb25lOiAoKSA9PiBkZWVwQ2xvbmUsXG4gIGRpc3BsYWNlUG9pbnRGcm9tVmVjdG9yOiAoKSA9PiBkaXNwbGFjZVBvaW50RnJvbVZlY3RvcixcbiAgZXh0ZW50OiAoKSA9PiBleHRlbnQsXG4gIGZpbmRNaW5NYXg6ICgpID0+IGZpbmRNaW5NYXgsXG4gIGZpbmRSYW5nZUV4dGVudDogKCkgPT4gZmluZFJhbmdlRXh0ZW50LFxuICBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZTogKCkgPT4gZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2UsXG4gIGZvcm1hdFBlcmNlbnRhZ2U6ICgpID0+IGZvcm1hdFBlcmNlbnRhZ2UsXG4gIGZyaWRheTogKCkgPT4gZnJpZGF5LFxuICBob3VyOiAoKSA9PiBob3VyLFxuICBpbnRlcnBvbGF0ZUNvbG9yOiAoKSA9PiBpbnRlcnBvbGF0ZUNvbG9yLFxuICBpbnRlcnBvbGF0ZU51bWJlcjogKCkgPT4gaW50ZXJwb2xhdGVOdW1iZXIsXG4gIGlzQmV0d2VlbkFuZ2xlczogKCkgPT4gaXNCZXR3ZWVuQW5nbGVzLFxuICBpc0NvbnRpbnVvdXM6ICgpID0+IGlzQ29udGludW91cyxcbiAgaXNEYXRlOiAoKSA9PiBpc1ZhbGlkRGF0ZSxcbiAgaXNEZW5zZUludGVydmFsOiAoKSA9PiBpc0RlbnNlSW50ZXJ2YWwsXG4gIGlzRXF1YWw6ICgpID0+IGlzRXF1YWwsXG4gIGlzTmVnYXRpdmU6ICgpID0+IGlzTmVnYXRpdmUsXG4gIGlzTnVtYmVyOiAoKSA9PiBpc0Zpbml0ZU51bWJlcixcbiAgaXNOdW1iZXJFcXVhbDogKCkgPT4gaXNFcXVhbCxcbiAgaXNOdW1iZXJPYmplY3Q6ICgpID0+IGlzTnVtYmVyT2JqZWN0LFxuICBpc1N0cmluZzogKCkgPT4gaXNTdHJpbmcsXG4gIGlzU3RyaW5nT2JqZWN0OiAoKSA9PiBpc1N0cmluZ09iamVjdCxcbiAganNvbkFwcGx5OiAoKSA9PiBqc29uQXBwbHksXG4gIGpzb25EaWZmOiAoKSA9PiBqc29uRGlmZixcbiAganNvbldhbGs6ICgpID0+IGpzb25XYWxrLFxuICBtaWxsaXNlY29uZDogKCkgPT4gbWlsbGlzZWNvbmQsXG4gIG1pbnV0ZTogKCkgPT4gbWludXRlLFxuICBtb2Q6ICgpID0+IG1vZCxcbiAgbW9uZGF5OiAoKSA9PiBtb25kYXksXG4gIG1vbnRoOiAoKSA9PiBtb250aCxcbiAgbm9ybWFsaXNlZEV4dGVudDogKCkgPT4gbm9ybWFsaXNlZEV4dGVudCxcbiAgbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YTogKCkgPT4gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YSxcbiAgbm9ybWFsaXplQW5nbGUxODA6ICgpID0+IG5vcm1hbGl6ZUFuZ2xlMTgwLFxuICBub3JtYWxpemVBbmdsZTM2MDogKCkgPT4gbm9ybWFsaXplQW5nbGUzNjAsXG4gIG5vcm1hbGl6ZUFuZ2xlMzYwSW5jbHVzaXZlOiAoKSA9PiBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZSxcbiAgcmFuZ2U6ICgpID0+IHJhbmdlLFxuICByZXNldElkczogKCkgPT4gcmVzZXRJZHMsXG4gIHJvdW5kOiAoKSA9PiByb3VuZCxcbiAgc2FuaXRpemVIdG1sOiAoKSA9PiBzYW5pdGl6ZUh0bWwsXG4gIHNhdHVyZGF5OiAoKSA9PiBzYXR1cmRheSxcbiAgc2Vjb25kOiAoKSA9PiBzZWNvbmQsXG4gIHNldEF0dHJpYnV0ZTogKCkgPT4gc2V0QXR0cmlidXRlLFxuICBzZXRWaXNpYmlsaXR5OiAoKSA9PiBzZXRWaXNpYmlsaXR5LFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc3VuZGF5OiAoKSA9PiBzdW5kYXksXG4gIHRodXJzZGF5OiAoKSA9PiB0aHVyc2RheSxcbiAgdGlja0Zvcm1hdDogKCkgPT4gdGlja0Zvcm1hdCxcbiAgdGlja1N0ZXA6ICgpID0+IHRpY2tTdGVwLFxuICB0aWNrczogKCkgPT4gY3JlYXRlVGlja3MsXG4gIHRvRGVncmVlczogKCkgPT4gdG9EZWdyZWVzLFxuICB0b0ZpeGVkOiAoKSA9PiB0b0ZpeGVkLFxuICB0b1JhZGlhbnM6ICgpID0+IHRvUmFkaWFucyxcbiAgdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWU6ICgpID0+IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlLFxuICB0dWVzZGF5OiAoKSA9PiB0dWVzZGF5LFxuICB1dGNEYXk6ICgpID0+IHV0Y0RheSxcbiAgdXRjSG91cjogKCkgPT4gdXRjSG91cixcbiAgdXRjTWludXRlOiAoKSA9PiB1dGNNaW51dGUsXG4gIHV0Y01vbnRoOiAoKSA9PiB1dGNNb250aCxcbiAgdXRjWWVhcjogKCkgPT4gdXRjWWVhcixcbiAgdXVpZDogKCkgPT4gdXVpZCxcbiAgd2VkbmVzZGF5OiAoKSA9PiB3ZWRuZXNkYXksXG4gIHllYXI6ICgpID0+IHllYXIsXG4gIHppcE9iamVjdDogKCkgPT4gemlwT2JqZWN0XG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92ZWN0b3IudHNcbnZhciBWZWMyID0ge1xuICBhZGQsXG4gIGFuZ2xlLFxuICBhcHBseSxcbiAgZXF1YWwsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZTIsXG4gIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMixcbiAgZnJvbSxcbiAgZnJvbU9mZnNldCxcbiAgbGVuZ3RoLFxuICBsZW5ndGhTcXVhcmVkLFxuICByZXF1aXJlZCxcbiAgcm90YXRlLFxuICBzdWJcbn07XG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICByZXR1cm4geyB4OiBhLnggKyBiLngsIHk6IGEueSArIGIueSB9O1xufVxuZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgcmV0dXJuIHsgeDogYS54IC0gYi54LCB5OiBhLnkgLSBiLnkgfTtcbn1cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcbn1cbmZ1bmN0aW9uIGxlbmd0aFNxdWFyZWQoYSkge1xuICByZXR1cm4gYS54ICogYS54ICsgYS55ICogYS55O1xufVxuZnVuY3Rpb24gZGlzdGFuY2UyKGEsIGIpIHtcbiAgY29uc3QgZCA9IHN1YihhLCBiKTtcbiAgcmV0dXJuIE1hdGguc3FydChkLnggKiBkLnggKyBkLnkgKiBkLnkpO1xufVxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmVkMihhLCBiKSB7XG4gIGNvbnN0IGQgPSBzdWIoYSwgYik7XG4gIHJldHVybiBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG59XG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKGEueSwgYS54KSAtIE1hdGguYXRhbjIoYi55LCBiLngpO1xufVxuZnVuY3Rpb24gcm90YXRlKGEsIHRoZXRhLCBiID0gcmVxdWlyZWQoKSkge1xuICBjb25zdCBsID0gVmVjMi5sZW5ndGgoYSk7XG4gIHJldHVybiB7IHg6IGIueCArIGwgKiBNYXRoLmNvcyh0aGV0YSksIHk6IGIueSArIGwgKiBNYXRoLnNpbih0aGV0YSkgfTtcbn1cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xufVxuZnVuY3Rpb24gZnJvbSh4LCB5KSB7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cbmZ1bmN0aW9uIGZyb21PZmZzZXQoYSkge1xuICByZXR1cm4geyB4OiBhLm9mZnNldFgsIHk6IGEub2Zmc2V0WSB9O1xufVxuZnVuY3Rpb24gYXBwbHkoYSwgYikge1xuICBhLnggPSBiLng7XG4gIGEueSA9IGIueTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiByZXF1aXJlZChhKSB7XG4gIHJldHVybiB7IHg6IGE/LnggPz8gMCwgeTogYT8ueSA/PyAwIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvemlwLnRzXG5mdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gIGNvbnN0IHppcHBlZCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB6aXBwZWRbYCR7a2V5c1tpXX1gXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB6aXBwZWRbYCR7a2V5c1tpXX1gXSA9IHZhbHVlcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHppcHBlZDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlLXN1cHBvcnQudHNcbnZhciBtb2R1bGVfc3VwcG9ydF9leHBvcnRzID0ge307XG5fX2V4cG9ydChtb2R1bGVfc3VwcG9ydF9leHBvcnRzLCB7XG4gIEFORDogKCkgPT4gQU5ELFxuICBBUlJBWTogKCkgPT4gQVJSQVksXG4gIEFSUkFZX09GOiAoKSA9PiBBUlJBWV9PRixcbiAgQWJzdHJhY3RCYXJTZXJpZXM6ICgpID0+IEFic3RyYWN0QmFyU2VyaWVzLFxuICBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXM6ICgpID0+IEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyxcbiAgQWN0aW9uT25TZXQ6ICgpID0+IEFjdGlvbk9uU2V0LFxuICBBbmltYXRpb246ICgpID0+IEFuaW1hdGlvbixcbiAgQW5pbWF0aW9uTWFuYWdlcjogKCkgPT4gQW5pbWF0aW9uTWFuYWdlcixcbiAgQXJlYVNlcmllc1RhZzogKCkgPT4gQXJlYVNlcmllc1RhZyxcbiAgQXhpczogKCkgPT4gQXhpcyxcbiAgQXhpc0ludGVydmFsOiAoKSA9PiBBeGlzSW50ZXJ2YWwsXG4gIEF4aXNMYWJlbDogKCkgPT4gQXhpc0xhYmVsLFxuICBBeGlzVGljazogKCkgPT4gQXhpc1RpY2ssXG4gIEF4aXNUaWNrczogKCkgPT4gQXhpc1RpY2tzLFxuICBCT09MRUFOOiAoKSA9PiBCT09MRUFOLFxuICBCT09MRUFOX0FSUkFZOiAoKSA9PiBCT09MRUFOX0FSUkFZLFxuICBCYWNrZ3JvdW5kOiAoKSA9PiBCYWNrZ3JvdW5kLFxuICBCYWNrZ3JvdW5kTW9kdWxlOiAoKSA9PiBCYWNrZ3JvdW5kTW9kdWxlLFxuICBCYXNlTW9kdWxlSW5zdGFuY2U6ICgpID0+IEJhc2VNb2R1bGVJbnN0YW5jZSxcbiAgQmFzZVByb3BlcnRpZXM6ICgpID0+IEJhc2VQcm9wZXJ0aWVzLFxuICBDT0xPUl9TVFJJTkc6ICgpID0+IENPTE9SX1NUUklORyxcbiAgQ09MT1JfU1RSSU5HX0FSUkFZOiAoKSA9PiBDT0xPUl9TVFJJTkdfQVJSQVksXG4gIENhY2hlZFRleHRNZWFzdXJlcjogKCkgPT4gQ2FjaGVkVGV4dE1lYXN1cmVyLFxuICBDYWNoZWRUZXh0TWVhc3VyZXJQb29sOiAoKSA9PiBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLFxuICBDYXJ0ZXNpYW5BeGlzOiAoKSA9PiBDYXJ0ZXNpYW5BeGlzLFxuICBDYXJ0ZXNpYW5TZXJpZXM6ICgpID0+IENhcnRlc2lhblNlcmllcyxcbiAgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50OiAoKSA9PiBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQsXG4gIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXM6ICgpID0+IENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMsXG4gIENhdGVnb3J5QXhpczogKCkgPT4gQ2F0ZWdvcnlBeGlzLFxuICBDaGFydEF4aXNEaXJlY3Rpb246ICgpID0+IENoYXJ0QXhpc0RpcmVjdGlvbixcbiAgQ2hhcnRFdmVudE1hbmFnZXI6ICgpID0+IENoYXJ0RXZlbnRNYW5hZ2VyLFxuICBDaGFydE9wdGlvbnM6ICgpID0+IENoYXJ0T3B0aW9ucyxcbiAgQ2hhcnRVcGRhdGVUeXBlOiAoKSA9PiBDaGFydFVwZGF0ZVR5cGUsXG4gIENvbnRleHRNZW51UmVnaXN0cnk6ICgpID0+IENvbnRleHRNZW51UmVnaXN0cnksXG4gIEN1cnNvcjogKCkgPT4gQ3Vyc29yLFxuICBDdXJzb3JNYW5hZ2VyOiAoKSA9PiBDdXJzb3JNYW5hZ2VyLFxuICBEQVRFOiAoKSA9PiBEQVRFLFxuICBEQVRFX0FSUkFZOiAoKSA9PiBEQVRFX0FSUkFZLFxuICBEQVRFX09SX0RBVEVUSU1FX01TOiAoKSA9PiBEQVRFX09SX0RBVEVUSU1FX01TLFxuICBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUzogKCkgPT4gREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUzogKCkgPT4gREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICBERUZBVUxUX1RPT0xUSVBfQ0xBU1M6ICgpID0+IERFRkFVTFRfVE9PTFRJUF9DTEFTUyxcbiAgREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1M6ICgpID0+IERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTLFxuICBERUdSRUU6ICgpID0+IERFR1JFRSxcbiAgRElSRUNUSU9OOiAoKSA9PiBESVJFQ1RJT04sXG4gIERPTU1hbmFnZXI6ICgpID0+IERPTU1hbmFnZXIsXG4gIERhdGFDb250cm9sbGVyOiAoKSA9PiBEYXRhQ29udHJvbGxlcixcbiAgRGF0YU1vZGVsOiAoKSA9PiBEYXRhTW9kZWwsXG4gIERhdGFNb2RlbFNlcmllczogKCkgPT4gRGF0YU1vZGVsU2VyaWVzLFxuICBEYXRhU2VydmljZTogKCkgPT4gRGF0YVNlcnZpY2UsXG4gIERlZmF1bHQ6ICgpID0+IERlZmF1bHQsXG4gIERlcHJlY2F0ZWQ6ICgpID0+IERlcHJlY2F0ZWQsXG4gIERlcHJlY2F0ZWRBbmRSZW5hbWVkVG86ICgpID0+IERlcHJlY2F0ZWRBbmRSZW5hbWVkVG8sXG4gIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDogKCkgPT4gRU1QVFlfVE9PTFRJUF9DT05URU5ULFxuICBGT05UX1NUWUxFOiAoKSA9PiBGT05UX1NUWUxFLFxuICBGT05UX1dFSUdIVDogKCkgPT4gRk9OVF9XRUlHSFQsXG4gIEZVTkNUSU9OOiAoKSA9PiBGVU5DVElPTixcbiAgR1JFQVRFUl9USEFOOiAoKSA9PiBHUkVBVEVSX1RIQU4sXG4gIEdlc3R1cmVEZXRlY3RvcjogKCkgPT4gR2VzdHVyZURldGVjdG9yLFxuICBHcm91cGVkQ2F0ZWdvcnlBeGlzOiAoKSA9PiBHcm91cGVkQ2F0ZWdvcnlBeGlzLFxuICBIaWVyYXJjaHlOb2RlOiAoKSA9PiBIaWVyYXJjaHlOb2RlLFxuICBIaWVyYXJjaHlTZXJpZXM6ICgpID0+IEhpZXJhcmNoeVNlcmllcyxcbiAgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllczogKCkgPT4gSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcyxcbiAgSGlnaGxpZ2h0TWFuYWdlcjogKCkgPT4gSGlnaGxpZ2h0TWFuYWdlcixcbiAgSGlnaGxpZ2h0UHJvcGVydGllczogKCkgPT4gSGlnaGxpZ2h0UHJvcGVydGllcyxcbiAgSGlnaGxpZ2h0U3R5bGU6ICgpID0+IEhpZ2hsaWdodFN0eWxlLFxuICBJTlRFUkFDVElPTl9SQU5HRTogKCkgPT4gSU5URVJBQ1RJT05fUkFOR0UsXG4gIElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTjogKCkgPT4gSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OLFxuICBJTlRFUlBPTEFUSU9OX1RZUEU6ICgpID0+IElOVEVSUE9MQVRJT05fVFlQRSxcbiAgSW50ZXJhY3Rpb25NYW5hZ2VyOiAoKSA9PiBJbnRlcmFjdGlvbk1hbmFnZXIsXG4gIEludGVyYWN0aW9uU3RhdGU6ICgpID0+IEludGVyYWN0aW9uU3RhdGUsXG4gIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzOiAoKSA9PiBJbnRlcnBvbGF0aW9uUHJvcGVydGllcyxcbiAgS2V5TmF2TWFuYWdlcjogKCkgPT4gS2V5TmF2TWFuYWdlcixcbiAgTEFCRUxfUExBQ0VNRU5UOiAoKSA9PiBMQUJFTF9QTEFDRU1FTlQsXG4gIExBUkdFU1RfS0VZX0lOVEVSVkFMOiAoKSA9PiBMQVJHRVNUX0tFWV9JTlRFUlZBTCxcbiAgTEVTU19USEFOOiAoKSA9PiBMRVNTX1RIQU4sXG4gIExJTkVfQ0FQOiAoKSA9PiBMSU5FX0NBUCxcbiAgTElORV9EQVNIOiAoKSA9PiBMSU5FX0RBU0gsXG4gIExJTkVfSk9JTjogKCkgPT4gTElORV9KT0lOLFxuICBMYXllcnM6ICgpID0+IExheWVycyxcbiAgTGF5b3V0U2VydmljZTogKCkgPT4gTGF5b3V0U2VydmljZSxcbiAgTG9uTGF0QkJveDogKCkgPT4gTG9uTGF0QkJveCxcbiAgTUFSS0VSX1NIQVBFOiAoKSA9PiBNQVJLRVJfU0hBUEUsXG4gIE1BVENISU5HX0NST1NTTElORV9UWVBFOiAoKSA9PiBNQVRDSElOR19DUk9TU0xJTkVfVFlQRSxcbiAgTUFYX1NQQUNJTkc6ICgpID0+IE1BWF9TUEFDSU5HLFxuICBNSU5fU1BBQ0lORzogKCkgPT4gTUlOX1NQQUNJTkcsXG4gIE1lcmNhdG9yU2NhbGU6ICgpID0+IE1lcmNhdG9yU2NhbGUsXG4gIE1vZHVsZVJlZ2lzdHJ5OiAoKSA9PiBNb2R1bGVSZWdpc3RyeSxcbiAgTW90aW9uOiAoKSA9PiBlYXNpbmdfZXhwb3J0cyxcbiAgTkFOOiAoKSA9PiBOQU4sXG4gIE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkc6ICgpID0+IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkcsXG4gIE5VTUJFUjogKCkgPT4gTlVNQkVSLFxuICBOVU1CRVJfQVJSQVk6ICgpID0+IE5VTUJFUl9BUlJBWSxcbiAgTlVNQkVSX09SX05BTjogKCkgPT4gTlVNQkVSX09SX05BTixcbiAgTmF2aWdhdG9yOiAoKSA9PiBOYXZpZ2F0b3IsXG4gIE5hdmlnYXRvck1vZHVsZTogKCkgPT4gTmF2aWdhdG9yTW9kdWxlLFxuICBPQkpFQ1Q6ICgpID0+IE9CSkVDVCxcbiAgT0JKRUNUX0FSUkFZOiAoKSA9PiBPQkpFQ1RfQVJSQVksXG4gIE9SOiAoKSA9PiBPUixcbiAgT1ZFUkZMT1dfU1RSQVRFR1k6ICgpID0+IE9WRVJGTE9XX1NUUkFURUdZLFxuICBPYnNlcnZlQ2hhbmdlczogKCkgPT4gT2JzZXJ2ZUNoYW5nZXMsXG4gIFBIQVNFX01FVEFEQVRBOiAoKSA9PiBQSEFTRV9NRVRBREFUQSxcbiAgUEhBU0VfT1JERVI6ICgpID0+IFBIQVNFX09SREVSLFxuICBQTEFDRU1FTlQ6ICgpID0+IFBMQUNFTUVOVCxcbiAgUExBSU5fT0JKRUNUOiAoKSA9PiBQTEFJTl9PQkpFQ1QsXG4gIFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVM6ICgpID0+IFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMsXG4gIFBPU0lUSU9OOiAoKSA9PiBQT1NJVElPTixcbiAgUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTOiAoKSA9PiBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMsXG4gIFBPU0lUSVZFX05VTUJFUjogKCkgPT4gUE9TSVRJVkVfTlVNQkVSLFxuICBQb2xhckF4aXM6ICgpID0+IFBvbGFyQXhpcyxcbiAgUG9sYXJTZXJpZXM6ICgpID0+IFBvbGFyU2VyaWVzLFxuICBQcm9wZXJ0aWVzQXJyYXk6ICgpID0+IFByb3BlcnRpZXNBcnJheSxcbiAgUHJveHlPbldyaXRlOiAoKSA9PiBQcm94eU9uV3JpdGUsXG4gIFByb3h5UHJvcGVydHk6ICgpID0+IFByb3h5UHJvcGVydHksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlOiAoKSA9PiBQcm94eVByb3BlcnR5T25Xcml0ZSxcbiAgUVVJQ0tfVFJBTlNJVElPTjogKCkgPT4gUVVJQ0tfVFJBTlNJVElPTixcbiAgUkFUSU86ICgpID0+IFJBVElPLFxuICBSRUdJT05TOiAoKSA9PiBSRUdJT05TLFxuICBSZWdpb25NYW5hZ2VyOiAoKSA9PiBSZWdpb25NYW5hZ2VyLFxuICBSZXBlYXRUeXBlOiAoKSA9PiBSZXBlYXRUeXBlLFxuICBTS0lQX0pTX0JVSUxUSU5TOiAoKSA9PiBTS0lQX0pTX0JVSUxUSU5TLFxuICBTTUFMTEVTVF9LRVlfSU5URVJWQUw6ICgpID0+IFNNQUxMRVNUX0tFWV9JTlRFUlZBTCxcbiAgU09SVF9ET01BSU5fR1JPVVBTOiAoKSA9PiBTT1JUX0RPTUFJTl9HUk9VUFMsXG4gIFNUUklORzogKCkgPT4gU1RSSU5HLFxuICBTVFJJTkdfQVJSQVk6ICgpID0+IFNUUklOR19BUlJBWSxcbiAgU2VyaWVzOiAoKSA9PiBTZXJpZXMsXG4gIFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50OiAoKSA9PiBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCxcbiAgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlOiAoKSA9PiBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUsXG4gIFNlcmllc01hcmtlcjogKCkgPT4gU2VyaWVzTWFya2VyLFxuICBTZXJpZXNOb2RlRXZlbnQ6ICgpID0+IFNlcmllc05vZGVFdmVudCxcbiAgU2VyaWVzTm9kZVBpY2tNb2RlOiAoKSA9PiBTZXJpZXNOb2RlUGlja01vZGUsXG4gIFNlcmllc1Byb3BlcnRpZXM6ICgpID0+IFNlcmllc1Byb3BlcnRpZXMsXG4gIFNlcmllc1Rvb2x0aXA6ICgpID0+IFNlcmllc1Rvb2x0aXAsXG4gIFNpbXBsZVRleHRNZWFzdXJlcjogKCkgPT4gU2ltcGxlVGV4dE1lYXN1cmVyLFxuICBTdGF0ZU1hY2hpbmU6ICgpID0+IFN0YXRlTWFjaGluZSxcbiAgVEVYVF9BTElHTjogKCkgPT4gVEVYVF9BTElHTixcbiAgVEVYVF9XUkFQOiAoKSA9PiBURVhUX1dSQVAsXG4gIFRJQ0tfSU5URVJWQUw6ICgpID0+IFRJQ0tfSU5URVJWQUwsXG4gIFRleHRVdGlsczogKCkgPT4gVGV4dFV0aWxzLFxuICBUZXh0V3JhcHBlcjogKCkgPT4gVGV4dFdyYXBwZXIsXG4gIFRvb2xiYXJNYW5hZ2VyOiAoKSA9PiBUb29sYmFyTWFuYWdlcixcbiAgVG9vbHRpcDogKCkgPT4gVG9vbHRpcCxcbiAgVG9vbHRpcE1hbmFnZXI6ICgpID0+IFRvb2x0aXBNYW5hZ2VyLFxuICBUb29sdGlwUG9zaXRpb246ICgpID0+IFRvb2x0aXBQb3NpdGlvbixcbiAgVU5JT046ICgpID0+IFVOSU9OLFxuICBVcGRhdGVTZXJ2aWNlOiAoKSA9PiBVcGRhdGVTZXJ2aWNlLFxuICBWRVJUSUNBTF9BTElHTjogKCkgPT4gVkVSVElDQUxfQUxJR04sXG4gIFZhbGlkYXRlOiAoKSA9PiBWYWxpZGF0ZSxcbiAgWm9vbU1hbmFnZXI6ICgpID0+IFpvb21NYW5hZ2VyLFxuICBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT046ICgpID0+IF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTixcbiAgYWNjdW11bGF0ZUdyb3VwOiAoKSA9PiBhY2N1bXVsYXRlR3JvdXAsXG4gIGFjY3VtdWxhdGVTdGFjazogKCkgPT4gYWNjdW11bGF0ZVN0YWNrLFxuICBhY2N1bXVsYXRlZFZhbHVlOiAoKSA9PiBhY2N1bXVsYXRlZFZhbHVlLFxuICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5OiAoKSA9PiBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5LFxuICBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZTogKCkgPT4gYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUsXG4gIGFkanVzdExhYmVsUGxhY2VtZW50OiAoKSA9PiBhZGp1c3RMYWJlbFBsYWNlbWVudCxcbiAgYWxsSW5TdHJpbmdVbmlvbjogKCkgPT4gYWxsSW5TdHJpbmdVbmlvbixcbiAgYW5pbWF0aW9uVmFsaWRhdGlvbjogKCkgPT4gYW5pbWF0aW9uVmFsaWRhdGlvbixcbiAgYXJlYTogKCkgPT4gYXJlYSxcbiAgYXJyYXlzRXF1YWw6ICgpID0+IGFycmF5c0VxdWFsLFxuICBiYWNrZmlsbFBhdGhQb2ludERhdGE6ICgpID0+IGJhY2tmaWxsUGF0aFBvaW50RGF0YSxcbiAgYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb246ICgpID0+IGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uLFxuICBiaWZ1cmNhdGU6ICgpID0+IGJpZnVyY2F0ZSxcbiAgYnVpbGRGb3JtYXR0ZXI6ICgpID0+IGJ1aWxkRm9ybWF0dGVyLFxuICBidWlsZFJlc2V0UGF0aEZuOiAoKSA9PiBidWlsZFJlc2V0UGF0aEZuLFxuICBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQ6ICgpID0+IGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdCxcbiAgY2FsY3VsYXRlTGFiZWxDaGFydFBhZGRpbmc6ICgpID0+IGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nLFxuICBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uOiAoKSA9PiBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uLFxuICBjYWxjdWxhdGVQbGFjZW1lbnQ6ICgpID0+IGNhbGN1bGF0ZVBsYWNlbWVudCxcbiAgY2hlY2tDcmlzcDogKCkgPT4gY2hlY2tDcmlzcCxcbiAgY2hpbGRyZW5JdGVyOiAoKSA9PiBjaGlsZHJlbkl0ZXIsXG4gIGNpcmN1bGFyU2xpY2VBcnJheTogKCkgPT4gY2lyY3VsYXJTbGljZUFycmF5LFxuICBjbGFtcDogKCkgPT4gY2xhbXAsXG4gIGNsYW1wQXJyYXk6ICgpID0+IGNsYW1wQXJyYXksXG4gIGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb246ICgpID0+IGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24sXG4gIGNvbXB1dGVCYXJGb2N1c0JvdW5kczogKCkgPT4gY29tcHV0ZUJhckZvY3VzQm91bmRzLFxuICBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHM6ICgpID0+IGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyxcbiAgY29udmVydFZhbHVlc1RvU2NhbGVCeURlZnM6ICgpID0+IGNvbnZlcnRWYWx1ZXNUb1NjYWxlQnlEZWZzLFxuICBjb3VudEZyYWN0aW9uRGlnaXRzOiAoKSA9PiBjb3VudEZyYWN0aW9uRGlnaXRzLFxuICBjcmVhdGVEYXR1bUlkOiAoKSA9PiBjcmVhdGVEYXR1bUlkLFxuICBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmc6ICgpID0+IGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZyxcbiAgY3JlYXRlRWxlbWVudDogKCkgPT4gY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiAoKSA9PiBjcmVhdGVFbGVtZW50TlMsXG4gIGRhdGVUb051bWJlcjogKCkgPT4gZGF0ZVRvTnVtYmVyLFxuICBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzOiAoKSA9PiBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzLFxuICBkZWVwQ2xvbmU6ICgpID0+IGRlZXBDbG9uZSxcbiAgZGVlcE1lcmdlOiAoKSA9PiBkZWVwTWVyZ2UsXG4gIGRlZmF1bHRUaW1lVGlja0Zvcm1hdDogKCkgPT4gZGVmYXVsdFRpbWVUaWNrRm9ybWF0LFxuICBkZXRlcm1pbmVQYXRoU3RhdHVzOiAoKSA9PiBkZXRlcm1pbmVQYXRoU3RhdHVzLFxuICBkaWZmOiAoKSA9PiBkaWZmLFxuICBkb3dubG9hZFVybDogKCkgPT4gZG93bmxvYWRVcmwsXG4gIGVudGVycHJpc2VNb2R1bGU6ICgpID0+IGVudGVycHJpc2VNb2R1bGUsXG4gIGV4dGVudDogKCkgPT4gZXh0ZW50LFxuICBleHRyYWN0RGVjb3JhdGVkUHJvcGVydGllczogKCkgPT4gZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXMsXG4gIGZpbmRNYXhWYWx1ZTogKCkgPT4gZmluZE1heFZhbHVlLFxuICBmaW5kTWluTWF4OiAoKSA9PiBmaW5kTWluTWF4LFxuICBmaW5kUXVhZHRyZWVNYXRjaDogKCkgPT4gZmluZFF1YWR0cmVlTWF0Y2gsXG4gIGZpbmRSYW5nZUV4dGVudDogKCkgPT4gZmluZFJhbmdlRXh0ZW50LFxuICBmaXhOdW1lcmljRXh0ZW50OiAoKSA9PiBmaXhOdW1lcmljRXh0ZW50LFxuICBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZTogKCkgPT4gZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2UsXG4gIGZvcm1hdFBlcmNlbnRhZ2U6ICgpID0+IGZvcm1hdFBlcmNlbnRhZ2UsXG4gIGZyb21Ub01vdGlvbjogKCkgPT4gZnJvbVRvTW90aW9uLFxuICBnZXREb2N1bWVudDogKCkgPT4gZ2V0RG9jdW1lbnQsXG4gIGdldE1pc3NDb3VudDogKCkgPT4gZ2V0TWlzc0NvdW50LFxuICBnZXRQYXRoOiAoKSA9PiBnZXRQYXRoLFxuICBnZXRQYXRoQ29tcG9uZW50czogKCkgPT4gZ2V0UGF0aENvbXBvbmVudHMsXG4gIGdldFJlY3RDb25maWc6ICgpID0+IGdldFJlY3RDb25maWcsXG4gIGdldFdpbmRvdzogKCkgPT4gZ2V0V2luZG93LFxuICBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHk6ICgpID0+IGdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSxcbiAgZ3JvdXBBdmVyYWdlOiAoKSA9PiBncm91cEF2ZXJhZ2UsXG4gIGdyb3VwQnk6ICgpID0+IGdyb3VwQnksXG4gIGdyb3VwQ291bnQ6ICgpID0+IGdyb3VwQ291bnQsXG4gIGdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5OiAoKSA9PiBncm91cFN0YWNrVmFsdWVQcm9wZXJ0eSxcbiAgZ3JvdXBTdW06ICgpID0+IGdyb3VwU3VtLFxuICBpbml0TWVudUtleU5hdjogKCkgPT4gaW5pdE1lbnVLZXlOYXYsXG4gIGluaXRUb29sYmFyS2V5TmF2OiAoKSA9PiBpbml0VG9vbGJhcktleU5hdixcbiAgaXNBcnJheTogKCkgPT4gaXNBcnJheSxcbiAgaXNCb29sZWFuOiAoKSA9PiBpc0Jvb2xlYW4sXG4gIGlzRGF0ZTogKCkgPT4gaXNEYXRlLFxuICBpc0RlY29yYXRlZE9iamVjdDogKCkgPT4gaXNEZWNvcmF0ZWRPYmplY3QsXG4gIGlzRGVmaW5lZDogKCkgPT4gaXNEZWZpbmVkLFxuICBpc0VudW1LZXk6ICgpID0+IGlzRW51bUtleSxcbiAgaXNFbnVtVmFsdWU6ICgpID0+IGlzRW51bVZhbHVlLFxuICBpc0VxdWFsOiAoKSA9PiBpc0VxdWFsLFxuICBpc0Zpbml0ZU51bWJlcjogKCkgPT4gaXNGaW5pdGVOdW1iZXIsXG4gIGlzRnVuY3Rpb246ICgpID0+IGlzRnVuY3Rpb24sXG4gIGlzSHRtbEVsZW1lbnQ6ICgpID0+IGlzSHRtbEVsZW1lbnQsXG4gIGlzTmVnYXRpdmU6ICgpID0+IGlzTmVnYXRpdmUsXG4gIGlzTnVtYmVyOiAoKSA9PiBpc051bWJlcixcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBpc09iamVjdExpa2U6ICgpID0+IGlzT2JqZWN0TGlrZSxcbiAgaXNQbGFpbk9iamVjdDogKCkgPT4gaXNQbGFpbk9iamVjdCxcbiAgaXNQcm9wZXJ0aWVzOiAoKSA9PiBpc1Byb3BlcnRpZXMsXG4gIGlzUmVnRXhwOiAoKSA9PiBpc1JlZ0V4cCxcbiAgaXNTdHJpbmc6ICgpID0+IGlzU3RyaW5nLFxuICBpc1N5bWJvbDogKCkgPT4gaXNTeW1ib2wsXG4gIGlzVmFsaWREYXRlOiAoKSA9PiBpc1ZhbGlkRGF0ZSxcbiAganNvbkFwcGx5OiAoKSA9PiBqc29uQXBwbHksXG4gIGpzb25EaWZmOiAoKSA9PiBqc29uRGlmZixcbiAganNvbldhbGs6ICgpID0+IGpzb25XYWxrLFxuICBrZXlQcm9wZXJ0eTogKCkgPT4ga2V5UHJvcGVydHksXG4gIGxhYmVsRGlyZWN0aW9uSGFuZGxpbmc6ICgpID0+IGxhYmVsRGlyZWN0aW9uSGFuZGxpbmcsXG4gIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzOiAoKSA9PiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyxcbiAgbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyOiAoKSA9PiBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXIsXG4gIG1hcEl0ZXJhYmxlOiAoKSA9PiBtYXBJdGVyYWJsZSxcbiAgbWFwVmFsdWVzOiAoKSA9PiBtYXBWYWx1ZXMsXG4gIG1hcmtlckZhZGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyRmFkZUluQW5pbWF0aW9uLFxuICBtYXJrZXJQYWxldHRlRmFjdG9yeTogKCkgPT4gbWFya2VyUGFsZXR0ZUZhY3RvcnksXG4gIG1hcmtlclNjYWxlSW5BbmltYXRpb246ICgpID0+IG1hcmtlclNjYWxlSW5BbmltYXRpb24sXG4gIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uLFxuICBtZXJnZUFycmF5RGVmYXVsdHM6ICgpID0+IG1lcmdlQXJyYXlEZWZhdWx0cyxcbiAgbWVyZ2VEZWZhdWx0czogKCkgPT4gbWVyZ2VEZWZhdWx0cyxcbiAgbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uOiAoKSA9PiBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb24sXG4gIG1pbk1heDogKCkgPT4gbWluTWF4LFxuICBtb2Q6ICgpID0+IG1vZCxcbiAgbW9kdWxlUmVnaXN0cnk6ICgpID0+IG1vZHVsZVJlZ2lzdHJ5LFxuICBuZWFyZXN0U3F1YXJlZDogKCkgPT4gbmVhcmVzdFNxdWFyZWQsXG4gIG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXI6ICgpID0+IG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXIsXG4gIG5vcm1hbGlzZUdyb3VwVG86ICgpID0+IG5vcm1hbGlzZUdyb3VwVG8sXG4gIG5vcm1hbGlzZVByb3BlcnR5VG86ICgpID0+IG5vcm1hbGlzZVByb3BlcnR5VG8sXG4gIG5vcm1hbGlzZWRFeHRlbnQ6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnQsXG4gIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGE6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEsXG4gIHBhaXJDYXRlZ29yeURhdGE6ICgpID0+IHBhaXJDYXRlZ29yeURhdGEsXG4gIHBhaXJDb250aW51b3VzRGF0YTogKCkgPT4gcGFpckNvbnRpbnVvdXNEYXRhLFxuICBwYXJ0aWFsQXNzaWduOiAoKSA9PiBwYXJ0aWFsQXNzaWduLFxuICBwYXRoRmFkZUluQW5pbWF0aW9uOiAoKSA9PiBwYXRoRmFkZUluQW5pbWF0aW9uLFxuICBwYXRoRmFkZU91dEFuaW1hdGlvbjogKCkgPT4gcGF0aEZhZGVPdXRBbmltYXRpb24sXG4gIHBhdGhSYW5nZVBvaW50czogKCkgPT4gcGF0aFJhbmdlUG9pbnRzLFxuICBwYXRoUmFuZ2VQb2ludHNSZXZlcnNlOiAoKSA9PiBwYXRoUmFuZ2VQb2ludHNSZXZlcnNlLFxuICBwYXRoUmFuZ2VzOiAoKSA9PiBwYXRoUmFuZ2VzLFxuICBwYXRoU3dpcGVJbkFuaW1hdGlvbjogKCkgPT4gcGF0aFN3aXBlSW5BbmltYXRpb24sXG4gIHBpY2tCeU1hdGNoaW5nQW5nbGU6ICgpID0+IHBpY2tCeU1hdGNoaW5nQW5nbGUsXG4gIHBpY2tOb2RlOiAoKSA9PiBwaWNrTm9kZSxcbiAgcGxvdFBhdGg6ICgpID0+IHBsb3RQYXRoLFxuICBwcmVkaWNhdGVXaXRoTWVzc2FnZTogKCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UsXG4gIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uLFxuICBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQ6ICgpID0+IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCxcbiAgcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnM6ICgpID0+IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zLFxuICBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zOiAoKSA9PiBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zLFxuICBwcmVwYXJlTGluZVBhdGhBbmltYXRpb246ICgpID0+IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbixcbiAgcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zOiAoKSA9PiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnMsXG4gIHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uOiAoKSA9PiBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbixcbiAgcHJlcGFyZU1hcmtlckFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZU1hcmtlckFuaW1hdGlvbixcbiAgcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9uczogKCkgPT4gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcmFuZ2U6ICgpID0+IHJhbmdlMixcbiAgcmFuZ2VkVmFsdWVQcm9wZXJ0eTogKCkgPT4gcmFuZ2VkVmFsdWVQcm9wZXJ0eSxcbiAgcmVuZGVyUGFydGlhbFBhdGg6ICgpID0+IHJlbmRlclBhcnRpYWxQYXRoLFxuICByZXNldEF4aXNHcm91cEZuOiAoKSA9PiByZXNldEF4aXNHcm91cEZuLFxuICByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuLFxuICByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbixcbiAgcmVzZXRBeGlzU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc1NlbGVjdGlvbkZuLFxuICByZXNldEJhclNlbGVjdGlvbnNGbjogKCkgPT4gcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gIHJlc2V0SWRzOiAoKSA9PiByZXNldElkcyxcbiAgcmVzZXRMYWJlbEZuOiAoKSA9PiByZXNldExhYmVsRm4sXG4gIHJlc2V0TWFya2VyRm46ICgpID0+IHJlc2V0TWFya2VyRm4sXG4gIHJlc2V0TWFya2VyUG9zaXRpb25GbjogKCkgPT4gcmVzZXRNYXJrZXJQb3NpdGlvbkZuLFxuICByZXNldE1vdGlvbjogKCkgPT4gcmVzZXRNb3Rpb24sXG4gIHJlc2V0UGllU2VsZWN0aW9uc0ZuOiAoKSA9PiByZXNldFBpZVNlbGVjdGlvbnNGbixcbiAgcm91bmQ6ICgpID0+IHJvdW5kLFxuICBzY2FsZTogKCkgPT4gc2NhbGUsXG4gIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uOiAoKSA9PiBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbixcbiAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uOiAoKSA9PiBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24sXG4gIHNldERvY3VtZW50OiAoKSA9PiBzZXREb2N1bWVudCxcbiAgc2V0RWxlbWVudEJCb3g6ICgpID0+IHNldEVsZW1lbnRCQm94LFxuICBzZXRQYXRoOiAoKSA9PiBzZXRQYXRoLFxuICBzZXRXaW5kb3c6ICgpID0+IHNldFdpbmRvdyxcbiAgc2hhbGxvd0Nsb25lOiAoKSA9PiBzaGFsbG93Q2xvbmUsXG4gIHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5OiAoKSA9PiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeSxcbiAgc3BsaXRQYWlyRGF0YTogKCkgPT4gc3BsaXRQYWlyRGF0YSxcbiAgc3RhdGljRnJvbVRvTW90aW9uOiAoKSA9PiBzdGF0aWNGcm9tVG9Nb3Rpb24sXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5LFxuICBzdW06ICgpID0+IHN1bSxcbiAgc3VtVmFsdWVzOiAoKSA9PiBzdW1WYWx1ZXMsXG4gIHRpbWVzOiAoKSA9PiB0aW1lcyxcbiAgdG9BcnJheTogKCkgPT4gdG9BcnJheSxcbiAgdG9GaXhlZDogKCkgPT4gdG9GaXhlZCxcbiAgdG9Ub29sdGlwSHRtbDogKCkgPT4gdG9Ub29sdGlwSHRtbCxcbiAgdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlOiAoKSA9PiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWUsXG4gIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5OiAoKSA9PiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWVQcm9wZXJ0eSxcbiAgdW5pcXVlOiAoKSA9PiB1bmlxdWUsXG4gIHVwZGF0ZUNsaXBQYXRoOiAoKSA9PiB1cGRhdGVDbGlwUGF0aCxcbiAgdXBkYXRlTGFiZWxOb2RlOiAoKSA9PiB1cGRhdGVMYWJlbE5vZGUsXG4gIHVwZGF0ZVJlY3Q6ICgpID0+IHVwZGF0ZVJlY3QsXG4gIHZhbGlkYXRlQ3Jvc3NMaW5lVmFsdWVzOiAoKSA9PiB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyxcbiAgdmFsdWVQcm9wZXJ0eTogKCkgPT4gdmFsdWVQcm9wZXJ0eSxcbiAgd2l0aG91dDogKCkgPT4gd2l0aG91dFxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVwcmVjYXRpb24udHNcbmZ1bmN0aW9uIGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgcmV0dXJuIChrZXksIG1lc3NhZ2UpID0+IHtcbiAgICBjb25zdCBtc2cgPSBbYFByb3BlcnR5IFske2tleX1dIGlzIGRlcHJlY2F0ZWQuYCwgbWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIExvZ2dlci53YXJuT25jZShtc2cpO1xuICB9O1xufVxuZnVuY3Rpb24gRGVwcmVjYXRlZChtZXNzYWdlLCBvcHRzKSB7XG4gIGNvbnN0IHdhcm5EZXByZWNhdGVkID0gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gIGNvbnN0IGRlZiA9IG9wdHM/LmRlZmF1bHQ7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKF8sIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgIT09IGRlZikge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gRGVwcmVjYXRlZEFuZFJlbmFtZWRUbyhuZXdQcm9wTmFtZSwgbWFwVmFsdWUpIHtcbiAgY29uc3Qgd2FybkRlcHJlY2F0ZWQgPSBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKTtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHRhcmdldFtuZXdQcm9wTmFtZV0pIHtcbiAgICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIGBVc2UgWyR7bmV3UHJvcE5hbWV9XSBpbnN0ZWFkLmApO1xuICAgICAgICBzZXRQYXRoKHRhcmdldCwgbmV3UHJvcE5hbWUsIG1hcFZhbHVlID8gbWFwVmFsdWUodmFsdWUpIDogdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJSRUFLX1RSQU5TRk9STV9DSEFJTjtcbiAgICB9LFxuICAgICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIGBVc2UgWyR7bmV3UHJvcE5hbWV9XSBpbnN0ZWFkLmApO1xuICAgICAgcmV0dXJuIGdldFBhdGgodGFyZ2V0LCBuZXdQcm9wTmFtZSk7XG4gICAgfVxuICApO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3NlYXJjaC51dGlsLnRzXG5mdW5jdGlvbiBmaW5kTWF4VmFsdWUobWluLCBtYXgsIGl0ZXJhdGVlKSB7XG4gIGlmIChtaW4gPiBtYXgpXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmQ7XG4gIHdoaWxlIChtYXggPj0gbWluKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChtYXggKyBtaW4pIC8gMik7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVyYXRlZShpbmRleCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG1heCA9IGluZGV4IC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgIG1pbiA9IGluZGV4ICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvaGllcmFyY2h5L2hpZXJhcmNoeVNlcmllcy50c1xudmFyIF9IaWVyYXJjaHlOb2RlID0gY2xhc3MgX0hpZXJhcmNoeU5vZGUge1xuICBjb25zdHJ1Y3RvcihzZXJpZXMsIGluZGV4LCBkYXR1bSwgc2l6ZSwgY29sb3JWYWx1ZSwgZmlsbCwgc3Ryb2tlLCBzdW1TaXplLCBkZXB0aCwgcGFyZW50LCBjaGlsZHJlbikge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmRhdHVtID0gZGF0dW07XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNvbG9yVmFsdWUgPSBjb2xvclZhbHVlO1xuICAgIHRoaXMuZmlsbCA9IGZpbGw7XG4gICAgdGhpcy5zdHJva2UgPSBzdHJva2U7XG4gICAgdGhpcy5zdW1TaXplID0gc3VtU2l6ZTtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMubWlkUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgfVxuICBjb250YWlucyhvdGhlcikge1xuICAgIGxldCBjdXJyZW50ID0gb3RoZXI7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50LmluZGV4ID49IHRoaXMuaW5kZXgpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgd2FsayhjYWxsYmFjazIsIG9yZGVyID0gX0hpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xuICAgIGlmIChvcmRlciA9PT0gX0hpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xuICAgICAgY2FsbGJhY2syKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC53YWxrKGNhbGxiYWNrMiwgb3JkZXIpO1xuICAgIH0pO1xuICAgIGlmIChvcmRlciA9PT0gX0hpZXJhcmNoeU5vZGUuV2Fsay5Qb3N0T3JkZXIpIHtcbiAgICAgIGNhbGxiYWNrMih0aGlzKTtcbiAgICB9XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkIHRoaXM7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB5aWVsZCogY2hpbGQ7XG4gICAgfVxuICB9XG59O1xuX0hpZXJhcmNoeU5vZGUuV2FsayA9IHtcbiAgUHJlT3JkZXI6IDAsXG4gIFBvc3RPcmRlcjogMVxufTtcbnZhciBIaWVyYXJjaHlOb2RlID0gX0hpZXJhcmNoeU5vZGU7XG52YXIgSGllcmFyY2h5U2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFszIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICBjb250ZW50R3JvdXBWaXJ0dWFsOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMucm9vdE5vZGUgPSBuZXcgSGllcmFyY2h5Tm9kZShcbiAgICAgIHRoaXMsXG4gICAgICAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICBbXVxuICAgICk7XG4gICAgdGhpcy5jb2xvckRvbWFpbiA9IFswLCAwXTtcbiAgICB0aGlzLm1heERlcHRoID0gMDtcbiAgICB0aGlzLmZvY3VzUGF0aCA9IFtdO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICByZWFkeToge1xuICAgICAgICAgIHVwZGF0ZURhdGE6IFwid2FpdGluZ1wiLFxuICAgICAgICAgIGNsZWFyOiBcImNsZWFyaW5nXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdGluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW5LZXksIHNpemVLZXksIGNvbG9yS2V5LCBmaWxscywgc3Ryb2tlcywgY29sb3JSYW5nZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgZ2V0SW5kZXggPSAoKSA9PiB7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgbGV0IG1heERlcHRoID0gMDtcbiAgICBsZXQgbWluQ29sb3IgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4Q29sb3IgPSAtSW5maW5pdHk7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IEFycmF5KCh0aGlzLmRhdGE/Lmxlbmd0aCA/PyAwKSArIDEpLmZpbGwodm9pZCAwKTtcbiAgICBjb25zdCBjcmVhdGVOb2RlID0gKGRhdHVtLCBwYXJlbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVJbmRleCA9IGdldEluZGV4KCk7XG4gICAgICBjb25zdCBkZXB0aCA9IHBhcmVudC5kZXB0aCAhPSBudWxsID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuS2V5ICE9IG51bGwgPyBkYXR1bVtjaGlsZHJlbktleV0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBpc0xlYWYgPSBjaGlsZHJlbiA9PSBudWxsIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICAgIGxldCBzaXplID0gc2l6ZUtleSAhPSBudWxsID8gZGF0dW1bc2l6ZUtleV0gOiB2b2lkIDA7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNpemUpKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLm1heChzaXplLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBpc0xlYWYgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1bVNpemUgPSBzaXplO1xuICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgZGVwdGgpO1xuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcktleSAhPSBudWxsID8gZGF0dW1bY29sb3JLZXldIDogdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb2xvcnNbbm9kZUluZGV4XSA9IGNvbG9yO1xuICAgICAgICBtaW5Db2xvciA9IE1hdGgubWluKG1pbkNvbG9yLCBjb2xvcik7XG4gICAgICAgIG1heENvbG9yID0gTWF0aC5tYXgobWF4Q29sb3IsIGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcHBlbmRDaGlsZHJlbihcbiAgICAgICAgbmV3IEhpZXJhcmNoeU5vZGUoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgZGF0dW0sXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHN1bVNpemUsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIFtdXG4gICAgICAgICksXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kQ2hpbGRyZW4gPSAobm9kZSwgZGF0YSkgPT4ge1xuICAgICAgZGF0YT8uZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjcmVhdGVOb2RlKGRhdHVtLCBub2RlKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgbm9kZS5zdW1TaXplICs9IGNoaWxkLnN1bVNpemU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBhcHBlbmRDaGlsZHJlbihcbiAgICAgIG5ldyBIaWVyYXJjaHlOb2RlKFxuICAgICAgICB0aGlzLFxuICAgICAgICAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIHRoaXMuZGF0YVxuICAgICk7XG4gICAgY29uc3QgY29sb3JEb21haW4gPSBbbWluQ29sb3IsIG1heENvbG9yXTtcbiAgICBsZXQgY29sb3JTY2FsZTtcbiAgICBpZiAoY29sb3JSYW5nZSAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShtaW5Db2xvcikgJiYgTnVtYmVyLmlzRmluaXRlKG1heENvbG9yKSkge1xuICAgICAgY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gICAgICBjb2xvclNjYWxlLmRvbWFpbiA9IGNvbG9yRG9tYWluO1xuICAgICAgY29sb3JTY2FsZS5yYW5nZSA9IGNvbG9yUmFuZ2U7XG4gICAgICBjb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByb290Tm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgY2hpbGRJbmRleCkgPT4ge1xuICAgICAgY2hpbGQud2Fsaygobm9kZSkgPT4ge1xuICAgICAgICBsZXQgZmlsbDtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNbbm9kZS5pbmRleF07XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgZmlsbCA9IGNvbG9yU2NhbGU/LmNvbnZlcnQoY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGwgPz8gKGZpbGwgPSBmaWxscz8uW2NoaWxkSW5kZXggJSBmaWxscy5sZW5ndGhdKTtcbiAgICAgICAgbm9kZS5maWxsID0gZmlsbDtcbiAgICAgICAgbm9kZS5zdHJva2UgPSBjb2xvclNjYWxlID09IG51bGwgPyBzdHJva2VzPy5bY2hpbGRJbmRleCAlIHN0cm9rZXMubGVuZ3RoXSA6IFwicmdiYSgwLCAwLCAwLCAwLjIpXCI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG4gICAgdGhpcy5tYXhEZXB0aCA9IG1heERlcHRoO1xuICAgIHRoaXMuY29sb3JEb21haW4gPSBjb2xvckRvbWFpbjtcbiAgICB0aGlzLmZvY3VzUGF0aCA9IFt7IG5vZGVEYXR1bTogdGhpcy5yb290Tm9kZSwgY2hpbGRJbmRleDogMCB9XTtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHRoaXMuZ2V0QW5pbWF0aW9uRGF0YSgpO1xuICAgIGNvbnN0IHJlc2l6ZSA9IHRoaXMuY2hlY2tSZXNpemUoc2VyaWVzUmVjdCk7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzaXplXCIsIGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgcmVzZXRBbGxBbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5hbmltYXRpb25SZXNldEZucz8uZGF0dW07XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGlmIChkYXR1bSAhPSBudWxsKSB7XG4gICAgICByZXNldE1vdGlvbihkYXRhLmRhdHVtU2VsZWN0aW9ucywgZGF0dW0pO1xuICAgIH1cbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zPy5kYXR1bTtcbiAgICBpZiAoZGF0dW0gIT0gbnVsbCkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSB7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRpb25UcmFuc2l0aW9uQ2xlYXIoKSB7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiY2xlYXJcIiwgdGhpcy5nZXRBbmltYXRpb25EYXRhKCkpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHtcbiAgICAgIGRhdHVtU2VsZWN0aW9uczogW3RoaXMuZ3JvdXBTZWxlY3Rpb25dXG4gICAgfTtcbiAgICByZXR1cm4gYW5pbWF0aW9uRGF0YTtcbiAgfVxuICBpc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKCkge1xuICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgY29sb3JLZXksIGNvbG9yTmFtZSwgY29sb3JSYW5nZSwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBsZWdlbmRUeXBlID09PSBcImdyYWRpZW50XCIgJiYgY29sb3JLZXkgIT0gbnVsbCAmJiBjb2xvclJhbmdlICE9IG51bGwgPyBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiZ3JhZGllbnRcIixcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGNvbG9yTmFtZSxcbiAgICAgICAgY29sb3JSYW5nZSxcbiAgICAgICAgY29sb3JEb21haW46IHRoaXMuY29sb3JEb21haW5cbiAgICAgIH1cbiAgICBdIDogW107XG4gIH1cbiAgZ2V0RGF0dW1JZEZyb21EYXRhKG5vZGUpIHtcbiAgICByZXR1cm4gYCR7bm9kZS5pbmRleH1gO1xuICB9XG4gIGdldERhdHVtSWQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShub2RlKTtcbiAgfVxuICBwaWNrRm9jdXMob3B0cykge1xuICAgIGlmICh0aGlzLnJvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKHRoaXMuZm9jdXNQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgTG9nZ2VyLmVycm9yKFwidGhpcy5mb2N1c1BhdGggc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXR1bUluZGV4RGVsdGE6IGNoaWxkRGVsdGEsIG90aGVySW5kZXhEZWx0YTogZGVwdGhEZWx0YSB9ID0gb3B0cztcbiAgICBjb25zdCB7IGZvY3VzUGF0aDogcGF0aCB9ID0gdGhpcztcbiAgICBjb25zdCBkZXB0aCA9IHBhdGgubGVuZ3RoIC0gMjtcbiAgICBpZiAoZGVwdGhEZWx0YSAhPT0gMCB8fCBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgdGFyZ2V0RGVwdGggPSBNYXRoLm1heCgwLCBkZXB0aCArIGRlcHRoRGVsdGEpO1xuICAgICAgaWYgKHBhdGhbdGFyZ2V0RGVwdGggKyAxXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhdGgubGVuZ3RoID0gdGFyZ2V0RGVwdGggKyAyO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKHBhdGhbdGFyZ2V0RGVwdGggKyAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVlcGVzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgd2hpbGUgKGRlZXBlc3Qubm9kZURhdHVtLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgKGRlZXBlc3Qubm9kZURhdHVtLmRlcHRoID8/IC0xKSA8IHRhcmdldERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV4dERlZXBlc3QgPSB7IG5vZGVEYXR1bTogZGVlcGVzdC5ub2RlRGF0dW0uY2hpbGRyZW5bMF0sIGNoaWxkSW5kZXg6IDAgfTtcbiAgICAgICAgICBwYXRoLnB1c2gobmV4dERlZXBlc3QpO1xuICAgICAgICAgIGRlZXBlc3QgPSBuZXh0RGVlcGVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKGRlZXBlc3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGREZWx0YSAhPT0gMCkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2hpbGQgPSBwYXRoW2RlcHRoICsgMV0uY2hpbGRJbmRleCArIGNoaWxkRGVsdGE7XG4gICAgICBjb25zdCBjdXJyZW50UGFyZW50ID0gcGF0aFtkZXB0aF0ubm9kZURhdHVtO1xuICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGN1cnJlbnRQYXJlbnQ/LmNoaWxkcmVuPy5sZW5ndGg7XG4gICAgICBpZiAoY2hpbGRDb3VudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2xhbXAoMCwgdGFyZ2V0Q2hpbGQsIGNoaWxkQ291bnQgLSAxKTtcbiAgICAgICAgY29uc3QgbmV3Rm9jdXMgPSB7IG5vZGVEYXR1bTogY3VycmVudFBhcmVudC5jaGlsZHJlbltuZXdDaGlsZF0sIGNoaWxkSW5kZXg6IG5ld0NoaWxkIH07XG4gICAgICAgIHBhdGhbZGVwdGggKyAxXSA9IG5ld0ZvY3VzO1xuICAgICAgICBwYXRoLmxlbmd0aCA9IGRlcHRoICsgMjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUZvY3VzT3V0cHV0cyhuZXdGb2N1cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMocGF0aFtwYXRoLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIShkYXR1bSBpbnN0YW5jZW9mIEhpZXJhcmNoeU5vZGUpKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoYGRhdHVtIGlzIG5vdCBIaWVyYXJjaHlOb2RlOiAke2RhdHVtfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYUFubm91bmNlSGllcmFyY2h5RGF0dW1cIiwge1xuICAgICAgbGV2ZWw6IChkYXR1bS5kZXB0aCA/PyAtMSkgKyAxLFxuICAgICAgY291bnQ6IGRhdHVtLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzT3V0cHV0cyh7IG5vZGVEYXR1bSwgY2hpbGRJbmRleCB9KSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5jb21wdXRlRm9jdXNCb3VuZHMobm9kZURhdHVtKTtcbiAgICBpZiAoYm91bmRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXR1bTogbm9kZURhdHVtLFxuICAgICAgICBkYXR1bUluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBvdGhlckluZGV4OiBub2RlRGF0dW0uZGVwdGgsXG4gICAgICAgIGJvdW5kcyxcbiAgICAgICAgc2hvd0ZvY3VzQm94OiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvaGllcmFyY2h5L2hpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNoaWxkcmVuS2V5ID0gXCJjaGlsZHJlblwiO1xuICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xuICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNoaWxkcmVuS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvdG9wb2xvZ3kvbG9uTGF0QmJveC50c1xudmFyIExvbkxhdEJCb3ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvbjAsIGxhdDAsIGxvbjEsIGxhdDEpIHtcbiAgICB0aGlzLmxvbjAgPSBsb24wO1xuICAgIHRoaXMubGF0MCA9IGxhdDA7XG4gICAgdGhpcy5sb24xID0gbG9uMTtcbiAgICB0aGlzLmxhdDEgPSBsYXQxO1xuICB9XG4gIG1lcmdlKG90aGVyKSB7XG4gICAgdGhpcy5sb24wID0gTWF0aC5taW4odGhpcy5sb24wLCBvdGhlci5sb24wKTtcbiAgICB0aGlzLmxhdDAgPSBNYXRoLm1pbih0aGlzLmxhdDAsIG90aGVyLmxhdDApO1xuICAgIHRoaXMubG9uMSA9IE1hdGgubWF4KHRoaXMubG9uMSwgb3RoZXIubG9uMSk7XG4gICAgdGhpcy5sYXQxID0gTWF0aC5tYXgodGhpcy5sYXQxLCBvdGhlci5sYXQxKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZW1wVXRpbHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUlkc0dlbmVyYXRvcigpIHtcbiAgY29uc3QgaWRzQ291bnRlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiAobmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBpZHNDb3VudGVyLmdldChuYW1lKTtcbiAgICBpZiAoY291bnRlcikge1xuICAgICAgaWRzQ291bnRlci5zZXQobmFtZSwgY291bnRlciArIDEpO1xuICAgICAgcmV0dXJuIGAke25hbWV9JHtjb3VudGVyfWA7XG4gICAgfVxuICAgIGlkc0NvdW50ZXIuc2V0KG5hbWUsIDEpO1xuICAgIHJldHVybiBuYW1lO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaWNrcy50c1xudmFyIF9BeGlzVGlja3MgPSBjbGFzcyBfQXhpc1RpY2tzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuYXhpc0dyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpc1RpY2tzYCwgekluZGV4OiAyIC8qIEFYSVNfWklOREVYICovIH0pO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuYXhpc0dyb3VwLCBUZXh0LCBmYWxzZSk7XG4gICAgdGhpcy5pbnRlcnZhbCA9IG5ldyBBeGlzSW50ZXJ2YWwoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEF4aXNMYWJlbCgpO1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG4gIH1cbiAgYXR0YWNoQXhpcyhheGlzTm9kZSkge1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5zY2FsZS5pbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWwuc3RlcDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IHRpY2tEYXRhID0gdGhpcy5nZW5lcmF0ZVRpY2tzKCk7XG4gICAgY29uc3QgeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gdGhpcztcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIHRpY2tEYXRhLnRpY2tzLm1hcCgoZCkgPT4gdGhpcy5jcmVhdGVMYWJlbERhdHVtKGQpKSxcbiAgICAgIChncm91cCkgPT4gZ3JvdXAuYXBwZW5kQ2hpbGQobmV3IFRleHQoKSksXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZFxuICAgICk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtKTtcbiAgICAgIGlmIChkYXR1bS52aXNpYmxlKSB7XG4gICAgICAgIGJveGVzLnB1c2gobm9kZS5nZXRCQm94KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXhpc0dyb3VwLnNldFByb3BlcnRpZXMoeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9KTtcbiAgICByZXR1cm4gQkJveC5tZXJnZShib3hlcyk7XG4gIH1cbiAgZ2V0TGFiZWxQYXJhbXMoZGF0dW0pIHtcbiAgICBjb25zdCB7IHBhZGRpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0cmFuc2xhdGUgfSA9IGRhdHVtO1xuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRyYW5zbGF0ZSxcbiAgICAgICAgICB5OiBwYWRkaW5nLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwidG9wXCJcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBwYWRkaW5nLFxuICAgICAgICAgIHk6IHRyYW5zbGF0ZSxcbiAgICAgICAgICB0ZXh0QWxpZ246IFwic3RhcnRcIixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCJcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZSh4LCB0b2xlcmFuY2UgPSAxZS0zKSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgodGhpcy5zY2FsZS5yYW5nZSk7XG4gICAgcmV0dXJuIHggPj0gbWluIC0gdG9sZXJhbmNlICYmIHggPD0gbWF4ICsgdG9sZXJhbmNlO1xuICB9XG4gIGNyZWF0ZUxhYmVsRGF0dW0oZGF0dW0pIHtcbiAgICBjb25zdCB7IHgsIHksIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH0gPSB0aGlzLmdldExhYmVsUGFyYW1zKGRhdHVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZTogQm9vbGVhbihkYXR1bS50aWNrTGFiZWwpLFxuICAgICAgdGlja0lkOiBkYXR1bS50aWNrSWQsXG4gICAgICBmaWxsOiB0aGlzLmxhYmVsLmNvbG9yLFxuICAgICAgZm9udEZhbWlseTogdGhpcy5sYWJlbC5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoaXMubGFiZWwuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IHRoaXMubGFiZWwuZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodDogdGhpcy5sYWJlbC5mb250V2VpZ2h0LFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICByb3RhdGlvbkNlbnRlclg6IDAsXG4gICAgICB0ZXh0OiBkYXR1bS50aWNrTGFiZWwsXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVUaWNrcygpIHtcbiAgICBjb25zdCB7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSA9IHRoaXMuaW50ZXJ2YWw7XG4gICAgY29uc3QgZXh0ZW50V2l0aEJsZWVkID0gcm91bmQoZmluZFJhbmdlRXh0ZW50KHRoaXMuc2NhbGUucmFuZ2UpLCAyKTtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCwgbWluVGlja0NvdW50LCB0aWNrQ291bnQgfSA9IGVzdGltYXRlVGlja0NvdW50KFxuICAgICAgZXh0ZW50V2l0aEJsZWVkLFxuICAgICAgbWluU3BhY2luZyxcbiAgICAgIG1heFNwYWNpbmcsXG4gICAgICBfQXhpc1RpY2tzLkRlZmF1bHRUaWNrQ291bnQsXG4gICAgICBfQXhpc1RpY2tzLkRlZmF1bHRNaW5TcGFjaW5nXG4gICAgKTtcbiAgICBpZiAodGlja0NvdW50KSB7XG4gICAgICB0aGlzLnNjYWxlLnRpY2tDb3VudCA9IHRpY2tDb3VudDtcbiAgICAgIHRoaXMuc2NhbGUubWluVGlja0NvdW50ID0gbWluVGlja0NvdW50O1xuICAgICAgdGhpcy5zY2FsZS5tYXhUaWNrQ291bnQgPSBtYXhUaWNrQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tEYXRhID0gdGhpcy5nZXRUaWNrc0RhdGEoKTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIiB8fCB0aGlzLnBvc2l0aW9uID09PSBcInRvcFwiKSB7XG4gICAgICBjb25zdCBtZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250OiB0aGlzLmxhYmVsIH0pO1xuICAgICAgbGV0IGxhc3RUaWNrUG9zaXRpb24gPSAtSW5maW5pdHk7XG4gICAgICB0aWNrRGF0YS50aWNrcyA9IHRpY2tEYXRhLnRpY2tzLmZpbHRlcigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAobGFzdFRpY2tQb3NpdGlvbiA8IGRhdGEudHJhbnNsYXRlKSB7XG4gICAgICAgICAgbGFzdFRpY2tQb3NpdGlvbiA9IGRhdGEudHJhbnNsYXRlICsgbWVhc3VyZXIudGV4dFdpZHRoKGRhdGEudGlja0xhYmVsLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrRGF0YTtcbiAgfVxuICBnZXRUaWNrc0RhdGEoKSB7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBjb25zdCByYXdUaWNrcyA9IHRoaXMuc2NhbGUudGlja3MoKTtcbiAgICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IHJhd1RpY2tzLnJlZHVjZSgobWF4LCB0aWNrKSA9PiBNYXRoLm1heChtYXgsIGNvdW50RnJhY3Rpb25EaWdpdHModGljaykpLCAwKTtcbiAgICBjb25zdCBpZEdlbmVyYXRvciA9IGNyZWF0ZUlkc0dlbmVyYXRvcigpO1xuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyID0gdGhpcy5sYWJlbC5mb3JtYXQgPyB0aGlzLnNjYWxlLnRpY2tGb3JtYXQoeyB0aWNrczogcmF3VGlja3MsIHNwZWNpZmllcjogdGhpcy5sYWJlbC5mb3JtYXQgfSkgOiAoeCkgPT4gaXNOdW1iZXIoeCkgPyB4LnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIDogU3RyaW5nKHgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByYXdUaWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHRpY2sgPSByYXdUaWNrc1tpbmRleF07XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSB0aGlzLnNjYWxlLmNvbnZlcnQodGljayk7XG4gICAgICBpZiAoIXRoaXMuaW5SYW5nZSh0cmFuc2xhdGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRpY2tMYWJlbCA9IHRoaXMubGFiZWwuZm9ybWF0dGVyPy4oeyB2YWx1ZTogdGljaywgaW5kZXgsIGZyYWN0aW9uRGlnaXRzIH0pID8/IGxhYmVsRm9ybWF0dGVyKHRpY2spO1xuICAgICAgY29uc3QgdGlja0lkID0gaWRHZW5lcmF0b3IodGlja0xhYmVsKTtcbiAgICAgIHRpY2tzLnB1c2goeyB0aWNrLCB0aWNrSWQsIHRpY2tMYWJlbCwgdHJhbnNsYXRlIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyByYXdUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHRpY2tzIH07XG4gIH1cbn07XG5fQXhpc1RpY2tzLkRlZmF1bHRUaWNrQ291bnQgPSA1O1xuX0F4aXNUaWNrcy5EZWZhdWx0TWluU3BhY2luZyA9IDUwO1xudmFyIEF4aXNUaWNrcyA9IF9BeGlzVGlja3M7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xlZ2VuZERhdHVtLnRzXG52YXIgX19GT1JDRV9NT0RVTEVfREVURUNUSU9OID0gMDtcbmV4cG9ydCB7XG4gIEFHX0NIQVJUU19MT0NBTEVfRU5fVVMsXG4gIEFnQ2hhcnRzLFxuICBBZ0Vycm9yQmFyU3VwcG9ydGVkU2VyaWVzVHlwZXMsXG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZSxcbiAgSUNPTlNfTEVHQUNZLFxuICBNYXJrZXIsXG4gIFZFUlNJT04sXG4gIG1vZHVsZV9zdXBwb3J0X2V4cG9ydHMgYXMgX01vZHVsZVN1cHBvcnQsXG4gIHNwYXJrbGluZXNfc2NhbGVfZXhwb3J0cyBhcyBfU2NhbGUsXG4gIGludGVncmF0ZWRfY2hhcnRzX3NjZW5lX2V4cG9ydHMgYXMgX1NjZW5lLFxuICBpbnRlZ3JhdGVkX2NoYXJ0c190aGVtZV9leHBvcnRzIGFzIF9UaGVtZSxcbiAgc3BhcmtsaW5lc191dGlsX2V4cG9ydHMgYXMgX1V0aWwsXG4gIHRpbWVfZXhwb3J0cyBhcyB0aW1lXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ag-charts-react/dist/package/index.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/ag-charts-react/dist/package/index.esm.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgCharts: function() { return /* binding */ AgCharts; },\n/* harmony export */   AgFinancialCharts: function() { return /* binding */ AgFinancialCharts; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var ag_charts_community__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-community */ \"(app-pages-browser)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\");\n// packages/ag-charts-react/src/index.ts\n\n\nfunction getOptions(options, containerRef) {\n  return {\n    ...options,\n    container: containerRef.current\n  };\n}\nfunction ChartWithConstructor(ctor, displayName) {\n  const Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function AgChartsReact(props, ref) {\n    const { options, style, className } = props;\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      const chart = ctor(getOptions(options, containerRef));\n      chartRef.current = chart;\n      return () => {\n        chart.destroy();\n      };\n    }, []);\n    const unsafeIsInitialMount = chartRef.current === void 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (!unsafeIsInitialMount) {\n        void chartRef.current?.update(getOptions(options, containerRef));\n      }\n    }, [options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => chartRef.current, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: containerRef,\n        style,\n        className\n      });\n    }, [style, className]);\n  });\n  Component.displayName = displayName;\n  return Component;\n}\nvar AgCharts = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.create(options),\n  \"AgCharts\"\n);\nvar AgFinancialCharts = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.createFinancialChart(options),\n  \"AgFinancialCharts\"\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtcmVhY3QvZGlzdC9wYWNrYWdlL2luZGV4LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBU2U7QUFHYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBVTtBQUM5QixZQUFZLDRCQUE0QjtBQUN4Qyx5QkFBeUIsNkNBQU07QUFDL0IscUJBQXFCLDZDQUFNO0FBQzNCLElBQUksc0RBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSwwREFBbUI7QUFDdkIsV0FBVyw4Q0FBTztBQUNsQixhQUFhLG9EQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFXO0FBQzFCO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLXJlYWN0L2Rpc3QvcGFja2FnZS9pbmRleC5lc20ubWpzPzlkNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvYWctY2hhcnRzLXJlYWN0L3NyYy9pbmRleC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCxcbiAgZm9yd2FyZFJlZixcbiAgdXNlRWZmZWN0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEFnQ2hhcnRzIGFzIEFnQ2hhcnRzQVBJXG59IGZyb20gXCJhZy1jaGFydHMtY29tbXVuaXR5XCI7XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMsIGNvbnRhaW5lclJlZikge1xuICByZXR1cm4ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgY29udGFpbmVyOiBjb250YWluZXJSZWYuY3VycmVudFxuICB9O1xufVxuZnVuY3Rpb24gQ2hhcnRXaXRoQ29uc3RydWN0b3IoY3RvciwgZGlzcGxheU5hbWUpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gZm9yd2FyZFJlZihmdW5jdGlvbiBBZ0NoYXJ0c1JlYWN0KHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHN0eWxlLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZigpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBjaGFydCA9IGN0b3IoZ2V0T3B0aW9ucyhvcHRpb25zLCBjb250YWluZXJSZWYpKTtcbiAgICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNoYXJ0LmRlc3Ryb3koKTtcbiAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHVuc2FmZUlzSW5pdGlhbE1vdW50ID0gY2hhcnRSZWYuY3VycmVudCA9PT0gdm9pZCAwO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIXVuc2FmZUlzSW5pdGlhbE1vdW50KSB7XG4gICAgICAgIHZvaWQgY2hhcnRSZWYuY3VycmVudD8udXBkYXRlKGdldE9wdGlvbnMob3B0aW9ucywgY29udGFpbmVyUmVmKSk7XG4gICAgICB9XG4gICAgfSwgW29wdGlvbnNdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gY2hhcnRSZWYuY3VycmVudCwgW10pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgIH0pO1xuICAgIH0sIFtzdHlsZSwgY2xhc3NOYW1lXSk7XG4gIH0pO1xuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgcmV0dXJuIENvbXBvbmVudDtcbn1cbnZhciBBZ0NoYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBDaGFydFdpdGhDb25zdHJ1Y3RvcihcbiAgKG9wdGlvbnMpID0+IEFnQ2hhcnRzQVBJLmNyZWF0ZShvcHRpb25zKSxcbiAgXCJBZ0NoYXJ0c1wiXG4pO1xudmFyIEFnRmluYW5jaWFsQ2hhcnRzID0gLyogQF9fUFVSRV9fICovIENoYXJ0V2l0aENvbnN0cnVjdG9yKFxuICAob3B0aW9ucykgPT4gQWdDaGFydHNBUEkuY3JlYXRlRmluYW5jaWFsQ2hhcnQob3B0aW9ucyksXG4gIFwiQWdGaW5hbmNpYWxDaGFydHNcIlxuKTtcbmV4cG9ydCB7XG4gIEFnQ2hhcnRzLFxuICBBZ0ZpbmFuY2lhbENoYXJ0c1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ag-charts-react/dist/package/index.esm.mjs\n"));

/***/ })

});