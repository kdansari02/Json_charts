"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ag-charts-community";
exports.ids = ["vendor-chunks/ag-charts-community"];
exports.modules = {

/***/ "(ssr)/./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: () => (/* binding */ AG_CHARTS_LOCALE_EN_US),\n/* harmony export */   AgCharts: () => (/* binding */ AgCharts),\n/* harmony export */   AgErrorBarSupportedSeriesTypes: () => (/* binding */ AgErrorBarSupportedSeriesTypes),\n/* harmony export */   AgTooltipPositionType: () => (/* binding */ AgTooltipPositionType),\n/* harmony export */   ICONS_LEGACY: () => (/* binding */ ICONS_LEGACY),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   _ModuleSupport: () => (/* binding */ module_support_exports),\n/* harmony export */   _Scale: () => (/* binding */ sparklines_scale_exports),\n/* harmony export */   _Scene: () => (/* binding */ integrated_charts_scene_exports),\n/* harmony export */   _Theme: () => (/* binding */ integrated_charts_theme_exports),\n/* harmony export */   _Util: () => (/* binding */ sparklines_util_exports),\n/* harmony export */   time: () => (/* binding */ time_exports)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when the focused item becomes visible\n  ariaAnnounceVisible: \"visible\",\n  // Screen reader announcement when the focused item becomes hidden\n  ariaAnnounceHidden: \"hidden\",\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for the color picker dialog\n  ariaLabelColorPicker: \"Color picker\",\n  // Screen reader text for the financial charts toolbar\n  ariaLabelFinancialCharts: \"Financial Charts\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number], \",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Text for the series type toolbar's chart type button\n  toolbarSeriesTypeDropdown: \"Chart Type\",\n  // Text for the series type toolbar's OHLC chart type button\n  toolbarSeriesTypeOHLC: \"OHLC\",\n  // Text for the series type toolbar's HLC chart type button\n  toolbarSeriesTypeHLC: \"HLC\",\n  // Text for the series type toolbar's high low chart type button\n  toolbarSeriesTypeHighLow: \"High Low\",\n  // Text for the series type toolbar's candles chart type button\n  toolbarSeriesTypeCandles: \"Candles\",\n  // Text for the series type toolbar's hollow candles chart type button\n  toolbarSeriesTypeHollowCandles: \"Hollow Candles\",\n  // Text for the series type toolbar's line chart type button\n  toolbarSeriesTypeLine: \"Line\",\n  // Text for the series type toolbar's line with markers chart type button\n  toolbarSeriesTypeLineWithMarkers: \"Line with Markers\",\n  // Text for the series type toolbar's line with step line chart type button\n  toolbarSeriesTypeStepLine: \"Step Line\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend Line\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal Line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical Line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel Channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint Channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear All\",\n  /**\n   * Text for the annotation toolbar's color picker annotation button\n   * @deprecated v10.1.0 use `toolbarAnnotationsLineColor` instead.\n   */\n  toolbarAnnotationsColor: \"Color\",\n  // Text for the annotation toolbar's fill color picker annotation button\n  toolbarAnnotationsFillColor: \"Fill Color\",\n  // Text for the annotation toolbar's line color picker annotation button\n  toolbarAnnotationsLineColor: \"Line Color\",\n  // Text for the annotation toolbar's text color picker annotation button\n  toolbarAnnotationsTextColor: \"Text Color\",\n  // Text for the annotation toolbar's text size picker annotation button\n  toolbarAnnotationsTextSize: \"Text Size\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete\",\n  // Text for the annotation toolbar's line annotations menu button\n  toolbarAnnotationsLineAnnotations: \"Trend Lines\",\n  // Text for the annotation toolbar's text annotations menu button\n  toolbarAnnotationsTextAnnotations: \"Text Annotations\",\n  // Text for the annotation toolbar's callout button\n  toolbarAnnotationsCallout: \"Callout\",\n  // Text for the annotation toolbar's comment button\n  toolbarAnnotationsComment: \"Comment\",\n  // Text for the annotation toolbar's note button\n  toolbarAnnotationsNote: \"Note\",\n  // Text for the annotation toolbar's text button\n  toolbarAnnotationsText: \"Text\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1M\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3M\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6M\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1Y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\"\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = {};\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/toolbarOptions.ts\nvar ICONS_LEGACY = [\n  \"delete-legacy\",\n  \"disjoint-channel\",\n  \"disjoint-channel-legacy\",\n  \"horizontal-line-legacy\",\n  \"line-color-legacy\",\n  \"lock\",\n  \"lock-legacy\",\n  \"pan-end-legacy\",\n  \"pan-left-legacy\",\n  \"pan-right-legacy\",\n  \"pan-start-legacy\",\n  \"parallel-channel\",\n  \"parallel-channel-legacy\",\n  \"reset-legacy\",\n  \"trend-line\",\n  \"trend-line-legacy\",\n  \"unlock\",\n  \"unlock-legacy\",\n  \"vertical-line\",\n  \"vertical-line-legacy\",\n  \"zoom-in-legacy\",\n  \"zoom-in-alt\",\n  \"zoom-in-alt-legacy\",\n  \"zoom-out-legacy\",\n  \"zoom-out-alt\",\n  \"zoom-out-alt-legacy\"\n];\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = {};\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/function.ts\nvar doOnceState = /* @__PURE__ */ new Map();\nfunction doOnce(func, key) {\n  if (doOnceState.has(key))\n    return;\n  doOnceState.set(key, true);\n  func();\n}\ndoOnce.clear = () => doOnceState.clear();\nfunction identity(x) {\n  return x;\n}\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction throttle(callback2, waitMs = 0, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback2(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback2(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\nfunction joinFunctions(...fns) {\n  return () => {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/logger.ts\nvar Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === \"object\") {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start, stop, extend) {\n    const rangeCallback = this._rangeCallback?.(start, stop);\n    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range3 = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === \"number\" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start, stop) => {\n        const s = snapTo === \"start\" ? start : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date) => {\n      const e = this._encode(date);\n      return Math.floor((e - offset4) / step);\n    };\n    const decode13 = (encoded) => {\n      return this._decode(encoded * step + offset4);\n    };\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date) {\n  return date.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\nvar millisecond_default = millisecond;\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date) {\n  return Math.floor((date.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\nvar second_default = second;\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date) {\n  return Math.floor((date.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\nvar minute_default = minute;\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date) {\n  return Math.floor((date.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\nvar hour_default = hour;\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\nvar day_default = day;\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date) {\n    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\nvar week_default = sunday;\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\nvar month_default = month;\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date) {\n  return date.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\nvar year_default = year;\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date) {\n  return date.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction uuid() {\n  const url = URL.createObjectURL(new Blob());\n  return url.split(\"/\").at(-1);\n}\n\n// packages/ag-charts-community/src/util/iterator.ts\nfunction toIterable(value) {\n  if (typeof value !== \"object\" || value == null || !(Symbol.iterator in value)) {\n    return argsIterable(value);\n  }\n  return value;\n}\nfunction* arraysIterable(...arrays) {\n  for (const array2 of arrays) {\n    for (const e of array2) {\n      yield e;\n    }\n  }\n}\nfunction* argsIterable(...args) {\n  for (const arg of args) {\n    yield arg;\n  }\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = \"$interpolate\";\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx, y: ty } = container.transformPoint(x, y);\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared3 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared3 === 0) {\n      return { nearest, distanceSquared: distanceSquared3 };\n    } else if (distanceSquared3 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared3;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array2) {\n  const [min, max] = findMinMax(array2);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array2) {\n  if (array2.length === 0)\n    return [];\n  const result = [Infinity, -Infinity];\n  for (const val of array2) {\n    if (val < result[0])\n      result[0] = val;\n    if (val > result[1])\n      result[1] = val;\n  }\n  return result;\n}\nfunction findRangeExtent(array2) {\n  const [min, max] = findMinMax(array2);\n  return max - min;\n}\nfunction isEqual(a, b, epsilon2 = 1e-10) {\n  return Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits);\n  }\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value) {\n  if (Math.floor(value) === value)\n    return 0;\n  return String(value).split(\".\")[1]?.length ?? 0;\n}\nfunction formatNormalizedPercentage(ratio2, locale) {\n  locale = locale ?? navigator.language;\n  return new Intl.NumberFormat(locale, { style: \"percent\" }).format(ratio2);\n}\nfunction formatPercentage(percent, locale) {\n  return formatNormalizedPercentage(percent / 100, locale);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  static fromDOMRect({ x, y, width, height }) {\n    return new _BBox(x, y, width, height);\n  }\n  toDOMRect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      top: this.y,\n      left: this.x,\n      right: this.x + this.width,\n      bottom: this.y + this.height,\n      toJSON() {\n        return {};\n      }\n    };\n  }\n  clone() {\n    const { x, y, width, height } = this;\n    return new _BBox(x, y, width, height);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  intersection(other) {\n    if (!this.collidesBBox(other))\n      return;\n    const newX1 = clamp(other.x, this.x, other.x + other.width);\n    const newY1 = clamp(other.y, this.y, other.y + other.height);\n    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);\n    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);\n    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  clip(clipRect) {\n    if (clipRect === void 0)\n      return this;\n    const x1 = Math.max(this.x, clipRect.x);\n    const y1 = Math.max(this.y, clipRect.y);\n    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);\n    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);\n    this.x = x1;\n    this.y = y1;\n    this.width = Math.max(0, x2 - x1);\n    this.height = Math.max(0, y2 - y1);\n    return this;\n  }\n  shrink(amount, position) {\n    const apply2 = (pos, amt) => {\n      switch (pos) {\n        case \"top\":\n          this.y += amt;\n        case \"bottom\":\n          this.height -= amt;\n          break;\n        case \"left\":\n          this.x += amt;\n        case \"right\":\n          this.width -= amt;\n          break;\n        case \"vertical\":\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case \"horizontal\":\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case void 0:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        default:\n      }\n    };\n    if (typeof amount === \"number\") {\n      apply2(position, amount);\n    } else if (typeof amount === \"object\") {\n      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = { ...amount };\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  combine(other) {\n    const { x, y, width, height } = this;\n    this.x = Math.min(x, other.x);\n    this.y = Math.min(y, other.y);\n    this.width = Math.max(x + width, other.x + other.width) - this.x;\n    this.height = Math.max(y + height, other.y + other.height) - this.y;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));\n_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nvar RedrawType = /* @__PURE__ */ ((RedrawType2) => {\n  RedrawType2[RedrawType2[\"NONE\"] = 0] = \"NONE\";\n  RedrawType2[RedrawType2[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  RedrawType2[RedrawType2[\"MINOR\"] = 2] = \"MINOR\";\n  RedrawType2[RedrawType2[\"MAJOR\"] = 3] = \"MAJOR\";\n  return RedrawType2;\n})(RedrawType || {});\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = 1 /* TRIVIAL */,\n    type = \"normal\",\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts ?? {};\n  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey, requiredOpts);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey, requiredOpts);\n      break;\n    case \"font\":\n      setter = buildFontSetter(privateKey, requiredOpts);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {\n        this.markDirty(value, value._dirty);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty(this, redraw);\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform(redraw);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildFontSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyFont) {\n        this._dirtyFont = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nvar ChangeDetectable = class {\n  constructor() {\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar _Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements3 = [1, 0, 0, 1, 0, 0]) {\n    this.elements = elements3;\n  }\n  setElements(elements3) {\n    const e = this.elements;\n    e[0] = elements3[0];\n    e[1] = elements3[1];\n    e[2] = elements3[2];\n    e[3] = elements3[3];\n    e[4] = elements3[4];\n    e[5] = elements3[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C ?? A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements3 = new Array(6);\n    this.AxB(this.elements, other.elements, elements3);\n    return new _Matrix(elements3);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const el = this.elements;\n    const xx = el[0];\n    const xy = el[1];\n    const yx = el[2];\n    const yy = el[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    target ?? (target = new BBox(0, 0, 0, 0));\n    target.x = cx * xx + cy * yx + el[4] - w;\n    target.y = cx * xy + cy * yy + el[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return _Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX ?? 0;\n      scy = opts?.scalingCenterY ?? 0;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX ?? 0;\n      rcy = opts?.rotationCenterY ?? 0;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n};\n_Matrix.instance = new _Matrix();\nvar Matrix = _Matrix;\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node extends ChangeDetectable {\n  constructor({ isVirtual, tag, zIndex, name } = {}) {\n    super();\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = createId(this);\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this._virtualChildren = [];\n    this._children = [];\n    // Used to check for duplicate nodes.\n    this.childSet = {};\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    this.matrix = new Matrix();\n    this.dirtyTransform = false;\n    this.scalingX = 1;\n    this.scalingY = 1;\n    this.scalingCenterX = null;\n    this.scalingCenterY = null;\n    this.rotationCenterX = null;\n    this.rotationCenterY = null;\n    this.rotation = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this._childNodeCounts = {\n      groups: 0,\n      nonGroups: 0\n    };\n    this.visible = true;\n    this.dirtyZIndex = false;\n    this.zIndex = 0;\n    /** Discriminators for render order within a zIndex. */\n    this.zIndexSubOrder = void 0;\n    this.pointerEvents = 0 /* All */;\n    this.name = name;\n    this.isVirtual = isVirtual ?? false;\n    this.tag = tag ?? NaN;\n    this.zIndex = zIndex ?? 0;\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this._parent?.datum;\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n    }\n    this._datum = datum;\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this._children) {\n      child._setLayerManager(value);\n    }\n    for (const child of this._virtualChildren) {\n      child._setLayerManager(value);\n    }\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  *ancestors() {\n    let node = this;\n    while (node = node.parent) {\n      yield node;\n    }\n  }\n  *traverseUp() {\n    yield this;\n    yield* this.ancestors();\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return this._virtualChildren.length ? this._children.concat(this._virtualChildren.flatMap((next) => next.children)) : this._children;\n  }\n  get virtualChildren() {\n    return this._virtualChildren;\n  }\n  hasVirtualChildren() {\n    return this._virtualChildren.length > 0;\n  }\n  // new Set<Node>()\n  setProperties(styles, pickKeys) {\n    if (pickKeys) {\n      for (const key of pickKeys) {\n        this[key] = styles[key];\n      }\n    } else {\n      Object.assign(this, styles);\n    }\n    return this;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    nodes = toIterable(nodes);\n    for (const node of nodes) {\n      if (node.parent) {\n        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n      }\n      if (node.layerManager) {\n        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\n      }\n      if (this.childSet[node.id]) {\n        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\n      }\n      if (node.isVirtual) {\n        this._virtualChildren.push(node);\n      } else {\n        this._children.push(node);\n      }\n      this.childSet[node.id] = true;\n      node._parent = this;\n      node._setLayerManager(this.layerManager);\n    }\n    this.dirtyZIndex = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    const error = () => {\n      throw new Error(`The node to be removed is not a child of this node.`);\n    };\n    if (node.parent !== this) {\n      error();\n    }\n    if (node.isVirtual) {\n      const i = this._virtualChildren.indexOf(node);\n      if (i < 0)\n        error();\n      this._virtualChildren.splice(i, 1);\n    } else {\n      const i = this._children.indexOf(node);\n      if (i < 0)\n        error();\n      this._children.splice(i, 1);\n    }\n    delete this.childSet[node.id];\n    node._parent = void 0;\n    node._setLayerManager();\n    this.dirtyZIndex = true;\n    this.markDirty(node, 3 /* MAJOR */);\n    return node;\n  }\n  clear() {\n    for (const child of arraysIterable(this._virtualChildren, this._children)) {\n      child._parent = void 0;\n      child._setLayerManager();\n    }\n    this._virtualChildren.length = 0;\n    this._children.length = 0;\n    this.childSet = {};\n  }\n  calculateCumulativeMatrix() {\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    return matrix;\n  }\n  transformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformPoint(x, y);\n  }\n  inverseTransformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformPoint(x, y);\n  }\n  transformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformBBox(bbox);\n  }\n  inverseTransformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformBBox(bbox);\n  }\n  markDirtyTransform() {\n    this.dirtyTransform = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  destroy() {\n    this.parent?.removeChild(this);\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const { children } = this;\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint = child.computeTransformedBBox()?.containsPoint(x, y);\n        const hit = containsPoint ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  getBBox(forceRecalculation = false) {\n    if (this.cachedBBox == null || forceRecalculation) {\n      this.cachedBBox = Object.freeze(this.computeBBox());\n    }\n    return this.cachedBBox;\n  }\n  computeBBox() {\n    return;\n  }\n  computeTransformedBBox() {\n    const bbox = this.getBBox()?.clone();\n    if (!bbox) {\n      return;\n    }\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    matrix.transformBBox(bbox, bbox);\n    return bbox;\n  }\n  computeTransformMatrix() {\n    if (!this.dirtyTransform) {\n      return;\n    }\n    const {\n      matrix,\n      scalingX,\n      scalingY,\n      rotation,\n      translationX,\n      translationY,\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    } = this;\n    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    });\n    this.dirtyTransform = false;\n  }\n  transformRenderContext(renderCtx, layerCtx) {\n    this.computeTransformMatrix();\n    this.matrix.toContext(layerCtx ?? renderCtx.ctx);\n    return this.matrix;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender() {\n    this._childNodeCounts.groups = 0;\n    this._childNodeCounts.nonGroups = 1;\n    for (const child of this.children) {\n      const childCounts = child.preRender();\n      this._childNodeCounts.groups += childCounts.groups;\n      this._childNodeCounts.nonGroups += childCounts.nonGroups;\n    }\n    return this._childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = 0 /* NONE */;\n    this.cachedBBox = this.computeBBox();\n    if (stats) {\n      stats.nodesRendered++;\n    }\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */, parentType = type) {\n    this.cachedBBox = void 0;\n    if (this._dirty > type || this._dirty === type && type === parentType) {\n      return;\n    }\n    this._dirty = type;\n    if (this.parent) {\n      this.parent.markDirty(this, parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  markClean(opts) {\n    const { force = false, recursive = true } = opts ?? {};\n    if (this._dirty === 0 /* NONE */ && !force) {\n      return;\n    }\n    this._dirty = 0 /* NONE */;\n    if (recursive !== false) {\n      for (const child of this._virtualChildren) {\n        child.markClean({ force });\n      }\n    }\n    if (recursive === true) {\n      for (const child of this._children) {\n        child.markClean({ force });\n      }\n    }\n  }\n  onVisibleChange() {\n  }\n  get nodeCount() {\n    let count = 1;\n    let dirtyCount = this._dirty >= 0 /* NONE */ || this.dirtyTransform ? 1 : 0;\n    let visibleCount = this.visible ? 1 : 0;\n    const countChild = (child) => {\n      const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;\n      count += childCount;\n      visibleCount += childVisibleCount;\n      dirtyCount += childDirtyCount;\n    };\n    for (const child of this._children) {\n      countChild(child);\n    }\n    for (const child of this._virtualChildren) {\n      countChild(child);\n    }\n    return { count, visibleCount, dirtyCount };\n  }\n  onZIndexChange() {\n    if (this.parent) {\n      this.parent.dirtyZIndex = true;\n    }\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotation\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationY\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    changeCb: (target) => target.onVisibleChange()\n  })\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndexSubOrder\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return !!_Color.nameToHex[str.toLowerCase()];\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta3 = max - min;\n      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta3 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta3 + 2;\n      } else {\n        h = (r - g) / delta3 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta3 = max - min;\n      const rc = (max - r) / delta3;\n      const gc = (max - g) / delta3;\n      const bc = (max - b) / delta3;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = {\n  // @ts-expect-error\n  __proto__: null,\n  aliceblue: \"#F0F8FF\",\n  antiquewhite: \"#FAEBD7\",\n  aqua: \"#00FFFF\",\n  aquamarine: \"#7FFFD4\",\n  azure: \"#F0FFFF\",\n  beige: \"#F5F5DC\",\n  bisque: \"#FFE4C4\",\n  black: \"#000000\",\n  blanchedalmond: \"#FFEBCD\",\n  blue: \"#0000FF\",\n  blueviolet: \"#8A2BE2\",\n  brown: \"#A52A2A\",\n  burlywood: \"#DEB887\",\n  cadetblue: \"#5F9EA0\",\n  chartreuse: \"#7FFF00\",\n  chocolate: \"#D2691E\",\n  coral: \"#FF7F50\",\n  cornflowerblue: \"#6495ED\",\n  cornsilk: \"#FFF8DC\",\n  crimson: \"#DC143C\",\n  cyan: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  darkcyan: \"#008B8B\",\n  darkgoldenrod: \"#B8860B\",\n  darkgray: \"#A9A9A9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#A9A9A9\",\n  darkkhaki: \"#BDB76B\",\n  darkmagenta: \"#8B008B\",\n  darkolivegreen: \"#556B2F\",\n  darkorange: \"#FF8C00\",\n  darkorchid: \"#9932CC\",\n  darkred: \"#8B0000\",\n  darksalmon: \"#E9967A\",\n  darkseagreen: \"#8FBC8F\",\n  darkslateblue: \"#483D8B\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  darkturquoise: \"#00CED1\",\n  darkviolet: \"#9400D3\",\n  deeppink: \"#FF1493\",\n  deepskyblue: \"#00BFFF\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1E90FF\",\n  firebrick: \"#B22222\",\n  floralwhite: \"#FFFAF0\",\n  forestgreen: \"#228B22\",\n  fuchsia: \"#FF00FF\",\n  gainsboro: \"#DCDCDC\",\n  ghostwhite: \"#F8F8FF\",\n  gold: \"#FFD700\",\n  goldenrod: \"#DAA520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#ADFF2F\",\n  grey: \"#808080\",\n  honeydew: \"#F0FFF0\",\n  hotpink: \"#FF69B4\",\n  indianred: \"#CD5C5C\",\n  indigo: \"#4B0082\",\n  ivory: \"#FFFFF0\",\n  khaki: \"#F0E68C\",\n  lavender: \"#E6E6FA\",\n  lavenderblush: \"#FFF0F5\",\n  lawngreen: \"#7CFC00\",\n  lemonchiffon: \"#FFFACD\",\n  lightblue: \"#ADD8E6\",\n  lightcoral: \"#F08080\",\n  lightcyan: \"#E0FFFF\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  lightgray: \"#D3D3D3\",\n  lightgreen: \"#90EE90\",\n  lightgrey: \"#D3D3D3\",\n  lightpink: \"#FFB6C1\",\n  lightsalmon: \"#FFA07A\",\n  lightseagreen: \"#20B2AA\",\n  lightskyblue: \"#87CEFA\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#B0C4DE\",\n  lightyellow: \"#FFFFE0\",\n  lime: \"#00FF00\",\n  limegreen: \"#32CD32\",\n  linen: \"#FAF0E6\",\n  magenta: \"#FF00FF\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66CDAA\",\n  mediumblue: \"#0000CD\",\n  mediumorchid: \"#BA55D3\",\n  mediumpurple: \"#9370DB\",\n  mediumseagreen: \"#3CB371\",\n  mediumslateblue: \"#7B68EE\",\n  mediumspringgreen: \"#00FA9A\",\n  mediumturquoise: \"#48D1CC\",\n  mediumvioletred: \"#C71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#F5FFFA\",\n  mistyrose: \"#FFE4E1\",\n  moccasin: \"#FFE4B5\",\n  navajowhite: \"#FFDEAD\",\n  navy: \"#000080\",\n  oldlace: \"#FDF5E6\",\n  olive: \"#808000\",\n  olivedrab: \"#6B8E23\",\n  orange: \"#FFA500\",\n  orangered: \"#FF4500\",\n  orchid: \"#DA70D6\",\n  palegoldenrod: \"#EEE8AA\",\n  palegreen: \"#98FB98\",\n  paleturquoise: \"#AFEEEE\",\n  palevioletred: \"#DB7093\",\n  papayawhip: \"#FFEFD5\",\n  peachpuff: \"#FFDAB9\",\n  peru: \"#CD853F\",\n  pink: \"#FFC0CB\",\n  plum: \"#DDA0DD\",\n  powderblue: \"#B0E0E6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#FF0000\",\n  rosybrown: \"#BC8F8F\",\n  royalblue: \"#4169E1\",\n  saddlebrown: \"#8B4513\",\n  salmon: \"#FA8072\",\n  sandybrown: \"#F4A460\",\n  seagreen: \"#2E8B57\",\n  seashell: \"#FFF5EE\",\n  sienna: \"#A0522D\",\n  silver: \"#C0C0C0\",\n  skyblue: \"#87CEEB\",\n  slateblue: \"#6A5ACD\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#FFFAFA\",\n  springgreen: \"#00FF7F\",\n  steelblue: \"#4682B4\",\n  tan: \"#D2B48C\",\n  teal: \"#008080\",\n  thistle: \"#D8BFD8\",\n  tomato: \"#FF6347\",\n  transparent: \"#00000000\",\n  turquoise: \"#40E0D0\",\n  violet: \"#EE82EE\",\n  wheat: \"#F5DEB3\",\n  white: \"#FFFFFF\",\n  whitesmoke: \"#F5F5F5\",\n  yellow: \"#FFFF00\",\n  yellowgreen: \"#9ACD32\"\n};\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/type-guards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isObjectLike(value) {\n  return isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumKey(enumObject, enumKey) {\n  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction deepMerge(...sources) {\n  return mergeDefaults(...sources.reverse());\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object2, mapper) {\n  return Object.entries(object2).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object2);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object2, keys) {\n  const clone = { ...object2 };\n  for (const key of keys) {\n    delete clone[key];\n  }\n  return clone;\n}\nfunction getPath(object2, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object2);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object2, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      Logger.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          self[propertyKey] = self[propertyKey] instanceof PropertiesArray ? self[propertyKey].reset(value) : self[propertyKey].set(value);\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        Logger.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object2, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object2;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    return new _PropertiesArray(this.itemFactory, ...properties);\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction deepClone(source, options) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, options));\n  }\n  if (isPlainObject(source)) {\n    return mapValues(\n      source,\n      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)\n    );\n  }\n  return shallowClone(source);\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return [...source];\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  if (isArray(json)) {\n    visit(json, ...jsons);\n    json.forEach((node, index) => {\n      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));\n    });\n  } else if (isPlainObject(json)) {\n    visit(json, ...jsons);\n    for (const key of Object.keys(json)) {\n      if (opts?.skip?.includes(key)) {\n        continue;\n      }\n      const value = json[key];\n      if (isArray(value) || isPlainObject(value)) {\n        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));\n      }\n    }\n  }\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property in source) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        Logger.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"object\") {\n        if (currentValue == null) {\n          targetAny[property] = {};\n        }\n        jsonApply(currentValue ?? targetAny[property], newValue, {\n          ...params,\n          path: propertyPath,\n          matcherPath: propertyMatcherPath\n        });\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\nfunction keyMapper(data, key) {\n  return data.map((dataObject) => dataObject?.[key]);\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array2) {\n  return array2.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    if (opts.from === opts.to)\n      return 0;\n    const diff2 = typeof opts.from === \"object\" ? jsonDiff(opts.from, opts.to) : null;\n    if (diff2) {\n      return calculatedDuration;\n    }\n    return 0;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  pause() {\n    this.isPlaying = false;\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from2, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from2, to);\n    }\n    const interpolatorEntries = [];\n    for (const key in to) {\n      const interpolator = this.interpolateValue(from2[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a === void 0 || b === void 0) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b)\n            return () => a;\n          break;\n      }\n    } catch (e) {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, intermediateFn } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      const { phase, start, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null && toFinish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from2,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          node.setProperties({ ...start, ...toStart });\n        },\n        onUpdate(props) {\n          node.setProperties(props);\n          if (intermediateFn) {\n            node.setProperties(intermediateFn(node, node.datum, status, ctx));\n          }\n        },\n        onStop: () => {\n          node.setProperties({\n            ...start,\n            ...toStart,\n            ...from2,\n            ...to,\n            ...finish,\n            ...toFinish\n          });\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from2;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start, finish, phase } = extraOpts;\n  const collapsable = finish == null;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from2,\n    to,\n    ease: easeOut,\n    collapsable,\n    onPlay: () => {\n      if (!start)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n        selection.cleanup();\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date, year2 = date.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date, year2 - 1);\n}\nfunction timezone(date) {\n  const offset4 = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(x) {\n  return x instanceof Date ? x.getTime() : x;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date) => formatter(date);\n}\nfunction calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));\n  }\n  const startYear = new Date(domain[0]).getFullYear();\n  const stopYear = new Date(domain.at(-1)).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second_default.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute_default.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour_default.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day_default.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month_default.floor(value) < value) {\n    if (week_default.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year_default.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\")\n      return true;\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.length - [...formatParts].reverse().findIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale {\n  constructor() {\n    this.type = \"band\";\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = /* @__PURE__ */ new Map();\n    /**\n     * The output range values for datum at each index.\n     */\n    this.ordinalRange = [];\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  set domain(values) {\n    this.index = /* @__PURE__ */ new Map();\n    this.invalid = true;\n    this._domain = [];\n    for (const value of values) {\n      const key = dateToNumber(value);\n      if (this.getIndex(key) === void 0) {\n        this.index.set(key, this._domain.push(value) - 1);\n      }\n    }\n  }\n  get domain() {\n    return this._domain;\n  }\n  getDomain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    return this._domain;\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null) {\n      return NaN;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => p === position);\n    return this.domain[index];\n  }\n  invertNearest(position) {\n    this.refresh();\n    let nearest = -1;\n    let minDistance = Infinity;\n    const index = this.ordinalRange.findIndex((p, i) => {\n      if (p === position)\n        return true;\n      const distance3 = Math.abs(position - p);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        nearest = i;\n      }\n      return false;\n    });\n    return this.domain[index] ?? this.domain[nearest];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round3 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep, step, inset;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n      step = round3 ? Math.round(rawStep) : rawStep;\n      inset = rangeDistance * paddingOuter;\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n      step = round3 ? Math.floor(rawStep) : rawStep;\n      inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    }\n    let bandwidth = step * (1 - paddingInner);\n    if (round3) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n    this.ordinalRange = this._domain.map((_, i) => inset + step * i);\n  }\n  getIndex(value) {\n    return this.index.get(value instanceof Date ? value.getTime() : value);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      let valueString = stringify(value);\n      const maxLength = 50;\n      if (valueString != null && valueString.length > maxLength) {\n        const excessCharacters = valueString.length - maxLength;\n        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;\n      }\n      Logger.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid2 = predicate(value, ctx);\n        if (!isValid2) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid2;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar DEGREE = NUMBER.restrict({ min: -360, max: 360 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v) => options.includes(v),\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.map((option) => `'${option}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\nfunction stringify(value) {\n  if (typeof value === \"number\") {\n    if (isNaN(value))\n      return \"NaN\";\n    if (value === Infinity)\n      return \"Infinity\";\n    if (value === -Infinity)\n      return \"-Infinity\";\n  }\n  return JSON.stringify(value);\n}\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    const sequencedModules = [\"toolbar\", \"navigator\"];\n    for (const m of this.moduleMap.values()) {\n      if (sequencedModules.includes(m.module.optionsKey)) {\n        continue;\n      }\n      yield m.moduleInstance;\n    }\n    for (const key of sequencedModules) {\n      const module = this.moduleMap.get(key);\n      if (module) {\n        yield module.moduleInstance;\n      }\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback2) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from2 = propsFn(node, node.datum);\n      node.setProperties(from2);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from2 = propsFn(node, node.datum);\n    node.setProperties(from2);\n  }\n}\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale {\n  constructor(domain, range3) {\n    this.invalid = true;\n    this.nice = false;\n    this.interval = void 0;\n    this.tickCount = _ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    // TODO(olegat) should be of type D[]\n    this.niceDomain = [];\n    this.defaultClampMode = \"raw\";\n    this.domain = domain;\n    this.range = range3;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const rangeDistance = this.getPixelRange();\n    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    const clampMode = opts?.clampMode ?? this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map((d) => this.transform(d));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    x = this.transform(x);\n    if (clampMode === \"clamped\") {\n      const [start, stop] = findMinMax(domain.map(Number));\n      if (Number(x) < start) {\n        return r0;\n      } else if (Number(x) > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\n_ContinuousScale.defaultMaxTickCount = 6;\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"nice\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"interval\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"maxTickCount\", 2);\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align, sign = \"-\", symbol, zero, width, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width != null && !isNaN(width)) {\n      result = addPadding(result, width, fill ?? zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width, fill = \" \", align = \">\") {\n  let result = numString;\n  if (align === \">\" || !align) {\n    result = result.padStart(width, fill);\n  } else if (align === \"<\") {\n    result = result.padEnd(width, fill);\n  } else if (align === \"^\") {\n    const padWidth = Math.max(0, width - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/array.ts\nfunction times(n, callback2) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(callback2(i));\n  }\n  return results;\n}\nfunction extent(values) {\n  if (values.length === 0) {\n    return;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let n of values) {\n    if (n instanceof Date) {\n      n = n.getTime();\n    }\n    if (typeof n !== \"number\") {\n      continue;\n    }\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n      max = n;\n    }\n  }\n  const result = [min, max];\n  if (result.every(isFinite)) {\n    return result;\n  }\n}\nfunction normalisedExtent(d, min, max) {\n  return normalisedExtentWithMetadata(d, min, max).extent;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array2) {\n  return Array.from(new Set(array2));\n}\nfunction groupBy(array2, iteratee) {\n  return array2.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction bifurcate(isLeft, array2) {\n  return array2.reduce(\n    ([left, right], value) => isLeft(value) ? [[...left, value], right] : [left, [...right, value]],\n    [[], []]\n  );\n}\nfunction* mapIterable(src, predicate) {\n  for (const e of src) {\n    yield predicate(e);\n  }\n}\nfunction constStringsIncludes(array2, value) {\n  const casting = array2;\n  return casting.includes(value);\n}\nfunction isInStringUnion(unionValues, value) {\n  return constStringsIncludes(unionValues, value);\n}\nfunction allInStringUnion(unionValues, values) {\n  return !values.some((v) => !isInStringUnion(unionValues, v));\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second_default, durationSecond, 1),\n  tInterval(second_default, durationSecond, 5),\n  tInterval(second_default, durationSecond, 15),\n  tInterval(second_default, durationSecond, 30),\n  tInterval(minute_default, durationMinute, 1),\n  tInterval(minute_default, durationMinute, 5),\n  tInterval(minute_default, durationMinute, 15),\n  tInterval(minute_default, durationMinute, 30),\n  tInterval(hour_default, durationHour, 1),\n  tInterval(hour_default, durationHour, 3),\n  tInterval(hour_default, durationHour, 6),\n  tInterval(hour_default, durationHour, 12),\n  tInterval(day_default, durationDay, 1),\n  tInterval(day_default, durationDay, 2),\n  tInterval(week_default, durationWeek, 1),\n  tInterval(week_default, durationWeek, 2),\n  tInterval(week_default, durationWeek, 3),\n  tInterval(month_default, durationMonth, 1),\n  tInterval(month_default, durationMonth, 2),\n  tInterval(month_default, durationMonth, 3),\n  tInterval(month_default, durationMonth, 4),\n  tInterval(month_default, durationMonth, 6),\n  tInterval(year_default, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction createTicks(start, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return range(start, stop, stop - start);\n  }\n  const step = tickStep(start, stop, count, minCount, maxCount);\n  if (isNaN(step)) {\n    return [];\n  }\n  start = Math.ceil(start / step) * step;\n  stop = Math.floor(stop / step) * step;\n  return range(start, stop, step);\n}\nfunction getTickInterval(start, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start, stop, count, minCount, maxCount), 1);\n    return millisecond_default.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year_default.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start, end, count, minCount = 0, maxCount = Infinity) {\n  if (start === end) {\n    return 1;\n  }\n  if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\\.|e/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const [_integer, decimal] = x.toExponential(digits - 1).split(/\\.|e/g);\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start, end, step) {\n  const n = Math.ceil(Math.abs(end - start) / step);\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start, end);\n  return times(n + 1, (i) => Math.round((d0 + step * i) * f) / f);\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    Logger.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start, end) {\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start, end];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start / m) * m;\n    const d1 = Math.ceil(end / m) * m;\n    const error = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error) {\n      minError = error;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\nfunction estimateTickCount(rangeExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {\n  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));\n  if (isNaN(minSpacing)) {\n    minSpacing = defaultMinSpacing;\n  }\n  if (isNaN(maxSpacing)) {\n    maxSpacing = rangeExtent;\n  }\n  if (minSpacing > maxSpacing) {\n    if (minSpacing === defaultMinSpacing) {\n      minSpacing = maxSpacing;\n    } else {\n      maxSpacing = minSpacing;\n    }\n  }\n  const maxTickCount = clamp(1, Math.floor(rangeExtent / minSpacing), Math.min(Math.floor(rangeExtent), 100));\n  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / maxSpacing));\n  const tickCount = clamp(minTickCount, defaultTickCount, maxTickCount);\n  return { minTickCount, maxTickCount, tickCount };\n}\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar _LogScale = class _LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = \"log\";\n    this.base = 10;\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    this.defaultClampMode = \"clamped\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  refresh() {\n    if (this.base <= 0) {\n      this.base = 0;\n      Logger.warnOnce(\"expecting a finite Number greater than to 0\");\n    }\n    super.refresh();\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.baseLog = _LogScale.getBaseLogMethod(this.base);\n    this.basePow = _LogScale.getBasePowerMethod(this.base);\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = this.pow(roundStart(this.log(d0)));\n    const n1 = this.pow(roundStop(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  ticks() {\n    const count = this.tickCount ?? 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    const start = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start);\n    let p1 = this.log(stop);\n    if (this.interval) {\n      const inBounds = (tick) => tick >= start && tick <= stop;\n      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);\n    }\n    const ticks = [];\n    const isPositive = start > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    if (count !== Infinity && ticks == null) {\n      this.ticks();\n    }\n    specifier ?? (specifier = this.base === 10 ? \".0e\" : \",\");\n    return isString(specifier) ? numberFormat(specifier) : specifier;\n  }\n  static getBaseLogMethod(base) {\n    switch (base) {\n      case 10:\n        return Math.log10;\n      case Math.E:\n        return Math.log;\n      case 2:\n        return Math.log2;\n      default:\n        const logBase = Math.log(base);\n        return (x) => Math.log(x) / logBase;\n    }\n  }\n  static getBasePowerMethod(base) {\n    switch (base) {\n      case 10:\n        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;\n      case Math.E:\n        return Math.exp;\n      default:\n        return (x) => base ** x;\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], _LogScale.prototype, \"base\", 2);\nvar LogScale = _LogScale;\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class _TimeScale extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(x, opts) {\n    return super.convert(new Date(x), opts);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;\n    const [start, stop] = findMinMax(this.getDomain().map(dateToNumber));\n    if (interval != null) {\n      return _TimeScale.getTicksForInterval({ start, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n    } else if (nice && tickCount === 2) {\n      return this.niceDomain;\n    } else if (nice && tickCount === 1) {\n      return this.niceDomain.slice(0, 1);\n    }\n    return _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n  }\n  static getDefaultTicks({\n    start,\n    stop,\n    tickCount,\n    minTickCount,\n    maxTickCount\n  }) {\n    const t = getTickInterval(start, stop, tickCount, minTickCount, maxTickCount);\n    return t ? t.range(new Date(start), new Date(stop)) : [];\n  }\n  static getTicksForInterval({\n    start,\n    stop,\n    interval,\n    availableRange\n  }) {\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks2 = interval.range(new Date(start), new Date(stop));\n      if (isDenseInterval(ticks2.length, availableRange)) {\n        return;\n      }\n      return ticks2;\n    }\n    const absInterval = Math.abs(interval);\n    if (isDenseInterval((stop - start) / absInterval, availableRange))\n      return;\n    const reversedInterval = [...TickIntervals].reverse();\n    const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval.duration === 0);\n    if (timeInterval) {\n      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n      return i.range(new Date(start), new Date(stop));\n    }\n    let date = new Date(start);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier,\n    formatOffset\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   * This method typically modifies the scales domain, and may only extend the bounds to the nearest round value.\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start = Math.min(dateToNumber(d0), dateToNumber(d1));\n    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n    const isReversed = d0 > d1;\n    const { interval } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === \"number\" ? (stop - start) / Math.max(interval, 1) : this.tickCount;\n      i = getTickInterval(start, stop, tickCount, this.minTickCount, this.maxTickCount);\n    }\n    if (i) {\n      const intervalRange = i.range(new Date(start), new Date(stop), true);\n      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n      const n0 = domain[0];\n      const n1 = domain.at(-1);\n      this.niceDomain = [n0, n1];\n    }\n  }\n};\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nvar _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.interval = void 0;\n    this._domain = [];\n    this.timestamps = [];\n    this.sortedTimestamps = [];\n    this.visibleRange = [0, 1];\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  setVisibleRange(visibleRange) {\n    this.visibleRange = visibleRange;\n  }\n  set domain(values) {\n    this.invalid = true;\n    if (values.length === 0) {\n      this._domain = [];\n      return;\n    }\n    this._domain = values;\n    this.timestamps = unique(values.map(dateToNumber));\n    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];\n    const start = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const isReversed = t0 > t1;\n    let ticks;\n    if (this.interval == null) {\n      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);\n    } else {\n      const [r0, r1] = this.range;\n      const availableRange = Math.abs(r1 - r0);\n      ticks = TimeScale.getTicksForInterval({ start, stop, interval: this.interval, availableRange }) ?? [];\n    }\n    const tickPositions = /* @__PURE__ */ new Set();\n    return ticks.filter((tick) => {\n      const position = this.convert(tick);\n      if (isNaN(position) || tickPositions.has(position)) {\n        return false;\n      }\n      tickPositions.add(position);\n      return true;\n    });\n  }\n  getDefaultTicks(maxTickCount, isReversed) {\n    const ticks = [];\n    const count = this.timestamps.length;\n    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);\n    const tickOffset = Math.floor(tickEvery / 2);\n    for (const [index, value] of this.timestamps.entries()) {\n      if (tickEvery > 0 && (index + tickOffset) % tickEvery)\n        continue;\n      if (isReversed) {\n        ticks.push(new Date(this.timestamps[count - index - 1]));\n      } else {\n        ticks.push(new Date(value));\n      }\n    }\n    return ticks;\n  }\n  convert(d) {\n    this.refresh();\n    const n = Number(d);\n    if (n < this.sortedTimestamps[0]) {\n      return NaN;\n    }\n    let i = this.findInterval(n);\n    if (this.timestamps[0] !== this.sortedTimestamps[0]) {\n      i = this.timestamps.length - i - 1;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  findInterval(target) {\n    const { sortedTimestamps } = this;\n    let low = 0;\n    let high = sortedTimestamps.length - 1;\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => position <= p);\n    return this.domain[index];\n  }\n  invertNearest(y) {\n    return new Date(super.invertNearest(y));\n  }\n};\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"maxTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"interval\", 2);\nvar OrdinalTimeScale = _OrdinalTimeScale;\n\n// packages/ag-charts-community/src/util/compare.ts\nfunction ascendingStringNumberUndefined(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  } else if (a == null && b == null) {\n    return 0;\n  } else if (a == null) {\n    return -1;\n  } else if (b == null) {\n    return 1;\n  }\n  return String(a).localeCompare(String(b));\n}\nfunction toLiteral(v) {\n  return typeof v === \"function\" ? v() : v;\n}\nfunction compoundAscending(a, b, comparator) {\n  for (const idx in a) {\n    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff2 !== 0) {\n      return diff2;\n    }\n  }\n  return 0;\n}\n\n// packages/ag-charts-community/src/scene/group.ts\nvar _Group = class _Group extends Node {\n  constructor(opts) {\n    super({ isVirtual: opts?.isVirtual, name: opts?.name });\n    this.opts = opts;\n    this.opacity = 1;\n    this.lastBBox = void 0;\n    const { zIndex, zIndexSubOrder } = opts ?? {};\n    this.isContainerNode = true;\n    if (zIndex !== void 0) {\n      this.zIndex = zIndex;\n    }\n    if (zIndexSubOrder !== void 0) {\n      this.zIndexSubOrder = zIndexSubOrder;\n    }\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  onZIndexChange() {\n    super.onZIndexChange();\n    if (this.layer) {\n      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n  isLayer() {\n    return this.layer != null;\n  }\n  _setLayerManager(layersManager) {\n    if (this._layerManager && this.layer) {\n      this._layerManager.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    if (this.layer) {\n      throw new Error(\"AG Charts - unable to deregister scene rendering layer!\");\n    }\n    super._setLayerManager(layersManager);\n  }\n  initialiseLayer() {\n    if (this.layer)\n      return;\n    if (!this._layerManager || this.opts?.layer !== true)\n      return;\n    this.layer = this._layerManager.addLayer({\n      name: this.name,\n      zIndex: this.zIndex,\n      zIndexSubOrder: this.zIndexSubOrder,\n      getComputedOpacity: () => this.getComputedOpacity(),\n      getVisibility: () => this.getVisibility()\n    });\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    for (const node of this.traverseUp()) {\n      if (node instanceof _Group) {\n        opacity *= node.opacity;\n      }\n    }\n    return opacity;\n  }\n  getVisibility() {\n    for (const node of this.traverseUp()) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  onVisibleChange() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  markDirty(source, type = 1 /* TRIVIAL */) {\n    if (this.isVirtual) {\n      super.markDirty(source, type);\n      return;\n    }\n    let parentType = type;\n    if (type < 2 /* MINOR */ || this.layer != null) {\n      parentType = 1 /* TRIVIAL */;\n    }\n    super.markDirty(source, type, parentType);\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    this.computeTransformMatrix();\n    return _Group.computeBBox(this.children);\n  }\n  computeTransformedBBox() {\n    return this.getBBox();\n  }\n  computeTransformedRegionBBox() {\n    if (this.clipRect) {\n      this.computeTransformMatrix();\n      return this.matrix.transformBBox(this.clipRect);\n    }\n    return this.computeTransformedBBox();\n  }\n  preRender() {\n    const counts = super.preRender();\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    if (this.opts?.layer !== true || this.layer != null)\n      return counts;\n    if (counts.nonGroups > 0) {\n      this.initialiseLayer();\n    }\n    if (this.opts?.nonEmptyChildDerivedZIndex && counts.nonGroups > 0) {\n      this.deriveZIndexFromChildren();\n    }\n    return counts;\n  }\n  deriveZIndexFromChildren() {\n    const children = this.children.filter((c) => c._childNodeCounts.nonGroups > 0);\n    this.sortChildren(children);\n    const lastChild = children.at(-1);\n    this.zIndex = lastChild?.zIndex ?? -Infinity;\n    this.zIndexSubOrder = lastChild?.zIndexSubOrder;\n  }\n  render(renderCtx) {\n    const { opts: { name = void 0 } = {}, _debug: debug3 } = this;\n    const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;\n    let { ctx, forceRender, clipBBox } = renderCtx;\n    const { resized, stats } = renderCtx;\n    const canvasCtxTransform = ctx.getTransform();\n    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of children) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);\n      if (isChildDirty) {\n        break;\n      }\n    }\n    if (name) {\n      debug3?.({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });\n    }\n    if (dirtyTransform) {\n      forceRender = \"dirtyTransform\";\n    } else if (layer) {\n      const currentBBox = this.getBBox();\n      if (this.lastBBox === void 0 || !this.lastBBox.equals(currentBBox)) {\n        forceRender = \"dirtyTransform\";\n        this.lastBBox = currentBBox;\n      }\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      if (name && stats) {\n        debug3?.({ name, result: \"skipping\", renderCtx, counts: this.nodeCount, group: this });\n      }\n      if (layer && stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      this.markClean({ recursive: false });\n      return;\n    }\n    const groupVisible = this.visible;\n    if (layer) {\n      ctx = layer.context;\n      ctx.save();\n      ctx.setTransform(layer.pixelRatio, 0, 0, layer.pixelRatio, 0, 0);\n      if (forceRender !== \"dirtyTransform\") {\n        forceRender = isChildDirty || dirtyZIndex;\n      }\n      if (forceRender)\n        layer.clear();\n      if (clipBBox) {\n        const { width, height, x, y } = clipBBox;\n        debug3?.(() => ({\n          name,\n          clipBBox,\n          ctxTransform: ctx.getTransform(),\n          renderCtx,\n          group: this\n        }));\n        ctx.beginPath();\n        ctx.rect(x, y, width, height);\n        ctx.clip();\n      }\n      ctx.setTransform(canvasCtxTransform);\n    } else {\n      ctx.globalAlpha *= this.opacity;\n    }\n    const matrix = this.transformRenderContext(renderCtx, ctx);\n    if (clipRect) {\n      const { x, y, width, height } = clipRect;\n      ctx.save();\n      debug3?.(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));\n      ctx.beginPath();\n      ctx.rect(x, y, width, height);\n      ctx.clip();\n      clipBBox = matrix.transformBBox(clipRect);\n    }\n    const hasVirtualChildren = this.hasVirtualChildren();\n    if (dirtyZIndex) {\n      this.sortChildren(children);\n      if (forceRender !== \"dirtyTransform\")\n        forceRender = true;\n    } else if (hasVirtualChildren) {\n      this.sortChildren(children);\n    }\n    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    const childRenderContext = renderContextChanged ? { ...renderCtx, ctx, forceRender, clipBBox } : renderCtx;\n    let skipped = 0;\n    for (const child of children) {\n      if (!child.visible || !groupVisible) {\n        child.markClean();\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      if (!forceRender && child.dirty === 0 /* NONE */) {\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      ctx.save();\n      child.render(childRenderContext);\n      ctx.restore();\n    }\n    if (stats)\n      stats.nodesSkipped += skipped;\n    super.render(renderCtx);\n    if (clipRect) {\n      ctx.restore();\n    }\n    if (hasVirtualChildren) {\n      for (const child of this.virtualChildren) {\n        child.markClean({ recursive: \"virtual\" });\n      }\n    }\n    if (layer) {\n      if (stats)\n        stats.layersRendered++;\n      ctx.restore();\n      if (forceRender)\n        layer.snapshot();\n      layer.context.verifyDepthZero?.();\n    }\n    if (name && stats) {\n      debug3?.({ name, result: \"rendered\", skipped, renderCtx, counts: this.nodeCount, group: this });\n    }\n  }\n  sortChildren(children) {\n    this.dirtyZIndex = false;\n    children.sort(\n      (a, b) => compoundAscending(\n        [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],\n        [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],\n        ascendingStringNumberUndefined\n      )\n    );\n  }\n  static computeBBox(nodes, opts) {\n    let left = Infinity;\n    let right = -Infinity;\n    let top = Infinity;\n    let bottom = -Infinity;\n    const skipInvisible = opts?.skipInvisible ?? true;\n    for (const n of nodes) {\n      if (skipInvisible && !n.visible)\n        continue;\n      const bbox = n.computeTransformedBBox();\n      if (!bbox)\n        continue;\n      const { x, y, width, height } = bbox;\n      if (x < left) {\n        left = x;\n      }\n      if (y < top) {\n        top = y;\n      }\n      if (x + width > right) {\n        right = x + width;\n      }\n      if (y + height > bottom) {\n        bottom = y + height;\n      }\n    }\n    return new BBox(left, top, right - left, bottom - top);\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectInGroupCoordinateSpace(bbox) {\n    this.clipRect = bbox ? this.transformBBox(bbox) : void 0;\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\n\n// packages/ag-charts-community/src/util/dom.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    element2.classList.add(className);\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\nfunction downloadUrl(dataUrl, fileName) {\n  const { body } = getDocument();\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\nfunction setElementBBox(element2, bbox) {\n  if (element2) {\n    element2.style.width = `${bbox.width}px`;\n    element2.style.height = `${bbox.height}px`;\n    element2.style.left = `${bbox.x}px`;\n    element2.style.top = `${bbox.y}px`;\n  }\n}\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      node.children.forEach(traverse);\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, Class, ...ExtraClasses) {\n    return _Selection.selectAll(node, (n) => {\n      return n instanceof Class || ExtraClasses.some((C) => n instanceof C);\n    });\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      const datum = this._nodes[index].datum;\n      yield { node, datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n  at(index) {\n    return this._nodes.at(index);\n  }\n};\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleDiff(angle0, angle1, counterClockwise) {\n  if (counterClockwise) {\n    [angle0, angle1] = [angle1, angle0];\n  }\n  const a0 = normalizeAngle360(angle0);\n  const a1 = normalizeAngle360(angle1) + twoPi;\n  return (a1 - a0) % twoPi;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction displacePointFromVector(centerX, centerY, radius, angle2) {\n  const x = centerX + radius * Math.cos(angle2);\n  const y = centerY + radius * Math.sin(angle2);\n  return { x, y };\n}\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(stops = []) {\n    this.stops = stops;\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(stops, angle2 = 0) {\n    super(stops);\n    this.angle = angle2;\n  }\n  createGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { stops, angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    if (w > 0 && h > 0) {\n      const diagonal = Math.sqrt(h * h + w * w) / 2;\n      const diagonalAngle = Math.atan2(h, w);\n      let quarteredAngle;\n      if (radians < Math.PI / 2) {\n        quarteredAngle = radians;\n      } else if (radians < Math.PI) {\n        quarteredAngle = Math.PI - radians;\n      } else if (radians < 1.5 * Math.PI) {\n        quarteredAngle = radians - Math.PI;\n      } else {\n        quarteredAngle = 2 * Math.PI - radians;\n      }\n      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n      for (const stop of stops) {\n        gradient.addColorStop(stop.offset, stop.color);\n      }\n      return gradient;\n    }\n    return \"black\";\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  onFillChange() {\n    const { fill } = this;\n    let linearGradientMatch;\n    if (fill?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient(\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else {\n      this.gradient = void 0;\n    }\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start, length2) {\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n    if (length2 == null) {\n      return alignedStart;\n    } else if (length2 === 0) {\n      return 0;\n    } else if (length2 < 1) {\n      return Math.ceil(length2 * pixelRatio) / pixelRatio;\n    }\n    return Math.round((length2 + start) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    path ? ctx.fill(path) : ctx.fill();\n  }\n  applyFill(ctx) {\n    ctx.fillStyle = this.gradient?.createGradient(ctx, this.getBBox()) ?? this.fill;\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    path ? ctx.stroke(path) : ctx.stroke();\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 2 /* MINOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(px, py) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      const { x, y } = this.transformPoint(px, py);\n      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  fill: void 0,\n  strokeWidth: 1\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width = 0, height = 0) {\n  return new OffscreenCanvas(width, height).getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/lruCache.ts\nvar LRUCache = class {\n  constructor(maxCacheSize = 5) {\n    this.maxCacheSize = maxCacheSize;\n    this.store = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    if (!this.store.has(key))\n      return void 0;\n    const hit = this.store.get(key);\n    this.store.delete(key);\n    this.store.set(key, hit);\n    return hit;\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  set(key, value) {\n    this.store.set(key, value);\n    if (this.store.size > this.maxCacheSize) {\n      const iterator = this.store.keys();\n      let evictCount = this.store.size - this.maxCacheSize;\n      while (evictCount > 0) {\n        const evictKeyIterator = iterator.next();\n        if (!evictKeyIterator.done) {\n          this.store.delete(evictKeyIterator.value);\n        }\n        evictCount--;\n      }\n    }\n    return value;\n  }\n  clear() {\n    this.store.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar CachedTextMeasurerPool = class {\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureText(text);\n  }\n  static measureLines(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureLines(text);\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getMeasurer(options) {\n    const font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    const key = `${font}-${options.textAlign ?? \"start\"}-${options.textBaseline ?? \"alphabetic\"}`;\n    return this.instanceMap.get(key) ?? this.createFontMeasurer(font, options, key);\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font, options, key) {\n    const ctx = createCanvasContext();\n    ctx.font = font;\n    ctx.textAlign = options.textAlign ?? \"start\";\n    ctx.textBaseline = options.textBaseline ?? \"alphabetic\";\n    const measurer = new CachedTextMeasurer(ctx, options);\n    this.instanceMap.set(key, measurer);\n    return measurer;\n  }\n};\nCachedTextMeasurerPool.instanceMap = new LRUCache(10);\nvar CachedTextMeasurer = class {\n  constructor(ctx, options) {\n    this.ctx = ctx;\n    // cached text measurements\n    this.measureMap = new LRUCache(100);\n    if (options.textAlign) {\n      ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      ctx.textBaseline = options.textBaseline;\n    }\n    ctx.font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    this.textMeasurer = new SimpleTextMeasurer(\n      (t) => this.cachedCtxMeasureText(t),\n      options.textBaseline ?? \"alphabetic\"\n    );\n  }\n  textWidth(text, estimate) {\n    return this.textMeasurer.textWidth(text, estimate);\n  }\n  measureText(text) {\n    return this.textMeasurer.measureText(text);\n  }\n  measureLines(text) {\n    return this.textMeasurer.measureLines(text);\n  }\n  cachedCtxMeasureText(text) {\n    if (!this.measureMap.has(text)) {\n      const rawResult = this.ctx.measureText(text);\n      this.measureMap.set(text, {\n        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,\n        emHeightAscent: rawResult.emHeightAscent,\n        emHeightDescent: rawResult.emHeightDescent,\n        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,\n        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,\n        alphabeticBaseline: rawResult.alphabeticBaseline,\n        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,\n        hangingBaseline: rawResult.hangingBaseline,\n        ideographicBaseline: rawResult.ideographicBaseline,\n        width: rawResult.width\n      });\n    }\n    return this.measureMap.get(text);\n  }\n};\nvar TextUtils = class {\n  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {\n    let fontString = \"\";\n    if (fontStyle) {\n      fontString += `${fontStyle} `;\n    }\n    if (fontWeight) {\n      fontString += `${fontWeight} `;\n    }\n    fontString += `${fontSize}px`;\n    if (lineHeight) {\n      fontString += `/${lineHeight}px`;\n    }\n    fontString += ` ${fontFamily}`;\n    return fontString.trim();\n  }\n  static getLineHeight(fontSize) {\n    return Math.ceil(fontSize * this.defaultLineHeight);\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n};\nTextUtils.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextUtils.defaultLineHeight = 1.15;\n// Normally between 1.1 and 1.2\nTextUtils.lineSplitter = /\\r?\\n/g;\nvar SimpleTextMeasurer = class {\n  constructor(measureTextFn, textBaseline = \"alphabetic\") {\n    this.measureTextFn = measureTextFn;\n    this.textBaseline = textBaseline;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Measures metrics for a single line of text.\n  getMetrics(text) {\n    const m = this.measureTextFn(text);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  getMultilineMetrics(lines) {\n    let width = 0;\n    let height = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);\n    const lineMetrics = [];\n    let index = 0;\n    const length2 = lines.length;\n    for (const line of lines) {\n      const m = this.measureTextFn(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width < m.width) {\n        width = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      lineMetrics.push({\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      });\n      index++;\n    }\n    height += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width, height, offsetTop, offsetLeft, lineMetrics };\n  }\n  textWidth(text, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text.length; i++) {\n        estimatedWidth += this.textWidth(text.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text.length > 1) {\n      return this.measureTextFn(text).width;\n    }\n    return this.charMap.get(text) ?? this.charWidth(text);\n  }\n  measureText(text) {\n    return this.getMetrics(text);\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  measureLines(text) {\n    const lines = typeof text === \"string\" ? text.split(TextUtils.lineSplitter) : text;\n    return this.getMultilineMetrics(lines);\n  }\n  charWidth(char) {\n    const { width } = this.measureTextFn(char);\n    this.charMap.set(char, width);\n    return width;\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nfunction SceneFontChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"font\", changeCb });\n}\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  static computeBBox(lines, x, y, opts) {\n    const { offsetTop, offsetLeft, width, height } = CachedTextMeasurerPool.measureLines(lines, opts);\n    return new BBox(x - offsetLeft, y - offsetTop, width, height);\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return bbox ? bbox.containsPoint(point.x, point.y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    const { fill, stroke, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = TextUtils.toFontString(this);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      ctx.fillStyle = fill;\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);\n    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);\n    for (const line of lines) {\n      renderCallback(line, x, y + offsetY);\n      offsetY += lineHeight;\n    }\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n};\n_Text.className = \"Text\";\n// The default line spacing for document editors is usually 1.15\n_Text.defaultLineHeightRatio = 1.15;\n_Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0) {\n    return false;\n  }\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!(datum?.length && datum[0].label)) {\n      continue;\n    }\n    for (let index = 0, ln = datum.length; index < ln; index++) {\n      const d = datum[index];\n      const { point, label, marker } = d;\n      const { text, width, height } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width * 0.5 + r + padding) * placement.x;\n        dy = (height * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(\n        (dataDatums) => dataDatums.some(\n          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width, height)\n        )\n      );\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width, height)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({ index, text, x, y, width, height, datum: d });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding) {\n  const result = [];\n  for (let index = 0; index < data.length; index++) {\n    const datum = data[index];\n    const {\n      point: { x, y },\n      label: { text }\n    } = datum;\n    let { width, height } = datum.label;\n    width += padding ?? 0;\n    height += padding ?? 0;\n    if (result.some((l) => rectRectOverlap(l, x, y, width, height))) {\n      return true;\n    }\n    result.push({ index, text, x, y, width, height, datum });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/equal.ts\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar debugQuietColor = \"color: grey\";\nvar _StateMachine = class _StateMachine {\n  constructor(defaultState, states, enterEach) {\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {\n      return;\n    }\n    const currentState = this.state;\n    const currentStateConfig = this.states[this.state];\n    let destination = currentStateConfig[event];\n    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;\n    if (Array.isArray(destination)) {\n      destination = destination.find((transition) => {\n        if (!transition.guard)\n          return true;\n        const valid = transition.guard(data);\n        if (!valid) {\n          this.debug(`${debugPrefix} ${transition.target} (guarded)`, debugQuietColor);\n        }\n        return valid;\n      });\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {\n      this.debug(`${debugPrefix} ${destination.target} (guarded)`, debugQuietColor);\n      return;\n    }\n    if (!destination) {\n      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);\n      return;\n    }\n    const destinationState = this.getDestinationState(destination);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`${debugPrefix} ${destinationState}`, debugColor);\n    this.state = destinationState;\n    if (typeof destination === \"function\") {\n      destination(data);\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine)) {\n      destination.action?.(data);\n    }\n    exitFn?.();\n    this.enterEach?.(currentState, destinationState);\n    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {\n      this.states[destinationState].onEnter?.(currentState, data);\n    }\n  }\n  is(value) {\n    if (this.state === _StateMachine.child && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== _StateMachine.child || !this.childState)\n      return true;\n    this.childState.transition(event, data);\n    if (!this.childState.is(_StateMachine.parent))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(destination) {\n    let state = this.state;\n    if (typeof destination === \"string\") {\n      state = destination;\n    } else if (destination instanceof _StateMachine) {\n      this.childState = destination;\n      state = _StateMachine.child;\n    } else if (typeof destination === \"object\") {\n      if (destination.target instanceof _StateMachine) {\n        this.childState = destination.target;\n        state = _StateMachine.child;\n      } else {\n        state = destination.target;\n      }\n    }\n    return state;\n  }\n};\n_StateMachine.child = \"__child\";\n_StateMachine.parent = \"__parent\";\nvar StateMachine = _StateMachine;\n\n// packages/ag-charts-community/src/util/textWrapper.ts\nvar TextWrapper = class {\n  static wrapText(text, options) {\n    return this.wrapLines(text, options).join(\"\\n\");\n  }\n  static wrapLines(text, options) {\n    const clippedResult = this.textWrap(text, options);\n    if (options.overflow === \"hide\" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {\n      return [];\n    }\n    return clippedResult;\n  }\n  static appendEllipsis(text) {\n    return text.replace(/[.,]{1,5}$/, \"\") + TextUtils.EllipsisChar;\n  }\n  static truncateLine(text, measurer, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer.textWidth(TextUtils.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text.length; i++) {\n      const charWidth = measurer.textWidth(text.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text + TextUtils.EllipsisChar : text;\n    }\n    text = text.slice(0, i).trimEnd();\n    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {\n      text = text.slice(0, -1).trimEnd();\n    }\n    return text + TextUtils.EllipsisChar;\n  }\n  static textWrap(text, options) {\n    const lines = text.split(TextUtils.lineSplitter);\n    const measurer = CachedTextMeasurerPool.getMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap == null || options.textWrap === \"on-space\";\n    for (let line of lines) {\n      line = line.trimEnd();\n      if (line === \"\") {\n        result.push(line);\n        continue;\n      }\n      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          const actualWidth = measurer.textWidth(line.slice(0, i + 1));\n          if (actualWidth <= options.maxWidth) {\n            estimatedWidth = actualWidth;\n            continue;\n          }\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = -1;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer, options);\n    return this.clipLines(result, measurer, options);\n  }\n  static getWordAt(text, position) {\n    const nextSpaceIndex = text.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height, lineMetrics } = measurer.measureLines(lines);\n    if (height <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        if (options.overflow === \"hide\") {\n          return [];\n        }\n        const clippedResults = lines.slice(0, i || 1);\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer, options) {\n    if (options.avoidOrphans === false || lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction setAttribute(e, qualifiedName, value) {\n  if (value === void 0 || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\nfunction setVisibility(element2, hiddenToken, hidden) {\n  element2.ariaHidden = `${hidden}`;\n  element2.classList.toggle(hiddenToken, hidden);\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, container, bounds) {\n  let { top, right, bottom, left, width, height } = bounds;\n  if (left != null) {\n    if (width != null) {\n      right = container.width - left + width;\n    } else if (right != null) {\n      width = container.width - left - right;\n    }\n  } else if (right != null && width != null) {\n    left = container.width - right - width;\n  }\n  if (top != null) {\n    if (height != null) {\n      bottom = container.height - top - height;\n    } else if (bottom != null) {\n      height = container.height - bottom - top;\n    }\n  } else if (bottom != null && height != null) {\n    top = container.height - bottom - height;\n  }\n  if (width == null) {\n    if (height == null) {\n      width = naturalWidth;\n      height = naturalHeight;\n    } else {\n      width = Math.ceil(naturalWidth * height / naturalHeight);\n    }\n  } else if (height == null) {\n    height = Math.ceil(naturalHeight * width / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((container.width - width) / 2);\n    } else {\n      left = container.width - right - width;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((container.height - height) / 2);\n    } else {\n      top = container.height - height - bottom;\n    }\n  }\n  return { x: left, y: top, width, height };\n}\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-chart-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-chart-dark-tooltip\";\nvar EMPTY_TOOLTIP_CONTENT = { html: \"\", ariaLabel: \"\" };\nfunction toAccessibleText(inputHtml) {\n  const lineConverter = (_match, offset4, str) => {\n    if (offset4 === 0 || str[offset4 - 1] !== \".\") {\n      return \". \";\n    }\n    return \" \";\n  };\n  return inputHtml.replace(/<br\\s*\\/?>/g, lineConverter).replace(/<\\/p\\s+>/g, lineConverter).replace(/<\\/li\\s*>/g, lineConverter).replace(/<[^<>]+>/g, \"\").replace(/\\n+/g, \" \").replace(/\\s+/g, \" \");\n}\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return { html: input, ariaLabel: input };\n  }\n  const {\n    content = defaults?.content ?? \"\",\n    title = defaults?.title,\n    color = defaults?.color ?? \"white\",\n    backgroundColor = defaults?.backgroundColor ?? \"#888\"\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : \"\";\n  const titleAria = title ? `${title}: ` : \"\";\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : \"\";\n  return {\n    html: `${titleHtml}${contentHtml}`,\n    ariaLabel: toAccessibleText(`${titleAria}${content}`)\n  };\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\"\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.bounds = \"extended\";\n    this.enableInteraction = false;\n    this.lastVisibilityChange = Date.now();\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n    setAttribute(this.element, \"aria-hidden\", true);\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n  }\n  isVisible() {\n    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + \"-hidden\");\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(boundingRect, canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    if (content != null && element2 != null) {\n      element2.innerHTML = content.html;\n    } else if (!element2?.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });\n    const relativeRect = {\n      x: boundingRect.x - canvasRect.x,\n      y: boundingRect.y - canvasRect.y,\n      width: boundingRect.width,\n      height: boundingRect.height\n    };\n    const position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    const minX = relativeRect.x;\n    const minY = relativeRect.y;\n    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;\n    const maxY = relativeRect.height - element2.clientHeight + minY;\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    element2.style.pointerEvents = meta.enableInteraction ? \"auto\" : \"none\";\n    element2.setAttribute(\"data-pointer-capture\", \"retain\");\n    this.enableInteraction = meta.enableInteraction ?? false;\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  toggle(visible) {\n    if (!this.element)\n      return;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);\n    const wasVisible = this.isVisible();\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    if (wasVisible !== visible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const animatedMoveThresholdMs = 100;\n    const thrashingThresholdMs = 5;\n    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass(\"no-animation\", noAnimation);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"hidden\", !visible);\n    toggleClass(\"arrow\", this._showArrow);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    if (newValue) {\n      target.element?.classList.add(newValue);\n    }\n    if (oldValue) {\n      target.element?.classList.remove(oldValue);\n    }\n  }),\n  Validate(STRING, { optional: true })\n], Tooltip.prototype, \"class\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(UNION([\"extended\", \"canvas\"]))\n], Tooltip.prototype, \"bounds\", 2);\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new Text({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.truncated = false;\n    this.layoutStyle = \"block\";\n  }\n  registerInteraction(moduleCtx) {\n    const { regionManager, proxyInteractionService, layoutService } = moduleCtx;\n    const region = regionManager.getRegion(\"root\");\n    const destroyFns = [\n      layoutService.addListener(\"layout-complete\", () => this.updateA11yText(proxyInteractionService)),\n      region.addListener(\"hover\", (event) => this.handleMouseMove(moduleCtx, event)),\n      region.addListener(\"leave\", (event) => this.handleMouseLeave(moduleCtx, event))\n    ];\n    return joinFunctions(...destroyFns);\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth);\n    const maxHeight = this.maxHeight ?? containerHeight;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrappedText = TextWrapper.wrapText(text ?? \"\", { maxWidth, maxHeight, font: this, textWrap: wrapping });\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);\n  }\n  updateA11yText(proxyService) {\n    if (this.enabled && this.text) {\n      const bbox = this.node.computeTransformedBBox();\n      if (bbox) {\n        const { id } = this;\n        this.proxyText ?? (this.proxyText = proxyService.createProxyElement({ type: \"text\", id, parent: \"canvas-proxy\" }));\n        this.proxyText.textContent = this.text;\n        this.proxyText.updateBounds(bbox);\n      }\n    } else {\n      this.proxyText?.remove();\n      this.proxyText = void 0;\n    }\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {\n      const { offsetX, offsetY } = event;\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.text })\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN)\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"lineHeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return TextUtils.toFontString(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction calculateLabelBBox(text, bbox, labelMatrix) {\n  const { x: labelX, y: labelY, width, height } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const { x, y } = bbox;\n  return {\n    point: { x, y },\n    label: { text, width, height }\n  };\n}\n\n// packages/ag-charts-community/src/chart/layers.ts\nvar Layers = /* @__PURE__ */ ((Layers2) => {\n  Layers2[Layers2[\"SERIES_BACKGROUND_ZINDEX\"] = 0] = \"SERIES_BACKGROUND_ZINDEX\";\n  Layers2[Layers2[\"AXIS_GRID_ZINDEX\"] = 1] = \"AXIS_GRID_ZINDEX\";\n  Layers2[Layers2[\"AXIS_ZINDEX\"] = 2] = \"AXIS_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 3] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LAYER_ZINDEX\"] = 4] = \"SERIES_LAYER_ZINDEX\";\n  Layers2[Layers2[\"SERIES_HIGHLIGHT_ZINDEX\"] = 5] = \"SERIES_HIGHLIGHT_ZINDEX\";\n  Layers2[Layers2[\"AXIS_FOREGROUND_ZINDEX\"] = 6] = \"AXIS_FOREGROUND_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSHAIR_ZINDEX\"] = 7] = \"SERIES_CROSSHAIR_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LABEL_ZINDEX\"] = 8] = \"SERIES_LABEL_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 9] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_ANNOTATION_ZINDEX\"] = 10] = \"SERIES_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"CHART_ANNOTATION_ZINDEX\"] = 11] = \"CHART_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"CHART_ANNOTATION_FOCUSED_ZINDEX\"] = 12] = \"CHART_ANNOTATION_FOCUSED_ZINDEX\";\n  Layers2[Layers2[\"LEGEND_ZINDEX\"] = 13] = \"LEGEND_ZINDEX\";\n  Layers2[Layers2[\"NAVIGATOR_ZINDEX\"] = 14] = \"NAVIGATOR_ZINDEX\";\n  Layers2[Layers2[\"FOREGROUND_ZINDEX\"] = 15] = \"FOREGROUND_ZINDEX\";\n  return Layers2;\n})(Layers || {});\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start, end] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start, isContinuous2) && !isNaN(scale2.convert(start));\n  const validEnd = checkDatum(end, isContinuous2) && !isNaN(scale2.convert(end));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringify(start)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringify(end)}`);\n    }\n  } else {\n    message.push(`value ${stringify(start)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  Logger.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const w = yDirection ? bbox.width : bbox.height;\n  const h = yDirection ? bbox.height : bbox.width;\n  const xTranslation = xTranslationDirection * (padding + w / 2);\n  const yTranslation = yTranslationDirection * (padding + h / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {\n  if (yDirection) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  insideLeft: { c: POSITION_LEFT_COORDINATES },\n  insideRight: { c: POSITION_RIGHT_COORDINATES },\n  insideTop: { c: POSITION_TOP_COORDINATES },\n  insideBottom: { c: POSITION_BOTTOM_COORDINATES },\n  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"topLeft\",\n    \"topRight\",\n    \"bottomLeft\",\n    \"bottomRight\",\n    \"inside\",\n    \"insideLeft\",\n    \"insideRight\",\n    \"insideTop\",\n    \"insideBottom\",\n    \"insideTopLeft\",\n    \"insideBottomLeft\",\n    \"insideTopRight\",\n    \"insideBottomRight\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar _CartesianCrossLine = class _CartesianCrossLine extends BaseProperties {\n  constructor() {\n    super();\n    this.id = createId(this);\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new Text();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.group.append(this.crossLineRange);\n    this.labelGroup.append(this.crossLineLabel);\n    this.crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible)\n      return;\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2)\n      return;\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, { clampMode: \"clamped\" })) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, { clampMode: \"clamped\" }) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine)\n      return;\n    this.data = [clampedYStart, clampedYEnd];\n    if (this.label.enabled) {\n      const yDirection = direction === \"y\" /* Y */;\n      const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n      const { x: labelX, y: labelY } = c({\n        yDirection,\n        xStart,\n        xEnd,\n        yStart: clampedYStart,\n        yEnd: clampedYEnd\n      });\n      this.labelPoint = {\n        x: labelX,\n        y: labelY\n      };\n    }\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text)\n      return;\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.computeTransformedBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    return isRange ? _CartesianCrossLine.RANGE_LAYER_ZINDEX : _CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start = range3?.[0] ?? value;\n    let end = range3?.[1];\n    if (!isContinuous2 && end === void 0) {\n      end = start;\n    }\n    if (isContinuous2 && start === end) {\n      end = void 0;\n    }\n    return [start, end];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled)\n      return;\n    const tempText = new Text();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.computeTransformedBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.translationX = x + xTranslation;\n    tempText.translationY = y + yTranslation;\n    return tempText.computeTransformedBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine)\n      return;\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)\n      return;\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\n_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE_ZINDEX */;\n_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE_ZINDEX */;\n_CartesianCrossLine.LABEL_LAYER_ZINDEX = 8 /* SERIES_LABEL_ZINDEX */;\n_CartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], _CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], _CartesianCrossLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _CartesianCrossLine.prototype, \"label\", 2);\nvar CartesianCrossLine = _CartesianCrossLine;\n\n// packages/ag-charts-community/src/chart/interaction/regions.ts\nvar REGIONS = /* @__PURE__ */ ((REGIONS2) => {\n  REGIONS2[\"TITLE\"] = \"title\";\n  REGIONS2[\"SUBTITLE\"] = \"subtitle\";\n  REGIONS2[\"FOOTNOTE\"] = \"footnote\";\n  REGIONS2[\"LEGEND\"] = \"legend\";\n  REGIONS2[\"NAVIGATOR\"] = \"navigator\";\n  REGIONS2[\"PAGINATION\"] = \"pagination\";\n  REGIONS2[\"ROOT\"] = \"root\";\n  REGIONS2[\"SERIES\"] = \"series\";\n  REGIONS2[\"HORIZONTAL_AXES\"] = \"horizontal-axes\";\n  REGIONS2[\"VERTICAL_AXES\"] = \"vertical-axes\";\n  REGIONS2[\"TOOLBAR\"] = \"toolbar\";\n  return REGIONS2;\n})(REGIONS || {});\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.minSpacing = NaN;\n    this.color = \"#575757\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start, end) {\n  const directDistance = Math.abs(end - start);\n  if (directDistance < halfCircle)\n    return end;\n  if (start > end)\n    return end + fullCircle;\n  return end - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    intermediateFn(node, _datum, _status) {\n      return { visible: !outOfBounds(node.y) };\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        opacity = 1;\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.lineNode = this.axisGroup.appendChild(new Line({ name: `${this.id}-Axis-line` }));\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });\n    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */ });\n    this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });\n    this.gridLineGroup = this.gridGroup.appendChild(\n      new Group({\n        name: `${this.id}-gridLines`,\n        zIndex: 1 /* AXIS_GRID_ZINDEX */\n      })\n    );\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\n    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this._titleCaption = new Caption();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = void 0;\n    this.maxThickness = Infinity;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n    this.destroyFns.push(this._titleCaption.registerInteraction(this.moduleCtx));\n    this._titleCaption.node.rotation = -Math.PI / 2;\n    this.axisGroup.appendChild(this._titleCaption.node);\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    this._crossLines = [];\n    let previousSize = void 0;\n    this.destroyFns.push(\n      moduleCtx.layoutService.addListener(\"layout-complete\", (e) => {\n        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = { ...e.chart };\n      })\n    );\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  set crossLines(value) {\n    const { CrossLineConstructor } = this.constructor;\n    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));\n    this._crossLines = value.map((crossLine) => {\n      const instance = new CrossLineConstructor();\n      instance.set(crossLine);\n      return instance;\n    });\n    this._crossLines.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n    this.crossLineGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n    this.crossLineGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    scale2.setVisibleRange?.(vr);\n    scale2.range = [start, start + span];\n    this.crossLines.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n    axisNode.appendChild(this.labelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n    axisNode.removeChild(this.labelGroup);\n  }\n  getAxisGroup() {\n    return this.axisGroup;\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(x, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  onFormatChange(ticks, fractionDigits, _domain, format) {\n    const { scale: scale2 } = this;\n    const logScale = scale2 instanceof LogScale;\n    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === \"number\" ? x.toFixed(fractionDigits + formatOffset) : String(x);\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        const formatter = scale2.tickFormat({ ticks, specifier: format });\n        this.labelFormatter = formatter;\n        this.datumFormatter = formatter;\n      } catch (e) {\n        this.labelFormatter = defaultFormatter(0);\n        this.datumFormatter = defaultFormatter(1);\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultFormatter(0);\n      this.datumFormatter = defaultFormatter(1);\n    }\n  }\n  setTickInterval(interval) {\n    this.scale.interval = this.interval?.step ?? interval;\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue && !value || !prevValue && value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update(_primaryTickCount = 0, animated = true) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;\n    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (!animated || this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition(\"update\", diff2);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\n    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\n    this.updateLayoutState(tickData.fractionDigits);\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  getTickLabelProps(datum, params) {\n    const { label } = this;\n    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);\n    const visible = text !== \"\" && text != null;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 6;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    titleNode.setProperties({\n      rotation,\n      text,\n      textBaseline,\n      visible: true,\n      x,\n      y\n    });\n  }\n  calculateLayout(primaryTickCount) {\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);\n    this.updateScale();\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;\n    this.updateLayoutState(tickData.fractionDigits);\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      tickData.ticks.forEach((datum) => {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    if (this.label.enabled) {\n      const tempText = new Text();\n      tickData.ticks.forEach((datum) => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties({\n          ...labelProps,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.computeTransformedBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    if (this.title?.enabled) {\n      const caption = new Caption();\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(caption, { spacing });\n      const titleNode = caption.node;\n      const titleBox = titleNode.computeTransformedBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = this.getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout?.(anySeriesActive, this.reverse);\n    });\n    return {\n      primaryTickCount: ticksResult.primaryTickCount,\n      bbox: transformedBBox\n    };\n  }\n  updateLayoutState(fractionDigits) {\n    this.layout.label = {\n      fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  getTransformBox(bbox) {\n    const matrix = new Matrix();\n    const {\n      rotation: axisRotation,\n      translationX,\n      translationY,\n      rotationCenterX,\n      rotationCenterY\n    } = this.getAxisTransform();\n    Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n      scalingCenterX: 0,\n      scalingCenterY: 0,\n      rotationCenterX,\n      rotationCenterY\n    });\n    return matrix.transformBBox(bbox);\n  }\n  setDomain(domain) {\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.scale.domain = this.dataDomain.domain;\n  }\n  updateScale() {\n    this.updateRange();\n    this.calculateDomain();\n    this.setTickInterval(this.interval.step);\n    const { scale: scale2, nice } = this;\n    if (!ContinuousScale.is(scale2)) {\n      return;\n    }\n    scale2.nice = nice;\n    scale2.update();\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      interval: { minSpacing, maxSpacing },\n      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }\n    } = this;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      fractionDigits: 0,\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\n      for (const strategy of tickStrategies) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const labelRotation = initialRotation + autoRotation;\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelOverlap = this.label.avoidCollisions ? this.checkLabelOverlap(labelRotation, rotated, labelMatrix, tickData.ticks, labelX, textMeasurer) : false;\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\n  }\n  getTickStrategies({\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label } = this;\n    const { minSpacing } = this.interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    const { scale: scale2 } = this;\n    const { step, values, minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.fractionDigits = fractionDigits;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = step !== void 0 || values !== void 0;\n    terminate || (terminate = shouldTerminate);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textMeasurer) {\n    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\n    const labelData = this.createLabelData(tickData, labelX, labelMatrix, textMeasurer);\n    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n    return axisLabelsOverlap(labelData, labelSpacing);\n  }\n  createLabelData(tickData, labelX, labelMatrix, textMeasurer) {\n    const labelData = [];\n    for (const { tickLabel, translationY } of tickData) {\n      if (!tickLabel)\n        continue;\n      const { width, height } = textMeasurer.measureLines(tickLabel);\n      const bbox = new BBox(labelX, translationY, width, height);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { range: range3, scale: scale2, visibleRange } = this;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        rawTicks = this.interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));\n          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        } else {\n          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = /* @__PURE__ */ new Map();\n    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    const filteredTicks = rawTicks.slice(start, end);\n    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);\n    for (let i = 0; i < filteredTicks.length; i++) {\n      const tick = filteredTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !this.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = this.formatTick(tick, fractionDigits, start + i);\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });\n      if (tickLabel === \"\" || tickLabel == null) {\n        continue;\n      }\n      labelCount++;\n    }\n    return { rawTicks, fractionDigits, ticks, labelCount };\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    const { scale: scale2 } = this;\n    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {\n      if (typeof tickCount === \"number\") {\n        scale2.tickCount = tickCount;\n        scale2.minTickCount = minTickCount ?? 0;\n        scale2.maxTickCount = maxTickCount ?? Infinity;\n      } else if (scale2 instanceof TimeScale) {\n        this.setTickInterval(tickCount);\n      }\n    }\n    return scale2.ticks?.() ?? [];\n  }\n  estimateTickCount({ minSpacing, maxSpacing }) {\n    if (!this.label.avoidCollisions) {\n      return {\n        minTickCount: ContinuousScale.defaultMaxTickCount,\n        maxTickCount: ContinuousScale.defaultMaxTickCount,\n        defaultTickCount: ContinuousScale.defaultMaxTickCount\n      };\n    }\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(\n      this.defaultTickMinSpacing,\n      rangeWithBleed / ContinuousScale.defaultMaxTickCount\n    );\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    const minRectDistance = 2;\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(\n      1,\n      Math.floor(rangeWithBleed / minSpacing),\n      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100\n    );\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return { minTickCount, maxTickCount, defaultTickCount };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        crossLine.label.parallel = crossLine.label.parallel ?? this.label.parallel;\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line) => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.stroke;\n      line.x1 = sideFlag * this.getTickSize();\n      line.x2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    return findRangeExtent(this.range);\n  }\n  /**\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\n   * the visible range is only a portion of the axis.\n   */\n  calculateRangeWithBleed() {\n    const visibleScale = 1 / findRangeExtent(this.visibleRange);\n    return round(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\n    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\n    this.setDomain(domains);\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      rotationCenterX: 0,\n      rotationCenterY: 0,\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;\n    const { rotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n    axisGroup.datum = this.getAxisTransform();\n    gridLineGroupSelection.each((line) => {\n      line.x1 = gridPadding;\n      line.x2 = -sideFlag * gridLength + gridPadding;\n    });\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error(\"AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.\");\n  }\n  updateSelections(lineData, data, params) {\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(\n      this.gridLength ? data : [],\n      (group) => group.append(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLineGroupSelection.update(\n      data,\n      (group) => group.appendChild(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLabelGroupSelection.update(\n      data.map((d) => this.getTickLabelProps(d, params)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n  }\n  updateAxisLine() {\n    const { line } = this;\n    const strokeWidth = line.enabled ? line.width : 0;\n    this.lineNode.setProperties({\n      stroke: line.stroke,\n      strokeWidth\n    });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: { style, width },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        fill: void 0,\n        stroke,\n        strokeWidth: width,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    const { label } = this;\n    if (!label.enabled) {\n      return;\n    }\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, [\n        \"fill\",\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStyle\",\n        \"fontWeight\",\n        \"text\",\n        \"textAlign\",\n        \"textBaseline\"\n      ]);\n    });\n  }\n  updateTitle(params) {\n    const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;\n    let spacing = 0;\n    if (title.enabled && params.anyTickVisible) {\n      const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n      spacing += tickWidth + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    this.setTitleProps(_titleCaption, { spacing });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, fractionDigits, index) {\n    return String(this.getFormatter(index, true)(datum, fractionDigits));\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(this.getFormatter()(datum));\n  }\n  getFormatter(index = 0, isTickLabel) {\n    const {\n      label,\n      labelFormatter,\n      datumFormatter,\n      moduleCtx: { callbackCache }\n    } = this;\n    if (label.formatter) {\n      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;\n    } else if (!isTickLabel && datumFormatter) {\n      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);\n    } else if (labelFormatter) {\n      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);\n    }\n    return (datum) => String(datum);\n  }\n  getBBox() {\n    return this.axisGroup.getBBox();\n  }\n  getRegionBBoxProvider() {\n    const { axisGroup } = this;\n    return {\n      id: this.id,\n      computeTransformedBBox() {\n        return axisGroup.computeTransformedBBox();\n      },\n      computeTransformedRegionBBox() {\n        return axisGroup.computeTransformedRegionBBox();\n      },\n      get visible() {\n        return axisGroup.visible;\n      }\n    };\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width, height) {\n    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  clipGrid(x, y, width, height) {\n    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  calculatePadding(min, max) {\n    const padding = Math.abs(this.reverse ? max : min) * 0.01;\n    return [padding, padding];\n  }\n  getTitleFormatterParams() {\n    const boundSeries = this.boundSeries.reduce((acc, next) => {\n      const keys = next.getKeys(this.direction);\n      const names = next.getNames(this.direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        acc.push({ key: keys[idx], name: names[idx] });\n      }\n      return acc;\n    }, []);\n    return {\n      direction: this.direction,\n      boundSeries,\n      defaultValue: this.title?.text\n    };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      id: this.id,\n      rect: this.getBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => {\n          if (keys.indexOf(key) < 0) {\n            keys.push(key);\n          }\n        });\n        return keys;\n      }, []),\n      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),\n      scaleBandwidth: () => scale2.bandwidth ?? 0,\n      scaleDomain: () => scale2.getDomain?.(),\n      scaleConvert: (val) => scale2.convert(val),\n      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),\n      scaleInvertNearest: (val) => scale2.invertNearest?.(val),\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  getScaleValueFormatter(format) {\n    const { scale: scale2 } = this;\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        return scale2.tickFormat({ specifier: format });\n      } catch (e) {\n        Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);\n      }\n    }\n    return this.getFormatter();\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = /* @__PURE__ */ new Set();\n    const removed = /* @__PURE__ */ new Set();\n    const tickMap = {};\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum?.tickId;\n      tickMap[tick ?? prev] = tickDatum;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return { changed: added.size > 0 || removed.size > 0, added, removed };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n_Axis.CrossLineConstructor = CartesianCrossLine;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  get direction() {\n    return [\"top\", \"bottom\"].includes(this.position) ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(primaryTickCount, animated) {\n    this.updateDirection();\n    return super.update(primaryTickCount, animated);\n  }\n  calculateLayout(primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(primaryTickCount);\n  }\n  createAxisContext() {\n    return {\n      ...super.createAxisContext(),\n      position: this.position\n    };\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar CategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new BandScale()) {\n    super(moduleCtx, scale2);\n    this._paddingOverrideEnabled = false;\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  set paddingInner(value) {\n    this._paddingOverrideEnabled = true;\n    this.scale.paddingInner = value;\n  }\n  get paddingInner() {\n    this._paddingOverrideEnabled = true;\n    return this.scale.paddingInner;\n  }\n  set paddingOuter(value) {\n    this.scale.paddingOuter = value;\n  }\n  get paddingOuter() {\n    return this.scale.paddingOuter;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    return { domain, clipped: false };\n  }\n  calculateDomain() {\n    if (!this._paddingOverrideEnabled) {\n      let paddingInner = Infinity;\n      let paddingOuter = -Infinity;\n      for (const s of this.boundSeries) {\n        const padding = s.getBandScalePadding?.();\n        if (padding == null)\n          continue;\n        paddingInner = Math.min(paddingInner, padding.inner);\n        paddingOuter = Math.max(paddingOuter, padding.outer);\n      }\n      this.scale.paddingInner = Number.isFinite(paddingInner) ? paddingInner : 0;\n      this.scale.paddingOuter = Number.isFinite(paddingOuter) ? paddingOuter : 0;\n    }\n    return super.calculateDomain();\n  }\n};\nCategoryAxis.className = \"CategoryAxis\";\nCategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], CategoryAxis.prototype, \"groupPaddingInner\", 2);\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar TreeNode = class {\n  // current number in sibling group (index)\n  constructor(label = \"\", parent, number2 = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number2;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n};\nfunction ticksToTree(ticks, pad2 = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad2) {\n    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach((tick) => {\n    if (pad2) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift(\"\");\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse();\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find((child) => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio2 = shift / subtrees;\n  wp.change -= ratio2;\n  wp.shift += shift;\n  wm.change += ratio2;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\nfunction apportion(v, defaultAncestor, distance3) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node, distance3) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach((child) => {\n      firstWalk(child, distance3);\n      defaultAncestor = apportion(child, defaultAncestor, distance3);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance3;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;\n  }\n}\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const { x, y } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\n}\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach((w) => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));\n    if (node.children.length) {\n      this.nonLeafNodes.push(node);\n    } else {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach((node) => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));\n    });\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach((node) => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar GroupedCategoryAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], GroupedCategoryAxisLabel.prototype, \"grid\", 2);\nvar GroupedCategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    const scale2 = new BandScale();\n    scale2.paddingOuter = 0.1;\n    scale2.paddingInner = scale2.paddingOuter * 2;\n    super(moduleCtx, scale2);\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    this.labelColor = \"rgba(87, 87, 87, 1)\";\n    this.includeInvisibleDomains = true;\n    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, Text);\n    this.lineNode.visible = false;\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    this.tickScale.range = scale2.range = [start, start + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    const s = this.scale;\n    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(\n        Math.abs(range3[1] - range3[0]),\n        layout.depth * lineHeight,\n        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,\n        -layout.depth * lineHeight,\n        range3[1] - range3[0] < 0\n      );\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineSelection.clear();\n    this.labelSelection.clear();\n  }\n  calculateDomain() {\n    const { direction } = this;\n    let isNumericX = null;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {\n      if (direction === \"y\" /* Y */ || isNumericX) {\n        return series.getDomain(direction);\n      }\n      if (isNumericX === null) {\n        const domain2 = series.getDomain(direction);\n        isNumericX = isNumber(domain2[0]);\n        return domain2;\n      }\n      return [];\n    });\n    this.setDomain(extent(flatDomains) ?? unique(flatDomains));\n    const { domain } = this.dataDomain;\n    this.tickTreeLayout = treeLayout(ticksToTree(domain));\n    this.tickScale.domain = domain.concat(\"\");\n    this.resizeTickTree();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n  }\n  updateTitleCaption() {\n    const { _titleCaption } = this;\n    _titleCaption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    const { tickLabelLayout } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout)\n      return;\n    const { separatorLayout } = this.computedLayout;\n    const { range: range3 } = this;\n    const epsilon2 = 1e-7;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = this.tick.enabled && datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;\n      line.stroke = this.tick.stroke;\n      line.fill = void 0;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout)\n      return;\n    const { axisLineLayout } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties({\n        ...datum,\n        stroke: this.line.stroke,\n        strokeWidth: this.line.width\n      });\n      line.x1 = datum.x;\n      line.x2 = datum.x;\n      line.y1 = datum.y1;\n      line.y2 = datum.y2;\n      line.strokeWidth = this.line.width;\n      line.stroke = this.line.stroke;\n    });\n  }\n  updateCategoryGridLines() {\n    const { gridLength, gridLine, label, range: range3, tickScale } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const { width, style } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = gridLine.enabled && y >= range3[0] && y <= range3[1];\n        const { stroke, lineDash } = style[index % styleCount];\n        line.stroke = stroke;\n        line.strokeWidth = width;\n        line.lineDash = lineDash;\n        line.fill = void 0;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale: scale2,\n      label,\n      label: { parallel },\n      moduleCtx: { callbackCache },\n      range: range3,\n      title,\n      title: { formatter = (p) => p.defaultValue } = {}\n    } = this;\n    const rangeStart = scale2.range[0];\n    const rangeEnd = scale2.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale2.domain.length || 0;\n    const keepEvery = Math.ceil(label.fontSize / bandwidth);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    const lineHeight = this.lineHeight;\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale2.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = (node) => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new Text();\n    const setLabelProps = (datum, index) => {\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: \"center\",\n        textBaseline: parallelFlipFlag === -1 ? \"bottom\" : \"hanging\",\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index === 0) {\n        const isCaptionEnabled = title?.enabled && labels.length > 0;\n        if (!isCaptionEnabled) {\n          return false;\n        }\n        const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n        tempText.setProperties({\n          fill: title.color,\n          fontFamily: title.fontFamily,\n          fontSize: title.fontSize,\n          fontStyle: title.fontStyle,\n          fontWeight: title.fontWeight,\n          text,\n          textBaseline: \"hanging\",\n          translationX: datum.screenY - label.fontSize * 0.25,\n          translationY: datum.screenX\n        });\n      } else if (index % keepEvery === 0) {\n        const isInRange = datum.screenX >= range3[0] && datum.screenX <= range3[1];\n        if (!isInRange) {\n          return false;\n        }\n        if (label.formatter) {\n          tempText.text = callbackCache.call(label.formatter, {\n            value: String(datum.label),\n            index\n          }) ?? String(datum.label);\n        } else {\n          tempText.text = String(datum.label);\n        }\n      } else {\n        return false;\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible)\n        return;\n      const bbox2 = tempText.computeTransformedBBox();\n      if (!bbox2)\n        return;\n      labelBBoxes.set(index, bbox2);\n      const isLeaf = !datum.children.length;\n      if (isLeaf && bbox2.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox2.width;\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      let visible = setLabelProps(datum, index);\n      const id = index;\n      tempText.x = labelX;\n      tempText.rotationCenterX = labelX;\n      const isLeaf = !datum.children.length;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n      } else {\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox2 = labelBBoxes.get(id);\n        if (bbox2 && bbox2.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(id);\n        } else if (isHorizontal) {\n          tempText.rotation = defaultRotation;\n        } else {\n          tempText.rotation = -Math.PI / 2;\n        }\n      }\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox2 = tempText.computeTransformedBBox();\n        if (bbox2) {\n          labelBBoxes.set(index, bbox2);\n        }\n        props = { ...copyLabelProps(tempText), visible };\n      } else {\n        labelBBoxes.delete(index);\n        props = { visible };\n      }\n      tickLabelLayout.push(props);\n    });\n    let minX = 0;\n    separatorData.forEach((d) => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon2 = 1e-7;\n    separatorData.forEach((datum) => {\n      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {\n        const { x1, x2, y } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({ x1, x2, y });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });\n    }\n    const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\n    const transformedBBox = this.getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = { axisLineLayout, separatorLayout, tickLabelLayout };\n    return { bbox, primaryTickCount: void 0 };\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], GroupedCategoryAxis.prototype, \"labelColor\", 2);\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.dependents = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n        }\n      } else {\n        this.modules.push(module);\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const { dependents } = this;\n    const yielded = /* @__PURE__ */ new Set();\n    let count = 0;\n    const maxCount = 3;\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    do {\n      for (const module of modulesByType) {\n        if (yielded.has(module.optionsKey) || dependents.has(module.optionsKey)) {\n          continue;\n        }\n        yield module;\n        yielded.add(module.optionsKey);\n        for (const [key, dependencies] of dependents.entries()) {\n          dependencies.delete(module.optionsKey);\n          if (dependencies.size === 0) {\n            dependents.delete(key);\n          }\n        }\n      }\n      count++;\n    } while (yielded.size < modulesByType.length && count < maxCount);\n    if (dependents.size > 0) {\n      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    for (const key of module.dependencies) {\n      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();\n      dependencies.add(module.optionsKey);\n      this.dependencies.set(key, dependencies);\n    }\n    this.dependents.set(module.optionsKey, new Set(module.dependencies));\n  }\n};\nvar moduleRegistry = new ModuleRegistry();\n\n// packages/ag-charts-community/src/util/async.ts\nfunction sleep(sleepTimeoutMs) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(void 0), sleepTimeoutMs);\n  });\n}\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => Logger.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(async () => void 0);\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error) {\n        Logger.error(\"mutex callback error\", error);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n  clear() {\n    this.top = this.right = this.bottom = this.left = 0;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"10.1.0\";\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      if (!(originator.mementoOriginatorKey in blob)) {\n        continue;\n      }\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      if (!originator.guardMemento(memento)) {\n        Logger.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, this.encodeTypes));\n    } catch (error) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    try {\n      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);\n    } catch (error) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: String(this[key]) };\n    }\n    return value;\n  }\n  decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {\n      return;\n    }\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/util/userAgent.ts\nfunction hasConstrainedCanvasMemory() {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const iPhoneOSMatch = navigator.userAgent.match(/\\(iPhone; CPU iPhone OS (\\d+_\\d+_\\d+) like Mac OS X\\)/);\n  if (iPhoneOSMatch == null) {\n    return false;\n  }\n  const [major, minor] = iPhoneOSMatch[1].split(\"_\").map(Number);\n  return major < 16 || major === 16 && minor < 6;\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar _HdpiCanvas = class _HdpiCanvas {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width, height, pixelRatio, canvasConstructor, willReadFrequently = false } = options;\n    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow(\"devicePixelRatio\");\n    this.element = canvasConstructor?.() ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width ?? this.width) + \"px\";\n    this.element.style.height = (height ?? this.height) + \"px\";\n    this.element.width = Math.round((width ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\", { willReadFrequently });\n    this.onEnabledChange();\n    this.resize(width ?? 0, height ?? 0);\n    _HdpiCanvas.debugContext(this.context);\n  }\n  static is(value) {\n    return value instanceof _HdpiCanvas;\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width, height) {\n    if (!(width > 0 && height > 0))\n      return;\n    const { element: element2, context, pixelRatio } = this;\n    element2.width = Math.round(width * pixelRatio);\n    element2.height = Math.round(height * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width + \"px\";\n    element2.style.height = height + \"px\";\n    this.width = width;\n    this.height = height;\n  }\n  snapshot() {\n  }\n  clear() {\n    this.context.save();\n    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  static debugContext(ctx) {\n    if (Debug.check(\"canvas\")) {\n      const save = ctx.save.bind(ctx);\n      const restore = ctx.restore.bind(ctx);\n      let depth = 0;\n      Object.assign(ctx, {\n        save() {\n          save();\n          depth++;\n        },\n        restore() {\n          if (depth === 0) {\n            throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n          }\n          restore();\n          depth--;\n        },\n        verifyDepthZero() {\n          if (depth !== 0) {\n            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n          }\n        }\n      });\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], _HdpiCanvas.prototype, \"enabled\", 2);\nvar HdpiCanvas = _HdpiCanvas;\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class _LayersManager {\n  constructor(canvas, markDirty) {\n    this.canvas = canvas;\n    this.markDirty = markDirty;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextZIndex = 0;\n    this.nextLayerId = 0;\n  }\n  static sortLayers(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],\n      ascendingStringNumberUndefined\n    );\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  forEach(callback2) {\n    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback2);\n  }\n  resize(width, height) {\n    this.canvas.resize(width, height);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width, height));\n  }\n  addLayer(opts) {\n    const { width, height, pixelRatio } = this.canvas;\n    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\n    const canvas = new HdpiCanvas({ width, height, pixelRatio });\n    const newLayer = {\n      id: this.nextLayerId++,\n      name,\n      canvas,\n      zIndex,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    };\n    if (zIndex >= this.nextZIndex) {\n      this.nextZIndex = zIndex + 1;\n    }\n    this.layersMap.set(canvas, newLayer);\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return newLayer.canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.markDirty();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layersMap.get(canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.markDirty();\n      this.debug(\"Scene.moveLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};\n  const end = performance.now();\n  const { start, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start, end)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null\n  ].filter(isString);\n  const measurer = new SimpleTextMeasurer((t) => ctx.measureText(t));\n  const statsSize = new Map(stats.map((t) => [t, measurer.measureLines(t)]));\n  const width = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height = accumulate(statsSize.values(), (s) => s.height);\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, 2 + seriesRect.x, y);\n  }\n  ctx.restore();\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = node.computeTransformedBBox();\n    if (!bbox) {\n      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nfunction buildTree(node) {\n  if (!Debug.check(true, \"scene\" /* SCENE */))\n    return {};\n  return {\n    node,\n    name: node.name ?? node.id,\n    dirty: RedrawType[node.dirty],\n    ...node.parent?.isVirtual ? {\n      virtualParentDirty: RedrawType[node.parent.dirty],\n      virtualParent: node.parent\n    } : {},\n    ...node.children.map((c) => buildTree(c)).reduce((result, childTree) => {\n      let { name: treeNodeName } = childTree;\n      const {\n        node: {\n          visible,\n          opacity,\n          zIndex,\n          zIndexSubOrder,\n          translationX,\n          translationY,\n          rotation,\n          scalingX,\n          scalingY\n        },\n        node: childNode,\n        virtualParent\n      } = childTree;\n      if (!visible || opacity <= 0) {\n        treeNodeName = `(${treeNodeName})`;\n      }\n      if (childNode instanceof Group && childNode.isLayer()) {\n        treeNodeName = `*${treeNodeName}*`;\n      }\n      const key = [\n        `${treeNodeName ?? \"<unknown>\"}`,\n        `z: ${zIndex}`,\n        zIndexSubOrder && `zo: ${zIndexSubOrder.map((v) => typeof v === \"function\" ? `${v()} (fn)` : v).join(\" / \")}`,\n        virtualParent && `(virtual parent)`,\n        translationX && `x: ${translationX}`,\n        translationY && `y: ${translationY}`,\n        rotation && `r: ${rotation}`,\n        scalingX !== 1 && `sx: ${scalingX}`,\n        scalingY !== 1 && `sy: ${scalingY}`\n      ].filter((v) => !!v).join(\" \");\n      let selectedKey = key;\n      let index = 1;\n      while (result[selectedKey] != null && index < 100) {\n        selectedKey = `${key} (${index++})`;\n      }\n      result[selectedKey] = childTree;\n      return result;\n    }, {})\n  };\n}\nfunction buildDirtyTree(node) {\n  if (node.dirty === 0 /* NONE */) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = node.children.map((c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: RedrawType[node.dirty],\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start, end) {\n  const duration = end != null ? end - start : start;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor({ width, height, pixelRatio, domManager }) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.isDirty = false;\n    this.domManager = domManager;\n    const canvasOpts = {\n      width,\n      height,\n      pixelRatio\n    };\n    if (domManager) {\n      canvasOpts.canvasConstructor = () => domManager.addChild(\"canvas\", \"scene-canvas\");\n    }\n    this.canvas = new HdpiCanvas(canvasOpts);\n    this.layersManager = new LayersManager(this.canvas, () => {\n      this.isDirty = true;\n    });\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  setContainer(value) {\n    const isElement = (v) => {\n      return typeof v.tagName !== \"undefined\";\n    };\n    if (isElement(value)) {\n      const { element: element2 } = this.canvas;\n      element2.parentElement?.removeChild(element2);\n      value.appendChild(element2);\n    } else {\n      this.domManager = value;\n      this.domManager.addChild(\"canvas\", \"scene-canvas\", this.canvas.element);\n    }\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  attachNode(node, rootGroupName) {\n    if (!rootGroupName) {\n      this.root?.appendChild(node);\n      return () => this.removeChild(node);\n    }\n    const parentGroup = this.root?.children.find((g) => g instanceof Group && g.name === rootGroupName);\n    if (!parentGroup)\n      throw new Error(\"AG Charts - Unrecognized root group name: \" + rootGroupName);\n    parentGroup.appendChild(node);\n    return () => parentGroup.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width > 0 && height > 0 && (width !== this.width || height !== this.height)) {\n      this.pendingSize = [width, height];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  async render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};\n    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = void 0;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          redrawType: RedrawType[root.dirty],\n          tree: buildTree(root)\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      devicePixelRatio: this.canvas.pixelRatio ?? 1,\n      forceRender: true,\n      resized: Boolean(pendingSize),\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\n    }\n    let canvasCleared = false;\n    if (!root || root.dirty >= 1 /* TRIVIAL */) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      this.debug(\"Scene.render() - before\", {\n        redrawType: RedrawType[root.dirty],\n        canvasCleared,\n        tree: buildTree(root)\n      });\n      if (root.visible) {\n        root.preRender();\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    if (this.layersManager.size && canvasCleared) {\n      const layerRenderStart = performance.now();\n      ctx.save();\n      ctx.resetTransform();\n      this.layersManager.forEach((layer) => {\n        if (layer.canvas.enabled && layer.getVisibility()) {\n          ctx.globalAlpha = layer.getComputedOpacity();\n          layer.canvas.drawImage(ctx);\n        }\n      });\n      ctx.restore();\n      debugSplitTimes[\"\\u26D9\"] = performance.now() - layerRenderStart;\n    }\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        redrawType: RedrawType[root.dirty],\n        tree: buildTree(root),\n        canvasCleared\n      });\n    }\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      return this.invoke(fn, params, paramCache);\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return this.invoke(fn, params, paramCache, serialisedParams);\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invoke(fn, params, paramCache, serialisedParams) {\n    try {\n      const result = fn(...params);\n      if (paramCache && serialisedParams != null) {\n        paramCache.set(serialisedParams, result);\n      }\n      return result;\n    } catch (e) {\n      Logger.warnOnce(`User callback errored, ignoring`, e);\n      return;\n    }\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    const annotations2 = this.cleanData(memento).map((annotation) => {\n      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);\n      return mergeDefaults(annotation, annotationTheme);\n    });\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: annotations2\n    });\n  }\n  updateData(annotations2) {\n    this.annotations = this.cleanData(annotations2 ?? []);\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n  cleanData(annotations2) {\n    for (const annotation of annotations2) {\n      if (\"textAlign\" in annotation)\n        delete annotation.textAlign;\n    }\n    return annotations2;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Group({ name: \"Axes-Grids\", layer: true, zIndex: 1 /* AXIS_GRID_ZINDEX */ });\n    this.axisGroup = new Group({ name: \"Axes\", layer: true, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return [...this.axes.get(direction) ?? []];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle((params) => this.fetch(params), requestThrottle, {\n      leading: false,\n      trailing: true\n    });\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);\n    } catch (error) {\n      this.debug(`DataService - request failed | ${id}`);\n      Logger.errorOnce(`DataService - request failed | [${error}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/styles.css\nvar styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:focus,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:focus,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block}.ag-charts-canvas-proxy{position:absolute;top:0;left:0;opacity:0;pointer-events:none}.ag-charts-tab-guard{width:0;height:0;opacity:0}.ag-charts-canvas-overlay{pointer-events:none;position:absolute;inset:0}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-active-color: var(--ag-active-color, #2196f3);--ag-charts-background-color: var(--ag-background-color, #fff);--ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);--ag-charts-border-color: var(--ag-border-color, #dddddd);--ag-charts-font-family: \"Verdana\", sans-serif;--ag-charts-font-size: var(--ag-font-size, 14px);--ag-charts-size: var(--ag-grid-size, 8px);--ag-charts-border: var(--ag-charts-border-color) var(--ag-borders, solid 1px);--ag-charts-border-critical: var(--ag-borders-critical, solid 1px);--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1;--ag-charts-align: center;--ag-charts-justify: center;--ag-charts-axis-label-background-color: #474747;--ag-charts-axis-label-color: #ffffff;--ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color: var( --ag-header-background-color, color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%) );--ag-charts-toolbar-size: 34px;--ag-charts-toolbar-size-small: 24px;--ag-charts-toolbar-border: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12% );--ag-charts-toolbar-focus-color: var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color: var(--ag-charts-toolbar-hover-color);--ag-charts-toolbar-active-color: var(--ag-charts-active-color);--ag-charts-toolbar-disabled-foreground-color: var( --ag-disabled-foreground-color, color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%) );--ag-charts-toolbar-disabled-background-color: color-mix( in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6% );--ag-charts-toolbar-gap: var(--ag-charts-size);--ag-charts-toolbar-font-size: 13px;--ag-charts-toolbar-font-size-small: 12px;--ag-charts-toolbar-button-padding: 6px;--ag-charts-toolbar-button-padding-small: 1px;--ag-charts-popover-background-color: var(--ag-charts-toolbar-background-color);--ag-charts-popover-foreground-color: var(--ag-charts-toolbar-foreground-color);--ag-charts-popover-border: var(--ag-charts-toolbar-border);--ag-charts-popover-active-color: var(--ag-charts-toolbar-active-color);--ag-charts-popover-hover-color: var(--ag-charts-toolbar-hover-color);--ag-charts-popover-active-background-color: var(--ag-charts-toolbar-active-background-color);--ag-charts-popover-font-size-small: var(--ag-charts-toolbar-font-size-small);--ag-charts-button-radius: var(--ag-border-radius, 4px);--ag-charts-focus-border-color: var(--ag-input-focus-border-color, var(--ag-charts-active-color));--ag-charts-focus-border: solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-icon-font-family: \"agChartsDefault\";--ag-charts-icon-font-weight: normal;--ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);--ag-charts-icon-size: 20px;--ag-charts-text-annotations-placeholder: #888888}.ag-charts-theme-default-dark{--ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));--ag-charts-foreground-color: var(--ag-foreground-color, #fff);--ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, .16));--ag-charts-hover-color: var( --ag-row-hover-color, color-mix(in srgb, transparent, var(--ag-charts-active-color) 20%) );--ag-charts-axis-label-background-color: #9caebb;--ag-charts-axis-label-color: #000000;--ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18% );--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-text-annotations-placeholder: #aaaaaa}.ag-charts-icon{display:block;width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size);speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt,.ag-charts-icon-zoom-in-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt,.ag-charts-icon-zoom-out-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-focus.ag-charts-focus__indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus.ag-charts-focus__indicator>div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus.ag-charts-focus__indicator>svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-focus--hidden{visibility:hidden}.ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity .2s ease-in-out,transform .2s ease-in-out}.ag-charts-toolbar--hidden,.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity .4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size: var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size: var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding: var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px;overflow:hidden}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,.ag-charts-toolbar--left .ag-charts-toolbar__align--end,.ag-charts-toolbar--right .ag-charts-toolbar__align--center,.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform .4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{--transition: background-color .25s ease-in-out, border-color .25s ease-in-out, color .25s ease-in-out;align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font:var(--ag-charts-toolbar-font-size) var(--ag-charts-font-family);justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;position:relative;transition:var(--transition);white-space:nowrap}.ag-charts-toolbar__button[data-toolbar-group=ranges]{padding:var(--ag-charts-toolbar-button-padding) calc(var(--ag-charts-toolbar-button-padding) * 1.5)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom,.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{.ag-charts-toolbar__button:nth-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:nth-last-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-right-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar--left,.ag-charts-toolbar--right{.ag-charts-toolbar__button{border-radius:0;margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button:nth-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:nth-last-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar__button--hidden-value,.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover{background:var(--ag-charts-toolbar-hover-color);z-index:1}.ag-charts-toolbar__button:focus-visible{border-color:var(--ag-charts-toolbar-focus-color);box-shadow:var(--ag-charts-focus-border-shadow);z-index:3}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);border-color:var(--ag-charts-toolbar-active-color);color:var(--ag-charts-toolbar-active-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled=true]){cursor:pointer}.ag-charts-toolbar__button--fill-visible:after{content:\"\";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--fill)}.ag-charts-toolbar__button--fill-visible[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#fff}.ag-chart-overlay--loading{color:#8c8c8c}.ag-chart-overlay__loading-background{background:#fff;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}.ag-chart-tooltip{transition:transform .1s ease;width:max-content;z-index:99999;font:12px Verdana,sans-serif;color:#464646;box-shadow:0 4px 8px #00000014}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:#fff;background-color:#888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,.15);text-overflow:inherit}.ag-chart-tooltip-arrow:before{content:\"\";position:absolute;top:100%;left:50%;transform:translate(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow:after{content:\"\";position:absolute;top:calc(100% - 1px);left:50%;transform:translate(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\\n';\n\n// packages/ag-charts-community/src/util/guardedElement.ts\nvar GuardedElement = class {\n  constructor(element2, topTabGuard, bottomTabGuard) {\n    this.element = element2;\n    this.topTabGuard = topTabGuard;\n    this.bottomTabGuard = bottomTabGuard;\n    this.destroyFns = [];\n    this.guardTabIndex = 0;\n    this.element.tabIndex = -1;\n    this.initEventListener(this.element, \"blur\", () => this.onBlur());\n    this.initEventListener(this.element, \"focus\", () => this.onFocus());\n    this.initEventListener(this.topTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.topTabGuard));\n    this.initEventListener(this.bottomTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.bottomTabGuard));\n  }\n  set tabIndex(index) {\n    if (index >= 0) {\n      this.guardTabIndex = index;\n    }\n    if (index > 0) {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.style.display = \"none\";\n    } else {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.tabIndex = index;\n    }\n  }\n  destroy() {\n    for (const fn of this.destroyFns)\n      fn();\n    this.destroyFns.length = 0;\n  }\n  initEventListener(elem, type, handler) {\n    elem.addEventListener(type, handler);\n    this.destroyFns.push(() => elem.removeEventListener(type, handler));\n  }\n  onBlur() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = this.guardTabIndex;\n      this.guardTarget = void 0;\n      this.guessedDelta = void 0;\n    }\n  }\n  onFocus() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = -1;\n    }\n  }\n  onTabStart(event, target) {\n    if (target.tabIndex > 0) {\n      this.guessedDelta = 0;\n      if (event.relatedTarget != null && \"tabIndex\" in event.relatedTarget) {\n        const prevTabIndex = Number(event.relatedTarget[\"tabIndex\"]);\n        if (!isNaN(prevTabIndex) && prevTabIndex > 0) {\n          this.guessedDelta = prevTabIndex < target.tabIndex ? 1 : -1;\n        }\n      }\n    }\n    this.guardTarget = target;\n    this.element.focus();\n  }\n  getBrowserFocusDelta() {\n    const { guessedDelta, guardTarget, topTabGuard, bottomTabGuard: botTabGuard } = this;\n    if (guessedDelta !== void 0)\n      return guessedDelta;\n    if (guardTarget === topTabGuard)\n      return 1;\n    if (guardTarget === botTabGuard)\n      return -1;\n    return 0;\n  }\n};\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n    };\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const {\n        target,\n        contentRect: { width, height }\n      } of entries) {\n        const entry = this.elements.get(target);\n        this.checkSize(entry, target, width, height);\n      }\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (!this.documentReady) {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n  checkSize(entry, element2, width, height) {\n    if (!entry)\n      return;\n    if (width !== entry.size?.width || height !== entry.size?.height) {\n      entry.size = { width, height };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n    this.checkSize(entry, element2, element2.offsetWidth, element2.offsetHeight);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/domLayout.html\nvar domLayout_default = '<div role=\"presentation\" class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div role=\"presentation\" class=\"ag-charts-canvas-center\"><div role=\"figure\" class=\"ag-charts-canvas-container\"><div role=\"presentation\" class=\"ag-charts-tab-guard\"></div><div role=\"presentation\" class=\"ag-charts-canvas\"></div><div role=\"presentation\" class=\"ag-charts-canvas-proxy\"></div><div role=\"presentation\" class=\"ag-charts-tab-guard\"></div><div role=\"presentation\" class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/chart/dom/domManager.ts\nvar CANVAS_CENTER_CLASS = \"canvas-center\";\nvar DOM_ELEMENT_CLASSES = [\"styles\", CANVAS_CENTER_CLASS, \"canvas\", \"canvas-proxy\", \"canvas-overlay\"];\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\", eventTypes: [\"focus\", \"blur\"] }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [CANVAS_CENTER_CLASS, { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar NULL_DOMRECT = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  toJSON() {\n    return NULL_DOMRECT;\n  }\n};\nvar DOMManager = class extends BaseManager {\n  constructor(container) {\n    super();\n    this.styles = {};\n    this.container = void 0;\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.addStyles(\"ag-charts-community\", styles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.guardedElement?.destroy();\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[CANVAS_CENTER_CLASS].element;\n    centerStyle.width = `${this.containerSize?.width ?? 0}px`;\n    centerStyle.height = `${this.containerSize?.height ?? 0}px`;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    const isShadowDom = this.getDocumentRoot(newContainer) != null;\n    if (!isShadowDom) {\n      for (const id of this.rootElements[\"styles\"].children.keys()) {\n        this.removeChild(\"styles\", id);\n      }\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.container = newContainer;\n    for (const [id, styles] of Object.entries(this.styles)) {\n      this.addStyles(id, styles);\n    }\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  createTabGuards() {\n    const canvasElement = this.rootElements[\"canvas\"].element.querySelector(\"canvas\");\n    const tabGuards = this.element.querySelectorAll(\".ag-charts-tab-guard\");\n    if (canvasElement == null || tabGuards[0] == null || tabGuards[1] == null) {\n      throw new Error(\"AG Charts - error initialising canvas tab guards\");\n    }\n    return new GuardedElement(canvasElement, tabGuards[0], tabGuards[1]);\n  }\n  setTabIndex(tabIndex) {\n    this.guardedElement ?? (this.guardedElement = this.createTabGuards());\n    this.guardedElement.tabIndex = tabIndex;\n  }\n  getBrowserFocusDelta() {\n    return this.guardedElement?.getBrowserFocusDelta() ?? 0;\n  }\n  addEventListenerOnElement(elementType, type, listener, options) {\n    const { element: element2 } = this.rootElements[elementType];\n    element2.addEventListener(type, listener, options);\n    return () => {\n      element2.removeEventListener(type, listener, options);\n    };\n  }\n  addEventListener(type, listener, options) {\n    this.element.addEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners.push([type, listener, options]);\n      els.children.forEach((el) => {\n        el.addEventListener(type, listener);\n      });\n    });\n  }\n  removeEventListener(type, listener, options) {\n    this.element.removeEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners = els.listeners.filter(([t, l]) => t !== type && l !== listener);\n      els.children.forEach((el) => {\n        el.removeEventListener(type, listener, options);\n      });\n    });\n  }\n  /** Get the main chart area client bound rect. */\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  /**\n   * Get the client bounding rect for overlay elements that might float outside the bounds of the\n   * main chart area.\n   */\n  getOverlayClientRect() {\n    const window2 = getWindow();\n    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);\n    const container = this.getRawOverlayClientRect();\n    const containerBBox = BBox.fromDOMRect(container ?? this.getBoundingClientRect());\n    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;\n  }\n  getRawOverlayClientRect() {\n    let element2 = this.element;\n    while (element2 != null) {\n      const styleMap = element2.computedStyleMap?.();\n      const overflowX = styleMap?.get(\"overflow-x\")?.toString();\n      const overflowY = styleMap?.get(\"overflow-y\")?.toString();\n      if (overflowX != null && overflowX !== \"visible\" || overflowY && overflowY !== \"visible\") {\n        return element2.getBoundingClientRect();\n      }\n      element2 = element2.parentElement;\n    }\n    const docRoot = this.getDocumentRoot();\n    if (docRoot) {\n      return docRoot.getBoundingClientRect();\n    }\n  }\n  getDocumentRoot(current = this.container) {\n    const docRoot = current?.ownerDocument?.body ?? getDocument(\"body\");\n    while (current != null) {\n      if (current === docRoot) {\n        return void 0;\n      }\n      if (current.parentNode instanceof DocumentFragment) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return void 0;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  calculateCanvasPosition(el) {\n    let x = 0;\n    let y = 0;\n    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect(\"canvas\") ?? {};\n    const elRect = el.getBoundingClientRect();\n    x = elRect.x - cx;\n    y = elRect.y - cy;\n    return { x, y };\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && el.contains(search);\n  }\n  isEventOverElement(event) {\n    const element2 = event.target;\n    return element2 != null && this.element.contains(element2);\n  }\n  addStyles(id, styles) {\n    this.styles[id] = styles;\n    if (this.container == null)\n      return;\n    const dataAttribute = \"data-ag-charts\";\n    const documentRoot = this.getDocumentRoot();\n    let styleElement;\n    if (documentRoot != null) {\n      styleElement = this.addChild(\"styles\", id);\n    } else {\n      const head = getDocument(\"head\");\n      for (const child of head.children) {\n        if (child.getAttribute(dataAttribute) === id)\n          return;\n      }\n      styleElement = createElement(\"style\");\n      head.appendChild(styleElement);\n    }\n    if (styleElement.getAttribute(dataAttribute) === id) {\n      return;\n    }\n    styleElement.setAttribute(dataAttribute, id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(style) {\n    this.element.style.cursor = style;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    const existing = children.get(id);\n    if (existing != null)\n      return existing;\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    element2?.appendChild(newChild);\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n  getIconClassNames(icon) {\n    return `ag-charts-icon ag-charts-icon-${icon}`;\n  }\n};\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bzier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  }\n  roundRect(x, y, width, height, radii) {\n    radii = Math.min(radii, width / 2, height / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width - radii, y);\n    this.arc(x + width - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width, y + radii);\n    this.lineTo(x + width, y + height - radii);\n    this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width - radii, y + height);\n    this.lineTo(x + radii, y + height);\n    this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */:\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          Logger.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  getPoints() {\n    const { commands, params } = this;\n    const coords = [];\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n        case 1 /* Line */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 3 /* Curve */:\n          pi += 4;\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 2 /* Arc */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          pi += 4;\n          break;\n        case 4 /* ClosePath */:\n          break;\n      }\n    }\n    return coords;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  computeSVGDataPath(ox, oy) {\n    const buffer = [];\n    const { commands, params } = this;\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          buffer.push(\"M\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 1 /* Line */:\n          buffer.push(\"L\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 3 /* Curve */:\n          buffer.push(\n            \"C\",\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++]\n          );\n          break;\n        case 2 /* Arc */:\n          const [cx, cy, r, a0, a1, ccw] = [\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++]\n          ];\n          const x0 = ox + cx + Math.cos(a0) * r;\n          const y0 = oy + cy + Math.sin(a0) * r;\n          const x1 = ox + cx + Math.cos(a1) * r;\n          const y1 = oy + cy + Math.sin(a1) * r;\n          const largeArcFlag = angleDiff(a0, a1, !!ccw) > Math.PI ? 1 : 0;\n          const sweepFlag = (ccw + 1) % 2;\n          const move = buffer.length === 0 ? \"M\" : \"L\";\n          buffer.push(move, x0, y0, \"A\", r, r, 0, largeArcFlag, sweepFlag, x1, y1);\n          break;\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(this, 3 /* MAJOR */);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n  }\n  distanceSquared(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.distanceSquaredTransformedPoint(point.x, point.y);\n  }\n  computeSVGDataPath() {\n    const { x, y } = this.inverseTransformPoint(0, 0);\n    if (this.dirtyPath) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    return this.path.computeSVGDataPath(x, y);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    if (!isNaN(this._clipX) && !isNaN(this._clipY) && this.clipMode != null) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      if (this.clipMode === \"normal\") {\n        ctx.clip(this._clipPath?.getPath2D());\n      }\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      if (this.clipMode === \"punch-out\") {\n        ctx.clip(this._clipPath?.getPath2D());\n        const { x = -1e4, y = -1e4, width = 2e4, height = 2e4 } = this.getBBox() ?? {};\n        ctx.clearRect(x, y, width, height);\n      }\n      ctx.restore();\n    } else {\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipMode\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/chart/dom/focusStyles.ts\nvar focusStyles_exports = {};\n__export(focusStyles_exports, {\n  block: () => block,\n  elements: () => elements,\n  modifiers: () => modifiers\n});\nvar block = \"ag-charts-focus\";\nvar elements = { indicator: \"ag-charts-focus__indicator\", svg: \"ag-charts-focus__svg\" };\nvar modifiers = { hidden: \"ag-charts-focus--hidden\" };\n\n// packages/ag-charts-community/src/chart/dom/focusIndicator.ts\nvar FocusIndicator = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    const { block: block3, elements: elements3, modifiers: modifiers3 } = focusStyles_exports;\n    this.div = getDocument().createElement(\"div\");\n    this.svg = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.path = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    this.svg.append(this.path);\n    this.element = domManager.addChild(\"canvas-overlay\", block3);\n    this.element.classList.add(block3, elements3.indicator, modifiers3.hidden);\n    this.element.ariaHidden = \"true\";\n    this.element.append(this.svg);\n  }\n  destroy() {\n    this.domManager.removeStyles(block);\n    this.domManager.removeChild(\"canvas-overlay\", block);\n  }\n  updateBounds(bounds) {\n    if (bounds === void 0) {\n      this.element.classList.add(modifiers.hidden);\n    } else if (bounds instanceof Path) {\n      this.path.setAttribute(\"d\", bounds.computeSVGDataPath());\n      this.show(this.svg);\n    } else {\n      setElementBBox(this.div, bounds);\n      this.show(this.div);\n    }\n  }\n  show(child) {\n    this.element.classList.remove(modifiers.hidden);\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/boundedText.ts\nvar BoundedText = class {\n  set textContent(text) {\n    this.textElement.textContent = text;\n    const bboxCalculator = this.textElement;\n    const bbox = bboxCalculator.getBBox?.();\n    if (bbox) {\n      this.svgElement.setAttribute(\"viewBox\", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);\n    }\n  }\n  get textContent() {\n    return this.textElement.textContent;\n  }\n  constructor() {\n    this.textElement = createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    this.textElement.role = \"presentation\";\n    this.svgElement = createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.svgElement.appendChild(this.textElement);\n    this.svgElement.style.width = \"100%\";\n    this.svgElement.style.opacity = \"0\";\n    this.svgElement.role = \"presentation\";\n    this.boundedContainer = createElement(\"div\");\n    this.boundedContainer.appendChild(this.svgElement);\n    this.boundedContainer.role = \"presentation\";\n  }\n  remove() {\n    this.boundedContainer.remove();\n  }\n  getContainer() {\n    return this.boundedContainer;\n  }\n  updateBounds(bounds) {\n    setElementBBox(this.boundedContainer, bounds);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateResult(type) {\n  if (\"button\" === type) {\n    return createElement(\"button\");\n  } else if (\"slider\" === type) {\n    return createElement(\"input\");\n  } else if (\"toolbar\" === type || \"group\" === type) {\n    return createElement(\"div\");\n  } else if (\"text\" === type) {\n    return new BoundedText();\n  } else {\n    throw Error(\"AG Charts - error allocating meta\");\n  }\n}\nfunction allocateMeta(params) {\n  const meta = { params, result: void 0 };\n  meta.result = allocateResult(meta.params.type);\n  return meta;\n}\nvar ProxyInteractionService = class {\n  constructor(updateService, localeManager, domManager, focusIndicator) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.focusIndicator = focusIndicator;\n    // This debug option make the proxies button partially transparent instead of fully transparent.\n    // To enabled this option, set window.agChartsDebug = ['showDOMProxies'].\n    this.debugShowDOMProxies = Debug.check(\"showDOMProxies\");\n    this.destroyFns = [];\n    this.destroyFns.push(updateService.addListener(\"update-complete\", () => this.update()));\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  update() {\n    if (this.focusable) {\n      this.focusIndicator.updateBounds(this.focusable.computeTransformedBBox());\n    }\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result: div } = meta;\n    this.domManager.addChild(\"canvas-overlay\", params.id, div);\n    div.classList.add(...params.classList);\n    div.style.pointerEvents = \"none\";\n    div.role = params.type;\n    div.ariaOrientation = params.ariaOrientation;\n    if (typeof params.ariaHidden === \"boolean\") {\n      div.ariaHidden = params.ariaHidden.toString();\n    }\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return div;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result: button } = meta;\n      this.initInteract(params, button);\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result: slider } = meta;\n      this.initInteract(params, slider);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      slider.ariaOrientation = params.ariaOrientation;\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n    }\n    if (checkType(\"text\", meta)) {\n      const { params, result: text } = meta;\n      this.initElement(params, text.getContainer());\n    }\n    return meta.result;\n  }\n  initElement(params, element2) {\n    const { id, parent } = params;\n    element2.id = id;\n    element2.style.pointerEvents = \"none\";\n    element2.style.opacity = this.debugShowDOMProxies ? \"0.25\" : \"0\";\n    element2.style.position = \"absolute\";\n    element2.style.overflow = \"hidden\";\n    if (typeof parent === \"string\") {\n      this.domManager.addChild(parent, id, element2);\n    } else {\n      parent.appendChild(element2);\n    }\n  }\n  initInteract(params, element2) {\n    const { focusable, onclick, onchange, onfocus, onblur, tabIndex } = params;\n    this.initElement(params, element2);\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    element2.addEventListener(\"focus\", (_event) => {\n      this.focusable = focusable;\n      element2.style.setProperty(\"pointerEvents\", null);\n      this.focusIndicator.updateBounds(focusable.computeTransformedBBox());\n    });\n    element2.addEventListener(\"blur\", (_event) => {\n      this.focusable = void 0;\n      element2.style.pointerEvents = \"none\";\n      this.focusIndicator.updateBounds(void 0);\n    });\n    if (onclick) {\n      element2.addEventListener(\"click\", onclick);\n    }\n    if (onfocus) {\n      element2.addEventListener(\"focus\", onfocus);\n    }\n    if (onblur) {\n      element2.addEventListener(\"blur\", onblur);\n    }\n    if (onchange) {\n      element2.addEventListener(\"change\", onchange);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      Logger.warnOnce(\n        \"Animation batch exceeded max animation time, skipping.\",\n        new Map(this.controllers.entries())\n      );\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  pause() {\n    for (const controller of this.controllers.values()) {\n      controller.pause();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error) {\n        Logger.error(\"Error during animation stop\", error);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts\nfunction buildPreventable(obj) {\n  const self = {\n    ...obj,\n    preventDefault() {\n      self.sourceEvent?.preventDefault();\n    }\n  };\n  return self;\n}\nfunction dispatchTypedEvent(listeners, event) {\n  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));\n}\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar POINTER_INTERACTION_TYPES = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"hover\",\n  \"drag-start\",\n  \"drag\",\n  \"drag-end\",\n  \"leave\",\n  \"enter\",\n  \"page-left\",\n  \"wheel\"\n];\nvar FOCUS_INTERACTION_TYPES = [\"blur\", \"focus\"];\nvar KEY_INTERACTION_TYPES = [\"keydown\", \"keyup\"];\nvar SHADOW_DOM_HANDLERS = [\"mousemove\", \"mouseup\"];\nvar WINDOW_EVENT_HANDLERS = [\"pagehide\", \"mousemove\", \"mouseup\"];\nvar EVENT_HANDLERS = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"mousedown\",\n  \"mouseleave\",\n  \"mouseenter\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"wheel\",\n  \"blur\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\"\n];\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 16] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 8] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 4] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 2] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 1] = \"Animation\";\n  InteractionState2[InteractionState2[\"All\"] = 31] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar PointerCapture = /* @__PURE__ */ ((PointerCapture2) => {\n  PointerCapture2[\"Retain\"] = \"retain\";\n  PointerCapture2[\"Exclusive\"] = \"exclusive\";\n  return PointerCapture2;\n})(PointerCapture || {});\nvar pointerCaptures = new Set(Object.values(PointerCapture));\nfunction isPointerEvent(type) {\n  return POINTER_INTERACTION_TYPES.includes(type);\n}\nfunction isFocusEvent(type) {\n  return FOCUS_INTERACTION_TYPES.includes(type);\n}\nfunction isKeyEvent(type) {\n  return KEY_INTERACTION_TYPES.includes(type);\n}\nvar _InteractionManager = class _InteractionManager extends BaseManager {\n  constructor(keyboardOptions, domManager) {\n    super();\n    this.keyboardOptions = keyboardOptions;\n    this.domManager = domManager;\n    this.debug = Debug.create(true, \"interaction\");\n    this.eventHandler = (event) => this.processEvent(event);\n    this.overlayEventHandler = (event) => this.processCanvasOverlayEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.pointerCaptureCanvasElement = void 0;\n    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: \"mousedown\" }];\n    this.dblclickHistory = [\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mouseup\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" }\n    ];\n    this.stateQueue = 16 /* Default */ | 1 /* Animation */;\n    this.rootElement = this.domManager.getDocumentRoot();\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith(\"touch\") || type === \"wheel\") {\n        this.domManager.addEventListener(type, this.eventHandler, { passive: false });\n      } else {\n        this.domManager.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().addEventListener(type, this.eventHandler);\n    }\n    this.destroyFns.push(\n      this.domManager.addEventListenerOnElement(\"canvas-overlay\", \"mouseover\", this.overlayEventHandler),\n      this.domManager.addEventListenerOnElement(\"canvas-overlay\", \"mouseout\", this.overlayEventHandler)\n    );\n    this.containerChanged(true);\n    this.domManager.addListener(\"container-changed\", () => this.containerChanged());\n  }\n  containerChanged(force = false) {\n    const newRoot = this.domManager.getDocumentRoot();\n    if (!force && newRoot === this.rootElement)\n      return;\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    this.rootElement = newRoot;\n    this.debug(\"[InteractionManager] Switching rootElement to:\", this.rootElement);\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.addEventListener(type, this.eventHandler);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().removeEventListener(type, this.eventHandler);\n    }\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.domManager.removeEventListener(type, this.eventHandler);\n    }\n    this.domManager.removeStyles(\"interactionManager\");\n  }\n  // Wrapper to only broadcast events when the InteractionManager is a given state.\n  addListener(type, handler, triggeringStates = 16 /* Default */) {\n    return super.addListener(type, (e) => {\n      const currentState = this.getState();\n      if (currentState & triggeringStates) {\n        handler(e);\n      }\n    });\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  getState() {\n    return this.stateQueue & -this.stateQueue;\n  }\n  processCanvasOverlayEvent(event) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    let target = event.target;\n    let pointerCapture = null;\n    while (target != null) {\n      pointerCapture = target.getAttribute(\"data-pointer-capture\");\n      if (pointerCapture == null) {\n        target = target.parentElement;\n      } else {\n        break;\n      }\n    }\n    if (target == null || pointerCapture == null || !pointerCaptures.has(pointerCapture))\n      return;\n    const isOverCanvasOverlay = event.type === \"mouseover\";\n    const pointerCaptureCanvasElement = isOverCanvasOverlay ? target : void 0;\n    if (this.pointerCaptureCanvasElement === pointerCaptureCanvasElement)\n      return;\n    this.pointerCaptureCanvasElement = pointerCaptureCanvasElement;\n    if (pointerCapture === \"exclusive\" /* Exclusive */) {\n      dispatchTypedEvent(\n        this.listeners,\n        this.buildPointerEvent({ type: isOverCanvasOverlay ? \"leave\" : \"enter\", event, ...coords })\n      );\n    }\n  }\n  processEvent(event) {\n    const type = this.decideInteractionEventTypes(event);\n    const target = event.target;\n    if (event.type === \"click\" && target?.ariaDisabled === \"true\") {\n      event.preventDefault();\n      return;\n    }\n    if (type != null) {\n      this.dispatchEvent(event, type).catch((e) => Logger.errorOnce(e));\n    }\n  }\n  async dispatchEvent(event, type) {\n    if (isPointerEvent(type)) {\n      this.dispatchPointerEvent(event, type);\n      return;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    if (isFocusEvent(type)) {\n      const sourceEvent = event;\n      dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    } else if (isKeyEvent(type)) {\n      const sourceEvent = event;\n      dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    }\n  }\n  extractElements(event) {\n    let relatedElement;\n    let targetElement;\n    if (\"relatedTarget\" in event && event[\"relatedTarget\"] instanceof HTMLElement) {\n      relatedElement = event[\"relatedTarget\"];\n    }\n    if (\"target\" in event && event[\"target\"] instanceof HTMLElement) {\n      targetElement = event[\"target\"];\n    }\n    return { relatedElement, targetElement };\n  }\n  dispatchPointerEvent(event, type) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    dispatchTypedEvent(this.listeners, this.buildPointerEvent({ type, event, ...coords }));\n  }\n  getEventHTMLTarget(event) {\n    if (event.target instanceof HTMLElement) {\n      return event.target;\n    } else if (event.currentTarget instanceof HTMLElement) {\n      return event.currentTarget;\n    }\n    return void 0;\n  }\n  recordDown(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.clickHistory[0], event);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[2], this.dblclickHistory[0]);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[0], event);\n    }\n    this.dragStartElement = this.getEventHTMLTarget(event);\n  }\n  recordUp(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[1], event);\n    }\n    this.dragStartElement = void 0;\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = \"drag-start\";\n    if (this.pointerCaptureCanvasElement?.isConnected === false) {\n      this.pointerCaptureCanvasElement = void 0;\n    }\n    if (this.pointerCaptureCanvasElement != null) {\n      return;\n    }\n    switch (event.type) {\n      case \"blur\":\n      case \"focus\":\n      case \"keydown\":\n      case \"keyup\":\n        return this.keyboardOptions.enabled ? event.type : void 0;\n      case \"click\":\n      case \"dblclick\":\n      case \"contextmenu\":\n      case \"wheel\":\n        return event.type;\n      case \"mousedown\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = true;\n        this.recordDown(event);\n        return dragStart;\n      case \"touchstart\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = true;\n        this.recordDown(event);\n        return dragStart;\n      case \"touchmove\":\n      case \"mousemove\":\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        return this.mouseDown || this.touchDown ? \"drag\" : \"hover\";\n      case \"mouseup\":\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = false;\n        this.recordUp(event);\n        return \"drag-end\";\n      case \"touchend\":\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = false;\n        this.recordUp(event);\n        return \"drag-end\";\n      case \"mouseleave\":\n      case \"touchcancel\":\n        return \"leave\";\n      case \"mouseenter\":\n        return \"enter\";\n      case \"pagehide\":\n        return \"page-left\";\n    }\n  }\n  isEventOverElement(event) {\n    return this.domManager.isEventOverElement(event);\n  }\n  calculateCoordinates(event) {\n    if (event instanceof MouseEvent) {\n      return this.getMouseEventCoords(event);\n    } else if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n      const lastTouch = event.touches[0] ?? event.changedTouches[0];\n      const { clientX, clientY, pageX, pageY } = lastTouch;\n      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        return;\n      }\n      return _InteractionManager.NULL_COORDS;\n    }\n  }\n  getMouseEventCoords(event) {\n    const { clientX, clientY, pageX, pageY } = event;\n    let { offsetX, offsetY } = event;\n    const target = this.getEventHTMLTarget(event);\n    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);\n      offsetX -= offsetDragStart.x - x;\n      offsetY -= offsetDragStart.y - y;\n    } else {\n      offsetX += x;\n      offsetY += y;\n    }\n    return { clientX, clientY, pageX, pageY, offsetX, offsetY };\n  }\n  isWheelEvent(event) {\n    return event.type === \"wheel\";\n  }\n  buildPointerEvent(opts) {\n    const { type, event, clientX, clientY } = opts;\n    let { offsetX, offsetY, pageX, pageY } = opts;\n    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {\n      const rect = this.domManager.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {\n      const pageRect = this.rootElement?.getBoundingClientRect();\n      pageX = clientX - (pageRect?.left ?? 0);\n      pageY = clientY - (pageRect?.top ?? 0);\n    }\n    let [deltaX, deltaY] = [NaN, NaN];\n    if (this.isWheelEvent(event)) {\n      const factor = event.deltaMode === 0 ? 0.01 : 1;\n      deltaX = event.deltaX * factor;\n      deltaY = event.deltaY * factor;\n    }\n    let pointerHistory = [];\n    if (event.type === \"click\") {\n      pointerHistory = this.clickHistory;\n    } else if (event.type === \"dblclick\") {\n      pointerHistory = this.dblclickHistory;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    const button = \"button\" in event ? Number(event.button) : 0;\n    const builtEvent = {\n      type,\n      offsetX,\n      offsetY,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n      button,\n      pointerHistory,\n      sourceEvent: event,\n      relatedElement,\n      targetElement\n    };\n    this.debug(\"InteractionManager - builtEvent: \", builtEvent);\n    return builtEvent;\n  }\n};\n_InteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\nvar InteractionManager = _InteractionManager;\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class extends BaseManager {\n  constructor(interactionManager, chartUpdateMutex) {\n    super();\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = false;\n    this.requestId = null;\n    this.skipAnimations = false;\n    this.currentAnonymousAnimationId = 0;\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate({ ...opts }) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.pause()\");\n    try {\n      this.batch.pause();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = requestAnimationFrame(cb);\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = async () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(1 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error) {\n          this.failsafeOnError(error);\n        }\n        this.listeners.dispatch(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.listeners.dispatch(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.listeners.dispatch(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error(\"Error during animation, skipping animations\", error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.stop();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(1 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/ariaAnnouncementServices.ts\nvar AriaAnnouncementService = class _AriaAnnouncementService {\n  constructor(localeManager, domManager, layoutService) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.layoutService = layoutService;\n    this.debug = Debug.create(true, \"aria\");\n    this.destroyFns = [];\n    this.liveElem = _AriaAnnouncementService.createAnnouncer();\n    this.domManager.addChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\", this.liveElem);\n    this.destroyFns.push(\n      this.layoutService.addListener(\"layout-complete\", (ev) => this.onResize(ev)),\n      () => this.domManager.removeChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\")\n    );\n  }\n  static createAnnouncer() {\n    const e = getDocument().createElement(\"div\");\n    e.classList.add(\"ag-charts-aria-announcer\");\n    setAttribute(e, \"role\", \"status\");\n    setAttribute(e, \"aria-live\", \"assertive\");\n    return e;\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  onResize(event) {\n    this.liveElem.style.width = `${event.chart.width}px`;\n    this.liveElem.style.height = `${event.chart.height}px`;\n  }\n  announceValue(id, params) {\n    const { localeManager, liveElem } = this;\n    const value = localeManager.t(id, params);\n    this.debug(`AriaAnnouncementService - announceValue: ${value}`);\n    liveElem.textContent = \"\\xA0\";\n    setTimeout(() => liveElem.innerText = value, 16);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: \"axis-hover\",\n      axisId,\n      direction\n    };\n    this.listeners.dispatch(\"axis-hover\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class _ContextMenuRegistry {\n  constructor(regionManager) {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n    const { Default: Default2, ContextMenu } = InteractionState;\n    this.destroyFns = [regionManager.listenAll(\"contextmenu\", (e) => this.onContextMenu(e), Default2 | ContextMenu)];\n  }\n  destroy() {\n    this.destroyFns.forEach((d) => d());\n  }\n  onContextMenu(event) {\n    const type = _ContextMenuRegistry.toContextType(event.region);\n    if (type === \"all\") {\n      this.dispatchContext(\"all\", event, {});\n    }\n  }\n  static toContextType(region) {\n    if (region === \"legend\" || region === \"series\") {\n      return region;\n    }\n    return \"all\";\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context) {\n    const { offsetX: x, offsetY: y, sourceEvent } = pointerEvent;\n    this.listeners.dispatch(\"\", buildPreventable({ type, x, y, context, sourceEvent }));\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    if (action.id && this.defaultActions.find(({ id }) => id === action.id)) {\n      return;\n    }\n    this.defaultActions.push(action);\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  setActionVisiblity(actionId, visible) {\n    if (visible) {\n      this.hiddenActions.delete(actionId);\n    } else {\n      this.hiddenActions.add(actionId);\n    }\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/cursorManager.ts\nvar Cursor = /* @__PURE__ */ ((Cursor2) => {\n  Cursor2[\"Auto\"] = \"auto\";\n  Cursor2[\"Default\"] = \"default\";\n  Cursor2[\"Grab\"] = \"grab\";\n  Cursor2[\"Grabbing\"] = \"grabbing\";\n  Cursor2[\"Move\"] = \"move\";\n  Cursor2[\"NotAllowed\"] = \"not-allowed\";\n  Cursor2[\"Pointer\"] = \"pointer\";\n  Cursor2[\"EWResize\"] = \"ew-resize\";\n  Cursor2[\"NSResize\"] = \"ns-resize\";\n  Cursor2[\"ZoomIn\"] = \"zoom-in\";\n  Cursor2[\"ZoomOut\"] = \"zoom-out\";\n  return Cursor2;\n})(Cursor || {});\nvar CursorManager = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.stateTracker = new StateTracker(\"default\");\n  }\n  updateCursor(callerId, style) {\n    this.stateTracker.set(callerId, style);\n    this.domManager.updateCursor(this.stateTracker.stateValue());\n  }\n  getCursor() {\n    return this.domManager.getCursor();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts\nfunction distanceSquared(finger1, finger2) {\n  const dx = finger1.screenX - finger2.screenX;\n  const dy = finger1.screenY - finger2.screenY;\n  return dx * dx + dy * dy;\n}\nfunction distance(finger1, finger2) {\n  return Math.sqrt(distanceSquared(finger1, finger2));\n}\nvar MIN_DISTANCE_TO_START_PINCH = 1;\nvar GestureDetector = class extends BaseManager {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.touchstart = (event) => this.onTouchStart(event);\n    this.touchmove = (event) => this.onTouchMove(event);\n    this.touchend = (event) => this.onTouchEnd(event);\n    this.touchcancel = (event) => this.onTouchCancel(event);\n    this.pinch = {\n      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },\n      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },\n      origin: { x: NaN, y: NaN },\n      distance: NaN,\n      status: 0 /* Off */\n    };\n    this.domManager.addEventListener(\"touchstart\", this.touchstart, { passive: true });\n    this.domManager.addEventListener(\"touchmove\", this.touchmove, { passive: false });\n    this.domManager.addEventListener(\"touchend\", this.touchend);\n    this.domManager.addEventListener(\"touchcancel\", this.touchcancel);\n  }\n  destroy() {\n    this.domManager.removeEventListener(\"touchstart\", this.touchstart);\n    this.domManager.removeEventListener(\"touchmove\", this.touchmove);\n    this.domManager.removeEventListener(\"touchend\", this.touchend);\n    this.domManager.removeEventListener(\"touchcancel\", this.touchcancel);\n  }\n  findPinchTouches(moveEvent) {\n    const { touches } = moveEvent;\n    const { finger1, finger2 } = this.pinch;\n    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {\n      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {\n        return [touches[0], touches[1]];\n      }\n      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {\n        return [touches[1], touches[0]];\n      }\n    }\n  }\n  copyTouchData(event) {\n    const keys = [\"identifier\", \"screenX\", \"screenY\"];\n    partialAssign(keys, this.pinch.finger1, event.touches[0]);\n    partialAssign(keys, this.pinch.finger2, event.touches[1]);\n    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);\n  }\n  dispatchPinchEvent(type, deltaDistance, sourceEvent) {\n    const { finger1, finger2, origin } = this.pinch;\n    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin }));\n  }\n  onTouchStart(event) {\n    this.stopPinchTracking(event);\n    const { pinch } = this;\n    if (event.touches.length === 2) {\n      pinch.status = 1 /* Initialized */;\n      this.copyTouchData(event);\n      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n    }\n  }\n  onTouchMove(event) {\n    const pinchTouches = this.findPinchTouches(event);\n    if (pinchTouches !== void 0) {\n      const [touch1, touch2] = pinchTouches;\n      const { pinch } = this;\n      const newDistance = distance(touch1, touch2);\n      const deltaDistance = newDistance - pinch.distance;\n      if (pinch.status === 1 /* Initialized */) {\n        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {\n          pinch.status = 2 /* Running */;\n          this.copyTouchData(event);\n          this.dispatchPinchEvent(\"pinch-start\", 0, event);\n        }\n      } else if (pinch.status === 2 /* Running */) {\n        pinch.distance = newDistance;\n        this.copyTouchData(event);\n        this.dispatchPinchEvent(\"pinch-move\", deltaDistance, event);\n      } else {\n        Logger.error(`unexpected pinch.status: ${pinch.status}`);\n      }\n    }\n  }\n  onTouchEnd(event) {\n    this.stopPinchTracking(event);\n  }\n  onTouchCancel(event) {\n    this.stopPinchTracking(event);\n  }\n  stopPinchTracking(event) {\n    const { pinch } = this;\n    if (pinch.status === 2 /* Running */) {\n      this.dispatchPinchEvent(\"pinch-end\", 0, event);\n    }\n    this.pinch.status = 0 /* Off */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight,\n        callerId\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts\nvar KeyNavManager = class extends BaseManager {\n  constructor(interactionManager, domManager) {\n    super();\n    this.domManager = domManager;\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.isClicking = false;\n    this.destroyFns.push(\n      interactionManager.addListener(\"drag-start\", (e) => this.onClickStart(e), 31 /* All */),\n      interactionManager.addListener(\"click\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"drag-end\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"wheel\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"hover\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"drag\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"blur\", (e) => this.onBlur(e), 31 /* All */),\n      interactionManager.addListener(\"focus\", (e) => this.onFocus(e), 31 /* All */),\n      interactionManager.addListener(\"keydown\", (e) => this.onKeyDown(e), 31 /* All */)\n    );\n  }\n  destroy() {\n    super.destroy();\n  }\n  onClickStart(event) {\n    this.isClicking = true;\n    this.mouseBlur(event);\n  }\n  onClickStop(event) {\n    this.mouseBlur(event);\n    this.isClicking = false;\n  }\n  mouseBlur(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    if (!this.isMouseBlurred) {\n      this.dispatch(\"blur\", 0, event);\n      this.isMouseBlurred = true;\n    }\n  }\n  onBlur(event) {\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.dispatch(\"blur\", 0, event);\n  }\n  onFocus(event) {\n    const delta3 = this.domManager.getBrowserFocusDelta();\n    this.dispatch(\"browserfocus\", delta3, event);\n    this.hasBrowserFocus = true;\n    const tabFocusFromClick = event.relatedElement == null && event.targetElement?.tagName === \"CANVAS\";\n    if (this.isClicking || tabFocusFromClick) {\n      this.isMouseBlurred = true;\n      return;\n    }\n    this.dispatch(\"tab\", delta3, event);\n  }\n  onKeyDown(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    this.isMouseBlurred = false;\n    const { code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;\n    if (code === \"Tab\") {\n      if (shiftKey) {\n        return this.dispatch(\"tab\", -1, event);\n      } else {\n        return this.dispatch(\"tab\", 1, event);\n      }\n    }\n    if (altKey || shiftKey || metaKey || ctrlKey)\n      return;\n    switch (code) {\n      case \"ArrowDown\":\n        return this.dispatch(\"nav-vert\", 1, event);\n      case \"ArrowUp\":\n        return this.dispatch(\"nav-vert\", -1, event);\n      case \"ArrowLeft\":\n        return this.dispatch(\"nav-hori\", -1, event);\n      case \"ArrowRight\":\n        return this.dispatch(\"nav-hori\", 1, event);\n      case \"ZoomIn\":\n      case \"Add\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"ZoomOut\":\n      case \"Substract\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n      case \"Space\":\n      case \"Enter\":\n        return this.dispatch(\"submit\", 0, event);\n      case \"Escape\":\n        return this.dispatch(\"cancel\", 0, event);\n      case \"Backspace\":\n      case \"Delete\":\n        return this.dispatch(\"delete\", 0, event);\n    }\n    switch (event.sourceEvent.key) {\n      case \"+\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"-\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n    }\n  }\n  dispatch(type, delta3, sourceEvent) {\n    dispatchTypedEvent(this.listeners, { type, delta: delta3, sourceEvent });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regionManager.ts\nvar REGION_TAB_ORDERING = [\"series\"];\nvar RegionListeners = class extends Listeners {\n};\nfunction addHandler(listeners, interactionManager, type, handler, triggeringStates = 16 /* Default */) {\n  return listeners?.addListener(type, (e) => {\n    const currentState = interactionManager.getState();\n    if (currentState & triggeringStates) {\n      handler(e);\n    }\n  }) ?? (() => {\n  });\n}\nvar RegionManager = class {\n  constructor(interactionManager, keyNavManager, focusIndicator) {\n    this.interactionManager = interactionManager;\n    this.keyNavManager = keyNavManager;\n    this.focusIndicator = focusIndicator;\n    this.currentTabIndex = 0;\n    this.isDragging = false;\n    this.leftCanvas = false;\n    this.regions = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.allRegionsListeners = new RegionListeners();\n    this.destroyFns.push(\n      ...POINTER_INTERACTION_TYPES.map(\n        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 31 /* All */)\n      ),\n      this.keyNavManager.addListener(\"blur\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"browserfocus\", this.onBrowserFocus.bind(this)),\n      this.keyNavManager.addListener(\"tab\", this.onTab.bind(this)),\n      this.keyNavManager.addListener(\"nav-vert\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-hori\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-zoom\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"submit\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"cancel\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"delete\", this.onNav.bind(this))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.currentRegion = void 0;\n    for (const region of this.regions.values()) {\n      region.listeners.destroy();\n    }\n    this.focusIndicator.destroy();\n    this.regions.clear();\n  }\n  addRegion(name, ...bboxproviders) {\n    if (this.regions.has(name)) {\n      throw new Error(`AG Charts - Region: ${name} already exists`);\n    }\n    const region = {\n      properties: { name, bboxproviders: [...bboxproviders] },\n      listeners: new RegionListeners()\n    };\n    this.regions.set(name, region);\n    return this.makeObserver(region);\n  }\n  updateRegion(name, ...bboxprovider) {\n    const region = this.regions.get(name);\n    if (region) {\n      region.properties.bboxproviders = [...bboxprovider];\n    } else {\n      throw new Error(\"AG Charts - unknown region: \" + name);\n    }\n  }\n  getRegion(name) {\n    return this.makeObserver(this.regions.get(name));\n  }\n  listenAll(type, handler, triggeringStates = 16 /* Default */) {\n    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);\n  }\n  // This method return a wrapper object that matches the interface of InteractionManager.addListener.\n  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.\n  makeObserver(region) {\n    const { interactionManager } = this;\n    class ObservableRegionImplementation {\n      addListener(type, handler, triggeringStates = 16 /* Default */) {\n        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);\n      }\n    }\n    return new ObservableRegionImplementation();\n  }\n  checkPointerHistory(targetRegion, event) {\n    for (const historyEvent of event.pointerHistory) {\n      const { region: historyRegion } = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY);\n      if (targetRegion.properties.name !== historyRegion?.properties.name) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Create and dispatch a copy of the InteractionEvent.\n  dispatch(region, partialEvent, bboxProviderId) {\n    if (region == null)\n      return;\n    const event = buildPreventable({\n      ...partialEvent,\n      region: region.properties.name,\n      bboxProviderId\n    });\n    this.allRegionsListeners.dispatch(event.type, event);\n    region.listeners.dispatch(event.type, event);\n  }\n  // Process events during a drag action. Returns false if this event should follow the standard\n  // RegionManager.processEvent flow, or true if this event already processed by this function.\n  handleDragging(event) {\n    const { currentRegion } = this;\n    switch (event.type) {\n      case \"drag-start\":\n        this.isDragging = true;\n        this.leftCanvas = false;\n        break;\n      case \"leave\":\n        this.leftCanvas = true;\n        return this.isDragging;\n      case \"enter\":\n        this.leftCanvas = false;\n        return this.isDragging;\n      case \"drag\":\n        if (this.isDragging) {\n          this.dispatch(currentRegion, event);\n          return true;\n        }\n        break;\n      case \"drag-end\":\n        if (this.isDragging) {\n          this.isDragging = false;\n          this.dispatch(currentRegion, event);\n          if (this.leftCanvas) {\n            this.dispatch(currentRegion, { ...event, type: \"leave\" });\n          }\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n  processPointerEvent(event) {\n    if (this.handleDragging(event)) {\n      return;\n    }\n    const { currentRegion } = this;\n    if (event.type === \"leave\") {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" });\n      this.currentRegion = void 0;\n      return;\n    }\n    const { region: newRegion, bboxProviderId } = this.pickRegion(event.offsetX, event.offsetY);\n    if (currentRegion !== void 0 && newRegion?.properties.name !== currentRegion.properties.name) {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" }, this.currentBBoxProviderId);\n    }\n    if (newRegion !== void 0 && newRegion.properties.name !== currentRegion?.properties.name) {\n      this.dispatch(newRegion, { ...event, type: \"enter\" }, bboxProviderId);\n    }\n    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {\n      this.dispatch(newRegion, event, bboxProviderId);\n    }\n    this.currentRegion = newRegion;\n    this.currentBBoxProviderId = bboxProviderId;\n  }\n  pickRegion(x, y) {\n    let currentArea = Infinity;\n    let currentRegion;\n    let currentBBoxProviderId;\n    for (const region of this.regions.values()) {\n      for (const provider of region.properties.bboxproviders) {\n        if (provider.visible === false)\n          continue;\n        const bbox = provider.computeTransformedRegionBBox?.() ?? provider.computeTransformedBBox();\n        const area2 = bbox.width * bbox.height;\n        if (area2 < currentArea && bbox.containsPoint(x, y)) {\n          currentArea = area2;\n          currentRegion = region;\n          currentBBoxProviderId = provider.id;\n        }\n      }\n    }\n    return { region: currentRegion, bboxProviderId: currentBBoxProviderId };\n  }\n  getTabRegion(tabIndex) {\n    if (tabIndex !== void 0 && tabIndex >= 0 && tabIndex < REGION_TAB_ORDERING.length) {\n      return this.regions.get(REGION_TAB_ORDERING[tabIndex]);\n    }\n    return void 0;\n  }\n  getNextInteractableTabIndex(currentIndex, delta3) {\n    const direction = delta3 < 0 ? -1 : 1;\n    let i = currentIndex;\n    while (delta3 !== 0) {\n      const region = this.getTabRegion(i + direction);\n      if (region === void 0) {\n        return void 0;\n      } else {\n        delta3 = delta3 - direction;\n      }\n      i = i + direction;\n    }\n    return i;\n  }\n  validateCurrentTabIndex() {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (focusedRegion !== void 0) {\n      this.currentTabIndex = this.getNextInteractableTabIndex(-1, 1) ?? 0;\n    }\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.currentTabIndex = -1;\n    } else if (event.delta < 0) {\n      this.currentTabIndex = REGION_TAB_ORDERING.length;\n    }\n  }\n  onTab(event) {\n    this.validateCurrentTabIndex();\n    const newTabIndex = this.getNextInteractableTabIndex(this.currentTabIndex, event.delta);\n    const newRegion = this.getTabRegion(newTabIndex);\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (newTabIndex !== void 0) {\n      this.currentTabIndex = newTabIndex;\n    }\n    if (focusedRegion !== void 0 && newRegion?.properties.name !== focusedRegion.properties.name) {\n      const { delta: delta3, sourceEvent } = event;\n      const blurEvent = buildPreventable({ type: \"blur\", delta: delta3, sourceEvent });\n      this.dispatch(focusedRegion, blurEvent);\n    }\n    if (newRegion === void 0) {\n      this.focusIndicator.updateBounds(void 0);\n    } else {\n      this.dispatch(newRegion, event);\n    }\n  }\n  onNav(event) {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    this.dispatch(focusedRegion, event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts\nvar TOOLBAR_ALIGNMENTS = [\"start\", \"center\", \"end\"];\nvar TOOLBAR_GROUPS = [\"seriesType\", \"annotations\", \"annotationOptions\", \"ranges\", \"zoom\"];\nvar TOOLBAR_GROUP_ORDERING = {\n  seriesType: 0,\n  annotations: 1,\n  annotationOptions: 2,\n  ranges: 3,\n  zoom: 4\n};\nvar ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {\n  ToolbarPosition2[\"Top\"] = \"top\";\n  ToolbarPosition2[\"Right\"] = \"right\";\n  ToolbarPosition2[\"Bottom\"] = \"bottom\";\n  ToolbarPosition2[\"Left\"] = \"left\";\n  ToolbarPosition2[\"Floating\"] = \"floating\";\n  ToolbarPosition2[\"FloatingTop\"] = \"floating-top\";\n  ToolbarPosition2[\"FloatingBottom\"] = \"floating-bottom\";\n  return ToolbarPosition2;\n})(ToolbarPosition || {});\nvar TOOLBAR_POSITIONS = Object.values(ToolbarPosition);\nfunction isAnimatingFloatingPosition(position) {\n  return [\"floating-top\" /* FloatingTop */, \"floating-bottom\" /* FloatingBottom */].includes(position);\n}\n\n// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts\nvar ToolbarManager = class extends BaseManager {\n  static isGroup(group, event) {\n    return event.group === group;\n  }\n  static isChildElement(domManager, element2) {\n    for (const position of TOOLBAR_POSITIONS) {\n      if (domManager.isManagedChildDOMElement(element2, \"canvas-overlay\", `toolbar-${position}`)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pressButton(group, id, value, rect) {\n    this.listeners.dispatch(\"button-pressed\", { type: \"button-pressed\", group, id, value, rect });\n  }\n  cancel(group) {\n    this.listeners.dispatch(\"cancelled\", { type: \"cancelled\", group });\n  }\n  toggleButton(group, id, options) {\n    const { active = false, enabled = true, visible = true } = options;\n    this.listeners.dispatch(\"button-toggled\", { type: \"button-toggled\", group, id, active, enabled, visible });\n  }\n  updateButton(group, id, options) {\n    this.listeners.dispatch(\"button-updated\", { type: \"button-updated\", group, id, ...options });\n  }\n  toggleGroup(caller, group, options) {\n    const { active, visible } = options;\n    this.listeners.dispatch(\"group-toggled\", { type: \"group-toggled\", caller, group, active, visible });\n  }\n  changeFloatingAnchor(group, anchor) {\n    this.listeners.dispatch(\"floating-anchor-changed\", { type: \"floating-anchor-changed\", group, anchor });\n  }\n  buttonMoved(group, value, rect, groupRect) {\n    this.listeners.dispatch(\"button-moved\", { type: \"button-moved\", group, value, rect, groupRect });\n  }\n  proxyGroupOptions(caller, group, options) {\n    this.listeners.dispatch(\"proxy-group-options\", { type: \"proxy-group-options\", caller, group, options });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.toggle(false));\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  getTooltipMeta(callerId) {\n    return this.stateTracker.get(callerId)?.meta;\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.toggle(false);\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    const boundingRect = this.tooltip.bounds === \"extended\" ? this.domManager.getOverlayClientRect() : canvasRect;\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, datum) {\n    const { offsetX, offsetY } = event;\n    const { tooltip } = datum.series.properties;\n    const meta = {\n      offsetX,\n      offsetY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, offsetX, offsetY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);\n    if (tooltip.position.type === \"node\" && refPoint) {\n      const { x, y } = refPoint;\n      const point = datum.series.contentGroup.inverseTransformPoint(x, y);\n      return {\n        ...meta,\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      };\n    }\n    return meta;\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutService.ts\nvar LayoutService = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.layoutComplete = \"layout-complete\";\n    this.debug = Debug.create(true, \"layout\");\n  }\n  addListener(eventType, handler) {\n    if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\n      return super.addListener(eventType, handler);\n    }\n    throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\n  }\n  dispatchPerformLayout(stage, ctx) {\n    if (this.isLayoutStage(stage)) {\n      return this.getListenersByType(stage).reduce((result, listener) => {\n        try {\n          const newCtx = listener.handler(result);\n          this.debug(\"[LayoutService] Context updated to: \", { ...newCtx }, listener);\n          return newCtx;\n        } catch (e) {\n          Logger.errorOnce(e);\n          return result;\n        }\n      }, ctx);\n    }\n    return ctx;\n  }\n  dispatchLayoutComplete(event) {\n    this.dispatch(this.layoutComplete, event);\n  }\n  isLayoutStage(eventType) {\n    return eventType !== this.layoutComplete;\n  }\n  isLayoutComplete(eventType) {\n    return eventType === this.layoutComplete;\n  }\n};\n\n// packages/ag-charts-community/src/chart/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)}(?:\\[(\\w+)])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\" }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : void 0;\n    if (format != null && formatter == null) {\n      Logger.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return String(value);\n  });\n};\n\n// packages/ag-charts-community/src/chart/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({\n    id,\n    seriesGrouping,\n    visible,\n    type\n  }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][id] = { grouping: seriesGrouping, visible };\n  }\n  deregisterSeries({ id, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][id];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({\n    type,\n    seriesGrouping,\n    visible\n  }) {\n    if (!seriesGrouping)\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType3) => {\n  ChartUpdateType3[ChartUpdateType3[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType3[ChartUpdateType3[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType3[ChartUpdateType3[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType3[ChartUpdateType3[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType3[ChartUpdateType3[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType3[ChartUpdateType3[\"PRE_SCENE_RENDER\"] = 5] = \"PRE_SCENE_RENDER\";\n  ChartUpdateType3[ChartUpdateType3[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType3[ChartUpdateType3[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType3;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete(rects) {\n    this.dispatch(\"update-complete\", {\n      type: \"update-complete\",\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    });\n  }\n  dispatchPreSceneRender(rects) {\n    this.dispatch(\"pre-scene-render\", { type: \"pre-scene-render\", ...rects });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    const { scene, root, syncManager, container, updateCallback, updateMutex, overrideDevicePixelRatio } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.zoomManager = chart.zoomManager;\n    this.domManager = new DOMManager(container);\n    scene?.setContainer(this.domManager);\n    this.scene = scene ?? new Scene({ pixelRatio: overrideDevicePixelRatio, domManager: this.domManager });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.localeManager = new LocaleManager();\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.chartEventManager = new ChartEventManager();\n    this.cursorManager = new CursorManager(this.domManager);\n    this.highlightManager = new HighlightManager();\n    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);\n    this.keyNavManager = new KeyNavManager(this.interactionManager, this.domManager);\n    this.focusIndicator = new FocusIndicator(this.domManager);\n    this.regionManager = new RegionManager(this.interactionManager, this.keyNavManager, this.focusIndicator);\n    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);\n    this.toolbarManager = new ToolbarManager();\n    this.gestureDetector = new GestureDetector(this.domManager);\n    this.layoutService = new LayoutService();\n    this.ariaAnnouncementService = new AriaAnnouncementService(\n      this.localeManager,\n      this.domManager,\n      this.layoutService\n    );\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(\n      this.updateService,\n      this.localeManager,\n      this.domManager,\n      this.focusIndicator\n    );\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.callbackCache = new CallbackCache();\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.animationManager.skip();\n    this.animationManager.play();\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n  }\n  destroy() {\n    this.tooltipManager.destroy();\n    this.contextMenuRegistry.destroy();\n    this.regionManager.destroy();\n    this.proxyInteractionService.destroy();\n    this.focusIndicator.destroy();\n    this.keyNavManager.destroy();\n    this.interactionManager.destroy();\n    this.animationManager.stop();\n    this.animationManager.destroy();\n    this.ariaAnnouncementService.destroy();\n    this.chartEventManager.destroy();\n    this.highlightManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.animationManager.reset();\n    this.syncManager.destroy();\n    this.domManager.destroy();\n    this.axisManager.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round2(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtentInternal(extent2) {\n  if (extent2 == null) {\n    return [];\n  }\n  let [min, max] = extent2.map(Number);\n  if (min === 0 && max === 0) {\n    return [0, 1];\n  }\n  if (min === Infinity && max === -Infinity) {\n    return [];\n  } else if (min === Infinity) {\n    min = 0;\n  } else if (max === -Infinity) {\n    max = 0;\n  }\n  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];\n}\nfunction fixNumericExtent(extent2, axis) {\n  const fixedExtent = fixNumericExtentInternal(extent2);\n  if (fixedExtent.length === 0) {\n    return fixedExtent;\n  }\n  let [min, max] = fixedExtent;\n  if (min === max) {\n    const [paddingMin, paddingMax] = axis?.calculatePadding(min, max) ?? [1, 1];\n    min -= paddingMin;\n    max += paddingMax;\n  }\n  return [min, max];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|\\\\')*'|\"(?:[^\"]|\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\") {\n    this.opts = opts;\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    for (const def of opts.props) {\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);\n  }\n  resolveProcessedDataDefsValues(defs, { keys, values }) {\n    const result = {};\n    for (const [searchId, { index, def }] of defs) {\n      const processedData = def.type === \"key\" ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  getDomain(scope, searchId, type = \"value\", processedData) {\n    const domains = this.getDomainsByType(type, processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(data, sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(data, sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    if (data.length > 0) {\n      for (const def of iterate(this.keys, this.values)) {\n        for (const [scope, missCount] of def.missing) {\n          if (missCount >= data.length) {\n            const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n          }\n        }\n      }\n    }\n    const end = performance.now();\n    processedData.time = end - start;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.findIndex((def) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));\n    });\n    if (result === -1) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(data, sources) {\n    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const sourcesById = new Map(sources?.map((s) => [s.id, s]));\n    const { keys: keyDefs, values: valueDefs } = this;\n    const resultData = new Array(data.length);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const [datumIdx, datum] of data.entries()) {\n      const sourceDatums = {};\n      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;\n      const keys = new Array(keyDefs.length);\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE)\n          break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE)\n        continue;\n      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;\n      let value;\n      for (const [valueDefIdx, def] of valueDefs.entries()) {\n        for (const scope of def.scopes ?? scopes) {\n          const source = sourcesById.get(scope);\n          const valueDatum = source?.data[datumIdx] ?? datum;\n          value = processValue(def, valueDatum, value, scope);\n          if (value === INVALID_VALUE || !values)\n            continue;\n          if (source != null && def.includeProperty !== false) {\n            const property = def.includeProperty && def.id != null ? def.id : def.property;\n            sourceDatums[scope] ?? (sourceDatums[scope] = {});\n            sourceDatums[scope][property] = value;\n          }\n          values[valueDefIdx] = value;\n        }\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs)\n            break;\n          for (const scope of def.scopes ?? scopes) {\n            validScopes?.delete(scope);\n          }\n          if (validScopes?.size === 0)\n            break;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs)\n        continue;\n      if (validScopes?.size === 0)\n        continue;\n      const result = { datum: { ...datum, ...sourceDatums }, keys, values };\n      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n        partialValidDataCount++;\n        result.validScopes = new Set(validScopes);\n      }\n      resultData[resultDataIdx++] = result;\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: data.length },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    const processedData = /* @__PURE__ */ new Map();\n    for (const dataEntry of data.data) {\n      const { keys, values, datum, validScopes } = dataEntry;\n      const group = groupingFn?.(dataEntry) ?? keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null && existingData.validScopes != null) {\n          for (const scope of existingData.validScopes) {\n            if (!validScopes.has(scope)) {\n              existingData.validScopes.delete(scope);\n            }\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const { keys, values, datum, validScopes } of processedData.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      data: resultData,\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      }\n    };\n  }\n  aggregateData(processedData) {\n    const isUngrouped = processedData.type === \"ungrouped\";\n    processedData.domain.aggValues = [];\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      const domain = [Infinity, -Infinity];\n      for (const datum of processedData.data) {\n        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));\n        if (datum.validScopes)\n          continue;\n        const values = isUngrouped ? [datum.values] : datum.values;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\n          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));\n        datum.aggValues[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domain);\n      }\n      processedData.domain.aggValues.push(domain);\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const affectedIndices = /* @__PURE__ */ new Set();\n    const updatedDomains = /* @__PURE__ */ new Map();\n    const groupProcessorIndices = /* @__PURE__ */ new Map();\n    const groupProcessorInitFns = /* @__PURE__ */ new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        const isDiscrete = valueDef.valueType === \"category\";\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());\n      }\n    }\n    const updateDomains = (values) => {\n      for (const valueIndex of affectedIndices) {\n        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        if (group.validScopes)\n          continue;\n        const valueIndexes = groupProcessorIndices.get(processor) ?? [];\n        const adjustFn = groupProcessorInitFns.get(processor)?.();\n        if (!adjustFn)\n          continue;\n        if (processedData.type === \"grouped\") {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n        } else if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === \"grouped\") {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = dataDomain.getDomain();\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes, property));\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      for (const datum of processedData.data) {\n        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {\n          accValue = reducer(accValue, datum);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, previousDatum, scope) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch (error) {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        const missCount = def.missing.get(scope) ?? 0;\n        def.missing.set(scope, missCount + 1);\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && def.validation?.(value, datum) === false) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            Logger.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.mode === \"integrated\") {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        Logger.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n  if (processedData.type === \"grouped\") {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const keys = next.keys ?? [];\n      const aggValues = next.aggValues ?? [];\n      const skipKeys = next.keys.map(() => void 0);\n      const skipAggValues = aggValues?.map(() => void 0);\n      acc.push(\n        ...next.values.map((v, i) => [\n          ...i === 0 ? keys : skipKeys,\n          ...v ?? [],\n          ...i == 0 ? aggValues : skipAggValues\n        ])\n      );\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const aggValues = next.aggValues ?? [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  }\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute() {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const scopes = this.requested.map(({ id }) => id);\n    const needsValueExtraction = this.hasMultipleDataSources(valid);\n    for (const { opts, data, resolves, rejects, ids } of merged) {\n      try {\n        const dataModel = new DataModel(opts, this.mode);\n        const processedData = dataModel.processData(data, valid);\n        if (this.debug.check()) {\n          getWindow(\"processedData\").push(processedData);\n        }\n        if (processedData?.partialValidDataCount === 0) {\n          resolves.forEach(\n            (resolve, requestIdx) => resolve({\n              dataModel,\n              processedData: this.processScopedData(\n                ids[requestIdx],\n                processedData,\n                scopes,\n                needsValueExtraction\n              )\n            })\n          );\n        } else if (processedData) {\n          this.splitResult(dataModel, processedData, ids, resolves);\n        } else {\n          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n        }\n      } catch (error) {\n        rejects.forEach((cb) => cb(error));\n      }\n    }\n  }\n  hasMultipleDataSources(validRequests) {\n    if (validRequests.length) {\n      const [{ data }, ...restRequests] = validRequests;\n      return restRequests.some((v) => data !== v.data);\n    }\n    return false;\n  }\n  processScopedData(id, processedData, ids, needsValueExtraction) {\n    const extractDatum = (datum) => {\n      if (Array.isArray(datum)) {\n        return datum.map(extractDatum);\n      }\n      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;\n      for (const otherId of ids) {\n        delete extracted[otherId];\n      }\n      return extracted;\n    };\n    const extractValues = (values) => {\n      if (Array.isArray(values)) {\n        return values.map(extractValues);\n      }\n      return values?.[id] ?? values;\n    };\n    return {\n      ...processedData,\n      data: processedData.data.map((datum) => ({\n        ...datum,\n        datum: extractDatum(datum.datum),\n        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values\n      }))\n    };\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData: {\n          ...processedData,\n          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)\n        }\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props) {\n      return props.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);\n  }\n  static mergeRequests(requests) {\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone = { ...prop, scopes: [id] };\n          _DataController.createIdsMap(id, clone);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone.type && _DataController.deepEqual(existing, clone)\n          );\n          if (!match) {\n            result.opts.props.push(clone);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone.idsMap?.size) {\n            _DataController.mergeIdsMap(clone.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      const toMapValue = toMap.get(scope);\n      if (toMapValue != null) {\n        for (const id of ids) {\n          toMapValue.add(id);\n        }\n      } else {\n        toMap.set(scope, new Set(ids));\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.hidden = /* @__PURE__ */ new Set();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.moduleFactory);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n    if (module.hidden) {\n      this.hidden.add(axisType);\n    }\n  }\n  create(axisType, moduleContext) {\n    const axisFactory = this.axesMap.get(axisType);\n    if (axisFactory) {\n      return axisFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  publicKeys() {\n    return [...this.keys()].filter((k) => !this.hidden.has(k));\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"foreground\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"chartToolbar\",\n    chartTypes: [\"cartesian\"]\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"], optionsInnerKey: \"miniChart\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bullet\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, moduleFactory });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;\n    if (legendFactory) {\n      return legendFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType2) {\n    return super.get(seriesType2) ?? \"unknown\";\n  }\n  isCartesian(seriesType2) {\n    return this.get(seriesType2) === \"cartesian\";\n  }\n  isPolar(seriesType2) {\n    return this.get(seriesType2) === \"polar\";\n  }\n  isHierarchy(seriesType2) {\n    return this.get(seriesType2) === \"hierarchy\";\n  }\n  isTopology(seriesType2) {\n    return this.get(seriesType2) === \"topology\";\n  }\n  isFlowProportion(seriesType2) {\n    return this.get(seriesType2) === \"flow-proportion\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType2, defaults) {\n    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));\n  }\n};\nvar chartTypes = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType2, {\n    chartTypes: [chartType2],\n    moduleFactory,\n    tooltipDefaults,\n    defaultAxes,\n    themeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    swapDefaultAxesCondition,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType2, themeTemplate);\n    this.seriesMap.set(seriesType2, {\n      moduleFactory,\n      tooltipDefaults,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault,\n      swapDefaultAxesCondition\n    });\n    chartTypes.set(seriesType2, chartType2);\n    if (!hidden) {\n      publicChartTypes.set(seriesType2, chartType2);\n    }\n  }\n  create(seriesType2, moduleContext) {\n    const seriesFactory = this.seriesMap.get(seriesType2)?.moduleFactory;\n    if (seriesFactory) {\n      return seriesFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType2}`);\n  }\n  cloneDefaultAxes(seriesType2) {\n    const defaultAxes = this.seriesMap.get(seriesType2)?.defaultAxes;\n    return defaultAxes ? { axes: deepClone(defaultAxes) } : null;\n  }\n  setThemeTemplate(seriesType2, themeTemplate) {\n    const currentTemplate = this.themeTemplates.get(seriesType2);\n    this.themeTemplates.set(seriesType2, mergeDefaults(themeTemplate, currentTemplate));\n  }\n  getThemeTemplate(seriesType2) {\n    return this.themeTemplates.get(seriesType2);\n  }\n  getPaletteFactory(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.tooltipDefaults;\n  }\n  isSolo(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.solo ?? false;\n  }\n  isGroupable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.groupable ?? false;\n  }\n  isStackable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackedByDefault ?? false;\n  }\n  isDefaultAxisSwapNeeded(options) {\n    let result;\n    for (const series of options.series ?? []) {\n      const { type = \"line\" } = series;\n      const isDefaultAxisSwapped = this.seriesMap.get(type)?.swapDefaultAxesCondition?.(series);\n      if (isDefaultAxisSwapped != null) {\n        if (result != null && result != isDefaultAxisSwapped) {\n          throw new Error(\"AG Charts - The provided series have incompatible directions\");\n        }\n        result = isDefaultAxisSwapped;\n      }\n    }\n    return result;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar ZoomManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.rejectCallbacks = /* @__PURE__ */ new Map();\n  }\n  updateAxes(axes) {\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {\n    if (rejectCallback) {\n      this.rejectCallbacks.set(callerId, rejectCallback);\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId || canChangeInitial) {\n        this.state.set(callerId, newZoom);\n        if (stateId !== callerId) {\n          this.rejectCallbacks.get(stateId)?.(callerId);\n        }\n      } else {\n        rejectCallback?.(stateId);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyChanges(callerId) {\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  applyChanges() {\n    const prevZoom = this.currentZoom;\n    this.currentZoom = this.state.stateValue();\n    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\"direction\", \"xKey\", \"yKey\", \"sizeKey\", \"angleKey\", \"radiusKey\", \"normalizedTo\"];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i, opts) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    if (opts?.seriesGrouping) {\n      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push(o);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  let targetIdx = -1;\n  for (const [key, optArray] of optsMap.entries()) {\n    for (const opts of optArray) {\n      targetIdx++;\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, outputIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"series-grouping\" });\n      } else if (diff2) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"update\" });\n      } else {\n        changes.push({ opts, series: outputSeries, idx: outputIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, outputIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: outputIdx, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  return input.series?.[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return true;\n  }\n  if (specifiedType === \"cartesian\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"polar\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"hierarchy\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"topology\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"flow-proportion\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-chart-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-chart-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      if (htmlContent instanceof HTMLElement) {\n        this.content = htmlContent;\n      } else {\n        const tempDiv = createElement(\"div\");\n        tempDiv.innerHTML = htmlContent;\n        this.content = tempDiv.firstElementChild;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        font: \"12px Verdana, sans-serif\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-chart-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-chart-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-chart-no-visible-series\", \"overlayNoVisibleSeries\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\n  const normalise = (val, extent2) => {\n    const result = val * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valueExtent = typeof value === \"number\" ? value : Math.max(...value);\n      const valIdx = valueExtent < 0 ? 0 : 1;\n      if (mode === \"sum\") {\n        valuesExtent[valIdx] += valueExtent;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);\n      }\n    }\n    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      values[valueIdx] = typeof value === \"number\" ? normalise(value, extent2) : value.map((v) => normalise(v, extent2));\n    }\n  };\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo, mode = \"sum\") {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start, span) => {\n    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start, end] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start = rangeMin;\n    if (rangeMax != null)\n      end = rangeMax;\n    const span = end - start;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === \"ungrouped\") {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys, values } = result.defs;\n      const { input, data } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!valueKeyIds?.includes(values[k].id))\n          continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        if (def.valueType === \"category\") {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = data[0]?.[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], \"keys\");\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, \"values\");\n      }\n      return { uniqueKeys, orderedKeys };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (!isFiniteNumber(currentVal))\n        continue;\n      if (mode === \"normal\")\n        acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === \"trailing\")\n        acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (values, valueIndexes) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === \"normal\") {\n            acc += sumValue;\n          }\n          values[valueIdx] = acc;\n          if (mode === \"trailing\") {\n            acc += sumValue;\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction groupStackAccFn() {\n  return () => (values, valueIndexes) => {\n    const acc = new Float64Array(32);\n    let stackCount = 0;\n    for (const valueIdx of valueIndexes) {\n      const currentValue = values[valueIdx];\n      acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;\n      stackCount += 1;\n      values[valueIdx] = acc.subarray(0, stackCount);\n    }\n  };\n}\nfunction accumulateStack(matchGroupId) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust: groupStackAccFn\n  };\n}\nfunction diff(previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate: (processedData) => {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const length2 = Math.max(previousData.data.length, processedData.data.length);\n      for (let i = 0; i < length2; i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : \"\";\n        const datumId = datum ? createDatumId(datum.keys) : \"\";\n        if (datum && prev && prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          removed.set(prevId, prev);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      return { changed, added, updated, removed, moved };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || typeof result === \"boolean\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2 = \"current\", opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupStackValueProperty(propName, scaleType, opts) {\n  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];\n}\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({ name: \"seriesRoot\", isVirtual: true });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this._pickNodeCache = new LRUCache();\n    const {\n      moduleCtx,\n      pickModes = [1 /* NEAREST_BY_MAIN_AXIS_FIRST */],\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-content`,\n        isVirtual: contentGroupVirtual,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.highlightGroup = new Group({\n      name: `${this.internalId}-highlight`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"highlight\")\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */\n      })\n    );\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"annotation\")\n    });\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(value) {\n    this.properties.visible = value;\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries({ id: internalId, type });\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ id: internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case \"data\":\n      case \"paths\":\n        break;\n      case \"labels\":\n        mainAdjust += 2e4;\n        break;\n      case \"marker\":\n        mainAdjust += 1e4;\n        break;\n      case \"highlight\":\n        subIndex += 15e3;\n        break;\n      case \"annotation\":\n        mainAdjust += 15e3;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction));\n    return seriesDomain.concat(moduleDomains.flat());\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.registerSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, intent, exactMatchOnly = false) {\n    const { pickModes, visible, rootGroup } = this;\n    if (!visible || !rootGroup.visible)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight-tooltip\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    let maxDistance = Infinity;\n    if (intent === \"tooltip\" || intent === \"highlight-tooltip\") {\n      const { tooltip } = this.properties;\n      maxDistance = typeof tooltip.range === \"number\" ? tooltip.range : Infinity;\n      exactMatchOnly || (exactMatchOnly = tooltip.range === \"exact\");\n    } else if (intent === \"event\") {\n      const { nodeClickRange } = this.properties;\n      maxDistance = typeof nodeClickRange === \"number\" ? nodeClickRange : Infinity;\n      exactMatchOnly || (exactMatchOnly = nodeClickRange === \"exact\");\n    }\n    const selectedPickModes = pickModes.filter(\n      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */\n    );\n    const { x, y } = point;\n    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });\n    if (this._pickNodeCache.has(key)) {\n      return this._pickNodeCache.get(key);\n    }\n    for (const pickMode of selectedPickModes) {\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_BY_MAIN_AXIS_FIRST */:\n        case 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */:\n          match = this.pickNodeMainAxisFirst(\n            point,\n            pickMode === 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */\n          );\n          break;\n        case 3 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n      }\n      if (match && match.distance <= maxDistance) {\n        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });\n      }\n    }\n    return this._pickNodeCache.set(key, void 0);\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.dispatch(\"visibility-changed\", { itemId, enabled });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n    }\n  }\n  getMinRects(_width, _height) {\n    return;\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nSeries.highlightedZIndex = 1e12;\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction convertValuesToScaleByDefs({\n  defs,\n  values,\n  xAxis,\n  yAxis\n}) {\n  if (!(xAxis && yAxis)) {\n    throw new Error(\"Axes must be defined\");\n  }\n  const result = {};\n  for (const [searchId, { def }] of defs) {\n    if (Object.hasOwn(values, searchId)) {\n      const { scale: scale2 } = def.type === \"key\" ? xAxis : yAxis;\n      result[searchId] = Math.round(scale2.convert(values[searchId]));\n    }\n  }\n  return result;\n}\nfunction pickNode(inputSeries, point, intent, exactMatchOnly) {\n  const reverseSeries = [...inputSeries].reverse();\n  let result;\n  for (const series of reverseSeries) {\n    if (!series.visible || !series.rootGroup.visible) {\n      continue;\n    }\n    const { match, distance: distance3 } = series.pickNode(point, intent, exactMatchOnly) ?? {};\n    if (!match || distance3 == null) {\n      continue;\n    }\n    if (!result || result.distance > distance3) {\n      result = { series, distance: distance3, datum: match };\n    }\n    if (distance3 === 0) {\n      break;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaClickManager.ts\nvar SeriesAreaClickManager = class extends BaseManager {\n  constructor(id, chart, ctx) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.series = [];\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    this.destroyFns.push(\n      this.ctx.regionManager.listenAll(\"click\", (event) => this.onClick(event)),\n      this.ctx.regionManager.listenAll(\"dblclick\", (event) => this.onClick(event)),\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      seriesRegion.addListener(\"leave\", () => this.onLeave()),\n      horizontalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      verticalAxesRegion.addListener(\"leave\", () => this.onLeave())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.lastHover = void 0;\n  }\n  preSceneRender() {\n    if (this.lastHover) {\n      this.onHover(this.lastHover);\n    }\n  }\n  update(type, opts) {\n    this.ctx.updateService.update(type, opts);\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.paddedRect;\n  }\n  onLeave() {\n    this.lastHover = void 0;\n    this.ctx.cursorManager.updateCursor(this.id);\n  }\n  onHover({ offsetX, offsetY }) {\n    const found = pickNode(this.series, { x: offsetX, y: offsetY }, \"event\");\n    if (found?.series.hasEventListener(\"nodeClick\") || found?.series.hasEventListener(\"nodeDoubleClick\")) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    } else {\n      this.ctx.cursorManager.updateCursor(this.id);\n    }\n  }\n  onClick(event) {\n    if (this.seriesRect?.containsPoint(event.offsetX, event.offsetY) && this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    const newEvent = { type: event.type === \"click\" ? \"click\" : \"doubleClick\", event: event.sourceEvent };\n    this.chart.fireEvent(newEvent);\n  }\n  checkSeriesNodeClick(event) {\n    const result = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, \"event\");\n    if (result == null)\n      return false;\n    if (event.type === \"click\") {\n      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    if (event.type === \"dblclick\") {\n      event.preventZoomDblClick = result.distance === 0;\n      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    return false;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(bboxOrPath) {\n  if (bboxOrPath instanceof BBox) {\n    return bboxOrPath.computeCenter();\n  }\n  return bboxOrPath?.computeTransformedBBox()?.computeCenter();\n}\nfunction drawPickedFocus(focusIndicator, pick) {\n  const { bounds, showFocusBox } = pick;\n  if (showFocusBox) {\n    focusIndicator?.updateBounds(bounds);\n  }\n}\nfunction makeKeyboardPointerEvent(focusIndicator, pick) {\n  drawPickedFocus(focusIndicator, pick);\n  const { x: offsetX, y: offsetY } = computeCenter(pick.bounds) ?? {};\n  if (offsetX !== void 0 && offsetY !== void 0) {\n    return { type: \"keyboard\", offsetX, offsetY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaFocusManager.ts\nvar SeriesAreaFocusManager = class extends BaseManager {\n  constructor(id, chart, ctx, chartType2, overlays) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.chartType = chartType2;\n    this.overlays = overlays;\n    this.series = [];\n    this.focus = {\n      hasFocus: false,\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.onAnimationStart()),\n      seriesRegion.addListener(\"blur\", () => this.onBlur()),\n      seriesRegion.addListener(\"tab\", (event) => this.onTab(event)),\n      seriesRegion.addListener(\"nav-vert\", (event) => this.onNavVert(event)),\n      seriesRegion.addListener(\"nav-hori\", (event) => this.onNavHori(event)),\n      seriesRegion.addListener(\"submit\", (event) => this.onSubmit(event)),\n      this.ctx.keyNavManager.addListener(\"browserfocus\", (event) => this.onBrowserFocus(event)),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.ctx.focusIndicator.updateBounds(void 0);\n      })\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n    this.onBlur();\n  }\n  dataChanged() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n  }\n  preSceneRender() {\n    this.refreshFocus();\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.rect;\n  }\n  refreshFocus() {\n    if (this.focus.hasFocus) {\n      this.handleSeriesFocus(0, 0);\n    }\n  }\n  onTab(event) {\n    this.handleFocus(0, 0);\n    event.preventDefault();\n    this.focus.hasFocus = true;\n  }\n  onNavVert(event) {\n    this.focus.seriesIndex += event.delta;\n    this.handleFocus(event.delta, 0);\n    event.preventDefault();\n  }\n  onNavHori(event) {\n    this.focus.datumIndex += event.delta;\n    this.handleFocus(0, event.delta);\n    event.preventDefault();\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = 0;\n      this.focus.seriesIndex = 0;\n    } else if (event.delta < 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = Infinity;\n      this.focus.seriesIndex = Infinity;\n    }\n  }\n  onAnimationStart() {\n    if (this.focus.hasFocus) {\n      this.onBlur();\n    }\n  }\n  onBlur() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n    this.focus.hasFocus = false;\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    this.focus.hasFocus = true;\n    const overlayFocus = this.overlays.getFocusInfo(this.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.ctx.focusIndicator.updateBounds(overlayFocus.rect);\n      this.ctx.ariaAnnouncementService.announceValue(overlayFocus.text);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    if (this.chartType === \"hierarchy\") {\n      this.handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta);\n      return;\n    }\n    const { focus, seriesRect, series } = this;\n    const visibleSeries = series.filter((s) => s.visible);\n    if (visibleSeries.length === 0)\n      return;\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta) {\n    this.focus.series = this.series[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series === void 0)\n      return;\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  updatePickedFocus(pick) {\n    const { focus } = this;\n    if (pick === void 0 || focus.series === void 0)\n      return;\n    const { datum, datumIndex } = pick;\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    const keyboardEvent = makeKeyboardPointerEvent(this.ctx.focusIndicator, pick);\n    if (keyboardEvent !== void 0) {\n      const html = focus.series.getTooltipHtml(datum);\n      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, datum);\n      const aria = this.getDatumAriaText(datum, html);\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n      this.ctx.ariaAnnouncementService.announceValue(\"ariaAnnounceHoverDatum\", { datum: aria });\n    }\n  }\n  onSubmit(event) {\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.chart.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    event.preventDefault();\n  }\n  getDatumAriaText(datum, html) {\n    const description = html.ariaLabel;\n    return datum.series.getDatumAriaText?.(datum, description) ?? description;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaHighlightManager.ts\nvar SeriesAreaHighlightManager = class extends BaseManager {\n  constructor(id, chart, ctx, highlight) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.highlight = highlight;\n    this.series = [];\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.pendingHoverEvent)\n        return;\n      if (this.chart.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      this.handleHover(false);\n    });\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const mouseMoveStates = 16 /* Default */ | 4 /* Annotations */;\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      this.ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      seriesRegion.addListener(\"drag\", (event) => this.onHover(event), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      // Cases where highlight should be cleared.\n      this.ctx.domManager.addListener(\"resize\", () => this.clearHighlight()),\n      seriesRegion.addListener(\"leave\", () => this.clearHighlight(), mouseMoveStates),\n      seriesRegion.addListener(\"blur\", () => this.clearHighlight()),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.clearHighlight()),\n      this.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearHighlight()),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearHighlight())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.stashedHoverEvent ?? (this.stashedHoverEvent = this.appliedHoverEvent);\n    this.clearHighlight();\n  }\n  preSceneRender() {\n    if (this.stashedHoverEvent != null) {\n      this.pendingHoverEvent = this.stashedHoverEvent;\n      this.stashedHoverEvent = void 0;\n      this.handleHover(true);\n    }\n  }\n  update(type, opts) {\n    this.ctx.updateService.update(type, opts);\n  }\n  layoutComplete(event) {\n    this.hoverRect = event.series.paddedRect;\n  }\n  clearHighlight() {\n    this.pendingHoverEvent = void 0;\n    this.appliedHoverEvent = void 0;\n    this.ctx.highlightManager.updateHighlight(this.id);\n  }\n  onHover(event) {\n    this.pendingHoverEvent = event;\n    this.hoverScheduler.schedule();\n  }\n  handleHover(redisplay) {\n    this.appliedHoverEvent = this.pendingHoverEvent;\n    this.pendingHoverEvent = void 0;\n    const event = this.appliedHoverEvent;\n    if (!event)\n      return;\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */)\n      return;\n    const { offsetX, offsetY } = event;\n    if (redisplay ? this.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearHighlight();\n      return;\n    }\n    const { range: range3 } = this.highlight;\n    const intent = range3 === \"tooltip\" ? \"highlight-tooltip\" : \"highlight\";\n    const found = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, intent);\n    if (found) {\n      this.ctx.highlightManager.updateHighlight(this.id, found.datum);\n      return;\n    }\n    this.ctx.highlightManager.updateHighlight(this.id);\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.ctx.cursorManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== \"default\" && newDatum) {\n      this.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaTooltipManager.ts\nvar SeriesAreaTooltipManager = class extends BaseManager {\n  constructor(id, chart, ctx, tooltip) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.tooltip = tooltip;\n    this.series = [];\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.lastHover)\n        return;\n      if (this.chart.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      this.handleHover(this.lastHover, false);\n    });\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      seriesRegion.addListener(\n        \"hover\",\n        (event) => this.onHover(event),\n        16 /* Default */ | 4 /* Annotations */\n      ),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      // Events that clear tooltip.\n      seriesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      seriesRegion.addListener(\"blur\", () => this.clearTooltip()),\n      seriesRegion.addListener(\"contextmenu\", () => this.clearTooltip(), 31 /* All */),\n      horizontalAxesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      verticalAxesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.clearTooltip()),\n      this.ctx.domManager.addListener(\"resize\", () => this.clearTooltip()),\n      this.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearTooltip()),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearTooltip())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n  }\n  preSceneRender() {\n    if (this.lastHover != null) {\n      this.handleHover(this.lastHover, true);\n    }\n  }\n  layoutComplete(event) {\n    this.hoverRect = event.series.paddedRect;\n  }\n  onHover(event) {\n    this.lastHover = event;\n    this.hoverScheduler.schedule();\n  }\n  clearTooltip() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.lastHover = void 0;\n  }\n  handleHover(event, redisplay) {\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */)\n      return;\n    const { offsetX, offsetY, targetElement } = event;\n    if (redisplay ? this.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearTooltip();\n      return;\n    }\n    if (targetElement && this.tooltip.interactive && this.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    const pick = pickNode(this.series, { x: offsetX, y: offsetY }, \"tooltip\");\n    if (!pick) {\n      this.clearTooltip();\n      return;\n    }\n    const html = pick.series.getTooltipHtml(pick.datum);\n    const tooltipEnabled = this.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && html != null;\n    if (shouldUpdateTooltip) {\n      const meta = TooltipManager.makeTooltipMeta(event, pick.datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts\nvar SeriesAreaManager = class extends BaseManager {\n  constructor(chart, ctx, chartType2, tooltip, highlight, overlays) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.series = [];\n    this.subManagers = [\n      new SeriesAreaFocusManager(this.id, chart, ctx, chartType2, overlays),\n      new SeriesAreaHighlightManager(this.id, chart, ctx, highlight),\n      new SeriesAreaTooltipManager(this.id, chart, ctx, tooltip),\n      new SeriesAreaClickManager(this.id, chart, ctx)\n    ];\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    this.destroyFns.push(\n      () => this.subManagers.forEach((s) => s.destroy()),\n      seriesRegion.addListener(\"contextmenu\", (event) => this.onContextMenu(event), 31 /* All */),\n      this.ctx.updateService.addListener(\"pre-scene-render\", () => this.preSceneRender())\n    );\n  }\n  dataChanged() {\n    for (const manager of this.subManagers) {\n      manager.dataChanged?.();\n    }\n  }\n  preSceneRender() {\n    for (const manager of this.subManagers) {\n      manager.preSceneRender?.();\n    }\n  }\n  seriesChanged(series) {\n    this.series = series;\n    for (const manager of this.subManagers) {\n      manager.seriesChanged(series);\n    }\n  }\n  onContextMenu(event) {\n    const { Default: Default2, ContextMenu } = InteractionState;\n    let pickedNode;\n    if (this.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {\n      const match = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, \"context-menu\");\n      if (match) {\n        this.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = match.datum;\n      }\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"series\", event, { pickedNode });\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot, highlightRoot, annotationRoot) {\n    this.seriesRoot = seriesRoot;\n    this.highlightRoot = highlightRoot;\n    this.annotationRoot = annotationRoot;\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      internalId,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.series[internalId] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);\n    }\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    const lookupIndex = this.lookupIdx(groupIndex);\n    let groupInfo = this.groups[type][lookupIndex];\n    if (!groupInfo) {\n      groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {\n        type,\n        id: lookupIndex,\n        seriesIds: [],\n        group: this.seriesRoot.appendChild(\n          new Group({\n            name: `${type}-content`,\n            layer: true,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"data\")\n          })\n        ),\n        highlight: this.highlightRoot.appendChild(\n          new Group({\n            name: `${type}-highlight`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"highlight\")\n          })\n        ),\n        annotation: this.annotationRoot.appendChild(\n          new Group({\n            name: `${type}-annotation`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"annotation\")\n          })\n        )\n      });\n    }\n    this.series[internalId] = { layerState: groupInfo, seriesConfig };\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series[internalId] != null) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\n    if (this.series[internalId] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series[internalId]?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.highlightRoot.removeChild(groupInfo.highlight);\n      this.annotationRoot.removeChild(groupInfo.annotation);\n      delete this.groups[groupInfo.type][groupInfo.id];\n      delete this.groups[type][internalId];\n    } else if (groupInfo?.seriesIds.length > 0) {\n      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"data\");\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"highlight\");\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"annotation\");\n    }\n    delete this.series[internalId];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.seriesRoot.removeChild(groupInfo.group);\n        this.highlightRoot.removeChild(groupInfo.highlight);\n        this.annotationRoot.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts\nvar BaseLayoutProcessor = class {\n  constructor(chartLike, layoutService) {\n    this.chartLike = chartLike;\n    this.layoutService = layoutService;\n    this.destroyFns = [];\n    this.destroyFns.push(\n      // eslint-disable-next-line sonarjs/no-duplicate-string\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionPadding(e)),\n      this.layoutService.addListener(\"layout-complete\", (e) => this.alignCaptions(e)),\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionCaptions(e))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  positionPadding(ctx) {\n    const { shrinkRect } = ctx;\n    const { padding } = this.chartLike;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    return { ...ctx, shrinkRect };\n  }\n  positionCaptions(ctx) {\n    const { shrinkRect, positions, padding } = ctx;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    const paddedShrinkRect = shrinkRect.clone().shrink(titlePadding);\n    const newShrinkRect = shrinkRect.clone();\n    const updateCaption = (caption) => {\n      const defaultCaptionHeight = shrinkRect.height / 10;\n      const captionLineHeight = caption.lineHeight ?? caption.fontSize * Text.defaultLineHeightRatio;\n      const maxWidth = shrinkRect.width;\n      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\n      caption.computeTextWrap(maxWidth, maxHeight);\n    };\n    const computeX = (align) => {\n      if (align === \"left\") {\n        return paddedShrinkRect.x;\n      } else if (align === \"right\") {\n        return paddedShrinkRect.x + paddedShrinkRect.width;\n      } else if (align !== \"center\") {\n        Logger.error(`invalid textAlign value: ${align}`);\n      }\n      return paddedShrinkRect.x + paddedShrinkRect.width / 2;\n    };\n    const positionTopAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"top\";\n      updateCaption(caption);\n      const bbox = caption.node.getBBox();\n      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"top\");\n        paddedShrinkRect.shrink(bboxHeight, \"top\");\n      }\n      return bbox;\n    };\n    const positionBottomAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y + paddedShrinkRect.height;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"bottom\";\n      updateCaption(caption);\n      const bbox = caption.node.getBBox();\n      const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"bottom\");\n        paddedShrinkRect.shrink(bboxHeight, \"bottom\");\n      }\n      return bbox;\n    };\n    title.node.visible = title.enabled;\n    subtitle.node.visible = subtitle.enabled;\n    footnote.node.visible = footnote.enabled;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      positions.title = positionTopAndShrinkBBox(title, spacing);\n    }\n    if (subtitle.enabled) {\n      positions.subtitle = positionTopAndShrinkBBox(subtitle, subtitle.spacing ?? 0);\n    }\n    if (footnote.enabled) {\n      positions.footnote = positionBottomAndShrinkBBox(footnote, footnote.spacing ?? 0);\n    }\n    padding.title = titlePadding;\n    return { ...ctx, shrinkRect: newShrinkRect, positions };\n  }\n  alignCaptions(ctx) {\n    const { rect } = ctx.series;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    for (const caption of [title, subtitle, footnote]) {\n      if (caption.layoutStyle !== \"overlay\")\n        continue;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = rect.x + titlePadding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.getBBox();\n        caption.node.x = rect.x + rect.width - bbox.width - titlePadding;\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow().catch((e) => Logger.errorOnce(e));\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  async updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom2 = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom2);\n      shouldRefresh = this.shouldRefresh(axis, zoom2);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom2) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom2);\n    return true;\n  }\n  getAxisWindow(axis, zoom2) {\n    const domain = axis.scale.getDomain?.();\n    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutService, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutService = layoutService;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.destroyFns.push(this.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    this.toggleOverlay(this.overlays.loading, rect, isLoading);\n    this.toggleOverlay(this.overlays.noData, rect, !isLoading && !hasData);\n    this.toggleOverlay(this.overlays.noVisibleSeries, rect, hasData && !anySeriesVisible);\n  }\n  toggleOverlay(overlay, seriesRect, visible) {\n    this.overlayElem.ariaHidden = (!visible).toString();\n    if (visible) {\n      const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n      this.overlayElem.appendChild(element2);\n    } else {\n      overlay.removeElement(() => {\n        this.overlayElem.innerText = \"\\xA0\";\n      }, this.animationManager);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new Group({ name: `${this.id}-series-root` });\n    this.highlightRoot = new Group({\n      name: `${this.id}-highlight-root`,\n      layer: true,\n      zIndex: 5 /* SERIES_HIGHLIGHT_ZINDEX */,\n      nonEmptyChildDerivedZIndex: true\n    });\n    this.annotationRoot = new Group({\n      name: `${this.id}-annotation-root`,\n      layer: true,\n      zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.titlePadding = 0;\n    this.seriesArea = new SeriesArea();\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n    this.keyboard = new Keyboard();\n    this.mode = \"standalone\";\n    this.destroyed = false;\n    this._skipSync = false;\n    this._destroyFns = [];\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    // FIXME: zoomManager should be owned by ctx, but it can't because it is used by CartesianChart.onAxisChange before ctx is initialised\n    this.zoomManager = new ZoomManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this.performUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error) {\n          Logger.error(\"update error\", error);\n        }\n      }).catch((e) => Logger.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this.onSeriesNodeClick = (event) => {\n      const seriesNodeClickEvent = {\n        ...event,\n        type: \"seriesNodeClick\"\n      };\n      Object.defineProperty(seriesNodeClickEvent, \"series\", {\n        enumerable: false,\n        // Should display the deprecation warning\n        get: () => event.series\n      });\n      this.fireEvent(seriesNodeClickEvent);\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      const seriesNodeDoubleClick = {\n        ...event,\n        type: \"seriesNodeDoubleClick\"\n      };\n      this.fireEvent(seriesNodeDoubleClick);\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.rootGroup.parent == null)\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        rootGroup: series.rootGroup,\n        highlightGroup: series.highlightGroup,\n        annotationGroup: series.annotationGroup,\n        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.dataProcessListeners = /* @__PURE__ */ new Set();\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container;\n    const root = new Group({ name: \"root\" });\n    const titleGroup = new Group({ name: \"titles\", layer: true, zIndex: 8 /* SERIES_LABEL_ZINDEX */ });\n    root.visible = false;\n    root.append(titleGroup);\n    root.append(this.seriesRoot);\n    root.append(this.highlightRoot);\n    root.append(this.annotationRoot);\n    titleGroup.append(this.title.node);\n    titleGroup.append(this.subtitle.node);\n    titleGroup.append(this.footnote.node);\n    const { overrideDevicePixelRatio } = options.specialOverrides;\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);\n    const ctx = this.ctx = new ChartContext(this, {\n      scene,\n      root,\n      syncManager: new SyncManager(this),\n      container,\n      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex,\n      overrideDevicePixelRatio\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new BaseLayoutProcessor(this, ctx.layoutService),\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutService,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const moduleContext = this.getModuleContext();\n    ctx.regionManager.addRegion(\"series\" /* SERIES */, this.seriesRoot, this.ctx.axisManager.axisGridGroup);\n    ctx.regionManager.addRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    ctx.regionManager.addRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const thisChart = this;\n    this.seriesAreaManager = new SeriesAreaManager(\n      {\n        fireEvent: this.fireEvent.bind(thisChart),\n        get performUpdateType() {\n          return thisChart.performUpdateType;\n        }\n      },\n      ctx,\n      this.getChartType(),\n      this.tooltip,\n      this.highlight,\n      this.overlays\n    );\n    ctx.regionManager.addRegion(\"root\", root);\n    this._destroyFns.push(\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext),\n      this.subtitle.registerInteraction(moduleContext),\n      this.footnote.registerInteraction(moduleContext),\n      ctx.interactionManager.addListener(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.series.map((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", { seriesCount: this.series.length });\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.zoomManager.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      await cb(this);\n      if (this.destroyed)\n        return;\n      this._pendingFactoryUpdatesCount--;\n    }).catch((e) => Logger.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this._skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    let updateDeferred = false;\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        await this.processData();\n        this.seriesAreaManager.dataChanged();\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        if (!this.checkFirstAutoSize(seriesToUpdate)) {\n          updateDeferred = true;\n          break;\n        }\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */:\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        const { seriesRect } = this;\n        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n        updateSplits(\"\\u{1F914}\");\n      case 5 /* PRE_SCENE_RENDER */:\n        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))\n          break;\n        ctx.updateService.dispatchPreSceneRender(this.getMinRects());\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });\n        this.extraDebugStats = {};\n        for (const key in splits) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!updateDeferred) {\n      ctx.updateService.dispatchUpdateComplete(this.getMinRects());\n    }\n    const end = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const { theme } = this.chartOptions.processedOptions;\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    } else if (typeof theme?.baseTheme === \"string\") {\n      themeClassName = theme.baseTheme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.baseTheme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);\n    setAttribute(this.ctx.scene.canvas.element, \"role\", \"img\");\n    setAttribute(this.ctx.scene.canvas.element, \"aria-label\", this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count + 1) ** 2 * 40;\n      if (count < 8) {\n        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });\n        this.debug(\"Chart.checkFirstAutoSize() - backing off until first size update\", backOffMs);\n        return false;\n      }\n      this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.parent == null) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels() {\n          return chart.placeLabels();\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n    this.seriesAreaManager?.seriesChanged(newValue);\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  updateAllSeriesListeners() {\n    this.series.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      this.addSeriesListeners(series);\n    });\n  }\n  assignSeriesToAxes() {\n    this.axes.forEach((axis) => {\n      axis.boundSeries = this.series.filter((s) => {\n        const seriesAxis = s.axes[axis.direction];\n        return seriesAxis === axis;\n      });\n    });\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          Logger.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width, height } = size;\n    width = Math.floor(width);\n    height = Math.floor(height);\n    if (width === 0 && height === 0)\n      return;\n    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];\n    if (autoWidth === width && authHeight === height)\n      return;\n    this._lastAutoSize = [width, height];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });\n    if (width == null || height == null || !isFiniteNumber(width) || !isFiniteNumber(height))\n      return;\n    if (scene.resize(width, height)) {\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.({ data: this.data }));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      const syncModule = this.modulesManager.getModule(\"sync\");\n      if (syncModule?.enabled) {\n        syncModule.syncAxes(this._skipSync);\n      } else {\n        this.assignSeriesToAxes();\n      }\n    }\n    const dataController = new DataController(this.mode);\n    const seriesPromises = this.series.map((s) => s.processData(dataController));\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.({ dataController }));\n    dataController.execute();\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const { legendType, legend } of this.modulesManager.legends()) {\n      legend.data = this.getLegendData(legendType, this.mode !== \"integrated\");\n    }\n    this.dataProcessListeners.forEach((resolve) => resolve());\n    this.dataProcessListeners.clear();\n  }\n  placeLabels() {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible)\n        continue;\n      const labelData = series.getLabelData();\n      if (isPointLabelDatum(labelData?.[0])) {\n        data.push(labelData);\n        visibleSeries.push(series);\n      }\n    }\n    const { seriesRect } = this;\n    const { top, right, bottom, left } = this.seriesArea.padding;\n    const labels = seriesRect && data.length > 0 ? placeLabels(data, {\n      x: -left,\n      y: -top,\n      width: seriesRect.width + left + right,\n      height: seriesRect.height + top + bottom\n    }) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  getLegendData(legendType, warnConflicts) {\n    var _a;\n    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n    const isCategoryLegendData = (data) => data.every((d) => d.legendType === \"category\");\n    if (warnConflicts && isCategoryLegendData(legendData)) {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbols: [{ marker }],\n        label\n      } of legendData) {\n        if (marker.fill == null)\n          continue;\n        const seriesType2 = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType2] ?? (seriesMarkerFills[seriesType2] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          Logger.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    return legendData;\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    await this.performLayout();\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async performLayout() {\n    const { width, height } = this.ctx.scene;\n    let ctx = { shrinkRect: new BBox(0, 0, width, height), positions: {}, padding: {} };\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"start-layout\", ctx);\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"before-series\", ctx);\n    for (const m of this.modulesManager.modules()) {\n      if (m.performLayout != null) {\n        ctx = await m.performLayout(ctx);\n      }\n    }\n    return ctx.shrinkRect;\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start = performance.now();\n    if (this._pendingFactoryUpdatesCount > 0) {\n      await this.updateMutex.waitForClearAcquireQueue();\n    }\n    while (this.performUpdateType !== 7 /* NONE */) {\n      if (performance.now() - start > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          Logger.warnOnce(message);\n        }\n      }\n      await sleep(50);\n    }\n    await this.updateMutex.waitForClearAcquireQueue();\n  }\n  waitForDataProcess(timeout) {\n    return new Promise((resolve) => {\n      this.dataProcessListeners.add(resolve);\n      if (isNumber(timeout)) {\n        setTimeout(() => {\n          if (this.dataProcessListeners.has(resolve)) {\n            this.dataProcessListeners.delete(resolve);\n            resolve();\n          }\n        }, timeout);\n      }\n    });\n  }\n  getMinRects() {\n    const { width, height } = this.ctx.scene;\n    const minRects = this.series.map((series) => series.getMinRects(width, height)).filter(isDefined);\n    if (minRects.length === 0)\n      return;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {\n      maxWidth = Math.max(maxWidth, minRect2.width);\n      maxHeight = Math.max(maxHeight, minRect2.height);\n      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);\n      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    let minVisibleRect = minRect.clone();\n    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {\n      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    }\n    return { minRect, minVisibleRect };\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const isDifferentOpts = newChartOptions !== this.chartOptions;\n    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};\n    const newOpts = newChartOptions.processedOptions;\n    const deltaOptions = newChartOptions.diffOptions(oldOpts);\n    if (deltaOptions == null)\n      return;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"locale.localeText\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series != null) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.listeners) {\n      this.updateAllSeriesListeners();\n    }\n    if (deltaOptions.locale?.localeText) {\n      this.modulesManager.getModule(\"locale\").localeText = deltaOptions.locale?.localeText;\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n    if (deltaOptions.initialState) {\n      this.applyInitialState(newChartOptions.userOptions.initialState);\n    }\n  }\n  applyInitialState(initialState) {\n    const {\n      ctx: { annotationManager, stateManager }\n    } = this;\n    if (initialState?.annotations != null) {\n      const annotations2 = initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations2);\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType2 } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType2);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      chart.series = optSeries.map((opts) => this.createSeries(opts));\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    for (const change of matchResult.changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\":\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default:\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n      }\n    }\n    for (let idx = 0; idx < seriesInstances.length; idx++) {\n      seriesInstances[idx]._declarationOrder = idx;\n    }\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    const axisGroups = {\n      [\"x\" /* X */]: [],\n      [\"y\" /* Y */]: []\n    };\n    chart.axes.forEach((axis) => axisGroups[axis.direction].push(axis.getRegionBBoxProvider()));\n    if (registerRegions) {\n      this.ctx.regionManager.updateRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */, ...axisGroups[\"x\" /* X */]);\n      this.ctx.regionManager.updateRegion(\"vertical-axes\" /* VERTICAL_AXES */, ...axisGroups[\"y\" /* Y */]);\n    }\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], _Chart.prototype, \"titlePadding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width, height } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar Marker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  computeBBox() {\n    const { x, y, size } = this;\n    const { center } = this.constructor;\n    return new BBox(x - size * center.x, y - size * center.y, size, size);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  applyPath(s, moves) {\n    const { path } = this;\n    let { x, y } = this;\n    if (this.repeat != null) {\n      x = 0;\n      y = 0;\n    }\n    path.clear();\n    for (const { x: mx, y: my, t } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === \"move\") {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeFill(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.fill(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeStroke(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.stroke(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n};\nMarker.center = { x: 0.5, y: 0.5 };\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], Marker.prototype, \"size\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"repeat\", 2);\n\n// packages/ag-charts-community/src/chart/marker/circle.ts\nvar Circle = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n};\nCircle.className = \"Circle\";\n\n// packages/ag-charts-community/src/chart/marker/cross.ts\nvar _Cross = class _Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, _Cross.moves);\n  }\n};\n_Cross.className = \"Cross\";\n_Cross.moves = [\n  { x: -1, y: 0, t: \"move\" },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 }\n];\nvar Cross = _Cross;\n\n// packages/ag-charts-community/src/chart/marker/diamond.ts\nvar _Diamond = class _Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _Diamond.moves);\n  }\n};\n_Diamond.className = \"Diamond\";\n_Diamond.moves = [\n  { x: 0, y: -1, t: \"move\" },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 }\n];\nvar Diamond = _Diamond;\n\n// packages/ag-charts-community/src/chart/marker/heart.ts\nvar Heart = class extends Marker {\n  rad(degree2) {\n    return degree2 / 180 * Math.PI;\n  }\n  updatePath() {\n    const { x, path, size, rad } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n};\nHeart.className = \"Heart\";\n\n// packages/ag-charts-community/src/chart/marker/pin.ts\nvar Pin = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const s = this.size;\n    const cx = 0.5;\n    const cy = 1;\n    path.clear();\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  }\n};\nPin.className = \"MapPin\";\nPin.center = { x: 0.5, y: 1 };\n\n// packages/ag-charts-community/src/chart/marker/plus.ts\nvar _Plus = class _Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, _Plus.moves);\n  }\n};\n_Plus.className = \"Plus\";\n_Plus.moves = [\n  { x: -0.5, y: -0.5, t: \"move\" },\n  { x: 0, y: -1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 }\n];\nvar Plus = _Plus;\n\n// packages/ag-charts-community/src/chart/marker/square.ts\nvar Square = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n};\nSquare.className = \"Square\";\n\n// packages/ag-charts-community/src/chart/marker/star.ts\nvar Star = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const spikes = 5;\n    const innerRadius = size / 2;\n    const rotation = Math.PI / 2;\n    path.clear();\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? size : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  }\n};\nStar.className = \"Star\";\n\n// packages/ag-charts-community/src/chart/marker/triangle.ts\nvar _Triangle = class _Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, _Triangle.moves);\n  }\n};\n_Triangle.className = \"Triangle\";\n_Triangle.moves = [\n  { x: 0, y: -0.48, t: \"move\" },\n  { x: 0.5, y: 0.87 },\n  { x: -1, y: 0 }\n];\nvar Triangle = _Triangle;\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  pin: Pin,\n  plus: Plus,\n  square: Square,\n  star: Star,\n  triangle: Triangle\n};\nvar MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.includes(shape);\n}\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === \"function\") {\n    return shape;\n  }\n  return Square;\n}\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.showFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return void 0;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return void 0;\n    }\n    const { showFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, showFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];\n      return !missing && enabled && focusable;\n    };\n    const searchBackward = (datumIndex2) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2--;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2++;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex);\n    } else {\n      datumIndex ?? (datumIndex = searchForward(clampedIndex));\n      datumIndex ?? (datumIndex = searchBackward(clampedIndex));\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return void 0;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], HighlightProperties.prototype, \"enabled\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlight = new HighlightProperties();\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.pickOutsideVisibleMinorAxis = false;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianSeriesProperties.prototype, \"pickOutsideVisibleMinorAxis\", 2);\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = [\"path\"],\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-dataNodes`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-markers`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"labels\")\n      })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.minRectsCache = {\n      dirtyNodeData: true\n    };\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = [];\n    for (let index = 0; index < pathsPerSeries.length; index++) {\n      this.paths[index] = new Path({ name: `${this.id}-${pathsPerSeries[index]}` });\n      this.paths[index].zIndex = 4 /* SERIES_LAYER_ZINDEX */;\n      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder(\"paths\", index);\n      this.contentGroup.appendChild(this.paths[index]);\n    }\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      markerSelectionGarbageCollection\n    );\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  async update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);\n    await this.updateSelections(visible);\n    await this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  async updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = await this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      this.minRectsCache.dirtyNodeData = true;\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    await this.updateSeriesSelections();\n  }\n  async updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    if (this.opts.hasMarkers) {\n      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === \"paths\") {\n      const [superFn] = result;\n      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;\n      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;\n    }\n    return result;\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.rootGroup.visible = animationEnabled || visible;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      await this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      await this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER_ZINDEX */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    await this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    await this.updateLabelNodes({ labelSelection });\n    if (hasMarkers) {\n      await this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  async updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = await this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width, height } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width, height);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = rootGroup.transformPoint(x, y);\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance3 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    const { pickOutsideVisibleMinorAxis } = this.properties;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter((a) => a instanceof CategoryAxis).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0) {\n      return;\n    }\n    const [majorDirection = \"x\" /* X */] = directions2;\n    const hitPoint = rootGroup.transformPoint(x, y);\n    const hitPointCoords = [hitPoint.x, hitPoint.y];\n    if (majorDirection !== \"x\" /* X */)\n      hitPointCoords.reverse();\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true) {\n        continue;\n      }\n      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];\n      if (majorDirection !== \"x\" /* X */)\n        visible.reverse();\n      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1]) {\n        continue;\n      }\n      const datumPoint = [datumX, datumY];\n      if (majorDirection !== \"x\" /* X */)\n        datumPoint.reverse();\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        }\n        if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\n   * between any two adjacent nodes.\n   */\n  getMinRects(width, height) {\n    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;\n    const newSizeCache = JSON.stringify({ width, height });\n    const dirtySize = newSizeCache !== sizeCache;\n    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {\n      return { minRect, minVisibleRect };\n    }\n    const rects = this.computeMinRects(width, height);\n    this.minRectsCache = {\n      dirtyNodeData: false,\n      sizeCache: newSizeCache,\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    };\n    return rects;\n  }\n  computeMinRects(width, height) {\n    const context = this._contextNodeData;\n    if (!context?.nodeData.length) {\n      return;\n    }\n    const { nodeData } = context;\n    const minRectXs = Array(nodeData.length);\n    const minRectYs = Array(nodeData.length);\n    for (const [i, { midPoint }] of nodeData.entries()) {\n      minRectXs[i] = midPoint?.x ?? 0;\n      minRectYs[i] = midPoint?.y ?? 0;\n    }\n    minRectXs.sort((a, b) => a - b);\n    minRectYs.sort((a, b) => a - b);\n    let zeroX, widthX, zeroY, heightY;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let i = 1; i < nodeData.length; i++) {\n      if (minRectXs[i] >= 0)\n        zeroX ?? (zeroX = i);\n      if (minRectXs[i] > width)\n        widthX ?? (widthX = i);\n      if (minRectYs[i] >= 0)\n        zeroY ?? (zeroY = i);\n      if (minRectYs[i] > height)\n        heightY ?? (heightY = i);\n      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);\n      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);\n    }\n    widthX ?? (widthX = nodeData.length);\n    heightY ?? (heightY = nodeData.length);\n    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];\n    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {\n      const x1 = minVisibleRectXs[i];\n      const x2 = minVisibleRectXs[i - 1];\n      const y1 = minVisibleRectYs[i];\n      const y2 = minVisibleRectYs[i - 1];\n      if (x1 != null && x2 != null) {\n        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);\n      }\n      if (y1 != null && y2 != null) {\n        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);\n      }\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    return { minRect, minVisibleRect };\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  async updateDatumNodes(_opts) {\n  }\n  async updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  async updateMarkerNodes(_opts) {\n  }\n  async updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  async updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetPathAnimation(data) {\n    const { path } = this.opts?.animationResetFns ?? {};\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n  }\n  resetDatumAnimation(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n  }\n  resetLabelAnimation(data) {\n    const { label } = this.opts?.animationResetFns ?? {};\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n  }\n  resetMarkerAnimation(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n  }\n  resetAllAnimation(data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.resetPathAnimation(data);\n    this.resetDatumAnimation(data);\n    this.resetLabelAnimation(data);\n    this.resetMarkerAnimation(data);\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    const animationData = this.getAnimationData();\n    if (!animationData)\n      return;\n    this.animationState.transition(\"clear\", animationData);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      if (axis.scale instanceof LogScale) {\n        const { range: range3, domain } = axis.scale;\n        result[direction] = {\n          type: \"log\",\n          convert: (d) => axis.scale.convert(d),\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const { range: range3 } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: \"continuous\",\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale) {\n        const { domain } = axis.scale;\n        result[direction] = {\n          type: \"category\",\n          domain,\n          range: domain.map((d) => axis.scale.convert(d))\n        };\n      }\n    }\n    return result;\n  }\n};\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar CartesianChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.firstSeriesTranslation = true;\n    this._lastCrossLineIds = void 0;\n    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();\n    this._lastClipSeries = false;\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    this.zoomManager.updateAxes(newValue);\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.firstSeriesTranslation = true;\n  }\n  getChartType() {\n    return \"cartesian\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;\n    const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);\n    this.seriesRoot.visible = visibility.series;\n    this.seriesRect = seriesRect;\n    this.animationRect = animationRect;\n    const { x, y } = seriesRect;\n    if (firstSeriesTranslation) {\n      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n      this.firstSeriesTranslation = false;\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, highlightRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    seriesRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    highlightRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    annotationRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries,\n      series: {\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect,\n        visible: visibility.series,\n        shouldFlipXY: this.shouldFlipXY()\n      },\n      axes: this.axes.map((axis) => axis.getLayoutState())\n    });\n    const modulePromises = this.modulesManager.mapModules((m) => m.performCartesianLayout?.({ seriesRect }));\n    await Promise.all(modulePromises);\n    return shrinkRect;\n  }\n  updateAxes(inputShrinkRect) {\n    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);\n    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);\n    let axisAreaWidths;\n    let clipSeries;\n    let visibility;\n    if (axesValid) {\n      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());\n      clipSeries = this._lastClipSeries;\n      visibility = { ...this._lastVisibility };\n    } else {\n      axisAreaWidths = /* @__PURE__ */ new Map();\n      clipSeries = false;\n      visibility = { crossLines: true, series: true };\n      this._lastCrossLineIds = crossLineIds;\n    }\n    const liveAxisWidths = new Set(this.axes.map((a) => a.position));\n    for (const position of axisAreaWidths.keys()) {\n      if (!liveAxisWidths.has(position)) {\n        axisAreaWidths.delete(position);\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {\n      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {\n        return false;\n      }\n      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {\n        return false;\n      }\n      return [...axisAreaWidths.entries()].every(([p, w]) => {\n        const otherW = otherAxisWidths.get(p);\n        if (w != null || otherW != null) {\n          return w === otherW;\n        }\n        return true;\n      });\n    };\n    const ceilValues = (map) => {\n      for (const [key, value] of map.entries()) {\n        if (value && Math.abs(value) === Infinity) {\n          map.set(key, 0);\n          continue;\n        }\n        map.set(key, value != null ? Math.ceil(value) : value);\n      }\n      return map;\n    };\n    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();\n    let lastPassVisibility = {};\n    let lastPassClipSeries = false;\n    let seriesRect = this.seriesRect?.clone();\n    let count = 0;\n    let primaryTickCounts = {};\n    do {\n      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());\n      clipSeries = lastPassClipSeries;\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisAreaWidths, inputShrinkRect.clone(), seriesRect);\n      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);\n      lastPassVisibility = result.visibility;\n      lastPassClipSeries = result.clipSeries;\n      ({ seriesRect, primaryTickCounts } = result);\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable axis layout.\");\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));\n    this.axes.forEach((axis) => {\n      axis.update(primaryTickCounts[axis.direction]);\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach((axis) => {\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(\n        seriesRect.x,\n        seriesRect.y,\n        seriesRect.width + clipRectPadding,\n        seriesRect.height + clipRectPadding\n      );\n      switch (axis.position) {\n        case \"left\":\n        case \"right\":\n          axis.clipTickLines(\n            inputShrinkRect.x,\n            seriesRect.y,\n            inputShrinkRect.width + clipRectPadding,\n            seriesRect.height + clipRectPadding\n          );\n          break;\n        case \"top\":\n        case \"bottom\":\n          axis.clipTickLines(\n            seriesRect.x,\n            inputShrinkRect.y,\n            seriesRect.width + clipRectPadding,\n            inputShrinkRect.height + clipRectPadding\n          );\n          break;\n      }\n    });\n    this._lastAxisAreaWidths = axisAreaWidths;\n    this._lastVisibility = visibility;\n    this._lastClipSeries = clipSeries;\n    return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };\n  }\n  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const axisGroups = /* @__PURE__ */ new Map();\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};\n    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);\n    for (const axis of this.axes) {\n      const { position = \"left\" } = axis;\n      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        paddedBounds,\n        primaryTickCounts,\n        clipSeries\n      });\n      axisWidths.set(axis.id, axisThickness);\n      if (!axisGroups.has(position))\n        axisGroups.set(position, []);\n      axisGroups.get(position)?.push(axis);\n      clipSeries = clipSeries || newClipSeries;\n    }\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups.entries()) {\n      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets));\n    }\n    for (const [position, axes] of axisGroups.entries()) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility, primaryTickCounts };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = {};\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    const reversedAxes = this.axes.slice().reverse();\n    directions.forEach((dir) => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = reversedAxes.find((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {\n    const result = bounds.clone();\n    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0) + horizontalPadding;\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisAreaWidths) {\n    const result = axisBound.clone();\n    result.x += axisAreaWidths.get(\"left\") ?? 0;\n    result.y += axisAreaWidths.get(\"top\") ?? 0;\n    result.width -= (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    result.height -= (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const { x, y, width, height } = seriesRect;\n    const clampBounds = [x, y, x + width, y + height];\n    const compareTo = clampBounds[(dimension === \"x\" ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    const clampFn = direction === 1 ? Math.min : Math.max;\n    return clampFn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    const { axis, seriesRect, paddedBounds, primaryTickCounts } = opts;\n    let { clipSeries } = opts;\n    const { position = \"left\", direction } = axis;\n    this.sizeAxis(axis, seriesRect, position);\n    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : void 0;\n    const isVertical = direction === \"y\" /* Y */;\n    const paddedBoundsCoefficient = 0.3;\n    if (axis.thickness) {\n      axis.maxThickness = axis.thickness;\n    } else {\n      axis.maxThickness = (isVertical ? paddedBounds.width : paddedBounds.height) * paddedBoundsCoefficient;\n    }\n    const layout = axis.calculateLayout(primaryTickCount);\n    primaryTickCount = layout.primaryTickCount;\n    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);\n    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n    let axisThickness;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    return { clipSeries, axisThickness, primaryTickCount };\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width, height } = seriesRect;\n    const minStart = 0;\n    const maxEnd = isLeftRight ? height : width;\n    let start = minStart;\n    let end = maxEnd;\n    const { width: axisWidth, unit, align } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end = start + axisWidth;\n    } else {\n      end = end * axisWidth / 100;\n    }\n    if (align === \"end\") {\n      start = maxEnd - (end - start);\n      end = maxEnd;\n    }\n    if (isCategory && isLeftRight) {\n      [min, max] = [1 - max, 1 - min];\n    } else if (isLeftRight) {\n      [start, end] = [end, start];\n    }\n    axis.range = [start, end];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width : height;\n  }\n  calculateAxisArea(axes, axisWidths, axisOffsets) {\n    let totalAxisWidth = 0;\n    let currentOffset = 0;\n    for (const axis of axes) {\n      axisOffsets.set(axis.id, currentOffset);\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n      if (axis.layoutConstraints.stacked) {\n        currentOffset += axisThickness + 15;\n      }\n    }\n    return totalAxisWidth;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    let axisBoundMainOffset = 0;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n      axisBoundMainOffset += 1;\n    }\n    axisBoundMainOffset += axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.updatePosition();\n    }\n  }\n  shouldFlipXY() {\n    return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));\n  }\n};\nCartesianChart.className = \"CartesianChart\";\nCartesianChart.type = \"cartesian\";\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi, licenseManager) {\n    this.factoryApi = factoryApi;\n    this.licenseManager = licenseManager;\n    this.chart = chart;\n    chart.publicApi = this;\n  }\n  static isInstance(x) {\n    if (x instanceof _AgChartInstanceProxy) {\n      return true;\n    }\n    if (x.constructor?.name === \"AgChartInstanceProxy\" && x.chart != null) {\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    const chartProps = [\"getOptions\", \"destroy\"];\n    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});\n    return chartProps.every((prop) => signatureProps.includes(prop));\n  }\n  async update(options) {\n    this.factoryApi.createOrUpdate(options, this);\n    await this.chart.waitForUpdate();\n  }\n  async updateDelta(deltaOptions) {\n    this.factoryApi.updateUserDelta(this, deltaOptions);\n    await this.chart.waitForUpdate();\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key in options) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      clone.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      return clone.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  getState() {\n    return this.factoryApi.caretaker.save(this.chart.ctx.annotationManager);\n  }\n  async setState(state) {\n    this.factoryApi.caretaker.restore(state, this.chart.ctx.annotationManager);\n    await this.chart.waitForUpdate();\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    this.chart.publicApi = void 0;\n    this.chart.destroy();\n  }\n  async prepareResizedChart(proxy, opts = {}) {\n    const { chart } = proxy;\n    const width = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const state = proxy.getState();\n    const isEnterprise = moduleRegistry.hasEnterpriseModules();\n    const overrideOptions = {};\n    const processedOptions = chart.chartOptions.getOptions();\n    if (isEnterprise) {\n      overrideOptions.animation = { enabled: false };\n      if (isAgCartesianChartOptions(processedOptions)) {\n        overrideOptions.toolbar = { enabled: false };\n      }\n      if (this.licenseManager?.isDisplayWatermark()) {\n        overrideOptions.foreground = {\n          text: this.licenseManager.getWatermarkMessage(),\n          image: {\n            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,\n            width: 170,\n            height: 25,\n            right: 25,\n            bottom: 50,\n            opacity: 0.7\n          }\n        };\n      }\n    }\n    const options = mergeDefaults(\n      {\n        container: document.createElement(\"div\"),\n        width,\n        height\n      },\n      overrideOptions,\n      processedOptions\n    );\n    const cloneProxy = await this.factoryApi.createOrUpdate(options);\n    await cloneProxy.setState(state);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"agChartV2\", chart.ctx.zoomManager.getZoom());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    const count = this.tickCount ?? ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start, stop) {\n    return this.interval ?? tickStep(start, stop, this.tickCount, this.minTickCount, this.maxTickCount);\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   */\n  updateNiceDomain() {\n    const count = this.tickCount;\n    if (count < 1) {\n      this.niceDomain = [...this.domain];\n      return;\n    }\n    let [start, stop] = this.domain;\n    if (count === 1) {\n      [start, stop] = niceTicksDomain(start, stop);\n    } else {\n      const roundStart = start > stop ? Math.ceil : Math.floor;\n      const roundStop = stop < start ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start;\n        const prev1 = stop;\n        const step = this.getTickStep(start, stop);\n        const [d0, d1] = this.domain;\n        if (step >= 1) {\n          start = roundStart(d0 / step) * step;\n          stop = roundStop(d1 / step) * step;\n        } else {\n          const s = 1 / step;\n          start = roundStart(d0 * s) / s;\n          stop = roundStop(d1 * s) / s;\n        }\n        if (start === prev0 && stop === prev1) {\n          break;\n        }\n      }\n    }\n    this.niceDomain = [start, stop];\n  }\n  tickFormat({ ticks: specifiedTicks, specifier }) {\n    return tickFormat(specifiedTicks ?? this.ticks(), specifier);\n  }\n};\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start, stop] = findMinMax(domain);\n  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);\n  const step = getTickStep(start, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start + segments * step;\n  const d = reverse ? [stop, start] : [start, stop];\n  const ticks = getTicks(start, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error(\"AG Charts - dataDomain not calculated, cannot perform tick calculation.\");\n    }\n    if (this.dataDomain.domain.length === 0) {\n      return [];\n    }\n    const { domain, ticks } = calculateNiceSecondaryAxis(\n      this.dataDomain.domain,\n      primaryTickCount ?? 0,\n      this.reverse\n    );\n    this.scale.nice = false;\n    this.scale.domain = domain;\n    this.scale.update();\n    return ticks;\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent2[0] > extent2[1];\n    const crossesZero = extent2[0] < 0 && extent2[1] > 0;\n    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      if (crossesZero) {\n        Logger.warn(\n          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n        );\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent2[0] === 0) {\n      extent2[0] = 1;\n    }\n    if (extent2[1] === 0) {\n      extent2[1] = -1;\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = (extent(d) ?? [0, 1e3]).map((x) => new Date(x));\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });\n    }\n  }\n  calculatePadding() {\n    return [0, 0];\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/util/corner.ts\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width, height);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width, height, topLeftCornerRadius);\n    return;\n  }\n  if (width < 0) {\n    x += width;\n    width = Math.abs(width);\n  }\n  if (height < 0) {\n    y += height;\n    height = Math.abs(height);\n  }\n  if (width <= 0 || height <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width, height);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height, maxHorizontalCornerRadius / width, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width - bottomRightCornerRadius;\n    const cy = y + height - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath;\n    this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      this.hittester = (hitX, hitY) => {\n        const point = this.transformPoint(hitX, hitY);\n        return this.getBBox().containsPoint(point.x, point.y);\n      };\n      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width, height, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width, height);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke, effectiveStrokeWidth } = this;\n    if (stroke && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx, zIndex = 0 /* SERIES_BACKGROUND_ZINDEX */, layer = false) {\n    super();\n    this.zIndex = zIndex;\n    this.layer = layer;\n    this.rectNode = new Rect();\n    this.textNode = new Text();\n    this.fill = \"white\";\n    this.node = new Group({ name: \"background\", zIndex: this.zIndex, layer: this.layer });\n    this.node.append([this.rectNode, this.textNode]);\n    this.visible = true;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  onLayoutComplete(e) {\n    const { width, height } = e.chart;\n    this.rectNode.width = width;\n    this.rectNode.height = height;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"textNode\")\n], Background.prototype, \"text\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Background(ctx)\n};\n\n// packages/ag-charts-community/src/scene/spriteRenderer.ts\nvar SpriteRenderer = class {\n  constructor() {\n    this.offscreenCanvas = new OffscreenCanvas(1, 1);\n    const ctx = this.offscreenCanvas.getContext(\"2d\");\n    if (ctx == null)\n      throw new TypeError(`AG Charts - invalid 2d context`);\n    this.renderCtx = {\n      ctx,\n      devicePixelRatio: 1,\n      forceRender: true,\n      resized: false,\n      debugNodes: {}\n    };\n  }\n  resize({ spritePixelRatio, spriteWidth, spriteHeight }) {\n    this.offscreenCanvas.width = Math.max(spriteWidth, 0) * spritePixelRatio;\n    this.offscreenCanvas.height = Math.max(spriteHeight, 0) * spritePixelRatio;\n  }\n  renderSprite(nodes, opts) {\n    nodes = toIterable(nodes);\n    const {\n      renderCtx,\n      renderCtx: { ctx },\n      offscreenCanvas\n    } = this;\n    const { scale: scale2 = 1, translateX = 0, translateY = 0 } = opts ?? {};\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.save();\n    ctx.beginPath();\n    ctx.setTransform(scale2, 0, 0, scale2, translateX, translateY);\n    for (const node of nodes) {\n      node.render(renderCtx);\n    }\n    ctx.closePath();\n    ctx.restore();\n    return offscreenCanvas.transferToImageBitmap();\n  }\n};\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, button, type, listener) {\n  button.addEventListener(type, listener);\n  destroyFns.push(() => button.removeEventListener(type, listener));\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initToolbarKeyNav(opts) {\n  const { orientation, toolbar, buttons, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const ariaHidden = buttons.length === 0;\n  toolbar.role = \"toolbar\";\n  toolbar.ariaOrientation = orientation;\n  toolbar.ariaHidden = ariaHidden.toString();\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[i - 1];\n    const curr = buttons[i];\n    const next = buttons[i + 1];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nfunction initMenuKeyNav(opts) {\n  const { orientation, menu, buttons, onEscape } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(buttons.length + i - 1) % buttons.length];\n    const curr = buttons[i];\n    const next = buttons[(buttons.length + i + 1) % buttons.length];\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = -1;\n  }\n  menu.tabIndex = -1;\n  if (onEscape)\n    addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  return destroyFns;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio2 = n / bboxIndex;\n      if (ratio2 < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.sourceImage = sourceImage;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n  }\n  updateBitmap(newBitmap, bitmapPixelRatio, x, y) {\n    this.sourceImage = newBitmap;\n    this.width = newBitmap.width / bitmapPixelRatio;\n    this.height = newBitmap.height / bitmapPixelRatio;\n    this.x = x / bitmapPixelRatio;\n    this.y = y / bitmapPixelRatio;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped++;\n      return;\n    }\n    const image = this.sourceImage;\n    if (!image)\n      return;\n    this.transformRenderContext(renderCtx);\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/chart/legendMarkerLabel.ts\nvar LegendMarkerLabel = class extends Group {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.label = new Text();\n    this.symbolsGroup = new Group({\n      name: \"legend-markerLabel-symbols\"\n    });\n    this.bitmap = new Image();\n    this.bitmapDirty = true;\n    this.enabled = true;\n    this.pageIndex = NaN;\n    this._markers = [];\n    this._lines = [];\n    const { markers, label, lines } = this;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n    this.updateSymbols(markers, lines);\n    this.append(argsIterable(this.symbolsGroup, label));\n  }\n  destroy() {\n    super.destroy();\n    this.proxyButton?.remove();\n  }\n  get markers() {\n    return this._markers;\n  }\n  get lines() {\n    return this._lines;\n  }\n  updateSymbols(markers, lines) {\n    if (arraysEqual(this._markers, markers) && arraysEqual(this._lines, lines))\n      return;\n    this.bitmapDirty = true;\n    this._markers = markers;\n    this._lines = lines;\n    this.symbolsGroup.clear();\n    this.symbolsGroup.append([this.bitmap, ...markers, ...lines]);\n  }\n  setEnabled(enabled) {\n    this.enabled = enabled;\n    this.refreshVisibilities();\n  }\n  refreshVisibilities() {\n    const opacity = this.enabled ? 1 : 0.5;\n    this.label.opacity = opacity;\n    this.opacity = opacity;\n    this.bitmap.opacity = opacity;\n    this.setBitmapVisibility(!this.enabled);\n  }\n  setBitmapVisibility(visible) {\n    const { lines, markers } = this;\n    [lines, markers].forEach((shapes) => shapes.forEach((shape) => shape.visible = !visible));\n    this.bitmap.visible = visible;\n  }\n  // The BBox of this.bitmap is `spritePadding` pixels bigger in each direction than BBox of the markers and lines.\n  // This padding allows the SpriteRenderer to draw antialiasing pixels that can extend beyond the shapes' bounds.\n  update(spriteRenderer, { spriteAAPadding, spritePixelRatio: scale2 }, dimensionProps) {\n    const { markers, lines } = this;\n    let spriteX = 0;\n    let spriteY = 0;\n    let shift = 0;\n    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {\n      const { length: length2, spacing } = dimensionProps[i] ?? 0;\n      const marker = markers[i];\n      const line = lines[i];\n      const size = marker?.size ?? 0;\n      let lineTop = Infinity;\n      let markerTop = Infinity;\n      let markerLeft = Infinity;\n      if (marker) {\n        const center = marker.constructor.center;\n        const radius = (size + marker.strokeWidth) / 2;\n        marker.x = (center.x - 0.5) * size + length2 / 2 + shift;\n        marker.y = (center.y - 0.5) * size;\n        markerTop = marker.y - radius;\n        markerLeft = marker.x - radius;\n      }\n      if (line) {\n        line.x1 = shift;\n        line.x2 = shift + length2;\n        line.y1 = 0;\n        line.y2 = 0;\n        line.markDirtyTransform();\n        lineTop = -line.strokeWidth / 2;\n      }\n      shift += spacing + Math.max(length2, size);\n      spriteX = Math.min(spriteX, line.x1, line.x2, markerLeft);\n      spriteY = Math.min(spriteY, lineTop, markerTop);\n    }\n    const lastSymbolProps = dimensionProps.at(-1);\n    const lastLine = this.lines.at(-1);\n    const lastMarker = this.markers.at(-1);\n    const lineEnd = lastLine ? lastLine.x2 : -Infinity;\n    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;\n    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);\n    if (this.bitmapDirty) {\n      this.setBitmapVisibility(false);\n      const translateX = (spriteAAPadding + spriteX) * scale2;\n      const translateY = (spriteAAPadding - spriteY) * scale2;\n      const sprite = spriteRenderer.renderSprite(this.symbolsGroup, {\n        scale: scale2,\n        translateX: Math.floor(translateX),\n        translateY: Math.floor(translateY)\n      });\n      this.bitmap.updateBitmap(sprite, scale2, Math.ceil(-translateX), Math.ceil(-translateY));\n      this.bitmapDirty = false;\n      this.refreshVisibilities();\n    }\n    if (dimensionProps.length < 2) {\n      return;\n    }\n    const bbox = this.symbolsGroup.getBBox();\n    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);\n    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);\n    this.symbolsGroup.setClipRectInGroupCoordinateSpace(clipRect);\n  }\n  computeBBox() {\n    const { label, lines, markers } = this;\n    return Group.computeBBox(arraysIterable([label], lines, markers), { skipInvisible: false });\n  }\n};\nLegendMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], LegendMarkerLabel.prototype, \"color\", 2);\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback, regionManager, cursorManager) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.regionManager = regionManager;\n    this.cursorManager = cursorManager;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new Group({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.destroyFns = [];\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    const region = this.regionManager.addRegion(\"pagination\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"click\", (event) => this.onPaginationClick(event)),\n      region.addListener(\"hover\", (event) => this.onPaginationMouseMove(event))\n    );\n    this.update();\n    this.updateMarkers();\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.getBBox();\n    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { size } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  nextButtonContainsPoint(offsetX, offsetY) {\n    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\n  }\n  previousButtonContainsPoint(offsetX, offsetY) {\n    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\n  }\n  clickNext() {\n    this.incrementPage();\n    this.onPaginationChanged();\n  }\n  clickPrevious() {\n    this.decrementPage();\n    this.onPaginationChanged();\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, this.totalPages - 1);\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  onPaginationClick(event) {\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.clickNext();\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.clickPrevious();\n    }\n  }\n  onPaginationMouseMove(event) {\n    const { offsetX, offsetY } = event;\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"next\";\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"previous\";\n    } else {\n      this.cursorManager.updateCursor(this.id);\n      this.highlightActive = void 0;\n    }\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker2 = getMarker(this.marker.shape || Triangle);\n    this.previousButton = new Marker2();\n    this.nextButton = new Marker2();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  getBBox() {\n    return this.group.getBBox(true);\n  }\n  computeCSSBounds() {\n    const prev = this._previousButton.computeTransformedBBox();\n    const next = this._nextButton.computeTransformedBBox();\n    return { prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.parent?.onMarkerShapeChange())\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new Group({ name: \"legend\", layer: true, zIndex: 13 /* LEGEND_ZINDEX */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      LegendMarkerLabel\n    );\n    this.spriteRenderer = new SpriteRenderer();\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.destroyFns = [];\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page),\n      ctx.regionManager,\n      ctx.cursorManager\n    );\n    this.pagination.attachPagination(this.group);\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_VISIBILITY,\n      type: \"legend\",\n      label: \"contextMenuToggleSeriesVisibility\",\n      action: (params) => this.contextToggleVisibility(params)\n    });\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_OTHER_SERIES,\n      type: \"legend\",\n      label: \"contextMenuToggleOtherSeries\",\n      action: (params) => this.contextToggleOtherSeries(params)\n    });\n    const { Default: Default2, Animation: Animation2, ContextMenu } = InteractionState;\n    const animationState = Default2 | Animation2;\n    const contextMenuState = Default2 | Animation2 | ContextMenu;\n    const region = ctx.regionManager.addRegion(\"legend\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"contextmenu\", (e) => this.checkContextClick(e), contextMenuState),\n      region.addListener(\"click\", (e) => this.checkLegendClick(e), animationState),\n      region.addListener(\"dblclick\", (e) => this.checkLegendDoubleClick(e), animationState),\n      region.addListener(\"hover\", (e) => this.handleLegendMouseMove(e), animationState),\n      region.addListener(\"leave\", () => this.handleLegendMouseExit(), animationState),\n      region.addListener(\"enter\", (e) => this.handleLegendMouseEnter(e), animationState),\n      ctx.layoutService.addListener(\"start-layout\", (e) => this.positionLegend(e)),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged()),\n      () => this.group.parent?.removeChild(this.group)\n    );\n    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `${this.id}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      id: `${this.id}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n  }\n  set data(value) {\n    this._data = value;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.pagination.destroy();\n    this.itemSelection.clear();\n  }\n  initLegendItemToolbar() {\n    this.itemSelection.each((markerLabel, _, i) => {\n      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"button\",\n        id: `ag-charts-legend-item-${i}`,\n        textContent: this.getItemAriaText(i),\n        parent: this.proxyLegendToolbar,\n        focusable: markerLabel,\n        // Retrieve the datum from the node rather than from the method parameter.\n        // The method parameter `datum` gets destroyed when the data is refreshed\n        // using Series.getLegendData(). But the scene node will stay the same.\n        onclick: () => {\n          this.doClick(markerLabel.datum);\n          markerLabel.proxyButton.textContent = this.getItemAriaText(i, !markerLabel.datum.enabled);\n        },\n        onblur: () => this.handleLegendMouseExit(),\n        onfocus: () => {\n          const bounds = markerLabel?.computeTransformedBBox();\n          const event = makeKeyboardPointerEvent(this.ctx.focusIndicator, { bounds, showFocusBox: true });\n          this.doHover(event, markerLabel.datum);\n          this.pagination.setPage(markerLabel.pageIndex);\n        }\n      }));\n    });\n    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton).filter((button) => !!button);\n    initToolbarKeyNav({\n      orientation: this.getOrientation(),\n      buttons,\n      toolbar: this.proxyLegendToolbar\n    });\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(this.group, 2 /* MINOR */);\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width, height) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    const proxyToolbarNeedsUpdate = this.itemSelection.nodes().length === 0;\n    this.itemSelection.update(data);\n    if (proxyToolbarNeedsUpdate) {\n      this.initLegendItemToolbar();\n    }\n    const bboxes = [];\n    const font = TextUtils.toFontString(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width * itemMaxWidthPercentage;\n    const spriteDims = this.calculateSpriteDimensions();\n    this.spriteRenderer.resize(spriteDims);\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, spriteDims);\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);\n      bboxes.push(markerLabel.getBBox());\n    });\n    width = Math.max(1, width);\n    height = Math.max(1, height);\n    if (!isFinite(width)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width;\n    size[1] = height;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  calcSymbolsEnabled(symbol) {\n    const { showSeriesStroke, marker } = this.item;\n    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    return { markerEnabled, lineEnabled };\n  }\n  calcSymbolsLengths(symbol) {\n    const { marker, line } = this.item;\n    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);\n    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth };\n  }\n  calculateSpriteDimensions() {\n    let spriteAAPadding = 0;\n    let spriteWidth = 0;\n    let spriteHeight = 0;\n    let markerWidth = 0;\n    this.itemSelection.each((_, datum) => {\n      datum.symbols.forEach((symbol) => {\n        const { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth } = this.calcSymbolsLengths(symbol);\n        const markerTotalLength = markerLength + markerStrokeWidth;\n        markerWidth = Math.max(markerWidth, lineLength, markerLength);\n        spriteWidth = Math.max(spriteWidth, lineLength, markerTotalLength);\n        spriteHeight = Math.max(spriteHeight, lineStrokeWidth, markerTotalLength);\n        spriteAAPadding = Math.max(spriteAAPadding, markerStrokeWidth + 0.5);\n      });\n    });\n    spriteWidth += spriteAAPadding * 2;\n    spriteHeight += spriteAAPadding * 2;\n    const spritePixelRatio = getWindow().devicePixelRatio;\n    return { spritePixelRatio, spriteAAPadding, spriteWidth, spriteHeight, markerWidth };\n  }\n  updateMarkerLabel(markerLabel, datum, spriteDims) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const { markerWidth } = spriteDims;\n    const dimensionProps = [];\n    let paddedSymbolWidth = paddingX;\n    if (markerLabel.markers.length !== datum.symbols.length && markerLabel.lines.length !== datum.symbols.length) {\n      const markers = [];\n      const lines = [];\n      datum.symbols.forEach((symbol) => {\n        const { shape: markerShape = symbol.marker.shape } = itemMarker;\n        const MarkerCtr = getMarker(markerShape);\n        lines.push(new Line());\n        markers.push(new MarkerCtr());\n      });\n      markerLabel.updateSymbols(markers, lines);\n    }\n    datum.symbols.forEach((symbol, i) => {\n      const spacing = symbol.marker.padding ?? itemMarker.padding;\n      const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;\n      dimensionProps.push({ length: markerWidth, spacing });\n      if (markerEnabled || lineEnabled) {\n        paddedSymbolWidth += spacing + markerWidth;\n      }\n      const marker = markerLabel.markers[i];\n      const line = markerLabel.lines[i];\n      if (marker) {\n        const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);\n        marker.fill = fill;\n        marker.stroke = stroke;\n        marker.strokeWidth = strokeWidth;\n        marker.fillOpacity = fillOpacity;\n        marker.strokeOpacity = strokeOpacity;\n      }\n      if (line) {\n        const lineStyles = this.getLineStyles(symbol);\n        line.stroke = lineStyles.stroke;\n        line.strokeOpacity = lineStyles.strokeOpacity;\n        line.strokeWidth = lineStyles.strokeWidth;\n        line.lineDash = lineStyles.lineDash;\n      }\n    });\n    markerLabel.update(this.spriteRenderer, spriteDims, dimensionProps);\n    return paddedSymbolWidth;\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = text.substring(0, maxCharLength);\n      addEllipsis = true;\n    }\n    const measurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const result = TextWrapper.truncateLine(text, measurer, maxItemWidth - paddedMarkerWidth, addEllipsis);\n    if (result.endsWith(TextUtils.EllipsisChar)) {\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return result;\n  }\n  updatePagination(bboxes, width, height) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width,\n      height\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  updateItemProxyButtons() {\n    this.itemSelection.each((markerLabel) => {\n      const bbox = markerLabel.computeTransformedBBox()?.clone();\n      bbox.translate(this.group.translationX, this.group.translationY);\n      setElementBBox(markerLabel.proxyButton, bbox);\n    });\n  }\n  updatePaginationProxyButtons(oldPages) {\n    this.proxyLegendPagination.style.display = this.pagination.visible ? \"absolute\" : \"none\";\n    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;\n    const newNeedsButtons = this.pages.length > 1;\n    if (oldNeedsButtons !== newNeedsButtons) {\n      if (newNeedsButtons) {\n        this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-prev-page`,\n          textContent: { id: \"ariaLabelLegendPagePrevious\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          focusable: this.pagination.previousButton,\n          onclick: () => this.pagination.clickPrevious()\n        });\n        this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-next-page`,\n          textContent: { id: \"ariaLabelLegendPageNext\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          focusable: this.pagination.nextButton,\n          onclick: () => this.pagination.clickNext()\n        }));\n      } else {\n        this.proxyNextButton?.remove();\n        this.proxyPrevButton?.remove();\n        [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];\n      }\n    }\n    const { prev, next } = this.pagination.computeCSSBounds();\n    setElementBBox(this.proxyPrevButton, prev);\n    setElementBBox(this.proxyNextButton, next);\n  }\n  calculatePagination(bboxes, width, height) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.getBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      lastPassPaginationBBox = this.pagination.getBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex;\n      let rowIndex;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n    });\n  }\n  updatePageNumber(pageNumber) {\n    const { pages } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.setEnabled(datum.enabled);\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const { toggleSeries } = this;\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_VISIBILITY, toggleSeries);\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_OTHER_SERIES, toggleSeries);\n  }\n  getLineStyles(datum) {\n    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth\n    };\n  }\n  getDatumForPoint(x, y) {\n    const visibleChildBBoxes = [];\n    const closestLeftTop = { dist: Infinity, datum: void 0 };\n    for (const child of this.group.children) {\n      if (!child.visible)\n        continue;\n      if (!(child instanceof LegendMarkerLabel))\n        continue;\n      const childBBox = child.getBBox().clone();\n      childBBox.grow(this.item.paddingX / 2, \"horizontal\");\n      childBBox.grow(this.item.paddingY / 2, \"vertical\");\n      if (childBBox.containsPoint(x, y)) {\n        return child.datum;\n      }\n      const distX = x - childBBox.x - this.item.paddingX / 2;\n      const distY = y - childBBox.y - this.item.paddingY / 2;\n      const dist = distX ** 2 + distY ** 2;\n      const toTheLeftTop = distX >= 0 && distY >= 0;\n      if (toTheLeftTop && dist < closestLeftTop.dist) {\n        closestLeftTop.dist = dist;\n        closestLeftTop.datum = child.datum;\n      }\n      visibleChildBBoxes.push(childBBox);\n    }\n    const pageBBox = BBox.merge(visibleChildBBoxes);\n    if (!pageBBox.containsPoint(x, y)) {\n      return;\n    }\n    return closestLeftTop.datum;\n  }\n  computePagedBBox() {\n    let actualBBox = this.group.getBBox();\n    if (this.pages.length <= 1) {\n      return actualBBox;\n    }\n    const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n    actualBBox = actualBBox.clone();\n    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    return actualBBox;\n  }\n  contextToggleVisibility(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doClick(datum);\n  }\n  contextToggleOtherSeries(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doDoubleClick(datum);\n  }\n  checkContextClick(event) {\n    const legendItem = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", event, { legendItem });\n  }\n  checkLegendClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(datum) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      const status = newEnabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\";\n      this.ctx.ariaAnnouncementService.announceValue(status);\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemClick?.({ type: \"click\", enabled: newEnabled, itemId, seriesId: series.id });\n    return true;\n  }\n  checkLegendDoubleClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doDoubleClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemDoubleClick?.({ type: \"dblclick\", enabled: true, itemId, seriesId: series.id });\n    return true;\n  }\n  handleLegendMouseMove(event) {\n    if (!this.enabled) {\n      return;\n    }\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    this.doHover(event, datum);\n  }\n  doHover(event, datum) {\n    const { toggleSeries, listeners } = this;\n    if (event === void 0 || datum === void 0) {\n      this.ctx.cursorManager.updateCursor(this.id);\n      this.updateHighlight();\n      return;\n    }\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const { offsetX, offsetY } = event;\n      this.ctx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.getItemLabel(datum) })\n      );\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (toggleSeries || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n    if (datum?.enabled && series) {\n      this.updateHighlight({\n        series,\n        itemId: datum?.itemId,\n        datum: void 0\n      });\n    } else {\n      this.updateHighlight();\n    }\n  }\n  handleLegendMouseExit() {\n    this.ctx.cursorManager.updateCursor(this.id);\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.updateHighlight();\n  }\n  updateHighlight(datum) {\n    const state = this.ctx.interactionManager.getState();\n    if (state === 16 /* Default */) {\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n    } else if (state === 1 /* Animation */) {\n      this.pendingHighlightDatum = datum;\n      this.ctx.animationManager.onBatchStop(() => {\n        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);\n      });\n    }\n  }\n  handleLegendMouseEnter(event) {\n    const {\n      enabled,\n      toggleSeries,\n      listeners: { legendItemClick: clickListener, legendItemDoubleClick: dblclickListener }\n    } = this;\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (enabled && datum !== void 0 && (toggleSeries || clickListener != null || dblclickListener != null)) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n  }\n  onLocaleChanged() {\n    this.itemSelection.each(({ proxyButton }, _, i) => {\n      if (proxyButton != null) {\n        proxyButton.textContent = this.getItemAriaText(i);\n      }\n    });\n  }\n  getItemAriaText(nodeIndex, enabled) {\n    const datum = this.data[nodeIndex];\n    const label = datum && this.getItemLabel(datum);\n    enabled ?? (enabled = datum.enabled);\n    const lm = this.ctx.localeManager;\n    if (nodeIndex >= 0 && label) {\n      const index = nodeIndex + 1;\n      const count = this.data.length;\n      const part1 = lm.t(\"ariaLabelLegendItem\", { label, index, count });\n      const part2 = lm.t(enabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\");\n      return [part1, part2].join(\"\");\n    }\n    return lm.t(\"ariaLabelLegendItemUnknown\");\n  }\n  positionLegend(ctx) {\n    const { shrinkRect } = ctx;\n    const newShrinkRect = shrinkRect.clone();\n    if (!this.enabled || !this.data.length) {\n      return { ...ctx, shrinkRect: newShrinkRect };\n    }\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\n    this.group.translationX = 0;\n    this.group.translationY = 0;\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return shrinkRect.height - legendBBox.height;\n        case \"right\":\n        default:\n          return shrinkRect.width - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      const legendPadding = this.spacing;\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (shrinkRect.width - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          newShrinkRect.shrink(legendBBox.height + legendPadding, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (shrinkRect.height - legendBBox.height) / 2;\n          newShrinkRect.shrink(legendBBox.width + legendPadding, this.position);\n      }\n      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\n      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\n      this.proxyLegendToolbar.style.removeProperty(\"display\");\n      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();\n    } else {\n      this.proxyLegendToolbar.style.display = \"none\";\n    }\n    this.updateItemProxyButtons();\n    this.updatePaginationProxyButtons(oldPages);\n    return { ...ctx, shrinkRect: newShrinkRect };\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width, height } = shrinkRect;\n    const aspectRatio = width / height;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);\n        break;\n      case \"left\":\n      case \"right\":\n      default:\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.updateGroupVisibility()),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Legend(ctx),\n  packageType: \"community\"\n};\n\n// packages/ag-charts-community/src/chart/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/chart/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Locale(ctx)\n};\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts\nvar RangeHandle = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 3;\n    this.centerX = 0;\n    this.centerY = 0;\n    this.width = 8;\n    this.height = 16;\n    this.gripLineGap = 2;\n    this.gripLineLength = 8;\n  }\n  setCenter(x, y) {\n    this.dirtyPath = true;\n    this.centerX = x;\n    this.centerY = y;\n  }\n  static align(minHandle, maxHandle, x, y, width, height, min, max) {\n    const handlePixelAlign = minHandle.strokeWidth / 2;\n    const minHandleX = minHandle.align(x + width * min) + handlePixelAlign;\n    const maxHandleX = minHandleX + minHandle.align(x + width * min, width * (max - min)) - 2 * handlePixelAlign;\n    const handleY = minHandle.align(y + height / 2) + handlePixelAlign;\n    minHandle.setCenter(minHandleX, handleY);\n    maxHandle.setCenter(maxHandleX, handleY);\n  }\n  computeBBox() {\n    const { centerX, centerY, width, height } = this;\n    const x = centerX - width / 2;\n    const y = centerY - height / 2;\n    return new BBox(x, y, width, height);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return bbox.containsPoint(point.x, point.y);\n  }\n  updatePath() {\n    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    path.clear();\n    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;\n    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY + halfHeight);\n    path.lineTo(centerX - halfWidth, centerY + halfHeight);\n    path.closePath();\n    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;\n    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - dx, centerY - dy);\n    path.lineTo(centerX - dx, centerY + dy);\n    path.moveTo(centerX + dx, centerY - dy);\n    path.lineTo(centerX + dx, centerY + dy);\n  }\n};\nRangeHandle.className = \"RangeHandle\";\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineGap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineLength\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts\nvar RangeMask = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 2;\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.min = 0;\n    this.max = 1;\n  }\n  layout(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.dirtyPath = true;\n  }\n  update(min, max) {\n    this.min = isNaN(min) ? this.min : min;\n    this.max = isNaN(max) ? this.max : max;\n    this.dirtyPath = true;\n  }\n  computeBBox() {\n    const { x, y, width, height } = this;\n    return new BBox(x, y, width, height);\n  }\n  computeVisibleRangeBBox() {\n    const { x, y, width, height, min, max } = this;\n    const minX = x + width * min;\n    const maxX = x + width * max;\n    return new BBox(minX, y, maxX - minX, height);\n  }\n  updatePath() {\n    const { path, x, y, width, height, min, max, strokeWidth } = this;\n    const pixelAlign = strokeWidth / 2;\n    path.clear();\n    const ax = this.align(x) + pixelAlign;\n    const ay = this.align(y) + pixelAlign;\n    const axw = ax + this.align(x, width) - 2 * pixelAlign;\n    const ayh = ay + this.align(y, height) - 2 * pixelAlign;\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.closePath();\n    const minX = this.align(x + width * min) + pixelAlign;\n    const maxX = minX + this.align(x + width * min, width * (max - min)) - 2 * pixelAlign;\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.closePath();\n  }\n};\nRangeMask.className = \"RangeMask\";\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts\nvar RangeSelector = class extends Group {\n  constructor(children) {\n    super({ name: \"rangeSelectorGroup\", layer: true, zIndex: 14 /* NAVIGATOR_ZINDEX */ });\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.lOffset = 0;\n    this.rOffset = 0;\n    this.isContainerNode = true;\n    this.background = new Group({ name: \"navigator-background\" });\n    this.background.zIndex = 1;\n    this.appendChild(this.background);\n    this.append(children);\n  }\n  layout(x, y, width, height, lOffset, rOffset) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.lOffset = lOffset;\n    this.rOffset = rOffset;\n    this.background.translationX = x;\n    this.background.translationY = y;\n  }\n  updateBackground(oldGroup, newGroup) {\n    if (oldGroup != null) {\n      this.background.removeChild(oldGroup);\n    }\n    if (newGroup != null) {\n      this.background.appendChild(newGroup);\n    }\n  }\n  computeBBox() {\n    const { x, y, width, height, lOffset, rOffset } = this;\n    return new BBox(x - lOffset, y, width + (lOffset + rOffset), height);\n  }\n};\n\n// packages/ag-charts-community/src/chart/navigator/navigator.ts\nvar Navigator = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.miniChart = void 0;\n    this.enabled = false;\n    this.mask = new RangeMask();\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.maskVisibleRange = {\n      id: \"navigator-mask-visible-range\",\n      getBBox: () => this.mask.computeVisibleRangeBBox(),\n      computeTransformedBBox: () => this.mask.computeVisibleRangeBBox()\n    };\n    this.height = 30;\n    this.spacing = 10;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);\n    this._min = 0;\n    this._max = 1;\n    this.minRange = 1e-3;\n    const region = ctx.regionManager.addRegion(\"navigator\", this.rangeSelector);\n    const dragStates = 16 /* Default */ | 1 /* Animation */ | 8 /* ZoomDrag */;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.rangeSelector),\n      region.addListener(\"hover\", (event) => this.onHover(event), dragStates),\n      region.addListener(\"drag-start\", (event) => this.onDragStart(event), dragStates),\n      region.addListener(\"drag\", (event) => this.onDrag(event), dragStates),\n      region.addListener(\"drag-end\", () => this.onDragEnd(), dragStates),\n      region.addListener(\"leave\", (event) => this.onLeave(event), dragStates),\n      this.ctx.localeManager.addListener(\"locale-changed\", () => this.updateZoom()),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event))\n    );\n    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `navigator-toolbar`,\n      classList: [\"ag-charts-proxy-navigator-toolbar\"],\n      ariaOrientation: \"vertical\",\n      ariaLabel: { id: \"ariaLabelNavigator\" }\n    });\n    this.updateGroupVisibility();\n    this.proxyNavigatorElements = [\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-min\",\n        ariaLabel: { id: \"ariaLabelNavigatorMinimum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.minHandle,\n        onchange: (ev) => this.onMinSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-pan\",\n        ariaLabel: { id: \"ariaLabelNavigatorRange\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maskVisibleRange,\n        onchange: (ev) => this.onPanSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-max\",\n        ariaLabel: { id: \"ariaLabelNavigatorMaximum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maxHandle,\n        onchange: (ev) => this.onMaxSliderChange(ev)\n      })\n    ];\n    initToolbarKeyNav({\n      orientation: \"vertical\",\n      toolbar: this.proxyNavigatorToolbar,\n      buttons: this.proxyNavigatorElements\n    });\n    this.destroyFns.push(() => {\n      this.proxyNavigatorElements.forEach((e) => e.remove());\n      this.proxyNavigatorToolbar.remove();\n    });\n  }\n  updateBackground(oldGroup, newGroup) {\n    this.rangeSelector?.updateBackground(oldGroup, newGroup);\n  }\n  updateGroupVisibility() {\n    const { enabled } = this;\n    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)\n      return;\n    this.rangeSelector.visible = enabled;\n    this.proxyNavigatorToolbar.ariaHidden = (!enabled).toString();\n    if (enabled) {\n      this.updateZoom();\n    } else {\n      this.ctx.zoomManager.updateZoom(\"navigator\");\n    }\n  }\n  async performLayout(ctx) {\n    const { shrinkRect } = ctx;\n    if (this.enabled) {\n      const navigatorTotalHeight = this.height + this.spacing;\n      shrinkRect.shrink(navigatorTotalHeight, \"bottom\");\n      this.y = shrinkRect.y + shrinkRect.height + this.spacing;\n    } else {\n      this.y = 0;\n    }\n    return { ...ctx, shrinkRect };\n  }\n  async performCartesianLayout(opts) {\n    const { x, width } = opts.seriesRect;\n    if (this.enabled) {\n      const { y, height } = this;\n      this.layoutNodes(x, y, width, height);\n      setElementBBox(this.proxyNavigatorToolbar, { x, y, width, height });\n      this.proxyNavigatorToolbar.style.removeProperty(\"display\");\n    } else {\n      this.proxyNavigatorToolbar.style.display = \"none\";\n    }\n    this.x = x;\n    this.width = width;\n  }\n  onHover(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"ew-resize\");\n    } else if (mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"grab\");\n    } else {\n      this.ctx.cursorManager.updateCursor(\"navigator\");\n    }\n  }\n  onDragStart(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle, x, width, _min: min } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.zIndex < maxHandle.zIndex) {\n      if (maxHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"max\";\n      } else if (minHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"min\";\n      }\n    } else if (minHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"min\";\n    } else if (maxHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"max\";\n    }\n    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.dragging = \"pan\";\n      this.panStart = (offsetX - x) / width - min;\n    }\n    if (this.dragging != null) {\n      this.ctx.zoomManager.fireZoomPanStartEvent(\"navigator\");\n    }\n  }\n  onDrag(event) {\n    if (!this.enabled || this.dragging == null)\n      return;\n    const { dragging, minRange, panStart, x, width } = this;\n    let { _min: min, _max: max } = this;\n    const { offsetX } = event;\n    const ratio2 = (offsetX - x) / width;\n    if (dragging === \"min\") {\n      min = clamp(0, ratio2, max - minRange);\n    } else if (dragging === \"max\") {\n      max = clamp(min + minRange, ratio2, 1);\n    } else if (dragging === \"pan\" && panStart != null) {\n      const span = max - min;\n      min = clamp(0, ratio2 - panStart, 1 - span);\n      max = min + span;\n    }\n    this._min = min;\n    this._max = max;\n    this.updateZoom();\n  }\n  onDragEnd() {\n    this.dragging = void 0;\n  }\n  onLeave(_event) {\n    this.ctx.cursorManager.updateCursor(\"navigator\");\n  }\n  onZoomChange(event) {\n    const { x } = event;\n    if (!x)\n      return;\n    this._min = x.min;\n    this._max = x.max;\n    this.updateNodes(x.min, x.max);\n    this.setPanSliderValue(x.min, x.max);\n    this.setSliderRatio(this.proxyNavigatorElements[0], x.min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], x.max);\n  }\n  onPanSliderChange(_event) {\n    const ratio2 = this.getSliderRatio(this.proxyNavigatorElements[1]);\n    const span = this._max - this._min;\n    this._min = clamp(0, ratio2, 1 - span);\n    this._max = this._min + span;\n    this.updateZoom();\n  }\n  onMinSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[0];\n    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);\n    this.updateZoom();\n  }\n  onMaxSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[2];\n    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);\n    this.updateZoom();\n  }\n  setPanSliderValue(min, max) {\n    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;\n    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t(\"ariaValuePanRange\", { min, max });\n  }\n  setSliderRatioClamped(slider, clampMin, clampMax) {\n    const ratio2 = this.getSliderRatio(slider);\n    const clampedRatio = clamp(clampMin, ratio2, clampMax);\n    if (clampedRatio !== ratio2) {\n      this.setSliderRatio(slider, clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setSliderRatio(slider, ratio2) {\n    const value = Math.round(ratio2 * 100);\n    slider.value = `${value}`;\n    slider.ariaValueText = formatPercentage(value);\n  }\n  getSliderRatio(slider) {\n    return parseFloat(slider.value) / 100;\n  }\n  layoutNodes(x, y, width, height) {\n    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;\n    rangeSelector.layout(x, y, width, height, minHandle.width / 2, maxHandle.width / 2);\n    mask.layout(x, y, width, height);\n    RangeHandle.align(minHandle, maxHandle, x, y, width, height, min, max);\n    if (min + (max - min) / 2 < 0.5) {\n      minHandle.zIndex = 3;\n      maxHandle.zIndex = 4;\n    } else {\n      minHandle.zIndex = 4;\n      maxHandle.zIndex = 3;\n    }\n    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {\n      const bbox = node.getBBox();\n      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };\n      setElementBBox(this.proxyNavigatorElements[index], tbox);\n    });\n  }\n  updateNodes(min, max) {\n    this.mask.update(min, max);\n  }\n  updateZoom() {\n    if (!this.enabled)\n      return;\n    const { _min: min, _max: max } = this;\n    if (min == null || max == null)\n      return;\n    const warnOnConflict = (stateId) => {\n      if (this.min == null && this.max == null)\n        return;\n      Logger.warnOnce(\n        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`\n      );\n    };\n    return this.ctx.zoomManager.updateZoom(\"navigator\", { x: { min, max } }, false, warnOnConflict);\n  }\n};\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Navigator.prototype, \"miniChart\", 2);\n__decorateClass([\n  Validate(BOOLEAN),\n  ObserveChanges((target) => target.updateGroupVisibility())\n], Navigator.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"spacing\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(min) {\n      this._min = min;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, LESS_THAN(\"max\")), { optional: true })\n], Navigator.prototype, \"min\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(max) {\n      this._max = max;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, GREATER_THAN(\"min\")), { optional: true })\n], Navigator.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Navigator(ctx),\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: \"#999999\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/theme.ts\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return { fill, stroke };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 17] = \"LARGE\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_WEIGHT2 = /* @__PURE__ */ ((FONT_WEIGHT3) => {\n  FONT_WEIGHT3[\"NORMAL\"] = \"normal\";\n  FONT_WEIGHT3[\"BOLD\"] = \"bold\";\n  FONT_WEIGHT3[\"BOLDER\"] = \"bolder\";\n  FONT_WEIGHT3[\"LIGHTER\"] = \"lighter\";\n  return FONT_WEIGHT3;\n})(FONT_WEIGHT2 || {});\nvar POSITION2 = /* @__PURE__ */ ((POSITION3) => {\n  POSITION3[\"TOP\"] = \"top\";\n  POSITION3[\"RIGHT\"] = \"right\";\n  POSITION3[\"BOTTOM\"] = \"bottom\";\n  POSITION3[\"LEFT\"] = \"left\";\n  return POSITION3;\n})(POSITION2 || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar DEFAULT_FONT_FAMILY = Symbol(\"default-font\");\nvar DEFAULT_LABEL_COLOUR = Symbol(\"default-label-colour\");\nvar DEFAULT_INVERTED_LABEL_COLOUR = Symbol(\"default-inverted-label-colour\");\nvar DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol(\"default-inside-series-label-colour\");\nvar DEFAULT_MUTED_LABEL_COLOUR = Symbol(\"default-muted-label-colour\");\nvar DEFAULT_AXIS_GRID_COLOUR = Symbol(\"default-axis-grid-colour\");\nvar DEFAULT_AXIS_LINE_COLOUR = Symbol(\"default-axis-line-colour\");\nvar DEFAULT_CROSS_LINES_COLOUR = Symbol(\"default-cross-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_COLOURS = Symbol(\"default-colours\");\nvar DEFAULT_PADDING = Symbol(\"default-padding\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar PALETTE_ALT_UP_STROKE = Symbol(\"palette-alt-up-stroke\");\nvar PALETTE_ALT_DOWN_STROKE = Symbol(\"palette-alt-down-stroke\");\nvar PALETTE_ALT_UP_FILL = Symbol(\"palette-alt-up-fill\");\nvar PALETTE_ALT_DOWN_FILL = Symbol(\"palette-alt-down-fill\");\nvar PALETTE_ALT_NEUTRAL_FILL = Symbol(\"palette-gray-fill\");\nvar PALETTE_ALT_NEUTRAL_STROKE = Symbol(\"palette-gray-stroke\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_ANNOTATION_COLOR = Symbol(\"default-annotation-stroke\");\nvar DEFAULT_TEXT_ANNOTATION_COLOR = Symbol(\"default-text-annotation-color\");\nvar DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol(\"default-annotation-background-fill\");\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_TEXTBOX_FILL = Symbol(\"default-textbox-fill\");\nvar DEFAULT_TEXTBOX_STROKE = Symbol(\"default-textbox-stroke\");\nvar DEFAULT_TEXTBOX_COLOR = Symbol(\"default-textbox-color\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio2, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio2, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return;\n  } else if (text === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isMarkerShape(value) || typeof value === \"function\" && Object.create(value.prototype) instanceof Marker,\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\n    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n  }\n  toTooltipHtml(defaults, params) {\n    if (this.renderer) {\n      return toTooltipHtml(this.renderer(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/scene/util/bezier.ts\nfunction evaluateBezier(p0, p1, p2, p3, t) {\n  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) + t ** 2 * p2 + t ** 3 * p3;\n}\nfunction solveBezier(p0, p1, p2, p3, value) {\n  if (value <= Math.min(p0, p3)) {\n    return p0 < p3 ? 0 : 1;\n  } else if (value >= Math.max(p0, p3)) {\n    return p0 < p3 ? 1 : 0;\n  }\n  let t0 = 0;\n  let t1 = 1;\n  let t = NaN;\n  for (let i = 0; i < 8; i += 1) {\n    t = (t0 + t1) / 2;\n    const curveValue = (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n    if (curveValue < value) {\n      t0 = t;\n    } else {\n      t1 = t;\n    }\n  }\n  return t;\n}\nfunction splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {\n  const x01 = (1 - t) * p0x + t * p1x;\n  const y01 = (1 - t) * p0y + t * p1y;\n  const x12 = (1 - t) * p1x + t * p2x;\n  const y12 = (1 - t) * p1y + t * p2y;\n  const x23 = (1 - t) * p2x + t * p3x;\n  const y23 = (1 - t) * p2y + t * p3y;\n  const x012 = (1 - t) * x01 + t * x12;\n  const y012 = (1 - t) * y01 + t * y12;\n  const x123 = (1 - t) * x12 + t * x23;\n  const y123 = (1 - t) * y12 + t * y23;\n  const x0123 = (1 - t) * x012 + t * x123;\n  const y0123 = (1 - t) * y012 + t * y123;\n  return [\n    [\n      { x: p0x, y: p0y },\n      { x: x01, y: y01 },\n      { x: x012, y: y012 },\n      { x: x0123, y: y0123 }\n    ],\n    [\n      { x: x0123, y: y0123 },\n      { x: x123, y: y123 },\n      { x: x23, y: y23 },\n      { x: p3x, y: p3y }\n    ]\n  ];\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts\nfunction spanRange(span) {\n  switch (span.type) {\n    case \"linear\":\n    case \"step\":\n      return [\n        { x: span.x0, y: span.y0 },\n        { x: span.x1, y: span.y1 }\n      ];\n    case \"cubic\":\n      return [\n        { x: span.cp0x, y: span.cp0y },\n        { x: span.cp3x, y: span.cp3y }\n      ];\n  }\n}\nfunction reverseSpan(span) {\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: span.x1,\n        y0: span.y1,\n        x1: span.x0,\n        y1: span.y0\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: span.cp3x,\n        cp0y: span.cp3y,\n        cp1x: span.cp2x,\n        cp1y: span.cp2y,\n        cp2x: span.cp1x,\n        cp2y: span.cp1y,\n        cp3x: span.cp0x,\n        cp3y: span.cp0y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: span.x1,\n        y0: span.y1,\n        x1: span.x0,\n        y1: span.y0,\n        stepX: span.stepX\n      };\n  }\n}\nfunction collapseSpanToPoint(span, point) {\n  const { x, y } = point;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y,\n        stepX: x\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: x,\n        cp0y: y,\n        cp1x: x,\n        cp1y: y,\n        cp2x: x,\n        cp2y: y,\n        cp3x: x,\n        cp3y: y\n      };\n  }\n}\nfunction rescaleSpan(span, nextStart, nextEnd) {\n  const [prevStart, prevEnd] = spanRange(span);\n  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;\n  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: nextStart.x,\n        cp0y: nextStart.y,\n        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,\n        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,\n        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,\n        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,\n        cp3x: nextEnd.x,\n        cp3y: nextEnd.y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y,\n        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale\n      };\n  }\n}\nfunction setMoveTo(span, moveTo) {\n  return span.moveTo !== moveTo ? { ...span, moveTo } : span;\n}\nfunction splitSpanAtX(span, x) {\n  const [start, end] = spanRange(span);\n  let x0;\n  let y0;\n  let x1;\n  let y1;\n  if (start.x < end.x) {\n    x0 = start.x;\n    y0 = start.y;\n    x1 = end.x;\n    y1 = end.y;\n  } else {\n    x0 = end.x;\n    y0 = end.y;\n    x1 = start.x;\n    y1 = start.y;\n  }\n  if (x < x0) {\n    return [rescaleSpan(span, start, start), setMoveTo(span, false)];\n  } else if (x > x1) {\n    return [span, setMoveTo(rescaleSpan(span, end, end), false)];\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const midY = y0 === y1 ? y0 : (y1 - y0) / (x1 - x0) * (x - x0) + y0;\n      return [\n        { type: \"linear\", moveTo: span.moveTo, x0, y0, x1: x, y1: midY },\n        { type: \"linear\", moveTo: false, x0: x, y0: midY, x1, y1 }\n      ];\n    }\n    case \"step\":\n      if (x < span.stepX) {\n        return [\n          { type: \"step\", moveTo: span.moveTo, x0, y0, x1: x, y1: y0, stepX: x },\n          { type: \"step\", moveTo: false, x0: x, y0, x1, y1, stepX: span.stepX }\n        ];\n      } else {\n        return [\n          { type: \"step\", moveTo: span.moveTo, x0, y0, x1: x, y1, stepX: span.stepX },\n          { type: \"step\", moveTo: false, x0: x, y0: y1, x1, y1, stepX: x }\n        ];\n      }\n    case \"cubic\": {\n      const t = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x);\n      const [a, b] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t\n      );\n      return [\n        {\n          type: \"cubic\",\n          moveTo: span.moveTo,\n          cp0x: a[0].x,\n          cp0y: a[0].y,\n          cp1x: a[1].x,\n          cp1y: a[1].y,\n          cp2x: a[2].x,\n          cp2y: a[2].y,\n          cp3x: a[3].x,\n          cp3y: a[3].y\n        },\n        {\n          type: \"cubic\",\n          moveTo: false,\n          cp0x: b[0].x,\n          cp0y: b[0].y,\n          cp1x: b[1].x,\n          cp1y: b[1].y,\n          cp2x: b[2].x,\n          cp2y: b[2].y,\n          cp3x: b[3].x,\n          cp3y: b[3].y\n        }\n      ];\n    }\n  }\n}\nfunction clipSpanX(span, x0, x1) {\n  const { moveTo } = span;\n  const [start, end] = spanRange(span);\n  let spanX0;\n  let spanY0;\n  let spanX1;\n  let spanY1;\n  if (start.x < end.x) {\n    spanX0 = start.x;\n    spanY0 = start.y;\n    spanX1 = end.x;\n    spanY1 = end.y;\n  } else {\n    spanX0 = end.x;\n    spanY0 = end.y;\n    spanX1 = start.x;\n    spanY1 = start.y;\n  }\n  if (x1 < spanX0) {\n    return rescaleSpan(span, start, start);\n  } else if (x0 > spanX1) {\n    return rescaleSpan(span, end, end);\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);\n      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;\n      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;\n      return { type: \"linear\", moveTo, x0, y0, x1, y1 };\n    }\n    case \"step\":\n      if (x1 <= span.stepX) {\n        const y = span.y0;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };\n      } else if (x0 >= span.stepX) {\n        const y = span.y1;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };\n      } else {\n        const { y0, y1, stepX } = span;\n        return { type: \"step\", moveTo, x0, y0, x1, y1, stepX };\n      }\n    case \"cubic\": {\n      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);\n      let [_unused, bezier] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t0\n      );\n      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);\n      [bezier, _unused] = splitBezier(\n        bezier[0].x,\n        bezier[0].y,\n        bezier[1].x,\n        bezier[1].y,\n        bezier[2].x,\n        bezier[2].y,\n        bezier[3].x,\n        bezier[3].y,\n        t1\n      );\n      return {\n        type: \"cubic\",\n        moveTo,\n        cp0x: bezier[0].x,\n        cp0y: bezier[0].y,\n        cp1x: bezier[1].x,\n        cp1y: bezier[1].y,\n        cp2x: bezier[2].x,\n        cp2y: bezier[2].y,\n        cp3x: bezier[3].x,\n        cp3y: bezier[3].y\n      };\n    }\n  }\n}\nfunction interpolateSpans(a, b, ratio2) {\n  if (a.type === \"cubic\" && b.type === \"cubic\") {\n    return {\n      type: \"cubic\",\n      moveTo: a.moveTo,\n      cp0x: (b.cp0x - a.cp0x) * ratio2 + a.cp0x,\n      cp0y: (b.cp0y - a.cp0y) * ratio2 + a.cp0y,\n      cp1x: (b.cp1x - a.cp1x) * ratio2 + a.cp1x,\n      cp1y: (b.cp1y - a.cp1y) * ratio2 + a.cp1y,\n      cp2x: (b.cp2x - a.cp2x) * ratio2 + a.cp2x,\n      cp2y: (b.cp2y - a.cp2y) * ratio2 + a.cp2y,\n      cp3x: (b.cp3x - a.cp3x) * ratio2 + a.cp3x,\n      cp3y: (b.cp3y - a.cp3y) * ratio2 + a.cp3y\n    };\n  } else if (a.type === \"step\" && b.type === \"step\") {\n    return {\n      type: \"step\",\n      moveTo: a.moveTo,\n      x0: (b.x0 - a.x0) * ratio2 + a.x0,\n      y0: (b.y0 - a.y0) * ratio2 + a.y0,\n      x1: (b.x1 - a.x1) * ratio2 + a.x1,\n      y1: (b.y1 - a.y1) * ratio2 + a.y1,\n      stepX: (b.stepX - a.stepX) * ratio2 + a.stepX\n    };\n  }\n  const [aStart, aEnd] = spanRange(a);\n  const [bStart, bEnd] = spanRange(b);\n  return {\n    type: \"linear\",\n    moveTo: a.moveTo,\n    x0: (bStart.x - aStart.x) * ratio2 + aStart.x,\n    y0: (bStart.y - aStart.y) * ratio2 + aStart.y,\n    x1: (bEnd.x - aEnd.x) * ratio2 + aEnd.x,\n    y1: (bEnd.y - aEnd.y) * ratio2 + aEnd.y\n  };\n}\nfunction plotSpan(path, span, moveTo = span.moveTo ? 1 /* MoveTo */ : 0 /* None */) {\n  const [start] = spanRange(span);\n  switch (moveTo) {\n    case 1 /* MoveTo */:\n      path.moveTo(start.x, start.y);\n      break;\n    case 2 /* LineTo */:\n      path.lineTo(start.x, start.y);\n      break;\n  }\n  switch (span.type) {\n    case \"linear\":\n      path.lineTo(span.x1, span.y1);\n      break;\n    case \"cubic\":\n      path.cubicCurveTo(span.cp1x, span.cp1y, span.cp2x, span.cp2y, span.cp3x, span.cp3y);\n      break;\n    case \"step\":\n      path.lineTo(span.stepX, span.y0);\n      path.lineTo(span.stepX, span.y1);\n      path.lineTo(span.x1, span.y1);\n      break;\n  }\n}\nfunction linearPoints(points) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      spans.push({ type: \"linear\", moveTo, x0, y0, x1, y1 });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction stepPoints(points, position) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  const p0 = typeof position === \"number\" ? position : lineSteps[position];\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      const stepX = x0 + (x1 - x0) * p0;\n      spans.push({ type: \"step\", moveTo, x0, y0, x1, y1, stepX });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar flatnessRatio = 0.05;\nfunction smoothPoints(iPoints, tension) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length <= 1)\n    return [];\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  const spans = [];\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    spans.push({\n      type: \"cubic\",\n      moveTo: i === 1,\n      cp0x: prev.x,\n      cp0y: prev.y,\n      cp1x: prev.x + dcp1x,\n      cp1y: prev.y + dcp1y,\n      cp2x: cur.x - dcp2x,\n      cp2y: cur.y - dcp2y,\n      cp3x: cur.x,\n      cp3y: cur.y\n    });\n  }\n  return spans;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = (datum) => {\n    const { xValue } = datum;\n    if (pairMap.moved[xValue]) {\n      return { point: readFirstPair(xValue, \"moved\"), status: \"updated\" };\n    } else if (pairMap.removed[xValue]) {\n      return { point: readFirstPair(xValue, \"removed\"), status: \"removed\" };\n    } else if (pairMap.added[xValue]) {\n      return { point: readFirstPair(xValue, \"added\"), status: \"added\" };\n    }\n    return { status: \"unknown\" };\n  };\n  const fromFn = (marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: point?.from?.x ?? marker.translationX,\n      translationY: point?.from?.y ?? marker.translationY,\n      opacity: marker.opacity,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (parentStatus === \"added\") {\n      return {\n        ...defaults,\n        opacity: 0,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"added\"]\n      };\n    }\n    if (status === \"added\") {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (status === \"removed\" || parentStatus === \"removed\") {\n      return {\n        ...defaults,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        opacity: 0,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"removed\"]\n      };\n    }\n    return defaults;\n  };\n  return { fromFn, toFn };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  if (datum === void 0 || datum.point === void 0)\n    return void 0;\n  const size = series.getFormattedMarkerStyle(datum).size;\n  const radius = size / 2;\n  const { x, y } = series.contentGroup.inverseTransformPoint(datum.point.x - radius, datum.point.y - radius);\n  return new BBox(x, y, size, size);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts\nfunction plotLinearPoints(path, points, continuePath) {\n  let didMove = continuePath;\n  for (const { x, y } of points) {\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n      didMove = true;\n    }\n  }\n}\nvar flatnessRatio2 = 0.05;\nfunction plotSmoothPoints(path, iPoints, tension, continuePath) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length === 0)\n    return;\n  if (continuePath) {\n    path.lineTo(points[0].x, points[0].y);\n  } else {\n    path.moveTo(points[0].x, points[0].y);\n  }\n  if (points.length <= 1)\n    return;\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio2 || 1 - prevRatio <= flatnessRatio2 || nextRatio <= flatnessRatio2 || 1 - nextRatio <= flatnessRatio2) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);\n  }\n}\nfunction plotStepPoints(path, points, align, continuePath) {\n  let lastPoint;\n  for (const point of points) {\n    if (lastPoint != null) {\n      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;\n      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;\n      path.lineTo(x, lastPoint?.y ?? point.y);\n      path.lineTo(x, point.y);\n      path.lineTo(point.x, point.y);\n    } else if (continuePath) {\n      path.lineTo(point.x, point.y);\n    } else {\n      path.moveTo(point.x, point.y);\n    }\n    lastPoint = point;\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction minMax(nodeData) {\n  return nodeData.reduce(\n    ({ min, max }, node) => {\n      if (min == null || min.point.x > node.point.x) {\n        min = node;\n      }\n      if (max == null || max.point.x < node.point.x) {\n        max = node;\n      }\n      return { min, max };\n    },\n    {}\n  );\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  const y = (targetX - a.x) * m + a.y;\n  return { x: targetX, y };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1, nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, \"out\", \"in\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.to = result[sIdx].from);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.from && result[eIdx]?.from) {\n      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach((d) => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, \"in\", \"out\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.from = result[sIdx].to);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.to && result[eIdx]?.to) {\n      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach((d) => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from2, to, ratio2) {\n  const x1 = isNaN(from2.x) ? to.x : from2.x;\n  const y1 = isNaN(from2.y) ? to.y : from2.y;\n  const xd = to.x - from2.x;\n  const yd = to.y - from2.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio2;\n  const yr = isNaN(yd) ? 0 : yd * ratio2;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nvar lineSteps2 = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction plotPath(points, path, interpolation, continuePath = false) {\n  const { path: linePath } = path;\n  if (interpolation?.type === \"smooth\") {\n    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);\n  } else if (interpolation?.type === \"step\") {\n    plotStepPoints(linePath, points, lineSteps2[interpolation.position ?? \"end\"], continuePath);\n  } else {\n    plotLinearPoints(linePath, points, continuePath);\n  }\n}\nfunction splitPairData(pairData, ratios) {\n  let previousTo;\n  let points = void 0;\n  const out = [];\n  const flushCurrent = () => {\n    if (points != null) {\n      out.push(points);\n      points = void 0;\n    }\n  };\n  for (const data of pairData) {\n    const { from: from2, to } = data;\n    const ratio2 = ratios[data.change];\n    if (ratio2 == null || from2 == null || to == null)\n      continue;\n    const point = calculatePoint(from2, to, ratio2);\n    if (data.moveTo === false) {\n      points ?? (points = []);\n      points.push(point);\n    } else if (data.moveTo === true || !previousTo) {\n      flushCurrent();\n      points = [point];\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === \"in\" ? ratio2 : 1 - ratio2;\n      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);\n      points ?? (points = []);\n      points.push({ x: midPointX, y: midPointY });\n      flushCurrent();\n      points = [point];\n    }\n    previousTo = point;\n  }\n  flushCurrent();\n  return out;\n}\nfunction renderPartialPath(pairData, ratios, path, interpolation) {\n  splitPairData(pairData, ratios).forEach((points) => {\n    plotPath(points, path, interpolation);\n  });\n}\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width },\n    {\n      phase: \"initial\",\n      start: { clipMode: \"normal\", clipY: height, visible },\n      finish: { clipMode: void 0, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: \"remove\" });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => {\n    return { visible: opts.getVisible(), opacity: opts.getOpacity(), clipScalingX: 1, clipMode: void 0 };\n  };\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areEqual(a, b) {\n  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && areEqual(a, b);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return areEqual(a, b);\n  }\n  return false;\n}\nfunction isScaleValid(scale2) {\n  if (scale2 == null)\n    return false;\n  if (!scale2.range.every((v) => Number.isFinite(v)))\n    return false;\n  if (scale2.type === \"category\") {\n    return scale2.domain.every((v) => v != null);\n  }\n  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction* pathRanges(points) {\n  let start = -1;\n  let end = 0;\n  for (const { point } of points) {\n    if (point.moveTo) {\n      const range3 = start >= 0 ? { start, end } : void 0;\n      start = end;\n      end = start;\n      if (range3 !== void 0) {\n        yield range3;\n      }\n    }\n    end += 1;\n  }\n  if (start !== -1) {\n    yield { start, end };\n  }\n}\nfunction* pathRangePoints(points, { start, end }) {\n  for (let i = start; i < end; i += 1) {\n    yield points[i].point;\n  }\n}\nfunction* pathRangePointsReverse(points, { start, end }) {\n  for (let i = end - 1; i >= start; i -= 1) {\n    yield points[i].point;\n  }\n}\nfunction integratedCategoryMatch(a, b) {\n  if (a == null || b == null)\n    return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\")\n    return false;\n  if (\"id\" in a && \"id\" in b) {\n    return a.id === b.id;\n  }\n  return a.toString() === b.toString();\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));\n  if (matchingIntegratedIndex >= 0) {\n    return scaling.range[matchingIntegratedIndex];\n  }\n  return NaN;\n}\nfunction scalesChanged(newData, oldData) {\n  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from2 = false, to = false) {\n  if (from2 === to) {\n    return Boolean(from2);\n  }\n  return from2 ? \"in\" : \"out\";\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  const { backfillSplitMode = \"intersect\" } = opts;\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from2, to, xValue, change = \"move\") => {\n    if (from2 && (isNaN(from2.point.x) || isNaN(from2.point.y))) {\n      from2 = to;\n    }\n    const resultPoint = {\n      from: from2?.point,\n      to: to?.point,\n      moveTo: calculateMoveTo(from2?.point.moveTo, to?.point.moveTo),\n      change\n    };\n    if (change === \"move\") {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === \"in\") {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === \"out\") {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\n  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from2 = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from2 ? scale(from2.xValue ?? NaN, newData.scales.x) : void 0;\n    const toUnshifted = to ? scale(to.xValue ?? NaN, oldData.scales.x) : void 0;\n    const NA = void 0;\n    if (fromShifted != null && closeMatch(fromShifted, to?.point.x)) {\n      pairUp(from2, to, to.xValue, \"move\");\n    } else if (fromShifted != null && fromShifted < (minToNode?.point.x ?? -Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (fromShifted != null && fromShifted > (maxToNode?.point.x ?? Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < (minFromNode?.point.x ?? -Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (toUnshifted != null && toUnshifted > (maxFromNode?.point.x ?? Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (fromShifted != null && fromShifted < to?.point.x) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < from2?.point.x) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (from2) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (to) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else {\n      throw new Error(\"Unable to process points\");\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap };\n}\nfunction pairCategoryData(newData, oldData, diff2, opts = {}) {\n  const { backfillSplitMode = \"intersect\", multiDatum = false } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pointResultMapping = {\n    in: \"added\",\n    move: \"moved\",\n    out: \"removed\"\n  };\n  let previousResultPoint = void 0;\n  let previousXValue = void 0;\n  const addToResultMap = (xValue, newPoint) => {\n    var _a;\n    const type = pointResultMapping[newPoint.change];\n    if (multiDatum) {\n      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);\n      resultMapMulti[type][xValue].push(newPoint);\n    } else {\n      resultMapSingle[type][xValue] = newPoint;\n    }\n    previousResultPoint = newPoint;\n    previousXValue = transformIntegratedCategoryValue(xValue);\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    const bXValue = transformIntegratedCategoryValue(before?.xValue);\n    const aXValue = transformIntegratedCategoryValue(after?.xValue);\n    let resultPoint;\n    if (bXValue === aXValue) {\n      resultPoint = {\n        change: \"move\",\n        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff2?.removed.has(String(bXValue))) {\n      resultPoint = {\n        change: \"out\",\n        moveTo: before.point.moveTo ?? false,\n        from: before.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff2?.added.has(String(aXValue))) {\n      resultPoint = {\n        change: \"in\",\n        moveTo: after.point.moveTo ?? false,\n        to: after.point\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some((pathPoint) => {\n    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\n    if (marker === \"out\")\n      return;\n    const unordered = x < previousX;\n    previousX = x;\n    return unordered;\n  }));\n  if (isXUnordered) {\n    return { result: void 0, resultMap: void 0 };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };\n}\nfunction determinePathStatus(newData, oldData, pairData) {\n  let status = \"updated\";\n  const visible = (data) => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = \"added\";\n  } else if (visible(oldData) && !visible(newData)) {\n    status = \"removed\";\n  } else {\n    for (let i = 0; i < pairData.length; i++) {\n      if (pairData[i].change !== \"move\")\n        break;\n      if (pairData[i].from?.x !== pairData[i].to?.x)\n        break;\n      if (pairData[i].from?.y !== pairData[i].to?.y)\n        break;\n      if (i === pairData.length - 1)\n        return \"no-op\";\n    }\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {\n  const status = determinePathStatus(newData, oldData, pairData);\n  const removePhaseFn = (ratio2, path) => {\n    render(pairData, { move: 0, out: ratio2 }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio2, path) => {\n    render(pairData, { move: ratio2 }, path, interpolation);\n  };\n  const addPhaseFn = (ratio2, path) => {\n    render(pairData, { move: 1, in: ratio2 }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  if (pairData === void 0 || pairMap === void 0) {\n    return;\n  }\n  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== \"updated\";\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, \"fade\", interpolation, renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return { ...pathFns, marker, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts\nfunction closeCmp(a, b, delta3 = 1e-6) {\n  if (a === b || 1 - Math.min(a, b) / Math.max(a, b) < delta3) {\n    return 0;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\nfunction closeMatch2(a, b, delta3) {\n  if (a === b) {\n    return true;\n  }\n  const an = Number(a);\n  const bn = Number(b);\n  return Number.isFinite(an) && Number.isFinite(bn) && closeCmp(an, bn, delta3) === 0;\n}\nfunction transformSpans(spanData, { x: xScale, y: yScale }) {\n  let rangeSpanData;\n  const interpolatingInvalidSpans = [];\n  let shiftedXStart = Infinity;\n  let shiftedXEnd = -Infinity;\n  for (const spanDatum of spanData) {\n    const x0 = scale(spanDatum.xValue0, xScale);\n    const y0 = scale(spanDatum.yValue0, yScale);\n    const x1 = scale(spanDatum.xValue1, xScale);\n    const y1 = scale(spanDatum.yValue1, yScale);\n    const startIsFinite = Number.isFinite(x0);\n    const endIsFinite = Number.isFinite(x1);\n    if (startIsFinite && endIsFinite && rangeSpanData == null) {\n      const unshifted = spanDatum.span;\n      const shifted = rescaleSpan(unshifted, { x: x0, y: y0 }, { x: x1, y: y1 });\n      const spanTransform = { unshifted, shifted };\n      shiftedXStart = Math.min(shiftedXStart, x0);\n      shiftedXEnd = Math.max(shiftedXEnd, x1);\n      interpolatingInvalidSpans.push(spanTransform);\n    } else if (startIsFinite && !endIsFinite && rangeSpanData == null) {\n      rangeSpanData = [spanDatum];\n    } else if (!startIsFinite && !endIsFinite && rangeSpanData != null) {\n      if (rangeSpanData != null) {\n        rangeSpanData.push(spanDatum);\n      }\n    } else if (!startIsFinite && endIsFinite && rangeSpanData != null) {\n      rangeSpanData.push(spanDatum);\n      const startSpanDatum = rangeSpanData.at(0);\n      const endSpanDatum = rangeSpanData.at(-1);\n      const transformStart = {\n        x: scale(startSpanDatum.xValue0, xScale),\n        y: scale(startSpanDatum.yValue0, yScale)\n      };\n      const transformEnd = {\n        x: scale(endSpanDatum.xValue1, xScale),\n        y: scale(endSpanDatum.yValue1, yScale)\n      };\n      const step = (transformEnd.x - transformStart.x) / (rangeSpanData.length - 1);\n      for (let i = 0; i < rangeSpanData.length; i += 1) {\n        const { span: interpolatingUnshifted, yValue0, yValue1 } = rangeSpanData[i];\n        const interpolatingShifted = rescaleSpan(\n          interpolatingUnshifted,\n          { x: transformStart.x + step * (i + 0), y: scale(yValue0, yScale) },\n          { x: transformStart.x + step * (i + 1), y: scale(yValue1, yScale) }\n        );\n        interpolatingInvalidSpans.push({ unshifted: interpolatingUnshifted, shifted: interpolatingShifted });\n      }\n      shiftedXStart = Math.min(shiftedXStart, transformStart.x);\n      shiftedXEnd = Math.max(shiftedXEnd, transformEnd.x);\n      rangeSpanData = void 0;\n    } else if (!startIsFinite && endIsFinite && rangeSpanData == null) {\n      const unshifted = spanDatum.span;\n      const shifted = rescaleSpan(unshifted, { x: x1, y: y0 }, { x: x1, y: y1 });\n      interpolatingInvalidSpans.push({ unshifted, shifted });\n    } else {\n      rangeSpanData = void 0;\n    }\n  }\n  if (rangeSpanData != null) {\n    const startSpanDatum = rangeSpanData.at(0);\n    const x = scale(startSpanDatum.xValue0, xScale);\n    for (const { span: interpolatingUnshifted, yValue0, yValue1 } of rangeSpanData) {\n      const interpolatingShifted = rescaleSpan(\n        interpolatingUnshifted,\n        { x, y: scale(yValue0, yScale) },\n        { x, y: scale(yValue1, yScale) }\n      );\n      interpolatingInvalidSpans.push({ unshifted: interpolatingUnshifted, shifted: interpolatingShifted });\n    }\n  }\n  const shiftedXRange = [shiftedXStart, shiftedXEnd];\n  return { interpolatingInvalidSpans, shiftedXRange };\n}\nfunction pairUpSpans(newData, oldData, splitMode) {\n  const oldSpans = transformSpans(oldData.data, newData.scales);\n  const newSpans = transformSpans(newData.data, oldData.scales);\n  const [oldRangeStartNewScale, oldRangeEndNewScale] = oldSpans.shiftedXRange;\n  const [newRangeStartOldScale, newRangeEndOldScale] = newSpans.shiftedXRange;\n  const removed = [];\n  const moved = [];\n  for (const oldSpanDatum of oldSpans.interpolatingInvalidSpans) {\n    const oldSpanOldScale = oldSpanDatum.unshifted;\n    const oldSpanNewScale = oldSpanDatum.shifted;\n    const [{ x: fromStartOldScale, y: fromStartOldScaleY }, { x: fromEndOldScale, y: fromEndOldScaleY }] = spanRange(oldSpanOldScale);\n    let hasCorrespondingSpan = false;\n    for (const newSpanDatum of newSpans.interpolatingInvalidSpans) {\n      const newSpanOldScale = newSpanDatum.shifted;\n      const newSpanNewScale = newSpanDatum.unshifted;\n      const [{ x: toStartOldScale }, { x: toEndOldScale }] = spanRange(newSpanOldScale);\n      if (closeCmp(fromStartOldScale, toEndOldScale) !== -1 || closeCmp(fromEndOldScale, toStartOldScale) !== 1) {\n        continue;\n      }\n      if (closeMatch2(fromStartOldScale, toStartOldScale) && closeMatch2(fromEndOldScale, toEndOldScale)) {\n        removed.push({ from: oldSpanOldScale, to: oldSpanOldScale });\n        moved.push({ from: oldSpanOldScale, to: newSpanNewScale });\n      } else if (fromStartOldScale <= toStartOldScale && fromEndOldScale >= toEndOldScale) {\n        removed.push({ from: oldSpanOldScale, to: oldSpanOldScale });\n        moved.push({ from: oldSpanOldScale, to: oldSpanNewScale });\n      } else {\n        const [{ x: fromStartNewScale }, { x: fromEndNewScale }] = spanRange(oldSpanNewScale);\n        const [{ x: toStartNewScale }, { x: toEndNewScale }] = spanRange(newSpanNewScale);\n        const xRangeStartOldScale = Math.max(fromStartOldScale, toStartOldScale);\n        const xRangeEndOldScale = Math.min(fromEndOldScale, toEndOldScale);\n        const clippedOldSpanOldScale = clipSpanX(oldSpanOldScale, xRangeStartOldScale, xRangeEndOldScale);\n        const clippedNewSpanOldScale = clipSpanX(newSpanOldScale, xRangeStartOldScale, xRangeEndOldScale);\n        const xRangeStartNewScale = Math.max(fromStartNewScale, toStartNewScale);\n        const xRangeEndNewScale = Math.min(fromEndNewScale, toEndNewScale);\n        const clippedNewSpanNewScale = clipSpanX(newSpanNewScale, xRangeStartNewScale, xRangeEndNewScale);\n        removed.push({ from: clippedOldSpanOldScale, to: clippedNewSpanOldScale });\n        moved.push({ from: clippedNewSpanOldScale, to: clippedNewSpanNewScale });\n      }\n      hasCorrespondingSpan = true;\n    }\n    if (hasCorrespondingSpan)\n      continue;\n    if (closeCmp(fromEndOldScale, newRangeStartOldScale) !== 1) {\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(\n          oldSpanOldScale,\n          { x: newRangeStartOldScale, y: fromStartOldScaleY },\n          { x: newRangeStartOldScale, y: fromEndOldScaleY }\n        )\n      });\n    } else if (closeCmp(fromStartOldScale, newRangeEndOldScale) !== -1) {\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(\n          oldSpanOldScale,\n          { x: newRangeEndOldScale, y: fromStartOldScaleY },\n          { x: newRangeEndOldScale, y: fromEndOldScaleY }\n        )\n      });\n    } else if (splitMode === 0 /* Zero */) {\n      const y = scale(0, oldData.scales.y);\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(oldSpanOldScale, { x: fromStartOldScale, y }, { x: fromEndOldScale, y })\n      });\n    } else if (splitMode === 1 /* Divide */) {\n      const [left, right] = splitSpanAtX(oldSpanOldScale, (fromStartOldScale + fromEndOldScale) / 2);\n      removed.push(\n        { from: left, to: collapseSpanToPoint(left, { x: fromStartOldScale, y: fromStartOldScaleY }) },\n        { from: right, to: collapseSpanToPoint(right, { x: fromEndOldScale, y: fromEndOldScaleY }) }\n      );\n    }\n  }\n  const added = [];\n  for (const newSpanDatum of newData.data) {\n    const newSpanNewScale = newSpanDatum.span;\n    const [{ x: toStartNewScale, y: toStartNewScaleY }, { x: toEndNewScale, y: toEndNewScaleY }] = spanRange(newSpanNewScale);\n    let hasCorrespondingSpan = false;\n    for (const oldSpanDatum of oldSpans.interpolatingInvalidSpans) {\n      const oldSpanNewScale = oldSpanDatum.shifted;\n      const [{ x: fromStartNewScale }, { x: fromEndNewScale }] = spanRange(oldSpanNewScale);\n      if (closeCmp(fromStartNewScale, toEndNewScale) !== -1 || closeCmp(fromEndNewScale, toStartNewScale) !== 1) {\n        continue;\n      }\n      if (closeMatch2(fromStartNewScale, toStartNewScale) && closeMatch2(fromEndNewScale, toEndNewScale)) {\n        added.push({ from: newSpanNewScale, to: newSpanNewScale });\n      } else if (fromStartNewScale <= toStartNewScale && fromEndNewScale >= toEndNewScale) {\n        const clippedOldSpanNewScale = clipSpanX(oldSpanNewScale, toStartNewScale, toEndNewScale);\n        added.push({ from: clippedOldSpanNewScale, to: newSpanNewScale });\n      } else {\n        added.push({ from: newSpanNewScale, to: newSpanNewScale });\n      }\n      hasCorrespondingSpan = true;\n    }\n    if (hasCorrespondingSpan)\n      continue;\n    if (closeCmp(toEndNewScale, oldRangeStartNewScale) !== 1) {\n      added.push({\n        from: rescaleSpan(\n          newSpanNewScale,\n          { x: oldRangeStartNewScale, y: toStartNewScaleY },\n          { x: oldRangeStartNewScale, y: toEndNewScaleY }\n        ),\n        to: newSpanNewScale\n      });\n    } else if (closeCmp(toStartNewScale, oldRangeEndNewScale) !== -1) {\n      added.push({\n        from: rescaleSpan(\n          newSpanNewScale,\n          { x: oldRangeEndNewScale, y: toStartNewScaleY },\n          { x: oldRangeEndNewScale, y: toEndNewScaleY }\n        ),\n        to: newSpanNewScale\n      });\n    } else if (splitMode === 0 /* Zero */) {\n      const y = scale(0, newData.scales.y);\n      added.push({\n        from: rescaleSpan(newSpanNewScale, { x: toStartNewScale, y }, { x: toEndNewScale, y }),\n        to: newSpanNewScale\n      });\n    } else if (splitMode === 1 /* Divide */) {\n      const [left, right] = splitSpanAtX(newSpanNewScale, (toStartNewScale + toEndNewScale) / 2);\n      added.push(\n        { from: collapseSpanToPoint(left, { x: toStartNewScale, y: toStartNewScaleY }), to: newSpanNewScale },\n        { from: collapseSpanToPoint(right, { x: toEndNewScale, y: toEndNewScaleY }), to: newSpanNewScale }\n      );\n    }\n  }\n  return { added, moved, removed };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nvar AreaSeriesTag = /* @__PURE__ */ ((AreaSeriesTag2) => {\n  AreaSeriesTag2[AreaSeriesTag2[\"Fill\"] = 0] = \"Fill\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Stroke\"] = 1] = \"Stroke\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Marker\"] = 2] = \"Marker\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Label\"] = 3] = \"Label\";\n  return AreaSeriesTag2;\n})(AreaSeriesTag || {});\nfunction plotSpans(ratio2, path, spans, phantomSpans) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const span = spans[i];\n    const phantomSpan = phantomSpans[i];\n    plotSpan(path.path, interpolateSpans(span.from, span.to, ratio2), 1 /* MoveTo */);\n    plotSpan(path.path, reverseSpan(interpolateSpans(phantomSpan.from, phantomSpan.to, ratio2)), 2 /* LineTo */);\n    path.path.closePath();\n  }\n}\nfunction prepareAreaPathAnimationFns(status, spans, phantomSpans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.removed, phantomSpans.removed);\n  const updatePhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.moved, phantomSpans.moved);\n  const addPhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.added, phantomSpans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData, diff2) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const spans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.spans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.spans, visible: oldData.visible },\n    0 /* Zero */\n  );\n  const phantomSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.phantomSpans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.phantomSpans, visible: oldData.visible },\n    0 /* Zero */\n  );\n  const prepareMarkerPairs = () => {\n    if (isCategoryBased) {\n      return pairCategoryData(newData, oldData, diff2, { backfillSplitMode: \"static\", multiDatum: true });\n    }\n    return pairContinuousData(newData, oldData, { backfillSplitMode: \"static\" });\n  };\n  const { resultMap: markerPairMap } = prepareMarkerPairs();\n  if (markerPairMap === void 0)\n    return;\n  const stackVisible = true;\n  const fadeMode = stackVisible ? \"none\" : \"fade\";\n  const fill = prepareAreaPathAnimationFns(status, spans, phantomSpans, fadeMode);\n  const marker = prepareMarkerAnimation(markerPairMap, status);\n  return { status, fill, marker };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: [\"fill\", \"stroke\"],\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [1 /* NEAREST_BY_MAIN_AXIS_FIRST */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const currentIds = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      stack: `area-stack-${groupIndex}-yValue-stack`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(currentIds), normalizedTo, \"range\"));\n    }\n    if (!isContinuousX && animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...groupStackValueProperty(yKey, yScaleType, {\n          id: `yValueStack`,\n          ...common,\n          groupId: currentIds.stack\n        }),\n        valueProperty(yKey, yScaleType, {\n          id: `yValue`,\n          ...common,\n          groupId: currentIds.value\n        }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: currentIds.values\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: currentIds.marker\n          },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, \"value\", processedData);\n    if (direction === \"x\" /* X */) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys), xAxis);\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent, yAxis);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueEnd`, `yValueRaw`, `yValueCumulative`]);\n    const yValueStackIndex = dataModel.resolveProcessedDataIndexById(this, \"yValueStack\");\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const itemId = yKey;\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    let datumIdx = -1;\n    groupedData?.forEach((datumGroup) => {\n      const {\n        keys,\n        keys: [xDatum],\n        datum: datumArray,\n        values: valuesArray\n      } = datumGroup;\n      valuesArray.forEach((values, valueIdx) => {\n        datumIdx++;\n        const seriesDatum = datumArray[valueIdx];\n        const dataValues2 = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n        const { yValueRaw: yDatum, yValueCumulative, yValueEnd } = dataValues2;\n        const validPoint = Number.isFinite(yDatum);\n        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n        if (validPoint && marker) {\n          markerData.push({\n            index: datumIdx,\n            series: this,\n            itemId,\n            datum: seriesDatum,\n            midPoint: { x: point.x, y: point.y },\n            cumulativeValue: yValueEnd,\n            yValue: yDatum,\n            xValue: xDatum,\n            yKey,\n            xKey,\n            point,\n            fill: marker.fill ?? seriesFill,\n            stroke: marker.stroke ?? seriesStroke,\n            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth)\n          });\n        }\n        if (validPoint && label) {\n          const labelText = this.getLabelText(\n            label,\n            {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.properties.xName,\n              yName: this.properties.yName\n            },\n            (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n          );\n          labelData.push({\n            index: datumIdx,\n            series: this,\n            itemId: yKey,\n            datum: seriesDatum,\n            x: point.x,\n            y: point.y,\n            label: labelText ? {\n              text: labelText,\n              fontStyle: label.fontStyle,\n              fontWeight: label.fontWeight,\n              fontSize: label.fontSize,\n              fontFamily: label.fontFamily,\n              textAlign: \"center\",\n              textBaseline: \"bottom\",\n              fill: label.color\n            } : void 0\n          });\n        }\n      });\n    });\n    const { interpolation } = this.properties;\n    const interpolatePoints = (points) => {\n      let spans;\n      const pointsIter = points.map((point) => point.point);\n      switch (interpolation.type) {\n        case \"linear\":\n          spans = linearPoints(pointsIter);\n          break;\n        case \"smooth\":\n          spans = smoothPoints(pointsIter, interpolation.tension);\n          break;\n        case \"step\":\n          spans = stepPoints(pointsIter, interpolation.position);\n          break;\n      }\n      return spans.map((span, i) => ({\n        span,\n        xValue0: points[i].xDatum,\n        yValue0: points[i].yDatum,\n        xValue1: points[i + 1].xDatum,\n        yValue1: points[i + 1].yDatum\n      }));\n    };\n    const spansForPoints = (points) => {\n      return points.flatMap((p) => {\n        return Array.isArray(p) ? interpolatePoints(p) : new Array(p.skip).fill(null);\n      });\n    };\n    const dataValues = groupedData?.flatMap((datumGroup) => {\n      const {\n        keys: [xDatum],\n        values: valuesArray\n      } = datumGroup;\n      return valuesArray.map((values) => ({ xDatum, values }));\n    });\n    const createPoint = (xDatum, yDatum) => ({\n      point: {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(yDatum)\n      },\n      xDatum,\n      yDatum\n    });\n    const getSeriesSpans = (index) => {\n      const points = [];\n      if (dataValues == null)\n        return [];\n      for (let i = 0; i < dataValues.length; i += 1) {\n        const { xDatum, values } = dataValues[i];\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[index];\n        const yDatumIsFinite = Number.isFinite(yDatum);\n        if (connectMissingData && !yDatumIsFinite)\n          continue;\n        const lastYValueStack = dataValues[i - 1]?.values[yValueStackIndex];\n        const nextYValueStack = dataValues[i + 1]?.values[yValueStackIndex];\n        let yValueEndBackwards = 0;\n        let yValueEndForwards = 0;\n        for (let j = 0; j <= index; j += 1) {\n          const value = yValueStack[j];\n          if (Number.isFinite(value)) {\n            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);\n            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);\n            if (lastWasFinite) {\n              yValueEndBackwards += value;\n            }\n            if (nextWasFinite) {\n              yValueEndForwards += value;\n            }\n          }\n        }\n        const currentPoints = points[points.length - 1];\n        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {\n          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {\n            points[points.length - 1] = { skip: 1 };\n          } else {\n            const pointBackwards = createPoint(xDatum, yValueEndBackwards);\n            const pointForwards = createPoint(xDatum, yValueEndForwards);\n            if (Array.isArray(currentPoints)) {\n              currentPoints.push(pointBackwards);\n            } else if (currentPoints != null) {\n              currentPoints.skip += 1;\n            }\n            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });\n          }\n        } else {\n          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);\n          const point = createPoint(xDatum, yValueEnd);\n          if (Array.isArray(currentPoints)) {\n            currentPoints.push(point);\n          } else if (currentPoints != null) {\n            currentPoints.skip += 1;\n            points.push([point]);\n          } else {\n            points.push([point]);\n          }\n        }\n      }\n      return spansForPoints(points);\n    };\n    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;\n    const getAxisSpans = () => {\n      if (dataValues == null)\n        return [];\n      const yValueZeroPoints = dataValues.map(({ xDatum, values }) => {\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[stackIndex];\n        if (connectMissingData && !Number.isFinite(yDatum))\n          return;\n        return createPoint(xDatum, 0);\n      }).filter((x) => x != null);\n      return interpolatePoints(yValueZeroPoints);\n    };\n    const currentSeriesSpans = getSeriesSpans(stackIndex);\n    const phantomSpans = currentSeriesSpans.map(() => null);\n    for (let j = stackIndex - 1; j >= -1; j -= 1) {\n      let spans;\n      for (let i = 0; i < phantomSpans.length; i += 1) {\n        if (phantomSpans[i] != null)\n          continue;\n        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());\n        phantomSpans[i] = spans[i];\n      }\n    }\n    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);\n    const strokeSpans = currentSeriesSpans.filter((span) => span != null);\n    const context = {\n      itemId,\n      fillData: { itemId, spans: fillSpans, phantomSpans },\n      strokeData: { itemId, spans: strokeSpans },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0\n    };\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke] = opts.paths;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      tag: 1 /* Stroke */,\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible\n    });\n    fill.setProperties({\n      tag: 0 /* Fill */,\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      strokeOpacity: this.properties.strokeOpacity,\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled,\n      strokeWidth\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    this.updateFillPath(paths, contextData);\n    this.updateStrokePath(paths, contextData);\n  }\n  updateFillPath(paths, contextData) {\n    const { spans, phantomSpans } = contextData.fillData;\n    const [fill] = paths;\n    const { path } = fill;\n    path.clear(true);\n    for (let i = 0; i < spans.length; i += 1) {\n      const { span } = spans[i];\n      const phantomSpan = phantomSpans[i].span;\n      plotSpan(path, span, 1 /* MoveTo */);\n      plotSpan(path, reverseSpan(phantomSpan), 2 /* LineTo */);\n      path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { spans } = contextData.strokeData;\n    const [, stroke] = paths;\n    const { path } = stroke;\n    path.clear(true);\n    for (const { span } of spans) {\n      plotSpan(path, span);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 3 /* Label */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text, datum) => {\n      const { x, y, label } = datum;\n      if (label && labelEnabled && this.visible) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = x;\n        text.y = y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const { xKey, xName, yName, tooltip, marker } = this.properties;\n    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {\n      stroke: this.properties.stroke,\n      strokeWidth: this.properties.strokeWidth\n    });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        color,\n        title,\n        seriesId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yKey,\n      yName,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      marker,\n      visible,\n      legendItemName\n    } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return [\n      {\n        legendType,\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: useAreaFill ? fill : marker.fill,\n              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n              stroke: marker.stroke ?? stroke,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke] = paths;\n    if (fill == null && stroke == null)\n      return;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateAreaPaths(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    const fns = prepareAreaPathAnimation(contextData, previousContextData, this.processedData?.reduced?.diff);\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    this.updateStrokePath(paths, contextData);\n    pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  moduleFactory: (ctx) => new AreaSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { fill: marker.fill, stroke: marker.stroke, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction* childrenIter(parent) {\n  for (const node of parent.children) {\n    yield node;\n  }\n}\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      Logger.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = series.contentGroup.transformPoint(point.x, point.y);\n  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  updateGroupScale(xAxis) {\n    const {\n      groupScale,\n      smallestDataInterval,\n      ctx: { seriesStateManager }\n    } = this;\n    const xScale = xAxis.scale;\n    const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth;\n    const domain = [];\n    const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.padding = 0.1;\n    } else {\n      groupScale.padding = 0;\n    }\n    groupScale.round = groupScale.padding !== 0;\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside\";\n  }\n};\n__decorateClass([\n  Validate(PLACEMENT)\n], BarSeriesLabel.prototype, \"placement\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction updateRect(rect, config) {\n  rect.crisp = config.crisp ?? true;\n  rect.fill = config.fill;\n  rect.stroke = config.stroke;\n  rect.strokeWidth = config.strokeWidth;\n  rect.fillOpacity = config.fillOpacity;\n  rect.strokeOpacity = config.strokeOpacity;\n  rect.lineDash = config.lineDash;\n  rect.lineDashOffset = config.lineDashOffset;\n  rect.fillShadow = config.fillShadow;\n  rect.topLeftCornerRadius = config.topLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.topRightCornerRadius = config.topRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomRightCornerRadius = config.bottomRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomLeftCornerRadius = config.bottomLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.visible = config.visible ?? true;\n}\nfunction getRectConfig({\n  datum,\n  isHighlighted,\n  style,\n  highlightStyle,\n  itemStyler,\n  seriesId,\n  ctx: { callbackCache },\n  ...opts\n}) {\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    cornerRadius = 0\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  let format;\n  if (itemStyler) {\n    format = callbackCache.call(itemStyler, {\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      highlighted: isHighlighted,\n      seriesId,\n      ...opts\n    });\n  }\n  return {\n    fill: format?.fill ?? fill,\n    fillOpacity: format?.fillOpacity ?? fillOpacity,\n    stroke: format?.stroke ?? stroke,\n    strokeWidth: format?.strokeWidth ?? strokeWidth,\n    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n    lineDash: format?.lineDash ?? lineDash,\n    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n    cornerRadius: format?.cornerRadius ?? cornerRadius,\n    topLeftCornerRadius: style.topLeftCornerRadius,\n    topRightCornerRadius: style.topRightCornerRadius,\n    bottomRightCornerRadius: style.bottomRightCornerRadius,\n    bottomLeftCornerRadius: style.bottomLeftCornerRadius,\n    fillShadow: style.fillShadow\n  };\n}\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width = isVertical ? datum.width : 0;\n    let height = isVertical ? 0 : datum.height;\n    const { opacity } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width = isVertical ? prevDatum.width : 0;\n      height = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height, width, height) : new BBox(x - width, y, width, height);\n    } else {\n      clipBBox = new BBox(x, y, width, height);\n    }\n    return { x, y, width, height, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    let source;\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    }\n    return source;\n  };\n  return { toFn, fromFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(_node, { x, y, width, height, clipBBox, opacity }) {\n  return { x, y, width, height, clipBBox, opacity };\n}\nfunction computeBarFocusBounds(datum, barGroup, seriesRect) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width, height } = datum;\n  return barGroup.inverseTransformBBox(new BBox(x, y, width, height)).clip(seriesRect);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nfunction adjustLabelPlacement({\n  isPositive,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  switch (placement) {\n    case \"start\": {\n      if (isVertical) {\n        y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\n        textBaseline = isPositive ? \"top\" : \"bottom\";\n      } else {\n        x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n    case \"outside\":\n    case \"end\": {\n      if (isVertical) {\n        y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\n        textBaseline = isPositive ? \"bottom\" : \"top\";\n      } else {\n        x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      pathsPerSeries: [],\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n  }\n  crossFilteringEnabled() {\n    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\n    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const extraProps = [];\n    if (isFiniteNumber(normalizedTo)) {\n      extraProps.push(\n        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), \"range\")\n      );\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),\n        ...this.crossFilteringEnabled() ? [\n          valueProperty(yFilterKey, yScaleType, {\n            id: `yFilterValue`,\n            invalidValue: null,\n            ...visibleProps\n          })\n        ] : [],\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    let yExtent = dataModel.getDomain(this, `yValue-end`, \"value\", processedData);\n    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, \"value\", processedData) : void 0;\n    if (yFilterExtent != null) {\n      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];\n    }\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      const scalePadding = isFiniteNumber(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;\n      const keysExtent = extent(keys) ?? [NaN, NaN];\n      const d0 = keysExtent[0] + -scalePadding;\n      const d1 = keysExtent[1] + scalePadding;\n      return fixNumericExtent([d0, d1], categoryAxis);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent, valueAxis);\n    } else {\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent(fixedYExtent, valueAxis);\n    }\n  }\n  async createNodeData() {\n    const { dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);\n    const yFilterIndex = this.crossFilteringEnabled() ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);\n    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);\n    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const nodeDatum = ({\n      datum,\n      valueIndex,\n      xValue,\n      yValue,\n      cumulativeValue,\n      phantom,\n      currY,\n      prevY,\n      isPositive,\n      yRange,\n      labelText,\n      crossScale = 1\n    }) => {\n      const x = xScale.convert(xValue);\n      const isUpward = isPositive !== yReversed;\n      const barX = x + groupScale.convert(String(groupIndex)) + barOffset;\n      const y = yScale.convert(currY);\n      const bottomY = yScale.convert(prevY);\n      const barAlongX = this.getBarDirection() === \"x\" /* X */;\n      const bboxHeight = yScale.convert(yRange);\n      const bboxBottom = yScale.convert(0);\n      const xOffset = barWidth * 0.5 * (1 - crossScale);\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(y, bottomY),\n        width: barAlongX ? Math.abs(bottomY - y) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bottomY - y)\n      };\n      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n      const barRect = {\n        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(bboxBottom, bboxHeight),\n        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bboxBottom - bboxHeight)\n      };\n      const {\n        fontStyle: labelFontStyle,\n        fontWeight: labelFontWeight,\n        fontSize: labelFontSize,\n        fontFamily: labelFontFamily,\n        color: labelColor,\n        placement\n      } = label;\n      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n      return {\n        series: this,\n        itemId: phantom ? createDatumId(yKey, phantom) : yKey,\n        datum,\n        valueIndex,\n        cumulativeValue,\n        phantom,\n        xValue,\n        yValue,\n        yKey,\n        xKey,\n        capDefaults: {\n          lengthRatioMultiplier,\n          lengthMax: lengthRatioMultiplier\n        },\n        x: barRect.x,\n        y: barRect.y,\n        width: barRect.width,\n        height: barRect.height,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        fill,\n        stroke,\n        opacity: 1,\n        strokeWidth,\n        cornerRadius,\n        topLeftCornerRadius: barAlongX !== isUpward,\n        topRightCornerRadius: isUpward,\n        bottomRightCornerRadius: barAlongX === isUpward,\n        bottomLeftCornerRadius: !isUpward,\n        clipBBox,\n        label: labelText != null ? {\n          text: labelText,\n          fill: labelColor,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          ...adjustLabelPlacement({\n            isPositive,\n            isVertical: !barAlongX,\n            placement,\n            rect\n          })\n        } : void 0,\n        missing: yValue == null,\n        focusable: !phantom\n      };\n    };\n    const { groupScale, processedData } = this;\n    const phantomNodes = [];\n    const nodes = [];\n    const labels = [];\n    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {\n      values.forEach((value, valueIndex) => {\n        const xValue = keys[xIndex];\n        const yRawValue = value[yRawIndex];\n        const yStart = Number(value[yStartIndex]);\n        const yFilterValue = yFilterIndex != null ? Number(value[yFilterIndex]) : void 0;\n        const yEnd = Number(value[yEndIndex]);\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;\n        if (!Number.isFinite(yEnd))\n          return;\n        if (yFilterValue != null && !Number.isFinite(yFilterValue))\n          return;\n        const labelText = yRawValue != null ? this.getLabelText(\n          this.properties.label,\n          {\n            datum: seriesDatum[valueIndex],\n            value: yFilterValue ?? yRawValue,\n            xKey,\n            yKey,\n            xName,\n            yName,\n            legendItemName\n          },\n          (v) => isFiniteNumber(v) ? v.toFixed(2) : String(v)\n        ) : void 0;\n        const inset = yFilterValue != null && yFilterValue > yRawValue;\n        const nodeData = nodeDatum({\n          datum: seriesDatum[valueIndex],\n          valueIndex,\n          xValue,\n          yValue: yFilterValue ?? yRawValue,\n          cumulativeValue: yFilterValue ?? yEnd,\n          phantom: false,\n          currY: yFilterValue != null ? yStart + yFilterValue : yEnd,\n          prevY: yStart,\n          isPositive,\n          yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),\n          labelText,\n          crossScale: inset ? 0.6 : void 0\n        });\n        nodes.push(nodeData);\n        labels.push(nodeData);\n        if (yFilterValue != null) {\n          const phantomNodeData = nodeDatum({\n            datum: seriesDatum[valueIndex],\n            valueIndex,\n            xValue,\n            yValue: yFilterValue,\n            cumulativeValue: yFilterValue,\n            phantom: true,\n            currY: yEnd,\n            prevY: yStart,\n            isPositive,\n            yRange,\n            labelText: void 0,\n            crossScale: void 0\n          });\n          phantomNodes.push(phantomNodeData);\n        }\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,\n      labelData: labels,\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled\n    };\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItem = nodeData.find(\n      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom\n    );\n    return highlightItem != null ? [highlightItem] : void 0;\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom)\n    );\n  }\n  async updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      stackGroup,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      shadow,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[\"x\" /* X */];\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    const style = {\n      fill,\n      stroke,\n      lineDash,\n      lineDashOffset,\n      fillShadow: shadow,\n      strokeWidth: this.getStrokeWidth(strokeWidth),\n      fillOpacity: 0,\n      strokeOpacity: 0\n    };\n    const rectParams = {\n      datum: void 0,\n      ctx: this.ctx,\n      seriesId: this.id,\n      isHighlighted: opts.isHighlight,\n      highlightStyle: itemHighlightStyle,\n      yKey,\n      style,\n      itemStyler,\n      stackGroup\n    };\n    opts.datumSelection.each((rect, datum) => {\n      style.fillOpacity = fillOpacity * (datum.phantom ? 0.2 : 1);\n      style.strokeOpacity = strokeOpacity * (datum.phantom ? 0.2 : 1);\n      style.cornerRadius = datum.cornerRadius;\n      style.topLeftCornerRadius = datum.topLeftCornerRadius;\n      style.topRightCornerRadius = datum.topRightCornerRadius;\n      style.bottomRightCornerRadius = datum.bottomRightCornerRadius;\n      style.bottomLeftCornerRadius = datum.bottomLeftCornerRadius;\n      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      rectParams.datum = datum;\n      const config = getRectConfig(rectParams);\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect(rect, config);\n    });\n  }\n  async updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text) => {\n      text.pointerEvents = 1 /* None */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;\n    const { xValue, yValue, datum, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        stackGroup,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        cornerRadius: this.properties.cornerRadius,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        lineDash: this.properties.lineDash ?? [],\n        lineDashOffset: this.properties.lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        stackGroup,\n        title,\n        color,\n        legendItemName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.data?.length || !this.properties.isValid() || !showInLegend) {\n      return [];\n    }\n    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? yName ?? yKey },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  moduleFactory: (ctx) => new BarSeries(ctx),\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  swapDefaultAxesCondition: (series) => series?.direction === \"horizontal\",\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        placement: \"inside\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta = 1e-6;\nvar isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class {\n  constructor() {\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const { xKey, yKey, sizeKey, labelKey, colorDomain, colorRange, colorKey, marker } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale } = this;\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, label, colorKey, marker, visible } = this.properties;\n    const markerShape = getMarker(marker.shape);\n    const { placement } = label;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : -1;\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = textMeasurer.measureText(String(labelText));\n      const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue: values[sizeDataIdx],\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      marker.getStyle()\n    );\n    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }))\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;\n    const title = this.properties.title ?? yName;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },\n      baseStyle\n    );\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: { text: labelText },\n      itemId\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id\n      }\n    );\n  }\n  getLegendData() {\n    if (!this.data?.length || !this.properties.isValid()) {\n      return [];\n    }\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  moduleFactory: (ctx) => new BubbleSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start, stop, binSize, segments);\n  }\n  getBins(start, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start + i * step) * precision) / precision;\n      let b = Math.round((start + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start = Math.floor(a / magnitude) * magnitude;\n    return {\n      start,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (item) => {\n        const xValue = item.keys[0];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, { props, groupByFn });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      axes,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;\n    const {\n      formatter: labelFormatter = (params) => String(params.value),\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor\n    } = this.properties.label;\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || !processedData || processedData.type !== \"grouped\")\n      return context;\n    processedData.data.forEach((group) => {\n      const {\n        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n        datum,\n        datum: { length: frequency },\n        keys: domain,\n        keys: [xDomainMin, xDomainMax]\n      } = group;\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          text: callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName,\n            yName\n          }) ?? String(total),\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          fill: labelColor,\n          x: x + w / 2,\n          y: y + h / 2\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        cornerRadius,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        opacity: 1,\n        strokeWidth,\n        label: selectionDatumLabel\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(\n      nodeData,\n      (rect) => {\n        rect.tag = 0 /* Bin */;\n        rect.crisp = true;\n      },\n      (datum) => datum.domain.join(\"_\")\n    );\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      fillOpacity: seriesFillOpacity,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      shadow,\n      highlightStyle: {\n        item: {\n          fill: highlightedFill,\n          fillOpacity: highlightFillOpacity = seriesFillOpacity,\n          stroke: highlightedStroke,\n          strokeWidth: highlightedDatumStrokeWidth\n        }\n      }\n    } = this.properties;\n    opts.datumSelection.each((rect, datum, index) => {\n      const {\n        cornerRadius,\n        topLeftCornerRadius,\n        topRightCornerRadius,\n        bottomRightCornerRadius,\n        bottomLeftCornerRadius\n      } = datum;\n      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;\n      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;\n      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;\n      rect.fillOpacity = fillOpacity;\n      rect.strokeOpacity = strokeOpacity;\n      rect.strokeWidth = strokeWidth;\n      rect.lineDash = lineDash;\n      rect.lineDashOffset = lineDashOffset;\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.fillShadow = shadow;\n      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n      rect.visible = datum.height > 0;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      text.textAlign = \"center\";\n      text.textBaseline = \"middle\";\n    });\n  }\n  async updateLabelNodes(opts) {\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text, datum) => {\n      const label = datum.label;\n      if (label && labelEnabled) {\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fontStyle = label.fontStyle;\n        text.fontWeight = label.fontWeight;\n        text.fontSize = label.fontSize;\n        text.fontFamily = label.fontFamily;\n        text.fill = label.fill;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, childrenIter(this.contentGroup.children[0]));\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax],\n      itemId\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : \"\";\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      itemId,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId: this.id\n    });\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || legendType !== \"category\") {\n      return [];\n    }\n    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: xKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: yName ?? xKey ?? \"Frequency\"\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity,\n              strokeOpacity,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  moduleFactory: (ctx) => new HistogramSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return { fill, stroke };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new LineSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (stackCount > 1) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: ids[0]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          {\n            id: `yValueStart`,\n            ...common,\n            groupId: ids[1]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: ids[2]\n          },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, \"range\"));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.processedData));\n      }\n    }\n    await this.requestDataModel(dataController, data, { props });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === \"x\" /* X */) {\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain), xAxis);\n    } else {\n      const stackCount = this.seriesGrouping?.stackCount ?? 1;\n      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, \"value\", processedData) : dataModel.getDomain(this, `yValueRaw`, \"value\", processedData);\n      return fixNumericExtent(domain, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { processedData, dataModel, axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!processedData || !dataModel || !xAxis || !yAxis) {\n      return;\n    }\n    const { xKey, yKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;\n    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const size = marker.enabled ? marker.size : 0;\n    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);\n    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;\n    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;\n    let moveTo = true;\n    processedData.data?.forEach(({ datum, values }) => {\n      const xDatum = values[xIdx];\n      const yDatum = values[yIdx];\n      const yCumulativeDatum = values[yCumulativeIdx];\n      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;\n      if (yDatum == null) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const x = xScale.convert(xDatum) + xOffset;\n      if (isNaN(x)) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const y = yScale.convert(yCumulativeDatum) + yOffset;\n      const labelText = this.getLabelText(\n        label,\n        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },\n        (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n      );\n      nodeData.push({\n        series: this,\n        datum,\n        yKey,\n        xKey,\n        point: { x, y, moveTo, size },\n        midPoint: { x, y },\n        cumulativeValue: yEndDatum,\n        yValue: yDatum,\n        xValue: xDatum,\n        capDefaults: {\n          lengthRatioMultiplier: this.properties.marker.getDiameter(),\n          lengthMax: Infinity\n        },\n        label: labelText ? {\n          text: labelText,\n          fontStyle: label.fontStyle,\n          fontWeight: label.fontWeight,\n          fontSize: label.fontSize,\n          fontFamily: label.fontFamily,\n          textAlign: \"center\",\n          textBaseline: \"bottom\",\n          fill: label.color\n        } : void 0\n      });\n      moveTo = false;\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  async updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const { shape, enabled } = this.properties.marker;\n    nodeData = shape && enabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  async updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text, datum) => {\n      const { point, label } = datum;\n      if (datum && label && enabled) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = point.x;\n        text.y = point.y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(this.properties.title ?? yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!(this.data?.length && this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        legendItemName,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? color0,\n              stroke: marker.stroke ?? stroke ?? color0,\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled\n            },\n            line: {\n              stroke: stroke ?? color0,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  async updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  updateLinePaths(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { nodeData } = contextData;\n    const [lineNode] = paths;\n    lineNode.path.clear(true);\n    for (const range3 of pathRanges(nodeData)) {\n      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);\n    }\n    lineNode.checkPathDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    const fns = prepareLinePathAnimation(\n      contextData,\n      previousContextData,\n      this.processedData?.reduced?.diff,\n      this.properties.interpolation\n    );\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.pathProperties);\n    pathMotion(this.id, \"path_update\", animationManager, [path], fns.path);\n    if (fns.hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  moduleFactory: (ctx) => new LineSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale } = this;\n    const { xKey, yKey, labelKey, colorKey, xName, yName, labelName, marker, label, visible } = this.properties;\n    const { placement } = label;\n    const markerShape = getMarker(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = textMeasurer.measureText(labelText);\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map(({ datum, x, y }) => ({\n        ...datum,\n        point: { x, y, size: datum.point.size },\n        placement: \"top\"\n      })),\n      (text) => {\n        text.pointerEvents = 1 /* None */;\n      }\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, label, itemId } = nodeDatum;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },\n      baseStyle\n    );\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  moduleFactory: (ctx) => new ScatterSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start = 0;\n  let end = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start + end) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start = s;\n    } else {\n      end = s;\n    }\n  }\n  return start;\n}\nvar delta2 = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta2) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x = NaN;\n  let p0y = NaN;\n  let p1x = NaN;\n  let p1y = NaN;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    let { innerRadius, outerRadius } = this;\n    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;\n    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);\n    return { innerRadius, outerRadius };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta3 = 1e-6;\n      if (!start && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3))\n        return;\n      if (start && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3))\n        return;\n      if (inner && !(radius >= clipSector.innerRadius - delta3))\n        return;\n      if (!inner && !(radius <= clipSector.outerRadius + delta3))\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - innerAngleOffset)\n        );\n        arc.clipEnd(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + innerAngleOffset)\n        );\n      } else {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + outerAngleOffset)\n        );\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - outerAngleOffset));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta3 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta3;\n    path.clear();\n    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {\n      return;\n    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);\n      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = radialEdgeInset;\n      }\n      r = Math.max(r, innerRadius);\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(point.x - this.centerX, point.y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      Logger.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke = sect.stroke ?? stroke;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance3 = 0;\n      if (radius < sector.innerRadius) {\n        distance3 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance3 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance3 };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return this.itemGroup.children;\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text = new Text();\n    text.pointerEvents = 1 /* None */;\n    return text;\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return { seriesRect };\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      Circle\n    );\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        focusable: true,\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0),\n          focusable: false\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      if (datum.itemId === highlightedDatum?.itemId) {\n        node.visible = true;\n        updateSectorFn(node, datum, index, true);\n      } else {\n        node.visible = false;\n      }\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        text.x = datum.midCos * labelRadius;\n        text.y = datum.midSin * labelRadius;\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = \"center\";\n      text.textBaseline = \"alphabetic\";\n      textBBoxes.push(text.getBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      spacing: 2\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  moduleFactory: (ctx) => new DonutSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation } = this.properties;\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0)\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        strokeOpacity,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      if (datum.itemId === highlightedDatum?.itemId) {\n        node.visible = true;\n        updateSectorFn(node, datum, index, true);\n      } else {\n        node.visible = false;\n      }\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  moduleFactory: (ctx) => new PieSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts\nvar ToolbarGroupProperties = class extends BaseProperties {\n  constructor(onChange, onButtonsChange) {\n    super();\n    this.onChange = onChange;\n    this.onButtonsChange = onButtonsChange;\n    this.align = \"start\";\n    this.position = \"top\" /* Top */;\n    this.size = \"normal\";\n    this.buttonOverrides = /* @__PURE__ */ new Map();\n  }\n  buttonConfigurations() {\n    return this.buttons?.map((button) => {\n      const id = button.id ?? button.value;\n      const overrides = this.buttonOverrides.get(id);\n      return overrides != null ? { ...button, ...overrides } : button;\n    }) ?? [];\n  }\n  buttonsChanged(configurationOnly) {\n    this.onButtonsChange(this.buttonConfigurations(), configurationOnly);\n  }\n  overrideButtonConfiguration(id, options) {\n    let overrides = this.buttonOverrides.get(id);\n    if (overrides == null) {\n      overrides = /* @__PURE__ */ Object.create(null);\n      this.buttonOverrides.set(id, overrides);\n    }\n    for (const key in options) {\n      const value = options[key];\n      if (value == null) {\n        delete overrides[key];\n      } else {\n        overrides[key] = value;\n      }\n    }\n    this.buttonsChanged(true);\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })\n], ToolbarGroupProperties.prototype, \"align\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })\n], ToolbarGroupProperties.prototype, \"position\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([\"small\", \"normal\"]), { optional: true })\n], ToolbarGroupProperties.prototype, \"size\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    for (const button of target.buttons ?? []) {\n      if (button.icon != null && ICONS_LEGACY.includes(button.icon)) {\n        Logger.warnOnce(`Icon '${button.icon}' is deprecated, use another icon instead.`);\n      }\n      if (button.ariaLabel === \"toolbarAnnotationsColor\") {\n        Logger.warnOnce(\n          `Aria label '${button.ariaLabel}' is deprecated, use 'toolbarAnnotationsLineColor' instead.`\n        );\n      }\n    }\n    target.buttonsChanged(false);\n  }),\n  Validate(ARRAY, { optional: true })\n], ToolbarGroupProperties.prototype, \"buttons\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts\nvar block2 = \"ag-charts-toolbar\";\nvar elements2 = {\n  align: \"ag-charts-toolbar__align\",\n  section: \"ag-charts-toolbar__section\",\n  button: \"ag-charts-toolbar__button\",\n  icon: \"ag-charts-toolbar__icon\",\n  label: \"ag-charts-toolbar__label\"\n};\nvar modifiers2 = {\n  [\"top\" /* Top */]: \"ag-charts-toolbar--top\",\n  [\"right\" /* Right */]: \"ag-charts-toolbar--right\",\n  [\"bottom\" /* Bottom */]: \"ag-charts-toolbar--bottom\",\n  [\"left\" /* Left */]: \"ag-charts-toolbar--left\",\n  [\"floating\" /* Floating */]: \"ag-charts-toolbar--floating\",\n  [\"floating-top\" /* FloatingTop */]: \"ag-charts-toolbar--floating-top\",\n  [\"floating-bottom\" /* FloatingBottom */]: \"ag-charts-toolbar--floating-bottom\",\n  small: \"ag-charts-toolbar--small\",\n  normal: \"ag-charts-toolbar--normal\",\n  hidden: \"ag-charts-toolbar--hidden\",\n  preventFlash: \"ag-charts-toolbar--prevent-flash\",\n  floatingHidden: \"ag-charts-toolbar--floating-hidden\",\n  align: {\n    start: \"ag-charts-toolbar__align--start\",\n    center: \"ag-charts-toolbar__align--center\",\n    end: \"ag-charts-toolbar__align--end\"\n  },\n  button: {\n    active: `ag-charts-toolbar__button--active`,\n    hiddenValue: `ag-charts-toolbar__button--hidden-value`,\n    hiddenToggled: `ag-charts-toolbar__button--hidden-toggled`,\n    fillVisible: `ag-charts-toolbar__button--fill-visible`\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbar.ts\nvar Toolbar = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.seriesType = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"seriesType\"),\n      this.onGroupButtonsChanged.bind(this, \"seriesType\")\n    );\n    this.annotations = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotations\"),\n      this.onGroupButtonsChanged.bind(this, \"annotations\")\n    );\n    this.annotationOptions = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotationOptions\"),\n      this.onGroupButtonsChanged.bind(this, \"annotationOptions\")\n    );\n    this.ranges = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"ranges\"),\n      this.onGroupButtonsChanged.bind(this, \"ranges\")\n    );\n    this.zoom = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"zoom\"),\n      this.onGroupButtonsChanged.bind(this, \"zoom\")\n    );\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.floatingDetectionRange = 38;\n    this.positions = {\n      [\"top\" /* Top */]: /* @__PURE__ */ new Set(),\n      [\"right\" /* Right */]: /* @__PURE__ */ new Set(),\n      [\"bottom\" /* Bottom */]: /* @__PURE__ */ new Set(),\n      [\"left\" /* Left */]: /* @__PURE__ */ new Set(),\n      [\"floating\" /* Floating */]: /* @__PURE__ */ new Set(),\n      [\"floating-top\" /* FloatingTop */]: /* @__PURE__ */ new Set(),\n      [\"floating-bottom\" /* FloatingBottom */]: /* @__PURE__ */ new Set()\n    };\n    this.positionAlignments = {\n      [\"top\" /* Top */]: {},\n      [\"right\" /* Right */]: {},\n      [\"bottom\" /* Bottom */]: {},\n      [\"left\" /* Left */]: {},\n      [\"floating\" /* Floating */]: {},\n      [\"floating-top\" /* FloatingTop */]: {},\n      [\"floating-bottom\" /* FloatingBottom */]: {}\n    };\n    this.groupCallers = {\n      seriesType: /* @__PURE__ */ new Set(),\n      annotations: /* @__PURE__ */ new Set(),\n      annotationOptions: /* @__PURE__ */ new Set(),\n      ranges: /* @__PURE__ */ new Set(),\n      zoom: /* @__PURE__ */ new Set()\n    };\n    this.groupButtons = {\n      seriesType: [],\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.ariaToolbars = [\n      { groups: [\"seriesType\", \"annotations\"], destroyFns: [] },\n      { groups: [\"annotationOptions\"], destroyFns: [] },\n      { groups: [\"ranges\"], destroyFns: [] },\n      { groups: [\"zoom\"], destroyFns: [] }\n    ];\n    this.pendingButtonToggledEvents = [];\n    this.groupProxied = /* @__PURE__ */ new Map();\n    this.hasNewLocale = true;\n    this.elements = {};\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position] = ctx.domManager.addChild(\"canvas-overlay\", `toolbar-${position}`);\n      this.elements[position].role = \"presentation\";\n      this.renderToolbar(position);\n    }\n    this.toggleVisibilities();\n    this.destroyFns.push(\n      ctx.interactionManager.addListener(\"hover\", this.onHover.bind(this), 31 /* All */),\n      ctx.interactionManager.addListener(\"leave\", this.onLeave.bind(this), 31 /* All */),\n      ctx.toolbarManager.addListener(\"button-toggled\", this.onButtonToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"button-updated\", this.onButtonUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"group-toggled\", this.onGroupToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"floating-anchor-changed\", this.onFloatingAnchorChanged.bind(this)),\n      ctx.toolbarManager.addListener(\"proxy-group-options\", this.onProxyGroupOptions.bind(this)),\n      ctx.layoutService.addListener(\"layout-complete\", this.onLayoutComplete.bind(this)),\n      ctx.localeManager.addListener(\"locale-changed\", () => {\n        this.hasNewLocale = true;\n      }),\n      () => this.destroyElements()\n    );\n  }\n  destroyElements() {\n    this.ctx.domManager.removeStyles(block2);\n    for (const element2 of Object.keys(this.elements)) {\n      this.ctx.domManager.removeChild(\"canvas-overlay\", `toolbar-${element2}`);\n    }\n  }\n  onHover(event) {\n    const {\n      enabled,\n      elements: elements3,\n      floatingDetectionRange,\n      ctx: { scene }\n    } = this;\n    const {\n      offsetY,\n      sourceEvent: { target }\n    } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled)\n      return;\n    const bottom = elements3[FloatingBottom];\n    const top = elements3[FloatingTop];\n    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;\n    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;\n    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;\n    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;\n    this.translateFloatingElements(FloatingBottom, bottomVisible);\n    this.translateFloatingElements(FloatingTop, topVisible);\n  }\n  onLeave(event) {\n    const {\n      enabled,\n      ctx: { scene }\n    } = this;\n    const { relatedElement, targetElement } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled || targetElement !== scene.canvas.element)\n      return;\n    const isTargetButton = TOOLBAR_GROUPS.some(\n      (group) => this.groupButtons[group].some((button) => button === relatedElement)\n    );\n    if (isTargetButton)\n      return;\n    this.translateFloatingElements(FloatingBottom, false);\n    this.translateFloatingElements(FloatingTop, false);\n  }\n  onGroupChanged(group) {\n    if (this[group] == null || this.groupProxied.has(group))\n      return;\n    this.createGroup(group);\n    this.toggleVisibilities();\n  }\n  onGroupButtonsChanged(group, buttons, configurationOnly) {\n    if (!this.enabled || this.groupProxied.has(group))\n      return;\n    if (configurationOnly) {\n      for (const buttonOptions of this[group].buttonConfigurations()) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n    } else {\n      this.createGroupButtons(group, buttons);\n    }\n    this.toggleVisibilities();\n  }\n  onLayoutComplete() {\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position].classList.remove(modifiers2.preventFlash);\n    }\n  }\n  onButtonUpdated(event) {\n    const { type: _type, group, id, ...params } = event;\n    this[group].overrideButtonConfiguration(id, { ...params });\n  }\n  setButtonActive(button, active) {\n    button.classList.toggle(modifiers2.button.active, active);\n  }\n  onButtonToggled(event) {\n    const { group, id, active, enabled, visible } = event;\n    if (this.groupButtons[group].length === 0) {\n      this.pendingButtonToggledEvents.push(event);\n      return;\n    }\n    for (const button of this.groupButtons[group]) {\n      if (button.dataset.toolbarId !== `${id}`)\n        continue;\n      button.ariaDisabled = `${!enabled}`;\n      setVisibility(button, modifiers2.button.hiddenToggled, !visible);\n      this.setButtonActive(button, active);\n    }\n  }\n  onGroupToggled(event) {\n    const { caller, group, active, visible } = event;\n    this.toggleGroup(caller, group, active, visible);\n    this.toggleVisibilities();\n  }\n  onFloatingAnchorChanged(event) {\n    const {\n      elements: elements3,\n      groupButtons,\n      positions,\n      horizontalSpacing,\n      verticalSpacing,\n      ctx: { domManager, toolbarManager }\n    } = this;\n    const { group, anchor } = event;\n    if (!positions[\"floating\" /* Floating */].has(group))\n      return;\n    const element2 = elements3[\"floating\" /* Floating */];\n    if (element2.classList.contains(modifiers2.hidden))\n      return;\n    const position = anchor.position ?? \"above\";\n    const { offsetWidth: width, offsetHeight: height } = element2;\n    let top = anchor.y - height - verticalSpacing;\n    let left = anchor.x - width / 2;\n    if (position === \"right\") {\n      top = anchor.y - height / 2;\n      left = anchor.x + horizontalSpacing;\n    } else if (position === \"above-left\") {\n      left = anchor.x;\n    }\n    const canvasRect = domManager.getBoundingClientRect();\n    top = clamp(0, top, canvasRect.height - height);\n    left = clamp(0, left, canvasRect.width - width);\n    element2.style.top = `${top}px`;\n    element2.style.left = `${left}px`;\n    const groupBBox = new BBox(left, top, width, height);\n    for (const button of groupButtons[group]) {\n      if (button.classList.contains(modifiers2.button.hiddenToggled))\n        continue;\n      const parent = button.offsetParent;\n      toolbarManager.buttonMoved(\n        group,\n        button.dataset.toolbarId,\n        new BBox(\n          button.offsetLeft + (parent?.offsetLeft ?? 0),\n          button.offsetTop + (parent?.offsetTop ?? 0),\n          button.offsetWidth,\n          button.offsetHeight\n        ),\n        groupBBox\n      );\n    }\n  }\n  buttonRect(button, canvasRect = this.ctx.domManager.getBoundingClientRect()) {\n    const buttonRect = button.getBoundingClientRect();\n    return new BBox(\n      buttonRect.left - canvasRect.left,\n      buttonRect.top - canvasRect.top,\n      buttonRect.width,\n      buttonRect.height\n    );\n  }\n  onProxyGroupOptions(event) {\n    if (!this.enabled)\n      return;\n    const { caller, group, options } = event;\n    this.groupProxied.set(group, options);\n    this[group].set(options);\n    this.toggleGroup(caller, group, void 0, options.enabled);\n    this.createGroup(group, options.enabled, options.position);\n    if (options.enabled) {\n      this.createGroupButtons(group, options.buttons);\n    }\n  }\n  createGroup(group, enabled, position) {\n    enabled ?? (enabled = this[group].enabled);\n    position ?? (position = this[group].position);\n    for (const pos of TOOLBAR_POSITIONS) {\n      if (enabled && position === pos) {\n        this.positions[pos].add(group);\n      } else {\n        this.positions[pos].delete(group);\n      }\n    }\n  }\n  createGroupButtons(group, buttons = []) {\n    for (const button of this.groupButtons[group]) {\n      button.remove();\n    }\n    const ariaToolbar = this.getAriaToolbar(group);\n    this.groupButtons[group] = [];\n    ariaToolbar.destroyFns.forEach((d) => d());\n    ariaToolbar.destroyFns = [];\n    if (buttons.length === 0)\n      return;\n    const { align, position } = this[group];\n    const alignElement = this.positionAlignments[position][align];\n    if (!alignElement)\n      return;\n    const nextSection = (section2) => {\n      const alignElementChildren = Array.from(alignElement.children);\n      const dataGroup = \"data-group\";\n      const dataSection = \"data-section\";\n      let sectionElement = alignElementChildren.find((prevSection2) => {\n        return prevSection2.getAttribute(dataGroup) === group && prevSection2.getAttribute(dataSection) === (section2 ?? \"\");\n      });\n      if (!sectionElement) {\n        sectionElement = createElement(\"div\");\n        sectionElement.role = \"presentation\";\n        sectionElement.setAttribute(dataGroup, group);\n        sectionElement.setAttribute(dataSection, section2 ?? \"\");\n        const groupIndex = TOOLBAR_GROUP_ORDERING[group];\n        const insertBeforeElement = alignElementChildren.find((prevSection2) => {\n          const prevGroup = prevSection2.getAttribute(dataGroup);\n          const prevGroupIndex = TOOLBAR_GROUP_ORDERING[prevGroup];\n          return prevGroupIndex > groupIndex;\n        });\n        if (insertBeforeElement != null) {\n          alignElement.insertBefore(sectionElement, insertBeforeElement);\n        } else {\n          alignElement.appendChild(sectionElement);\n        }\n        this.destroyFns.push(() => sectionElement.remove());\n      }\n      sectionElement.classList.add(elements2.section, modifiers2[this[group].size]);\n      return sectionElement;\n    };\n    let prevSection = buttons.at(0)?.section;\n    let section = nextSection(prevSection);\n    for (const options of buttons) {\n      if (prevSection !== options.section) {\n        section = nextSection(options.section);\n      }\n      prevSection = options.section;\n      const button = this.createButtonElement(group, options);\n      section.appendChild(button);\n      this.groupButtons[group].push(button);\n    }\n    const onEscape = () => {\n      this.ctx.toolbarManager.cancel(group);\n    };\n    let onFocus;\n    let onBlur;\n    if (isAnimatingFloatingPosition(position)) {\n      onFocus = () => this.translateFloatingElements(position, true);\n      onBlur = () => this.translateFloatingElements(position, false);\n    }\n    const orientation = this.computeAriaOrientation(this[group].position);\n    const ariaToolbarButtons = ariaToolbar.groups.map((g) => this.groupButtons[g]).flat();\n    ariaToolbar.destroyFns = initToolbarKeyNav({\n      orientation,\n      toolbar: alignElement,\n      buttons: ariaToolbarButtons,\n      onEscape,\n      onFocus,\n      onBlur\n    });\n    this.updateToolbarAriaLabel(group, alignElement);\n  }\n  computeAriaOrientation(position) {\n    return {\n      top: \"horizontal\",\n      right: \"vertical\",\n      bottom: \"horizontal\",\n      left: \"vertical\",\n      floating: \"horizontal\",\n      \"floating-top\": \"horizontal\",\n      \"floating-bottom\": \"horizontal\"\n    }[position];\n  }\n  toggleGroup(caller, group, active, enabled) {\n    if (enabled === true) {\n      this.groupCallers[group].add(caller);\n    } else if (enabled === false) {\n      this.groupCallers[group].delete(caller);\n    }\n    if (active != null) {\n      for (const button of this.groupButtons[group]) {\n        this.setButtonActive(button, active);\n      }\n    }\n  }\n  processPendingEvents() {\n    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();\n    for (const event of pendingButtonToggledEvents) {\n      this.onButtonToggled(event);\n    }\n    this.pendingButtonToggledEvents = [];\n  }\n  async performLayout(ctx) {\n    if (!this.enabled)\n      return ctx;\n    this.refreshOuterLayout(ctx.shrinkRect);\n    this.refreshLocale();\n    return ctx;\n  }\n  async performCartesianLayout(opts) {\n    if (!this.enabled)\n      return;\n    this.refreshInnerLayout(opts.seriesRect);\n  }\n  refreshOuterLayout(shrinkRect) {\n    const { elements: elements3, horizontalSpacing, verticalSpacing } = this;\n    if (!elements3.top.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.top.offsetHeight + verticalSpacing, \"top\");\n    }\n    if (!elements3.right.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.right.offsetWidth + horizontalSpacing, \"right\");\n    }\n    if (!elements3.bottom.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.bottom.offsetHeight + verticalSpacing, \"bottom\");\n      elements3.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;\n    }\n    if (!elements3.left.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.left.offsetWidth + horizontalSpacing, \"left\");\n    }\n  }\n  refreshLocale() {\n    const { hasNewLocale } = this;\n    if (!hasNewLocale)\n      return;\n    for (const group of TOOLBAR_GROUPS) {\n      const buttons = this[group].buttonConfigurations();\n      for (const buttonOptions of buttons) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n      this.updateToolbarAriaLabel(group);\n    }\n    this.hasNewLocale = false;\n  }\n  refreshInnerLayout(rect) {\n    const { elements: elements3, verticalSpacing } = this;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    elements3.top.style.top = `${rect.y - elements3.top.offsetHeight - verticalSpacing}px`;\n    elements3.top.style.left = `${rect.x}px`;\n    elements3.top.style.width = `${rect.width}px`;\n    elements3.bottom.style.left = `${rect.x}px`;\n    elements3.bottom.style.width = `${rect.width}px`;\n    elements3.right.style.top = `${rect.y}px`;\n    elements3.right.style.right = `0px`;\n    elements3.right.style.height = `${rect.height}px`;\n    elements3.left.style.top = `${rect.y}px`;\n    elements3.left.style.left = `0px`;\n    elements3.left.style.height = `${rect.height}px`;\n    elements3[FloatingTop].style.top = `${rect.y}px`;\n    elements3[FloatingBottom].style.top = `${rect.y + rect.height - elements3[FloatingBottom].offsetHeight}px`;\n  }\n  refreshButtonContent(group, buttonOptions) {\n    const id = this.buttonId(buttonOptions);\n    const button = this.groupProxied.get(group)?.buttons?.find((b) => this.buttonId(b) === id) ?? buttonOptions;\n    const element2 = this.groupButtons[group].find((b) => b.getAttribute(\"data-toolbar-id\") === id);\n    if (element2 == null)\n      return;\n    this.updateButton(element2, button);\n  }\n  toggleVisibilities() {\n    if (this.elements == null)\n      return;\n    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;\n    const isButtonVisible = (element2) => (button) => {\n      const id = this.buttonId(button);\n      return id == null || id === element2.dataset.toolbarId;\n    };\n    for (const position of TOOLBAR_POSITIONS) {\n      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);\n      setVisibility(this.elements[position], modifiers2.hidden, !visible);\n    }\n    for (const group of TOOLBAR_GROUPS) {\n      if (this[group] == null)\n        continue;\n      const groupVisible = isGroupVisible(group);\n      for (const button of this.groupButtons[group]) {\n        const buttonVisible = groupVisible && this[group].buttonConfigurations().some(isButtonVisible(button));\n        setVisibility(button, modifiers2.button.hiddenValue, !buttonVisible);\n      }\n    }\n  }\n  translateFloatingElements(position, visible) {\n    const { elements: elements3, verticalSpacing: verticalMargin, positionAlignments } = this;\n    const element2 = elements3[position];\n    const alignments = Object.values(positionAlignments[position]);\n    setVisibility(element2, modifiers2.floatingHidden, !visible);\n    const dir = position === \"floating-bottom\" /* FloatingBottom */ ? 1 : -1;\n    for (const align of alignments) {\n      align.style.transform = visible && align.style.transform !== \"\" ? \"translateY(0)\" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;\n    }\n  }\n  renderToolbar(position = \"top\" /* Top */) {\n    const element2 = this.elements[position];\n    element2.classList.add(block2, modifiers2[position], modifiers2.preventFlash);\n    if (isAnimatingFloatingPosition(position)) {\n      element2.classList.add(modifiers2.floatingHidden);\n    }\n    for (const align of TOOLBAR_ALIGNMENTS) {\n      const alignmentElement = createElement(\"div\");\n      alignmentElement.role = \"presentation\";\n      alignmentElement.classList.add(elements2.align, modifiers2.align[align]);\n      alignmentElement.dataset.pointerCapture = \"exclusive\";\n      element2.appendChild(alignmentElement);\n      this.positionAlignments[position][align] = alignmentElement;\n    }\n  }\n  createButtonElement(group, options) {\n    const button = createElement(\"button\");\n    button.classList.add(elements2.button);\n    button.dataset.toolbarGroup = group;\n    button.tabIndex = -1;\n    button.dataset.toolbarId = this.buttonId(options);\n    button.onclick = makeAccessibleClickListener(\n      button,\n      this.onButtonPress.bind(this, button, group, options.id, options.value)\n    );\n    this.updateButton(button, options);\n    this.destroyFns.push(() => button.remove());\n    return button;\n  }\n  getAriaToolbar(group) {\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        return ariaToolbar;\n      }\n    }\n    throw new Error(`AG Charts - cannot find aria-toolbar of '${group}'`);\n  }\n  updateToolbarAriaLabel(group, alignElement) {\n    if (!alignElement) {\n      const { align, position } = this[group];\n      alignElement = this.positionAlignments[position][align];\n      if (!alignElement)\n        return;\n    }\n    const map = {\n      seriesType: \"ariaLabelFinancialCharts\",\n      annotations: \"ariaLabelFinancialCharts\",\n      annotationOptions: \"ariaLabelAnnotationOptionsToolbar\",\n      ranges: \"ariaLabelRangesToolbar\",\n      zoom: \"ariaLabelZoomToolbar\"\n    };\n    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);\n  }\n  updateButton(button, options) {\n    const {\n      ctx: { domManager, localeManager }\n    } = this;\n    if (options.tooltip) {\n      const tooltip = localeManager.t(options.tooltip);\n      button.title = tooltip;\n    }\n    let inner = \"\";\n    if (options.icon != null) {\n      inner = `<span class=\"${domManager.getIconClassNames(options.icon)} ${elements2.icon}\"></span>`;\n    }\n    if (options.label != null) {\n      const label = localeManager.t(options.label);\n      inner = `${inner}<span class=\"${elements2.label}\">${label}</span>`;\n    }\n    button.innerHTML = inner;\n    button.classList.toggle(modifiers2.button.fillVisible, options.fill != null);\n    button.style.setProperty(\"--fill\", options.fill ?? null);\n    const ariaLabel = options.ariaLabel ? this.ctx.localeManager.t(options.ariaLabel) : void 0;\n    setAttribute(button, \"aria-label\", ariaLabel);\n  }\n  onButtonPress(button, group, id, value) {\n    this.ctx.toolbarManager.pressButton(group, this.buttonId({ id, value }), value, this.buttonRect(button));\n  }\n  buttonId(button) {\n    const { id, value, label } = button;\n    if (id != null)\n      return id;\n    if (value != null && typeof value !== \"object\")\n      return String(value);\n    return label ?? \"\";\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.processPendingEvents();\n    target.toggleVisibilities();\n  }),\n  Validate(BOOLEAN)\n], Toolbar.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts\nvar DAY = 1e3 * 60 * 60 * 24;\nvar MONTH = DAY * 30;\nvar YEAR = DAY * 365;\nvar seriesType = {\n  enabled: false,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      tooltip: \"toolbarSeriesTypeDropdown\",\n      value: \"type\"\n    }\n  ]\n};\nvar annotations = {\n  enabled: true,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"trend-line-drawing\",\n      tooltip: \"toolbarAnnotationsLineAnnotations\",\n      value: \"line-menu\",\n      section: \"line-annotations\"\n    },\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextAnnotations\",\n      value: \"text-menu\",\n      section: \"text-annotations\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsClearAll\",\n      value: \"clear\",\n      section: \"tools\"\n    }\n  ]\n};\nvar annotationOptions = {\n  enabled: true,\n  position: \"floating\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextColor\",\n      value: \"text-color\"\n    },\n    {\n      icon: \"line-color\",\n      tooltip: \"toolbarAnnotationsLineColor\",\n      value: \"line-color\"\n    },\n    {\n      icon: \"fill-color\",\n      tooltip: \"toolbarAnnotationsFillColor\",\n      value: \"fill-color\"\n    },\n    {\n      tooltip: \"toolbarAnnotationsTextSize\",\n      value: \"text-size\"\n    },\n    {\n      icon: \"unlocked\",\n      tooltip: \"toolbarAnnotationsLock\",\n      value: \"lock\"\n    },\n    {\n      icon: \"locked\",\n      tooltip: \"toolbarAnnotationsUnlock\",\n      value: \"unlock\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsDelete\",\n      value: \"delete\"\n    }\n  ]\n};\nvar ranges = {\n  enabled: false,\n  position: DEFAULT_TOOLBAR_POSITION,\n  align: \"start\",\n  buttons: [\n    {\n      label: \"toolbarRange1Month\",\n      ariaLabel: \"toolbarRange1MonthAria\",\n      value: MONTH\n    },\n    {\n      label: \"toolbarRange3Months\",\n      ariaLabel: \"toolbarRange3MonthsAria\",\n      value: 3 * MONTH\n    },\n    {\n      label: \"toolbarRange6Months\",\n      ariaLabel: \"toolbarRange6MonthsAria\",\n      value: 6 * MONTH\n    },\n    {\n      label: \"toolbarRangeYearToDate\",\n      ariaLabel: \"toolbarRangeYearToDateAria\",\n      value: (_start, end) => [(/* @__PURE__ */ new Date(`${new Date(end).getFullYear()}-01-01`)).getTime(), end],\n      id: \"year-to-date\"\n    },\n    {\n      label: \"toolbarRange1Year\",\n      ariaLabel: \"toolbarRange1YearAria\",\n      value: YEAR\n    },\n    {\n      label: \"toolbarRangeAll\",\n      ariaLabel: \"toolbarRangeAllAria\",\n      value: (start, end) => [start, end],\n      id: \"all\"\n    }\n  ]\n};\nvar zoom = {\n  enabled: true,\n  position: \"top\",\n  align: \"end\",\n  buttons: [\n    {\n      icon: \"zoom-out\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\"\n    },\n    {\n      icon: \"zoom-in\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\"\n    },\n    {\n      icon: \"pan-start\",\n      tooltip: \"toolbarZoomPanStart\",\n      value: \"pan-start\"\n    },\n    {\n      icon: \"pan-end\",\n      tooltip: \"toolbarZoomPanEnd\",\n      value: \"pan-end\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\"\n    }\n  ]\n};\nvar ToolbarModule = {\n  type: \"root\",\n  optionsKey: \"toolbar\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Toolbar(ctx),\n  themeTemplate: {\n    toolbar: {\n      enabled: true,\n      seriesType,\n      annotations,\n      annotationOptions,\n      ranges,\n      zoom\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    NavigatorModule,\n    ToolbarModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      moduleFactory: (ctx) => new AxisConstructor(ctx),\n      hidden: AxisConstructor === GroupedCategoryAxis\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType2 of m.chartTypes) {\n        chartDefaults.set(chartType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType2 of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);\n        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/flowProportionChart.ts\nfunction isFlowProportion(series) {\n  return series.type === \"sankey\" || series.type === \"chord\";\n}\nvar FlowProportionChart = class extends Chart {\n  getChartType() {\n    return \"flow-proportion\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { nodes } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isFlowProportion(series)) {\n        series.setChartNodes(nodes);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(fullSeriesRect.x, fullSeriesRect.y, fullSeriesRect.width, fullSeriesRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nFlowProportionChart.className = \"FlowProportionChart\";\nFlowProportionChart.type = \"flow-proportion\";\n\n// packages/ag-charts-community/src/chart/hierarchyChart.ts\nvar HierarchyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"hierarchy\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n    }\n    await Promise.all(\n      this.series.map(async (series) => {\n        await series.update({ seriesRect: shrinkRect });\n      })\n    );\n    seriesRoot.visible = this.series[0].visible;\n    seriesRoot.setClipRectInGroupCoordinateSpace(\n      new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n    );\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  getAriaLabel() {\n    const captionText = this.getCaptionText();\n    return `hierarchical chart, ${captionText}`;\n  }\n};\nHierarchyChart.className = \"HierarchyChart\";\nHierarchyChart.type = \"hierarchy\";\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND_ZINDEX */;\n  }\n  getChartType() {\n    return \"polar\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const fullSeriesRect = shrinkRect.clone();\n    this.computeSeriesRect(shrinkRect);\n    await this.computeCircle(shrinkRect);\n    this.axes.forEach((axis) => axis.update());\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  updateAxes(cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\n      return;\n    }\n    const angleScale = angleAxis.scale;\n    const angles = angleScale.ticks?.().map((value) => angleScale.convert(value));\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange?.();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angles;\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  computeSeriesRect(shrinkRect) {\n    const {\n      seriesArea: { padding }\n    } = this;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter((series) => {\n      return series instanceof PolarSeries;\n    });\n    const polarAxes = this.axes.filter((axis) => {\n      return axis instanceof PolarAxis;\n    });\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.x + seriesBox.width / 2;\n    const centerY = seriesBox.y + seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of [...polarAxes, ...polarSeries]) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      if (refined.radius === radius) {\n        return;\n      }\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale {\n  constructor(domain, range3) {\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/topologyChart.ts\nfunction isTopologySeries(series) {\n  return series.type === \"map-shape\" || series.type === \"map-line\" || series.type === \"map-marker\" || series.type === \"map-shape-background\" || series.type === \"map-line-background\";\n}\nvar TopologyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.xAxis = new NumberAxis(this.getModuleContext());\n    this.xAxis.position = \"bottom\";\n    this.yAxis = new NumberAxis(this.getModuleContext());\n    this.yAxis.position = \"left\";\n    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);\n  }\n  getChartType() {\n    return \"topology\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { topology } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isTopologySeries(series)) {\n        series.setChartTopology(topology);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    const mapSeries = this.series.filter(isTopologySeries);\n    const combinedBbox = mapSeries.reduce((combined, series) => {\n      if (!series.visible)\n        return combined;\n      const bbox = series.topologyBounds;\n      if (bbox == null)\n        return combined;\n      if (combined == null)\n        return bbox;\n      combined.merge(bbox);\n      return combined;\n    }, void 0);\n    let scale2;\n    if (combinedBbox != null) {\n      const { lon0, lat0, lon1, lat1 } = combinedBbox;\n      const domain = [\n        [lon0, lat0],\n        [lon1, lat1]\n      ];\n      const bounds = MercatorScale.bounds(domain);\n      const { width, height } = shrinkRect;\n      const viewBoxScale = Math.min(width / bounds.width, height / bounds.height);\n      const viewBoxWidth = bounds.width * viewBoxScale;\n      const viewBoxHeight = bounds.height * viewBoxScale;\n      const viewBoxOriginX = (width - viewBoxWidth) / 2;\n      const viewBoxOriginY = (height - viewBoxHeight) / 2;\n      const x0 = viewBoxOriginX;\n      const y0 = viewBoxOriginY;\n      const x1 = viewBoxOriginX + viewBoxWidth;\n      const y1 = viewBoxOriginY + viewBoxHeight;\n      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);\n      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);\n      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);\n      const xStart = x0 - xSpan * xZoom.min;\n      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));\n      const yStart = y0 - ySpan * (1 - yZoom.max);\n      scale2 = new MercatorScale(domain, [\n        [xStart, yStart],\n        [xStart + xSpan, yStart + ySpan]\n      ]);\n    }\n    mapSeries.forEach((series) => {\n      series.scale = scale2;\n    });\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nTopologyChart.className = \"TopologyChart\";\nTopologyChart.type = \"topology\";\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nvar chartTypes2 = [\"ohlc\", \"line\", \"step-line\", \"hlc\", \"high-low\", \"candlestick\", \"hollow-candlestick\"];\nfunction priceVolume(opts, getTheme) {\n  const {\n    xKey,\n    dateKey = xKey ?? \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType: chartType2 = \"candlestick\",\n    navigator: navigator2 = false,\n    volume = true,\n    rangeToolbar,\n    rangeButtons = rangeToolbar ?? true,\n    statusBar = true,\n    annotations: annotations2,\n    toolbar = annotations2 ?? true,\n    zoom: zoom2 = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  if (xKey != null) {\n    Logger.warnOnce(\"Property [xKey] is deprecated, use [dateKey] instead.\");\n  }\n  if (rangeToolbar != null) {\n    Logger.warnOnce(\"Property [rangeToolbar] is deprecated, use [rangeButtons] instead.\");\n  }\n  if (annotations2 != null) {\n    Logger.warnOnce(\"Property [annotations] is deprecated, use [toolbar] instead.\");\n  }\n  const priceSeries = createPriceSeries(theme, chartType2, dateKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator2,\n      series: [\n        {\n          type: \"line\",\n          xKey: dateKey,\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator2,\n      ...miniChart\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom2,\n      // @ts-expect-error\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = {\n    chartToolbar: { enabled: true },\n    toolbar: {\n      seriesType: {\n        enabled: toolbar\n      },\n      annotationOptions: {\n        enabled: toolbar\n      },\n      annotations: {\n        enabled: toolbar\n      },\n      ranges: {\n        enabled: rangeButtons\n      }\n    }\n  };\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      }\n    }\n  ] : [];\n  return {\n    theme: typeof theme === \"string\" ? theme : {\n      baseTheme: \"ag-financial\",\n      ...theme ?? {}\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    padding: {\n      top: 6,\n      right: 8,\n      bottom: 5\n    },\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    annotations: {\n      enabled: toolbar\n    },\n    tooltip: { enabled: false },\n    data,\n    // @ts-expect-error\n    titlePadding: 4,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      tooltip: { enabled: false },\n      // @ts-expect-error\n      highlight: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {\n  if (chartType2 === RANGE_AREA_TYPE) {\n    Logger.warnOnce(`type '${chartType2}' is deprecated, use 'hlc' chart type instead`);\n    chartType2 = \"hlc\";\n  }\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  const common = {\n    pickOutsideVisibleMinorAxis: true\n  };\n  switch (chartType2 ?? \"candlestick\") {\n    case \"ohlc\":\n      return [\n        {\n          type: \"ohlc\",\n          ...common,\n          ...keys\n        }\n      ];\n    case \"line\":\n      return [\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"step-line\":\n      return [\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n            type: \"step\"\n          },\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"hlc\":\n      const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);\n      return [\n        {\n          type: RANGE_AREA_TYPE,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: closeKey,\n          fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: RANGE_AREA_TYPE,\n          ...common,\n          xKey,\n          yHighKey: closeKey,\n          yLowKey: lowKey,\n          fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"high-low\":\n      const rangeBarColors = getThemeColors(\"range-bar\", theme);\n      return [\n        {\n          type: \"range-bar\",\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: lowKey,\n          fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,\n          stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,\n          tooltip: {\n            range: \"nearest\"\n          }\n        }\n      ];\n    case \"candlestick\":\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys\n        }\n      ];\n    case \"hollow-candlestick\":\n      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys,\n          item: {\n            up: {\n              fill: item?.up?.fill ?? \"transparent\"\n            }\n          }\n        }\n      ];\n    default:\n      Logger.warnOnce(`unknown chart type: ${chartType2}; expected one of: ${chartTypes2.join(\", \")}`);\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys\n        }\n      ];\n  }\n}\nfunction getThemeColors(seriesType2, theme) {\n  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.fill);\n  const stroke = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.stroke);\n  return { fill, stroke };\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options, silent) {\n  const usedOptions = [];\n  const optionsChartType = chartTypes.get(optionsType(options));\n  for (const {\n    type,\n    chartTypes: moduleChartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !moduleChartTypes.includes(optionsChartType))\n      continue;\n    if (type === \"root\" || type === \"legend\") {\n      const optionValue = options[optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === identifier))\n        continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== identifier);\n    } else if (type === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[optionsKey]))\n        continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type === \"series\") {\n      if (!options.series?.some((series) => series.type === identifier))\n        continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter((series) => series.type !== identifier);\n    } else if (type === \"series-option\") {\n      if (!options.series?.some((series) => series[optionsKey]))\n        continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length && !silent) {\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://charts.ag-grid.com/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    Logger.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// packages/ag-charts-community/src/util/string.util.ts\nfunction stringifyValue(value, maxLength = Infinity) {\n  switch (typeof value) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"number\":\n      if (isNaN(value)) {\n        return \"NaN\";\n      } else if (value === Infinity) {\n        return \"Infinity\";\n      } else if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n    default:\n      value = JSON.stringify(value);\n      if (value.length > maxLength) {\n        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;\n      }\n      return value;\n  }\n}\n\n// packages/ag-charts-community/src/util/validate.ts\nvar descriptionSymbol = Symbol(\"description\");\nvar requiredSymbol = Symbol(\"required\");\nfunction isValid(options, optionsDefs, path) {\n  const { errors } = validate(options, optionsDefs, path);\n  for (const { message } of errors) {\n    Logger.warn(message);\n  }\n  return errors.length === 0;\n}\nfunction validateMessage(path, value, validatorOrDefs) {\n  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];\n  const expecting = description ? `; expecting ${description}` : \"\";\n  const prefix = path ? `Option \\`${path}\\`` : \"Value\";\n  return `${prefix} cannot be set to \\`${stringifyValue(value)}\\`${expecting}, ignoring.`;\n}\nfunction validate(options, optionsDefs, path = \"\") {\n  if (!isObject(options)) {\n    return {\n      valid: null,\n      errors: [{ path, value: options, message: validateMessage(path, options, \"an object\") }]\n    };\n  }\n  const optionsKeys = new Set(Object.keys(options));\n  const errors = [];\n  const valid = {};\n  function extendPath(key) {\n    if (isArray(optionsDefs)) {\n      return `${path}[${key}]`;\n    }\n    return path ? `${path}.${key}` : key;\n  }\n  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {\n    optionsKeys.delete(key);\n    const value = options[key];\n    if (!validatorOrDefs[requiredSymbol] && typeof value === \"undefined\")\n      continue;\n    if (isFunction(validatorOrDefs)) {\n      if (validatorOrDefs(value)) {\n        valid[key] = value;\n      } else {\n        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });\n      }\n    } else {\n      const nestedResult = validate(value, validatorOrDefs, extendPath(key));\n      valid[key] = nestedResult.valid;\n      errors.push(...nestedResult.errors);\n    }\n  }\n  for (const key of optionsKeys) {\n    errors.push({\n      key,\n      path,\n      unknown: true,\n      message: `Unknown option \\`${extendPath(key)}\\`, ignoring.`\n    });\n  }\n  return { valid, errors };\n}\nfunction attachDescription(validator, description) {\n  return Object.assign((value) => validator(value), { [descriptionSymbol]: description });\n}\nvar or = (...validators) => attachDescription(\n  (value) => validators.some((validator) => validator(value)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" or \")\n);\nvar array = attachDescription(isArray, \"an array\");\nvar boolean = attachDescription(isBoolean, \"a boolean\");\nvar callback = attachDescription(isFunction, \"a function\");\nvar number = attachDescription(isFiniteNumber, \"a number\");\nvar object = attachDescription(isObject, \"an object\");\nvar string = attachDescription(isString, \"a string\");\nvar numberMin = (min, inclusive = true) => attachDescription(\n  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),\n  `a number greater than ${inclusive ? \"or equal to \" : \"\"}${min}`\n);\nvar numberRange = (min, max) => attachDescription(\n  (value) => isFiniteNumber(value) && value >= min && value <= max,\n  `a number between ${min} and ${max} inclusive`\n);\nvar positiveNumber = numberMin(0);\nvar minOneNumber = numberMin(1);\nvar ratio = numberRange(0, 1);\nvar degree = numberRange(0, 360);\nvar arrayOf = (validator, description) => attachDescription(\n  (value) => isArray(value) && value.every(validator),\n  description ?? `${validator[descriptionSymbol]} array`\n);\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };\n  }\n};\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontSize: 12 /* SMALL */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        color: DEFAULT_LABEL_COLOUR,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: 12 /* SMALL */,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      },\n      crosshair: {\n        enabled: true\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },\n      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 17 /* LARGE */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: \"rgb(140, 140, 140)\",\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontSize: 12 /* SMALL */,\n            fontFamily: DEFAULT_FONT_FAMILY\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: DEFAULT_LABEL_COLOUR },\n          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },\n          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },\n          label: { color: DEFAULT_LABEL_COLOUR }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    if (overrides) {\n      this.mergeOverrides(defaults, overrides);\n    }\n    const { fills, strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = mergeDefaults(palette, {\n      fills: Object.values(fills),\n      strokes: Object.values(strokes),\n      ...otherColors\n    });\n    this.paletteType = paletteType(palette);\n    this.config = Object.freeze(this.templateTheme(defaults));\n  }\n  mergeOverrides(defaults, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType2 = s;\n        defaults[seriesType2] = mergeDefaults(cleanedCommon, defaults[seriesType2]);\n      }\n    }\n    chartTypes.seriesTypes.forEach((s) => {\n      const seriesType2 = s;\n      if (overrides[seriesType2]) {\n        defaults[seriesType2] = mergeDefaults(overrides[seriesType2], defaults[seriesType2]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType2 of seriesTypes) {\n        config[seriesType2] || (config[seriesType2] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType2, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType2)\n      };\n      for (const seriesType2 of seriesTypes) {\n        result[seriesType2] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType2),\n          result[seriesType2] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType2];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes.flowProportionTypes)\n    );\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = deepClone(themeTemplate);\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, (node) => {\n      if (isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (params.has(symbol)) {\n            node[i] = params.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (params.has(value)) {\n            node[name] = params.get(value);\n          }\n        }\n      }\n    });\n    return deepClone(themeInstance);\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },\n      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },\n      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(DEFAULT_FONT_FAMILY, \"Verdana, sans-serif\");\n    params.set(DEFAULT_LABEL_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INVERTED_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"rgb(140, 140, 140)\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"rgb(224,234,241)\");\n    params.set(DEFAULT_AXIS_LINE_COLOUR, \"rgb(195, 195, 195)\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"rgba(0, 0, 0, 0.5)\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_PADDING, 20);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#ffffff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#ffffff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_TEXTBOX_FILL, \"#fafafa\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#dddddd\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#000000\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);\n    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: { enabled: false }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  \"grouped-category\": _ChartTheme.getAxisDefaults({\n    tick: { enabled: true }\n  })\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },\n      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },\n      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"#7D91A0\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#545A6E\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"white\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, \"white\");\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_TEXTBOX_FILL, \"#28313e\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#4b525d\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#ffffff\");\n    return params;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#343A4E\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#F2F3F3\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },\n      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },\n      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\",\n  GRAY: \"#eeeeee\"\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\",\n  GRAY: \"#888888\"\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },\n      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },\n      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },\n      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },\n      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },\n      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },\n      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },\n      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },\n      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = () => new ChartTheme();\nvar darkTheme = () => new DarkTheme();\nvar themes = {\n  // darkThemes,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": () => new SheetsDark(),\n  \"ag-polychroma-dark\": () => new PolychromaDark(),\n  \"ag-vivid-dark\": () => new VividDark(),\n  \"ag-material-dark\": () => new MaterialDark(),\n  \"ag-financial-dark\": () => new FinancialDark(),\n  // lightThemes,\n  null: lightTheme,\n  undefined: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": () => new SheetsLight(),\n  \"ag-polychroma\": () => new PolychromaLight(),\n  \"ag-vivid\": () => new VividLight(),\n  \"ag-material\": () => new MaterialLight(),\n  \"ag-financial\": () => new FinancialLight()\n};\nfunction getChartTheme(value) {\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  if (isValid(value, themeOptionsDef, \"theme\")) {\n    const flattenedTheme = reduceThemeOptions(value);\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n    return new baseTheme.constructor(flattenedTheme);\n  }\n  return lightTheme();\n}\nfunction reduceThemeOptions(options) {\n  let maybeNested = options;\n  let palette;\n  const overrides = [];\n  while (typeof maybeNested === \"object\") {\n    palette ?? (palette = maybeNested.palette);\n    if (maybeNested.overrides) {\n      overrides.push(maybeNested.overrides);\n    }\n    maybeNested = maybeNested.baseTheme;\n  }\n  return {\n    baseTheme: maybeNested,\n    overrides: mergeDefaults(...overrides),\n    palette\n  };\n}\nvar themeOptionsDef = {\n  baseTheme: or(string, object),\n  overrides: object,\n  palette: {\n    fills: arrayOf(string),\n    strokes: arrayOf(string),\n    up: { fill: string, stroke: string },\n    down: { fill: string, stroke: string },\n    neutral: { fill: string, stroke: string }\n  }\n};\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar ChartOptions = class {\n  constructor(userOptions, specialOverrides) {\n    this.debug = Debug.create(true, \"opts\");\n    var _a;\n    const cloneOptions = { shallow: [\"data\"] };\n    userOptions = deepClone(userOptions, cloneOptions);\n    const chartType2 = this.optionsType(userOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(userOptions);\n    }\n    let options = deepClone(userOptions, cloneOptions);\n    this.type = specialOverrides?.type;\n    if (this.type != null) {\n      const presetOptions = PRESETS[this.type]?.(options, () => this.activeTheme) ?? options;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", options, presetOptions);\n      options = presetOptions;\n    }\n    this.activeTheme = getChartTheme(options.theme);\n    if (this.type) {\n      options = this.activeTheme.templateTheme(options);\n    }\n    this.sanityCheckAndCleanup(options);\n    this.defaultAxes = this.getDefaultAxes(options);\n    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    const {\n      axes: axesThemes = {},\n      annotations: { axesButtons = null, ...annotationsThemes } = {},\n      series: _,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(chartType2);\n    this.userOptions = userOptions;\n    this.processedOptions = deepClone(\n      mergeDefaults(\n        options,\n        axesButtons != null ? { annotations: { axesButtons } } : {},\n        themeDefaults,\n        this.defaultAxes\n      ),\n      cloneOptions\n    );\n    this.processAxesOptions(this.processedOptions, axesThemes);\n    this.processSeriesOptions(this.processedOptions);\n    this.processMiniChartSeriesOptions(this.processedOptions);\n    this.annotationThemes = annotationsThemes;\n    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {\n      (_a = this.processedOptions).legend ?? (_a.legend = {});\n      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(this.processedOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(this.processedOptions, true);\n    }\n  }\n  getOptions() {\n    return this.processedOptions ?? {};\n  }\n  diffOptions(options) {\n    return jsonDiff(options, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType2) {\n    const themeConfig = deepClone(this.activeTheme?.config[seriesType2] ?? {});\n    this.removeLeftoverSymbols(themeConfig);\n    return themeConfig;\n  }\n  getDefaultAxes(options) {\n    const optionsType2 = this.optionsType(options);\n    const axesDefaults = seriesRegistry.cloneDefaultAxes(optionsType2);\n    if (seriesRegistry.isDefaultAxisSwapNeeded(options)) {\n      this.swapAxesPosition(axesDefaults);\n    }\n    return axesDefaults;\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheckAndCleanup(options) {\n    this.deprecationWarnings(options);\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n    this.removeDisabledOptions(options);\n    this.removeLeftoverSymbols(options);\n    if (options.series?.some((s) => s.type === \"bullet\") && options.sync != null && options.sync.enabled !== false) {\n      Logger.warnOnce(\"bullet series cannot be synced, disabling synchronization.\");\n      delete options.sync;\n    }\n  }\n  swapAxesPosition(options) {\n    if (isAgCartesianChartOptions(options)) {\n      const [axis0, axis1] = options.axes ?? [];\n      options.axes = [\n        { ...axis0, position: axis1.position },\n        { ...axis1, position: axis0.position }\n      ];\n    }\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options) {\n    const defaultSeriesType = this.getDefaultSeriesType(options);\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = defaultSeriesType);\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions)\n      );\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getSeriesPalette(seriesType2, options) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType2);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = this.activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: this.activeTheme.getTemplateParameters(),\n      palette: this.activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */:\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType2 = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType: seriesType2, series: [series], groupId: \"__default__\" });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType: seriesType2, series: [], groupId };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return \"line\";\n    } else if (isAgPolarChartOptions(options)) {\n      return \"pie\";\n    } else if (isAgHierarchyChartOptions(options)) {\n      return \"treemap\";\n    } else if (isAgTopologyChartOptions(options)) {\n      return \"map-shape\";\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return \"sankey\";\n    }\n    throw new Error(\"Invalid chart options type detected.\");\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType2) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType2)?.range\n      }\n    };\n  }\n  deprecationWarnings(options) {\n    const deprecatedArrayProps = { yKeys: \"yKey\", yNames: \"yName\" };\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n      if (options.series?.some((s) => s[oldProp] != null)) {\n        Logger.warnOnce(\n          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`\n        );\n      }\n    });\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options) {\n      const axes = options.axes ?? [];\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = axisRegistry.publicKeys().join(\", \");\n          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      Logger.warnOnce(\n        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        Logger.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  enableConfiguredOptions(options) {\n    jsonWalk(\n      this.userOptions,\n      (visitingUserOpts, visitingMergedOpts) => {\n        if (visitingMergedOpts && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n          visitingMergedOpts.enabled = true;\n        }\n      },\n      { skip: [\"data\", \"theme\"] },\n      options\n    );\n    jsonWalk(\n      options,\n      (visitingMergedOpts) => {\n        if (visitingMergedOpts._enabledFromTheme != null) {\n          delete visitingMergedOpts._enabledFromTheme;\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n          Object.keys(optionsNode).forEach((key) => {\n            if (key === \"enabled\")\n              return;\n            delete optionsNode[key];\n          });\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (!optionsNode || !isObject(optionsNode))\n          return;\n        for (const [key, value] of Object.entries(optionsNode)) {\n          if (isSymbol(value)) {\n            delete optionsNode[key];\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n\n// packages/ag-charts-community/src/api/agCharts.ts\nvar debug2 = Debug.create(true, \"opts\");\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return \"cartesian\";\n  } else if (isAgPolarChartOptions(options)) {\n    return \"polar\";\n  } else if (isAgHierarchyChartOptions(options)) {\n    return \"hierarchy\";\n  } else if (isAgTopologyChartOptions(options)) {\n    return \"topology\";\n  } else if (isAgFlowProportionChartOptions(options)) {\n    return \"flow-proportion\";\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  static setGridContext(gridContext) {\n    this.gridContext = gridContext;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(options) {\n    this.licenseCheck(options);\n    const chart = AgChartsInternal.createOrUpdate(options, void 0, this.licenseManager);\n    if (enterpriseModule.styles != null) {\n      chart.chart.ctx.domManager.addStyles(\"ag-charts-enterprise\", enterpriseModule.styles);\n    }\n    if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {\n      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  static createFinancialChart(options) {\n    return this.create({\n      _type: \"price-volume\",\n      ...options\n    });\n  }\n};\nAgCharts.licenseChecked = false;\nAgCharts.gridContext = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(options, proxy, licenseManager) {\n    _AgChartsInternal.initialiseModules();\n    debug2(\">>> AgCharts.createOrUpdate() user options\", options);\n    const defaultType = proxy?.chart.chartOptions.type;\n    const { _type = defaultType, ...otherOptions } = options;\n    let mutableOptions = otherOptions;\n    if (AgCharts.optionsMutationFn) {\n      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, _type);\n      debug2(\">>> AgCharts.createOrUpdate() MUTATED user options\", options);\n    }\n    const { overrideDevicePixelRatio, document: document2, window: userWindow, ...userOptions } = mutableOptions;\n    const chartOptions = new ChartOptions(userOptions, {\n      overrideDevicePixelRatio,\n      document: document2,\n      window: userWindow,\n      type: _type\n    });\n    let chart = proxy?.chart;\n    if (chart == null || chartType(userOptions) !== chartType(chart?.chartOptions.processedOptions)) {\n      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);\n    } else {\n      proxy.chart = chart;\n    }\n    if (debug2.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(userOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      chartRef.applyOptions(chartOptions);\n      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;\n      chartRef.queuedUserOptions.splice(0, queueIdx);\n    });\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, { shallow: [\"data\"] });\n    jsonWalk(\n      deltaOptions,\n      (node) => {\n        if (typeof node !== \"object\")\n          return;\n        for (const [key, value] of Object.entries(node)) {\n          if (typeof value === \"undefined\") {\n            Object.assign(node, { [key]: Symbol(\"UNSET\") });\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n    const { chart } = proxy;\n    const lastUpdateOptions = chart.getOptions();\n    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);\n    debug2(\">>> AgCharts.updateUserDelta() user delta\", deltaOptions);\n    debug2(\"AgCharts.updateUserDelta() - base options\", lastUpdateOptions);\n    _AgChartsInternal.createOrUpdate(userOptions, proxy);\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);\n    return new ChartConstructor(options, transferableResource);\n  }\n  static getChartByOptions(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return CartesianChart;\n    } else if (isAgHierarchyChartOptions(options)) {\n      return HierarchyChart;\n    } else if (isAgPolarChartOptions(options)) {\n      return PolarChart;\n    } else if (isAgTopologyChartOptions(options)) {\n      return TopologyChart;\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return FlowProportionChart;\n    }\n    throw new Error(\n      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  createOrUpdate(opts, chart) {\n    return _AgChartsInternal.createOrUpdate(opts, chart);\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  BBox: () => BBox,\n  BandScale: () => BandScale,\n  Caption: () => Caption,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Circle: () => Circle,\n  ContinuousScale: () => ContinuousScale,\n  Diamond: () => Diamond,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  Group: () => Group,\n  HdpiCanvas: () => HdpiCanvas,\n  Image: () => Image,\n  Label: () => Label,\n  Line: () => Line,\n  LinearGradientFill: () => LinearGradientFill,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Node: () => Node,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  RedrawType: () => RedrawType,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Shape: () => Shape,\n  Square: () => Square,\n  SvgPath: () => SvgPath,\n  Text: () => Text,\n  Tooltip: () => Tooltip,\n  Triangle: () => Triangle,\n  drawCorner: () => drawCorner,\n  easing: () => easing_exports,\n  evaluateBezier: () => evaluateBezier,\n  getFont: () => getFont,\n  getMarker: () => getMarker,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  motion: () => motion,\n  sectorBox: () => sectorBox,\n  solveBezier: () => solveBezier,\n  splitBezier: () => splitBezier,\n  toRadians: () => toRadians,\n  toTooltipHtml: () => toTooltipHtml\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);\n  }\n};\nArc2.className = \"Arc\";\nArc2.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  lineWidth: 1,\n  fillStyle: null\n});\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/shape/linearGradientFill.ts\nvar LinearGradientFill = class extends Shape {\n  constructor() {\n    super(...arguments);\n    this.direction = \"to-right\";\n    this.stops = void 0;\n    this._mask = void 0;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(newMask) {\n    if (this._mask != null) {\n      this.removeChild(this._mask);\n    }\n    if (newMask != null) {\n      this.appendChild(newMask);\n    }\n    this._mask = newMask;\n  }\n  isPointInPath(x, y) {\n    return this.mask?.isPointInPath(x, y) ?? false;\n  }\n  computeBBox() {\n    return this.mask?.getBBox();\n  }\n  render(renderCtx) {\n    const { mask, stops } = this;\n    const { ctx, devicePixelRatio } = renderCtx;\n    const pixelLength = 1 / devicePixelRatio;\n    const maskBbox = mask?.computeTransformedBBox();\n    if (mask == null || stops == null || maskBbox == null)\n      return;\n    if (mask.dirtyPath) {\n      mask.updatePath();\n      mask.dirtyPath = false;\n    }\n    ctx.save();\n    ctx.clip(mask.path.getPath2D());\n    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    const x0 = Math.floor(maskBbox.x);\n    const x1 = Math.ceil(maskBbox.x + maskBbox.width);\n    const y0 = Math.floor(maskBbox.y);\n    const y1 = Math.ceil(maskBbox.y + maskBbox.height);\n    const horizontal = this.direction === \"to-right\" || this.direction === \"to-left\";\n    const reversed = this.direction === \"to-top\" || this.direction === \"to-left\";\n    const colorScale = new ColorScale();\n    const [i0, i1] = horizontal ? [x0, x1] : [y0, y1];\n    colorScale.domain = stops.map((_, index) => {\n      return i0 + (i1 - i0) * index / (stops.length - 1);\n    });\n    colorScale.range = reversed ? stops.slice().reverse() : stops;\n    colorScale.update();\n    const height = y1 - y0;\n    const width = x1 - x0;\n    switch (this.direction) {\n      case \"to-right\":\n      case \"to-left\":\n        for (let x = x0; x <= x1; x += pixelLength) {\n          ctx.fillStyle = colorScale.convert(x);\n          ctx.fillRect(x, y0, pixelLength, height);\n        }\n        break;\n      case \"to-bottom\":\n      case \"to-top\":\n        for (let y = y0; y <= y1; y += pixelLength) {\n          ctx.fillStyle = colorScale.convert(y);\n          ctx.fillRect(x0, y, width, pixelLength);\n        }\n        break;\n    }\n    ctx.restore();\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"direction\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"stops\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"_mask\", 2);\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty = isEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/scene/shape/svgPath.ts\nvar SvgPath = class extends Path {\n  constructor(d) {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.commands = [];\n    for (const [_, command, paramsString] of d.matchAll(/([A-Z])([0-9. ]+)/g)) {\n      const params = paramsString.split(\" \").map(Number);\n      this.commands.push([command, params]);\n    }\n  }\n  updatePath() {\n    const { path, x, y } = this;\n    path.clear();\n    let lastX = x;\n    let lastY = y;\n    for (const [command, params] of this.commands) {\n      switch (command) {\n        case \"M\":\n          path.moveTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          break;\n        case \"C\":\n          path.cubicCurveTo(\n            x + params[0],\n            y + params[1],\n            x + params[2],\n            y + params[3],\n            x + params[4],\n            y + params[5]\n          );\n          lastX = x + params[4];\n          lastY = y + params[5];\n          break;\n        case \"H\":\n          path.lineTo(x + params[0], lastY);\n          lastX = y + params[0];\n          break;\n        case \"L\":\n          path.lineTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          lastY = y + params[1];\n          break;\n        case \"V\":\n          path.lineTo(lastX, y + params[0]);\n          lastY = y + params[0];\n          break;\n        default:\n          throw new Error(`Could not translate command '${command}' with '${params.join(\" \")}'`);\n      }\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"y\", 2);\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\nvar getFont = TextUtils.toFontString;\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_ANNOTATION_COLOR: () => DEFAULT_ANNOTATION_COLOR,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOURS: () => DEFAULT_COLOURS,\n  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_PADDING: () => DEFAULT_PADDING,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_WEIGHT: () => FONT_WEIGHT2,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,\n  POSITION: () => POSITION2,\n  getChartTheme: () => getChartTheme,\n  markerPaletteFactory: () => markerPaletteFactory,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  themes: () => themes2\n});\nvar themes2 = mapValues(\n  themes,\n  (themeFactory) => themeFactory?.()\n);\n\n// packages/ag-charts-community/src/sparklines-scale.ts\nvar sparklines_scale_exports = {};\n__export(sparklines_scale_exports, {\n  BandScale: () => BandScale,\n  ColorScale: () => ColorScale,\n  ContinuousScale: () => ContinuousScale,\n  Invalidating: () => Invalidating,\n  LinearScale: () => LinearScale,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  TimeScale: () => TimeScale\n});\n\n// packages/ag-charts-community/src/sparklines-util.ts\nvar sparklines_util_exports = {};\n__export(sparklines_util_exports, {\n  Color: () => Color,\n  Debug: () => Debug,\n  Logger: () => Logger,\n  Padding: () => Padding,\n  TimeInterval: () => TimeInterval,\n  Vec2: () => Vec2,\n  angleBetween: () => angleBetween,\n  angleDiff: () => angleDiff,\n  areArrayNumbersEqual: () => areArrayNumbersEqual,\n  bifurcate: () => bifurcate,\n  checkDatum: () => checkDatum,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  countFractionDigits: () => countFractionDigits,\n  createId: () => createId,\n  day: () => day,\n  deepClone: () => deepClone,\n  displacePointFromVector: () => displacePointFromVector,\n  extent: () => extent,\n  findMinMax: () => findMinMax,\n  findRangeExtent: () => findRangeExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  friday: () => friday,\n  hour: () => hour,\n  interpolateColor: () => interpolateColor,\n  interpolateNumber: () => interpolateNumber,\n  isBetweenAngles: () => isBetweenAngles,\n  isContinuous: () => isContinuous,\n  isDate: () => isValidDate,\n  isDenseInterval: () => isDenseInterval,\n  isEqual: () => isEqual,\n  isNegative: () => isNegative,\n  isNumber: () => isFiniteNumber,\n  isNumberEqual: () => isEqual,\n  isNumberObject: () => isNumberObject,\n  isString: () => isString,\n  isStringObject: () => isStringObject,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  mod: () => mod,\n  monday: () => monday,\n  month: () => month,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  range: () => range,\n  resetIds: () => resetIds,\n  round: () => round,\n  sanitizeHtml: () => sanitizeHtml,\n  saturday: () => saturday,\n  second: () => second,\n  setAttribute: () => setAttribute,\n  setVisibility: () => setVisibility,\n  shallowClone: () => shallowClone,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tickFormat: () => tickFormat,\n  tickStep: () => tickStep,\n  ticks: () => createTicks,\n  toDegrees: () => toDegrees,\n  toFixed: () => toFixed,\n  toRadians: () => toRadians,\n  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  uuid: () => uuid,\n  wednesday: () => wednesday,\n  year: () => year,\n  zipObject: () => zipObject\n});\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance: distance2,\n  distanceSquared: distanceSquared2,\n  from,\n  fromOffset,\n  length,\n  lengthSquared,\n  required,\n  rotate,\n  sub\n};\nfunction add(a, b) {\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance2(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared2(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction angle(a, b) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = required()) {\n  const l = Vec2.length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from(x, y) {\n  return { x, y };\n}\nfunction fromOffset(a) {\n  return { x: a.offsetX, y: a.offsetY };\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\n\n// packages/ag-charts-community/src/util/zip.ts\nfunction zipObject(keys, values) {\n  const zipped = {};\n  if (Array.isArray(values)) {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values[i];\n    }\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values;\n    }\n  }\n  return zipped;\n}\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  AreaSeriesTag: () => AreaSeriesTag,\n  Axis: () => Axis,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  AxisTicks: () => AxisTicks,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CachedTextMeasurer: () => CachedTextMeasurer,\n  CachedTextMeasurerPool: () => CachedTextMeasurerPool,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  Cursor: () => Cursor,\n  CursorManager: () => CursorManager,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DEGREE: () => DEGREE,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  GREATER_THAN: () => GREATER_THAN,\n  GestureDetector: () => GestureDetector,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightProperties: () => HighlightProperties,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  KeyNavManager: () => KeyNavManager,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  Layers: () => Layers,\n  LayoutService: () => LayoutService,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  Navigator: () => Navigator,\n  NavigatorModule: () => NavigatorModule,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PropertiesArray: () => PropertiesArray,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REGIONS: () => REGIONS,\n  RegionManager: () => RegionManager,\n  RepeatType: () => RepeatType,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Series: () => Series,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  SimpleTextMeasurer: () => SimpleTextMeasurer,\n  StateMachine: () => StateMachine,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  TextUtils: () => TextUtils,\n  TextWrapper: () => TextWrapper,\n  ToolbarManager: () => ToolbarManager,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  ZoomManager: () => ZoomManager,\n  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,\n  accumulateGroup: () => accumulateGroup,\n  accumulateStack: () => accumulateStack,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  allInStringUnion: () => allInStringUnion,\n  animationValidation: () => animationValidation,\n  area: () => area,\n  arraysEqual: () => arraysEqual,\n  backfillPathPointData: () => backfillPathPointData,\n  basicContinuousCheckDatumValidation: () => basicContinuousCheckDatumValidation,\n  bifurcate: () => bifurcate,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  childrenIter: () => childrenIter,\n  circularSliceArray: () => circularSliceArray,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,\n  countFractionDigits: () => countFractionDigits,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  createElementNS: () => createElementNS,\n  dateToNumber: () => dateToNumber,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepMerge: () => deepMerge,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  determinePathStatus: () => determinePathStatus,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  enterpriseModule: () => enterpriseModule,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMaxValue: () => findMaxValue,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  fromToMotion: () => fromToMotion,\n  getDocument: () => getDocument,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRectConfig: () => getRectConfig,\n  getWindow: () => getWindow,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupBy: () => groupBy,\n  groupCount: () => groupCount,\n  groupStackValueProperty: () => groupStackValueProperty,\n  groupSum: () => groupSum,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initToolbarKeyNav: () => initToolbarKeyNav,\n  isArray: () => isArray,\n  isBoolean: () => isBoolean,\n  isDate: () => isDate,\n  isDecoratedObject: () => isDecoratedObject,\n  isDefined: () => isDefined,\n  isEnumKey: () => isEnumKey,\n  isEnumValue: () => isEnumValue,\n  isEqual: () => isEqual,\n  isFiniteNumber: () => isFiniteNumber,\n  isFunction: () => isFunction,\n  isHtmlElement: () => isHtmlElement,\n  isNegative: () => isNegative,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isObjectLike: () => isObjectLike,\n  isPlainObject: () => isPlainObject,\n  isProperties: () => isProperties,\n  isRegExp: () => isRegExp,\n  isString: () => isString,\n  isSymbol: () => isSymbol,\n  isValidDate: () => isValidDate,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapIterable: () => mapIterable,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  minMax: () => minMax,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  pairCategoryData: () => pairCategoryData,\n  pairContinuousData: () => pairContinuousData,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathFadeOutAnimation: () => pathFadeOutAnimation,\n  pathRangePoints: () => pathRangePoints,\n  pathRangePointsReverse: () => pathRangePointsReverse,\n  pathRanges: () => pathRanges,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  pickNode: () => pickNode,\n  plotPath: () => plotPath,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareMarkerAnimation: () => prepareMarkerAnimation,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range2,\n  rangedValueProperty: () => rangedValueProperty,\n  renderPartialPath: () => renderPartialPath,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  scale: () => scale,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  splitPairData: () => splitPairData,\n  staticFromToMotion: () => staticFromToMotion,\n  stringify: () => stringify,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  times: () => times,\n  toArray: () => toArray,\n  toFixed: () => toFixed,\n  toTooltipHtml: () => toTooltipHtml,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  unique: () => unique,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  updateRect: () => updateRect,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    Logger.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/util/search.util.ts\nfunction findMaxValue(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value == null) {\n      max = index - 1;\n    } else {\n      found = value;\n      min = index + 1;\n    }\n  }\n  return found;\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  contains(other) {\n    let current = other;\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback2(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback2, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback2(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      contentGroupVirtual: false\n    });\n    this.rootNode = new HierarchyNode(\n      this,\n      0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      []\n    );\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.focusPath = [];\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  async processData() {\n    const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;\n    let index = 0;\n    const getIndex = () => {\n      index += 1;\n      return index;\n    };\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const colors = new Array((this.data?.length ?? 0) + 1).fill(void 0);\n    const createNode = (datum, parent) => {\n      const nodeIndex = getIndex();\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let size = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(size)) {\n        size = Math.max(size, 0);\n      } else {\n        size = isLeaf ? 1 : 0;\n      }\n      const sumSize = size;\n      maxDepth = Math.max(maxDepth, depth);\n      const color = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof color === \"number\") {\n        colors[nodeIndex] = color;\n        minColor = Math.min(minColor, color);\n        maxColor = Math.max(maxColor, color);\n      }\n      return appendChildren(\n        new HierarchyNode(\n          this,\n          nodeIndex,\n          datum,\n          size,\n          color,\n          void 0,\n          void 0,\n          sumSize,\n          depth,\n          parent,\n          []\n        ),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      data?.forEach((datum) => {\n        const child = createNode(datum, node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new HierarchyNode(\n        this,\n        0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        []\n      ),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    let colorScale;\n    if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n      colorScale = new ColorScale();\n      colorScale.domain = colorDomain;\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    rootNode.children.forEach((child, childIndex) => {\n      child.walk((node) => {\n        let fill;\n        const color = colors[node.index];\n        if (color != null) {\n          fill = colorScale?.convert(color);\n        }\n        fill ?? (fill = fills?.[childIndex % fills.length]);\n        node.fill = fill;\n        node.stroke = colorScale == null ? strokes?.[childIndex % strokes.length] : \"rgba(0, 0, 0, 0.2)\";\n      });\n    });\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n    this.focusPath = [{ nodeDatum: this.rootNode, childIndex: 0 }];\n  }\n  async update({ seriesRect }) {\n    await this.updateSelections();\n    await this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(data) {\n    const datum = this.animationResetFns?.datum;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const datum = this.animationResetFns?.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange, visible } = this.properties;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  pickFocus(opts) {\n    if (this.rootNode.children.length === 0)\n      return void 0;\n    if (this.focusPath.length === 0) {\n      Logger.error(\"this.focusPath should not be empty\");\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const { focusPath: path } = this;\n    const depth = path.length - 2;\n    if (depthDelta !== 0 || path.length === 1) {\n      const targetDepth = Math.max(0, depth + depthDelta);\n      if (path[targetDepth + 1] !== void 0) {\n        path.length = targetDepth + 2;\n        return this.computeFocusOutputs(path[targetDepth + 1]);\n      } else {\n        let deepest = path[path.length - 1];\n        while (deepest.nodeDatum.children.length > 0 && (deepest.nodeDatum.depth ?? -1) < targetDepth) {\n          const nextDeepest = { nodeDatum: deepest.nodeDatum.children[0], childIndex: 0 };\n          path.push(nextDeepest);\n          deepest = nextDeepest;\n        }\n        return this.computeFocusOutputs(deepest);\n      }\n    } else if (childDelta !== 0) {\n      const targetChild = path[depth + 1].childIndex + childDelta;\n      const currentParent = path[depth].nodeDatum;\n      const childCount = currentParent?.children?.length;\n      if (childCount !== void 0) {\n        const newChild = clamp(0, targetChild, childCount - 1);\n        const newFocus = { nodeDatum: currentParent.children[newChild], childIndex: newChild };\n        path[depth + 1] = newFocus;\n        path.length = depth + 2;\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else {\n      return this.computeFocusOutputs(path[path.length - 1]);\n    }\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof HierarchyNode)) {\n      Logger.error(`datum is not HierarchyNode: ${datum}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n  computeFocusOutputs({ nodeDatum, childIndex }) {\n    const bounds = this.computeFocusBounds(nodeDatum);\n    if (bounds) {\n      return {\n        datum: nodeDatum,\n        datumIndex: childIndex,\n        otherIndex: nodeDatum.depth,\n        bounds,\n        showFocusBox: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/util/tempUtils.ts\nfunction createIdsGenerator() {\n  const idsCounter = /* @__PURE__ */ new Map();\n  return (name) => {\n    const counter = idsCounter.get(name);\n    if (counter) {\n      idsCounter.set(name, counter + 1);\n      return `${name}${counter}`;\n    }\n    idsCounter.set(name, 1);\n    return name;\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axisTicks.ts\nvar _AxisTicks = class _AxisTicks {\n  constructor() {\n    this.id = createId(this);\n    this.axisGroup = new Group({ name: `${this.id}-AxisTicks`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.labelSelection = Selection.select(this.axisGroup, Text, false);\n    this.interval = new AxisInterval();\n    this.label = new AxisLabel();\n    this.scale = new LinearScale();\n    this.position = \"bottom\";\n    this.translationX = 0;\n    this.translationY = 0;\n    this.padding = 0;\n  }\n  attachAxis(axisNode) {\n    axisNode.appendChild(this.axisGroup);\n  }\n  calculateLayout() {\n    this.scale.interval = this.interval.step;\n    const boxes = [];\n    const tickData = this.generateTicks();\n    const { translationX, translationY } = this;\n    this.labelSelection.update(\n      tickData.ticks.map((d) => this.createLabelDatum(d)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n    this.labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n      if (datum.visible) {\n        boxes.push(node.getBBox());\n      }\n    });\n    this.axisGroup.setProperties({ translationX, translationY });\n    return BBox.merge(boxes);\n  }\n  getLabelParams(datum) {\n    const { padding } = this;\n    const { translate } = datum;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        return {\n          x: translate,\n          y: padding,\n          textAlign: \"center\",\n          textBaseline: \"top\"\n        };\n      case \"left\":\n      case \"right\":\n        return {\n          x: padding,\n          y: translate,\n          textAlign: \"start\",\n          textBaseline: \"middle\"\n        };\n    }\n  }\n  inRange(x, tolerance = 1e-3) {\n    const [min, max] = findMinMax(this.scale.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  createLabelDatum(datum) {\n    const { x, y, textBaseline, textAlign } = this.getLabelParams(datum);\n    return {\n      visible: Boolean(datum.tickLabel),\n      tickId: datum.tickId,\n      fill: this.label.color,\n      fontFamily: this.label.fontFamily,\n      fontSize: this.label.fontSize,\n      fontStyle: this.label.fontStyle,\n      fontWeight: this.label.fontWeight,\n      rotation: 0,\n      rotationCenterX: 0,\n      text: datum.tickLabel,\n      textAlign,\n      textBaseline,\n      x,\n      y\n    };\n  }\n  generateTicks() {\n    const { minSpacing, maxSpacing } = this.interval;\n    const extentWithBleed = round(findRangeExtent(this.scale.range), 2);\n    const { maxTickCount, minTickCount, tickCount } = estimateTickCount(\n      extentWithBleed,\n      minSpacing,\n      maxSpacing,\n      _AxisTicks.DefaultTickCount,\n      _AxisTicks.DefaultMinSpacing\n    );\n    if (tickCount) {\n      this.scale.tickCount = tickCount;\n      this.scale.minTickCount = minTickCount;\n      this.scale.maxTickCount = maxTickCount;\n    }\n    const tickData = this.getTicksData();\n    if (this.position === \"bottom\" || this.position === \"top\") {\n      const measurer = CachedTextMeasurerPool.getMeasurer({ font: this.label });\n      let lastTickPosition = -Infinity;\n      tickData.ticks = tickData.ticks.filter((data) => {\n        if (lastTickPosition < data.translate) {\n          lastTickPosition = data.translate + measurer.textWidth(data.tickLabel, true);\n          return true;\n        }\n      });\n    }\n    return tickData;\n  }\n  getTicksData() {\n    const ticks = [];\n    const rawTicks = this.scale.ticks();\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const idGenerator = createIdsGenerator();\n    const labelFormatter = this.label.format ? this.scale.tickFormat({ ticks: rawTicks, specifier: this.label.format }) : (x) => isNumber(x) ? x.toFixed(fractionDigits) : String(x);\n    for (let index = 0; index < rawTicks.length; index++) {\n      const tick = rawTicks[index];\n      const translate = this.scale.convert(tick);\n      if (!this.inRange(translate))\n        continue;\n      const tickLabel = this.label.formatter?.({ value: tick, index, fractionDigits }) ?? labelFormatter(tick);\n      const tickId = idGenerator(tickLabel);\n      ticks.push({ tick, tickId, tickLabel, translate });\n    }\n    return { rawTicks, fractionDigits, ticks };\n  }\n};\n_AxisTicks.DefaultTickCount = 5;\n_AxisTicks.DefaultMinSpacing = 50;\nvar AxisTicks = _AxisTicks;\n\n// packages/ag-charts-community/src/chart/legendDatum.ts\nvar __FORCE_MODULE_DETECTION = 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLWNvbW11bml0eS9kaXN0L3BhY2thZ2UvbWFpbi5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBLHVDQUF1QyxNQUFNLFlBQVksTUFBTSxxQkFBcUIsWUFBWTtBQUNoRztBQUNBLDBDQUEwQyxPQUFPLEtBQUssTUFBTSxTQUFTLE1BQU0sS0FBSyxHQUFHLElBQUksVUFBVSxFQUFFLEtBQUs7QUFDeEc7QUFDQSwwQ0FBMEMsT0FBTyxLQUFLLE1BQU0sSUFBSSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGdCQUFnQixNQUFNLGNBQWMsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxlQUFlLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNFQUFzRSxRQUFRO0FBQzlFLEdBQUc7QUFDSDtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyxnQkFBZ0IsS0FBSztBQUMzRTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLEdBQUcsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBLGdCQUFnQiwrQkFBK0IsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0scUNBQXFDLFlBQVk7QUFDbEY7QUFDQTtBQUNBLDJCQUEyQixNQUFNLDhCQUE4QixrQkFBa0I7QUFDakY7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUIsUUFBUSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkNBQTJDLElBQUk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsZUFBZSxFQUFFLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QyxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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NUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBLDhDQUE4Qyw2REFBNkQsa0NBQWtDLG9EQUFvRDtBQUNqTSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdDQUF3QyxvREFBb0Q7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDhDQUE4QyxzREFBc0Q7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUEwRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlFQUFpRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtEO0FBQzdGLE1BQU07QUFDTjtBQUNBLDJDQUEyQyxrREFBa0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0MsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsNENBQTRDLE9BQU8sa0JBQWtCLEdBQUc7QUFDeEU7QUFDQTtBQUNBLCtDQUErQyxVQUFVLGtCQUFrQixHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QUEwQztBQUNuRSxxQ0FBcUMsMkJBQTJCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0RBQXdEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSwwREFBMEQ7QUFDcEUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQTREO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCw4RkFBOEYsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFLFVBQVUsYUFBYTtBQUN2QixZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRkFBaUY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksMkJBQTJCO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGVBQWU7QUFDbkUsb0RBQW9ELGdDQUFnQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFOztBQUVBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QXVEO0FBQ3ZELFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNERBQTREO0FBQzVELFVBQVUsc0RBQXNEO0FBQ2hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDLGFBQWE7QUFDYjtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3RkFBd0Y7QUFDcEcsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQsVUFBVSxpQkFBaUI7QUFDM0IsV0FBVywrQkFBK0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsMEJBQTBCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEVBQTBFLFNBQVMsUUFBUSxnQkFBZ0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFlBQVksNkJBQTZCO0FBQ3pDLFlBQVksc0ZBQXNGO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFCQUFxQjtBQUNuRixNQUFNO0FBQ04sZ0VBQWdFLHVCQUF1QjtBQUN2RixNQUFNO0FBQ04sK0RBQStELHNCQUFzQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QjtBQUN4RjtBQUNBO0FBQ0EsOERBQThELHdCQUF3QjtBQUN0RjtBQUNBO0FBQ0EsNkRBQTZELHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdELHNCQUFzQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxxQkFBcUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsOERBQThELHNDQUFzQztBQUNwRyxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQixPQUFPLFdBQVcsY0FBYyx5QkFBeUI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQXFEO0FBQ2pFLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0ZBQW9GLFFBQVE7QUFDNUY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUE2QztBQUNyRCxRQUFRLDJDQUEyQztBQUNuRCxRQUFRLDhDQUE4QztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxrR0FBa0c7QUFDOUc7QUFDQSxZQUFZLGdHQUFnRztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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Q2hDLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCO0FBQ3hGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFB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QUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlDQUFpQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0dBQXNHO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUSxVQUFVLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGlCQUFpQjtBQUNyQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQTJEO0FBQ3ZFLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxRQUFRLDBDQUEwQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtCQUFrQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSwrQ0FBK0M7QUFDdEgsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQ0FBb0M7QUFDckY7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhcnRfbWFrZXIvLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLWNvbW11bml0eS9kaXN0L3BhY2thZ2UvbWFpbi5lc20ubWpzPzdlNTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2RlY29yYXRlQ2xhc3MgPSAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGtpbmQpID0+IHtcbiAgdmFyIHJlc3VsdCA9IGtpbmQgPiAxID8gdm9pZCAwIDoga2luZCA/IF9fZ2V0T3duUHJvcERlc2ModGFyZ2V0LCBrZXkpIDogdGFyZ2V0O1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxLCBkZWNvcmF0b3I7IGkgPj0gMDsgaS0tKVxuICAgIGlmIChkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgcmVzdWx0ID0gKGtpbmQgPyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHJlc3VsdCkgOiBkZWNvcmF0b3IocmVzdWx0KSkgfHwgcmVzdWx0O1xuICBpZiAoa2luZCAmJiByZXN1bHQpXG4gICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWxvY2FsZS9zcmMvZW4tVVMudHNcbnZhciBBR19DSEFSVFNfTE9DQUxFX0VOX1VTID0ge1xuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIHRoZSBmb2N1c2VkIGl0ZW0gYmVjb21lcyB2aXNpYmxlXG4gIGFyaWFBbm5vdW5jZVZpc2libGU6IFwidmlzaWJsZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIHRoZSBmb2N1c2VkIGl0ZW0gYmVjb21lcyBoaWRkZW5cbiAgYXJpYUFubm91bmNlSGlkZGVuOiBcImhpZGRlblwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGFuIGl0ZW0gaW4gdGhlIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUhvdmVyRGF0dW06IFwiJHtkYXR1bX1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUNoYXJ0OiBcImNoYXJ0LCAke3Nlcmllc0NvdW50fVtudW1iZXJdIHNlcmllc1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGFuIGl0ZW0gaW4gYSB0cmVlbWFwIG9yIHN1bmJ1cnN0IGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUhpZXJhcmNoeURhdHVtOiBcImxldmVsICR7bGV2ZWx9W251bWJlcl0sICR7Y291bnR9W251bWJlcl0gY2hpbGRyZW4sICR7ZGVzY3JpcHRpb259XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBsaW5rIGluIGEgU2Fua2V5IG9yIGNob3JkIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUZsb3dQcm9wb3J0aW9uTGluazogXCJsaW5rICR7aW5kZXh9IG9mICR7Y291bnR9LCBmcm9tICR7ZnJvbX0gdG8gJHt0b30sICR7c2l6ZU5hbWV9ICR7c2l6ZX1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIG5vZGUgaW4gYSBTYW5rZXkgb3IgY2hvcmQgY2hhcnRcbiAgYXJpYUFubm91bmNlRmxvd1Byb3BvcnRpb25Ob2RlOiBcIm5vZGUgJHtpbmRleH0gb2YgJHtjb3VudH0sICR7ZGVzY3JpcHRpb259XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW5ub3RhdGlvbi1vcHRpb25zIHRvb2xiYXJcbiAgYXJpYUxhYmVsQW5ub3RhdGlvbk9wdGlvbnNUb29sYmFyOiBcIkFubm90YXRpb24gT3B0aW9uc1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBjb2xvciBwaWNrZXIgZGlhbG9nXG4gIGFyaWFMYWJlbENvbG9yUGlja2VyOiBcIkNvbG9yIHBpY2tlclwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBmaW5hbmNpYWwgY2hhcnRzIHRvb2xiYXJcbiAgYXJpYUxhYmVsRmluYW5jaWFsQ2hhcnRzOiBcIkZpbmFuY2lhbCBDaGFydHNcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbGVnZW5kIHRvb2xiYXJcbiAgYXJpYUxhYmVsTGVnZW5kOiBcIkxlZ2VuZFwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBsZWdlbmQgcGFnaW5hdGlvbiBidXR0b25cbiAgYXJpYUxhYmVsTGVnZW5kUGFnaW5hdGlvbjogXCJMZWdlbmQgUGFnaW5hdGlvblwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBwcmV2aW91cyBsZWdlbmQgcGFnZSBidXR0b25cbiAgYXJpYUxhYmVsTGVnZW5kUGFnZVByZXZpb3VzOiBcIlByZXZpb3VzIExlZ2VuZCBQYWdlXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIG5leHQgbGVnZW5kIHBhZ2UgYnV0dG9uXG4gIGFyaWFMYWJlbExlZ2VuZFBhZ2VOZXh0OiBcIk5leHQgTGVnZW5kIFBhZ2VcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgYW4gaXRlbSBpbiB0aGUgbGVnZW5kXG4gIGFyaWFMYWJlbExlZ2VuZEl0ZW06IFwiJHtsYWJlbH0sIExlZ2VuZCBpdGVtICR7aW5kZXh9W251bWJlcl0gb2YgJHtjb3VudH1bbnVtYmVyXSwgXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGFuIHVua25vd24gaXRlbSBpbiB0aGUgbGVnZW5kXG4gIGFyaWFMYWJlbExlZ2VuZEl0ZW1Vbmtub3duOiBcIlVua25vd24gbGVnZW5kIGl0ZW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbmF2aWdhdG9yIGVsZW1lbnRcbiAgYXJpYUxhYmVsTmF2aWdhdG9yOiBcIk5hdmlnYXRvclwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JSYW5nZTogXCJSYW5nZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIHN0YXJ0IG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JNaW5pbXVtOiBcIk1pbmltdW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbiBhY2Nlc3NpYmlsaXR5IGNvbnRyb2wgdGhhdCBjaGFuZ2VzIHRoZSBlbmQgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvck1heGltdW06IFwiTWF4aW11bVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHJhbmdlcyB0b29sYmFyXG4gIGFyaWFMYWJlbFJhbmdlc1Rvb2xiYXI6IFwiUmFuZ2VzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3Igem9vbSB0b29sYmFyXG4gIGFyaWFMYWJlbFpvb21Ub29sYmFyOiBcIlpvb21cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgdmFsdWUgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFWYWx1ZVBhblJhbmdlOiBcIiR7bWlufVtwZXJjZW50XSB0byAke21heH1bcGVyY2VudF1cIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ2xvYWRpbmcgZGF0YScgb3ZlcmxheVxuICBvdmVybGF5TG9hZGluZ0RhdGE6IFwiTG9hZGluZyBkYXRhLi4uXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdubyBkYXRhJyBvdmVybGF5XG4gIG92ZXJsYXlOb0RhdGE6IFwiTm8gZGF0YSB0byBkaXNwbGF5XCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdubyB2aXNpYmxlIHNlcmllcycgb3ZlcmxheVxuICBvdmVybGF5Tm9WaXNpYmxlU2VyaWVzOiBcIk5vIHZpc2libGUgc2VyaWVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVEcm9wZG93bjogXCJDaGFydCBUeXBlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgT0hMQyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZU9ITEM6IFwiT0hMQ1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIEhMQyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhMQzogXCJITENcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBoaWdoIGxvdyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhpZ2hMb3c6IFwiSGlnaCBMb3dcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBjYW5kbGVzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlQ2FuZGxlczogXCJDYW5kbGVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgaG9sbG93IGNhbmRsZXMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVIb2xsb3dDYW5kbGVzOiBcIkhvbGxvdyBDYW5kbGVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUxpbmU6IFwiTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGxpbmUgd2l0aCBtYXJrZXJzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlTGluZVdpdGhNYXJrZXJzOiBcIkxpbmUgd2l0aCBNYXJrZXJzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSB3aXRoIHN0ZXAgbGluZSBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZVN0ZXBMaW5lOiBcIlN0ZXAgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdHJlbmQgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVHJlbmRMaW5lOiBcIlRyZW5kIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGhvcml6b250YWwgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zSG9yaXpvbnRhbExpbmU6IFwiSG9yaXpvbnRhbCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB2ZXJ0aWNhbCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNWZXJ0aWNhbExpbmU6IFwiVmVydGljYWwgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcGFyYWxsZWwgY2hhbm5lbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zUGFyYWxsZWxDaGFubmVsOiBcIlBhcmFsbGVsIENoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRpc2pvaW50IGNoYW5uZWwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Rpc2pvaW50Q2hhbm5lbDogXCJEaXNqb2ludCBDaGFubmVsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjbGVhciBhbGwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NsZWFyQWxsOiBcIkNsZWFyIEFsbFwiLFxuICAvKipcbiAgICogVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNvbG9yIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICAgKiBAZGVwcmVjYXRlZCB2MTAuMS4wIHVzZSBgdG9vbGJhckFubm90YXRpb25zTGluZUNvbG9yYCBpbnN0ZWFkLlxuICAgKi9cbiAgdG9vbGJhckFubm90YXRpb25zQ29sb3I6IFwiQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGZpbGwgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0ZpbGxDb2xvcjogXCJGaWxsIENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIGNvbG9yIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3I6IFwiTGluZSBDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dENvbG9yOiBcIlRleHQgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgc2l6ZSBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dFNpemU6IFwiVGV4dCBTaXplXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsb2NrIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xvY2s6IFwiTG9ja1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdW5sb2NrIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1VubG9jazogXCJVbmxvY2tcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRlbGV0ZSBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEZWxldGU6IFwiRGVsZXRlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIGFubm90YXRpb25zIG1lbnUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVBbm5vdGF0aW9uczogXCJUcmVuZCBMaW5lc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBhbm5vdGF0aW9ucyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUZXh0QW5ub3RhdGlvbnM6IFwiVGV4dCBBbm5vdGF0aW9uc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgY2FsbG91dCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zQ2FsbG91dDogXCJDYWxsb3V0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjb21tZW50IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNDb21tZW50OiBcIkNvbW1lbnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIG5vdGUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc05vdGU6IFwiTm90ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dDogXCJUZXh0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMSBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlMU1vbnRoOiBcIjFNXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMSBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlMU1vbnRoQXJpYTogXCIxIG1vbnRoXCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMyBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlM01vbnRoczogXCIzTVwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDMgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTNNb250aHNBcmlhOiBcIjMgbW9udGhzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgNiBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlNk1vbnRoczogXCI2TVwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDYgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTZNb250aHNBcmlhOiBcIjYgbW9udGhzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgeWVhciB0byBkYXRlIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VZZWFyVG9EYXRlOiBcIllURFwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIHllYXIgdG8gZGF0ZSBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlWWVhclRvRGF0ZUFyaWE6IFwiWWVhciB0byBkYXRlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMSB5ZWFyIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxWWVhcjogXCIxWVwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgeWVhciBidXR0b25cbiAgdG9vbGJhclJhbmdlMVllYXJBcmlhOiBcIjEgeWVhclwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIGZ1bGwgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZUFsbDogXCJBbGxcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyBmdWxsIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VBbGxBcmlhOiBcIkFsbFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3Mgem9vbSBvdXQgYnV0dG9uXG4gIHRvb2xiYXJab29tWm9vbU91dDogXCJab29tIG91dFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3Mgem9vbSBpbiBidXR0b25cbiAgdG9vbGJhclpvb21ab29tSW46IFwiWm9vbSBpblwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIGxlZnQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuTGVmdDogXCJQYW4gbGVmdFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHJpZ2h0IGJ1dHRvblxuICB0b29sYmFyWm9vbVBhblJpZ2h0OiBcIlBhbiByaWdodFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHRvIHRoZSBzdGFydCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5TdGFydDogXCJQYW4gdG8gdGhlIHN0YXJ0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gdG8gdGhlIGVuZCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5FbmQ6IFwiUGFuIHRvIHRoZSBlbmRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiByZXNldCBidXR0b25cbiAgdG9vbGJhclpvb21SZXNldDogXCJSZXNldCB0aGUgem9vbVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgZG93bmxvYWQgYnV0dG9uXG4gIGNvbnRleHRNZW51RG93bmxvYWQ6IFwiRG93bmxvYWRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHRvZ2dsZSBzZXJpZXMgdmlzaWJpbGl0eSBidXR0b25cbiAgY29udGV4dE1lbnVUb2dnbGVTZXJpZXNWaXNpYmlsaXR5OiBcIlRvZ2dsZSBWaXNpYmlsaXR5XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyB0b2dnbGUgb3RoZXIgc2VyaWVzIHZpc2liaWxpdHkgYnV0dG9uXG4gIGNvbnRleHRNZW51VG9nZ2xlT3RoZXJTZXJpZXM6IFwiVG9nZ2xlIE90aGVyIFNlcmllc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3Mgem9vbSB0byBwb2ludCBidXR0b25cbiAgY29udGV4dE1lbnVab29tVG9DdXJzb3I6IFwiWm9vbSB0byBoZXJlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyBwYW4gdG8gcG9pbnQgYnV0dG9uXG4gIGNvbnRleHRNZW51UGFuVG9DdXJzb3I6IFwiUGFuIHRvIGhlcmVcIlxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9lcnJvckJhck9wdGlvbnMudHNcbnZhciBBZ0Vycm9yQmFyU3VwcG9ydGVkU2VyaWVzVHlwZXMgPSBbXCJiYXJcIiwgXCJsaW5lXCIsIFwic2NhdHRlclwiXTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9uYXZpZ2F0b3JPcHRpb25zLnRzXG52YXIgX19NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0ge307XG52YXIgX19WRVJJRllfTUlOSV9DSEFSVF9TRVJJRVNfT1BUSU9OUyA9IHZvaWQgMDtcbl9fVkVSSUZZX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSBfX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvdG9vbGJhck9wdGlvbnMudHNcbnZhciBJQ09OU19MRUdBQ1kgPSBbXG4gIFwiZGVsZXRlLWxlZ2FjeVwiLFxuICBcImRpc2pvaW50LWNoYW5uZWxcIixcbiAgXCJkaXNqb2ludC1jaGFubmVsLWxlZ2FjeVwiLFxuICBcImhvcml6b250YWwtbGluZS1sZWdhY3lcIixcbiAgXCJsaW5lLWNvbG9yLWxlZ2FjeVwiLFxuICBcImxvY2tcIixcbiAgXCJsb2NrLWxlZ2FjeVwiLFxuICBcInBhbi1lbmQtbGVnYWN5XCIsXG4gIFwicGFuLWxlZnQtbGVnYWN5XCIsXG4gIFwicGFuLXJpZ2h0LWxlZ2FjeVwiLFxuICBcInBhbi1zdGFydC1sZWdhY3lcIixcbiAgXCJwYXJhbGxlbC1jaGFubmVsXCIsXG4gIFwicGFyYWxsZWwtY2hhbm5lbC1sZWdhY3lcIixcbiAgXCJyZXNldC1sZWdhY3lcIixcbiAgXCJ0cmVuZC1saW5lXCIsXG4gIFwidHJlbmQtbGluZS1sZWdhY3lcIixcbiAgXCJ1bmxvY2tcIixcbiAgXCJ1bmxvY2stbGVnYWN5XCIsXG4gIFwidmVydGljYWwtbGluZVwiLFxuICBcInZlcnRpY2FsLWxpbmUtbGVnYWN5XCIsXG4gIFwiem9vbS1pbi1sZWdhY3lcIixcbiAgXCJ6b29tLWluLWFsdFwiLFxuICBcInpvb20taW4tYWx0LWxlZ2FjeVwiLFxuICBcInpvb20tb3V0LWxlZ2FjeVwiLFxuICBcInpvb20tb3V0LWFsdFwiLFxuICBcInpvb20tb3V0LWFsdC1sZWdhY3lcIlxuXTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC90b29sdGlwT3B0aW9ucy50c1xudmFyIEFnVG9vbHRpcFBvc2l0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEFnVG9vbHRpcFBvc2l0aW9uVHlwZTIpID0+IHtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlBPSU5URVJcIl0gPSBcInBvaW50ZXJcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIk5PREVcIl0gPSBcIm5vZGVcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlRPUFwiXSA9IFwidG9wXCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJSSUdIVFwiXSA9IFwicmlnaHRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkJPVFRPTVwiXSA9IFwiYm90dG9tXCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJMRUZUXCJdID0gXCJsZWZ0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJUT1BfTEVGVFwiXSA9IFwidG9wLWxlZnRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlRPUF9SSUdIVFwiXSA9IFwidG9wLXJpZ2h0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJCT1RUT01fUklHSFRcIl0gPSBcImJvdHRvbS1yaWdodFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiQk9UVE9NX0xFRlRcIl0gPSBcImJvdHRvbS1sZWZ0XCI7XG4gIHJldHVybiBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyO1xufSkoQWdUb29sdGlwUG9zaXRpb25UeXBlIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC90aGVtZU9wdGlvbnMudHNcbnZhciBfX1RIRU1FX09WRVJSSURFUyA9IHt9O1xudmFyIF9fVkVSSUZZX1RIRU1FX09WRVJSSURFUyA9IHZvaWQgMDtcbl9fVkVSSUZZX1RIRU1FX09WRVJSSURFUyA9IF9fVEhFTUVfT1ZFUlJJREVTO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvaW5kZXgudHNcbnZhciB0aW1lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRpbWVfZXhwb3J0cywge1xuICBUaW1lSW50ZXJ2YWw6ICgpID0+IFRpbWVJbnRlcnZhbCxcbiAgZGF5OiAoKSA9PiBkYXksXG4gIGZyaWRheTogKCkgPT4gZnJpZGF5LFxuICBob3VyOiAoKSA9PiBob3VyLFxuICBtaWxsaXNlY29uZDogKCkgPT4gbWlsbGlzZWNvbmQsXG4gIG1pbnV0ZTogKCkgPT4gbWludXRlLFxuICBtb25kYXk6ICgpID0+IG1vbmRheSxcbiAgbW9udGg6ICgpID0+IG1vbnRoLFxuICBzYXR1cmRheTogKCkgPT4gc2F0dXJkYXksXG4gIHNlY29uZDogKCkgPT4gc2Vjb25kLFxuICBzdW5kYXk6ICgpID0+IHN1bmRheSxcbiAgdGh1cnNkYXk6ICgpID0+IHRodXJzZGF5LFxuICB0dWVzZGF5OiAoKSA9PiB0dWVzZGF5LFxuICB1dGNEYXk6ICgpID0+IHV0Y0RheSxcbiAgdXRjSG91cjogKCkgPT4gdXRjSG91cixcbiAgdXRjTWludXRlOiAoKSA9PiB1dGNNaW51dGUsXG4gIHV0Y01vbnRoOiAoKSA9PiB1dGNNb250aCxcbiAgdXRjWWVhcjogKCkgPT4gdXRjWWVhcixcbiAgd2VkbmVzZGF5OiAoKSA9PiB3ZWRuZXNkYXksXG4gIHllYXI6ICgpID0+IHllYXJcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Z1bmN0aW9uLnRzXG52YXIgZG9PbmNlU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZG9PbmNlKGZ1bmMsIGtleSkge1xuICBpZiAoZG9PbmNlU3RhdGUuaGFzKGtleSkpXG4gICAgcmV0dXJuO1xuICBkb09uY2VTdGF0ZS5zZXQoa2V5LCB0cnVlKTtcbiAgZnVuYygpO1xufVxuZG9PbmNlLmNsZWFyID0gKCkgPT4gZG9PbmNlU3RhdGUuY2xlYXIoKTtcbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiogaXRlcmF0ZSguLi5pdGVyYXRvcnMpIHtcbiAgZm9yIChjb25zdCBpdGVyYXRvciBvZiBpdGVyYXRvcnMpIHtcbiAgICB5aWVsZCogaXRlcmF0b3I7XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrMiwgd2FpdE1zID0gMCwgb3B0aW9ucykge1xuICBjb25zdCB7IGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCB0aW1lcklkO1xuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCBzaG91bGRXYWl0ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHRpbWVvdXRIYW5kbGVyKCkge1xuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZW91dEhhbmRsZXIsIHdhaXRNcyk7XG4gICAgICBjYWxsYmFjazIoLi4ubGFzdEFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRXYWl0ID0gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0aHJvdHRsZUNhbGxiYWNrKC4uLmFyZ3MpIHtcbiAgICBpZiAoc2hvdWxkV2FpdCkge1xuICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRXYWl0ID0gdHJ1ZTtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVvdXRIYW5kbGVyLCB3YWl0TXMpO1xuICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgY2FsbGJhY2syKC4uLmFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aHJvdHRsZUNhbGxiYWNrLCB7XG4gICAgY2FuY2VsKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgc2hvdWxkV2FpdCA9IGZhbHNlO1xuICAgICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBqb2luRnVuY3Rpb25zKC4uLmZucykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9sb2dnZXIudHNcbnZhciBMb2dnZXIgPSB7XG4gIGxvZyguLi5sb2dDb250ZW50KSB7XG4gICAgY29uc29sZS5sb2coLi4ubG9nQ29udGVudCk7XG4gIH0sXG4gIHdhcm4obWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGNvbnNvbGUud2FybihgQUcgQ2hhcnRzIC0gJHttZXNzYWdlfWAsIC4uLmxvZ0NvbnRlbnQpO1xuICB9LFxuICBlcnJvcihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBBRyBDaGFydHMgZXJyb3JgLCBtZXNzYWdlLCAuLi5sb2dDb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgQUcgQ2hhcnRzIC0gJHttZXNzYWdlfWAsIC4uLmxvZ0NvbnRlbnQpO1xuICAgIH1cbiAgfSxcbiAgdGFibGUoLi4ubG9nQ29udGVudCkge1xuICAgIGNvbnNvbGUudGFibGUoLi4ubG9nQ29udGVudCk7XG4gIH0sXG4gIHdhcm5PbmNlKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBkb09uY2UoKCkgPT4gTG9nZ2VyLndhcm4obWVzc2FnZSwgLi4ubG9nQ29udGVudCksIGBMb2dnZXIud2FybjogJHttZXNzYWdlfWApO1xuICB9LFxuICBlcnJvck9uY2UobWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGRvT25jZSgoKSA9PiBMb2dnZXIuZXJyb3IobWVzc2FnZSwgLi4ubG9nQ29udGVudCksIGBMb2dnZXIuZXJyb3I6ICR7bWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2ludGVydmFsLnRzXG52YXIgVGltZUludGVydmFsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZW5jb2RlLCBfZGVjb2RlLCBfcmFuZ2VDYWxsYmFjaykge1xuICAgIHRoaXMuX2VuY29kZSA9IF9lbmNvZGU7XG4gICAgdGhpcy5fZGVjb2RlID0gX2RlY29kZTtcbiAgICB0aGlzLl9yYW5nZUNhbGxiYWNrID0gX3JhbmdlQ2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGxhdGVzdCBpbnRlcnZhbCBib3VuZGFyeSBkYXRlIGJlZm9yZSBvciBlcXVhbCB0byBkYXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgYGRheS5mbG9vcihkYXRlKWAgdHlwaWNhbGx5IHJldHVybnMgMTI6MDAgQU0gbG9jYWwgdGltZSBvbiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGZsb29yKGRhdGUpIHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkKTtcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGRhdGUgcmVwcmVzZW50aW5nIHRoZSBlYXJsaWVzdCBpbnRlcnZhbCBib3VuZGFyeSBkYXRlIGFmdGVyIG9yIGVxdWFsIHRvIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqL1xuICBjZWlsKGRhdGUpIHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoTnVtYmVyKGRhdGUpIC0gMSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkKTtcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGUgKyAxKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBkYXRlcyByZXByZXNlbnRpbmcgZXZlcnkgaW50ZXJ2YWwgYm91bmRhcnkgYWZ0ZXIgb3IgZXF1YWwgdG8gc3RhcnQgKGluY2x1c2l2ZSkgYW5kIGJlZm9yZSBzdG9wIChleGNsdXNpdmUpLlxuICAgKiBAcGFyYW0gc3RhcnQgUmFuZ2Ugc3RhcnQuXG4gICAqIEBwYXJhbSBzdG9wIFJhbmdlIGVuZC5cbiAgICogQHBhcmFtIGV4dGVuZCBJZiBzcGVjaWZpZWQsIHRoZSByZXF1ZXN0ZWQgcmFuZ2Ugd2lsbCBiZSBleHRlbmRlZCB0byB0aGUgY2xvc2VzdCBcIm5pY2VcIiB2YWx1ZXMuXG4gICAqL1xuICByYW5nZShzdGFydCwgc3RvcCwgZXh0ZW5kKSB7XG4gICAgY29uc3QgcmFuZ2VDYWxsYmFjayA9IHRoaXMuX3JhbmdlQ2FsbGJhY2s/LihzdGFydCwgc3RvcCk7XG4gICAgY29uc3QgZTAgPSB0aGlzLl9lbmNvZGUoZXh0ZW5kID8gdGhpcy5mbG9vcihzdGFydCkgOiB0aGlzLmNlaWwoc3RhcnQpKTtcbiAgICBjb25zdCBlMSA9IHRoaXMuX2VuY29kZShleHRlbmQgPyB0aGlzLmNlaWwoc3RvcCkgOiB0aGlzLmZsb29yKHN0b3ApKTtcbiAgICBpZiAoZTEgPCBlMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByYW5nZTMgPSBbXTtcbiAgICBmb3IgKGxldCBlID0gZTA7IGUgPD0gZTE7IGUrKykge1xuICAgICAgY29uc3QgZCA9IHRoaXMuX2RlY29kZShlKTtcbiAgICAgIHJhbmdlMy5wdXNoKGQpO1xuICAgIH1cbiAgICByYW5nZUNhbGxiYWNrPy4oKTtcbiAgICByZXR1cm4gcmFuZ2UzO1xuICB9XG59O1xudmFyIENvdW50YWJsZVRpbWVJbnRlcnZhbCA9IGNsYXNzIGV4dGVuZHMgVGltZUludGVydmFsIHtcbiAgZ2V0T2Zmc2V0KHNuYXBUbywgc3RlcCkge1xuICAgIGNvbnN0IHMgPSB0eXBlb2Ygc25hcFRvID09PSBcIm51bWJlclwiIHx8IHNuYXBUbyBpbnN0YW5jZW9mIERhdGUgPyB0aGlzLl9lbmNvZGUobmV3IERhdGUoc25hcFRvKSkgOiAwO1xuICAgIHJldHVybiBNYXRoLmZsb29yKHMpICUgc3RlcDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGZpbHRlcmVkIHZpZXcgb2YgdGhpcyBpbnRlcnZhbCByZXByZXNlbnRpbmcgZXZlcnkgc3RlcCd0aCBkYXRlLlxuICAgKiBJdCBjYW4gYmUgYSBudW1iZXIgb2YgbWludXRlcywgaG91cnMsIGRheXMgZXRjLlxuICAgKiBNdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAgICogQHBhcmFtIHN0ZXBcbiAgICovXG4gIGV2ZXJ5KHN0ZXAsIG9wdGlvbnMpIHtcbiAgICBsZXQgb2Zmc2V0NCA9IDA7XG4gICAgbGV0IHJhbmdlQ2FsbGJhY2s7XG4gICAgY29uc3QgdW5zYWZlU3RlcCA9IHN0ZXA7XG4gICAgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoc3RlcCkpO1xuICAgIGlmICh1bnNhZmVTdGVwICE9PSBzdGVwKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYGludGVydmFsIHN0ZXAgb2YgWyR7dW5zYWZlU3RlcH1dIHJvdW5kZWQgdG8gWyR7c3RlcH1dLmApO1xuICAgIH1cbiAgICBjb25zdCB7IHNuYXBUbyA9IFwic3RhcnRcIiB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBpZiAodHlwZW9mIHNuYXBUbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgaW5pdGlhbE9mZnNldCA9IG9mZnNldDQ7XG4gICAgICByYW5nZUNhbGxiYWNrID0gKHN0YXJ0LCBzdG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBzbmFwVG8gPT09IFwic3RhcnRcIiA/IHN0YXJ0IDogc3RvcDtcbiAgICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KHMsIHN0ZXApO1xuICAgICAgICByZXR1cm4gKCkgPT4gb2Zmc2V0NCA9IGluaXRpYWxPZmZzZXQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNuYXBUbyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KG5ldyBEYXRlKHNuYXBUbyksIHN0ZXApO1xuICAgIH0gZWxzZSBpZiAoc25hcFRvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KHNuYXBUbywgc3RlcCk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZTEzID0gKGRhdGUpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9lbmNvZGUoZGF0ZSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZSAtIG9mZnNldDQpIC8gc3RlcCk7XG4gICAgfTtcbiAgICBjb25zdCBkZWNvZGUxMyA9IChlbmNvZGVkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGVuY29kZWQgKiBzdGVwICsgb2Zmc2V0NCk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRpbWVJbnRlcnZhbChlbmNvZGUxMywgZGVjb2RlMTMsIHJhbmdlQ2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvbWlsbGlzZWNvbmQudHNcbmZ1bmN0aW9uIGVuY29kZShkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShlbmNvZGVkKTtcbn1cbnZhciBtaWxsaXNlY29uZCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlLCBkZWNvZGUpO1xudmFyIG1pbGxpc2Vjb25kX2RlZmF1bHQgPSBtaWxsaXNlY29uZDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2R1cmF0aW9uLnRzXG52YXIgZXBvY2hZZWFyID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKSkuZ2V0RnVsbFllYXIoKTtcbnZhciBkdXJhdGlvblNlY29uZCA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjA7XG52YXIgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbnZhciBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xudmFyIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNztcbnZhciBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMDtcbnZhciBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3NlY29uZC50c1xudmFyIG9mZnNldCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuZnVuY3Rpb24gZW5jb2RlMihkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldCkgLyBkdXJhdGlvblNlY29uZCk7XG59XG5mdW5jdGlvbiBkZWNvZGUyKGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldCArIGVuY29kZWQgKiBkdXJhdGlvblNlY29uZCk7XG59XG52YXIgc2Vjb25kID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUyLCBkZWNvZGUyKTtcbnZhciBzZWNvbmRfZGVmYXVsdCA9IHNlY29uZDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL21pbnV0ZS50c1xudmFyIG9mZnNldDIgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbmZ1bmN0aW9uIGVuY29kZTMoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBvZmZzZXQyKSAvIGR1cmF0aW9uTWludXRlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTMoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUob2Zmc2V0MiArIGVuY29kZWQgKiBkdXJhdGlvbk1pbnV0ZSk7XG59XG52YXIgbWludXRlID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUzLCBkZWNvZGUzKTtcbnZhciBtaW51dGVfZGVmYXVsdCA9IG1pbnV0ZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2hvdXIudHNcbnZhciBvZmZzZXQzID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGU0KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gb2Zmc2V0MykgLyBkdXJhdGlvbkhvdXIpO1xufVxuZnVuY3Rpb24gZGVjb2RlNChlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShvZmZzZXQzICsgZW5jb2RlZCAqIGR1cmF0aW9uSG91cik7XG59XG52YXIgaG91ciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlNCwgZGVjb2RlNCk7XG52YXIgaG91cl9kZWZhdWx0ID0gaG91cjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2RheS50c1xuZnVuY3Rpb24gZW5jb2RlNShkYXRlKSB7XG4gIGNvbnN0IHR6T2Zmc2V0TXMgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gdHpPZmZzZXRNcykgLyBkdXJhdGlvbkRheSk7XG59XG5mdW5jdGlvbiBkZWNvZGU1KGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKDE5NzAsIDAsIDEpO1xuICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgZGF5ID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU1LCBkZWNvZGU1KTtcbnZhciBkYXlfZGVmYXVsdCA9IGRheTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3dlZWsudHNcbmZ1bmN0aW9uIHdlZWtkYXkod2Vla1N0YXJ0KSB7XG4gIGNvbnN0IHRodXJzZGF5MiA9IDQ7XG4gIGNvbnN0IGRheVNoaWZ0ID0gKDcgKyB3ZWVrU3RhcnQgLSB0aHVyc2RheTIpICUgNztcbiAgZnVuY3Rpb24gZW5jb2RlMTMoZGF0ZSkge1xuICAgIGNvbnN0IHR6T2Zmc2V0TXMgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSB0ek9mZnNldE1zKSAvIGR1cmF0aW9uV2VlayAtIGRheVNoaWZ0IC8gNyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlMTMoZW5jb2RlZCkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgxOTcwLCAwLCAxKTtcbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkICogNyArIGRheVNoaWZ0KTtcbiAgICByZXR1cm4gZDtcbiAgfVxuICByZXR1cm4gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMywgZGVjb2RlMTMpO1xufVxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcbnZhciB3ZWVrX2RlZmF1bHQgPSBzdW5kYXk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9tb250aC50c1xuZnVuY3Rpb24gZW5jb2RlNihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgKiAxMiArIGRhdGUuZ2V0TW9udGgoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTYoZW5jb2RlZCkge1xuICBjb25zdCB5ZWFyMiA9IE1hdGguZmxvb3IoZW5jb2RlZCAvIDEyKTtcbiAgY29uc3QgbW9udGgyID0gZW5jb2RlZCAtIHllYXIyICogMTI7XG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyMiwgbW9udGgyLCAxKTtcbn1cbnZhciBtb250aCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlNiwgZGVjb2RlNik7XG52YXIgbW9udGhfZGVmYXVsdCA9IG1vbnRoO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUveWVhci50c1xuZnVuY3Rpb24gZW5jb2RlNyhkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBkZWNvZGU3KGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBkLnNldEZ1bGxZZWFyKGVuY29kZWQpO1xuICBkLnNldE1vbnRoKDAsIDEpO1xuICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB5ZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU3LCBkZWNvZGU3KTtcbnZhciB5ZWFyX2RlZmF1bHQgPSB5ZWFyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjTWludXRlLnRzXG5mdW5jdGlvbiBlbmNvZGU4KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBkdXJhdGlvbk1pbnV0ZSk7XG59XG5mdW5jdGlvbiBkZWNvZGU4KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQgKiBkdXJhdGlvbk1pbnV0ZSk7XG59XG52YXIgdXRjTWludXRlID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU4LCBkZWNvZGU4KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y0hvdXIudHNcbmZ1bmN0aW9uIGVuY29kZTkoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIGR1cmF0aW9uSG91cik7XG59XG5mdW5jdGlvbiBkZWNvZGU5KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQgKiBkdXJhdGlvbkhvdXIpO1xufVxudmFyIHV0Y0hvdXIgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTksIGRlY29kZTkpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjRGF5LnRzXG5mdW5jdGlvbiBlbmNvZGUxMChkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gZHVyYXRpb25EYXkpO1xufVxuZnVuY3Rpb24gZGVjb2RlMTAoZW5jb2RlZCkge1xuICBjb25zdCBkID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApO1xuICBkLnNldFVUQ0RhdGUoZC5nZXRVVENEYXRlKCkgKyBlbmNvZGVkKTtcbiAgZC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgdXRjRGF5ID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMCwgZGVjb2RlMTApO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjTW9udGgudHNcbmZ1bmN0aW9uIGVuY29kZTExKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAqIDEyICsgZGF0ZS5nZXRVVENNb250aCgpO1xufVxuZnVuY3Rpb24gZGVjb2RlMTEoZW5jb2RlZCkge1xuICBjb25zdCB5ZWFyMiA9IE1hdGguZmxvb3IoZW5jb2RlZCAvIDEyKTtcbiAgY29uc3QgbW9udGgyID0gZW5jb2RlZCAtIHllYXIyICogMTI7XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyMiwgbW9udGgyLCAxKSk7XG59XG52YXIgdXRjTW9udGggPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTExLCBkZWNvZGUxMSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNZZWFyLnRzXG5mdW5jdGlvbiBlbmNvZGUxMihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMihlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgZC5zZXRVVENGdWxsWWVhcihlbmNvZGVkKTtcbiAgZC5zZXRVVENNb250aCgwLCAxKTtcbiAgZC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgdXRjWWVhciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTIsIGRlY29kZTEyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL2Zyb21Ub01vdGlvbi50c1xudmFyIGZyb21Ub01vdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChmcm9tVG9Nb3Rpb25fZXhwb3J0cywge1xuICBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HOiAoKSA9PiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HLFxuICBmcm9tVG9Nb3Rpb246ICgpID0+IGZyb21Ub01vdGlvbixcbiAgc3RhdGljRnJvbVRvTW90aW9uOiAoKSA9PiBzdGF0aWNGcm9tVG9Nb3Rpb25cbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2lkLnRzXG52YXIgSURfTUFQID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlc2V0SWRzKCkge1xuICBJRF9NQVAuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlkKGluc3RhbmNlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IE9iamVjdC5oYXNPd24oY29uc3RydWN0b3IsIFwiY2xhc3NOYW1lXCIpID8gY29uc3RydWN0b3IuY2xhc3NOYW1lIDogY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAke2NvbnN0cnVjdG9yfSBpcyBtaXNzaW5nIHRoZSAnY2xhc3NOYW1lJyBwcm9wZXJ0eS5gKTtcbiAgfVxuICBjb25zdCBuZXh0SWQgPSAoSURfTUFQLmdldChjbGFzc05hbWUpID8/IDApICsgMTtcbiAgSURfTUFQLnNldChjbGFzc05hbWUsIG5leHRJZCk7XG4gIHJldHVybiBgJHtjbGFzc05hbWV9LSR7bmV4dElkfWA7XG59XG5mdW5jdGlvbiB1dWlkKCkge1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKCkpO1xuICByZXR1cm4gdXJsLnNwbGl0KFwiL1wiKS5hdCgtMSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaXRlcmF0b3IudHNcbmZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSkge1xuICAgIHJldHVybiBhcmdzSXRlcmFibGUodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uKiBhcnJheXNJdGVyYWJsZSguLi5hcnJheXMpIHtcbiAgZm9yIChjb25zdCBhcnJheTIgb2YgYXJyYXlzKSB7XG4gICAgZm9yIChjb25zdCBlIG9mIGFycmF5Mikge1xuICAgICAgeWllbGQgZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uKiBhcmdzSXRlcmFibGUoLi4uYXJncykge1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgeWllbGQgYXJnO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaW50ZXJwb2xhdGluZy50c1xudmFyIGludGVycG9sYXRlID0gXCIkaW50ZXJwb2xhdGVcIjtcbnZhciBpc0ludGVycG9sYXRpbmcgPSAoeCkgPT4geFtpbnRlcnBvbGF0ZV0gIT0gbnVsbDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9uZWFyZXN0LnRzXG5mdW5jdGlvbiBuZWFyZXN0U3F1YXJlZCh4LCB5LCBvYmplY3RzLCBtYXhEaXN0YW5jZVNxdWFyZWQgPSBJbmZpbml0eSkge1xuICBjb25zdCByZXN1bHQgPSB7IG5lYXJlc3Q6IHZvaWQgMCwgZGlzdGFuY2VTcXVhcmVkOiBtYXhEaXN0YW5jZVNxdWFyZWQgfTtcbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGNvbnN0IHRoaXNEaXN0YW5jZSA9IG9iai5kaXN0YW5jZVNxdWFyZWQoeCwgeSk7XG4gICAgaWYgKHRoaXNEaXN0YW5jZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgbmVhcmVzdDogb2JqLCBkaXN0YW5jZVNxdWFyZWQ6IDAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXNEaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgIHJlc3VsdC5uZWFyZXN0ID0gb2JqO1xuICAgICAgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCA9IHRoaXNEaXN0YW5jZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXIoeCwgeSwgY29udGFpbmVyLCBtYXhEaXN0YW5jZVNxdWFyZWQgPSBJbmZpbml0eSkge1xuICBjb25zdCB7IHg6IHR4LCB5OiB0eSB9ID0gY29udGFpbmVyLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICBjb25zdCByZXN1bHQgPSB7IG5lYXJlc3Q6IHZvaWQgMCwgZGlzdGFuY2VTcXVhcmVkOiBtYXhEaXN0YW5jZVNxdWFyZWQgfTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjb250YWluZXIuY2hpbGRyZW4pIHtcbiAgICBjb25zdCB7IG5lYXJlc3QsIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMyB9ID0gY2hpbGQubmVhcmVzdFNxdWFyZWQodHgsIHR5LCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKTtcbiAgICBpZiAoZGlzdGFuY2VTcXVhcmVkMyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQzIH07XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVNxdWFyZWQzIDwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgcmVzdWx0Lm5lYXJlc3QgPSBuZWFyZXN0O1xuICAgICAgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCA9IGRpc3RhbmNlU3F1YXJlZDM7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbnVtYmVyLnRzXG5mdW5jdGlvbiBjbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gY2xhbXBBcnJheSh2YWx1ZSwgYXJyYXkyKSB7XG4gIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KGFycmF5Mik7XG4gIHJldHVybiBjbGFtcChtaW4sIHZhbHVlLCBtYXgpO1xufVxuZnVuY3Rpb24gZmluZE1pbk1heChhcnJheTIpIHtcbiAgaWYgKGFycmF5Mi5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCByZXN1bHQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGZvciAoY29uc3QgdmFsIG9mIGFycmF5Mikge1xuICAgIGlmICh2YWwgPCByZXN1bHRbMF0pXG4gICAgICByZXN1bHRbMF0gPSB2YWw7XG4gICAgaWYgKHZhbCA+IHJlc3VsdFsxXSlcbiAgICAgIHJlc3VsdFsxXSA9IHZhbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFJhbmdlRXh0ZW50KGFycmF5Mikge1xuICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heChhcnJheTIpO1xuICByZXR1cm4gbWF4IC0gbWluO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBlcHNpbG9uMiA9IDFlLTEwKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBlcHNpbG9uMjtcbn1cbmZ1bmN0aW9uIGlzTmVnYXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGguc2lnbih2YWx1ZSkgPT09IC0xIHx8IE9iamVjdC5pcyh2YWx1ZSwgLTApO1xufVxuZnVuY3Rpb24gcm91bmQodmFsdWUsIGRlY2ltYWxzID0gMikge1xuICBjb25zdCBiYXNlID0gMTAgKiogZGVjaW1hbHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogYmFzZSkgLyBiYXNlO1xufVxuZnVuY3Rpb24gdG9GaXhlZCh2YWx1ZSwgZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzID0gMikge1xuICBjb25zdCBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnModmFsdWUpKSAvIE1hdGguTE4xMCk7XG4gIGlmIChwb3dlciA+PSAwIHx8ICFpc0Zpbml0ZShwb3dlcikpIHtcbiAgICByZXR1cm4gdmFsdWUudG9GaXhlZChmcmFjdGlvbk9yU2lnbmlmaWNhbnREaWdpdHMpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b0ZpeGVkKE1hdGguYWJzKHBvd2VyKSAtIDEgKyBmcmFjdGlvbk9yU2lnbmlmaWNhbnREaWdpdHMpO1xufVxuZnVuY3Rpb24gbW9kKG4sIG0pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IobiAlIG0gKyAobiA8IDAgPyBtIDogMCkpO1xufVxuZnVuY3Rpb24gY291bnRGcmFjdGlvbkRpZ2l0cyh2YWx1ZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlKVxuICAgIHJldHVybiAwO1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5zcGxpdChcIi5cIilbMV0/Lmxlbmd0aCA/PyAwO1xufVxuZnVuY3Rpb24gZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2UocmF0aW8yLCBsb2NhbGUpIHtcbiAgbG9jYWxlID0gbG9jYWxlID8/IG5hdmlnYXRvci5sYW5ndWFnZTtcbiAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHsgc3R5bGU6IFwicGVyY2VudFwiIH0pLmZvcm1hdChyYXRpbzIpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGVyY2VudGFnZShwZXJjZW50LCBsb2NhbGUpIHtcbiAgcmV0dXJuIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlKHBlcmNlbnQgLyAxMDAsIGxvY2FsZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2Jib3gudHNcbnZhciBfQkJveCA9IGNsYXNzIF9CQm94IHtcbiAgY29uc3RydWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgc3RhdGljIGZyb21ET01SZWN0KHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KSB7XG4gICAgcmV0dXJuIG5ldyBfQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICB0b0RPTVJlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIHRvcDogdGhpcy55LFxuICAgICAgbGVmdDogdGhpcy54LFxuICAgICAgcmlnaHQ6IHRoaXMueCArIHRoaXMud2lkdGgsXG4gICAgICBib3R0b206IHRoaXMueSArIHRoaXMuaGVpZ2h0LFxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBfQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueSAmJiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiB4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgfVxuICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuY29sbGlkZXNCQm94KG90aGVyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXdYMSA9IGNsYW1wKG90aGVyLngsIHRoaXMueCwgb3RoZXIueCArIG90aGVyLndpZHRoKTtcbiAgICBjb25zdCBuZXdZMSA9IGNsYW1wKG90aGVyLnksIHRoaXMueSwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG4gICAgY29uc3QgbmV3WDIgPSBjbGFtcChvdGhlci54LCB0aGlzLnggKyB0aGlzLndpZHRoLCBvdGhlci54ICsgb3RoZXIud2lkdGgpO1xuICAgIGNvbnN0IG5ld1kyID0gY2xhbXAob3RoZXIueSwgdGhpcy55ICsgdGhpcy5oZWlnaHQsIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuICAgIHJldHVybiBuZXcgX0JCb3gobmV3WDEsIG5ld1kxLCBuZXdYMiAtIG5ld1gxLCBuZXdZMiAtIG5ld1kxKTtcbiAgfVxuICBjb2xsaWRlc0JCb3gob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy54IDwgb3RoZXIueCArIG90aGVyLndpZHRoICYmIHRoaXMueCArIHRoaXMud2lkdGggPiBvdGhlci54ICYmIHRoaXMueSA8IG90aGVyLnkgKyBvdGhlci5oZWlnaHQgJiYgdGhpcy55ICsgdGhpcy5oZWlnaHQgPiBvdGhlci55O1xuICB9XG4gIGNvbXB1dGVDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICB9XG4gIGlzRmluaXRlKCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGhpcy54KSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy55KSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy53aWR0aCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBkeCA9IHggLSBjbGFtcCh0aGlzLngsIHgsIHRoaXMueCArIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGR5ID0geSAtIGNsYW1wKHRoaXMueSwgeSwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuICBzdGF0aWMgbmVhcmVzdEJveCh4LCB5LCBib3hlcykge1xuICAgIHJldHVybiBuZWFyZXN0U3F1YXJlZCh4LCB5LCBib3hlcyk7XG4gIH1cbiAgY2xpcChjbGlwUmVjdCkge1xuICAgIGlmIChjbGlwUmVjdCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heCh0aGlzLngsIGNsaXBSZWN0LngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgodGhpcy55LCBjbGlwUmVjdC55KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIGNsaXBSZWN0LnggKyBjbGlwUmVjdC53aWR0aCk7XG4gICAgY29uc3QgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgY2xpcFJlY3QueSArIGNsaXBSZWN0LmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDAsIHgyIC0geDEpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgeTIgLSB5MSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2hyaW5rKGFtb3VudCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBhcHBseTIgPSAocG9zLCBhbXQpID0+IHtcbiAgICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICB0aGlzLnkgKz0gYW10O1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gYW10O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgIHRoaXMueCArPSBhbXQ7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIHRoaXMud2lkdGggLT0gYW10O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICB0aGlzLnkgKz0gYW10O1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdCAqIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgdGhpcy54ICs9IGFtdDtcbiAgICAgICAgICB0aGlzLndpZHRoIC09IGFtdCAqIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICAgIHRoaXMueCArPSBhbXQ7XG4gICAgICAgICAgdGhpcy53aWR0aCAtPSBhbXQgKiAyO1xuICAgICAgICAgIHRoaXMueSArPSBhbXQ7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gYW10ICogMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBhcHBseTIocG9zaXRpb24sIGFtb3VudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYW1vdW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhhbW91bnQpLmZvckVhY2goKFtwb3MsIGFtdF0pID0+IGFwcGx5Mihwb3MsIGFtdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93KGFtb3VudCwgcG9zaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5zaHJpbmsoLWFtb3VudCwgcG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYWRkaW5nQ29weSA9IHsgLi4uYW1vdW50IH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYWRkaW5nQ29weSkge1xuICAgICAgICBwYWRkaW5nQ29weVtrZXldICo9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5zaHJpbmsocGFkZGluZ0NvcHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMueCArPSB4O1xuICAgIHRoaXMueSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbWJpbmUob3RoZXIpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgdGhpcy54ID0gTWF0aC5taW4oeCwgb3RoZXIueCk7XG4gICAgdGhpcy55ID0gTWF0aC5taW4oeSwgb3RoZXIueSk7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHggKyB3aWR0aCwgb3RoZXIueCArIG90aGVyLndpZHRoKSAtIHRoaXMueDtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHkgKyBoZWlnaHQsIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpIC0gdGhpcy55O1xuICB9XG4gIHN0YXRpYyBtZXJnZShib3hlcykge1xuICAgIGxldCBsZWZ0ID0gSW5maW5pdHk7XG4gICAgbGV0IHRvcCA9IEluZmluaXR5O1xuICAgIGxldCByaWdodCA9IC1JbmZpbml0eTtcbiAgICBsZXQgYm90dG9tID0gLUluZmluaXR5O1xuICAgIGZvciAoY29uc3QgYm94IG9mIGJveGVzKSB7XG4gICAgICBpZiAoYm94LnggPCBsZWZ0KSB7XG4gICAgICAgIGxlZnQgPSBib3gueDtcbiAgICAgIH1cbiAgICAgIGlmIChib3gueSA8IHRvcCkge1xuICAgICAgICB0b3AgPSBib3gueTtcbiAgICAgIH1cbiAgICAgIGlmIChib3gueCArIGJveC53aWR0aCA+IHJpZ2h0KSB7XG4gICAgICAgIHJpZ2h0ID0gYm94LnggKyBib3gud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnkgKyBib3guaGVpZ2h0ID4gYm90dG9tKSB7XG4gICAgICAgIGJvdHRvbSA9IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQkJveChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgfVxuICBbaW50ZXJwb2xhdGVdKG90aGVyLCBkKSB7XG4gICAgcmV0dXJuIG5ldyBfQkJveChcbiAgICAgIHRoaXMueCAqICgxIC0gZCkgKyBvdGhlci54ICogZCxcbiAgICAgIHRoaXMueSAqICgxIC0gZCkgKyBvdGhlci55ICogZCxcbiAgICAgIHRoaXMud2lkdGggKiAoMSAtIGQpICsgb3RoZXIud2lkdGggKiBkLFxuICAgICAgdGhpcy5oZWlnaHQgKiAoMSAtIGQpICsgb3RoZXIuaGVpZ2h0ICogZFxuICAgICk7XG4gIH1cbn07XG5fQkJveC56ZXJvID0gT2JqZWN0LmZyZWV6ZShuZXcgX0JCb3goMCwgMCwgMCwgMCkpO1xuX0JCb3guTmFOID0gT2JqZWN0LmZyZWV6ZShuZXcgX0JCb3goTmFOLCBOYU4sIE5hTiwgTmFOKSk7XG52YXIgQkJveCA9IF9CQm94O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9jaGFuZ2VEZXRlY3RhYmxlLnRzXG52YXIgUmVkcmF3VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHJhd1R5cGUyKSA9PiB7XG4gIFJlZHJhd1R5cGUyW1JlZHJhd1R5cGUyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIFJlZHJhd1R5cGUyW1JlZHJhd1R5cGUyW1wiVFJJVklBTFwiXSA9IDFdID0gXCJUUklWSUFMXCI7XG4gIFJlZHJhd1R5cGUyW1JlZHJhd1R5cGUyW1wiTUlOT1JcIl0gPSAyXSA9IFwiTUlOT1JcIjtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJNQUpPUlwiXSA9IDNdID0gXCJNQUpPUlwiO1xuICByZXR1cm4gUmVkcmF3VHlwZTI7XG59KShSZWRyYXdUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGBfXyR7a2V5fWA7XG4gICAgaWYgKHRhcmdldFtrZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXBhcmVHZXRTZXQodGFyZ2V0LCBrZXksIHByaXZhdGVLZXksIG9wdHMpO1xuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUdldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7XG4gICAgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovLFxuICAgIHR5cGUgPSBcIm5vcm1hbFwiLFxuICAgIGNoYW5nZUNiLFxuICAgIGNvbnZlcnRvcixcbiAgICBjaGVja0RpcnR5T25Bc3NpZ25tZW50ID0gZmFsc2VcbiAgfSA9IG9wdHMgPz8ge307XG4gIGNvbnN0IHJlcXVpcmVkT3B0cyA9IHsgcmVkcmF3LCB0eXBlLCBjaGFuZ2VDYiwgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCwgY29udmVydG9yIH07XG4gIGxldCBzZXR0ZXI7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJub3JtYWxcIjpcbiAgICAgIHNldHRlciA9IGJ1aWxkTm9ybWFsU2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJhbnNmb3JtXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZFRyYW5zZm9ybVNldHRlcihwcml2YXRlS2V5LCByZXF1aXJlZE9wdHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICAgIHNldHRlciA9IGJ1aWxkUGF0aFNldHRlcihwcml2YXRlS2V5LCByZXF1aXJlZE9wdHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZvbnRcIjpcbiAgICAgIHNldHRlciA9IGJ1aWxkRm9udFNldHRlcihwcml2YXRlS2V5LCByZXF1aXJlZE9wdHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc2V0dGVyID0gYnVpbGRDaGVja0RpcnR5Q2hhaW4oXG4gICAgYnVpbGRDaGFuZ2VDYWxsYmFja0NoYWluKGJ1aWxkQ29udmVydG9yQ2hhaW4oc2V0dGVyLCByZXF1aXJlZE9wdHMpLCByZXF1aXJlZE9wdHMpLFxuICAgIHJlcXVpcmVkT3B0c1xuICApO1xuICBjb25zdCBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1twcml2YXRlS2V5XTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgc2V0OiBzZXR0ZXIsXG4gICAgZ2V0OiBnZXR0ZXIsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBidWlsZENvbnZlcnRvckNoYWluKHNldHRlckZuLCBvcHRzKSB7XG4gIGNvbnN0IHsgY29udmVydG9yIH0gPSBvcHRzO1xuICBpZiAoY29udmVydG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBzZXR0ZXJGbi5jYWxsKHRoaXMsIGNvbnZlcnRvcih2YWx1ZSkpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNldHRlckZuO1xufVxudmFyIE5PX0NIQU5HRSA9IFN5bWJvbChcIm5vLWNoYW5nZVwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2hhbmdlQ2FsbGJhY2tDaGFpbihzZXR0ZXJGbiwgb3B0cykge1xuICBjb25zdCB7IGNoYW5nZUNiIH0gPSBvcHRzO1xuICBpZiAoY2hhbmdlQ2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnN0IGNoYW5nZSA9IHNldHRlckZuLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKGNoYW5nZSAhPT0gTk9fQ0hBTkdFKSB7XG4gICAgICAgIGNoYW5nZUNiLmNhbGwodGhpcywgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNldHRlckZuO1xufVxuZnVuY3Rpb24gYnVpbGRDaGVja0RpcnR5Q2hhaW4oc2V0dGVyRm4sIG9wdHMpIHtcbiAgY29uc3QgeyBjaGVja0RpcnR5T25Bc3NpZ25tZW50IH0gPSBvcHRzO1xuICBpZiAoY2hlY2tEaXJ0eU9uQXNzaWdubWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc3QgY2hhbmdlID0gc2V0dGVyRm4uY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAoY2hhbmdlICE9PSBOT19DSEFOR0UgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5fZGlydHkgPiAwIC8qIE5PTkUgKi8pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkodmFsdWUsIHZhbHVlLl9kaXJ0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNldHRlckZuO1xufVxuZnVuY3Rpb24gYnVpbGROb3JtYWxTZXR0ZXIocHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLywgY2hhbmdlQ2IgfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCByZWRyYXcpO1xuICAgICAgY2hhbmdlQ2I/Lih0aGlzKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtU2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8gfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICB0aGlzLm1hcmtEaXJ0eVRyYW5zZm9ybShyZWRyYXcpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQYXRoU2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8gfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX2RpcnR5UGF0aCkge1xuICAgICAgICB0aGlzLl9kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCByZWRyYXcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRGb250U2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8gfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX2RpcnR5Rm9udCkge1xuICAgICAgICB0aGlzLl9kaXJ0eUZvbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCByZWRyYXcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxudmFyIENoYW5nZURldGVjdGFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2RpcnR5ID0gMyAvKiBNQUpPUiAqLztcbiAgfVxuICBtYXJrRGlydHkoX3NvdXJjZSwgdHlwZSA9IDEgLyogVFJJVklBTCAqLykge1xuICAgIGlmICh0aGlzLl9kaXJ0eSA8IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RpcnR5ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgbWFya0NsZWFuKF9vcHRzKSB7XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHkgPiAwIC8qIE5PTkUgKi87XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL21hdHJpeC50c1xudmFyIF9NYXRyaXggPSBjbGFzcyBfTWF0cml4IHtcbiAgZ2V0IGUoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlbGVtZW50czMgPSBbMSwgMCwgMCwgMSwgMCwgMF0pIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHMzO1xuICB9XG4gIHNldEVsZW1lbnRzKGVsZW1lbnRzMykge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSBlbGVtZW50czNbMF07XG4gICAgZVsxXSA9IGVsZW1lbnRzM1sxXTtcbiAgICBlWzJdID0gZWxlbWVudHMzWzJdO1xuICAgIGVbM10gPSBlbGVtZW50czNbM107XG4gICAgZVs0XSA9IGVsZW1lbnRzM1s0XTtcbiAgICBlWzVdID0gZWxlbWVudHMzWzVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBpZGVudGl0eSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gZVswXSA9PT0gMSAmJiBlWzFdID09PSAwICYmIGVbMl0gPT09IDAgJiYgZVszXSA9PT0gMSAmJiBlWzRdID09PSAwICYmIGVbNV0gPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSBBeEIgbWF0cml4IG11bHRpcGxpY2F0aW9uIGFuZCBzYXZlcyB0aGUgcmVzdWx0XG4gICAqIHRvIGBDYCwgaWYgZ2l2ZW4sIG9yIHRvIGBBYCBvdGhlcndpc2UuXG4gICAqL1xuICBBeEIoQSwgQiwgQykge1xuICAgIGNvbnN0IGEgPSBBWzBdICogQlswXSArIEFbMl0gKiBCWzFdLCBiID0gQVsxXSAqIEJbMF0gKyBBWzNdICogQlsxXSwgYyA9IEFbMF0gKiBCWzJdICsgQVsyXSAqIEJbM10sIGQgPSBBWzFdICogQlsyXSArIEFbM10gKiBCWzNdLCBlID0gQVswXSAqIEJbNF0gKyBBWzJdICogQls1XSArIEFbNF0sIGYgPSBBWzFdICogQls0XSArIEFbM10gKiBCWzVdICsgQVs1XTtcbiAgICBDID0gQyA/PyBBO1xuICAgIENbMF0gPSBhO1xuICAgIENbMV0gPSBiO1xuICAgIENbMl0gPSBjO1xuICAgIENbM10gPSBkO1xuICAgIENbNF0gPSBlO1xuICAgIENbNV0gPSBmO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYG90aGVyYCBtYXRyaXggZ2V0cyBwb3N0LW11bHRpcGxpZWQgdG8gdGhlIGN1cnJlbnQgbWF0cml4LlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICogQHBhcmFtIG90aGVyXG4gICAqL1xuICBtdWx0aXBseVNlbGYob3RoZXIpIHtcbiAgICB0aGlzLkF4Qih0aGlzLmVsZW1lbnRzLCBvdGhlci5lbGVtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgb3RoZXJgIG1hdHJpeCBnZXRzIHBvc3QtbXVsdGlwbGllZCB0byB0aGUgY3VycmVudCBtYXRyaXguXG4gICAqIFJldHVybnMgYSBuZXcgbWF0cml4LlxuICAgKiBAcGFyYW0gb3RoZXJcbiAgICovXG4gIG11bHRpcGx5KG90aGVyKSB7XG4gICAgY29uc3QgZWxlbWVudHMzID0gbmV3IEFycmF5KDYpO1xuICAgIHRoaXMuQXhCKHRoaXMuZWxlbWVudHMsIG90aGVyLmVsZW1lbnRzLCBlbGVtZW50czMpO1xuICAgIHJldHVybiBuZXcgX01hdHJpeChlbGVtZW50czMpO1xuICB9XG4gIHByZU11bHRpcGx5U2VsZihvdGhlcikge1xuICAgIHRoaXMuQXhCKG90aGVyLmVsZW1lbnRzLCB0aGlzLmVsZW1lbnRzLCB0aGlzLmVsZW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGlzIG1hdHJpeCBhcyBhIG5ldyBtYXRyaXguXG4gICAqL1xuICBpbnZlcnNlKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50cztcbiAgICBsZXQgYSA9IGVsWzBdLCBiID0gZWxbMV0sIGMgPSBlbFsyXSwgZCA9IGVsWzNdO1xuICAgIGNvbnN0IGUgPSBlbFs0XSwgZiA9IGVsWzVdO1xuICAgIGNvbnN0IHJEID0gMSAvIChhICogZCAtIGIgKiBjKTtcbiAgICBhICo9IHJEO1xuICAgIGIgKj0gckQ7XG4gICAgYyAqPSByRDtcbiAgICBkICo9IHJEO1xuICAgIHJldHVybiBuZXcgX01hdHJpeChbZCwgLWIsIC1jLCBhLCBjICogZiAtIGQgKiBlLCBiICogZSAtIGEgKiBmXSk7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggdG8gdGhlIGdpdmVuIG1hdHJpeC5cbiAgICovXG4gIGludmVyc2VUbyhvdGhlcikge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50cztcbiAgICBsZXQgYSA9IGVsWzBdLCBiID0gZWxbMV0sIGMgPSBlbFsyXSwgZCA9IGVsWzNdO1xuICAgIGNvbnN0IGUgPSBlbFs0XSwgZiA9IGVsWzVdO1xuICAgIGNvbnN0IHJEID0gMSAvIChhICogZCAtIGIgKiBjKTtcbiAgICBhICo9IHJEO1xuICAgIGIgKj0gckQ7XG4gICAgYyAqPSByRDtcbiAgICBkICo9IHJEO1xuICAgIG90aGVyLnNldEVsZW1lbnRzKFtkLCAtYiwgLWMsIGEsIGMgKiBmIC0gZCAqIGUsIGIgKiBlIC0gYSAqIGZdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnZlcnRTZWxmKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50cztcbiAgICBsZXQgYSA9IGVsWzBdLCBiID0gZWxbMV0sIGMgPSBlbFsyXSwgZCA9IGVsWzNdO1xuICAgIGNvbnN0IGUgPSBlbFs0XSwgZiA9IGVsWzVdO1xuICAgIGNvbnN0IHJEID0gMSAvIChhICogZCAtIGIgKiBjKTtcbiAgICBhICo9IHJEO1xuICAgIGIgKj0gckQ7XG4gICAgYyAqPSByRDtcbiAgICBkICo9IHJEO1xuICAgIGVsWzBdID0gZDtcbiAgICBlbFsxXSA9IC1iO1xuICAgIGVsWzJdID0gLWM7XG4gICAgZWxbM10gPSBhO1xuICAgIGVsWzRdID0gYyAqIGYgLSBkICogZTtcbiAgICBlbFs1XSA9IGIgKiBlIC0gYSAqIGY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHJhbnNmb3JtUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICogZVswXSArIHkgKiBlWzJdICsgZVs0XSxcbiAgICAgIHk6IHggKiBlWzFdICsgeSAqIGVbM10gKyBlWzVdXG4gICAgfTtcbiAgfVxuICB0cmFuc2Zvcm1CQm94KGJib3gsIHRhcmdldCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCB4eCA9IGVsWzBdO1xuICAgIGNvbnN0IHh5ID0gZWxbMV07XG4gICAgY29uc3QgeXggPSBlbFsyXTtcbiAgICBjb25zdCB5eSA9IGVsWzNdO1xuICAgIGNvbnN0IGhfdyA9IGJib3gud2lkdGggKiAwLjU7XG4gICAgY29uc3QgaF9oID0gYmJveC5oZWlnaHQgKiAwLjU7XG4gICAgY29uc3QgY3ggPSBiYm94LnggKyBoX3c7XG4gICAgY29uc3QgY3kgPSBiYm94LnkgKyBoX2g7XG4gICAgY29uc3QgdyA9IE1hdGguYWJzKGhfdyAqIHh4KSArIE1hdGguYWJzKGhfaCAqIHl4KTtcbiAgICBjb25zdCBoID0gTWF0aC5hYnMoaF93ICogeHkpICsgTWF0aC5hYnMoaF9oICogeXkpO1xuICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gbmV3IEJCb3goMCwgMCwgMCwgMCkpO1xuICAgIHRhcmdldC54ID0gY3ggKiB4eCArIGN5ICogeXggKyBlbFs0XSAtIHc7XG4gICAgdGFyZ2V0LnkgPSBjeCAqIHh5ICsgY3kgKiB5eSArIGVsWzVdIC0gaDtcbiAgICB0YXJnZXQud2lkdGggPSB3ICsgdztcbiAgICB0YXJnZXQuaGVpZ2h0ID0gaCArIGg7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0b0NvbnRleHQoY3R4KSB7XG4gICAgaWYgKHRoaXMuaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgY3R4LnRyYW5zZm9ybShlWzBdLCBlWzFdLCBlWzJdLCBlWzNdLCBlWzRdLCBlWzVdKTtcbiAgfVxuICBzdGF0aWMgZmx5d2VpZ2h0KHNvdXJjZU1hdHJpeCkge1xuICAgIHJldHVybiBfTWF0cml4Lmluc3RhbmNlLnNldEVsZW1lbnRzKHNvdXJjZU1hdHJpeC5lbGVtZW50cyk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIHNjYWxpbmdYLCBzY2FsaW5nWSwgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZLCBvcHRzKSB7XG4gICAgY29uc3Qgc3ggPSBzY2FsaW5nWDtcbiAgICBjb25zdCBzeSA9IHNjYWxpbmdZO1xuICAgIGxldCBzY3g7XG4gICAgbGV0IHNjeTtcbiAgICBpZiAoc3ggPT09IDEgJiYgc3kgPT09IDEpIHtcbiAgICAgIHNjeCA9IDA7XG4gICAgICBzY3kgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3ggPSBvcHRzPy5zY2FsaW5nQ2VudGVyWCA/PyAwO1xuICAgICAgc2N5ID0gb3B0cz8uc2NhbGluZ0NlbnRlclkgPz8gMDtcbiAgICB9XG4gICAgY29uc3QgciA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHIpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHIpO1xuICAgIGxldCByY3g7XG4gICAgbGV0IHJjeTtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgcmN4ID0gMDtcbiAgICAgIHJjeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJjeCA9IG9wdHM/LnJvdGF0aW9uQ2VudGVyWCA/PyAwO1xuICAgICAgcmN5ID0gb3B0cz8ucm90YXRpb25DZW50ZXJZID8/IDA7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0gdHJhbnNsYXRpb25YO1xuICAgIGNvbnN0IHR5ID0gdHJhbnNsYXRpb25ZO1xuICAgIGNvbnN0IHR4NCA9IHNjeCAqICgxIC0gc3gpIC0gcmN4O1xuICAgIGNvbnN0IHR5NCA9IHNjeSAqICgxIC0gc3kpIC0gcmN5O1xuICAgIG1hdHJpeC5zZXRFbGVtZW50cyhbXG4gICAgICBjb3MgKiBzeCxcbiAgICAgIHNpbiAqIHN4LFxuICAgICAgLXNpbiAqIHN5LFxuICAgICAgY29zICogc3ksXG4gICAgICBjb3MgKiB0eDQgLSBzaW4gKiB0eTQgKyByY3ggKyB0eCxcbiAgICAgIHNpbiAqIHR4NCArIGNvcyAqIHR5NCArIHJjeSArIHR5XG4gICAgXSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICBzdGF0aWMgZnJvbUNvbnRleHQoY3R4KSB7XG4gICAgY29uc3QgZG9tTWF0cml4ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgIHJldHVybiBuZXcgX01hdHJpeChbZG9tTWF0cml4LmEsIGRvbU1hdHJpeC5iLCBkb21NYXRyaXguYywgZG9tTWF0cml4LmQsIGRvbU1hdHJpeC5lLCBkb21NYXRyaXguZl0pO1xuICB9XG59O1xuX01hdHJpeC5pbnN0YW5jZSA9IG5ldyBfTWF0cml4KCk7XG52YXIgTWF0cml4ID0gX01hdHJpeDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbm9kZS50c1xudmFyIFBvaW50ZXJFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyRXZlbnRzMikgPT4ge1xuICBQb2ludGVyRXZlbnRzMltQb2ludGVyRXZlbnRzMltcIkFsbFwiXSA9IDBdID0gXCJBbGxcIjtcbiAgUG9pbnRlckV2ZW50czJbUG9pbnRlckV2ZW50czJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIFBvaW50ZXJFdmVudHMyO1xufSkoUG9pbnRlckV2ZW50cyB8fCB7fSk7XG52YXIgX05vZGUgPSBjbGFzcyBfTm9kZSBleHRlbmRzIENoYW5nZURldGVjdGFibGUge1xuICBjb25zdHJ1Y3Rvcih7IGlzVmlydHVhbCwgdGFnLCB6SW5kZXgsIG5hbWUgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogVW5pcXVlIG51bWJlciB0byBhbGxvdyBjcmVhdGlvbiBvcmRlciB0byBiZSBlYXNpbHkgZGV0ZXJtaW5lZC4gKi9cbiAgICB0aGlzLnNlcmlhbE51bWJlciA9IF9Ob2RlLl9uZXh0U2VyaWFsTnVtYmVyKys7XG4gICAgLyoqXG4gICAgICogVW5pcXVlIG5vZGUgSUQgaW4gdGhlIGZvcm0gYENsYXNzTmFtZS1OYXR1cmFsTnVtYmVyYC5cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgLyoqXG4gICAgICogVG8gc2ltcGxpZnkgdGhlIHR5cGUgc3lzdGVtIChlc3BlY2lhbGx5IGluIFNlbGVjdGlvbnMpIHdlIGRvbid0IGhhdmUgdGhlIGBQYXJlbnRgIG5vZGVcbiAgICAgKiAob25lIHRoYXQgaGFzIGNoaWxkcmVuKS4gSW5zdGVhZCwgd2UgbWltaWMgSFRNTCBET00sIHdoZXJlIGFueSBub2RlIGNhbiBoYXZlIGNoaWxkcmVuLlxuICAgICAqIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGRpc3Rpbmd1aXNoIHJlZ3VsYXIgbGVhZiBub2RlcyBmcm9tIGNvbnRhaW5lciBsZWFmcyBzb21laG93LlxuICAgICAqL1xuICAgIHRoaXMuaXNDb250YWluZXJOb2RlID0gZmFsc2U7XG4gICAgdGhpcy5fdmlydHVhbENoaWxkcmVuID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAvLyBVc2VkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgbm9kZXMuXG4gICAgdGhpcy5jaGlsZFNldCA9IHt9O1xuICAgIC8vIFRoZXNlIG1hdHJpY2VzIG1heSBuZWVkIHRvIGhhdmUgcGFja2FnZSBsZXZlbCB2aXNpYmlsaXR5XG4gICAgLy8gZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBwdXJwb3Nlcy5cbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmRpcnR5VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsaW5nWCA9IDE7XG4gICAgdGhpcy5zY2FsaW5nWSA9IDE7XG4gICAgdGhpcy5zY2FsaW5nQ2VudGVyWCA9IG51bGw7XG4gICAgdGhpcy5zY2FsaW5nQ2VudGVyWSA9IG51bGw7XG4gICAgdGhpcy5yb3RhdGlvbkNlbnRlclggPSBudWxsO1xuICAgIHRoaXMucm90YXRpb25DZW50ZXJZID0gbnVsbDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIHRoaXMuX2NoaWxkTm9kZUNvdW50cyA9IHtcbiAgICAgIGdyb3VwczogMCxcbiAgICAgIG5vbkdyb3VwczogMFxuICAgIH07XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gZmFsc2U7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICAgIC8qKiBEaXNjcmltaW5hdG9ycyBmb3IgcmVuZGVyIG9yZGVyIHdpdGhpbiBhIHpJbmRleC4gKi9cbiAgICB0aGlzLnpJbmRleFN1Yk9yZGVyID0gdm9pZCAwO1xuICAgIHRoaXMucG9pbnRlckV2ZW50cyA9IDAgLyogQWxsICovO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pc1ZpcnR1YWwgPSBpc1ZpcnR1YWwgPz8gZmFsc2U7XG4gICAgdGhpcy50YWcgPSB0YWcgPz8gTmFOO1xuICAgIHRoaXMuekluZGV4ID0gekluZGV4ID8/IDA7XG4gIH1cbiAgLyoqXG4gICAqIFNvbWUgYXJiaXRyYXJ5IGRhdGEgYm91bmQgdG8gdGhlIG5vZGUuXG4gICAqL1xuICBnZXQgZGF0dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdHVtID8/IHRoaXMuX3BhcmVudD8uZGF0dW07XG4gIH1cbiAgZ2V0IHByZXZpb3VzRGF0dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGF0dW07XG4gIH1cbiAgc2V0IGRhdHVtKGRhdHVtKSB7XG4gICAgaWYgKHRoaXMuX2RhdHVtICE9PSBkYXR1bSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNEYXR1bSA9IHRoaXMuX2RhdHVtO1xuICAgIH1cbiAgICB0aGlzLl9kYXR1bSA9IGRhdHVtO1xuICB9XG4gIF9zZXRMYXllck1hbmFnZXIodmFsdWUpIHtcbiAgICB0aGlzLl9sYXllck1hbmFnZXIgPSB2YWx1ZTtcbiAgICB0aGlzLl9kZWJ1ZyA9IHZhbHVlPy5kZWJ1ZztcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKHZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLl9zZXRMYXllck1hbmFnZXIodmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXQgbGF5ZXJNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXllck1hbmFnZXI7XG4gIH1cbiAgKmFuY2VzdG9ycygpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbiAgKnRyYXZlcnNlVXAoKSB7XG4gICAgeWllbGQgdGhpcztcbiAgICB5aWVsZCogdGhpcy5hbmNlc3RvcnMoKTtcbiAgfVxuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH1cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5fY2hpbGRyZW4uY29uY2F0KHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5mbGF0TWFwKChuZXh0KSA9PiBuZXh0LmNoaWxkcmVuKSkgOiB0aGlzLl9jaGlsZHJlbjtcbiAgfVxuICBnZXQgdmlydHVhbENoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl92aXJ0dWFsQ2hpbGRyZW47XG4gIH1cbiAgaGFzVmlydHVhbENoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgfVxuICAvLyBuZXcgU2V0PE5vZGU+KClcbiAgc2V0UHJvcGVydGllcyhzdHlsZXMsIHBpY2tLZXlzKSB7XG4gICAgaWYgKHBpY2tLZXlzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBwaWNrS2V5cykge1xuICAgICAgICB0aGlzW2tleV0gPSBzdHlsZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzdHlsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBvbmUgb3IgbW9yZSBuZXcgbm9kZSBpbnN0YW5jZXMgdG8gdGhpcyBwYXJlbnQuXG4gICAqIElmIG9uZSBuZWVkcyB0bzpcbiAgICogLSBtb3ZlIGEgY2hpbGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiAtIG1vdmUgYSBjaGlsZCBmcm9tIG9uZSBwYXJlbnQgdG8gYW5vdGhlciAoaW5jbHVkaW5nIHBhcmVudHMgaW4gb3RoZXIgc2NlbmVzKVxuICAgKiBvbmUgc2hvdWxkIHVzZSB0aGUge0BsaW5rIGluc2VydEJlZm9yZX0gbWV0aG9kIGluc3RlYWQuXG4gICAqIEBwYXJhbSBub2RlcyBBIG5vZGUgb3Igbm9kZXMgdG8gYXBwZW5kLlxuICAgKi9cbiAgYXBwZW5kKG5vZGVzKSB7XG4gICAgbm9kZXMgPSB0b0l0ZXJhYmxlKG5vZGVzKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bm9kZX0gYWxyZWFkeSBiZWxvbmdzIHRvIGFub3RoZXIgcGFyZW50OiAke25vZGUucGFyZW50fS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmxheWVyTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bm9kZX0gYWxyZWFkeSBiZWxvbmdzIHRvIGEgc2NlbmU6ICR7bm9kZS5sYXllck1hbmFnZXJ9LmApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hpbGRTZXRbbm9kZS5pZF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IG5vZGU6ICR7bm9kZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmlzVmlydHVhbCkge1xuICAgICAgICB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkU2V0W25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgIG5vZGUuX3BhcmVudCA9IHRoaXM7XG4gICAgICBub2RlLl9zZXRMYXllck1hbmFnZXIodGhpcy5sYXllck1hbmFnZXIpO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCAzIC8qIE1BSk9SICovKTtcbiAgfVxuICBhcHBlbmRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5hcHBlbmQobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbm9kZSB0byBiZSByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgbm9kZS5gKTtcbiAgICB9O1xuICAgIGlmIChub2RlLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgZXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuaXNWaXJ0dWFsKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fdmlydHVhbENoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaSA8IDApXG4gICAgICAgIGVycm9yKCk7XG4gICAgICB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4uc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgIGlmIChpIDwgMClcbiAgICAgICAgZXJyb3IoKTtcbiAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuY2hpbGRTZXRbbm9kZS5pZF07XG4gICAgbm9kZS5fcGFyZW50ID0gdm9pZCAwO1xuICAgIG5vZGUuX3NldExheWVyTWFuYWdlcigpO1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSB0cnVlO1xuICAgIHRoaXMubWFya0RpcnR5KG5vZGUsIDMgLyogTUFKT1IgKi8pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYXJyYXlzSXRlcmFibGUodGhpcy5fdmlydHVhbENoaWxkcmVuLCB0aGlzLl9jaGlsZHJlbikpIHtcbiAgICAgIGNoaWxkLl9wYXJlbnQgPSB2b2lkIDA7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgfVxuICAgIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jaGlsZFNldCA9IHt9O1xuICB9XG4gIGNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKSB7XG4gICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgY29uc3QgbWF0cml4ID0gTWF0cml4LmZseXdlaWdodCh0aGlzLm1hdHJpeCk7XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2YgdGhpcy5hbmNlc3RvcnMoKSkge1xuICAgICAgcGFyZW50LmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIG1hdHJpeC5wcmVNdWx0aXBseVNlbGYocGFyZW50Lm1hdHJpeCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbiAgdHJhbnNmb3JtUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlQ3VtdWxhdGl2ZU1hdHJpeCgpO1xuICAgIHJldHVybiBtYXRyaXguaW52ZXJ0U2VsZigpLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICB9XG4gIGludmVyc2VUcmFuc2Zvcm1Qb2ludCh4LCB5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCk7XG4gICAgcmV0dXJuIG1hdHJpeC50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgfVxuICB0cmFuc2Zvcm1CQm94KGJib3gpIHtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKTtcbiAgICByZXR1cm4gbWF0cml4LmludmVydFNlbGYoKS50cmFuc2Zvcm1CQm94KGJib3gpO1xuICB9XG4gIGludmVyc2VUcmFuc2Zvcm1CQm94KGJib3gpIHtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKTtcbiAgICByZXR1cm4gbWF0cml4LnRyYW5zZm9ybUJCb3goYmJveCk7XG4gIH1cbiAgbWFya0RpcnR5VHJhbnNmb3JtKCkge1xuICAgIHRoaXMuZGlydHlUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIDMgLyogTUFKT1IgKi8pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wYXJlbnQ/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoX3gsIF95KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBIaXQgdGVzdGluZyBtZXRob2QuXG4gICAqIFJlY3Vyc2l2ZWx5IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoaXMgbm9kZSBvciBhbnkgb2YgaXRzIGNoaWxkcmVuLlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIG9yIGB1bmRlZmluZWRgLlxuICAgKiBOb2RlcyB0aGF0IHJlbmRlciBsYXRlciAoc2hvdyBvbiB0b3ApIGFyZSBoaXQgdGVzdGVkIGZpcnN0LlxuICAgKi9cbiAgcGlja05vZGUoeCwgeSkge1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMucG9pbnRlckV2ZW50cyA9PT0gMSAvKiBOb25lICovIHx8ICF0aGlzLmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcztcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMWUzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgY29udGFpbnNQb2ludCA9IGNoaWxkLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKT8uY29udGFpbnNQb2ludCh4LCB5KTtcbiAgICAgICAgY29uc3QgaGl0ID0gY29udGFpbnNQb2ludCA/IGNoaWxkLnBpY2tOb2RlKHgsIHkpIDogdm9pZCAwO1xuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2hpbGRyZW5baV0ucGlja05vZGUoeCwgeSk7XG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5pc0NvbnRhaW5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBnZXRCQm94KGZvcmNlUmVjYWxjdWxhdGlvbiA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkQkJveCA9PSBudWxsIHx8IGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgICAgdGhpcy5jYWNoZWRCQm94ID0gT2JqZWN0LmZyZWV6ZSh0aGlzLmNvbXB1dGVCQm94KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZWRCQm94O1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKT8uY2xvbmUoKTtcbiAgICBpZiAoIWJib3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgY29uc3QgbWF0cml4ID0gTWF0cml4LmZseXdlaWdodCh0aGlzLm1hdHJpeCk7XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2YgdGhpcy5hbmNlc3RvcnMoKSkge1xuICAgICAgcGFyZW50LmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIG1hdHJpeC5wcmVNdWx0aXBseVNlbGYocGFyZW50Lm1hdHJpeCk7XG4gICAgfVxuICAgIG1hdHJpeC50cmFuc2Zvcm1CQm94KGJib3gsIGJib3gpO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIGNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKSB7XG4gICAgaWYgKCF0aGlzLmRpcnR5VHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hdHJpeCxcbiAgICAgIHNjYWxpbmdYLFxuICAgICAgc2NhbGluZ1ksXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWSxcbiAgICAgIHNjYWxpbmdDZW50ZXJYLFxuICAgICAgc2NhbGluZ0NlbnRlclksXG4gICAgICByb3RhdGlvbkNlbnRlclgsXG4gICAgICByb3RhdGlvbkNlbnRlcllcbiAgICB9ID0gdGhpcztcbiAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgc2NhbGluZ1gsIHNjYWxpbmdZLCByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIHtcbiAgICAgIHNjYWxpbmdDZW50ZXJYLFxuICAgICAgc2NhbGluZ0NlbnRlclksXG4gICAgICByb3RhdGlvbkNlbnRlclgsXG4gICAgICByb3RhdGlvbkNlbnRlcllcbiAgICB9KTtcbiAgICB0aGlzLmRpcnR5VHJhbnNmb3JtID0gZmFsc2U7XG4gIH1cbiAgdHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgsIGxheWVyQ3R4KSB7XG4gICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgdGhpcy5tYXRyaXgudG9Db250ZXh0KGxheWVyQ3R4ID8/IHJlbmRlckN0eC5jdHgpO1xuICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgfVxuICAvKiogUGVyZm9ybSBhbnkgcHJlLXJlbmRlcmluZyBpbml0aWFsaXphdGlvbi4gKi9cbiAgcHJlUmVuZGVyKCkge1xuICAgIHRoaXMuX2NoaWxkTm9kZUNvdW50cy5ncm91cHMgPSAwO1xuICAgIHRoaXMuX2NoaWxkTm9kZUNvdW50cy5ub25Hcm91cHMgPSAxO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRDb3VudHMgPSBjaGlsZC5wcmVSZW5kZXIoKTtcbiAgICAgIHRoaXMuX2NoaWxkTm9kZUNvdW50cy5ncm91cHMgKz0gY2hpbGRDb3VudHMuZ3JvdXBzO1xuICAgICAgdGhpcy5fY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcyArPSBjaGlsZENvdW50cy5ub25Hcm91cHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGlsZE5vZGVDb3VudHM7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgICB0aGlzLmNhY2hlZEJCb3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XG4gICAgaWYgKHN0YXRzKSB7XG4gICAgICBzdGF0cy5ub2Rlc1JlbmRlcmVkKys7XG4gICAgfVxuICB9XG4gIG1hcmtEaXJ0eShfc291cmNlLCB0eXBlID0gMSAvKiBUUklWSUFMICovLCBwYXJlbnRUeXBlID0gdHlwZSkge1xuICAgIHRoaXMuY2FjaGVkQkJveCA9IHZvaWQgMDtcbiAgICBpZiAodGhpcy5fZGlydHkgPiB0eXBlIHx8IHRoaXMuX2RpcnR5ID09PSB0eXBlICYmIHR5cGUgPT09IHBhcmVudFR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0eXBlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQubWFya0RpcnR5KHRoaXMsIHBhcmVudFR5cGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXllck1hbmFnZXIpIHtcbiAgICAgIHRoaXMubGF5ZXJNYW5hZ2VyLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBnZXQgZGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xuICB9XG4gIG1hcmtDbGVhbihvcHRzKSB7XG4gICAgY29uc3QgeyBmb3JjZSA9IGZhbHNlLCByZWN1cnNpdmUgPSB0cnVlIH0gPSBvcHRzID8/IHt9O1xuICAgIGlmICh0aGlzLl9kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgICBpZiAocmVjdXJzaXZlICE9PSBmYWxzZSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGQubWFya0NsZWFuKHsgZm9yY2UgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGQubWFya0NsZWFuKHsgZm9yY2UgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uVmlzaWJsZUNoYW5nZSgpIHtcbiAgfVxuICBnZXQgbm9kZUNvdW50KCkge1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgbGV0IGRpcnR5Q291bnQgPSB0aGlzLl9kaXJ0eSA+PSAwIC8qIE5PTkUgKi8gfHwgdGhpcy5kaXJ0eVRyYW5zZm9ybSA/IDEgOiAwO1xuICAgIGxldCB2aXNpYmxlQ291bnQgPSB0aGlzLnZpc2libGUgPyAxIDogMDtcbiAgICBjb25zdCBjb3VudENoaWxkID0gKGNoaWxkKSA9PiB7XG4gICAgICBjb25zdCB7IGNvdW50OiBjaGlsZENvdW50LCB2aXNpYmxlQ291bnQ6IGNoaWxkVmlzaWJsZUNvdW50LCBkaXJ0eUNvdW50OiBjaGlsZERpcnR5Q291bnQgfSA9IGNoaWxkLm5vZGVDb3VudDtcbiAgICAgIGNvdW50ICs9IGNoaWxkQ291bnQ7XG4gICAgICB2aXNpYmxlQ291bnQgKz0gY2hpbGRWaXNpYmxlQ291bnQ7XG4gICAgICBkaXJ0eUNvdW50ICs9IGNoaWxkRGlydHlDb3VudDtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgIGNvdW50Q2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgY291bnRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvdW50LCB2aXNpYmxlQ291bnQsIGRpcnR5Q291bnQgfTtcbiAgfVxuICBvblpJbmRleENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5fTm9kZS5fbmV4dFNlcmlhbE51bWJlciA9IDA7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJzY2FsaW5nWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInNjYWxpbmdZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwic2NhbGluZ0NlbnRlclhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJzY2FsaW5nQ2VudGVyWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInJvdGF0aW9uQ2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInJvdGF0aW9uQ2VudGVyWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwidHJhbnNsYXRpb25YXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwidHJhbnNsYXRpb25ZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMyAvKiBNQUpPUiAqLyxcbiAgICBjaGFuZ2VDYjogKHRhcmdldCkgPT4gdGFyZ2V0Lm9uVmlzaWJsZUNoYW5nZSgpXG4gIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDEgLyogVFJJVklBTCAqLyxcbiAgICBjaGFuZ2VDYjogKHRhcmdldCkgPT4gdGFyZ2V0Lm9uWkluZGV4Q2hhbmdlKClcbiAgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ6SW5kZXhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAxIC8qIFRSSVZJQUwgKi8sXG4gICAgY2hhbmdlQ2I6ICh0YXJnZXQpID0+IHRhcmdldC5vblpJbmRleENoYW5nZSgpXG4gIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwiekluZGV4U3ViT3JkZXJcIiwgMik7XG52YXIgTm9kZSA9IF9Ob2RlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NvbG9yLnRzXG52YXIgbGVycCA9ICh4LCB5LCB0KSA9PiB4ICogKDEgLSB0KSArIHkgKiB0O1xudmFyIHNyZ2JUb0xpbmVhciA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxO1xuICBjb25zdCBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIGlmIChhYnMgPD0gMC4wNDA0NSlcbiAgICByZXR1cm4gdmFsdWUgLyAxMi45MjtcbiAgcmV0dXJuIHNpZ24gKiAoKGFicyArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG59O1xudmFyIHNyZ2JGcm9tTGluZWFyID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gIGNvbnN0IGFicyA9IE1hdGguYWJzKHZhbHVlKTtcbiAgaWYgKGFicyA+IDMxMzA4ZS03KSB7XG4gICAgcmV0dXJuIHNpZ24gKiAoMS4wNTUgKiBhYnMgKiogKDEgLyAyLjQpIC0gMC4wNTUpO1xuICB9XG4gIHJldHVybiAxMi45MiAqIHZhbHVlO1xufTtcbnZhciBfQ29sb3IgPSBjbGFzcyBfQ29sb3Ige1xuICAvKipcbiAgICogRXZlcnkgY29sb3IgY29tcG9uZW50IHNob3VsZCBiZSBpbiB0aGUgWzAsIDFdIHJhbmdlLlxuICAgKiBTb21lIGVhc2luZyBmdW5jdGlvbnMgKHN1Y2ggYXMgZWxhc3RpYyBlYXNpbmcpIGNhbiBvdmVyc2hvb3QgdGhlIHRhcmdldCB2YWx1ZSBieSBzb21lIGFtb3VudC5cbiAgICogU28sIHdoZW4gYW5pbWF0aW5nIGNvbG9ycywgaWYgdGhlIHNvdXJjZSBvciB0YXJnZXQgY29sb3IgY29tcG9uZW50cyBhcmUgYWxyZWFkeSBuZWFyXG4gICAqIG9yIGF0IHRoZSBlZGdlIG9mIHRoZSBhbGxvd2VkIFswLCAxXSByYW5nZSwgaXQgaXMgcG9zc2libGUgZm9yIHRoZSBpbnRlcm1lZGlhdGUgY29sb3JcbiAgICogY29tcG9uZW50IHZhbHVlIHRvIGVuZCB1cCBvdXRzaWRlIG9mIHRoYXQgcmFuZ2UgbWlkLWFuaW1hdGlvbi4gRm9yIHRoaXMgcmVhc29uIHRoZSBjb25zdHJ1Y3RvclxuICAgKiBwZXJmb3JtcyByYW5nZSBjaGVja2luZy9jb25zdHJhaW5pbmcuXG4gICAqIEBwYXJhbSByIFJlZCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBnIEdyZWVuIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGIgQmx1ZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBhIEFscGhhIChvcGFjaXR5KSBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyLCBnLCBiLCBhID0gMSkge1xuICAgIHRoaXMuciA9IGNsYW1wKDAsIHIgfHwgMCwgMSk7XG4gICAgdGhpcy5nID0gY2xhbXAoMCwgZyB8fCAwLCAxKTtcbiAgICB0aGlzLmIgPSBjbGFtcCgwLCBiIHx8IDAsIDEpO1xuICAgIHRoaXMuYSA9IGNsYW1wKDAsIGEgfHwgMCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgY29sb3Igc3RyaW5nIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzIHRvIGJlIHZhbGlkOlxuICAgKiAtICNyZ2JcbiAgICogLSAjcnJnZ2JiXG4gICAqIC0gcmdiKHIsIGcsIGIpXG4gICAqIC0gcmdiYShyLCBnLCBiLCBhKVxuICAgKiAtIENTUyBjb2xvciBuYW1lIHN1Y2ggYXMgJ3doaXRlJywgJ29yYW5nZScsICdjeWFuJywgZXRjLlxuICAgKi9cbiAgc3RhdGljIHZhbGlkQ29sb3JTdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKFwiI1wiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gISFfQ29sb3IucGFyc2VIZXgoc3RyKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKFwicmdiXCIpID49IDApIHtcbiAgICAgIHJldHVybiAhIV9Db2xvci5zdHJpbmdUb1JnYmEoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuICEhX0NvbG9yLm5hbWVUb0hleFtzdHIudG9Mb3dlckNhc2UoKV07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnaXZlbiBzdHJpbmcgY2FuIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAqIC0gI3JnYlxuICAgKiAtICNycmdnYmJcbiAgICogLSByZ2IociwgZywgYilcbiAgICogLSByZ2JhKHIsIGcsIGIsIGEpXG4gICAqIC0gQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGMuXG4gICAqIEBwYXJhbSBzdHJcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihcIiNcIikgPj0gMCkge1xuICAgICAgcmV0dXJuIF9Db2xvci5mcm9tSGV4U3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IF9Db2xvci5uYW1lVG9IZXhbc3RyLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmIChoZXgpIHtcbiAgICAgIHJldHVybiBfQ29sb3IuZnJvbUhleFN0cmluZyhoZXgpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoXCJyZ2JcIikgPj0gMCkge1xuICAgICAgcmV0dXJuIF9Db2xvci5mcm9tUmdiYVN0cmluZyhzdHIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3Igc3RyaW5nOiAnJHtzdHJ9J2ApO1xuICB9XG4gIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLyNoZXgtbm90YXRpb25cbiAgc3RhdGljIHBhcnNlSGV4KGlucHV0KSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC8gL2csIFwiXCIpLnNsaWNlKDEpO1xuICAgIGxldCBwYXJ0cztcbiAgICBzd2l0Y2ggKGlucHV0Lmxlbmd0aCkge1xuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA4OlxuICAgICAgICBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXJzZUludChgJHtpbnB1dFtpXX0ke2lucHV0W2kgKyAxXX1gLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgICBwYXJ0cyA9IGlucHV0LnNwbGl0KFwiXCIpLm1hcCgocCkgPT4gcGFyc2VJbnQocCwgMTYpKS5tYXAoKHApID0+IHAgKyBwICogMTYpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHBhcnRzPy5sZW5ndGggPj0gMyAmJiBwYXJ0cy5ldmVyeSgocCkgPT4gcCA+PSAwKSkge1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBwYXJ0cy5wdXNoKDI1NSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tSGV4U3RyaW5nKHN0cikge1xuICAgIGNvbnN0IHZhbHVlcyA9IF9Db2xvci5wYXJzZUhleChzdHIpO1xuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHZhbHVlcztcbiAgICAgIHJldHVybiBuZXcgX0NvbG9yKHIgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUsIGEgLyAyNTUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBoZXhhZGVjaW1hbCBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgc3RhdGljIHN0cmluZ1RvUmdiYShzdHIpIHtcbiAgICBsZXQgcG8gPSAtMTtcbiAgICBsZXQgcGMgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IHN0cltpXTtcbiAgICAgIGlmIChwbyA9PT0gLTEgJiYgYyA9PT0gXCIoXCIpIHtcbiAgICAgICAgcG8gPSBpO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBcIilcIikge1xuICAgICAgICBwYyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG8gPT09IC0xIHx8IHBjID09PSAtMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb250ZW50cyA9IHN0ci5zdWJzdHJpbmcocG8gKyAxLCBwYyk7XG4gICAgY29uc3QgcGFydHMgPSBjb250ZW50cy5zcGxpdChcIixcIik7XG4gICAgY29uc3QgcmdiYSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQocGFydCk7XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQuaW5kZXhPZihcIiVcIikgPj0gMCkge1xuICAgICAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAxMDApO1xuICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDMpIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAyNTUpO1xuICAgICAgICB2YWx1ZSAvPSAyNTU7XG4gICAgICB9XG4gICAgICByZ2JhLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmdiYTtcbiAgfVxuICBzdGF0aWMgZnJvbVJnYmFTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgcmdiYSA9IF9Db2xvci5zdHJpbmdUb1JnYmEoc3RyKTtcbiAgICBpZiAocmdiYSkge1xuICAgICAgaWYgKHJnYmEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYmFbMF0sIHJnYmFbMV0sIHJnYmFbMl0pO1xuICAgICAgfSBlbHNlIGlmIChyZ2JhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdLCByZ2JhWzNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgcmdiL3JnYmEgY29sb3Igc3RyaW5nOiAnJHtzdHJ9J2ApO1xuICB9XG4gIHN0YXRpYyBmcm9tQXJyYXkoYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgX0NvbG9yKGFyclswXSwgYXJyWzFdLCBhcnJbMl0sIGFyclszXSk7XG4gICAgfVxuICAgIGlmIChhcnIubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihhcnJbMF0sIGFyclsxXSwgYXJyWzJdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGdpdmVuIGFycmF5IHNob3VsZCBjb250YWluIDMgb3IgNCBjb2xvciBjb21wb25lbnRzIChudW1iZXJzKS5cIik7XG4gIH1cbiAgc3RhdGljIGZyb21IU0IoaCwgcywgYiwgYWxwaGEgPSAxKSB7XG4gICAgY29uc3QgcmdiID0gX0NvbG9yLkhTQnRvUkdCKGgsIHMsIGIpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgZnJvbUhTTChoLCBzLCBsLCBhbHBoYSA9IDEpIHtcbiAgICBjb25zdCByZ2IgPSBfQ29sb3IuSFNMdG9SR0IoaCwgcywgbCk7XG4gICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSwgYWxwaGEpO1xuICB9XG4gIHN0YXRpYyBmcm9tT0tMQ0gobCwgYywgaCwgYWxwaGEgPSAxKSB7XG4gICAgY29uc3QgcmdiID0gX0NvbG9yLk9LTENIdG9SR0IobCwgYywgaCk7XG4gICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSwgYWxwaGEpO1xuICB9XG4gIHN0YXRpYyBwYWRIZXgoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDEgPyBcIjBcIiArIHN0ciA6IHN0cjtcbiAgfVxuICB0b0hleFN0cmluZygpIHtcbiAgICBsZXQgaGV4ID0gXCIjXCIgKyBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5yICogMjU1KS50b1N0cmluZygxNikpICsgX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuZyAqIDI1NSkudG9TdHJpbmcoMTYpKSArIF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpLnRvU3RyaW5nKDE2KSk7XG4gICAgaWYgKHRoaXMuYSA8IDEpIHtcbiAgICAgIGhleCArPSBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5hICogMjU1KS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIHRvUmdiYVN0cmluZyhmcmFjdGlvbkRpZ2l0cyA9IDMpIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gW01hdGgucm91bmQodGhpcy5yICogMjU1KSwgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpLCBNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSldO1xuICAgIGNvbnN0IGsgPSBNYXRoLnBvdygxMCwgZnJhY3Rpb25EaWdpdHMpO1xuICAgIGlmICh0aGlzLmEgIT09IDEpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChNYXRoLnJvdW5kKHRoaXMuYSAqIGspIC8gayk7XG4gICAgICByZXR1cm4gYHJnYmEoJHtjb21wb25lbnRzLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGByZ2IoJHtjb21wb25lbnRzLmpvaW4oXCIsIFwiKX0pYDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5hID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b1JnYmFTdHJpbmcoKTtcbiAgfVxuICB0b0hTQigpIHtcbiAgICByZXR1cm4gX0NvbG9yLlJHQnRvSFNCKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9XG4gIHN0YXRpYyBSR0J0b09LTENIKHIsIGcsIGIpIHtcbiAgICBjb25zdCBMU1JHQjAgPSBzcmdiVG9MaW5lYXIocik7XG4gICAgY29uc3QgTFNSR0IxID0gc3JnYlRvTGluZWFyKGcpO1xuICAgIGNvbnN0IExTUkdCMiA9IHNyZ2JUb0xpbmVhcihiKTtcbiAgICBjb25zdCBMTVMwID0gTWF0aC5jYnJ0KDAuNDEyMjIxNDcwOCAqIExTUkdCMCArIDAuNTM2MzMyNTM2MyAqIExTUkdCMSArIDAuMDUxNDQ1OTkyOSAqIExTUkdCMik7XG4gICAgY29uc3QgTE1TMSA9IE1hdGguY2JydCgwLjIxMTkwMzQ5ODIgKiBMU1JHQjAgKyAwLjY4MDY5OTU0NTEgKiBMU1JHQjEgKyAwLjEwNzM5Njk1NjYgKiBMU1JHQjIpO1xuICAgIGNvbnN0IExNUzIgPSBNYXRoLmNicnQoMC4wODgzMDI0NjE5ICogTFNSR0IwICsgMC4yODE3MTg4Mzc2ICogTFNSR0IxICsgMC42Mjk5Nzg3MDA1ICogTFNSR0IyKTtcbiAgICBjb25zdCBPS0xBQjAgPSAwLjIxMDQ1NDI1NTMgKiBMTVMwICsgMC43OTM2MTc3ODUgKiBMTVMxIC0gMC4wMDQwNzIwNDY4ICogTE1TMjtcbiAgICBjb25zdCBPS0xBQjEgPSAxLjk3Nzk5ODQ5NTEgKiBMTVMwIC0gMi40Mjg1OTIyMDUgKiBMTVMxICsgMC40NTA1OTM3MDk5ICogTE1TMjtcbiAgICBjb25zdCBPS0xBQjIgPSAwLjAyNTkwNDAzNzEgKiBMTVMwICsgMC43ODI3NzE3NjYyICogTE1TMSAtIDAuODA4Njc1NzY2ICogTE1TMjtcbiAgICBjb25zdCBodWUgPSBNYXRoLmF0YW4yKE9LTEFCMiwgT0tMQUIxKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgY29uc3QgT0tMQ0gwID0gT0tMQUIwO1xuICAgIGNvbnN0IE9LTENIMSA9IE1hdGguaHlwb3QoT0tMQUIxLCBPS0xBQjIpO1xuICAgIGNvbnN0IE9LTENIMiA9IGh1ZSA+PSAwID8gaHVlIDogaHVlICsgMzYwO1xuICAgIHJldHVybiBbT0tMQ0gwLCBPS0xDSDEsIE9LTENIMl07XG4gIH1cbiAgc3RhdGljIE9LTENIdG9SR0IobCwgYywgaCkge1xuICAgIGNvbnN0IE9LTEFCMCA9IGw7XG4gICAgY29uc3QgT0tMQUIxID0gYyAqIE1hdGguY29zKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICBjb25zdCBPS0xBQjIgPSBjICogTWF0aC5zaW4oaCAqIE1hdGguUEkgLyAxODApO1xuICAgIGNvbnN0IExNUzAgPSAoT0tMQUIwICsgMC4zOTYzMzc3Nzc0ICogT0tMQUIxICsgMC4yMTU4MDM3NTczICogT0tMQUIyKSAqKiAzO1xuICAgIGNvbnN0IExNUzEgPSAoT0tMQUIwIC0gMC4xMDU1NjEzNDU4ICogT0tMQUIxIC0gMC4wNjM4NTQxNzI4ICogT0tMQUIyKSAqKiAzO1xuICAgIGNvbnN0IExNUzIgPSAoT0tMQUIwIC0gMC4wODk0ODQxNzc1ICogT0tMQUIxIC0gMS4yOTE0ODU1NDggKiBPS0xBQjIpICoqIDM7XG4gICAgY29uc3QgTFNSR0IwID0gNC4wNzY3NDE2NjIxICogTE1TMCAtIDMuMzA3NzExNTkxMyAqIExNUzEgKyAwLjIzMDk2OTkyOTIgKiBMTVMyO1xuICAgIGNvbnN0IExTUkdCMSA9IC0xLjI2ODQzODAwNDYgKiBMTVMwICsgMi42MDk3NTc0MDExICogTE1TMSAtIDAuMzQxMzE5Mzk2NSAqIExNUzI7XG4gICAgY29uc3QgTFNSR0IyID0gLTAuMDA0MTk2MDg2MyAqIExNUzAgLSAwLjcwMzQxODYxNDcgKiBMTVMxICsgMS43MDc2MTQ3MDEgKiBMTVMyO1xuICAgIGNvbnN0IFNSR0IwID0gc3JnYkZyb21MaW5lYXIoTFNSR0IwKTtcbiAgICBjb25zdCBTUkdCMSA9IHNyZ2JGcm9tTGluZWFyKExTUkdCMSk7XG4gICAgY29uc3QgU1JHQjIgPSBzcmdiRnJvbUxpbmVhcihMU1JHQjIpO1xuICAgIHJldHVybiBbU1JHQjAsIFNSR0IxLCBTUkdCMl07XG4gIH1cbiAgc3RhdGljIFJHQnRvSFNMKHIsIGcsIGIpIHtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIGxldCBoO1xuICAgIGxldCBzO1xuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgaCA9IDA7XG4gICAgICBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVsdGEzID0gbWF4IC0gbWluO1xuICAgICAgcyA9IGwgPiAwLjUgPyBkZWx0YTMgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YTMgLyAobWF4ICsgbWluKTtcbiAgICAgIGlmIChtYXggPT09IHIpIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTMgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICB9IGVsc2UgaWYgKG1heCA9PT0gZykge1xuICAgICAgICBoID0gKGIgLSByKSAvIGRlbHRhMyArIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gKHIgLSBnKSAvIGRlbHRhMyArIDQ7XG4gICAgICB9XG4gICAgICBoICo9IDM2MCAvIDY7XG4gICAgfVxuICAgIHJldHVybiBbaCwgcywgbF07XG4gIH1cbiAgc3RhdGljIEhTTHRvUkdCKGgsIHMsIGwpIHtcbiAgICBoID0gKGggJSAzNjAgKyAzNjApICUgMzYwO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByZXR1cm4gW2wsIGwsIGxdO1xuICAgIH1cbiAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIGZ1bmN0aW9uIGh1ZVRvUmdiKHQpIHtcbiAgICAgIGlmICh0IDwgMClcbiAgICAgICAgdCArPSAxO1xuICAgICAgaWYgKHQgPiAxKVxuICAgICAgICB0IC09IDE7XG4gICAgICBpZiAodCA8IDEgLyA2KVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgIGlmICh0IDwgMSAvIDIpXG4gICAgICAgIHJldHVybiBxO1xuICAgICAgaWYgKHQgPCAyIC8gMylcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGNvbnN0IHIgPSBodWVUb1JnYihoIC8gMzYwICsgMSAvIDMpO1xuICAgIGNvbnN0IGcgPSBodWVUb1JnYihoIC8gMzYwKTtcbiAgICBjb25zdCBiID0gaHVlVG9SZ2IoaCAvIDM2MCAtIDEgLyAzKTtcbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gUkdCIHRyaXBsZSB0byBhbiBhcnJheSBvZiBIU0IgKEhTVikgY29tcG9uZW50cy5cbiAgICovXG4gIHN0YXRpYyBSR0J0b0hTQihyLCBnLCBiKSB7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgUyA9IG1heCA9PT0gMCA/IDAgOiAobWF4IC0gbWluKSAvIG1heDtcbiAgICBsZXQgSCA9IDA7XG4gICAgaWYgKG1pbiAhPT0gbWF4KSB7XG4gICAgICBjb25zdCBkZWx0YTMgPSBtYXggLSBtaW47XG4gICAgICBjb25zdCByYyA9IChtYXggLSByKSAvIGRlbHRhMztcbiAgICAgIGNvbnN0IGdjID0gKG1heCAtIGcpIC8gZGVsdGEzO1xuICAgICAgY29uc3QgYmMgPSAobWF4IC0gYikgLyBkZWx0YTM7XG4gICAgICBpZiAociA9PT0gbWF4KSB7XG4gICAgICAgIEggPSBiYyAtIGdjO1xuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgICAgSCA9IDIgKyByYyAtIGJjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSCA9IDQgKyBnYyAtIHJjO1xuICAgICAgfVxuICAgICAgSCAvPSA2O1xuICAgICAgaWYgKEggPCAwKSB7XG4gICAgICAgIEggPSBIICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtIICogMzYwLCBTLCBtYXhdO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gSFNCIChIU1YpIHRyaXBsZSB0byBhbiBhcnJheSBvZiBSR0IgY29tcG9uZW50cy5cbiAgICovXG4gIHN0YXRpYyBIU0J0b1JHQihILCBTLCBCKSB7XG4gICAgSCA9IChIICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbiAgICBsZXQgciA9IDA7XG4gICAgbGV0IGcgPSAwO1xuICAgIGxldCBiID0gMDtcbiAgICBpZiAoUyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gQjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaCA9IChIIC0gTWF0aC5mbG9vcihIKSkgKiA2O1xuICAgICAgY29uc3QgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuICAgICAgY29uc3QgcCA9IEIgKiAoMSAtIFMpO1xuICAgICAgY29uc3QgcSA9IEIgKiAoMSAtIFMgKiBmKTtcbiAgICAgIGNvbnN0IHQgPSBCICogKDEgLSBTICogKDEgLSBmKSk7XG4gICAgICBzd2l0Y2ggKGggPj4gMCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgciA9IEI7XG4gICAgICAgICAgZyA9IHQ7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByID0gcTtcbiAgICAgICAgICBnID0gQjtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSBCO1xuICAgICAgICAgIGIgPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IHE7XG4gICAgICAgICAgYiA9IEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByID0gdDtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gQjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHIgPSBCO1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSBxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9XG4gIHN0YXRpYyBtaXgoYzAsIGMxLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29sb3IobGVycChjMC5yLCBjMS5yLCB0KSwgbGVycChjMC5nLCBjMS5nLCB0KSwgbGVycChjMC5iLCBjMS5iLCB0KSwgbGVycChjMC5hLCBjMS5hLCB0KSk7XG4gIH1cbn07XG4vKipcbiAqIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNDpcbiAqIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtY29sb3IvI25hbWVkLWNvbG9yc1xuICovXG5fQ29sb3IubmFtZVRvSGV4ID0ge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgYW50aXF1ZXdoaXRlOiBcIiNGQUVCRDdcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGFxdWFtYXJpbmU6IFwiIzdGRkZENFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgYmlzcXVlOiBcIiNGRkU0QzRcIixcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgYnJvd246IFwiI0E1MkEyQVwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjaGFydHJldXNlOiBcIiM3RkZGMDBcIixcbiAgY2hvY29sYXRlOiBcIiNEMjY5MUVcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIGNvcm5zaWxrOiBcIiNGRkY4RENcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBkYXJrYmx1ZTogXCIjMDAwMDhCXCIsXG4gIGRhcmtjeWFuOiBcIiMwMDhCOEJcIixcbiAgZGFya2dvbGRlbnJvZDogXCIjQjg4NjBCXCIsXG4gIGRhcmtncmF5OiBcIiNBOUE5QTlcIixcbiAgZGFya2dyZWVuOiBcIiMwMDY0MDBcIixcbiAgZGFya2dyZXk6IFwiI0E5QTlBOVwiLFxuICBkYXJra2hha2k6IFwiI0JEQjc2QlwiLFxuICBkYXJrbWFnZW50YTogXCIjOEIwMDhCXCIsXG4gIGRhcmtvbGl2ZWdyZWVuOiBcIiM1NTZCMkZcIixcbiAgZGFya29yYW5nZTogXCIjRkY4QzAwXCIsXG4gIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICBkYXJrcmVkOiBcIiM4QjAwMDBcIixcbiAgZGFya3NhbG1vbjogXCIjRTk5NjdBXCIsXG4gIGRhcmtzZWFncmVlbjogXCIjOEZCQzhGXCIsXG4gIGRhcmtzbGF0ZWJsdWU6IFwiIzQ4M0Q4QlwiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgZGFya3NsYXRlZ3JleTogXCIjMkY0RjRGXCIsXG4gIGRhcmt0dXJxdW9pc2U6IFwiIzAwQ0VEMVwiLFxuICBkYXJrdmlvbGV0OiBcIiM5NDAwRDNcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBkZWVwc2t5Ymx1ZTogXCIjMDBCRkZGXCIsXG4gIGRpbWdyYXk6IFwiIzY5Njk2OVwiLFxuICBkaW1ncmV5OiBcIiM2OTY5NjlcIixcbiAgZG9kZ2VyYmx1ZTogXCIjMUU5MEZGXCIsXG4gIGZpcmVicmljazogXCIjQjIyMjIyXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgZm9yZXN0Z3JlZW46IFwiIzIyOEIyMlwiLFxuICBmdWNoc2lhOiBcIiNGRjAwRkZcIixcbiAgZ2FpbnNib3JvOiBcIiNEQ0RDRENcIixcbiAgZ2hvc3R3aGl0ZTogXCIjRjhGOEZGXCIsXG4gIGdvbGQ6IFwiI0ZGRDcwMFwiLFxuICBnb2xkZW5yb2Q6IFwiI0RBQTUyMFwiLFxuICBncmF5OiBcIiM4MDgwODBcIixcbiAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIGdyZXk6IFwiIzgwODA4MFwiLFxuICBob25leWRldzogXCIjRjBGRkYwXCIsXG4gIGhvdHBpbms6IFwiI0ZGNjlCNFwiLFxuICBpbmRpYW5yZWQ6IFwiI0NENUM1Q1wiLFxuICBpbmRpZ286IFwiIzRCMDA4MlwiLFxuICBpdm9yeTogXCIjRkZGRkYwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgbGF2ZW5kZXI6IFwiI0U2RTZGQVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgbGF3bmdyZWVuOiBcIiM3Q0ZDMDBcIixcbiAgbGVtb25jaGlmZm9uOiBcIiNGRkZBQ0RcIixcbiAgbGlnaHRibHVlOiBcIiNBREQ4RTZcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGxpZ2h0Y3lhbjogXCIjRTBGRkZGXCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgbGlnaHRncmF5OiBcIiNEM0QzRDNcIixcbiAgbGlnaHRncmVlbjogXCIjOTBFRTkwXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIGxpZ2h0cGluazogXCIjRkZCNkMxXCIsXG4gIGxpZ2h0c2FsbW9uOiBcIiNGRkEwN0FcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGxpZ2h0c2t5Ymx1ZTogXCIjODdDRUZBXCIsXG4gIGxpZ2h0c2xhdGVncmF5OiBcIiM3Nzg4OTlcIixcbiAgbGlnaHRzbGF0ZWdyZXk6IFwiIzc3ODg5OVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIGxpbWVncmVlbjogXCIjMzJDRDMyXCIsXG4gIGxpbmVuOiBcIiNGQUYwRTZcIixcbiAgbWFnZW50YTogXCIjRkYwMEZGXCIsXG4gIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICBtZWRpdW1ibHVlOiBcIiMwMDAwQ0RcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgbWVkaXVtcHVycGxlOiBcIiM5MzcwREJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBGQTlBXCIsXG4gIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhEMUNDXCIsXG4gIG1lZGl1bXZpb2xldHJlZDogXCIjQzcxNTg1XCIsXG4gIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIG1pc3R5cm9zZTogXCIjRkZFNEUxXCIsXG4gIG1vY2Nhc2luOiBcIiNGRkU0QjVcIixcbiAgbmF2YWpvd2hpdGU6IFwiI0ZGREVBRFwiLFxuICBuYXZ5OiBcIiMwMDAwODBcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgb3JhbmdlOiBcIiNGRkE1MDBcIixcbiAgb3JhbmdlcmVkOiBcIiNGRjQ1MDBcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgcGFsZWdvbGRlbnJvZDogXCIjRUVFOEFBXCIsXG4gIHBhbGVncmVlbjogXCIjOThGQjk4XCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBwYWxldmlvbGV0cmVkOiBcIiNEQjcwOTNcIixcbiAgcGFwYXlhd2hpcDogXCIjRkZFRkQ1XCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIHBlcnU6IFwiI0NEODUzRlwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgcGx1bTogXCIjRERBMEREXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBwdXJwbGU6IFwiIzgwMDA4MFwiLFxuICByZWJlY2NhcHVycGxlOiBcIiM2NjMzOTlcIixcbiAgcmVkOiBcIiNGRjAwMDBcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgcm95YWxibHVlOiBcIiM0MTY5RTFcIixcbiAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBzYW5keWJyb3duOiBcIiNGNEE0NjBcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBzZWFzaGVsbDogXCIjRkZGNUVFXCIsXG4gIHNpZW5uYTogXCIjQTA1MjJEXCIsXG4gIHNpbHZlcjogXCIjQzBDMEMwXCIsXG4gIHNreWJsdWU6IFwiIzg3Q0VFQlwiLFxuICBzbGF0ZWJsdWU6IFwiIzZBNUFDRFwiLFxuICBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLFxuICBzbGF0ZWdyZXk6IFwiIzcwODA5MFwiLFxuICBzbm93OiBcIiNGRkZBRkFcIixcbiAgc3ByaW5nZ3JlZW46IFwiIzAwRkY3RlwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICB0YW46IFwiI0QyQjQ4Q1wiLFxuICB0ZWFsOiBcIiMwMDgwODBcIixcbiAgdGhpc3RsZTogXCIjRDhCRkQ4XCIsXG4gIHRvbWF0bzogXCIjRkY2MzQ3XCIsXG4gIHRyYW5zcGFyZW50OiBcIiMwMDAwMDAwMFwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIHdoaXRlOiBcIiNGRkZGRkZcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gIHllbGxvd2dyZWVuOiBcIiM5QUNEMzJcIlxufTtcbnZhciBDb2xvciA9IF9Db2xvcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9pbnRlcnBvbGF0ZS50c1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIoYSwgYikge1xuICByZXR1cm4gKGQpID0+IE51bWJlcihhKSAqICgxIC0gZCkgKyBOdW1iZXIoYikgKiBkO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcihhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBhID0gQ29sb3IuZnJvbVN0cmluZyhhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhID0gQ29sb3IuZnJvbUFycmF5KFswLCAwLCAwXSk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBiID0gQ29sb3IuZnJvbVN0cmluZyhiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBiID0gQ29sb3IuZnJvbUFycmF5KFswLCAwLCAwXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAoZCkgPT4gQ29sb3IubWl4KGEsIGIsIGQpLnRvUmdiYVN0cmluZygpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlY29yYXRvci50c1xudmFyIEJSRUFLX1RSQU5TRk9STV9DSEFJTiA9IFN5bWJvbChcIkJSRUFLXCIpO1xudmFyIENPTkZJR19LRVkgPSBcIl9fZGVjb3JhdG9yX2NvbmZpZ1wiO1xuZnVuY3Rpb24gaW5pdGlhbGlzZUNvbmZpZyh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpIHtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBDT05GSUdfS0VZKSA9PSBudWxsKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgQ09ORklHX0tFWSwgeyB2YWx1ZToge30gfSk7XG4gIH1cbiAgY29uc3QgY29uZmlnID0gdGFyZ2V0W0NPTkZJR19LRVldO1xuICBjb25zdCBwcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5T3JTeW1ib2wudG9TdHJpbmcoKTtcbiAgaWYgKHR5cGVvZiBjb25maWdbcHJvcGVydHlLZXldICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gIH1cbiAgY29uc3QgdmFsdWVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbmZpZ1twcm9wZXJ0eUtleV0gPSB7IHNldHRlcnM6IFtdLCBnZXR0ZXJzOiBbXSwgb2JzZXJ2ZXJzOiBbXSwgdmFsdWVzTWFwIH07XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCk7XG4gIGNvbnN0IHByZXZTZXQgPSBkZXNjcmlwdG9yPy5zZXQ7XG4gIGNvbnN0IHByZXZHZXQgPSBkZXNjcmlwdG9yPy5nZXQ7XG4gIGNvbnN0IGdldHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCB2YWx1ZSA9IHByZXZHZXQgPyBwcmV2R2V0LmNhbGwodGhpcykgOiB2YWx1ZXNNYXAuZ2V0KHRoaXMpO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtRm4gb2YgY29uZmlnW3Byb3BlcnR5S2V5XS5nZXR0ZXJzKSB7XG4gICAgICB2YWx1ZSA9IHRyYW5zZm9ybUZuKHRoaXMsIHByb3BlcnR5S2V5T3JTeW1ib2wsIHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gQlJFQUtfVFJBTlNGT1JNX0NIQUlOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBjb25zdCBzZXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IHsgc2V0dGVycywgb2JzZXJ2ZXJzIH0gPSBjb25maWdbcHJvcGVydHlLZXldO1xuICAgIGxldCBvbGRWYWx1ZTtcbiAgICBpZiAoc2V0dGVycy5zb21lKChmKSA9PiBmLmxlbmd0aCA+IDIpKSB7XG4gICAgICBvbGRWYWx1ZSA9IHByZXZHZXQgPyBwcmV2R2V0LmNhbGwodGhpcykgOiB2YWx1ZXNNYXAuZ2V0KHRoaXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybUZuIG9mIHNldHRlcnMpIHtcbiAgICAgIHZhbHVlID0gdHJhbnNmb3JtRm4odGhpcywgcHJvcGVydHlLZXlPclN5bWJvbCwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gQlJFQUtfVFJBTlNGT1JNX0NIQUlOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZTZXQpIHtcbiAgICAgIHByZXZTZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc01hcC5zZXQodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9ic2VydmVyRm4gb2Ygb2JzZXJ2ZXJzKSB7XG4gICAgICBvYnNlcnZlckZuKHRoaXMsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB7XG4gICAgc2V0OiBzZXR0ZXIsXG4gICAgZ2V0OiBnZXR0ZXIsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShzZXRUcmFuc2Zvcm0sIGdldFRyYW5zZm9ybSwgY29uZmlnTWV0YWRhdGEpIHtcbiAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpID0+IHtcbiAgICBjb25zdCBjb25maWcgPSBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCk7XG4gICAgY29uZmlnLnNldHRlcnMucHVzaChzZXRUcmFuc2Zvcm0pO1xuICAgIGlmIChnZXRUcmFuc2Zvcm0pIHtcbiAgICAgIGNvbmZpZy5nZXR0ZXJzLnVuc2hpZnQoZ2V0VHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ01ldGFkYXRhKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgY29uZmlnTWV0YWRhdGEpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZE9ic2VydmVyVG9JbnN0YW5jZVByb3BlcnR5KHNldE9ic2VydmVyKSB7XG4gIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSA9PiB7XG4gICAgaW5pdGlhbGlzZUNvbmZpZyh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpLm9ic2VydmVycy5wdXNoKHNldE9ic2VydmVyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRGVjb3JhdGVkT2JqZWN0KHRhcmdldCkge1xuICByZXR1cm4gdHlwZW9mIHRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDT05GSUdfS0VZIGluIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRhcmdldCkge1xuICBjb25zdCB0YXJnZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgd2hpbGUgKGlzRGVjb3JhdGVkT2JqZWN0KHRhcmdldCkpIHtcbiAgICB0YXJnZXRzLmFkZCh0YXJnZXQ/LltDT05GSUdfS0VZXSk7XG4gICAgdGFyZ2V0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20odGFyZ2V0cykuZmxhdE1hcCgoY29uZmlnTWFwKSA9PiBPYmplY3Qua2V5cyhjb25maWdNYXApKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRhcmdldCkge1xuICByZXR1cm4gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB0YXJnZXRba2V5XSA/PyBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0eU1ldGFkYXRhKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkge1xuICBjb25zdCBwcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5T3JTeW1ib2wudG9TdHJpbmcoKTtcbiAgd2hpbGUgKGlzRGVjb3JhdGVkT2JqZWN0KHRhcmdldCkpIHtcbiAgICBjb25zdCBjb25maWcgPSB0YXJnZXRbQ09ORklHX0tFWV07XG4gICAgaWYgKE9iamVjdC5oYXNPd24oY29uZmlnLCBwcm9wZXJ0eUtleSkpIHtcbiAgICAgIHJldHVybiBjb25maWdbcHJvcGVydHlLZXldO1xuICAgIH1cbiAgICB0YXJnZXQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3R5cGUtZ3VhcmRzLnRzXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNEYXRlKHZhbHVlKSAmJiAhaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgIWlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzRW51bUtleShlbnVtT2JqZWN0LCBlbnVtS2V5KSB7XG4gIHJldHVybiBpc1N0cmluZyhlbnVtS2V5KSAmJiBPYmplY3Qua2V5cyhlbnVtT2JqZWN0KS5pbmNsdWRlcyhlbnVtS2V5KTtcbn1cbmZ1bmN0aW9uIGlzRW51bVZhbHVlKGVudW1PYmplY3QsIGVudW1WYWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhlbnVtT2JqZWN0KS5pbmNsdWRlcyhlbnVtVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzeW1ib2xcIjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9vYmplY3QudHNcbmZ1bmN0aW9uIGRlZXBNZXJnZSguLi5zb3VyY2VzKSB7XG4gIHJldHVybiBtZXJnZURlZmF1bHRzKC4uLnNvdXJjZXMucmV2ZXJzZSgpKTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMoLi4uc291cmNlcykge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmICghaXNPYmplY3Qoc291cmNlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGtleXMgPSBpc0RlY29yYXRlZE9iamVjdChzb3VyY2UpID8gbGlzdERlY29yYXRlZFByb3BlcnRpZXMoc291cmNlKSA6IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pICYmIGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VEZWZhdWx0cyh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPz8gKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VBcnJheURlZmF1bHRzKGRhdGFBcnJheSwgLi4uaXRlbURlZmF1bHRzKSB7XG4gIGlmIChpdGVtRGVmYXVsdHMgJiYgaXNBcnJheShkYXRhQXJyYXkpKSB7XG4gICAgcmV0dXJuIGRhdGFBcnJheS5tYXAoKGl0ZW0pID0+IG1lcmdlRGVmYXVsdHMoaXRlbSwgLi4uaXRlbURlZmF1bHRzKSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFBcnJheTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QyLCBtYXBwZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iamVjdDIpLnJlZHVjZShcbiAgICAocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWFwcGVyKHZhbHVlLCBrZXksIG9iamVjdDIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5mdW5jdGlvbiB3aXRob3V0KG9iamVjdDIsIGtleXMpIHtcbiAgY29uc3QgY2xvbmUgPSB7IC4uLm9iamVjdDIgfTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSBjbG9uZVtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIGdldFBhdGgob2JqZWN0MiwgcGF0aCkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBpc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gcGF0aEFycmF5LnJlZHVjZSgodmFsdWUsIHBhdGhLZXkpID0+IHZhbHVlW3BhdGhLZXldLCBvYmplY3QyKTtcbn1cbnZhciBTS0lQX0pTX0JVSUxUSU5TID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiX19wcm90b19fXCIsIFwiY29uc3RydWN0b3JcIiwgXCJwcm90b3R5cGVcIl0pO1xuZnVuY3Rpb24gc2V0UGF0aChvYmplY3QyLCBwYXRoLCBuZXdWYWx1ZSkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBpc0FycmF5KHBhdGgpID8gcGF0aC5zbGljZSgpIDogcGF0aC5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGxhc3RLZXkgPSBwYXRoQXJyYXkucG9wKCk7XG4gIGlmIChwYXRoQXJyYXkuc29tZSgocCkgPT4gU0tJUF9KU19CVUlMVElOUy5oYXMocCkpKVxuICAgIHJldHVybjtcbiAgY29uc3QgbGFzdE9iamVjdCA9IHBhdGhBcnJheS5yZWR1Y2UoKHZhbHVlLCBwYXRoS2V5KSA9PiB2YWx1ZVtwYXRoS2V5XSwgb2JqZWN0Mik7XG4gIGxhc3RPYmplY3RbbGFzdEtleV0gPSBuZXdWYWx1ZTtcbiAgcmV0dXJuIGxhc3RPYmplY3RbbGFzdEtleV07XG59XG5mdW5jdGlvbiBwYXJ0aWFsQXNzaWduKGtleXNUb0NvcHksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmIChzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvQ29weSkge1xuICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcHJvcGVydGllcy50c1xudmFyIEJhc2VQcm9wZXJ0aWVzID0gY2xhc3Mge1xuICBzZXQocHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgJHtjbGFzc05hbWV9IC0gZXhwZWN0aW5nIGEgcHJvcGVydGllcyBvYmplY3RgKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSk7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eUtleSBvZiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0aGlzKSkge1xuICAgICAgaWYgKGtleXMuaGFzKHByb3BlcnR5S2V5KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbcHJvcGVydHlLZXldO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGlzUHJvcGVydGllcyhzZWxmW3Byb3BlcnR5S2V5XSkpIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XSA9IHNlbGZbcHJvcGVydHlLZXldIGluc3RhbmNlb2YgUHJvcGVydGllc0FycmF5ID8gc2VsZltwcm9wZXJ0eUtleV0ucmVzZXQodmFsdWUpIDogc2VsZltwcm9wZXJ0eUtleV0uc2V0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuZGVsZXRlKHByb3BlcnR5S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB1bmtub3duS2V5IG9mIGtleXMpIHtcbiAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Vua25vd25LZXl9XSBpbiAke2NsYXNzTmFtZX0gLSBwcm9wZXJ0eSBpcyB1bmtub3duYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlzVmFsaWQod2FybmluZ1ByZWZpeCkge1xuICAgIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0aGlzKS5ldmVyeSgocHJvcGVydHlLZXkpID0+IHtcbiAgICAgIGNvbnN0IHsgb3B0aW9uYWwgfSA9IGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0eU1ldGFkYXRhKHRoaXMsIHByb3BlcnR5S2V5KTtcbiAgICAgIGNvbnN0IHZhbGlkID0gb3B0aW9uYWwgPT09IHRydWUgfHwgdHlwZW9mIHRoaXNbcHJvcGVydHlLZXldICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYCR7d2FybmluZ1ByZWZpeCA/PyBcIlwifVske3Byb3BlcnR5S2V5fV0gaXMgcmVxdWlyZWQuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSk7XG4gIH1cbiAgdG9Kc29uKCkge1xuICAgIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0aGlzKS5yZWR1Y2UoKG9iamVjdDIsIHByb3BlcnR5S2V5KSA9PiB7XG4gICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gdGhpc1twcm9wZXJ0eUtleV07XG4gICAgICBvYmplY3QyW3Byb3BlcnR5S2V5XSA9IGlzUHJvcGVydGllcyhwcm9wZXJ0eVZhbHVlKSA/IHByb3BlcnR5VmFsdWUudG9Kc29uKCkgOiBwcm9wZXJ0eVZhbHVlO1xuICAgICAgcmV0dXJuIG9iamVjdDI7XG4gICAgfSwge30pO1xuICB9XG59O1xudmFyIFByb3BlcnRpZXNBcnJheSA9IGNsYXNzIF9Qcm9wZXJ0aWVzQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKGl0ZW1GYWN0b3J5LCAuLi5wcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIocHJvcGVydGllcy5sZW5ndGgpO1xuICAgIGNvbnN0IGlzQ29uc3RydWN0b3IgPSAodmFsdWUyKSA9PiBCb29sZWFuKHZhbHVlMj8ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvcj8ubmFtZSk7XG4gICAgY29uc3QgdmFsdWUgPSBpc0NvbnN0cnVjdG9yKGl0ZW1GYWN0b3J5KSA/IChwYXJhbXMpID0+IG5ldyBpdGVtRmFjdG9yeSgpLnNldChwYXJhbXMpIDogaXRlbUZhY3Rvcnk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXRlbUZhY3RvcnlcIiwgeyB2YWx1ZSwgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UgfSk7XG4gICAgdGhpcy5zZXQocHJvcGVydGllcyk7XG4gIH1cbiAgc2V0KHByb3BlcnRpZXMpIHtcbiAgICBpZiAoaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldID0gdGhpcy5pdGVtRmFjdG9yeShwcm9wZXJ0aWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXQocHJvcGVydGllcykge1xuICAgIHJldHVybiBuZXcgX1Byb3BlcnRpZXNBcnJheSh0aGlzLml0ZW1GYWN0b3J5LCAuLi5wcm9wZXJ0aWVzKTtcbiAgfVxuICB0b0pzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKCh2YWx1ZSkgPT4gdmFsdWU/LnRvSnNvbj8uKCkgPz8gdmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gaXNQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEJhc2VQcm9wZXJ0aWVzIHx8IHZhbHVlIGluc3RhbmNlb2YgUHJvcGVydGllc0FycmF5O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2pzb24udHNcbnZhciBDTEFTU19JTlNUQU5DRV9UWVBFID0gXCJjbGFzcy1pbnN0YW5jZVwiO1xuZnVuY3Rpb24ganNvbkRpZmYoc291cmNlLCB0YXJnZXQsIHNraXApIHtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGlmICghaXNBcnJheShzb3VyY2UpIHx8IHNvdXJjZS5sZW5ndGggIT09IHRhcmdldC5sZW5ndGggfHwgdGFyZ2V0LnNvbWUoKHYsIGkpID0+IGpzb25EaWZmKHNvdXJjZVtpXSwgdikgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBhbGxLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgLi4uT2JqZWN0LmtleXMoc291cmNlKSxcbiAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldClcbiAgICBdKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgICBpZiAoc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldIHx8IHNraXA/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVtrZXldID09PSB0eXBlb2YgdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgY29uc3QgZGlmZjIgPSBqc29uRGlmZihzb3VyY2Vba2V5XSwgdGFyZ2V0W2tleV0pO1xuICAgICAgICBpZiAoZGlmZjIgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGRpZmYyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICB9IGVsc2UgaWYgKHNvdXJjZSAhPT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKChpdGVtKSA9PiBkZWVwQ2xvbmUoaXRlbSwgb3B0aW9ucykpO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbWFwVmFsdWVzKFxuICAgICAgc291cmNlLFxuICAgICAgKHZhbHVlLCBrZXkpID0+IG9wdGlvbnM/LnNoYWxsb3c/LmluY2x1ZGVzKGtleSkgPyBzaGFsbG93Q2xvbmUodmFsdWUpIDogZGVlcENsb25lKHZhbHVlLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNoYWxsb3dDbG9uZShzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKHNvdXJjZSkge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIFsuLi5zb3VyY2VdO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICByZXR1cm4geyAuLi5zb3VyY2UgfTtcbiAgfVxuICBpZiAoaXNEYXRlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc291cmNlKTtcbiAgfVxuICBpZiAoaXNSZWdFeHAoc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZS5zb3VyY2UsIHNvdXJjZS5mbGFncyk7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGpzb25XYWxrKGpzb24sIHZpc2l0LCBvcHRzLCAuLi5qc29ucykge1xuICBpZiAoaXNBcnJheShqc29uKSkge1xuICAgIHZpc2l0KGpzb24sIC4uLmpzb25zKTtcbiAgICBqc29uLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBqc29uV2Fsayhub2RlLCB2aXNpdCwgb3B0cywgLi4ua2V5TWFwcGVyKGpzb25zLCBpbmRleCkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoanNvbikpIHtcbiAgICB2aXNpdChqc29uLCAuLi5qc29ucyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoanNvbikpIHtcbiAgICAgIGlmIChvcHRzPy5za2lwPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBqc29uW2tleV07XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAganNvbldhbGsodmFsdWUsIHZpc2l0LCBvcHRzLCAuLi5rZXlNYXBwZXIoanNvbnMsIGtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24ganNvbkFwcGx5KHRhcmdldCwgc291cmNlLCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCB7IHBhdGgsIG1hdGNoZXJQYXRoID0gcGF0aD8ucmVwbGFjZSgvKFxcW1swLTkrXStdKS9pLCBcIltdXCIpLCBza2lwID0gW10gfSA9IHBhcmFtcztcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB0YXJnZXQgaXMgdW5pbml0aWFsaXNlZDogJHtwYXRoID8/IFwiPHJvb3Q+XCJ9YCk7XG4gIH1cbiAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNQcm9wZXJ0aWVzKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnNldChzb3VyY2UpO1xuICB9XG4gIGNvbnN0IHRhcmdldEFueSA9IHRhcmdldDtcbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGNsYXNzaWZ5KHRhcmdldCk7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgaWYgKFNLSVBfSlNfQlVJTFRJTlMuaGFzKHByb3BlcnR5KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHByb3BlcnR5TWF0Y2hlclBhdGggPSBgJHttYXRjaGVyUGF0aCA/IG1hdGNoZXJQYXRoICsgXCIuXCIgOiBcIlwifSR7cHJvcGVydHl9YDtcbiAgICBpZiAoc2tpcC5pbmNsdWRlcyhwcm9wZXJ0eU1hdGNoZXJQYXRoKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICBjb25zdCBwcm9wZXJ0eVBhdGggPSBgJHtwYXRoID8gcGF0aCArIFwiLlwiIDogXCJcIn0ke3Byb3BlcnR5fWA7XG4gICAgY29uc3QgdGFyZ2V0Q2xhc3MgPSB0YXJnZXRBbnkuY29uc3RydWN0b3I7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0QW55W3Byb3BlcnR5XTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlVHlwZSA9IGNsYXNzaWZ5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICBjb25zdCBuZXdWYWx1ZVR5cGUgPSBjbGFzc2lmeShuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gQ0xBU1NfSU5TVEFOQ0VfVFlQRSAmJiAhKHByb3BlcnR5IGluIHRhcmdldCkpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gJHt0YXJnZXRDbGFzcz8ubmFtZX0gLSBwcm9wZXJ0eSBpcyB1bmtub3duYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZVR5cGUgIT0gbnVsbCAmJiBuZXdWYWx1ZVR5cGUgIT0gbnVsbCAmJiBuZXdWYWx1ZVR5cGUgIT09IGN1cnJlbnRWYWx1ZVR5cGUgJiYgKGN1cnJlbnRWYWx1ZVR5cGUgIT09IENMQVNTX0lOU1RBTkNFX1RZUEUgfHwgbmV3VmFsdWVUeXBlICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICBMb2dnZXIud2FybihcbiAgICAgICAgICBgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiAke3RhcmdldENsYXNzPy5uYW1lfSAtIGNhbid0IGFwcGx5IHR5cGUgb2YgWyR7bmV3VmFsdWVUeXBlfV0sIGFsbG93ZWQgdHlwZXMgYXJlOiBbJHtjdXJyZW50VmFsdWVUeXBlfV1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvcGVydGllcyhjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0uc2V0KG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWVUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBqc29uQXBwbHkoY3VycmVudFZhbHVlID8/IHRhcmdldEFueVtwcm9wZXJ0eV0sIG5ld1ZhbHVlLCB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIHBhdGg6IHByb3BlcnR5UGF0aCxcbiAgICAgICAgICBtYXRjaGVyUGF0aDogcHJvcGVydHlNYXRjaGVyUGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gWyR7dGFyZ2V0Q2xhc3M/Lm5hbWV9XTsgbmVzdGVkIGVycm9yIGlzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBrZXlNYXBwZXIoZGF0YSwga2V5KSB7XG4gIHJldHVybiBkYXRhLm1hcCgoZGF0YU9iamVjdCkgPT4gZGF0YU9iamVjdD8uW2tleV0pO1xufVxuZnVuY3Rpb24gY2xhc3NpZnkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNIdG1sRWxlbWVudCh2YWx1ZSkgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgIHJldHVybiBcInByaW1pdGl2ZVwiO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBcImFycmF5XCI7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IFwib2JqZWN0XCIgOiBDTEFTU19JTlNUQU5DRV9UWVBFO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gIH1cbiAgcmV0dXJuIFwicHJpbWl0aXZlXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9lYXNpbmcudHNcbnZhciBlYXNpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWFzaW5nX2V4cG9ydHMsIHtcbiAgZWFzZUluOiAoKSA9PiBlYXNlSW4sXG4gIGVhc2VJbk91dDogKCkgPT4gZWFzZUluT3V0LFxuICBlYXNlSW5PdXRRdWFkOiAoKSA9PiBlYXNlSW5PdXRRdWFkLFxuICBlYXNlSW5RdWFkOiAoKSA9PiBlYXNlSW5RdWFkLFxuICBlYXNlT3V0OiAoKSA9PiBlYXNlT3V0LFxuICBlYXNlT3V0UXVhZDogKCkgPT4gZWFzZU91dFF1YWQsXG4gIGludmVyc2VFYXNlT3V0OiAoKSA9PiBpbnZlcnNlRWFzZU91dCxcbiAgbGluZWFyOiAoKSA9PiBsaW5lYXJcbn0pO1xudmFyIGxpbmVhciA9IChuKSA9PiBuO1xudmFyIGVhc2VJbiA9IChuKSA9PiAxIC0gTWF0aC5jb3MobiAqIE1hdGguUEkgLyAyKTtcbnZhciBlYXNlT3V0ID0gKG4pID0+IE1hdGguc2luKG4gKiBNYXRoLlBJIC8gMik7XG52YXIgZWFzZUluT3V0ID0gKG4pID0+IC0oTWF0aC5jb3MobiAqIE1hdGguUEkpIC0gMSkgLyAyO1xudmFyIGVhc2VJblF1YWQgPSAobikgPT4gbiAqIG47XG52YXIgZWFzZU91dFF1YWQgPSAobikgPT4gMSAtICgxIC0gbikgKiogMjtcbnZhciBlYXNlSW5PdXRRdWFkID0gKG4pID0+IG4gPCAwLjUgPyAyICogbiAqIG4gOiAxIC0gKC0yICogbiArIDIpICoqIDIgLyAyO1xudmFyIGludmVyc2VFYXNlT3V0ID0gKHgpID0+IDIgKiBNYXRoLmFzaW4oeCkgLyBNYXRoLlBJO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vYW5pbWF0aW9uLnRzXG52YXIgUVVJQ0tfVFJBTlNJVElPTiA9IDAuMjtcbnZhciBQSEFTRV9PUkRFUiA9IFtcImluaXRpYWxcIiwgXCJyZW1vdmVcIiwgXCJ1cGRhdGVcIiwgXCJhZGRcIiwgXCJ0cmFpbGluZ1wiLCBcImVuZFwiLCBcIm5vbmVcIl07XG52YXIgUEhBU0VfTUVUQURBVEEgPSB7XG4gIGluaXRpYWw6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMSxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9LFxuICBhZGQ6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC4yNSxcbiAgICBhbmltYXRpb25EZWxheTogMC43NVxuICB9LFxuICByZW1vdmU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC4yNSxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9LFxuICB1cGRhdGU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC41LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwLjI1XG4gIH0sXG4gIHRyYWlsaW5nOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IFFVSUNLX1RSQU5TSVRJT04sXG4gICAgYW5pbWF0aW9uRGVsYXk6IDEsXG4gICAgc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9uczogdHJ1ZVxuICB9LFxuICBlbmQ6IHtcbiAgICBhbmltYXRpb25EZWxheTogMSArIFFVSUNLX1RSQU5TSVRJT04sXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAsXG4gICAgc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9uczogdHJ1ZVxuICB9LFxuICBub25lOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDBcbiAgfVxufTtcbnZhciBSZXBlYXRUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVwZWF0VHlwZTIpID0+IHtcbiAgUmVwZWF0VHlwZTJbXCJMb29wXCJdID0gXCJsb29wXCI7XG4gIFJlcGVhdFR5cGUyW1wiUmV2ZXJzZVwiXSA9IFwicmV2ZXJzZVwiO1xuICByZXR1cm4gUmVwZWF0VHlwZTI7XG59KShSZXBlYXRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzTm9kZUFycmF5KGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkyLmV2ZXJ5KChuKSA9PiBuIGluc3RhbmNlb2YgTm9kZSk7XG59XG5mdW5jdGlvbiBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKSB7XG4gIHJldHVybiBpc05vZGVBcnJheShzZWxlY3Rpb25zT3JOb2RlcykgPyB7IG5vZGVzOiBzZWxlY3Rpb25zT3JOb2Rlcywgc2VsZWN0aW9uczogW10gfSA6IHsgbm9kZXM6IFtdLCBzZWxlY3Rpb25zOiBzZWxlY3Rpb25zT3JOb2RlcyB9O1xufVxudmFyIEFuaW1hdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZWxhcHNlZCA9IDA7XG4gICAgdGhpcy5pdGVyYXRpb24gPSAwO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1JldmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmlkID0gb3B0cy5pZDtcbiAgICB0aGlzLmdyb3VwSWQgPSBvcHRzLmdyb3VwSWQ7XG4gICAgdGhpcy5hdXRvcGxheSA9IG9wdHMuYXV0b3BsYXkgPz8gdHJ1ZTtcbiAgICB0aGlzLmVhc2UgPSBvcHRzLmVhc2UgPz8gbGluZWFyO1xuICAgIHRoaXMucGhhc2UgPSBvcHRzLnBoYXNlO1xuICAgIGNvbnN0IGR1cmF0aW9uUHJvcG9ydGlvbiA9IG9wdHMuZHVyYXRpb24gPz8gUEhBU0VfTUVUQURBVEFbdGhpcy5waGFzZV0uYW5pbWF0aW9uRHVyYXRpb247XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uUHJvcG9ydGlvbiAqIG9wdHMuZGVmYXVsdER1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXkgPSAob3B0cy5kZWxheSA/PyAwKSAqIG9wdHMuZGVmYXVsdER1cmF0aW9uO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9wdHMub25Db21wbGV0ZTtcbiAgICB0aGlzLm9uUGxheSA9IG9wdHMub25QbGF5O1xuICAgIHRoaXMub25TdG9wID0gb3B0cy5vblN0b3A7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG9wdHMub25VcGRhdGU7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZSA9IHRoaXMuY3JlYXRlSW50ZXJwb2xhdG9yKG9wdHMuZnJvbSwgb3B0cy50byk7XG4gICAgdGhpcy5mcm9tID0gb3B0cy5mcm9tO1xuICAgIGlmIChvcHRzLnNraXAgPT09IHRydWUpIHtcbiAgICAgIHRoaXMub25VcGRhdGU/LihvcHRzLnRvLCBmYWxzZSwgdGhpcyk7XG4gICAgICB0aGlzLm9uU3RvcD8uKHRoaXMpO1xuICAgICAgdGhpcy5vbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jb2xsYXBzYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmNoZWNrQ29sbGFwc2Uob3B0cywgdGhpcy5kdXJhdGlvbik7XG4gICAgfVxuICB9XG4gIGNoZWNrQ29sbGFwc2Uob3B0cywgY2FsY3VsYXRlZER1cmF0aW9uKSB7XG4gICAgaWYgKG9wdHMuZnJvbSA9PT0gb3B0cy50bylcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IGRpZmYyID0gdHlwZW9mIG9wdHMuZnJvbSA9PT0gXCJvYmplY3RcIiA/IGpzb25EaWZmKG9wdHMuZnJvbSwgb3B0cy50bykgOiBudWxsO1xuICAgIGlmIChkaWZmMikge1xuICAgICAgcmV0dXJuIGNhbGN1bGF0ZWREdXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcGxheShpbml0aWFsVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcgfHwgdGhpcy5pc0NvbXBsZXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLm9uUGxheT8uKHRoaXMpO1xuICAgIGlmICghdGhpcy5hdXRvcGxheSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgaWYgKCFpbml0aWFsVXBkYXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMub25VcGRhdGU/Lih0aGlzLmZyb20sIHRydWUsIHRoaXMpO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5vblN0b3A/Lih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHRpbWUyKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybiB0aW1lMjtcbiAgICBpZiAoIXRoaXMuaXNQbGF5aW5nICYmIHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgIHRoaXMucGxheSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNFbGFwc2VkID0gdGhpcy5lbGFwc2VkO1xuICAgIHRoaXMuZWxhcHNlZCArPSB0aW1lMjtcbiAgICBpZiAodGhpcy5kZWxheSA+IHRoaXMuZWxhcHNlZClcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZSh0aGlzLmlzUmV2ZXJzZSA/IDEgLSB0aGlzLmRlbHRhIDogdGhpcy5kZWx0YSk7XG4gICAgdGhpcy5vblVwZGF0ZT8uKHZhbHVlLCBmYWxzZSwgdGhpcyk7XG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uO1xuICAgIGlmICh0aGlzLmVsYXBzZWQgPj0gdG90YWxEdXJhdGlvbikge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5vbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICByZXR1cm4gdGltZTIgLSAodG90YWxEdXJhdGlvbiAtIHByZXZpb3VzRWxhcHNlZCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBkZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5lYXNlKGNsYW1wKDAsICh0aGlzLmVsYXBzZWQgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24sIDEpKTtcbiAgfVxuICBjcmVhdGVJbnRlcnBvbGF0b3IoZnJvbTIsIHRvKSB7XG4gICAgaWYgKHR5cGVvZiB0byAhPT0gXCJvYmplY3RcIiB8fCBpc0ludGVycG9sYXRpbmcodG8pKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyb20yLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGludGVycG9sYXRvckVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0bykge1xuICAgICAgY29uc3QgaW50ZXJwb2xhdG9yID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyb20yW2tleV0sIHRvW2tleV0pO1xuICAgICAgaWYgKGludGVycG9sYXRvciAhPSBudWxsKSB7XG4gICAgICAgIGludGVycG9sYXRvckVudHJpZXMucHVzaChba2V5LCBpbnRlcnBvbGF0b3JdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChkKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgaW50ZXJwb2xhdG9yXSBvZiBpbnRlcnBvbGF0b3JFbnRyaWVzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gaW50ZXJwb2xhdG9yKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGludGVycG9sYXRlVmFsdWUoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDAgfHwgYiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0ludGVycG9sYXRpbmcoYSkpIHtcbiAgICAgIHJldHVybiAoZCkgPT4gYVtpbnRlcnBvbGF0ZV0oYiwgZCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVOdW1iZXIoYSwgYik7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcihhLCBiKTtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW50ZXJwb2xhdGUgdmFsdWVzOiAke2F9LCAke2J9YCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9mcm9tVG9Nb3Rpb24udHNcbnZhciBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HID0ge1xuICBhZGRlZDogXCJhZGRcIixcbiAgdXBkYXRlZDogXCJ1cGRhdGVcIixcbiAgcmVtb3ZlZDogXCJyZW1vdmVcIixcbiAgdW5rbm93bjogXCJpbml0aWFsXCIsXG4gIFwibm8tb3BcIjogXCJub25lXCJcbn07XG5mdW5jdGlvbiBmcm9tVG9Nb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbnNPck5vZGVzLCBmbnMsIGdldERhdHVtSWQsIGRpZmYyKSB7XG4gIGNvbnN0IHsgZnJvbUZuLCB0b0ZuLCBpbnRlcm1lZGlhdGVGbiB9ID0gZm5zO1xuICBjb25zdCB7IG5vZGVzLCBzZWxlY3Rpb25zIH0gPSBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKTtcbiAgY29uc3QgcHJvY2Vzc05vZGVzID0gKGxpdmVOb2Rlcywgc3ViTm9kZXMpID0+IHtcbiAgICBsZXQgcHJldkZyb21Qcm9wcztcbiAgICBsZXQgbGl2ZU5vZGVJbmRleCA9IDA7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHN1Yk5vZGVzKSB7XG4gICAgICBjb25zdCBpc0xpdmUgPSBsaXZlTm9kZXNbbGl2ZU5vZGVJbmRleF0gPT09IG5vZGU7XG4gICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIGxhc3Q6IG5vZGVJbmRleCA+PSBzdWJOb2Rlcy5sZW5ndGggLSAxLFxuICAgICAgICBsYXN0TGl2ZTogbGl2ZU5vZGVJbmRleCA+PSBsaXZlTm9kZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgcHJldjogc3ViTm9kZXNbbm9kZUluZGV4IC0gMV0sXG4gICAgICAgIHByZXZGcm9tUHJvcHMsXG4gICAgICAgIHByZXZMaXZlOiBsaXZlTm9kZXNbbGl2ZU5vZGVJbmRleCAtIDFdLFxuICAgICAgICBuZXh0OiBzdWJOb2Rlc1tub2RlSW5kZXggKyAxXSxcbiAgICAgICAgbmV4dExpdmU6IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4ICsgKGlzTGl2ZSA/IDEgOiAwKV1cbiAgICAgIH07XG4gICAgICBjb25zdCBhbmltYXRpb25JZCA9IGAke2dyb3VwSWR9XyR7c3ViSWR9XyR7bm9kZS5pZH1gO1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25JZChhbmltYXRpb25JZCk7XG4gICAgICBsZXQgc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICBpZiAoIWlzTGl2ZSkge1xuICAgICAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0RGF0dW1JZCAmJiBkaWZmMikge1xuICAgICAgICBzdGF0dXMgPSBjYWxjdWxhdGVTdGF0dXMobm9kZSwgbm9kZS5kYXR1bSwgZ2V0RGF0dW1JZCwgZGlmZjIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBwaGFzZSwgc3RhcnQsIGZpbmlzaCwgZGVsYXksIGR1cmF0aW9uLCAuLi5mcm9tMiB9ID0gZnJvbUZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGhhc2U6IHRvUGhhc2UsXG4gICAgICAgIHN0YXJ0OiB0b1N0YXJ0LFxuICAgICAgICBmaW5pc2g6IHRvRmluaXNoLFxuICAgICAgICBkZWxheTogdG9EZWxheSxcbiAgICAgICAgZHVyYXRpb246IHRvRHVyYXRpb24sXG4gICAgICAgIC4uLnRvXG4gICAgICB9ID0gdG9Gbihub2RlLCBub2RlLmRhdHVtLCBzdGF0dXMsIGN0eCk7XG4gICAgICBjb25zdCBjb2xsYXBzYWJsZSA9IGZpbmlzaCA9PSBudWxsICYmIHRvRmluaXNoID09IG51bGw7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgICBpZDogYW5pbWF0aW9uSWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIHBoYXNlOiBwaGFzZSA/PyB0b1BoYXNlID8/IFwidXBkYXRlXCIsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiA/PyB0b0R1cmF0aW9uLFxuICAgICAgICBkZWxheTogZGVsYXkgPz8gdG9EZWxheSxcbiAgICAgICAgZnJvbTogZnJvbTIsXG4gICAgICAgIHRvLFxuICAgICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgICBjb2xsYXBzYWJsZSxcbiAgICAgICAgb25QbGF5OiAoKSA9PiB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHsgLi4uc3RhcnQsIC4uLnRvU3RhcnQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBkYXRlKHByb3BzKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgICBpZiAoaW50ZXJtZWRpYXRlRm4pIHtcbiAgICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhpbnRlcm1lZGlhdGVGbihub2RlLCBub2RlLmRhdHVtLCBzdGF0dXMsIGN0eCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TdG9wOiAoKSA9PiB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIC4uLnN0YXJ0LFxuICAgICAgICAgICAgLi4udG9TdGFydCxcbiAgICAgICAgICAgIC4uLmZyb20yLFxuICAgICAgICAgICAgLi4udG8sXG4gICAgICAgICAgICAuLi5maW5pc2gsXG4gICAgICAgICAgICAuLi50b0ZpbmlzaFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgbGl2ZU5vZGVJbmRleCsrO1xuICAgICAgfVxuICAgICAgbm9kZUluZGV4Kys7XG4gICAgICBwcmV2RnJvbVByb3BzID0gZnJvbTI7XG4gICAgfVxuICB9O1xuICBsZXQgc2VsZWN0aW9uSW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uTm9kZXMgPSBzZWxlY3Rpb24ubm9kZXMoKTtcbiAgICBjb25zdCBsaXZlTm9kZXMgPSBzZWxlY3Rpb25Ob2Rlcy5maWx0ZXIoKG4pID0+ICFzZWxlY3Rpb24uaXNHYXJiYWdlKG4pKTtcbiAgICBwcm9jZXNzTm9kZXMobGl2ZU5vZGVzLCBzZWxlY3Rpb25Ob2Rlcyk7XG4gICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfV9zZWxlY3Rpb25fJHtzZWxlY3Rpb25JbmRleH1gLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIHBoYXNlOiBcImVuZFwiLFxuICAgICAgZnJvbTogMCxcbiAgICAgIHRvOiAxLFxuICAgICAgZWFzZTogZWFzZU91dCxcbiAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3Rpb25JbmRleCsrO1xuICB9XG4gIHByb2Nlc3NOb2Rlcyhub2Rlcywgbm9kZXMpO1xufVxuZnVuY3Rpb24gc3RhdGljRnJvbVRvTW90aW9uKGdyb3VwSWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb25zT3JOb2RlcywgZnJvbTIsIHRvLCBleHRyYU9wdHMpIHtcbiAgY29uc3QgeyBub2Rlcywgc2VsZWN0aW9ucyB9ID0gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyhzZWxlY3Rpb25zT3JOb2Rlcyk7XG4gIGNvbnN0IHsgc3RhcnQsIGZpbmlzaCwgcGhhc2UgfSA9IGV4dHJhT3B0cztcbiAgY29uc3QgY29sbGFwc2FibGUgPSBmaW5pc2ggPT0gbnVsbDtcbiAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1gLFxuICAgIGdyb3VwSWQsXG4gICAgcGhhc2U6IHBoYXNlID8/IFwidXBkYXRlXCIsXG4gICAgZnJvbTogZnJvbTIsXG4gICAgdG8sXG4gICAgZWFzZTogZWFzZU91dCxcbiAgICBjb2xsYXBzYWJsZSxcbiAgICBvblBsYXk6ICgpID0+IHtcbiAgICAgIGlmICghc3RhcnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoc3RhcnQpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcbiAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblVwZGF0ZShwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uU3RvcDogKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnRvLCAuLi5maW5pc2ggfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnRvLCAuLi5maW5pc2ggfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3RhdHVzKG5vZGUsIGRhdHVtLCBnZXREYXR1bUlkLCBkaWZmMikge1xuICBjb25zdCBpZCA9IGdldERhdHVtSWQobm9kZSwgZGF0dW0pO1xuICBpZiAoZGlmZjIuYWRkZWQuaGFzKGlkKSkge1xuICAgIHJldHVybiBcImFkZGVkXCI7XG4gIH1cbiAgaWYgKGRpZmYyLnJlbW92ZWQuaGFzKGlkKSkge1xuICAgIHJldHVybiBcInJlbW92ZWRcIjtcbiAgfVxuICByZXR1cm4gXCJ1cGRhdGVkXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZUZvcm1hdC50c1xudmFyIENPTlNUQU5UUyA9IHtcbiAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICBtb250aHM6IFtcbiAgICBcIkphbnVhcnlcIixcbiAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgXCJNYXJjaFwiLFxuICAgIFwiQXByaWxcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuZVwiLFxuICAgIFwiSnVseVwiLFxuICAgIFwiQXVndXN0XCIsXG4gICAgXCJTZXB0ZW1iZXJcIixcbiAgICBcIk9jdG9iZXJcIixcbiAgICBcIk5vdmVtYmVyXCIsXG4gICAgXCJEZWNlbWJlclwiXG4gIF0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn07XG5mdW5jdGlvbiBkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZlllYXIgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpKSB7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnRPZlllYXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgY29uc3QgdGltZURpZmYgPSBkYXRlLmdldFRpbWUoKSAtIHN0YXJ0T2ZZZWFyLmdldFRpbWUoKSArIHN0YXJ0T2Zmc2V0ICogNmU0O1xuICBjb25zdCB0aW1lT25lRGF5ID0gMzZlNSAqIDI0O1xuICByZXR1cm4gTWF0aC5mbG9vcih0aW1lRGlmZiAvIHRpbWVPbmVEYXkpO1xufVxuZnVuY3Rpb24gd2Vla09mWWVhcihkYXRlLCBzdGFydERheSkge1xuICBjb25zdCBzdGFydE9mWWVhciA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIGNvbnN0IHN0YXJ0T2ZZZWFyRGF5ID0gc3RhcnRPZlllYXIuZ2V0RGF5KCk7XG4gIGNvbnN0IGZpcnN0V2Vla1N0YXJ0T2Zmc2V0ID0gKHN0YXJ0RGF5IC0gc3RhcnRPZlllYXJEYXkgKyA3KSAlIDc7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCBmaXJzdFdlZWtTdGFydE9mZnNldCArIDEpO1xuICBpZiAoc3RhcnRPZmZzZXQgPD0gZGF0ZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheU9mWWVhcihkYXRlLCBzdGFydE9mZnNldCkgLyA3KSArIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgU1VOREFZID0gMDtcbnZhciBNT05EQVkgPSAxO1xudmFyIFRIVVJTREFZID0gNDtcbmZ1bmN0aW9uIGlzb1dlZWtPZlllYXIoZGF0ZSwgeWVhcjIgPSBkYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgY29uc3QgZmlyc3RPZlllYXIgPSBuZXcgRGF0ZSh5ZWFyMiwgMCwgMSk7XG4gIGNvbnN0IGZpcnN0T2ZZZWFyRGF5ID0gZmlyc3RPZlllYXIuZ2V0RGF5KCk7XG4gIGNvbnN0IGZpcnN0VGh1cnNkYXlPZmZzZXQgPSAoVEhVUlNEQVkgLSBmaXJzdE9mWWVhckRheSArIDcpICUgNztcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuZXcgRGF0ZSh5ZWFyMiwgMCwgZmlyc3RUaHVyc2RheU9mZnNldCAtIChUSFVSU0RBWSAtIE1PTkRBWSkgKyAxKTtcbiAgaWYgKHN0YXJ0T2Zmc2V0IDw9IGRhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZmZzZXQpIC8gNykgKyAxO1xuICB9XG4gIHJldHVybiBpc29XZWVrT2ZZZWFyKGRhdGUsIHllYXIyIC0gMSk7XG59XG5mdW5jdGlvbiB0aW1lem9uZShkYXRlKSB7XG4gIGNvbnN0IG9mZnNldDQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGNvbnN0IHVuc2lnbmVkT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0NCk7XG4gIGNvbnN0IHNpZ24gPSBvZmZzZXQ0ID4gMCA/IFwiLVwiIDogXCIrXCI7XG4gIHJldHVybiBgJHtzaWdufSR7cGFkKE1hdGguZmxvb3IodW5zaWduZWRPZmZzZXQgLyA2MCksIDIsIFwiMFwiKX0ke3BhZChNYXRoLmZsb29yKHVuc2lnbmVkT2Zmc2V0ICUgNjApLCAyLCBcIjBcIil9YDtcbn1cbnZhciBGT1JNQVRURVJTID0ge1xuICBhOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0RGF5c1tkLmdldERheSgpXSxcbiAgQTogKGQpID0+IENPTlNUQU5UUy5kYXlzW2QuZ2V0RGF5KCldLFxuICBiOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0TW9udGhzW2QuZ2V0TW9udGgoKV0sXG4gIEI6IChkKSA9PiBDT05TVEFOVFMubW9udGhzW2QuZ2V0TW9udGgoKV0sXG4gIGM6IFwiJXgsICVYXCIsXG4gIGQ6IChkLCBwKSA9PiBwYWQoZC5nZXREYXRlKCksIDIsIHAgPz8gXCIwXCIpLFxuICBlOiBcIiVfZFwiLFxuICBmOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxZTMsIDYsIHAgPz8gXCIwXCIpLFxuICBIOiAoZCwgcCkgPT4gcGFkKGQuZ2V0SG91cnMoKSwgMiwgcCA/PyBcIjBcIiksXG4gIEk6IChkLCBwKSA9PiB7XG4gICAgY29uc3QgaG91cnMgPSBkLmdldEhvdXJzKCkgJSAxMjtcbiAgICByZXR1cm4gaG91cnMgPT09IDAgPyBcIjEyXCIgOiBwYWQoaG91cnMsIDIsIHAgPz8gXCIwXCIpO1xuICB9LFxuICBqOiAoZCwgcCkgPT4gcGFkKGRheU9mWWVhcihkKSArIDEsIDMsIHAgPz8gXCIwXCIpLFxuICBtOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIDIsIHAgPz8gXCIwXCIpLFxuICBNOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWludXRlcygpLCAyLCBwID8/IFwiMFwiKSxcbiAgTDogKGQsIHApID0+IHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCAzLCBwID8/IFwiMFwiKSxcbiAgcDogKGQpID0+IGQuZ2V0SG91cnMoKSA8IDEyID8gXCJBTVwiIDogXCJQTVwiLFxuICBROiAoZCkgPT4gU3RyaW5nKGQuZ2V0VGltZSgpKSxcbiAgczogKGQpID0+IFN0cmluZyhNYXRoLmZsb29yKGQuZ2V0VGltZSgpIC8gMWUzKSksXG4gIFM6IChkLCBwKSA9PiBwYWQoZC5nZXRTZWNvbmRzKCksIDIsIHAgPz8gXCIwXCIpLFxuICB1OiAoZCkgPT4ge1xuICAgIGxldCBkYXkyID0gZC5nZXREYXkoKTtcbiAgICBpZiAoZGF5MiA8IDEpXG4gICAgICBkYXkyICs9IDc7XG4gICAgcmV0dXJuIFN0cmluZyhkYXkyICUgNyk7XG4gIH0sXG4gIFU6IChkLCBwKSA9PiBwYWQod2Vla09mWWVhcihkLCBTVU5EQVkpLCAyLCBwID8/IFwiMFwiKSxcbiAgVjogKGQsIHApID0+IHBhZChpc29XZWVrT2ZZZWFyKGQpLCAyLCBwID8/IFwiMFwiKSxcbiAgdzogKGQsIHApID0+IHBhZChkLmdldERheSgpLCAyLCBwID8/IFwiMFwiKSxcbiAgVzogKGQsIHApID0+IHBhZCh3ZWVrT2ZZZWFyKGQsIE1PTkRBWSksIDIsIHAgPz8gXCIwXCIpLFxuICB4OiBcIiUtbS8lLWQvJVlcIixcbiAgWDogXCIlLUk6JU06JVMgJXBcIixcbiAgeTogKGQsIHApID0+IHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIDIsIHAgPz8gXCIwXCIpLFxuICBZOiAoZCwgcCkgPT4gcGFkKGQuZ2V0RnVsbFllYXIoKSwgNCwgcCA/PyBcIjBcIiksXG4gIFo6IChkKSA9PiB0aW1lem9uZShkKSxcbiAgXCIlXCI6ICgpID0+IFwiJVwiXG59O1xudmFyIFBBRFMgPSB7XG4gIF86IFwiIFwiLFxuICBcIjBcIjogXCIwXCIsXG4gIFwiLVwiOiBcIlwiXG59O1xuZnVuY3Rpb24gcGFkKHZhbHVlLCBzaXplLCBwYWRDaGFyKSB7XG4gIGNvbnN0IG91dHB1dCA9IFN0cmluZyhNYXRoLmZsb29yKHZhbHVlKSk7XG4gIGlmIChvdXRwdXQubGVuZ3RoID49IHNpemUpIHtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBgJHtwYWRDaGFyLnJlcGVhdChzaXplIC0gb3V0cHV0Lmxlbmd0aCl9JHtvdXRwdXR9YDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cmluZykge1xuICBjb25zdCBmb3JtYXRQYXJ0cyA9IFtdO1xuICB3aGlsZSAoZm9ybWF0U3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgbmV4dEVzY2FwZUlkeCA9IGZvcm1hdFN0cmluZy5pbmRleE9mKFwiJVwiKTtcbiAgICBpZiAobmV4dEVzY2FwZUlkeCAhPT0gMCkge1xuICAgICAgY29uc3QgbGl0ZXJhbFBhcnQgPSBuZXh0RXNjYXBlSWR4ID4gMCA/IGZvcm1hdFN0cmluZy5zdWJzdHJpbmcoMCwgbmV4dEVzY2FwZUlkeCkgOiBmb3JtYXRTdHJpbmc7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKGxpdGVyYWxQYXJ0KTtcbiAgICB9XG4gICAgaWYgKG5leHRFc2NhcGVJZHggPCAwKVxuICAgICAgYnJlYWs7XG4gICAgY29uc3QgbWF5YmVQYWRTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xuICAgIGNvbnN0IG1heWJlUGFkID0gUEFEU1ttYXliZVBhZFNwZWNpZmllcl07XG4gICAgaWYgKG1heWJlUGFkICE9IG51bGwpIHtcbiAgICAgIG5leHRFc2NhcGVJZHgrKztcbiAgICB9XG4gICAgY29uc3QgbWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xuICAgIGNvbnN0IG1heWJlRm9ybWF0dGVyID0gRk9STUFUVEVSU1ttYXliZUZvcm1hdHRlclNwZWNpZmllcl07XG4gICAgaWYgKHR5cGVvZiBtYXliZUZvcm1hdHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKFttYXliZUZvcm1hdHRlciwgbWF5YmVQYWRdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXliZUZvcm1hdHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIobWF5YmVGb3JtYXR0ZXIpO1xuICAgICAgZm9ybWF0UGFydHMucHVzaChbZm9ybWF0dGVyLCBtYXliZVBhZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKGAke21heWJlUGFkID8/IFwiXCJ9JHttYXliZUZvcm1hdHRlclNwZWNpZmllcn1gKTtcbiAgICB9XG4gICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnN1YnN0cmluZyhuZXh0RXNjYXBlSWR4ICsgMik7XG4gIH1cbiAgcmV0dXJuIChkYXRlVGltZSkgPT4ge1xuICAgIGNvbnN0IGRhdGVUaW1lQXNEYXRlID0gdHlwZW9mIGRhdGVUaW1lID09PSBcIm51bWJlclwiID8gbmV3IERhdGUoZGF0ZVRpbWUpIDogZGF0ZVRpbWU7XG4gICAgcmV0dXJuIGZvcm1hdFBhcnRzLm1hcCgoYykgPT4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyBjIDogY1swXShkYXRlVGltZUFzRGF0ZSwgY1sxXSkpLmpvaW4oXCJcIik7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZUZvcm1hdERlZmF1bHRzLnRzXG5mdW5jdGlvbiBkYXRlVG9OdW1iZXIoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIERhdGUgPyB4LmdldFRpbWUoKSA6IHg7XG59XG5mdW5jdGlvbiBkZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0KSB7XG4gIGNvbnN0IGZvcm1hdFN0cmluZyA9IGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQpO1xuICBjb25zdCBmb3JtYXR0ZXIgPSBidWlsZEZvcm1hdHRlcihmb3JtYXRTdHJpbmcpO1xuICByZXR1cm4gKGRhdGUpID0+IGZvcm1hdHRlcihkYXRlKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcyA9IFtdLCBkb21haW4gPSB0aWNrcywgZm9ybWF0T2Zmc2V0ID0gMCkge1xuICBsZXQgbWluSW50ZXJ2YWwgPSBJbmZpbml0eTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIG1pbkludGVydmFsID0gTWF0aC5taW4obWluSW50ZXJ2YWwsIE1hdGguYWJzKHRpY2tzW2ldIC0gdGlja3NbaSAtIDFdKSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRZZWFyID0gbmV3IERhdGUoZG9tYWluWzBdKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBzdG9wWWVhciA9IG5ldyBEYXRlKGRvbWFpbi5hdCgtMSkpLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IHllYXJDaGFuZ2UgPSBzdG9wWWVhciAtIHN0YXJ0WWVhciA+IDA7XG4gIGNvbnN0IHRpbWVGb3JtYXQgPSBpc0Zpbml0ZShtaW5JbnRlcnZhbCkgPyBnZXRJbnRlcnZhbExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KG1pbkludGVydmFsLCB0aWNrcykgOiBnZXRMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh0aWNrc1swXSk7XG4gIHJldHVybiBmb3JtYXRTdHJpbmdCdWlsZGVyKE1hdGgubWF4KHRpbWVGb3JtYXQgLSBmb3JtYXRPZmZzZXQsIDApLCB5ZWFyQ2hhbmdlLCB0aWNrcyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcnZhbExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KHZhbHVlLCB0aWNrcykge1xuICBpZiAodmFsdWUgPCBkdXJhdGlvblNlY29uZCkge1xuICAgIHJldHVybiAwIC8qIE1JTExJU0VDT05EICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25NaW51dGUpIHtcbiAgICByZXR1cm4gMSAvKiBTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbkhvdXIpIHtcbiAgICByZXR1cm4gMiAvKiBNSU5VVEUgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbkRheSkge1xuICAgIHJldHVybiAzIC8qIEhPVVIgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbldlZWspIHtcbiAgICByZXR1cm4gNCAvKiBXRUVLX0RBWSAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uRGF5ICogMjggfHwgdmFsdWUgPCBkdXJhdGlvbkRheSAqIDMxICYmIGhhc0R1cGxpY2F0ZU1vbnRoKHRpY2tzKSkge1xuICAgIHJldHVybiA1IC8qIFNIT1JUX01PTlRIICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25ZZWFyKSB7XG4gICAgcmV0dXJuIDYgLyogTU9OVEggKi87XG4gIH1cbiAgcmV0dXJuIDcgLyogWUVBUiAqLztcbn1cbmZ1bmN0aW9uIGdldExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KHZhbHVlKSB7XG4gIGlmIChzZWNvbmRfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiAwIC8qIE1JTExJU0VDT05EICovO1xuICB9IGVsc2UgaWYgKG1pbnV0ZV9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDEgLyogU0VDT05EICovO1xuICB9IGVsc2UgaWYgKGhvdXJfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiAyIC8qIE1JTlVURSAqLztcbiAgfSBlbHNlIGlmIChkYXlfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiAzIC8qIEhPVVIgKi87XG4gIH0gZWxzZSBpZiAobW9udGhfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIGlmICh3ZWVrX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICAgIHJldHVybiA0IC8qIFdFRUtfREFZICovO1xuICAgIH1cbiAgICByZXR1cm4gNSAvKiBTSE9SVF9NT05USCAqLztcbiAgfSBlbHNlIGlmICh5ZWFyX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gNiAvKiBNT05USCAqLztcbiAgfVxuICByZXR1cm4gNyAvKiBZRUFSICovO1xufVxuZnVuY3Rpb24gaGFzRHVwbGljYXRlTW9udGgodGlja3MpIHtcbiAgbGV0IHByZXZNb250aCA9IG5ldyBEYXRlKHRpY2tzWzBdKS5nZXRNb250aCgpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGlja01vbnRoID0gbmV3IERhdGUodGlja3NbaV0pLmdldE1vbnRoKCk7XG4gICAgaWYgKHByZXZNb250aCA9PT0gdGlja01vbnRoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcHJldk1vbnRoID0gdGlja01vbnRoO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ0J1aWxkZXIoZGVmYXVsdFRpbWVGb3JtYXQsIHllYXJDaGFuZ2UsIHRpY2tzKSB7XG4gIGNvbnN0IGZpcnN0VGljayA9IGRhdGVUb051bWJlcih0aWNrc1swXSk7XG4gIGNvbnN0IGxhc3RUaWNrID0gZGF0ZVRvTnVtYmVyKHRpY2tzLmF0KC0xKSk7XG4gIGNvbnN0IGV4dGVudDIgPSBNYXRoLmFicyhsYXN0VGljayAtIGZpcnN0VGljayk7XG4gIGNvbnN0IGFjdGl2ZVllYXIgPSB5ZWFyQ2hhbmdlIHx8IGRlZmF1bHRUaW1lRm9ybWF0ID09PSA3IC8qIFlFQVIgKi87XG4gIGNvbnN0IGFjdGl2ZURhdGUgPSBleHRlbnQyID09PSAwO1xuICBjb25zdCBwYXJ0cyA9IFtcbiAgICBbXCJob3VyXCIsIDYgKiBkdXJhdGlvbkhvdXIsIDE0ICogZHVyYXRpb25EYXksIDMgLyogSE9VUiAqLywgXCIlSSAlcFwiXSxcbiAgICBbXCJob3VyXCIsIGR1cmF0aW9uTWludXRlLCA2ICogZHVyYXRpb25Ib3VyLCAzIC8qIEhPVVIgKi8sIFwiJUk6JU1cIl0sXG4gICAgW1wic2Vjb25kXCIsIDFlMywgNiAqIGR1cmF0aW9uSG91ciwgMSAvKiBTRUNPTkQgKi8sIFwiOiVTXCJdLFxuICAgIFtcIm1zXCIsIDAsIDYgKiBkdXJhdGlvbkhvdXIsIDAgLyogTUlMTElTRUNPTkQgKi8sIFwiLiVMXCJdLFxuICAgIFtcImFtL3BtXCIsIGR1cmF0aW9uTWludXRlLCA2ICogZHVyYXRpb25Ib3VyLCAzIC8qIEhPVVIgKi8sIFwiJXBcIl0sXG4gICAgXCIgXCIsXG4gICAgW1wiZGF5XCIsIGR1cmF0aW9uRGF5LCBkdXJhdGlvbldlZWssIDQgLyogV0VFS19EQVkgKi8sIFwiJWFcIl0sXG4gICAgW1wibW9udGhcIiwgYWN0aXZlRGF0ZSA/IDAgOiBkdXJhdGlvbldlZWssIDUyICogZHVyYXRpb25XZWVrLCA1IC8qIFNIT1JUX01PTlRIICovLCBcIiViICVkXCJdLFxuICAgIFtcIm1vbnRoXCIsIDUgKiBkdXJhdGlvbldlZWssIDEwICogZHVyYXRpb25ZZWFyLCA2IC8qIE1PTlRIICovLCBcIiVCXCJdLFxuICAgIFwiIFwiLFxuICAgIFtcInllYXJcIiwgYWN0aXZlWWVhciA/IDAgOiBkdXJhdGlvblllYXIsIEluZmluaXR5LCA3IC8qIFlFQVIgKi8sIFwiJVlcIl1cbiAgXTtcbiAgY29uc3QgZm9ybWF0UGFydHMgPSBwYXJ0cy5maWx0ZXIoKHYpID0+IHtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBbXywgbWluLCBtYXgsIGZvcm1hdF0gPSB2O1xuICAgIHJldHVybiBmb3JtYXQgPj0gZGVmYXVsdFRpbWVGb3JtYXQgJiYgbWluIDw9IGV4dGVudDIgJiYgZXh0ZW50MiA8IG1heDtcbiAgfSkucmVkdWNlKFxuICAgIChyLCBuZXh0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG5leHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgci5yZXN1bHQucHVzaChuZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXIudXNlZC5oYXMobmV4dFswXSkpIHtcbiAgICAgICAgci5yZXN1bHQucHVzaChuZXh0KTtcbiAgICAgICAgci51c2VkLmFkZChuZXh0WzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sXG4gICAgeyByZXN1bHQ6IFtdLCB1c2VkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpIH1cbiAgKS5yZXN1bHQ7XG4gIGNvbnN0IGZpcnN0Rm9ybWF0ID0gZm9ybWF0UGFydHMuZmluZEluZGV4KCh2KSA9PiB0eXBlb2YgdiAhPT0gXCJzdHJpbmdcIik7XG4gIGNvbnN0IGxhc3RGb3JtYXQgPSBmb3JtYXRQYXJ0cy5sZW5ndGggLSBbLi4uZm9ybWF0UGFydHNdLnJldmVyc2UoKS5maW5kSW5kZXgoKHYpID0+IHR5cGVvZiB2ICE9PSBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIGZvcm1hdFBhcnRzLnNsaWNlKGZpcnN0Rm9ybWF0LCBsYXN0Rm9ybWF0KS5tYXAoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA6IHZbNF0pLmpvaW4oXCJcIikucmVwbGFjZUFsbCgvXFxzKy9nLCBcIiBcIikudHJpbSgpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9pbnZhbGlkYXRpbmcudHNcbnZhciBJbnZhbGlkYXRpbmcgPSAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICBjb25zdCBtYXBwZWRQcm9wZXJ0eSA9IFN5bWJvbChTdHJpbmcocHJvcGVydHlLZXkpKTtcbiAgdGFyZ2V0W21hcHBlZFByb3BlcnR5XSA9IHZvaWQgMDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1ttYXBwZWRQcm9wZXJ0eV07XG4gICAgfSxcbiAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1ttYXBwZWRQcm9wZXJ0eV07XG4gICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXNbbWFwcGVkUHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSk7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9iYW5kU2NhbGUudHNcbnZhciBfQmFuZFNjYWxlID0gY2xhc3MgX0JhbmRTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiYmFuZFwiO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnJvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcnZhbCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBNYXBzIGRhdHVtIHRvIGl0cyBpbmRleCBpbiB0aGUge0BsaW5rIGRvbWFpbn0gYXJyYXkuXG4gICAgICogVXNlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlIGRhdGEgKG5vdCBhbGxvd2VkKS5cbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IHJhbmdlIHZhbHVlcyBmb3IgZGF0dW0gYXQgZWFjaCBpbmRleC5cbiAgICAgKi9cbiAgICB0aGlzLm9yZGluYWxSYW5nZSA9IFtdO1xuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHVuaXF1ZSBkYXRhIG9ubHkuXG4gICAgICovXG4gICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgdGhpcy5fYmFuZHdpZHRoID0gMTtcbiAgICB0aGlzLl9zdGVwID0gMTtcbiAgICB0aGlzLl9pbnNldCA9IDE7XG4gICAgdGhpcy5fcmF3QmFuZHdpZHRoID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF0aW8gb2YgdGhlIHJhbmdlIHRoYXQgaXMgcmVzZXJ2ZWQgZm9yIHNwYWNlIGJldHdlZW4gYmFuZHMuXG4gICAgICovXG4gICAgdGhpcy5fcGFkZGluZ0lubmVyID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF0aW8gb2YgdGhlIHJhbmdlIHRoYXQgaXMgcmVzZXJ2ZWQgZm9yIHNwYWNlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBhbmQgYWZ0ZXIgdGhlIGxhc3QgYmFuZC5cbiAgICAgKi9cbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSAwO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9CYW5kU2NhbGU7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAoIXRoaXMuaW52YWxpZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcIkV4cGVjdGVkIHVwZGF0ZSB0byBub3QgaW52YWxpZGF0ZSBzY2FsZVwiKTtcbiAgICB9XG4gIH1cbiAgc2V0IGRvbWFpbih2YWx1ZXMpIHtcbiAgICB0aGlzLmluZGV4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBjb25zdCBrZXkgPSBkYXRlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHRoaXMuZ2V0SW5kZXgoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuaW5kZXguc2V0KGtleSwgdGhpcy5fZG9tYWluLnB1c2godmFsdWUpIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBkb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICBnZXREb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICB0aWNrcygpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIGNvbnZlcnQoZCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldEluZGV4KGQpO1xuICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yZGluYWxSYW5nZVtpXSA/PyBOYU47XG4gIH1cbiAgaW52ZXJ0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGluYWxSYW5nZS5maW5kSW5kZXgoKHApID0+IHAgPT09IHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5kb21haW5baW5kZXhdO1xuICB9XG4gIGludmVydE5lYXJlc3QocG9zaXRpb24pIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBsZXQgbmVhcmVzdCA9IC0xO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwLCBpKSA9PiB7XG4gICAgICBpZiAocCA9PT0gcG9zaXRpb24pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgZGlzdGFuY2UzID0gTWF0aC5hYnMocG9zaXRpb24gLSBwKTtcbiAgICAgIGlmIChkaXN0YW5jZTMgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlMztcbiAgICAgICAgbmVhcmVzdCA9IGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluW2luZGV4XSA/PyB0aGlzLmRvbWFpbltuZWFyZXN0XTtcbiAgfVxuICBnZXQgYmFuZHdpZHRoKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9iYW5kd2lkdGg7XG4gIH1cbiAgZ2V0IHN0ZXAoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gIH1cbiAgZ2V0IGluc2V0KCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9pbnNldDtcbiAgfVxuICBnZXQgcmF3QmFuZHdpZHRoKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9yYXdCYW5kd2lkdGg7XG4gIH1cbiAgc2V0IHBhZGRpbmcodmFsdWUpIHtcbiAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSB2YWx1ZTtcbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0lubmVyO1xuICB9XG4gIHNldCBwYWRkaW5nSW5uZXIodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gIH1cbiAgZ2V0IHBhZGRpbmdJbm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0lubmVyO1xuICB9XG4gIHNldCBwYWRkaW5nT3V0ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gIH1cbiAgZ2V0IHBhZGRpbmdPdXRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ091dGVyO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RvbWFpbi5sZW5ndGg7XG4gICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtyMCwgcjFdID0gdGhpcy5yYW5nZTtcbiAgICBsZXQgeyBfcGFkZGluZ0lubmVyOiBwYWRkaW5nSW5uZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBfcGFkZGluZ091dGVyOiBwYWRkaW5nT3V0ZXIsIHJvdW5kOiByb3VuZDMgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZ2VEaXN0YW5jZSA9IHIxIC0gcjA7XG4gICAgbGV0IHJhd1N0ZXAsIHN0ZXAsIGluc2V0O1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgcGFkZGluZ0lubmVyID0gMDtcbiAgICAgIHJhd1N0ZXAgPSByYW5nZURpc3RhbmNlICogKDEgLSBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICAgIHN0ZXAgPSByb3VuZDMgPyBNYXRoLnJvdW5kKHJhd1N0ZXApIDogcmF3U3RlcDtcbiAgICAgIGluc2V0ID0gcmFuZ2VEaXN0YW5jZSAqIHBhZGRpbmdPdXRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3U3RlcCA9IHJhbmdlRGlzdGFuY2UgLyBNYXRoLm1heCgxLCBjb3VudCAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgICAgc3RlcCA9IHJvdW5kMyA/IE1hdGguZmxvb3IocmF3U3RlcCkgOiByYXdTdGVwO1xuICAgICAgaW5zZXQgPSByMCArIChyYW5nZURpc3RhbmNlIC0gc3RlcCAqIChjb3VudCAtIHBhZGRpbmdJbm5lcikpIC8gMjtcbiAgICB9XG4gICAgbGV0IGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kMykge1xuICAgICAgaW5zZXQgPSBNYXRoLnJvdW5kKGluc2V0KTtcbiAgICAgIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgdGhpcy5faW5zZXQgPSBpbnNldDtcbiAgICB0aGlzLl9iYW5kd2lkdGggPSBiYW5kd2lkdGg7XG4gICAgdGhpcy5fcmF3QmFuZHdpZHRoID0gcmF3U3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICB0aGlzLm9yZGluYWxSYW5nZSA9IHRoaXMuX2RvbWFpbi5tYXAoKF8sIGkpID0+IGluc2V0ICsgc3RlcCAqIGkpO1xuICB9XG4gIGdldEluZGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0KHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLmdldFRpbWUoKSA6IHZhbHVlKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0JhbmRTY2FsZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9CYW5kU2NhbGUucHJvdG90eXBlLCBcInJvdW5kXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQmFuZFNjYWxlLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbnZhciBCYW5kU2NhbGUgPSBfQmFuZFNjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZhbGlkYXRpb24udHNcbmZ1bmN0aW9uIFZhbGlkYXRlKHByZWRpY2F0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgb3B0aW9uYWwgPSBmYWxzZSwgcHJvcGVydHk6IG92ZXJyaWRlUHJvcGVydHkgfSA9IG9wdGlvbnM7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0geyAuLi5vcHRpb25zLCB0YXJnZXQsIHByb3BlcnR5IH07XG4gICAgICBpZiAob3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHByZWRpY2F0ZSh2YWx1ZSwgY29udGV4dCkpIHtcbiAgICAgICAgaWYgKGlzUHJvcGVydGllcyh0YXJnZXRbcHJvcGVydHldKSAmJiAhaXNQcm9wZXJ0aWVzKHZhbHVlKSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0uc2V0KHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjbGVhbktleSA9IG92ZXJyaWRlUHJvcGVydHkgPz8gU3RyaW5nKHByb3BlcnR5KS5yZXBsYWNlKC9eXyovLCBcIlwiKTtcbiAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0YXJnZXQuY29uc3RydWN0b3IuY2xhc3NOYW1lID8/IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoL1Byb3BlcnRpZXMkLywgXCJcIik7XG4gICAgICBsZXQgdmFsdWVTdHJpbmcgPSBzdHJpbmdpZnkodmFsdWUpO1xuICAgICAgY29uc3QgbWF4TGVuZ3RoID0gNTA7XG4gICAgICBpZiAodmFsdWVTdHJpbmcgIT0gbnVsbCAmJiB2YWx1ZVN0cmluZy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZXhjZXNzQ2hhcmFjdGVycyA9IHZhbHVlU3RyaW5nLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSB2YWx1ZVN0cmluZy5zbGljZSgwLCBtYXhMZW5ndGgpICsgYC4uLiAoKyR7ZXhjZXNzQ2hhcmFjdGVyc30gY2hhcmFjdGVycylgO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgIGBQcm9wZXJ0eSBbJHtjbGVhbktleX1dIG9mIFske3RhcmdldE5hbWV9XSBjYW5ub3QgYmUgc2V0IHRvIFske3ZhbHVlU3RyaW5nfV0ke3ByZWRpY2F0ZS5tZXNzYWdlID8gYDsgZXhwZWN0aW5nICR7Z2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGNvbnRleHQpfWAgOiBcIlwifSwgaWdub3JpbmcuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBCUkVBS19UUkFOU0ZPUk1fQ0hBSU47XG4gICAgfSxcbiAgICB2b2lkIDAsXG4gICAgeyBvcHRpb25hbCB9XG4gICk7XG59XG52YXIgQU5EID0gKC4uLnByZWRpY2F0ZXMpID0+IHtcbiAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICBtZXNzYWdlcy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuIHByZWRpY2F0ZXMuZXZlcnkoKHByZWRpY2F0ZSkgPT4ge1xuICAgICAgICBjb25zdCBpc1ZhbGlkMiA9IHByZWRpY2F0ZSh2YWx1ZSwgY3R4KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkMikge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkMjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgKCkgPT4gbWVzc2FnZXMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgQU5EIFwiKVxuICApO1xufTtcbnZhciBPUiA9ICguLi5wcmVkaWNhdGVzKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlLCBjdHgpID0+IHByZWRpY2F0ZXMuc29tZSgocHJlZGljYXRlKSA9PiBwcmVkaWNhdGUodmFsdWUsIGN0eCkpLFxuICAoY3R4KSA9PiBwcmVkaWNhdGVzLm1hcChnZXRQcmVkaWNhdGVNZXNzYWdlTWFwcGVyKGN0eCkpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIE9SIFwiKVxuKTtcbnZhciBPQkpFQ1QgPSBhdHRhY2hPYmplY3RSZXN0cmljdGlvbnMoXG4gIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICh2YWx1ZSwgY3R4KSA9PiBpc1Byb3BlcnRpZXModmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSAmJiBpc1Byb3BlcnRpZXMoY3R4LnRhcmdldFtjdHgucHJvcGVydHldKSxcbiAgICBcImEgcHJvcGVydGllcyBvYmplY3RcIlxuICApXG4pO1xudmFyIFBMQUlOX09CSkVDVCA9IGF0dGFjaE9iamVjdFJlc3RyaWN0aW9ucyhwcmVkaWNhdGVXaXRoTWVzc2FnZSgodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSwgXCJhbiBvYmplY3RcIikpO1xudmFyIEJPT0xFQU4gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc0Jvb2xlYW4sIFwiYSBib29sZWFuXCIpO1xudmFyIEZVTkNUSU9OID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNGdW5jdGlvbiwgXCJhIGZ1bmN0aW9uXCIpO1xudmFyIFNUUklORyA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzU3RyaW5nLCBcImEgc3RyaW5nXCIpO1xudmFyIE5VTUJFUiA9IGF0dGFjaE51bWJlclJlc3RyaWN0aW9ucyhwcmVkaWNhdGVXaXRoTWVzc2FnZShpc0Zpbml0ZU51bWJlciwgXCJhIG51bWJlclwiKSk7XG52YXIgTkFOID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc051bWJlcih2YWx1ZSkgJiYgaXNOYU4odmFsdWUpLCBcIk5hTlwiKTtcbnZhciBQT1NJVElWRV9OVU1CRVIgPSBOVU1CRVIucmVzdHJpY3QoeyBtaW46IDAgfSk7XG52YXIgUkFUSU8gPSBOVU1CRVIucmVzdHJpY3QoeyBtaW46IDAsIG1heDogMSB9KTtcbnZhciBERUdSRUUgPSBOVU1CRVIucmVzdHJpY3QoeyBtaW46IC0zNjAsIG1heDogMzYwIH0pO1xudmFyIE5VTUJFUl9PUl9OQU4gPSBPUihOVU1CRVIsIE5BTik7XG52YXIgQVJSQVkgPSBhdHRhY2hBcnJheVJlc3RyaWN0aW9ucyhwcmVkaWNhdGVXaXRoTWVzc2FnZShpc0FycmF5LCBcImFuIGFycmF5XCIpKTtcbnZhciBBUlJBWV9PRiA9IChwcmVkaWNhdGUsIG1lc3NhZ2UpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUsIGN0eCkgPT4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoKGl0ZW0pID0+IHByZWRpY2F0ZShpdGVtLCBjdHgpKSxcbiAgKGN0eCkgPT4ge1xuICAgIGNvbnN0IGFycmF5TWVzc2FnZSA9IGdldFByZWRpY2F0ZU1lc3NhZ2UoQVJSQVksIGN0eCkgPz8gXCJcIjtcbiAgICByZXR1cm4gbWVzc2FnZSA/IGAke2FycmF5TWVzc2FnZX0gb2YgJHttZXNzYWdlfWAgOiBhcnJheU1lc3NhZ2U7XG4gIH1cbik7XG52YXIgaXNDb21wYXJhYmxlID0gKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgfHwgaXNWYWxpZERhdGUodmFsdWUpO1xudmFyIExFU1NfVEhBTiA9IChvdGhlckZpZWxkKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHYsIGN0eCkgPT4gIWlzQ29tcGFyYWJsZSh2KSB8fCAhaXNDb21wYXJhYmxlKGN0eC50YXJnZXRbb3RoZXJGaWVsZF0pIHx8IHYgPCBjdHgudGFyZ2V0W290aGVyRmllbGRdLFxuICBgdG8gYmUgbGVzcyB0aGFuICR7b3RoZXJGaWVsZH1gXG4pO1xudmFyIEdSRUFURVJfVEhBTiA9IChvdGhlckZpZWxkKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHYsIGN0eCkgPT4gIWlzQ29tcGFyYWJsZSh2KSB8fCAhaXNDb21wYXJhYmxlKGN0eC50YXJnZXRbb3RoZXJGaWVsZF0pIHx8IHYgPiBjdHgudGFyZ2V0W290aGVyRmllbGRdLFxuICBgdG8gYmUgZ3JlYXRlciB0aGFuICR7b3RoZXJGaWVsZH1gXG4pO1xudmFyIERBVEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc1ZhbGlkRGF0ZSwgXCJEYXRlIG9iamVjdFwiKTtcbnZhciBEQVRFX09SX0RBVEVUSU1FX01TID0gT1IoREFURSwgUE9TSVRJVkVfTlVNQkVSKTtcbnZhciBjb2xvck1lc3NhZ2UgPSBgQSBjb2xvciBzdHJpbmcgY2FuIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHMgdG8gYmUgdmFsaWQ6ICNyZ2IsICNycmdnYmIsIHJnYihyLCBnLCBiKSwgcmdiYShyLCBnLCBiLCBhKSBvciBhIENTUyBjb2xvciBuYW1lIHN1Y2ggYXMgJ3doaXRlJywgJ29yYW5nZScsICdjeWFuJywgZXRjYDtcbnZhciBDT0xPUl9TVFJJTkcgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHYpID0+IGlzU3RyaW5nKHYpICYmIENvbG9yLnZhbGlkQ29sb3JTdHJpbmcodiksXG4gIGBjb2xvciBTdHJpbmcuICR7Y29sb3JNZXNzYWdlfWBcbik7XG52YXIgQ09MT1JfU1RSSU5HX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVlfT0YoQ09MT1JfU1RSSU5HKSwgYGNvbG9yIHN0cmluZ3MuICR7Y29sb3JNZXNzYWdlfWApO1xudmFyIEJPT0xFQU5fQVJSQVkgPSBBUlJBWV9PRihCT09MRUFOLCBcImJvb2xlYW4gdmFsdWVzXCIpO1xudmFyIE5VTUJFUl9BUlJBWSA9IEFSUkFZX09GKE5VTUJFUiwgXCJudW1iZXJzXCIpO1xudmFyIFNUUklOR19BUlJBWSA9IEFSUkFZX09GKFNUUklORywgXCJzdHJpbmdzXCIpO1xudmFyIERBVEVfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWV9PRihEQVRFKSwgXCJEYXRlIG9iamVjdHNcIik7XG52YXIgT0JKRUNUX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVlfT0YoT0JKRUNUKSwgXCJvYmplY3RzXCIpO1xudmFyIExJTkVfQ0FQID0gVU5JT04oW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdLCBcImEgbGluZSBjYXBcIik7XG52YXIgTElORV9KT0lOID0gVU5JT04oW1wicm91bmRcIiwgXCJiZXZlbFwiLCBcIm1pdGVyXCJdLCBcImEgbGluZSBqb2luXCIpO1xudmFyIExJTkVfREFTSCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICBBUlJBWV9PRihQT1NJVElWRV9OVU1CRVIpLFxuICBcIm51bWJlcnMgc3BlY2lmeWluZyB0aGUgbGVuZ3RoIGluIHBpeGVscyBvZiBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMsIGZvciBleGFtcGxlLCBbNiwgM10gbWVhbnMgZGFzaGVzIHdpdGggYSBsZW5ndGggb2YgNiBwaXhlbHMgd2l0aCBnYXBzIGJldHdlZW4gb2YgMyBwaXhlbHMuXCJcbik7XG52YXIgUE9TSVRJT04gPSBVTklPTihbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0sIFwiYSBwb3NpdGlvblwiKTtcbnZhciBGT05UX1NUWUxFID0gVU5JT04oW1wibm9ybWFsXCIsIFwiaXRhbGljXCIsIFwib2JsaXF1ZVwiXSwgXCJhIGZvbnQgc3R5bGVcIik7XG52YXIgRk9OVF9XRUlHSFQgPSBPUihcbiAgVU5JT04oW1wibm9ybWFsXCIsIFwiYm9sZFwiLCBcImJvbGRlclwiLCBcImxpZ2h0ZXJcIl0sIFwiYSBmb250IHdlaWdodFwiKSxcbiAgTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxLCBtYXg6IDFlMyB9KVxuKTtcbnZhciBURVhUX1dSQVAgPSBVTklPTihbXCJuZXZlclwiLCBcImFsd2F5c1wiLCBcImh5cGhlbmF0ZVwiLCBcIm9uLXNwYWNlXCJdLCBcImEgdGV4dCB3cmFwIHN0cmF0ZWd5XCIpO1xudmFyIFRFWFRfQUxJR04gPSBVTklPTihbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl0sIFwiYSB0ZXh0IGFsaWduXCIpO1xudmFyIFZFUlRJQ0FMX0FMSUdOID0gVU5JT04oW1widG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdLCBcImEgdmVydGljYWwgYWxpZ25cIik7XG52YXIgT1ZFUkZMT1dfU1RSQVRFR1kgPSBVTklPTihbXCJlbGxpcHNpc1wiLCBcImhpZGVcIl0sIFwiYW4gb3ZlcmZsb3cgc3RyYXRlZ3lcIik7XG52YXIgRElSRUNUSU9OID0gVU5JT04oW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLCBcImEgZGlyZWN0aW9uXCIpO1xudmFyIFBMQUNFTUVOVCA9IFVOSU9OKFtcImluc2lkZVwiLCBcIm91dHNpZGVcIl0sIFwiYSBwbGFjZW1lbnRcIik7XG52YXIgSU5URVJBQ1RJT05fUkFOR0UgPSBPUihVTklPTihbXCJleGFjdFwiLCBcIm5lYXJlc3RcIl0sIFwiaW50ZXJhY3Rpb24gcmFuZ2VcIiksIE5VTUJFUik7XG52YXIgTEFCRUxfUExBQ0VNRU5UID0gVU5JT04oW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKTtcbmZ1bmN0aW9uIFVOSU9OKG9wdGlvbnMsIG1lc3NhZ2UgPSBcImFcIikge1xuICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHYpID0+IG9wdGlvbnMuaW5jbHVkZXModiksXG4gICAgYCR7bWVzc2FnZX0ga2V5d29yZCBzdWNoIGFzICR7am9pblVuaW9uT3B0aW9ucyhvcHRpb25zKX1gXG4gICk7XG59XG52YXIgTUlOX1NQQUNJTkcgPSBPUihBTkQoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxIH0pLCBMRVNTX1RIQU4oXCJtYXhTcGFjaW5nXCIpKSwgTkFOKTtcbnZhciBNQVhfU1BBQ0lORyA9IE9SKEFORChOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEgfSksIEdSRUFURVJfVEhBTihcIm1pblNwYWNpbmdcIikpLCBOQU4pO1xuZnVuY3Rpb24gcHJlZGljYXRlV2l0aE1lc3NhZ2UocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gIHByZWRpY2F0ZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgcmV0dXJuIHByZWRpY2F0ZTtcbn1cbmZ1bmN0aW9uIGpvaW5Vbmlvbk9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zLm1hcCgob3B0aW9uKSA9PiBgJyR7b3B0aW9ufSdgKTtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG4gIGNvbnN0IGxhc3RWYWx1ZSA9IHZhbHVlcy5wb3AoKTtcbiAgcmV0dXJuIGAke3ZhbHVlcy5qb2luKFwiLCBcIil9IG9yICR7bGFzdFZhbHVlfWA7XG59XG5mdW5jdGlvbiBnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHByZWRpY2F0ZS5tZXNzYWdlKSA/IHByZWRpY2F0ZS5tZXNzYWdlKGN0eCkgOiBwcmVkaWNhdGUubWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGdldFByZWRpY2F0ZU1lc3NhZ2VNYXBwZXIoY3R4KSB7XG4gIHJldHVybiAocHJlZGljYXRlKSA9PiBnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaEFycmF5UmVzdHJpY3Rpb25zKHByZWRpY2F0ZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGUsIHtcbiAgICByZXN0cmljdCh7IGxlbmd0aDogbGVuZ3RoMiwgbWluTGVuZ3RoIH0gPSB7fSkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBcImFuIGFycmF5XCI7XG4gICAgICBpZiAoaXNOdW1iZXIobWluTGVuZ3RoKSAmJiBtaW5MZW5ndGggPiAwKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImEgbm9uLWVtcHR5IGFycmF5XCI7XG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGxlbmd0aDIpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgYW4gYXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3RoMn1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICAgICAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpICYmIChpc051bWJlcihsZW5ndGgyKSA/IHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoMiA6IHRydWUpICYmIChpc051bWJlcihtaW5MZW5ndGgpID8gdmFsdWUubGVuZ3RoID49IG1pbkxlbmd0aCA6IHRydWUpLFxuICAgICAgICBtZXNzYWdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRhY2hOdW1iZXJSZXN0cmljdGlvbnMocHJlZGljYXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHByZWRpY2F0ZSwge1xuICAgIHJlc3RyaWN0KHsgbWluLCBtYXggfSA9IHt9KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gW1wiYSBudW1iZXJcIl07XG4gICAgICBjb25zdCBoYXNNaW4gPSBpc051bWJlcihtaW4pO1xuICAgICAgY29uc3QgaGFzTWF4ID0gaXNOdW1iZXIobWF4KTtcbiAgICAgIGlmIChoYXNNaW4gJiYgaGFzTWF4KSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSBpbmNsdXNpdmVgKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTWluKSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7bWlufWApO1xuICAgICAgfSBlbHNlIGlmIChoYXNNYXgpIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHttYXh9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgICAgICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmIChoYXNNaW4gPyB2YWx1ZSA+PSBtaW4gOiB0cnVlKSAmJiAoaGFzTWF4ID8gdmFsdWUgPD0gbWF4IDogdHJ1ZSksXG4gICAgICAgIG1lc3NhZ2Uuam9pbihcIiBcIilcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaE9iamVjdFJlc3RyaWN0aW9ucyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlZGljYXRlLCB7XG4gICAgcmVzdHJpY3Qob2JqZWN0VHlwZSkge1xuICAgICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICAgICAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2Ygb2JqZWN0VHlwZSxcbiAgICAgICAgKGN0eCkgPT4gZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCkgPz8gYGFuIGluc3RhbmNlIG9mICR7b2JqZWN0VHlwZS5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSlcbiAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpXG4gICAgICByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KVxuICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRBeGlzRGlyZWN0aW9uLnRzXG52YXIgQ2hhcnRBeGlzRGlyZWN0aW9uID0gLyogQF9fUFVSRV9fICovICgoQ2hhcnRBeGlzRGlyZWN0aW9uMikgPT4ge1xuICBDaGFydEF4aXNEaXJlY3Rpb24yW1wiWFwiXSA9IFwieFwiO1xuICBDaGFydEF4aXNEaXJlY3Rpb24yW1wiWVwiXSA9IFwieVwiO1xuICByZXR1cm4gQ2hhcnRBeGlzRGlyZWN0aW9uMjtcbn0pKENoYXJ0QXhpc0RpcmVjdGlvbiB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9tb2R1bGVNYXAudHNcbnZhciBNb2R1bGVNYXAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubW9kdWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAqbW9kdWxlcygpIHtcbiAgICBjb25zdCBzZXF1ZW5jZWRNb2R1bGVzID0gW1widG9vbGJhclwiLCBcIm5hdmlnYXRvclwiXTtcbiAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5tb2R1bGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChzZXF1ZW5jZWRNb2R1bGVzLmluY2x1ZGVzKG0ubW9kdWxlLm9wdGlvbnNLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgbS5tb2R1bGVJbnN0YW5jZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2VxdWVuY2VkTW9kdWxlcykge1xuICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5tb2R1bGVNYXAuZ2V0KGtleSk7XG4gICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgIHlpZWxkIG1vZHVsZS5tb2R1bGVJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkTW9kdWxlKG1vZHVsZSwgbW9kdWxlRmFjdG9yeSkge1xuICAgIGlmICh0aGlzLm1vZHVsZU1hcC5oYXMobW9kdWxlLm9wdGlvbnNLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIG1vZHVsZSBhbHJlYWR5IGluaXRpYWxpc2VkOiAke21vZHVsZS5vcHRpb25zS2V5fWApO1xuICAgIH1cbiAgICB0aGlzLm1vZHVsZU1hcC5zZXQobW9kdWxlLm9wdGlvbnNLZXksIHsgbW9kdWxlLCBtb2R1bGVJbnN0YW5jZTogbW9kdWxlRmFjdG9yeShtb2R1bGUpIH0pO1xuICB9XG4gIHJlbW92ZU1vZHVsZShtb2R1bGUpIHtcbiAgICBjb25zdCBtb2R1bGVLZXkgPSBpc1N0cmluZyhtb2R1bGUpID8gbW9kdWxlIDogbW9kdWxlLm9wdGlvbnNLZXk7XG4gICAgdGhpcy5tb2R1bGVNYXAuZ2V0KG1vZHVsZUtleSk/Lm1vZHVsZUluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB0aGlzLm1vZHVsZU1hcC5kZWxldGUobW9kdWxlS2V5KTtcbiAgfVxuICBnZXRNb2R1bGUobW9kdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLmdldChpc1N0cmluZyhtb2R1bGUpID8gbW9kdWxlIDogbW9kdWxlLm9wdGlvbnNLZXkpPy5tb2R1bGVJbnN0YW5jZTtcbiAgfVxuICBpc0VuYWJsZWQobW9kdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLmhhcyhpc1N0cmluZyhtb2R1bGUpID8gbW9kdWxlIDogbW9kdWxlLm9wdGlvbnNLZXkpO1xuICB9XG4gIG1hcE1vZHVsZXMoY2FsbGJhY2syKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tb2R1bGVNYXAudmFsdWVzKCksIChtLCBpKSA9PiBjYWxsYmFjazIobS5tb2R1bGVJbnN0YW5jZSwgaSkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBtb2R1bGVLZXkgb2YgdGhpcy5tb2R1bGVNYXAua2V5cygpKSB7XG4gICAgICB0aGlzLm1vZHVsZU1hcC5nZXQobW9kdWxlS2V5KT8ubW9kdWxlSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLm1vZHVsZU1hcC5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vcmVzZXRNb3Rpb24udHNcbnZhciByZXNldE1vdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZXNldE1vdGlvbl9leHBvcnRzLCB7XG4gIHJlc2V0TW90aW9uOiAoKSA9PiByZXNldE1vdGlvblxufSk7XG5mdW5jdGlvbiByZXNldE1vdGlvbihzZWxlY3Rpb25zT3JOb2RlcywgcHJvcHNGbikge1xuICBjb25zdCB7IG5vZGVzLCBzZWxlY3Rpb25zIH0gPSBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKTtcbiAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgY29uc3QgZnJvbTIgPSBwcm9wc0ZuKG5vZGUsIG5vZGUuZGF0dW0pO1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGZyb20yKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBjb25zdCBmcm9tMiA9IHByb3BzRm4obm9kZSwgbm9kZS5kYXR1bSk7XG4gICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGZyb20yKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9jb250aW51b3VzU2NhbGUudHNcbnZhciBfQ29udGludW91c1NjYWxlID0gY2xhc3MgX0NvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGRvbWFpbiwgcmFuZ2UzKSB7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLm5pY2UgPSBmYWxzZTtcbiAgICB0aGlzLmludGVydmFsID0gdm9pZCAwO1xuICAgIHRoaXMudGlja0NvdW50ID0gX0NvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xuICAgIHRoaXMubWluVGlja0NvdW50ID0gMDtcbiAgICB0aGlzLm1heFRpY2tDb3VudCA9IEluZmluaXR5O1xuICAgIC8vIFRPRE8ob2xlZ2F0KSBzaG91bGQgYmUgb2YgdHlwZSBEW11cbiAgICB0aGlzLm5pY2VEb21haW4gPSBbXTtcbiAgICB0aGlzLmRlZmF1bHRDbGFtcE1vZGUgPSBcInJhd1wiO1xuICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTM7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0NvbnRpbnVvdXNTY2FsZTtcbiAgfVxuICB0cmFuc2Zvcm0oeCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIHRyYW5zZm9ybUludmVydCh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgY2FsY0JhbmR3aWR0aChzbWFsbGVzdEludGVydmFsID0gMSkge1xuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgY29uc3QgcmFuZ2VEaXN0YW5jZSA9IHRoaXMuZ2V0UGl4ZWxSYW5nZSgpO1xuICAgIGNvbnN0IGludGVydmFscyA9IE1hdGguYWJzKGRvbWFpblsxXSAtIGRvbWFpblswXSkgLyBzbWFsbGVzdEludGVydmFsICsgMTtcbiAgICBjb25zdCBtYXhCYW5kcyA9IE1hdGguZmxvb3IocmFuZ2VEaXN0YW5jZSk7XG4gICAgY29uc3QgYmFuZHMgPSBNYXRoLm1pbihpbnRlcnZhbHMsIG1heEJhbmRzKTtcbiAgICByZXR1cm4gcmFuZ2VEaXN0YW5jZSAvIE1hdGgubWF4KDEsIGJhbmRzKTtcbiAgfVxuICBnZXREb21haW4oKSB7XG4gICAgaWYgKHRoaXMubmljZSkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICBpZiAodGhpcy5uaWNlRG9tYWluLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uaWNlRG9tYWluO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kb21haW47XG4gIH1cbiAgY29udmVydCh4LCBvcHRzKSB7XG4gICAgY29uc3QgY2xhbXBNb2RlID0gb3B0cz8uY2xhbXBNb2RlID8/IHRoaXMuZGVmYXVsdENsYW1wTW9kZTtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCkubWFwKChkKSA9PiB0aGlzLnRyYW5zZm9ybShkKSk7XG4gICAgY29uc3QgW2QwLCBkMV0gPSBkb21haW47XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtyMCwgcjFdID0gcmFuZ2UzO1xuICAgIHggPSB0aGlzLnRyYW5zZm9ybSh4KTtcbiAgICBpZiAoY2xhbXBNb2RlID09PSBcImNsYW1wZWRcIikge1xuICAgICAgY29uc3QgW3N0YXJ0LCBzdG9wXSA9IGZpbmRNaW5NYXgoZG9tYWluLm1hcChOdW1iZXIpKTtcbiAgICAgIGlmIChOdW1iZXIoeCkgPCBzdGFydCkge1xuICAgICAgICByZXR1cm4gcjA7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlcih4KSA+IHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHIxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZDAgPT09IGQxKSB7XG4gICAgICByZXR1cm4gKHIwICsgcjEpIC8gMjtcbiAgICB9IGVsc2UgaWYgKHggPT09IGQwKSB7XG4gICAgICByZXR1cm4gcjA7XG4gICAgfSBlbHNlIGlmICh4ID09PSBkMSkge1xuICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgICByZXR1cm4gcjAgKyAoTnVtYmVyKHgpIC0gTnVtYmVyKGQwKSkgLyAoTnVtYmVyKGQxKSAtIE51bWJlcihkMCkpICogKHIxIC0gcjApO1xuICB9XG4gIGludmVydCh4KSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKS5tYXAoKGQyKSA9PiB0aGlzLnRyYW5zZm9ybShkMikpO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gZG9tYWluO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBbcjAsIHIxXSA9IHJhbmdlMztcbiAgICBjb25zdCBpc1JldmVyc2VkID0gcjAgPiByMTtcbiAgICBjb25zdCByTWluID0gaXNSZXZlcnNlZCA/IHIxIDogcjA7XG4gICAgY29uc3Qgck1heCA9IGlzUmV2ZXJzZWQgPyByMCA6IHIxO1xuICAgIGxldCBkO1xuICAgIGlmICh4IDwgck1pbikge1xuICAgICAgcmV0dXJuIGlzUmV2ZXJzZWQgPyBkMSA6IGQwO1xuICAgIH0gZWxzZSBpZiAoeCA+IHJNYXgpIHtcbiAgICAgIHJldHVybiBpc1JldmVyc2VkID8gZDAgOiBkMTtcbiAgICB9IGVsc2UgaWYgKHIwID09PSByMSkge1xuICAgICAgZCA9IHRoaXMudG9Eb21haW4oKE51bWJlcihkMCkgKyBOdW1iZXIoZDEpKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gdGhpcy50b0RvbWFpbihOdW1iZXIoZDApICsgKHggLSByMCkgLyAocjEgLSByMCkgKiAoTnVtYmVyKGQxKSAtIE51bWJlcihkMCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtSW52ZXJ0KGQpO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKCF0aGlzLmludmFsaWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsUmFuZ2UoKSB7XG4gICAgY29uc3QgW2EsIGJdID0gdGhpcy5yYW5nZTtcbiAgICByZXR1cm4gTWF0aC5hYnMoYiAtIGEpO1xuICB9XG59O1xuX0NvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50ID0gNTtcbl9Db250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudCA9IDY7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcIm5pY2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJ0aWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcIm1pblRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwibWF4VGlja0NvdW50XCIsIDIpO1xudmFyIENvbnRpbnVvdXNTY2FsZSA9IF9Db250aW51b3VzU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbnVtYmVyRm9ybWF0LnRzXG5mdW5jdGlvbiBwYXJzZUZvcm1hdChmb3JtYXQpIHtcbiAgbGV0IHByZWZpeDtcbiAgbGV0IHN1ZmZpeDtcbiAgY29uc3Qgc3Vycm91bmRlZCA9IHN1cnJvdW5kZWRSZWdFeC5leGVjKGZvcm1hdCk7XG4gIGlmIChzdXJyb3VuZGVkKSB7XG4gICAgWywgcHJlZml4LCBmb3JtYXQsIHN1ZmZpeF0gPSBzdXJyb3VuZGVkO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gZm9ybWF0UmVnRXguZXhlYyhmb3JtYXQpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbnVtYmVyIGZvcm1hdHRlciBpcyBpbnZhbGlkOiAke2Zvcm1hdH1gKTtcbiAgfVxuICBjb25zdCBbLCBmaWxsLCBhbGlnbiwgc2lnbiwgc3ltYm9sLCB6ZXJvLCB3aWR0aCwgY29tbWEsIHByZWNpc2lvbiwgdHJpbSwgdHlwZV0gPSBtYXRjaDtcbiAgcmV0dXJuIHtcbiAgICBmaWxsLFxuICAgIGFsaWduLFxuICAgIHNpZ24sXG4gICAgc3ltYm9sLFxuICAgIHplcm8sXG4gICAgd2lkdGg6IHBhcnNlSW50KHdpZHRoKSxcbiAgICBjb21tYSxcbiAgICBwcmVjaXNpb246IHBhcnNlSW50KHByZWNpc2lvbiksXG4gICAgdHJpbTogQm9vbGVhbih0cmltKSxcbiAgICB0eXBlLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXhcbiAgfTtcbn1cbmZ1bmN0aW9uIG51bWJlckZvcm1hdChmb3JtYXQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZvcm1hdChmb3JtYXQpIDogZm9ybWF0O1xuICBjb25zdCB7IGZpbGwsIGFsaWduLCBzaWduID0gXCItXCIsIHN5bWJvbCwgemVybywgd2lkdGgsIGNvbW1hLCB0eXBlLCBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiLCBwcmVjaXNpb24gfSA9IG9wdGlvbnM7XG4gIGxldCB7IHRyaW0gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByZWNpc2lvbklzTmFOID0gcHJlY2lzaW9uID09IG51bGwgfHwgaXNOYU4ocHJlY2lzaW9uKTtcbiAgbGV0IGZvcm1hdEJvZHk7XG4gIGlmICghdHlwZSkge1xuICAgIGZvcm1hdEJvZHkgPSBkZWNpbWFsVHlwZXNbXCJnXCJdO1xuICAgIHRyaW0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGUgaW4gZGVjaW1hbFR5cGVzICYmIHR5cGUgaW4gaW50ZWdlclR5cGVzKSB7XG4gICAgZm9ybWF0Qm9keSA9IHByZWNpc2lvbklzTmFOID8gaW50ZWdlclR5cGVzW3R5cGVdIDogZGVjaW1hbFR5cGVzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW4gZGVjaW1hbFR5cGVzKSB7XG4gICAgZm9ybWF0Qm9keSA9IGRlY2ltYWxUeXBlc1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluIGludGVnZXJUeXBlcykge1xuICAgIGZvcm1hdEJvZHkgPSBpbnRlZ2VyVHlwZXNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbnVtYmVyIGZvcm1hdHRlciB0eXBlIGlzIGludmFsaWQ6ICR7dHlwZX1gKTtcbiAgfVxuICBsZXQgZm9ybWF0dGVyUHJlY2lzaW9uO1xuICBpZiAocHJlY2lzaW9uID09IG51bGwgfHwgcHJlY2lzaW9uSXNOYU4pIHtcbiAgICBmb3JtYXR0ZXJQcmVjaXNpb24gPSB0eXBlID8gNiA6IDEyO1xuICB9IGVsc2Uge1xuICAgIGZvcm1hdHRlclByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgfVxuICByZXR1cm4gKG4pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gZm9ybWF0Qm9keShuLCBmb3JtYXR0ZXJQcmVjaXNpb24pO1xuICAgIGlmICh0cmltKSB7XG4gICAgICByZXN1bHQgPSByZW1vdmVUcmFpbGluZ1plcm9zKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChjb21tYSkge1xuICAgICAgcmVzdWx0ID0gaW5zZXJ0U2VwYXJhdG9yKHJlc3VsdCwgY29tbWEpO1xuICAgIH1cbiAgICByZXN1bHQgPSBhZGRTaWduKG4sIHJlc3VsdCwgc2lnbik7XG4gICAgaWYgKHN5bWJvbCAmJiBzeW1ib2wgIT09IFwiI1wiKSB7XG4gICAgICByZXN1bHQgPSBgJHtzeW1ib2x9JHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHN5bWJvbCA9PT0gXCIjXCIgJiYgdHlwZSA9PT0gXCJ4XCIpIHtcbiAgICAgIHJlc3VsdCA9IGAweCR7cmVzdWx0fWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcInNcIikge1xuICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSR7Z2V0U0lQcmVmaXgobil9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiJVwiIHx8IHR5cGUgPT09IFwicFwiKSB7XG4gICAgICByZXN1bHQgPSBgJHtyZXN1bHR9JWA7XG4gICAgfVxuICAgIGlmICh3aWR0aCAhPSBudWxsICYmICFpc05hTih3aWR0aCkpIHtcbiAgICAgIHJlc3VsdCA9IGFkZFBhZGRpbmcocmVzdWx0LCB3aWR0aCwgZmlsbCA/PyB6ZXJvLCBhbGlnbik7XG4gICAgfVxuICAgIHJlc3VsdCA9IGAke3ByZWZpeH0ke3Jlc3VsdH0ke3N1ZmZpeH1gO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG52YXIgZm9ybWF0UmVnRXggPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyTigqzCo8Kl4oKj4oK5I10pPygwKT8oXFxkKyk/KCwpPyg/OlxcLihcXGQrKSk/KH4pPyhbJWEtel0pPyQvaTtcbnZhciBzdXJyb3VuZGVkUmVnRXggPSAvXigoPzpbXiNdfCNbXntdKSopI3soW159XSspfSguKikkLztcbnZhciBpbnRlZ2VyVHlwZXMgPSB7XG4gIGI6IChuKSA9PiBhYnNGbG9vcihuKS50b1N0cmluZygyKSxcbiAgYzogKG4pID0+IFN0cmluZy5mcm9tQ2hhckNvZGUobiksXG4gIGQ6IChuKSA9PiBNYXRoLnJvdW5kKE1hdGguYWJzKG4pKS50b0ZpeGVkKDApLFxuICBvOiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoOCksXG4gIHg6IChuKSA9PiBhYnNGbG9vcihuKS50b1N0cmluZygxNiksXG4gIFg6IChuKSA9PiBpbnRlZ2VyVHlwZXMueChuKS50b1VwcGVyQ2FzZSgpLFxuICBuOiAobikgPT4gaW50ZWdlclR5cGVzLmQobiksXG4gIFwiJVwiOiAobikgPT4gYCR7YWJzRmxvb3IobiAqIDEwMCkudG9GaXhlZCgwKX1gXG59O1xudmFyIGRlY2ltYWxUeXBlcyA9IHtcbiAgZTogKG4sIGYpID0+IE1hdGguYWJzKG4pLnRvRXhwb25lbnRpYWwoZiksXG4gIEU6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZShuLCBmKS50b1VwcGVyQ2FzZSgpLFxuICBmOiAobiwgZikgPT4gTWF0aC5hYnMobikudG9GaXhlZChmKSxcbiAgRjogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5mKG4sIGYpLnRvVXBwZXJDYXNlKCksXG4gIGc6IChuLCBmKSA9PiB7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiBcIjBcIjtcbiAgICB9XG4gICAgY29uc3QgYSA9IE1hdGguYWJzKG4pO1xuICAgIGNvbnN0IHAgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoYSkpO1xuICAgIGlmIChwID49IC00ICYmIHAgPCBmKSB7XG4gICAgICByZXR1cm4gYS50b0ZpeGVkKGYgLSAxIC0gcCk7XG4gICAgfVxuICAgIHJldHVybiBhLnRvRXhwb25lbnRpYWwoZiAtIDEpO1xuICB9LFxuICBHOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmcobiwgZikudG9VcHBlckNhc2UoKSxcbiAgbjogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5nKG4sIGYpLFxuICBwOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLnIobiAqIDEwMCwgZiksXG4gIHI6IChuLCBmKSA9PiB7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiBcIjBcIjtcbiAgICB9XG4gICAgY29uc3QgYSA9IE1hdGguYWJzKG4pO1xuICAgIGNvbnN0IHAgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoYSkpO1xuICAgIGNvbnN0IHEgPSBwIC0gKGYgLSAxKTtcbiAgICBpZiAocSA8PSAwKSB7XG4gICAgICByZXR1cm4gYS50b0ZpeGVkKC1xKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IDEwICoqIHE7XG4gICAgcmV0dXJuIChNYXRoLnJvdW5kKGEgLyB4KSAqIHgpLnRvRml4ZWQoKTtcbiAgfSxcbiAgczogKG4sIGYpID0+IHtcbiAgICBjb25zdCBwID0gZ2V0U0lQcmVmaXhQb3dlcihuKTtcbiAgICByZXR1cm4gZGVjaW1hbFR5cGVzLnIobiAvIDEwICoqIHAsIGYpO1xuICB9LFxuICBcIiVcIjogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5mKG4gKiAxMDAsIGYpXG59O1xudmFyIG1pblNJUHJlZml4ID0gLTI0O1xudmFyIG1heFNJUHJlZml4ID0gMjQ7XG52YXIgc2lQcmVmaXhlcyA9IHtcbiAgW21pblNJUHJlZml4XTogXCJ5XCIsXG4gIFstMjFdOiBcInpcIixcbiAgWy0xOF06IFwiYVwiLFxuICBbLTE1XTogXCJmXCIsXG4gIFstMTJdOiBcInBcIixcbiAgWy05XTogXCJuXCIsXG4gIFstNl06IFwiXFx4QjVcIixcbiAgWy0zXTogXCJtXCIsXG4gIFswXTogXCJcIixcbiAgWzNdOiBcImtcIixcbiAgWzZdOiBcIk1cIixcbiAgWzldOiBcIkdcIixcbiAgWzEyXTogXCJUXCIsXG4gIFsxNV06IFwiUFwiLFxuICBbMThdOiBcIkVcIixcbiAgWzIxXTogXCJaXCIsXG4gIFttYXhTSVByZWZpeF06IFwiWVwiXG59O1xudmFyIG1pbnVzU2lnbiA9IFwiXFx1MjIxMlwiO1xuZnVuY3Rpb24gYWJzRmxvb3Iobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFpbGluZ1plcm9zKG51bVN0cmluZykge1xuICByZXR1cm4gbnVtU3RyaW5nLnJlcGxhY2UoL1xcLjArJC8sIFwiXCIpLnJlcGxhY2UoLyhcXC5bMS05XSkwKyQvLCBcIiQxXCIpO1xufVxuZnVuY3Rpb24gaW5zZXJ0U2VwYXJhdG9yKG51bVN0cmluZywgc2VwYXJhdG9yKSB7XG4gIGxldCBkb3RJbmRleCA9IG51bVN0cmluZy5pbmRleE9mKFwiLlwiKTtcbiAgaWYgKGRvdEluZGV4IDwgMCkge1xuICAgIGRvdEluZGV4ID0gbnVtU3RyaW5nLmxlbmd0aDtcbiAgfVxuICBjb25zdCBpbnRlZ2VyQ2hhcnMgPSBudW1TdHJpbmcuc3Vic3RyaW5nKDAsIGRvdEluZGV4KS5zcGxpdChcIlwiKTtcbiAgY29uc3QgZnJhY3Rpb25hbFBhcnQgPSBudW1TdHJpbmcuc3Vic3RyaW5nKGRvdEluZGV4KTtcbiAgZm9yIChsZXQgaSA9IGludGVnZXJDaGFycy5sZW5ndGggLSAzOyBpID4gMDsgaSAtPSAzKSB7XG4gICAgaW50ZWdlckNoYXJzLnNwbGljZShpLCAwLCBzZXBhcmF0b3IpO1xuICB9XG4gIHJldHVybiBgJHtpbnRlZ2VyQ2hhcnMuam9pbihcIlwiKX0ke2ZyYWN0aW9uYWxQYXJ0fWA7XG59XG5mdW5jdGlvbiBnZXRTSVByZWZpeChuKSB7XG4gIHJldHVybiBzaVByZWZpeGVzW2dldFNJUHJlZml4UG93ZXIobildO1xufVxuZnVuY3Rpb24gZ2V0U0lQcmVmaXhQb3dlcihuKSB7XG4gIHJldHVybiBjbGFtcChtaW5TSVByZWZpeCwgbiA/IE1hdGguZmxvb3IoTWF0aC5sb2cxMChNYXRoLmFicyhuKSkgLyAzKSAqIDMgOiAwLCBtYXhTSVByZWZpeCk7XG59XG5mdW5jdGlvbiBhZGRTaWduKG51bSwgbnVtU3RyaW5nLCBzaWduVHlwZSA9IFwiXCIpIHtcbiAgaWYgKHNpZ25UeXBlID09PSBcIihcIikge1xuICAgIHJldHVybiBudW0gPj0gMCA/IG51bVN0cmluZyA6IGAoJHtudW1TdHJpbmd9KWA7XG4gIH1cbiAgY29uc3QgcGx1c1NpZ24gPSBzaWduVHlwZSA9PT0gXCIrXCIgPyBcIitcIiA6IFwiXCI7XG4gIHJldHVybiBgJHtudW0gPj0gMCA/IHBsdXNTaWduIDogbWludXNTaWdufSR7bnVtU3RyaW5nfWA7XG59XG5mdW5jdGlvbiBhZGRQYWRkaW5nKG51bVN0cmluZywgd2lkdGgsIGZpbGwgPSBcIiBcIiwgYWxpZ24gPSBcIj5cIikge1xuICBsZXQgcmVzdWx0ID0gbnVtU3RyaW5nO1xuICBpZiAoYWxpZ24gPT09IFwiPlwiIHx8ICFhbGlnbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRTdGFydCh3aWR0aCwgZmlsbCk7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiPFwiKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZEVuZCh3aWR0aCwgZmlsbCk7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiXlwiKSB7XG4gICAgY29uc3QgcGFkV2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIGNvbnN0IHBhZExlZnQgPSBNYXRoLmNlaWwocGFkV2lkdGggLyAyKTtcbiAgICBjb25zdCBwYWRSaWdodCA9IE1hdGguZmxvb3IocGFkV2lkdGggLyAyKTtcbiAgICByZXN1bHQgPSByZXN1bHQucGFkU3RhcnQocGFkTGVmdCArIHJlc3VsdC5sZW5ndGgsIGZpbGwpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRFbmQocGFkUmlnaHQgKyByZXN1bHQubGVuZ3RoLCBmaWxsKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2FycmF5LnRzXG5mdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjazIpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHJlc3VsdHMucHVzaChjYWxsYmFjazIoaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gZXh0ZW50KHZhbHVlcykge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbWluID0gSW5maW5pdHk7XG4gIGxldCBtYXggPSAtSW5maW5pdHk7XG4gIGZvciAobGV0IG4gb2YgdmFsdWVzKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBuID0gbi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuIDwgbWluKSB7XG4gICAgICBtaW4gPSBuO1xuICAgIH1cbiAgICBpZiAobiA+IG1heCkge1xuICAgICAgbWF4ID0gbjtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW21pbiwgbWF4XTtcbiAgaWYgKHJlc3VsdC5ldmVyeShpc0Zpbml0ZSkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpc2VkRXh0ZW50KGQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KS5leHRlbnQ7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KSB7XG4gIGxldCBjbGlwcGVkID0gZmFsc2U7XG4gIGlmIChkLmxlbmd0aCA+IDIpIHtcbiAgICBkID0gZXh0ZW50KGQpID8/IFtOYU4sIE5hTl07XG4gIH1cbiAgaWYgKCFpc05hTihtaW4pKSB7XG4gICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1pbiA+IGRbMF0pO1xuICAgIGQgPSBbbWluLCBkWzFdXTtcbiAgfVxuICBpZiAoIWlzTmFOKG1heCkpIHtcbiAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWF4IDwgZFsxXSk7XG4gICAgZCA9IFtkWzBdLCBtYXhdO1xuICB9XG4gIGlmIChkWzBdID4gZFsxXSkge1xuICAgIGQgPSBbXTtcbiAgfVxuICByZXR1cm4geyBleHRlbnQ6IGQsIGNsaXBwZWQgfTtcbn1cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFbaV0pICYmIEFycmF5LmlzQXJyYXkoYltpXSkpIHtcbiAgICAgIGlmICghYXJyYXlzRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5mdW5jdGlvbiB1bmlxdWUoYXJyYXkyKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoYXJyYXkyKSk7XG59XG5mdW5jdGlvbiBncm91cEJ5KGFycmF5MiwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGFycmF5Mi5yZWR1Y2UoKHJlc3VsdCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGdyb3VwS2V5ID0gaXRlcmF0ZWUoaXRlbSk7XG4gICAgcmVzdWx0W2dyb3VwS2V5XSA/PyAocmVzdWx0W2dyb3VwS2V5XSA9IFtdKTtcbiAgICByZXN1bHRbZ3JvdXBLZXldLnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gY2lyY3VsYXJTbGljZUFycmF5KGRhdGEsIHNpemUsIG9mZnNldDQgPSAwKSB7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChkYXRhLmF0KChpICsgb2Zmc2V0NCkgJSBkYXRhLmxlbmd0aCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBiaWZ1cmNhdGUoaXNMZWZ0LCBhcnJheTIpIHtcbiAgcmV0dXJuIGFycmF5Mi5yZWR1Y2UoXG4gICAgKFtsZWZ0LCByaWdodF0sIHZhbHVlKSA9PiBpc0xlZnQodmFsdWUpID8gW1suLi5sZWZ0LCB2YWx1ZV0sIHJpZ2h0XSA6IFtsZWZ0LCBbLi4ucmlnaHQsIHZhbHVlXV0sXG4gICAgW1tdLCBbXV1cbiAgKTtcbn1cbmZ1bmN0aW9uKiBtYXBJdGVyYWJsZShzcmMsIHByZWRpY2F0ZSkge1xuICBmb3IgKGNvbnN0IGUgb2Ygc3JjKSB7XG4gICAgeWllbGQgcHJlZGljYXRlKGUpO1xuICB9XG59XG5mdW5jdGlvbiBjb25zdFN0cmluZ3NJbmNsdWRlcyhhcnJheTIsIHZhbHVlKSB7XG4gIGNvbnN0IGNhc3RpbmcgPSBhcnJheTI7XG4gIHJldHVybiBjYXN0aW5nLmluY2x1ZGVzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzSW5TdHJpbmdVbmlvbih1bmlvblZhbHVlcywgdmFsdWUpIHtcbiAgcmV0dXJuIGNvbnN0U3RyaW5nc0luY2x1ZGVzKHVuaW9uVmFsdWVzLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBhbGxJblN0cmluZ1VuaW9uKHVuaW9uVmFsdWVzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuICF2YWx1ZXMuc29tZSgodikgPT4gIWlzSW5TdHJpbmdVbmlvbih1bmlvblZhbHVlcywgdikpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpY2tzLnRzXG52YXIgdEludGVydmFsID0gKHRpbWVJbnRlcnZhbCwgYmFzZUR1cmF0aW9uLCBzdGVwKSA9PiAoe1xuICBkdXJhdGlvbjogYmFzZUR1cmF0aW9uICogc3RlcCxcbiAgdGltZUludGVydmFsLFxuICBzdGVwXG59KTtcbnZhciBUaWNrSW50ZXJ2YWxzID0gW1xuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCAxKSxcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgNSksXG4gIHRJbnRlcnZhbChzZWNvbmRfZGVmYXVsdCwgZHVyYXRpb25TZWNvbmQsIDE1KSxcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgMzApLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCAxKSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgNSksXG4gIHRJbnRlcnZhbChtaW51dGVfZGVmYXVsdCwgZHVyYXRpb25NaW51dGUsIDE1KSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgMzApLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDEpLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDMpLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDYpLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDEyKSxcbiAgdEludGVydmFsKGRheV9kZWZhdWx0LCBkdXJhdGlvbkRheSwgMSksXG4gIHRJbnRlcnZhbChkYXlfZGVmYXVsdCwgZHVyYXRpb25EYXksIDIpLFxuICB0SW50ZXJ2YWwod2Vla19kZWZhdWx0LCBkdXJhdGlvbldlZWssIDEpLFxuICB0SW50ZXJ2YWwod2Vla19kZWZhdWx0LCBkdXJhdGlvbldlZWssIDIpLFxuICB0SW50ZXJ2YWwod2Vla19kZWZhdWx0LCBkdXJhdGlvbldlZWssIDMpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgMSksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCAyKSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDMpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgNCksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCA2KSxcbiAgdEludGVydmFsKHllYXJfZGVmYXVsdCwgZHVyYXRpb25ZZWFyLCAxKVxuXTtcbnZhciBUaWNrTXVsdGlwbGllcnMgPSBbMSwgMiwgNSwgMTBdO1xuZnVuY3Rpb24gY3JlYXRlVGlja3Moc3RhcnQsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQpIHtcbiAgaWYgKGNvdW50IDwgMikge1xuICAgIHJldHVybiByYW5nZShzdGFydCwgc3RvcCwgc3RvcCAtIHN0YXJ0KTtcbiAgfVxuICBjb25zdCBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQpO1xuICBpZiAoaXNOYU4oc3RlcCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gIHJldHVybiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCk7XG59XG5mdW5jdGlvbiBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQsIHRhcmdldEludGVydmFsKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRhcmdldEludGVydmFsID8/IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heChjb3VudCwgMSk7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCB0aWNrSW50ZXJ2YWwgb2YgVGlja0ludGVydmFscykge1xuICAgIGlmICh0YXJnZXQgPD0gdGlja0ludGVydmFsLmR1cmF0aW9uKVxuICAgICAgYnJlYWs7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgY29uc3Qgc3RlcDIgPSBNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCksIDEpO1xuICAgIHJldHVybiBtaWxsaXNlY29uZF9kZWZhdWx0LmV2ZXJ5KHN0ZXAyKTtcbiAgfSBlbHNlIGlmIChpID09PSBUaWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgIGNvbnN0IHN0ZXAyID0gdGFyZ2V0SW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSA6IDE7XG4gICAgcmV0dXJuIHllYXJfZGVmYXVsdC5ldmVyeShzdGVwMik7XG4gIH1cbiAgY29uc3QgaTAgPSBUaWNrSW50ZXJ2YWxzW2kgLSAxXTtcbiAgY29uc3QgaTEgPSBUaWNrSW50ZXJ2YWxzW2ldO1xuICBjb25zdCB7IHRpbWVJbnRlcnZhbCwgc3RlcCB9ID0gdGFyZ2V0IC0gaTAuZHVyYXRpb24gPCBpMS5kdXJhdGlvbiAtIHRhcmdldCA/IGkwIDogaTE7XG4gIHJldHVybiB0aW1lSW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG59XG5mdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgZW5kLCBjb3VudCwgbWluQ291bnQgPSAwLCBtYXhDb3VudCA9IEluZmluaXR5KSB7XG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKGNvdW50IDwgMSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgY29uc3QgZXh0ZW50MiA9IE1hdGguYWJzKGVuZCAtIHN0YXJ0KTtcbiAgY29uc3Qgc3RlcCA9IDEwICoqIE1hdGguZmxvb3IoTWF0aC5sb2cxMChleHRlbnQyIC8gY291bnQpKTtcbiAgbGV0IG0gPSBOYU4sIG1pbkRpZmYgPSBJbmZpbml0eSwgaXNJbkJvdW5kcyA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IG11bHRpcGxpZXIgb2YgVGlja011bHRpcGxpZXJzKSB7XG4gICAgY29uc3QgYyA9IE1hdGguY2VpbChleHRlbnQyIC8gKG11bHRpcGxpZXIgKiBzdGVwKSk7XG4gICAgY29uc3QgdmFsaWRCb3VuZHMgPSBjID49IG1pbkNvdW50ICYmIGMgPD0gbWF4Q291bnQ7XG4gICAgaWYgKGlzSW5Cb3VuZHMgJiYgIXZhbGlkQm91bmRzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgZGlmZkNvdW50ID0gTWF0aC5hYnMoYyAtIGNvdW50KTtcbiAgICBpZiAobWluRGlmZiA+IGRpZmZDb3VudCB8fCBpc0luQm91bmRzICE9PSB2YWxpZEJvdW5kcykge1xuICAgICAgaXNJbkJvdW5kcyB8fCAoaXNJbkJvdW5kcyA9IHZhbGlkQm91bmRzKTtcbiAgICAgIG1pbkRpZmYgPSBkaWZmQ291bnQ7XG4gICAgICBtID0gbXVsdGlwbGllcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0gKiBzdGVwO1xufVxuZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhkZWNpbWFsKSB7XG4gIGZvciAobGV0IGkgPSBkZWNpbWFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgaWYgKGRlY2ltYWxbaV0gIT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdGlja0Zvcm1hdCh0aWNrcywgZm9ybWF0KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUZvcm1hdChmb3JtYXQgPz8gXCIsZlwiKTtcbiAgaWYgKG9wdGlvbnMucHJlY2lzaW9uID09IG51bGwgfHwgaXNOYU4ob3B0aW9ucy5wcmVjaXNpb24pKSB7XG4gICAgaWYgKCFvcHRpb25zLnR5cGUgfHwgXCJlRUZnR25wcnNcIi5pbmNsdWRlcyhvcHRpb25zLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAuLi50aWNrcy5tYXAoKHgpID0+IHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyLCBkZWNpbWFsXSA9IHgudG9FeHBvbmVudGlhbCgob3B0aW9ucy50eXBlID8gNiA6IDEyKSAtIDEpLnNwbGl0KC9cXC58ZS9nKTtcbiAgICAgICAgICByZXR1cm4gKGludGVnZXIgIT09IFwiMVwiICYmIGludGVnZXIgIT09IFwiLTFcIiA/IDEgOiAwKSArIGRlY2ltYWxQbGFjZXMoZGVjaW1hbCkgKyAxO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFwiZiVcIi5pbmNsdWRlcyhvcHRpb25zLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAuLi50aWNrcy5tYXAoKHgpID0+IHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCB4ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgbCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChNYXRoLmFicyh4KSkpO1xuICAgICAgICAgIGNvbnN0IGRpZ2l0cyA9IG9wdGlvbnMudHlwZSA/IDYgOiAxMjtcbiAgICAgICAgICBjb25zdCBbX2ludGVnZXIsIGRlY2ltYWxdID0geC50b0V4cG9uZW50aWFsKGRpZ2l0cyAtIDEpLnNwbGl0KC9cXC58ZS9nKTtcbiAgICAgICAgICBjb25zdCBkZWNpbWFsTGVuZ3RoID0gZGVjaW1hbFBsYWNlcyhkZWNpbWFsKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGVjaW1hbExlbmd0aCAtIGwpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZm9ybWF0dGVyID0gbnVtYmVyRm9ybWF0KG9wdGlvbnMpO1xuICByZXR1cm4gKG4pID0+IGZvcm1hdHRlcihOdW1iZXIobikpO1xufVxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICBjb25zdCBuID0gTWF0aC5jZWlsKE1hdGguYWJzKGVuZCAtIHN0YXJ0KSAvIHN0ZXApO1xuICBjb25zdCBmID0gMTAgKiogY291bnRGcmFjdGlvbkRpZ2l0cyhzdGVwKTtcbiAgY29uc3QgZDAgPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgcmV0dXJuIHRpbWVzKG4gKyAxLCAoaSkgPT4gTWF0aC5yb3VuZCgoZDAgKyBzdGVwICogaSkgKiBmKSAvIGYpO1xufVxuZnVuY3Rpb24gaXNEZW5zZUludGVydmFsKGNvdW50LCBhdmFpbGFibGVSYW5nZSkge1xuICBpZiAoY291bnQgPj0gYXZhaWxhYmxlUmFuZ2UpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICBgdGhlIGNvbmZpZ3VyZWQgaW50ZXJ2YWwgcmVzdWx0cyBpbiBtb3JlIHRoYW4gMSBpdGVtIHBlciBwaXhlbCwgaWdub3JpbmcuIFN1cHBseSBhIGxhcmdlciBpbnRlcnZhbCBvciBvbWl0IHRoaXMgY29uZmlndXJhdGlvbmBcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5pY2VUaWNrc0RvbWFpbihzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGV4dGVudDIgPSBNYXRoLmFicyhlbmQgLSBzdGFydCk7XG4gIGNvbnN0IHN0ZXAgPSAxMCAqKiBNYXRoLmZsb29yKE1hdGgubG9nMTAoZXh0ZW50MikpO1xuICBsZXQgbWluRXJyb3IgPSBJbmZpbml0eSwgdGlja3MgPSBbc3RhcnQsIGVuZF07XG4gIGZvciAoY29uc3QgbXVsdGlwbGllciBvZiBUaWNrTXVsdGlwbGllcnMpIHtcbiAgICBjb25zdCBtID0gbXVsdGlwbGllciAqIHN0ZXA7XG4gICAgY29uc3QgZDAgPSBNYXRoLmZsb29yKHN0YXJ0IC8gbSkgKiBtO1xuICAgIGNvbnN0IGQxID0gTWF0aC5jZWlsKGVuZCAvIG0pICogbTtcbiAgICBjb25zdCBlcnJvciA9IDEgLSBleHRlbnQyIC8gTWF0aC5hYnMoZDEgLSBkMCk7XG4gICAgaWYgKG1pbkVycm9yID4gZXJyb3IpIHtcbiAgICAgIG1pbkVycm9yID0gZXJyb3I7XG4gICAgICB0aWNrcyA9IFtkMCwgZDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZVRpY2tDb3VudChyYW5nZUV4dGVudCwgbWluU3BhY2luZywgbWF4U3BhY2luZywgZGVmYXVsdFRpY2tDb3VudCwgZGVmYXVsdE1pblNwYWNpbmcpIHtcbiAgZGVmYXVsdE1pblNwYWNpbmcgPSBNYXRoLm1heChkZWZhdWx0TWluU3BhY2luZywgcmFuZ2VFeHRlbnQgLyAoZGVmYXVsdFRpY2tDb3VudCArIDEpKTtcbiAgaWYgKGlzTmFOKG1pblNwYWNpbmcpKSB7XG4gICAgbWluU3BhY2luZyA9IGRlZmF1bHRNaW5TcGFjaW5nO1xuICB9XG4gIGlmIChpc05hTihtYXhTcGFjaW5nKSkge1xuICAgIG1heFNwYWNpbmcgPSByYW5nZUV4dGVudDtcbiAgfVxuICBpZiAobWluU3BhY2luZyA+IG1heFNwYWNpbmcpIHtcbiAgICBpZiAobWluU3BhY2luZyA9PT0gZGVmYXVsdE1pblNwYWNpbmcpIHtcbiAgICAgIG1pblNwYWNpbmcgPSBtYXhTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhTcGFjaW5nID0gbWluU3BhY2luZztcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4VGlja0NvdW50ID0gY2xhbXAoMSwgTWF0aC5mbG9vcihyYW5nZUV4dGVudCAvIG1pblNwYWNpbmcpLCBNYXRoLm1pbihNYXRoLmZsb29yKHJhbmdlRXh0ZW50KSwgMTAwKSk7XG4gIGNvbnN0IG1pblRpY2tDb3VudCA9IE1hdGgubWluKG1heFRpY2tDb3VudCwgTWF0aC5jZWlsKHJhbmdlRXh0ZW50IC8gbWF4U3BhY2luZykpO1xuICBjb25zdCB0aWNrQ291bnQgPSBjbGFtcChtaW5UaWNrQ291bnQsIGRlZmF1bHRUaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gIHJldHVybiB7IG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50LCB0aWNrQ291bnQgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvbG9nU2NhbGUudHNcbnZhciBfTG9nU2NhbGUgPSBjbGFzcyBfTG9nU2NhbGUgZXh0ZW5kcyBDb250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbMSwgMTBdLCBbMCwgMV0pO1xuICAgIHRoaXMudHlwZSA9IFwibG9nXCI7XG4gICAgdGhpcy5iYXNlID0gMTA7XG4gICAgdGhpcy5iYXNlTG9nID0gaWRlbnRpdHk7XG4gICAgdGhpcy5iYXNlUG93ID0gaWRlbnRpdHk7XG4gICAgdGhpcy5sb2cgPSAoeCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbiguLi50aGlzLmRvbWFpbik7XG4gICAgICByZXR1cm4gc3RhcnQgPj0gMCA/IHRoaXMuYmFzZUxvZyh4KSA6IC10aGlzLmJhc2VMb2coLXgpO1xuICAgIH07XG4gICAgdGhpcy5wb3cgPSAoeCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbiguLi50aGlzLmRvbWFpbik7XG4gICAgICByZXR1cm4gc3RhcnQgPj0gMCA/IHRoaXMuYmFzZVBvdyh4KSA6IC10aGlzLmJhc2VQb3coLXgpO1xuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0Q2xhbXBNb2RlID0gXCJjbGFtcGVkXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHRyYW5zZm9ybSh4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbiguLi50aGlzLmRvbWFpbik7XG4gICAgcmV0dXJuIHN0YXJ0ID49IDAgPyBNYXRoLmxvZyh4KSA6IC1NYXRoLmxvZygteCk7XG4gIH1cbiAgdHJhbnNmb3JtSW52ZXJ0KHgpIHtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICByZXR1cm4gc3RhcnQgPj0gMCA/IE1hdGguZXhwKHgpIDogLU1hdGguZXhwKC14KTtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLmJhc2UgPD0gMCkge1xuICAgICAgdGhpcy5iYXNlID0gMDtcbiAgICAgIExvZ2dlci53YXJuT25jZShcImV4cGVjdGluZyBhIGZpbml0ZSBOdW1iZXIgZ3JlYXRlciB0aGFuIHRvIDBcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlZnJlc2goKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmFzZUxvZyA9IF9Mb2dTY2FsZS5nZXRCYXNlTG9nTWV0aG9kKHRoaXMuYmFzZSk7XG4gICAgdGhpcy5iYXNlUG93ID0gX0xvZ1NjYWxlLmdldEJhc2VQb3dlck1ldGhvZCh0aGlzLmJhc2UpO1xuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOaWNlRG9tYWluKCkge1xuICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5kb21haW47XG4gICAgY29uc3Qgcm91bmRTdGFydCA9IGQwID4gZDEgPyBNYXRoLmNlaWwgOiBNYXRoLmZsb29yO1xuICAgIGNvbnN0IHJvdW5kU3RvcCA9IGQwID4gZDEgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsO1xuICAgIGNvbnN0IG4wID0gdGhpcy5wb3cocm91bmRTdGFydCh0aGlzLmxvZyhkMCkpKTtcbiAgICBjb25zdCBuMSA9IHRoaXMucG93KHJvdW5kU3RvcCh0aGlzLmxvZyhkMSkpKTtcbiAgICB0aGlzLm5pY2VEb21haW4gPSBbbjAsIG4xXTtcbiAgfVxuICB0aWNrcygpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGlja0NvdW50ID8/IDEwO1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMiB8fCBjb3VudCA8IDEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihkMCwgZDEpO1xuICAgIGNvbnN0IHN0b3AgPSBNYXRoLm1heChkMCwgZDEpO1xuICAgIGxldCBwMCA9IHRoaXMubG9nKHN0YXJ0KTtcbiAgICBsZXQgcDEgPSB0aGlzLmxvZyhzdG9wKTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgY29uc3QgaW5Cb3VuZHMgPSAodGljaykgPT4gdGljayA+PSBzdGFydCAmJiB0aWNrIDw9IHN0b3A7XG4gICAgICBjb25zdCBzdGVwID0gTWF0aC5taW4oTWF0aC5hYnModGhpcy5pbnRlcnZhbCksIE1hdGguYWJzKHAxIC0gcDApKTtcbiAgICAgIGNvbnN0IHRpY2tzMiA9IHJhbmdlKHAwLCBwMSwgc3RlcCkubWFwKHRoaXMucG93KS5maWx0ZXIoaW5Cb3VuZHMpO1xuICAgICAgaWYgKCFpc0RlbnNlSW50ZXJ2YWwodGlja3MyLmxlbmd0aCwgdGhpcy5nZXRQaXhlbFJhbmdlKCkpKSB7XG4gICAgICAgIHJldHVybiB0aWNrczI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzQmFzZUludGVnZXIgPSBiYXNlICUgMSA9PT0gMDtcbiAgICBjb25zdCBpc0RpZmZMYXJnZSA9IHAxIC0gcDAgPj0gY291bnQ7XG4gICAgaWYgKCFpc0Jhc2VJbnRlZ2VyIHx8IGlzRGlmZkxhcmdlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGlja3MocDAsIHAxLCBNYXRoLm1pbihwMSAtIHAwLCBjb3VudCkpLm1hcCh0aGlzLnBvdyk7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgaXNQb3NpdGl2ZSA9IHN0YXJ0ID4gMDtcbiAgICBwMCA9IE1hdGguZmxvb3IocDApIC0gMTtcbiAgICBwMSA9IE1hdGgucm91bmQocDEpICsgMTtcbiAgICBjb25zdCBhdmFpbGFibGVTcGFjaW5nID0gZmluZFJhbmdlRXh0ZW50KHRoaXMucmFuZ2UpIC8gY291bnQ7XG4gICAgbGV0IGxhc3RUaWNrUG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBwID0gcDA7IHAgPD0gcDE7IHArKykge1xuICAgICAgY29uc3QgbmV4dE1hZ25pdHVkZVRpY2tQb3NpdGlvbiA9IHRoaXMuY29udmVydCh0aGlzLnBvdyhwICsgMSkpO1xuICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBiYXNlOyBrKyspIHtcbiAgICAgICAgY29uc3QgcSA9IGlzUG9zaXRpdmUgPyBrIDogYmFzZSAtIGsgKyAxO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5wb3cocCkgKiBxO1xuICAgICAgICBjb25zdCB0aWNrUG9zaXRpb24gPSB0aGlzLmNvbnZlcnQodCk7XG4gICAgICAgIGNvbnN0IHByZXZTcGFjaW5nID0gTWF0aC5hYnMobGFzdFRpY2tQb3NpdGlvbiAtIHRpY2tQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IG5leHRTcGFjaW5nID0gTWF0aC5hYnModGlja1Bvc2l0aW9uIC0gbmV4dE1hZ25pdHVkZVRpY2tQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGZpdHMgPSBwcmV2U3BhY2luZyA+PSBhdmFpbGFibGVTcGFjaW5nICYmIG5leHRTcGFjaW5nID49IGF2YWlsYWJsZVNwYWNpbmc7XG4gICAgICAgIGlmICh0ID49IHN0YXJ0ICYmIHQgPD0gc3RvcCAmJiAoayA9PT0gMSB8fCBmaXRzIHx8IHRpY2tzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICB0aWNrcy5wdXNoKHQpO1xuICAgICAgICAgIGxhc3RUaWNrUG9zaXRpb24gPSB0aWNrUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIHRpY2tGb3JtYXQoe1xuICAgIGNvdW50LFxuICAgIHRpY2tzLFxuICAgIHNwZWNpZmllclxuICB9KSB7XG4gICAgaWYgKGNvdW50ICE9PSBJbmZpbml0eSAmJiB0aWNrcyA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRpY2tzKCk7XG4gICAgfVxuICAgIHNwZWNpZmllciA/PyAoc3BlY2lmaWVyID0gdGhpcy5iYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIik7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHNwZWNpZmllcikgPyBudW1iZXJGb3JtYXQoc3BlY2lmaWVyKSA6IHNwZWNpZmllcjtcbiAgfVxuICBzdGF0aWMgZ2V0QmFzZUxvZ01ldGhvZChiYXNlKSB7XG4gICAgc3dpdGNoIChiYXNlKSB7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gTWF0aC5sb2cxMDtcbiAgICAgIGNhc2UgTWF0aC5FOlxuICAgICAgICByZXR1cm4gTWF0aC5sb2c7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zdCBsb2dCYXNlID0gTWF0aC5sb2coYmFzZSk7XG4gICAgICAgIHJldHVybiAoeCkgPT4gTWF0aC5sb2coeCkgLyBsb2dCYXNlO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0QmFzZVBvd2VyTWV0aG9kKGJhc2UpIHtcbiAgICBzd2l0Y2ggKGJhc2UpIHtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiAoeCkgPT4geCA+PSAwID8gMTAgKiogeCA6IDEgLyAxMCAqKiAteDtcbiAgICAgIGNhc2UgTWF0aC5FOlxuICAgICAgICByZXR1cm4gTWF0aC5leHA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKHgpID0+IGJhc2UgKiogeDtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Mb2dTY2FsZS5wcm90b3R5cGUsIFwiYmFzZVwiLCAyKTtcbnZhciBMb2dTY2FsZSA9IF9Mb2dTY2FsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvdGltZVNjYWxlLnRzXG52YXIgVGltZVNjYWxlID0gY2xhc3MgX1RpbWVTY2FsZSBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFtdLCBbMCwgMV0pO1xuICAgIHRoaXMudHlwZSA9IFwidGltZVwiO1xuICB9XG4gIHRvRG9tYWluKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZCk7XG4gIH1cbiAgY29udmVydCh4LCBvcHRzKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbnZlcnQobmV3IERhdGUoeCksIG9wdHMpO1xuICB9XG4gIGludmVydCh5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN1cGVyLmludmVydCh5KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdW5pZm9ybWx5LXNwYWNlZCBkYXRlcyB0aGF0IHJlcHJlc2VudCB0aGUgc2NhbGUncyBkb21haW4uXG4gICAqL1xuICB0aWNrcygpIHtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgeyBpbnRlcnZhbCwgbmljZSwgdGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9ID0gdGhpcztcbiAgICBjb25zdCBbc3RhcnQsIHN0b3BdID0gZmluZE1pbk1heCh0aGlzLmdldERvbWFpbigpLm1hcChkYXRlVG9OdW1iZXIpKTtcbiAgICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9UaW1lU2NhbGUuZ2V0VGlja3NGb3JJbnRlcnZhbCh7IHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCwgYXZhaWxhYmxlUmFuZ2U6IHRoaXMuZ2V0UGl4ZWxSYW5nZSgpIH0pID8/IF9UaW1lU2NhbGUuZ2V0RGVmYXVsdFRpY2tzKHsgc3RhcnQsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQgfSk7XG4gICAgfSBlbHNlIGlmIChuaWNlICYmIHRpY2tDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMubmljZURvbWFpbjtcbiAgICB9IGVsc2UgaWYgKG5pY2UgJiYgdGlja0NvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5uaWNlRG9tYWluLnNsaWNlKDAsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gX1RpbWVTY2FsZS5nZXREZWZhdWx0VGlja3MoeyBzdGFydCwgc3RvcCwgdGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdFRpY2tzKHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIHRpY2tDb3VudCxcbiAgICBtaW5UaWNrQ291bnQsXG4gICAgbWF4VGlja0NvdW50XG4gIH0pIHtcbiAgICBjb25zdCB0ID0gZ2V0VGlja0ludGVydmFsKHN0YXJ0LCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICByZXR1cm4gdCA/IHQucmFuZ2UobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShzdG9wKSkgOiBbXTtcbiAgfVxuICBzdGF0aWMgZ2V0VGlja3NGb3JJbnRlcnZhbCh7XG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICBpbnRlcnZhbCxcbiAgICBhdmFpbGFibGVSYW5nZVxuICB9KSB7XG4gICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaW50ZXJ2YWwgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHRpY2tzMiA9IGludGVydmFsLnJhbmdlKG5ldyBEYXRlKHN0YXJ0KSwgbmV3IERhdGUoc3RvcCkpO1xuICAgICAgaWYgKGlzRGVuc2VJbnRlcnZhbCh0aWNrczIubGVuZ3RoLCBhdmFpbGFibGVSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tzMjtcbiAgICB9XG4gICAgY29uc3QgYWJzSW50ZXJ2YWwgPSBNYXRoLmFicyhpbnRlcnZhbCk7XG4gICAgaWYgKGlzRGVuc2VJbnRlcnZhbCgoc3RvcCAtIHN0YXJ0KSAvIGFic0ludGVydmFsLCBhdmFpbGFibGVSYW5nZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmV2ZXJzZWRJbnRlcnZhbCA9IFsuLi5UaWNrSW50ZXJ2YWxzXS5yZXZlcnNlKCk7XG4gICAgY29uc3QgdGltZUludGVydmFsID0gcmV2ZXJzZWRJbnRlcnZhbC5maW5kKCh0aWNrSW50ZXJ2YWwpID0+IGFic0ludGVydmFsICUgdGlja0ludGVydmFsLmR1cmF0aW9uID09PSAwKTtcbiAgICBpZiAodGltZUludGVydmFsKSB7XG4gICAgICBjb25zdCBpID0gdGltZUludGVydmFsLnRpbWVJbnRlcnZhbC5ldmVyeShhYnNJbnRlcnZhbCAvICh0aW1lSW50ZXJ2YWwuZHVyYXRpb24gLyB0aW1lSW50ZXJ2YWwuc3RlcCkpO1xuICAgICAgcmV0dXJuIGkucmFuZ2UobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShzdG9wKSk7XG4gICAgfVxuICAgIGxldCBkYXRlID0gbmV3IERhdGUoc3RhcnQpO1xuICAgIGNvbnN0IHN0b3BEYXRlID0gbmV3IERhdGUoc3RvcCk7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICB3aGlsZSAoZGF0ZSA8PSBzdG9wRGF0ZSkge1xuICAgICAgdGlja3MucHVzaChkYXRlKTtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKyBhYnNJbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHRpbWUgZm9ybWF0IGZ1bmN0aW9uIHN1aXRhYmxlIGZvciBkaXNwbGF5aW5nIHRpY2sgdmFsdWVzLlxuICAgKiBAcGFyYW0gc3BlY2lmaWVyIElmIHRoZSBzcGVjaWZpZXIgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvXG4gICAqIHRoZSB7QGxpbmsgVGltZUxvY2FsZU9iamVjdC5mb3JtYXR9IG1ldGhvZC5cbiAgICogSWYgbm8gc3BlY2lmaWVyIGlzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBkZWZhdWx0IHRpbWUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgKi9cbiAgdGlja0Zvcm1hdCh7XG4gICAgdGlja3MsXG4gICAgZG9tYWluLFxuICAgIHNwZWNpZmllcixcbiAgICBmb3JtYXRPZmZzZXRcbiAgfSkge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IGRlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQpIDogYnVpbGRGb3JtYXR0ZXIoc3BlY2lmaWVyKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0ZW5kcyB0aGUgZG9tYWluIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG9uIG5pY2Ugcm91bmQgdmFsdWVzLlxuICAgKiBUaGlzIG1ldGhvZCB0eXBpY2FsbHkgbW9kaWZpZXMgdGhlIHNjYWxl4oCZcyBkb21haW4sIGFuZCBtYXkgb25seSBleHRlbmQgdGhlIGJvdW5kcyB0byB0aGUgbmVhcmVzdCByb3VuZCB2YWx1ZS5cbiAgICovXG4gIHVwZGF0ZU5pY2VEb21haW4oKSB7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA0O1xuICAgIGxldCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluSXRlcmF0aW9uKGQwLCBkMSk7XG4gICAgICBjb25zdCBbbjAsIG4xXSA9IHRoaXMubmljZURvbWFpbjtcbiAgICAgIGlmIChkYXRlVG9OdW1iZXIoZDApID09PSBkYXRlVG9OdW1iZXIobjApICYmIGRhdGVUb051bWJlcihkMSkgPT09IGRhdGVUb051bWJlcihuMSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkMCA9IG4wO1xuICAgICAgZDEgPSBuMTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTmljZURvbWFpbkl0ZXJhdGlvbihkMCwgZDEpIHtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKGRhdGVUb051bWJlcihkMCksIGRhdGVUb051bWJlcihkMSkpO1xuICAgIGNvbnN0IHN0b3AgPSBNYXRoLm1heChkYXRlVG9OdW1iZXIoZDApLCBkYXRlVG9OdW1iZXIoZDEpKTtcbiAgICBjb25zdCBpc1JldmVyc2VkID0gZDAgPiBkMTtcbiAgICBjb25zdCB7IGludGVydmFsIH0gPSB0aGlzO1xuICAgIGxldCBpO1xuICAgIGlmIChpbnRlcnZhbCBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCkge1xuICAgICAgaSA9IGludGVydmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aWNrQ291bnQgPSB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgPyAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KGludGVydmFsLCAxKSA6IHRoaXMudGlja0NvdW50O1xuICAgICAgaSA9IGdldFRpY2tJbnRlcnZhbChzdGFydCwgc3RvcCwgdGlja0NvdW50LCB0aGlzLm1pblRpY2tDb3VudCwgdGhpcy5tYXhUaWNrQ291bnQpO1xuICAgIH1cbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgaW50ZXJ2YWxSYW5nZSA9IGkucmFuZ2UobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShzdG9wKSwgdHJ1ZSk7XG4gICAgICBjb25zdCBkb21haW4gPSBpc1JldmVyc2VkID8gWy4uLmludGVydmFsUmFuZ2VdLnJldmVyc2UoKSA6IGludGVydmFsUmFuZ2U7XG4gICAgICBjb25zdCBuMCA9IGRvbWFpblswXTtcbiAgICAgIGNvbnN0IG4xID0gZG9tYWluLmF0KC0xKTtcbiAgICAgIHRoaXMubmljZURvbWFpbiA9IFtuMCwgbjFdO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvb3JkaW5hbFRpbWVTY2FsZS50c1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG52YXIgX09yZGluYWxUaW1lU2NhbGUgPSBjbGFzcyBfT3JkaW5hbFRpbWVTY2FsZSBleHRlbmRzIEJhbmRTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJvcmRpbmFsLXRpbWVcIjtcbiAgICB0aGlzLnRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xuICAgIHRoaXMubWluVGlja0NvdW50ID0gMDtcbiAgICB0aGlzLm1heFRpY2tDb3VudCA9IEluZmluaXR5O1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgdGhpcy50aW1lc3RhbXBzID0gW107XG4gICAgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzID0gW107XG4gICAgdGhpcy52aXNpYmxlUmFuZ2UgPSBbMCwgMV07XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX09yZGluYWxUaW1lU2NhbGU7XG4gIH1cbiAgc2V0VmlzaWJsZVJhbmdlKHZpc2libGVSYW5nZSkge1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gdmlzaWJsZVJhbmdlO1xuICB9XG4gIHNldCBkb21haW4odmFsdWVzKSB7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RvbWFpbiA9IHZhbHVlcztcbiAgICB0aGlzLnRpbWVzdGFtcHMgPSB1bmlxdWUodmFsdWVzLm1hcChkYXRlVG9OdW1iZXIpKTtcbiAgICB0aGlzLnNvcnRlZFRpbWVzdGFtcHMgPSB0aGlzLnRpbWVzdGFtcHMuc2xpY2UoKS5zb3J0KGNvbXBhcmVOdW1iZXJzKTtcbiAgfVxuICBnZXQgZG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgW3QwLCB0MV0gPSBbdGhpcy50aW1lc3RhbXBzWzBdLCB0aGlzLnRpbWVzdGFtcHMuYXQoLTEpXTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHQwLCB0MSk7XG4gICAgY29uc3Qgc3RvcCA9IE1hdGgubWF4KHQwLCB0MSk7XG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IHQwID4gdDE7XG4gICAgbGV0IHRpY2tzO1xuICAgIGlmICh0aGlzLmludGVydmFsID09IG51bGwpIHtcbiAgICAgIHRpY2tzID0gdGhpcy5nZXREZWZhdWx0VGlja3ModGhpcy5tYXhUaWNrQ291bnQsIGlzUmV2ZXJzZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbcjAsIHIxXSA9IHRoaXMucmFuZ2U7XG4gICAgICBjb25zdCBhdmFpbGFibGVSYW5nZSA9IE1hdGguYWJzKHIxIC0gcjApO1xuICAgICAgdGlja3MgPSBUaW1lU2NhbGUuZ2V0VGlja3NGb3JJbnRlcnZhbCh7IHN0YXJ0LCBzdG9wLCBpbnRlcnZhbDogdGhpcy5pbnRlcnZhbCwgYXZhaWxhYmxlUmFuZ2UgfSkgPz8gW107XG4gICAgfVxuICAgIGNvbnN0IHRpY2tQb3NpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHJldHVybiB0aWNrcy5maWx0ZXIoKHRpY2spID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5jb252ZXJ0KHRpY2spO1xuICAgICAgaWYgKGlzTmFOKHBvc2l0aW9uKSB8fCB0aWNrUG9zaXRpb25zLmhhcyhwb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGlja1Bvc2l0aW9ucy5hZGQocG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGVmYXVsdFRpY2tzKG1heFRpY2tDb3VudCwgaXNSZXZlcnNlZCkge1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRpbWVzdGFtcHMubGVuZ3RoO1xuICAgIGNvbnN0IHRpY2tFdmVyeSA9IE1hdGguY2VpbChjb3VudCAqICh0aGlzLnZpc2libGVSYW5nZVsxXSAtIHRoaXMudmlzaWJsZVJhbmdlWzBdKSAvIG1heFRpY2tDb3VudCk7XG4gICAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IodGlja0V2ZXJ5IC8gMik7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHZhbHVlXSBvZiB0aGlzLnRpbWVzdGFtcHMuZW50cmllcygpKSB7XG4gICAgICBpZiAodGlja0V2ZXJ5ID4gMCAmJiAoaW5kZXggKyB0aWNrT2Zmc2V0KSAlIHRpY2tFdmVyeSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICB0aWNrcy5wdXNoKG5ldyBEYXRlKHRoaXMudGltZXN0YW1wc1tjb3VudCAtIGluZGV4IC0gMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tzLnB1c2gobmV3IERhdGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGNvbnZlcnQoZCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IG4gPSBOdW1iZXIoZCk7XG4gICAgaWYgKG4gPCB0aGlzLnNvcnRlZFRpbWVzdGFtcHNbMF0pIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGxldCBpID0gdGhpcy5maW5kSW50ZXJ2YWwobik7XG4gICAgaWYgKHRoaXMudGltZXN0YW1wc1swXSAhPT0gdGhpcy5zb3J0ZWRUaW1lc3RhbXBzWzBdKSB7XG4gICAgICBpID0gdGhpcy50aW1lc3RhbXBzLmxlbmd0aCAtIGkgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmRpbmFsUmFuZ2VbaV0gPz8gTmFOO1xuICB9XG4gIGZpbmRJbnRlcnZhbCh0YXJnZXQpIHtcbiAgICBjb25zdCB7IHNvcnRlZFRpbWVzdGFtcHMgfSA9IHRoaXM7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBzb3J0ZWRUaW1lc3RhbXBzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKHNvcnRlZFRpbWVzdGFtcHNbbWlkXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZFRpbWVzdGFtcHNbbWlkXSA8IHRhcmdldCkge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aW1lIGZvcm1hdCBmdW5jdGlvbiBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0aWNrIHZhbHVlcy5cbiAgICogQHBhcmFtIHNwZWNpZmllciBJZiB0aGUgc3BlY2lmaWVyIHN0cmluZyBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0b1xuICAgKiB0aGUge0BsaW5rIFRpbWVMb2NhbGVPYmplY3QuZm9ybWF0fSBtZXRob2QuXG4gICAqIElmIG5vIHNwZWNpZmllciBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZGVmYXVsdCB0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICovXG4gIHRpY2tGb3JtYXQoe1xuICAgIHRpY2tzLFxuICAgIGRvbWFpbixcbiAgICBzcGVjaWZpZXJcbiAgfSkge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IGRlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluKSA6IGJ1aWxkRm9ybWF0dGVyKHNwZWNpZmllcik7XG4gIH1cbiAgaW52ZXJ0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGluYWxSYW5nZS5maW5kSW5kZXgoKHApID0+IHBvc2l0aW9uIDw9IHApO1xuICAgIHJldHVybiB0aGlzLmRvbWFpbltpbmRleF07XG4gIH1cbiAgaW52ZXJ0TmVhcmVzdCh5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN1cGVyLmludmVydE5lYXJlc3QoeSkpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwidGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwibWluVGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwibWF4VGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwiaW50ZXJ2YWxcIiwgMik7XG52YXIgT3JkaW5hbFRpbWVTY2FsZSA9IF9PcmRpbmFsVGltZVNjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NvbXBhcmUudHNcbmZ1bmN0aW9uIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG4gIH0gZWxzZSBpZiAoYSA9PSBudWxsICYmIGIgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbn1cbmZ1bmN0aW9uIHRvTGl0ZXJhbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdigpIDogdjtcbn1cbmZ1bmN0aW9uIGNvbXBvdW5kQXNjZW5kaW5nKGEsIGIsIGNvbXBhcmF0b3IpIHtcbiAgZm9yIChjb25zdCBpZHggaW4gYSkge1xuICAgIGNvbnN0IGRpZmYyID0gY29tcGFyYXRvcih0b0xpdGVyYWwoYVtpZHhdKSwgdG9MaXRlcmFsKGJbaWR4XSkpO1xuICAgIGlmIChkaWZmMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGRpZmYyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JvdXAudHNcbnZhciBfR3JvdXAgPSBjbGFzcyBfR3JvdXAgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKHsgaXNWaXJ0dWFsOiBvcHRzPy5pc1ZpcnR1YWwsIG5hbWU6IG9wdHM/Lm5hbWUgfSk7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGFzdEJCb3ggPSB2b2lkIDA7XG4gICAgY29uc3QgeyB6SW5kZXgsIHpJbmRleFN1Yk9yZGVyIH0gPSBvcHRzID8/IHt9O1xuICAgIHRoaXMuaXNDb250YWluZXJOb2RlID0gdHJ1ZTtcbiAgICBpZiAoekluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuekluZGV4ID0gekluZGV4O1xuICAgIH1cbiAgICBpZiAoekluZGV4U3ViT3JkZXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IHpJbmRleFN1Yk9yZGVyO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfR3JvdXA7XG4gIH1cbiAgb25aSW5kZXhDaGFuZ2UoKSB7XG4gICAgc3VwZXIub25aSW5kZXhDaGFuZ2UoKTtcbiAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgdGhpcy5fbGF5ZXJNYW5hZ2VyPy5tb3ZlTGF5ZXIodGhpcy5sYXllciwgdGhpcy56SW5kZXgsIHRoaXMuekluZGV4U3ViT3JkZXIpO1xuICAgIH1cbiAgfVxuICBpc0xheWVyKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyICE9IG51bGw7XG4gIH1cbiAgX3NldExheWVyTWFuYWdlcihsYXllcnNNYW5hZ2VyKSB7XG4gICAgaWYgKHRoaXMuX2xheWVyTWFuYWdlciAmJiB0aGlzLmxheWVyKSB7XG4gICAgICB0aGlzLl9sYXllck1hbmFnZXIucmVtb3ZlTGF5ZXIodGhpcy5sYXllcik7XG4gICAgICB0aGlzLmxheWVyID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIGRlcmVnaXN0ZXIgc2NlbmUgcmVuZGVyaW5nIGxheWVyIVwiKTtcbiAgICB9XG4gICAgc3VwZXIuX3NldExheWVyTWFuYWdlcihsYXllcnNNYW5hZ2VyKTtcbiAgfVxuICBpbml0aWFsaXNlTGF5ZXIoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLl9sYXllck1hbmFnZXIgfHwgdGhpcy5vcHRzPy5sYXllciAhPT0gdHJ1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxheWVyID0gdGhpcy5fbGF5ZXJNYW5hZ2VyLmFkZExheWVyKHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHpJbmRleDogdGhpcy56SW5kZXgsXG4gICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy56SW5kZXhTdWJPcmRlcixcbiAgICAgIGdldENvbXB1dGVkT3BhY2l0eTogKCkgPT4gdGhpcy5nZXRDb21wdXRlZE9wYWNpdHkoKSxcbiAgICAgIGdldFZpc2liaWxpdHk6ICgpID0+IHRoaXMuZ2V0VmlzaWJpbGl0eSgpXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q29tcHV0ZWRPcGFjaXR5KCkge1xuICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy50cmF2ZXJzZVVwKCkpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgX0dyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gbm9kZS5vcGFjaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuICBnZXRWaXNpYmlsaXR5KCkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLnRyYXZlcnNlVXAoKSkge1xuICAgICAgaWYgKCFub2RlLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvblZpc2libGVDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXIpIHtcbiAgICAgIHRoaXMubGF5ZXIuZW5hYmxlZCA9IHRoaXMudmlzaWJsZTtcbiAgICB9XG4gIH1cbiAgbWFya0RpcnR5KHNvdXJjZSwgdHlwZSA9IDEgLyogVFJJVklBTCAqLykge1xuICAgIGlmICh0aGlzLmlzVmlydHVhbCkge1xuICAgICAgc3VwZXIubWFya0RpcnR5KHNvdXJjZSwgdHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXJlbnRUeXBlID0gdHlwZTtcbiAgICBpZiAodHlwZSA8IDIgLyogTUlOT1IgKi8gfHwgdGhpcy5sYXllciAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRUeXBlID0gMSAvKiBUUklWSUFMICovO1xuICAgIH1cbiAgICBzdXBlci5tYXJrRGlydHkoc291cmNlLCB0eXBlLCBwYXJlbnRUeXBlKTtcbiAgfVxuICAvLyBXZSBjb25zaWRlciBhIGdyb3VwIHRvIGJlIGJvdW5kbGVzcywgdGh1cyBhbnkgcG9pbnQgYmVsb25ncyB0byBpdC5cbiAgY29udGFpbnNQb2ludChfeCwgX3kpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICByZXR1cm4gX0dyb3VwLmNvbXB1dGVCQm94KHRoaXMuY2hpbGRyZW4pO1xuICB9XG4gIGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpO1xuICB9XG4gIGNvbXB1dGVUcmFuc2Zvcm1lZFJlZ2lvbkJCb3goKSB7XG4gICAgaWYgKHRoaXMuY2xpcFJlY3QpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0cml4LnRyYW5zZm9ybUJCb3godGhpcy5jbGlwUmVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgfVxuICBwcmVSZW5kZXIoKSB7XG4gICAgY29uc3QgY291bnRzID0gc3VwZXIucHJlUmVuZGVyKCk7XG4gICAgY291bnRzLmdyb3VwcyArPSAxO1xuICAgIGNvdW50cy5ub25Hcm91cHMgLT0gMTtcbiAgICBpZiAodGhpcy5vcHRzPy5sYXllciAhPT0gdHJ1ZSB8fCB0aGlzLmxheWVyICE9IG51bGwpXG4gICAgICByZXR1cm4gY291bnRzO1xuICAgIGlmIChjb3VudHMubm9uR3JvdXBzID4gMCkge1xuICAgICAgdGhpcy5pbml0aWFsaXNlTGF5ZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0cz8ubm9uRW1wdHlDaGlsZERlcml2ZWRaSW5kZXggJiYgY291bnRzLm5vbkdyb3VwcyA+IDApIHtcbiAgICAgIHRoaXMuZGVyaXZlWkluZGV4RnJvbUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudHM7XG4gIH1cbiAgZGVyaXZlWkluZGV4RnJvbUNoaWxkcmVuKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IGMuX2NoaWxkTm9kZUNvdW50cy5ub25Hcm91cHMgPiAwKTtcbiAgICB0aGlzLnNvcnRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgY29uc3QgbGFzdENoaWxkID0gY2hpbGRyZW4uYXQoLTEpO1xuICAgIHRoaXMuekluZGV4ID0gbGFzdENoaWxkPy56SW5kZXggPz8gLUluZmluaXR5O1xuICAgIHRoaXMuekluZGV4U3ViT3JkZXIgPSBsYXN0Q2hpbGQ/LnpJbmRleFN1Yk9yZGVyO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IG9wdHM6IHsgbmFtZSA9IHZvaWQgMCB9ID0ge30sIF9kZWJ1ZzogZGVidWczIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZGlydHksIGRpcnR5WkluZGV4LCBsYXllciwgY2hpbGRyZW4sIGNsaXBSZWN0LCBkaXJ0eVRyYW5zZm9ybSB9ID0gdGhpcztcbiAgICBsZXQgeyBjdHgsIGZvcmNlUmVuZGVyLCBjbGlwQkJveCB9ID0gcmVuZGVyQ3R4O1xuICAgIGNvbnN0IHsgcmVzaXplZCwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBjb25zdCBjYW52YXNDdHhUcmFuc2Zvcm0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgY29uc3QgaXNEaXJ0eSA9IGRpcnR5ID49IDIgLyogTUlOT1IgKi8gfHwgZGlydHlaSW5kZXggfHwgcmVzaXplZDtcbiAgICBsZXQgaXNDaGlsZERpcnR5ID0gaXNEaXJ0eTtcbiAgICBsZXQgaXNDaGlsZExheWVyRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpc0NoaWxkRGlydHkgfHwgKGlzQ2hpbGREaXJ0eSA9IGNoaWxkLmxheWVyTWFuYWdlciA9PSBudWxsICYmIGNoaWxkLmRpcnR5ID49IDEgLyogVFJJVklBTCAqLyk7XG4gICAgICBpc0NoaWxkTGF5ZXJEaXJ0eSB8fCAoaXNDaGlsZExheWVyRGlydHkgPSBjaGlsZC5sYXllck1hbmFnZXIgIT0gbnVsbCAmJiBjaGlsZC5kaXJ0eSA+PSAxIC8qIFRSSVZJQUwgKi8pO1xuICAgICAgaWYgKGlzQ2hpbGREaXJ0eSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGRlYnVnMz8uKHsgbmFtZSwgZ3JvdXA6IHRoaXMsIGlzRGlydHksIGlzQ2hpbGREaXJ0eSwgZGlydHlUcmFuc2Zvcm0sIHJlbmRlckN0eCwgZm9yY2VSZW5kZXIgfSk7XG4gICAgfVxuICAgIGlmIChkaXJ0eVRyYW5zZm9ybSkge1xuICAgICAgZm9yY2VSZW5kZXIgPSBcImRpcnR5VHJhbnNmb3JtXCI7XG4gICAgfSBlbHNlIGlmIChsYXllcikge1xuICAgICAgY29uc3QgY3VycmVudEJCb3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgIGlmICh0aGlzLmxhc3RCQm94ID09PSB2b2lkIDAgfHwgIXRoaXMubGFzdEJCb3guZXF1YWxzKGN1cnJlbnRCQm94KSkge1xuICAgICAgICBmb3JjZVJlbmRlciA9IFwiZGlydHlUcmFuc2Zvcm1cIjtcbiAgICAgICAgdGhpcy5sYXN0QkJveCA9IGN1cnJlbnRCQm94O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRGlydHkgJiYgIWlzQ2hpbGREaXJ0eSAmJiAhaXNDaGlsZExheWVyRGlydHkgJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAobmFtZSAmJiBzdGF0cykge1xuICAgICAgICBkZWJ1ZzM/Lih7IG5hbWUsIHJlc3VsdDogXCJza2lwcGluZ1wiLCByZW5kZXJDdHgsIGNvdW50czogdGhpcy5ub2RlQ291bnQsIGdyb3VwOiB0aGlzIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxheWVyICYmIHN0YXRzKSB7XG4gICAgICAgIHN0YXRzLmxheWVyc1NraXBwZWQrKztcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xuICAgICAgfVxuICAgICAgdGhpcy5tYXJrQ2xlYW4oeyByZWN1cnNpdmU6IGZhbHNlIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncm91cFZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBjdHggPSBsYXllci5jb250ZXh0O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0obGF5ZXIucGl4ZWxSYXRpbywgMCwgMCwgbGF5ZXIucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgIT09IFwiZGlydHlUcmFuc2Zvcm1cIikge1xuICAgICAgICBmb3JjZVJlbmRlciA9IGlzQ2hpbGREaXJ0eSB8fCBkaXJ0eVpJbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JjZVJlbmRlcilcbiAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgIGlmIChjbGlwQkJveCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGNsaXBCQm94O1xuICAgICAgICBkZWJ1ZzM/LigoKSA9PiAoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2xpcEJCb3gsXG4gICAgICAgICAgY3R4VHJhbnNmb3JtOiBjdHguZ2V0VHJhbnNmb3JtKCksXG4gICAgICAgICAgcmVuZGVyQ3R4LFxuICAgICAgICAgIGdyb3VwOiB0aGlzXG4gICAgICAgIH0pKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oY2FudmFzQ3R4VHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICB9XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy50cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCwgY3R4KTtcbiAgICBpZiAoY2xpcFJlY3QpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gY2xpcFJlY3Q7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZGVidWczPy4oKCkgPT4gKHsgbmFtZSwgY2xpcFJlY3QsIGN0eFRyYW5zZm9ybTogY3R4LmdldFRyYW5zZm9ybSgpLCByZW5kZXJDdHgsIGdyb3VwOiB0aGlzIH0pKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGNsaXBCQm94ID0gbWF0cml4LnRyYW5zZm9ybUJCb3goY2xpcFJlY3QpO1xuICAgIH1cbiAgICBjb25zdCBoYXNWaXJ0dWFsQ2hpbGRyZW4gPSB0aGlzLmhhc1ZpcnR1YWxDaGlsZHJlbigpO1xuICAgIGlmIChkaXJ0eVpJbmRleCkge1xuICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgaWYgKGZvcmNlUmVuZGVyICE9PSBcImRpcnR5VHJhbnNmb3JtXCIpXG4gICAgICAgIGZvcmNlUmVuZGVyID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc1ZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJDb250ZXh0Q2hhbmdlZCA9IGZvcmNlUmVuZGVyICE9PSByZW5kZXJDdHguZm9yY2VSZW5kZXIgfHwgY2xpcEJCb3ggIT09IHJlbmRlckN0eC5jbGlwQkJveCB8fCBjdHggIT09IHJlbmRlckN0eC5jdHg7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dENoYW5nZWQgPyB7IC4uLnJlbmRlckN0eCwgY3R4LCBmb3JjZVJlbmRlciwgY2xpcEJCb3ggfSA6IHJlbmRlckN0eDtcbiAgICBsZXQgc2tpcHBlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKCFjaGlsZC52aXNpYmxlIHx8ICFncm91cFZpc2libGUpIHtcbiAgICAgICAgY2hpbGQubWFya0NsZWFuKCk7XG4gICAgICAgIGlmIChzdGF0cylcbiAgICAgICAgICBza2lwcGVkICs9IGNoaWxkLm5vZGVDb3VudC5jb3VudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcmNlUmVuZGVyICYmIGNoaWxkLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8pIHtcbiAgICAgICAgaWYgKHN0YXRzKVxuICAgICAgICAgIHNraXBwZWQgKz0gY2hpbGQubm9kZUNvdW50LmNvdW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjaGlsZC5yZW5kZXIoY2hpbGRSZW5kZXJDb250ZXh0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChzdGF0cylcbiAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBza2lwcGVkO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIGlmIChjbGlwUmVjdCkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGhhc1ZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLnZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oeyByZWN1cnNpdmU6IFwidmlydHVhbFwiIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubGF5ZXJzUmVuZGVyZWQrKztcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIpXG4gICAgICAgIGxheWVyLnNuYXBzaG90KCk7XG4gICAgICBsYXllci5jb250ZXh0LnZlcmlmeURlcHRoWmVybz8uKCk7XG4gICAgfVxuICAgIGlmIChuYW1lICYmIHN0YXRzKSB7XG4gICAgICBkZWJ1ZzM/Lih7IG5hbWUsIHJlc3VsdDogXCJyZW5kZXJlZFwiLCBza2lwcGVkLCByZW5kZXJDdHgsIGNvdW50czogdGhpcy5ub2RlQ291bnQsIGdyb3VwOiB0aGlzIH0pO1xuICAgIH1cbiAgfVxuICBzb3J0Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gZmFsc2U7XG4gICAgY2hpbGRyZW4uc29ydChcbiAgICAgIChhLCBiKSA9PiBjb21wb3VuZEFzY2VuZGluZyhcbiAgICAgICAgW2EuekluZGV4LCAuLi5hLnpJbmRleFN1Yk9yZGVyID8/IFt2b2lkIDAsIHZvaWQgMF0sIGEuc2VyaWFsTnVtYmVyXSxcbiAgICAgICAgW2IuekluZGV4LCAuLi5iLnpJbmRleFN1Yk9yZGVyID8/IFt2b2lkIDAsIHZvaWQgMF0sIGIuc2VyaWFsTnVtYmVyXSxcbiAgICAgICAgYXNjZW5kaW5nU3RyaW5nTnVtYmVyVW5kZWZpbmVkXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZUJCb3gobm9kZXMsIG9wdHMpIHtcbiAgICBsZXQgbGVmdCA9IEluZmluaXR5O1xuICAgIGxldCByaWdodCA9IC1JbmZpbml0eTtcbiAgICBsZXQgdG9wID0gSW5maW5pdHk7XG4gICAgbGV0IGJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBza2lwSW52aXNpYmxlID0gb3B0cz8uc2tpcEludmlzaWJsZSA/PyB0cnVlO1xuICAgIGZvciAoY29uc3QgbiBvZiBub2Rlcykge1xuICAgICAgaWYgKHNraXBJbnZpc2libGUgJiYgIW4udmlzaWJsZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBiYm94ID0gbi5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICBpZiAoIWJib3gpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBiYm94O1xuICAgICAgaWYgKHggPCBsZWZ0KSB7XG4gICAgICAgIGxlZnQgPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHkgPCB0b3ApIHtcbiAgICAgICAgdG9wID0geTtcbiAgICAgIH1cbiAgICAgIGlmICh4ICsgd2lkdGggPiByaWdodCkge1xuICAgICAgICByaWdodCA9IHggKyB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICh5ICsgaGVpZ2h0ID4gYm90dG9tKSB7XG4gICAgICAgIGJvdHRvbSA9IHkgKyBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQkJveChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtcyBiYm94IGdpdmVuIGluIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZSB0byBiYm94IGluIHRoaXMgZ3JvdXAncyBjb29yZGluYXRlIHNwYWNlIGFuZFxuICAgKiBzZXRzIHRoaXMgZ3JvdXAncyBjbGlwUmVjdCB0byB0aGUgdHJhbnNmb3JtZWQgYmJveC5cbiAgICogQHBhcmFtIGJib3ggY2xpcFJlY3QgYmJveCBpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqL1xuICBzZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoYmJveCkge1xuICAgIHRoaXMuY2xpcFJlY3QgPSBiYm94ID8gdGhpcy50cmFuc2Zvcm1CQm94KGJib3gpIDogdm9pZCAwO1xuICB9XG59O1xuX0dyb3VwLmNsYXNzTmFtZSA9IFwiR3JvdXBcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDMgLyogTUFKT1IgKi8sXG4gICAgY29udmVydG9yOiAodikgPT4gY2xhbXAoMCwgdiwgMSlcbiAgfSlcbl0sIF9Hcm91cC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCAyKTtcbnZhciBHcm91cCA9IF9Hcm91cDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kb20udHNcbnZhciB2ZXJpZmllZEdsb2JhbHMgPSB7fTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLndpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG59XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KHByb3BlcnR5TmFtZSkge1xuICByZXR1cm4gcHJvcGVydHlOYW1lID8gdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50Py5bcHJvcGVydHlOYW1lXSA6IHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhwcm9wZXJ0eU5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnR5TmFtZSA/IHZlcmlmaWVkR2xvYmFscy53aW5kb3c/Lltwcm9wZXJ0eU5hbWVdIDogdmVyaWZpZWRHbG9iYWxzLndpbmRvdztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50MiA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBzdHlsZSA9IGNsYXNzTmFtZTtcbiAgICBjbGFzc05hbWUgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKGNsYXNzTmFtZSkge1xuICAgIGVsZW1lbnQyLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQyLnN0eWxlLCBzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQyO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSkge1xuICByZXR1cm4gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkVXJsKGRhdGFVcmwsIGZpbGVOYW1lKSB7XG4gIGNvbnN0IHsgYm9keSB9ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3QgZWxlbWVudDIgPSBjcmVhdGVFbGVtZW50KFwiYVwiLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICBlbGVtZW50Mi5ocmVmID0gZGF0YVVybDtcbiAgZWxlbWVudDIuZG93bmxvYWQgPSBmaWxlTmFtZTtcbiAgYm9keS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gIGVsZW1lbnQyLmNsaWNrKCk7XG4gIHNldFRpbWVvdXQoKCkgPT4gYm9keS5yZW1vdmVDaGlsZChlbGVtZW50MikpO1xufVxuZnVuY3Rpb24gc2V0RG9jdW1lbnQoZG9jdW1lbnQyKSB7XG4gIHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50Mjtcbn1cbmZ1bmN0aW9uIHNldFdpbmRvdyh3aW5kb3cyKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSB3aW5kb3cyO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudEJCb3goZWxlbWVudDIsIGJib3gpIHtcbiAgaWYgKGVsZW1lbnQyKSB7XG4gICAgZWxlbWVudDIuc3R5bGUud2lkdGggPSBgJHtiYm94LndpZHRofXB4YDtcbiAgICBlbGVtZW50Mi5zdHlsZS5oZWlnaHQgPSBgJHtiYm94LmhlaWdodH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUubGVmdCA9IGAke2Jib3gueH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUudG9wID0gYCR7YmJveC55fXB4YDtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlYnVnLnRzXG52YXIgTE9OR19USU1FX1BFUklPRF9USFJFU0hPTEQgPSAyZTM7XG52YXIgdGltZU9mTGFzdExvZyA9IERhdGUubm93KCk7XG52YXIgbG9nVGltZUdhcCA9ICgpID0+IHtcbiAgY29uc3QgdGltZVNpbmNlTGFzdExvZyA9IERhdGUubm93KCkgLSB0aW1lT2ZMYXN0TG9nO1xuICBpZiAodGltZVNpbmNlTGFzdExvZyA+IExPTkdfVElNRV9QRVJJT0RfVEhSRVNIT0xEKSB7XG4gICAgY29uc3QgcHJldHR5RHVyYXRpb24gPSAoTWF0aC5mbG9vcih0aW1lU2luY2VMYXN0TG9nIC8gMTAwKSAvIDEwKS50b0ZpeGVkKDEpO1xuICAgIExvZ2dlci5sb2coYCoqKiogJHtwcmV0dHlEdXJhdGlvbn1zIHNpbmNlIGxhc3QgbG9nIG1lc3NhZ2UgKioqKmApO1xuICB9XG4gIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xufTtcbnZhciBEZWJ1ZyA9IHtcbiAgY3JlYXRlKC4uLmRlYnVnU2VsZWN0b3JzKSB7XG4gICAgY29uc3QgcmVzdWx0Rm4gPSAoLi4ubG9nQ29udGVudCkgPT4ge1xuICAgICAgaWYgKERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSkge1xuICAgICAgICBpZiAodHlwZW9mIGxvZ0NvbnRlbnRbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGxvZ0NvbnRlbnQgPSB0b0FycmF5KGxvZ0NvbnRlbnRbMF0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nVGltZUdhcCgpO1xuICAgICAgICBMb2dnZXIubG9nKC4uLmxvZ0NvbnRlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzdWx0Rm4sIHsgY2hlY2s6ICgpID0+IERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSB9KTtcbiAgfSxcbiAgY2hlY2soLi4uZGVidWdTZWxlY3RvcnMpIHtcbiAgICBpZiAoZGVidWdTZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWJ1Z1NlbGVjdG9ycy5wdXNoKHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBjaGFydERlYnVnID0gdG9BcnJheShnZXRXaW5kb3coXCJhZ0NoYXJ0c0RlYnVnXCIpKTtcbiAgICByZXR1cm4gY2hhcnREZWJ1Zy5zb21lKChzZWxlY3RvcikgPT4gZGVidWdTZWxlY3RvcnMuaW5jbHVkZXMoc2VsZWN0b3IpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2VsZWN0aW9uLnRzXG52YXIgU2VsZWN0aW9uID0gY2xhc3MgX1NlbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudE5vZGUsIGNsYXNzT3JGYWN0b3J5LCBhdXRvQ2xlYW51cCA9IHRydWUpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuICAgIHRoaXMuYXV0b0NsZWFudXAgPSBhdXRvQ2xlYW51cDtcbiAgICB0aGlzLmdhcmJhZ2VCaW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX25vZGVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJzY2VuZVwiLCBcInNjZW5lOnNlbGVjdGlvbnNcIik7XG4gICAgdGhpcy5ub2RlRmFjdG9yeSA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKE5vZGUsIGNsYXNzT3JGYWN0b3J5KSA/ICgpID0+IG5ldyBjbGFzc09yRmFjdG9yeSgpIDogY2xhc3NPckZhY3Rvcnk7XG4gIH1cbiAgc3RhdGljIHNlbGVjdChwYXJlbnQsIGNsYXNzT3JGYWN0b3J5LCBnYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUpIHtcbiAgICByZXR1cm4gbmV3IF9TZWxlY3Rpb24ocGFyZW50LCBjbGFzc09yRmFjdG9yeSwgZ2FyYmFnZUNvbGxlY3Rpb24pO1xuICB9XG4gIHN0YXRpYyBzZWxlY3RBbGwocGFyZW50LCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgdHJhdmVyc2UgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2godHJhdmVyc2UpO1xuICAgIH07XG4gICAgdHJhdmVyc2UocGFyZW50KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBzdGF0aWMgc2VsZWN0QnlDbGFzcyhub2RlLCBDbGFzcywgLi4uRXh0cmFDbGFzc2VzKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChuKSA9PiB7XG4gICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIENsYXNzIHx8IEV4dHJhQ2xhc3Nlcy5zb21lKChDKSA9PiBuIGluc3RhbmNlb2YgQyk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNlbGVjdEJ5VGFnKG5vZGUsIHRhZykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEFsbChub2RlLCAobikgPT4gbi50YWcgPT09IHRhZyk7XG4gIH1cbiAgY3JlYXRlTm9kZShkYXR1bSwgaW5pdGlhbGl6ZXIsIGlkeCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVGYWN0b3J5KGRhdHVtKTtcbiAgICBub2RlLmRhdHVtID0gZGF0dW07XG4gICAgaW5pdGlhbGl6ZXI/Lihub2RlKTtcbiAgICBpZiAoaWR4ID09IG51bGwpIHtcbiAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25vZGVzLnNwbGljZShpZHgsIDAsIG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGF0YSBpbiBhIHNlbGVjdGlvbi4gSWYgYW4gYGdldERhdHVtSWQoKWAgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIG1haW50YWluIGEgbGlzdCBvZiBpZHMgcmVsYXRlZCB0b1xuICAgKiB0aGUgbm9kZXMuIE90aGVyd2lzZSwgdGFrZSB0aGUgbW9yZSBlZmZpY2llbnQgcm91dGUgb2Ygc2ltcGx5IGNyZWF0aW5nIGFuZCBkZXN0cm95aW5nIG5vZGVzIGF0IHRoZSBlbmRcbiAgICogb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgdXBkYXRlKGRhdGEsIGluaXRpYWxpemVyLCBnZXREYXR1bUlkKSB7XG4gICAgaWYgKHRoaXMuZ2FyYmFnZUJpbi5zaXplID4gMCkge1xuICAgICAgdGhpcy5kZWJ1ZyhgU2VsZWN0aW9uIC0gdXBkYXRlKCkgY2FsbGVkIHdpdGggcGVuZGluZyBnYXJiYWdlOiAke2RhdGF9YCk7XG4gICAgfVxuICAgIGlmIChnZXREYXR1bUlkKSB7XG4gICAgICBjb25zdCBkYXRhTWFwID0gbmV3IE1hcChcbiAgICAgICAgZGF0YS5tYXAoKGRhdHVtLCBpZHgpID0+IFtnZXREYXR1bUlkKGRhdHVtKSwgW2RhdHVtLCBpZHhdXSlcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IFtub2RlLCBkYXR1bUlkXSBvZiB0aGlzLl9ub2Rlc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGRhdGFNYXAuaGFzKGRhdHVtSWQpKSB7XG4gICAgICAgICAgY29uc3QgW25ld0RhdHVtXSA9IGRhdGFNYXAuZ2V0KGRhdHVtSWQpO1xuICAgICAgICAgIG5vZGUuZGF0dW0gPSBuZXdEYXR1bTtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKG5vZGUpO1xuICAgICAgICAgIGRhdGFNYXAuZGVsZXRlKGRhdHVtSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2RhdHVtSWQsIFtkYXR1bSwgaWR4XV0gb2YgZGF0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5fbm9kZXNNYXAuc2V0KHRoaXMuY3JlYXRlTm9kZShkYXR1bSwgaW5pdGlhbGl6ZXIsIGlkeCksIGRhdHVtSWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heChkYXRhLmxlbmd0aCwgdGhpcy5kYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmFkZCh0aGlzLl9ub2Rlc1tpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA+PSB0aGlzLl9ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZU5vZGUoZGF0YVtpXSwgaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX25vZGVzW2ldLmRhdHVtID0gZGF0YVtpXTtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBkYXRhLnNsaWNlKCk7XG4gICAgaWYgKHRoaXMuYXV0b0NsZWFudXApIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX25vZGVzID0gdGhpcy5fbm9kZXMuZmlsdGVyKChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5nYXJiYWdlQmluLmhhcyhub2RlKSkge1xuICAgICAgICB0aGlzLl9ub2Rlc01hcC5kZWxldGUobm9kZSk7XG4gICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUobm9kZSk7XG4gICAgICAgIG5vZGUuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnVwZGF0ZShbXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaXNHYXJiYWdlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5nYXJiYWdlQmluLmhhcyhub2RlKTtcbiAgfVxuICBoYXNHYXJiYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmdhcmJhZ2VCaW4uc2l6ZSA+IDA7XG4gIH1cbiAgZWFjaChpdGVyYXRlMikge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5fbm9kZXMuZW50cmllcygpKSB7XG4gICAgICBpdGVyYXRlMihlbnRyeVsxXSwgZW50cnlbMV0uZGF0dW0sIGVudHJ5WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpbmRleF07XG4gICAgICBjb25zdCBkYXR1bSA9IHRoaXMuX25vZGVzW2luZGV4XS5kYXR1bTtcbiAgICAgIHlpZWxkIHsgbm9kZSwgZGF0dW0sIGluZGV4IH07XG4gICAgfVxuICB9XG4gIHNlbGVjdChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RBbGwodGhpcy5wYXJlbnROb2RlLCBwcmVkaWNhdGUpO1xuICB9XG4gIHNlbGVjdEJ5Q2xhc3MoQ2xhc3MpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RCeUNsYXNzKHRoaXMucGFyZW50Tm9kZSwgQ2xhc3MpO1xuICB9XG4gIHNlbGVjdEJ5VGFnKHRhZykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKHRoaXMucGFyZW50Tm9kZSwgdGFnKTtcbiAgfVxuICBub2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXM7XG4gIH1cbiAgYXQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuYXQoaW5kZXgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2FuZ2xlLnRzXG52YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlMzYwKHJhZGlhbnMpIHtcbiAgcmFkaWFucyAlPSB0d29QaTtcbiAgcmFkaWFucyArPSB0d29QaTtcbiAgcmFkaWFucyAlPSB0d29QaTtcbiAgcmV0dXJuIHJhZGlhbnM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZShyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJhZGlhbnMgKz0gdHdvUGk7XG4gIGlmIChyYWRpYW5zICE9PSB0d29QaSkge1xuICAgIHJhZGlhbnMgJT0gdHdvUGk7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTE4MChyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIGlmIChyYWRpYW5zIDwgLU1hdGguUEkpIHtcbiAgICByYWRpYW5zICs9IHR3b1BpO1xuICB9IGVsc2UgaWYgKHJhZGlhbnMgPj0gTWF0aC5QSSkge1xuICAgIHJhZGlhbnMgLT0gdHdvUGk7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnM7XG59XG5mdW5jdGlvbiBpc0JldHdlZW5BbmdsZXModGFyZ2V0QW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHQgPSBub3JtYWxpemVBbmdsZTM2MCh0YXJnZXRBbmdsZSk7XG4gIGNvbnN0IGEwID0gbm9ybWFsaXplQW5nbGUzNjAoc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGExID0gbm9ybWFsaXplQW5nbGUzNjAoZW5kQW5nbGUpO1xuICBpZiAoYTAgPCBhMSkge1xuICAgIHJldHVybiBhMCA8PSB0ICYmIHQgPD0gYTE7XG4gIH0gZWxzZSBpZiAoYTAgPiBhMSkge1xuICAgIHJldHVybiBhMCA8PSB0IHx8IHQgPD0gYTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzIC8gMTgwICogTWF0aC5QSTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zIC8gTWF0aC5QSSAqIDE4MDtcbn1cbmZ1bmN0aW9uIGFuZ2xlRGlmZihhbmdsZTAsIGFuZ2xlMSwgY291bnRlckNsb2Nrd2lzZSkge1xuICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgIFthbmdsZTAsIGFuZ2xlMV0gPSBbYW5nbGUxLCBhbmdsZTBdO1xuICB9XG4gIGNvbnN0IGEwID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUwKTtcbiAgY29uc3QgYTEgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTEpICsgdHdvUGk7XG4gIHJldHVybiAoYTEgLSBhMCkgJSB0d29QaTtcbn1cbmZ1bmN0aW9uIGFuZ2xlQmV0d2VlbihhbmdsZTAsIGFuZ2xlMSkge1xuICBhbmdsZTAgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTApO1xuICBhbmdsZTEgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTEpO1xuICByZXR1cm4gYW5nbGUxIC0gYW5nbGUwICsgKGFuZ2xlMCA+IGFuZ2xlMSA/IDIgKiBNYXRoLlBJIDogMCk7XG59XG5mdW5jdGlvbiBkaXNwbGFjZVBvaW50RnJvbVZlY3RvcihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlMikge1xuICBjb25zdCB4ID0gY2VudGVyWCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlMik7XG4gIGNvbnN0IHkgPSBjZW50ZXJZICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUyKTtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Rpc3RhbmNlLnRzXG5mdW5jdGlvbiBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MSAtIHgyO1xuICBjb25zdCBkeSA9IHkxIC0geTI7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbmZ1bmN0aW9uIGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGJlc3QpIHtcbiAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oYmVzdCwgcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIHgxLCB5MSkpO1xuICB9XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBjb25zdCB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSkpKTtcbiAgY29uc3QgaXggPSB4MSArIHQgKiBkeDtcbiAgY29uc3QgaXkgPSB5MSArIHQgKiBkeTtcbiAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBpeCwgaXkpKTtcbn1cbmZ1bmN0aW9uIGFyY0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIGJlc3QpIHtcbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbZW5kQW5nbGUsIHN0YXJ0QW5nbGVdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXTtcbiAgfVxuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHkgLSBjeSwgeCAtIGN4KTtcbiAgaWYgKCFpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZW5kWCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZW5kWSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBzdGFydFgsIHN0YXJ0WSksIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBlbmRYLCBlbmRZKSk7XG4gIH1cbiAgY29uc3QgZGlzdFRvQXJjID0gcmFkaXVzIC0gTWF0aC5zcXJ0KHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3kpKTtcbiAgcmV0dXJuIE1hdGgubWluKGJlc3QsIGRpc3RUb0FyYyAqIGRpc3RUb0FyYyk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyYWRpZW50L2dyYWRpZW50LnRzXG52YXIgR3JhZGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0b3BzID0gW10pIHtcbiAgICB0aGlzLnN0b3BzID0gc3RvcHM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyYWRpZW50L2xpbmVhckdyYWRpZW50LnRzXG52YXIgTGluZWFyR3JhZGllbnQgPSBjbGFzcyBleHRlbmRzIEdyYWRpZW50IHtcbiAgY29uc3RydWN0b3Ioc3RvcHMsIGFuZ2xlMiA9IDApIHtcbiAgICBzdXBlcihzdG9wcyk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlMjtcbiAgfVxuICBjcmVhdGVHcmFkaWVudChjdHgsIGJib3gpIHtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IDkwO1xuICAgIGNvbnN0IHsgc3RvcHMsIGFuZ2xlOiBhbmdsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFkaWFucyA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyhhbmdsZTIgKyBhbmdsZU9mZnNldCkpO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgIGNvbnN0IHcgPSBiYm94LndpZHRoO1xuICAgIGNvbnN0IGggPSBiYm94LmhlaWdodDtcbiAgICBjb25zdCBjeCA9IGJib3gueCArIHcgKiAwLjU7XG4gICAgY29uc3QgY3kgPSBiYm94LnkgKyBoICogMC41O1xuICAgIGlmICh3ID4gMCAmJiBoID4gMCkge1xuICAgICAgY29uc3QgZGlhZ29uYWwgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdykgLyAyO1xuICAgICAgY29uc3QgZGlhZ29uYWxBbmdsZSA9IE1hdGguYXRhbjIoaCwgdyk7XG4gICAgICBsZXQgcXVhcnRlcmVkQW5nbGU7XG4gICAgICBpZiAocmFkaWFucyA8IE1hdGguUEkgLyAyKSB7XG4gICAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gcmFkaWFucztcbiAgICAgIH0gZWxzZSBpZiAocmFkaWFucyA8IE1hdGguUEkpIHtcbiAgICAgICAgcXVhcnRlcmVkQW5nbGUgPSBNYXRoLlBJIC0gcmFkaWFucztcbiAgICAgIH0gZWxzZSBpZiAocmFkaWFucyA8IDEuNSAqIE1hdGguUEkpIHtcbiAgICAgICAgcXVhcnRlcmVkQW5nbGUgPSByYWRpYW5zIC0gTWF0aC5QSTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gMiAqIE1hdGguUEkgLSByYWRpYW5zO1xuICAgICAgfVxuICAgICAgY29uc3QgbCA9IGRpYWdvbmFsICogTWF0aC5hYnMoTWF0aC5jb3MocXVhcnRlcmVkQW5nbGUgLSBkaWFnb25hbEFuZ2xlKSk7XG4gICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChjeCArIGNvcyAqIGwsIGN5ICsgc2luICogbCwgY3ggLSBjb3MgKiBsLCBjeSAtIHNpbiAqIGwpO1xuICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHN0b3BzKSB7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgc3RvcC5jb2xvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICAgIHJldHVybiBcImJsYWNrXCI7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3NoYXBlLnRzXG52YXIgTElORUFSX0dSQURJRU5UX1JFR0VYUCA9IC9ebGluZWFyLWdyYWRpZW50XFwoKC0/W1xcZC5dKylkZWcsKC4qPylcXCkkL2k7XG52YXIgX1NoYXBlID0gY2xhc3MgX1NoYXBlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmZpbGwgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5maWxsO1xuICAgIHRoaXMuc3Ryb2tlID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmxpbmVEYXNoID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZURhc2g7XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHRoaXMubGluZUNhcCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVDYXA7XG4gICAgdGhpcy5saW5lSm9pbiA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVKb2luO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IHZvaWQgMDtcbiAgICB0aGlzLm9wYWNpdHkgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5vcGFjaXR5O1xuICAgIHRoaXMuZmlsbFNoYWRvdyA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmZpbGxTaGFkb3c7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBkZWZhdWx0IHN0eWxlcyBpbnRyb2R1Y2VkIGJ5IHRoaXMgc3ViY2xhc3MuXG4gICAqL1xuICByZXN0b3JlT3duU3R5bGVzKCkge1xuICAgIGNvbnN0IHsgZGVmYXVsdFN0eWxlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRTdHlsZXMpO1xuICB9XG4gIG9uRmlsbENoYW5nZSgpIHtcbiAgICBjb25zdCB7IGZpbGwgfSA9IHRoaXM7XG4gICAgbGV0IGxpbmVhckdyYWRpZW50TWF0Y2g7XG4gICAgaWYgKGZpbGw/LnN0YXJ0c1dpdGgoXCJsaW5lYXItZ3JhZGllbnRcIikgJiYgKGxpbmVhckdyYWRpZW50TWF0Y2ggPSBMSU5FQVJfR1JBRElFTlRfUkVHRVhQLmV4ZWMoZmlsbCkpKSB7XG4gICAgICBjb25zdCBhbmdsZTIgPSBwYXJzZUZsb2F0KGxpbmVhckdyYWRpZW50TWF0Y2hbMV0pO1xuICAgICAgY29uc3QgY29sb3JzID0gW107XG4gICAgICBjb25zdCBjb2xvcnNQYXJ0ID0gbGluZWFyR3JhZGllbnRNYXRjaFsyXTtcbiAgICAgIGNvbnN0IGNvbG9yUmVnZXggPSAvKCNbMC05YS1mXSspfChyZ2JhP1xcKC4rP1xcKSl8KFthLXpdKykvZ2k7XG4gICAgICBsZXQgYztcbiAgICAgIHdoaWxlIChjID0gY29sb3JSZWdleC5leGVjKGNvbG9yc1BhcnQpKSB7XG4gICAgICAgIGNvbG9ycy5wdXNoKGNbMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ncmFkaWVudCA9IG5ldyBMaW5lYXJHcmFkaWVudChcbiAgICAgICAgY29sb3JzLm1hcCgoY29sb3IsIGluZGV4KSA9PiAoeyBjb2xvciwgb2Zmc2V0OiBpbmRleCAvIChjb2xvcnMubGVuZ3RoIC0gMSkgfSkpLFxuICAgICAgICBhbmdsZTJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3JhZGllbnQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZGV2aWNlLXBpeGVsIGFsaWduZWQgY29vcmRpbmF0ZSAob3IgbGVuZ3RoIGlmIGxlbmd0aCBpcyBzdXBwbGllZCkuXG4gICAqXG4gICAqIE5PVEU6IE5vdCBzdWl0YWJsZSBmb3Igc3Ryb2tlcywgc2luY2UgdGhlIHN0cm9rZSBuZWVkcyB0byBiZSBvZmZzZXQgdG8gdGhlIG1pZGRsZVxuICAgKiBvZiBhIGRldmljZSBwaXhlbC5cbiAgICovXG4gIGFsaWduKHN0YXJ0LCBsZW5ndGgyKSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXM/LnBpeGVsUmF0aW8gPz8gMTtcbiAgICBjb25zdCBhbGlnbmVkU3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0ICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIGlmIChsZW5ndGgyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhbGlnbmVkU3RhcnQ7XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPCAxKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKChsZW5ndGgyICsgc3RhcnQpICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvIC0gYWxpZ25lZFN0YXJ0O1xuICB9XG4gIGZpbGxTdHJva2UoY3R4LCBwYXRoKSB7XG4gICAgdGhpcy5yZW5kZXJGaWxsKGN0eCwgcGF0aCk7XG4gICAgdGhpcy5yZW5kZXJTdHJva2UoY3R4LCBwYXRoKTtcbiAgfVxuICByZW5kZXJGaWxsKGN0eCwgcGF0aCkge1xuICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcbiAgICAgIHRoaXMuYXBwbHlGaWxsKGN0eCk7XG4gICAgICB0aGlzLmFwcGx5RmlsbEFscGhhKGN0eCk7XG4gICAgICB0aGlzLmFwcGx5U2hhZG93KGN0eCk7XG4gICAgICB0aGlzLmV4ZWN1dGVGaWxsKGN0eCwgcGF0aCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gIH1cbiAgZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKSB7XG4gICAgcGF0aCA/IGN0eC5maWxsKHBhdGgpIDogY3R4LmZpbGwoKTtcbiAgfVxuICBhcHBseUZpbGwoY3R4KSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZ3JhZGllbnQ/LmNyZWF0ZUdyYWRpZW50KGN0eCwgdGhpcy5nZXRCQm94KCkpID8/IHRoaXMuZmlsbDtcbiAgfVxuICBhcHBseUZpbGxBbHBoYShjdHgpIHtcbiAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5maWxsT3BhY2l0eTtcbiAgfVxuICBhcHBseVNoYWRvdyhjdHgpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcy5waXhlbFJhdGlvID8/IDE7XG4gICAgY29uc3QgZmlsbFNoYWRvdyA9IHRoaXMuZmlsbFNoYWRvdztcbiAgICBpZiAoZmlsbFNoYWRvdz8uZW5hYmxlZCkge1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gZmlsbFNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gZmlsbFNoYWRvdy54T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gZmlsbFNoYWRvdy55T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gZmlsbFNoYWRvdy5ibHVyICogcGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cbiAgcmVuZGVyU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZVdpZHRoKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIGlmICh0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5saW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGluZUpvaW4pIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5saW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMubWl0ZXJMaW1pdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKSB7XG4gICAgcGF0aCA/IGN0eC5zdHJva2UocGF0aCkgOiBjdHguc3Ryb2tlKCk7XG4gIH1cbiAgY29udGFpbnNQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQb2ludEluUGF0aCh4LCB5KTtcbiAgfVxufTtcbi8qKlxuICogRGVmYXVsdHMgZm9yIHN0eWxlIHByb3BlcnRpZXMuIE5vdGUgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZSBwb3NpdGlvblxuICogYW5kIHNoYXBlIG9mIHRoZSBub2RlIGFyZSBub3QgY29uc2lkZXJlZCBzdHlsZSBwcm9wZXJ0aWVzLCBmb3IgZXhhbXBsZTpcbiAqIGB4YCwgYHlgLCBgd2lkdGhgLCBgaGVpZ2h0YCwgYHJhZGl1c2AsIGByb3RhdGlvbmAsIGV0Yy5cbiAqIENhbiBiZSB1c2VkIHRvIHJlc2V0IHRvIHRoZSBvcmlnaW5hbCBzdHlsaW5nIGFmdGVyIHNvbWUgY3VzdG9tIHN0eWxpbmdcbiAqIGhhcyBiZWVuIGFwcGxpZWQgKHVzaW5nIHRoZSBgcmVzdG9yZU93blN0eWxlc2AgbWV0aG9kKS5cbiAqIFRoZXNlIHN0YXRpYyBkZWZhdWx0cyBhcmUgbWVhbnQgdG8gYmUgaW5oZXJpdGVkIGJ5IHN1YmNsYXNzZXMuXG4gKi9cbl9TaGFwZS5kZWZhdWx0U3R5bGVzID0ge1xuICBmaWxsOiBcImJsYWNrXCIsXG4gIHN0cm9rZTogdm9pZCAwLFxuICBzdHJva2VXaWR0aDogMCxcbiAgbGluZURhc2g6IHZvaWQgMCxcbiAgbGluZURhc2hPZmZzZXQ6IDAsXG4gIGxpbmVDYXA6IHZvaWQgMCxcbiAgbGluZUpvaW46IHZvaWQgMCxcbiAgb3BhY2l0eTogMSxcbiAgZmlsbFNoYWRvdzogdm9pZCAwXG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8sIGNoYW5nZUNiOiAocykgPT4gcy5vbkZpbGxDaGFuZ2UoKSB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZUNhcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVKb2luXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibWl0ZXJMaW1pdFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDIgLyogTUlOT1IgKi8sXG4gICAgY29udmVydG9yOiAodikgPT4gY2xhbXAoMCwgdiwgMSlcbiAgfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovLCBjaGVja0RpcnR5T25Bc3NpZ25tZW50OiB0cnVlIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImZpbGxTaGFkb3dcIiwgMik7XG52YXIgU2hhcGUgPSBfU2hhcGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL2xpbmUudHNcbnZhciBMaW5lID0gY2xhc3MgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMucmVzdG9yZU93blN0eWxlcygpO1xuICB9XG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpcy54MSA9IHZhbHVlO1xuICAgIHRoaXMueDIgPSB2YWx1ZTtcbiAgfVxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMueTEgPSB2YWx1ZTtcbiAgICB0aGlzLnkyID0gdmFsdWU7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIG5ldyBCQm94KFxuICAgICAgTWF0aC5taW4odGhpcy54MSwgdGhpcy54MiksXG4gICAgICBNYXRoLm1pbih0aGlzLnkxLCB0aGlzLnkyKSxcbiAgICAgIE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKSxcbiAgICAgIE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKVxuICAgICk7XG4gIH1cbiAgaXNQb2ludEluUGF0aChweCwgcHkpIHtcbiAgICBpZiAodGhpcy54MSA9PT0gdGhpcy54MiB8fCB0aGlzLnkxID09PSB0aGlzLnkyKSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudHJhbnNmb3JtUG9pbnQocHgsIHB5KTtcbiAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKS5jbG9uZSgpLmdyb3codGhpcy5zdHJva2VXaWR0aCAvIDIpLmNvbnRhaW5zUG9pbnQoeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQocHgsIHB5KSB7XG4gICAgY29uc3QgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcbiAgICByZXR1cm4gbGluZURpc3RhbmNlU3F1YXJlZChweCwgcHksIHgxLCB5MSwgeDIsIHkyLCBJbmZpbml0eSk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMsIGRldmljZVBpeGVsUmF0aW8gfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgpO1xuICAgIGxldCB7IHgxLCB5MSwgeDIsIHkyIH0gPSB0aGlzO1xuICAgIGlmICh4MSA9PT0geDIpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh4MSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIE1hdGgudHJ1bmMoc3Ryb2tlV2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSAlIDIgLyAoZGV2aWNlUGl4ZWxSYXRpbyAqIDIpO1xuICAgICAgeDEgPSB4O1xuICAgICAgeDIgPSB4O1xuICAgIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgICBjb25zdCB7IHN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQoeTEgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBNYXRoLnRydW5jKHN0cm9rZVdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbykgJSAyIC8gKGRldmljZVBpeGVsUmF0aW8gKiAyKTtcbiAgICAgIHkxID0geTtcbiAgICAgIHkyID0geTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgdGhpcy5maWxsU3Ryb2tlKGN0eCk7XG4gICAgdGhpcy5maWxsU2hhZG93Py5tYXJrQ2xlYW4oKTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxufTtcbkxpbmUuY2xhc3NOYW1lID0gXCJMaW5lXCI7XG5MaW5lLmRlZmF1bHRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTaGFwZS5kZWZhdWx0U3R5bGVzLCB7XG4gIGZpbGw6IHZvaWQgMCxcbiAgc3Ryb2tlV2lkdGg6IDFcbn0pO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmUucHJvdG90eXBlLCBcIngxXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmUucHJvdG90eXBlLCBcInkxXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmUucHJvdG90eXBlLCBcIngyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmUucHJvdG90eXBlLCBcInkyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NhbnZhcy51dGlsLnRzXG5mdW5jdGlvbiBjcmVhdGVDYW52YXNDb250ZXh0KHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KFwiMmRcIik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbHJ1Q2FjaGUudHNcbnZhciBMUlVDYWNoZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWF4Q2FjaGVTaXplID0gNSkge1xuICAgIHRoaXMubWF4Q2FjaGVTaXplID0gbWF4Q2FjaGVTaXplO1xuICAgIHRoaXMuc3RvcmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBpZiAoIXRoaXMuc3RvcmUuaGFzKGtleSkpXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IGhpdCA9IHRoaXMuc3RvcmUuZ2V0KGtleSk7XG4gICAgdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcbiAgICB0aGlzLnN0b3JlLnNldChrZXksIGhpdCk7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuaGFzKGtleSk7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgICBpZiAodGhpcy5zdG9yZS5zaXplID4gdGhpcy5tYXhDYWNoZVNpemUpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5zdG9yZS5rZXlzKCk7XG4gICAgICBsZXQgZXZpY3RDb3VudCA9IHRoaXMuc3RvcmUuc2l6ZSAtIHRoaXMubWF4Q2FjaGVTaXplO1xuICAgICAgd2hpbGUgKGV2aWN0Q291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGV2aWN0S2V5SXRlcmF0b3IgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghZXZpY3RLZXlJdGVyYXRvci5kb25lKSB7XG4gICAgICAgICAgdGhpcy5zdG9yZS5kZWxldGUoZXZpY3RLZXlJdGVyYXRvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZpY3RDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zdG9yZS5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RleHRNZWFzdXJlci50c1xudmFyIENhY2hlZFRleHRNZWFzdXJlclBvb2wgPSBjbGFzcyB7XG4gIC8vIE1lYXN1cmVzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcm92aWRlZCB0ZXh0LCBoYW5kbGluZyBtdWx0aWxpbmUgaWYgbmVlZGVkLlxuICBzdGF0aWMgbWVhc3VyZVRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IHRoaXMuZ2V0TWVhc3VyZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgfVxuICBzdGF0aWMgbWVhc3VyZUxpbmVzKHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSB0aGlzLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRleHQpO1xuICB9XG4gIC8vIEdldHMgYSBUZXh0TWVhc3VyZXIgaW5zdGFuY2UsIGNvbmZpZ3VyaW5nIHRleHQgYWxpZ25tZW50IGFuZCBiYXNlbGluZSBpZiBwcm92aWRlZC5cbiAgc3RhdGljIGdldE1lYXN1cmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb250ID0gdHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuZm9udCA6IFRleHRVdGlscy50b0ZvbnRTdHJpbmcob3B0aW9ucy5mb250KTtcbiAgICBjb25zdCBrZXkgPSBgJHtmb250fS0ke29wdGlvbnMudGV4dEFsaWduID8/IFwic3RhcnRcIn0tJHtvcHRpb25zLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIn1gO1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlTWFwLmdldChrZXkpID8/IHRoaXMuY3JlYXRlRm9udE1lYXN1cmVyKGZvbnQsIG9wdGlvbnMsIGtleSk7XG4gIH1cbiAgLy8gQ3JlYXRlcyBvciByZXRyaWV2ZXMgYSBUZXh0TWVhc3VyZXIgaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgZm9udC5cbiAgc3RhdGljIGNyZWF0ZUZvbnRNZWFzdXJlcihmb250LCBvcHRpb25zLCBrZXkpIHtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNDb250ZXh0KCk7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbiA/PyBcInN0YXJ0XCI7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdGlvbnMudGV4dEJhc2VsaW5lID8/IFwiYWxwaGFiZXRpY1wiO1xuICAgIGNvbnN0IG1lYXN1cmVyID0gbmV3IENhY2hlZFRleHRNZWFzdXJlcihjdHgsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5zdGFuY2VNYXAuc2V0KGtleSwgbWVhc3VyZXIpO1xuICAgIHJldHVybiBtZWFzdXJlcjtcbiAgfVxufTtcbkNhY2hlZFRleHRNZWFzdXJlclBvb2wuaW5zdGFuY2VNYXAgPSBuZXcgTFJVQ2FjaGUoMTApO1xudmFyIENhY2hlZFRleHRNZWFzdXJlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY3R4LCBvcHRpb25zKSB7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgLy8gY2FjaGVkIHRleHQgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5tZWFzdXJlTWFwID0gbmV3IExSVUNhY2hlKDEwMCk7XG4gICAgaWYgKG9wdGlvbnMudGV4dEFsaWduKSB7XG4gICAgICBjdHgudGV4dEFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRleHRCYXNlbGluZSkge1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdGlvbnMudGV4dEJhc2VsaW5lO1xuICAgIH1cbiAgICBjdHguZm9udCA9IHR5cGVvZiBvcHRpb25zLmZvbnQgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmZvbnQgOiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKG9wdGlvbnMuZm9udCk7XG4gICAgdGhpcy50ZXh0TWVhc3VyZXIgPSBuZXcgU2ltcGxlVGV4dE1lYXN1cmVyKFxuICAgICAgKHQpID0+IHRoaXMuY2FjaGVkQ3R4TWVhc3VyZVRleHQodCksXG4gICAgICBvcHRpb25zLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIlxuICAgICk7XG4gIH1cbiAgdGV4dFdpZHRoKHRleHQsIGVzdGltYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dE1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0LCBlc3RpbWF0ZSk7XG4gIH1cbiAgbWVhc3VyZVRleHQodGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRleHRNZWFzdXJlci5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgfVxuICBtZWFzdXJlTGluZXModGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRleHRNZWFzdXJlci5tZWFzdXJlTGluZXModGV4dCk7XG4gIH1cbiAgY2FjaGVkQ3R4TWVhc3VyZVRleHQodGV4dCkge1xuICAgIGlmICghdGhpcy5tZWFzdXJlTWFwLmhhcyh0ZXh0KSkge1xuICAgICAgY29uc3QgcmF3UmVzdWx0ID0gdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICB0aGlzLm1lYXN1cmVNYXAuc2V0KHRleHQsIHtcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgZW1IZWlnaHRBc2NlbnQ6IHJhd1Jlc3VsdC5lbUhlaWdodEFzY2VudCxcbiAgICAgICAgZW1IZWlnaHREZXNjZW50OiByYXdSZXN1bHQuZW1IZWlnaHREZXNjZW50LFxuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94TGVmdDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94TGVmdCxcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICAgIGFscGhhYmV0aWNCYXNlbGluZTogcmF3UmVzdWx0LmFscGhhYmV0aWNCYXNlbGluZSxcbiAgICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50OiByYXdSZXN1bHQuZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50OiByYXdSZXN1bHQuZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgaGFuZ2luZ0Jhc2VsaW5lOiByYXdSZXN1bHQuaGFuZ2luZ0Jhc2VsaW5lLFxuICAgICAgICBpZGVvZ3JhcGhpY0Jhc2VsaW5lOiByYXdSZXN1bHQuaWRlb2dyYXBoaWNCYXNlbGluZSxcbiAgICAgICAgd2lkdGg6IHJhd1Jlc3VsdC53aWR0aFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lYXN1cmVNYXAuZ2V0KHRleHQpO1xuICB9XG59O1xudmFyIFRleHRVdGlscyA9IGNsYXNzIHtcbiAgc3RhdGljIHRvRm9udFN0cmluZyh7IGZvbnRTaXplID0gMTAsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udEZhbWlseSwgbGluZUhlaWdodCB9KSB7XG4gICAgbGV0IGZvbnRTdHJpbmcgPSBcIlwiO1xuICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYCR7Zm9udFN0eWxlfSBgO1xuICAgIH1cbiAgICBpZiAoZm9udFdlaWdodCkge1xuICAgICAgZm9udFN0cmluZyArPSBgJHtmb250V2VpZ2h0fSBgO1xuICAgIH1cbiAgICBmb250U3RyaW5nICs9IGAke2ZvbnRTaXplfXB4YDtcbiAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgZm9udFN0cmluZyArPSBgLyR7bGluZUhlaWdodH1weGA7XG4gICAgfVxuICAgIGZvbnRTdHJpbmcgKz0gYCAke2ZvbnRGYW1pbHl9YDtcbiAgICByZXR1cm4gZm9udFN0cmluZy50cmltKCk7XG4gIH1cbiAgc3RhdGljIGdldExpbmVIZWlnaHQoZm9udFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGZvbnRTaXplICogdGhpcy5kZWZhdWx0TGluZUhlaWdodCk7XG4gIH1cbiAgLy8gRGV0ZXJtaW5lcyB2ZXJ0aWNhbCBvZmZzZXQgbW9kaWZpZXIgYmFzZWQgb24gdGV4dCBiYXNlbGluZS5cbiAgc3RhdGljIGdldFZlcnRpY2FsTW9kaWZpZXIodGV4dEJhc2VsaW5lKSB7XG4gICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGNhc2UgXCJoYW5naW5nXCI6XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICByZXR1cm4gMC41O1xuICAgICAgY2FzZSBcImFscGhhYmV0aWNcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIGNhc2UgXCJpZGVvZ3JhcGhpY1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG59O1xuVGV4dFV0aWxzLkVsbGlwc2lzQ2hhciA9IFwiXFx1MjAyNlwiO1xuLy8gUmVwcmVzZW50YXRpb24gZm9yIHRleHQgY2xpcHBpbmcuXG5UZXh0VXRpbHMuZGVmYXVsdExpbmVIZWlnaHQgPSAxLjE1O1xuLy8gTm9ybWFsbHkgYmV0d2VlbiAxLjEgYW5kIDEuMlxuVGV4dFV0aWxzLmxpbmVTcGxpdHRlciA9IC9cXHI/XFxuL2c7XG52YXIgU2ltcGxlVGV4dE1lYXN1cmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtZWFzdXJlVGV4dEZuLCB0ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIikge1xuICAgIHRoaXMubWVhc3VyZVRleHRGbiA9IG1lYXN1cmVUZXh0Rm47XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgLy8gbG9jYWwgY2hhcnMgd2lkdGggY2FjaGUgcGVyIFRleHRNZWFzdXJlclxuICAgIHRoaXMuY2hhck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLy8gTWVhc3VyZXMgbWV0cmljcyBmb3IgYSBzaW5nbGUgbGluZSBvZiB0ZXh0LlxuICBnZXRNZXRyaWNzKHRleHQpIHtcbiAgICBjb25zdCBtID0gdGhpcy5tZWFzdXJlVGV4dEZuKHRleHQpO1xuICAgIG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID8/IChtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA9IG0uZW1IZWlnaHRBc2NlbnQpO1xuICAgIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID0gbS5lbUhlaWdodERlc2NlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogbS53aWR0aCxcbiAgICAgIGhlaWdodDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgbGluZUhlaWdodDogbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgKyBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBvZmZzZXRUb3A6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBvZmZzZXRMZWZ0OiBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdFxuICAgIH07XG4gIH1cbiAgLy8gQ2FsY3VsYXRlcyBhZ2dyZWdhdGVkIG1ldHJpY3MgZm9yIG11bHRpbGluZSB0ZXh0LlxuICBnZXRNdWx0aWxpbmVNZXRyaWNzKGxpbmVzKSB7XG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICBsZXQgb2Zmc2V0VG9wID0gMDtcbiAgICBsZXQgb2Zmc2V0TGVmdCA9IDA7XG4gICAgbGV0IGJhc2VsaW5lRGlzdGFuY2UgPSAwO1xuICAgIGNvbnN0IHZlcnRpY2FsTW9kaWZpZXIgPSBUZXh0VXRpbHMuZ2V0VmVydGljYWxNb2RpZmllcih0aGlzLnRleHRCYXNlbGluZSk7XG4gICAgY29uc3QgbGluZU1ldHJpY3MgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGxlbmd0aDIgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5tZWFzdXJlVGV4dEZuKGxpbmUpO1xuICAgICAgbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID0gbS5lbUhlaWdodEFzY2VudCk7XG4gICAgICBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA9IG0uZW1IZWlnaHREZXNjZW50KTtcbiAgICAgIGlmICh3aWR0aCA8IG0ud2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSBtLndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldExlZnQgPCBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdCkge1xuICAgICAgICBvZmZzZXRMZWZ0ID0gbS5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgaGVpZ2h0ICs9IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICAgIG9mZnNldFRvcCArPSBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSArPSBtLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gbGVuZ3RoMiAtIDEpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSArPSBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICB9XG4gICAgICBsaW5lTWV0cmljcy5wdXNoKHtcbiAgICAgICAgdGV4dDogbGluZSxcbiAgICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBsaW5lSGVpZ2h0OiBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCArIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgb2Zmc2V0VG9wOiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBvZmZzZXRMZWZ0OiBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdFxuICAgICAgfSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBoZWlnaHQgKz0gYmFzZWxpbmVEaXN0YW5jZTtcbiAgICBvZmZzZXRUb3AgKz0gYmFzZWxpbmVEaXN0YW5jZSAqIHZlcnRpY2FsTW9kaWZpZXI7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCBsaW5lTWV0cmljcyB9O1xuICB9XG4gIHRleHRXaWR0aCh0ZXh0LCBlc3RpbWF0ZSkge1xuICAgIGlmIChlc3RpbWF0ZSkge1xuICAgICAgbGV0IGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlc3RpbWF0ZWRXaWR0aCArPSB0aGlzLnRleHRXaWR0aCh0ZXh0LmNoYXJBdChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXN0aW1hdGVkV2lkdGg7XG4gICAgfVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lYXN1cmVUZXh0Rm4odGV4dCkud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoYXJNYXAuZ2V0KHRleHQpID8/IHRoaXMuY2hhcldpZHRoKHRleHQpO1xuICB9XG4gIG1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNZXRyaWNzKHRleHQpO1xuICB9XG4gIC8vIE1lYXN1cmVzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcm92aWRlZCB0ZXh0LCBoYW5kbGluZyBtdWx0aWxpbmUgaWYgbmVlZGVkLlxuICBtZWFzdXJlTGluZXModGV4dCkge1xuICAgIGNvbnN0IGxpbmVzID0gdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgPyB0ZXh0LnNwbGl0KFRleHRVdGlscy5saW5lU3BsaXR0ZXIpIDogdGV4dDtcbiAgICByZXR1cm4gdGhpcy5nZXRNdWx0aWxpbmVNZXRyaWNzKGxpbmVzKTtcbiAgfVxuICBjaGFyV2lkdGgoY2hhcikge1xuICAgIGNvbnN0IHsgd2lkdGggfSA9IHRoaXMubWVhc3VyZVRleHRGbihjaGFyKTtcbiAgICB0aGlzLmNoYXJNYXAuc2V0KGNoYXIsIHdpZHRoKTtcbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3RleHQudHNcbmZ1bmN0aW9uIFNjZW5lRm9udENoYW5nZURldGVjdGlvbihvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMyAvKiBNQUpPUiAqLywgY2hhbmdlQ2IgfSA9IG9wdHMgPz8ge307XG4gIHJldHVybiBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdywgdHlwZTogXCJmb250XCIsIGNoYW5nZUNiIH0pO1xufVxudmFyIF9UZXh0ID0gY2xhc3MgX1RleHQgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMudGV4dEFsaWduID0gX1RleHQuZGVmYXVsdFN0eWxlcy50ZXh0QWxpZ247XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSBfVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRCYXNlbGluZTtcbiAgfVxuICBvblRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5saW5lcyA9IHRoaXMudGV4dD8uc3BsaXQoXCJcXG5cIikubWFwKChzKSA9PiBzLnRyaW0oKSkgPz8gW107XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVCQm94KGxpbmVzLCB4LCB5LCBvcHRzKSB7XG4gICAgY29uc3QgeyBvZmZzZXRUb3AsIG9mZnNldExlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wubWVhc3VyZUxpbmVzKGxpbmVzLCBvcHRzKTtcbiAgICByZXR1cm4gbmV3IEJCb3goeCAtIG9mZnNldExlZnQsIHkgLSBvZmZzZXRUb3AsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgbGluZXMsIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH0gPSB0aGlzO1xuICAgIHJldHVybiBfVGV4dC5jb21wdXRlQkJveChsaW5lcywgeCwgeSwgeyBmb250OiB0aGlzLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9KTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiBiYm94ID8gYmJveC5jb250YWluc1BvaW50KHBvaW50LngsIHBvaW50LnkpIDogZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggfHwgIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCk7XG4gICAgY29uc3QgeyBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGl4ZWxSYXRpbyB9ID0gdGhpcy5sYXllck1hbmFnZXIuY2FudmFzO1xuICAgIGN0eC5mb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZyh0aGlzKTtcbiAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuICAgIGlmIChmaWxsKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLmZpbGxPcGFjaXR5O1xuICAgICAgY29uc3QgeyBmaWxsU2hhZG93IH0gPSB0aGlzO1xuICAgICAgaWYgKGZpbGxTaGFkb3c/LmVuYWJsZWQpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gZmlsbFNoYWRvdy5jb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBmaWxsU2hhZG93LnhPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IGZpbGxTaGFkb3cueU9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gZmlsbFNoYWRvdy5ibHVyICogcGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyTGluZXMoKGxpbmUsIHgsIHkpID0+IGN0eC5maWxsVGV4dChsaW5lLCB4LCB5KSk7XG4gICAgfVxuICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlV2lkdGgpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICBjb25zdCB7IGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgbGluZUNhcCwgbGluZUpvaW4gfSA9IHRoaXM7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyTGluZXMoKGxpbmUsIHgsIHkpID0+IGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHkpKTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbiAgcmVuZGVyTGluZXMocmVuZGVyQ2FsbGJhY2spIHtcbiAgICBjb25zdCB7IGxpbmVzLCB4LCB5IH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQgPz8gVGV4dFV0aWxzLmdldExpbmVIZWlnaHQodGhpcy5mb250U2l6ZSk7XG4gICAgbGV0IG9mZnNldFkgPSAobGluZUhlaWdodCAtIGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGgpICogVGV4dFV0aWxzLmdldFZlcnRpY2FsTW9kaWZpZXIodGhpcy50ZXh0QmFzZWxpbmUpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgcmVuZGVyQ2FsbGJhY2sobGluZSwgeCwgeSArIG9mZnNldFkpO1xuICAgICAgb2Zmc2V0WSArPSBsaW5lSGVpZ2h0O1xuICAgIH1cbiAgfVxuICBzZXRGb250KHByb3BzKSB7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gcHJvcHMuZm9udEZhbWlseTtcbiAgICB0aGlzLmZvbnRTaXplID0gcHJvcHMuZm9udFNpemU7XG4gICAgdGhpcy5mb250U3R5bGUgPSBwcm9wcy5mb250U3R5bGU7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gcHJvcHMuZm9udFdlaWdodDtcbiAgfVxuICBzZXRBbGlnbihwcm9wcykge1xuICAgIHRoaXMudGV4dEFsaWduID0gcHJvcHMudGV4dEFsaWduO1xuICAgIHRoaXMudGV4dEJhc2VsaW5lID0gcHJvcHMudGV4dEJhc2VsaW5lO1xuICB9XG59O1xuX1RleHQuY2xhc3NOYW1lID0gXCJUZXh0XCI7XG4vLyBUaGUgZGVmYXVsdCBsaW5lIHNwYWNpbmcgZm9yIGRvY3VtZW50IGVkaXRvcnMgaXMgdXN1YWxseSAxLjE1XG5fVGV4dC5kZWZhdWx0TGluZUhlaWdodFJhdGlvID0gMS4xNTtcbl9UZXh0LmRlZmF1bHRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTaGFwZS5kZWZhdWx0U3R5bGVzLCB7XG4gIHRleHRBbGlnbjogXCJzdGFydFwiLFxuICBmb250U3R5bGU6IHZvaWQgMCxcbiAgZm9udFdlaWdodDogdm9pZCAwLFxuICBmb250U2l6ZTogMTAsXG4gIGZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiLFxuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiXG59KTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCBjaGFuZ2VDYjogKG8pID0+IG8ub25UZXh0Q2hhbmdlKCkgfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ0ZXh0QWxpZ25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInRleHRCYXNlbGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwibGluZUhlaWdodFwiLCAyKTtcbnZhciBUZXh0ID0gX1RleHQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvbGFiZWxQbGFjZW1lbnQudHNcbmZ1bmN0aW9uIGNpcmNsZVJlY3RPdmVybGFwKGMsIHVuaXRDZW50ZXIsIHgsIHksIHcsIGgpIHtcbiAgaWYgKGMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3ggPSBjLng7XG4gIGxldCBjeSA9IGMueTtcbiAgaWYgKHVuaXRDZW50ZXIgIT0gbnVsbCkge1xuICAgIGN4IC09ICh1bml0Q2VudGVyLnggLSAwLjUpICogYy5zaXplO1xuICAgIGN5IC09ICh1bml0Q2VudGVyLnkgLSAwLjUpICogYy5zaXplO1xuICB9XG4gIGxldCBlZGdlWCA9IGN4O1xuICBpZiAoY3ggPCB4KSB7XG4gICAgZWRnZVggPSB4O1xuICB9IGVsc2UgaWYgKGN4ID4geCArIHcpIHtcbiAgICBlZGdlWCA9IHggKyB3O1xuICB9XG4gIGxldCBlZGdlWSA9IGN5O1xuICBpZiAoY3kgPCB5KSB7XG4gICAgZWRnZVkgPSB5O1xuICB9IGVsc2UgaWYgKGN5ID4geSArIGgpIHtcbiAgICBlZGdlWSA9IHkgKyBoO1xuICB9XG4gIGNvbnN0IGR4ID0gY3ggLSBlZGdlWDtcbiAgY29uc3QgZHkgPSBjeSAtIGVkZ2VZO1xuICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgcmV0dXJuIGQgPD0gYy5zaXplICogMC41O1xufVxuZnVuY3Rpb24gcmVjdFJlY3RPdmVybGFwKHIxLCB4MiwgeTIsIHcyLCBoMikge1xuICBjb25zdCB4T3ZlcmxhcCA9IHIxLnggKyByMS53aWR0aCA+IHgyICYmIHIxLnggPCB4MiArIHcyO1xuICBjb25zdCB5T3ZlcmxhcCA9IHIxLnkgKyByMS5oZWlnaHQgPiB5MiAmJiByMS55IDwgeTIgKyBoMjtcbiAgcmV0dXJuIHhPdmVybGFwICYmIHlPdmVybGFwO1xufVxuZnVuY3Rpb24gcmVjdENvbnRhaW5zUmVjdChyMSwgcjJ4LCByMnksIHIydywgcjJoKSB7XG4gIHJldHVybiByMnggKyByMncgPCByMS54ICsgcjEud2lkdGggJiYgcjJ4ID4gcjEueCAmJiByMnkgPiByMS55ICYmIHIyeSArIHIyaCA8IHIxLnkgKyByMS5oZWlnaHQ7XG59XG5mdW5jdGlvbiBpc1BvaW50TGFiZWxEYXR1bSh4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHgucG9pbnQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHgubGFiZWwgPT09IFwib2JqZWN0XCI7XG59XG52YXIgbGFiZWxQbGFjZW1lbnRzID0ge1xuICB0b3A6IHsgeDogMCwgeTogLTEgfSxcbiAgYm90dG9tOiB7IHg6IDAsIHk6IDEgfSxcbiAgbGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICByaWdodDogeyB4OiAxLCB5OiAwIH1cbn07XG5mdW5jdGlvbiBwbGFjZUxhYmVscyhkYXRhLCBib3VuZHMsIHBhZGRpbmcgPSA1KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBkYXRhID0gZGF0YS5tYXAoKGQpID0+IGQuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBiLnBvaW50LnNpemUgLSBhLnBvaW50LnNpemUpKTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGFiZWxzID0gcmVzdWx0W2pdID0gW107XG4gICAgY29uc3QgZGF0dW0gPSBkYXRhW2pdO1xuICAgIGlmICghKGRhdHVtPy5sZW5ndGggJiYgZGF0dW1bMF0ubGFiZWwpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsbiA9IGRhdHVtLmxlbmd0aDsgaW5kZXggPCBsbjsgaW5kZXgrKykge1xuICAgICAgY29uc3QgZCA9IGRhdHVtW2luZGV4XTtcbiAgICAgIGNvbnN0IHsgcG9pbnQsIGxhYmVsLCBtYXJrZXIgfSA9IGQ7XG4gICAgICBjb25zdCB7IHRleHQsIHdpZHRoLCBoZWlnaHQgfSA9IGxhYmVsO1xuICAgICAgY29uc3QgciA9IHBvaW50LnNpemUgKiAwLjU7XG4gICAgICBsZXQgZHggPSAwO1xuICAgICAgbGV0IGR5ID0gMDtcbiAgICAgIGlmIChyID4gMCAmJiBkLnBsYWNlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IGxhYmVsUGxhY2VtZW50c1tkLnBsYWNlbWVudF07XG4gICAgICAgIGR4ID0gKHdpZHRoICogMC41ICsgciArIHBhZGRpbmcpICogcGxhY2VtZW50Lng7XG4gICAgICAgIGR5ID0gKGhlaWdodCAqIDAuNSArIHIgKyBwYWRkaW5nKSAqIHBsYWNlbWVudC55O1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IHBvaW50LnggLSB3aWR0aCAqIDAuNSArIGR4IC0gKChtYXJrZXI/LmNlbnRlci54ID8/IDAuNSkgLSAwLjUpICogcG9pbnQuc2l6ZTtcbiAgICAgIGNvbnN0IHkgPSBwb2ludC55IC0gaGVpZ2h0ICogMC41ICsgZHkgLSAoKG1hcmtlcj8uY2VudGVyLnkgPz8gMC41KSAtIDAuNSkgKiBwb2ludC5zaXplO1xuICAgICAgY29uc3Qgd2l0aGluQm91bmRzID0gIWJvdW5kcyB8fCByZWN0Q29udGFpbnNSZWN0KGJvdW5kcywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBpZiAoIXdpdGhpbkJvdW5kcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXBQb2ludHMgPSBkYXRhLnNvbWUoXG4gICAgICAgIChkYXRhRGF0dW1zKSA9PiBkYXRhRGF0dW1zLnNvbWUoXG4gICAgICAgICAgKGRhdGFEYXR1bSkgPT4gY2lyY2xlUmVjdE92ZXJsYXAoZGF0YURhdHVtLnBvaW50LCBkYXRhRGF0dW0ubWFya2VyPy5jZW50ZXIsIHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBpZiAob3ZlcmxhcFBvaW50cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXBMYWJlbHMgPSByZXN1bHQuc29tZSgobDIpID0+IGwyLnNvbWUoKGwzKSA9PiByZWN0UmVjdE92ZXJsYXAobDMsIHgsIHksIHdpZHRoLCBoZWlnaHQpKSk7XG4gICAgICBpZiAob3ZlcmxhcExhYmVscykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxhYmVscy5wdXNoKHsgaW5kZXgsIHRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRhdHVtOiBkIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXhpc0xhYmVsc092ZXJsYXAoZGF0YSwgcGFkZGluZykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZGF0dW0gPSBkYXRhW2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBwb2ludDogeyB4LCB5IH0sXG4gICAgICBsYWJlbDogeyB0ZXh0IH1cbiAgICB9ID0gZGF0dW07XG4gICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gZGF0dW0ubGFiZWw7XG4gICAgd2lkdGggKz0gcGFkZGluZyA/PyAwO1xuICAgIGhlaWdodCArPSBwYWRkaW5nID8/IDA7XG4gICAgaWYgKHJlc3VsdC5zb21lKChsKSA9PiByZWN0UmVjdE92ZXJsYXAobCwgeCwgeSwgd2lkdGgsIGhlaWdodCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goeyBpbmRleCwgdGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZGF0dW0gfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2VxdWFsLnRzXG5mdW5jdGlvbiBhcmVBcnJheU51bWJlcnNFcXVhbChhcnJBLCBhcnJCKSB7XG4gIHJldHVybiBhcnJBLmxlbmd0aCA9PT0gYXJyQi5sZW5ndGggJiYgYXJyQS5ldmVyeSgoaXRlbSwgaSkgPT4gTnVtYmVyKGl0ZW0pID09PSBOdW1iZXIoYXJyQltpXSkpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Byb3h5LnRzXG5mdW5jdGlvbiBQcm94eVByb3BlcnR5KHByb3h5UGF0aCwgY29uZmlnTWV0YWRhdGEpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwcm94eVBhdGgpID8gcHJveHlQYXRoIDogcHJveHlQYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBbcHJvcGVydHldID0gcGF0aEFycmF5O1xuICAgIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgICAodGFyZ2V0LCBfLCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlLFxuICAgICAgKHRhcmdldCkgPT4gdGFyZ2V0W3Byb3BlcnR5XSxcbiAgICAgIGNvbmZpZ01ldGFkYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICh0YXJnZXQsIF8sIHZhbHVlKSA9PiBzZXRQYXRoKHRhcmdldCwgcGF0aEFycmF5LCB2YWx1ZSksXG4gICAgKHRhcmdldCkgPT4gZ2V0UGF0aCh0YXJnZXQsIHBhdGhBcnJheSksXG4gICAgY29uZmlnTWV0YWRhdGFcbiAgKTtcbn1cbmZ1bmN0aW9uIFByb3h5T25Xcml0ZShwcm94eVByb3BlcnR5KSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwgXywgdmFsdWUpID0+IHRhcmdldFtwcm94eVByb3BlcnR5XSA9IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIFByb3h5UHJvcGVydHlPbldyaXRlKGNoaWxkTmFtZSwgY2hpbGRQcm9wZXJ0eSkge1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHRhcmdldFtjaGlsZE5hbWVdW2NoaWxkUHJvcGVydHkgPz8ga2V5XSA9IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIEFjdGlvbk9uU2V0KG9wdHMpIHtcbiAgY29uc3QgeyBuZXdWYWx1ZTogbmV3VmFsdWVGbiwgb2xkVmFsdWU6IG9sZFZhbHVlRm4sIGNoYW5nZVZhbHVlOiBjaGFuZ2VWYWx1ZUZuIH0gPSBvcHRzO1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIF8sIG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG9sZFZhbHVlRm4/LmNhbGwodGFyZ2V0LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBuZXdWYWx1ZUZuPy5jYWxsKHRhcmdldCwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgY2hhbmdlVmFsdWVGbj8uY2FsbCh0YXJnZXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBPYnNlcnZlQ2hhbmdlcyhvYnNlcnZlckZuKSB7XG4gIHJldHVybiBhZGRPYnNlcnZlclRvSW5zdGFuY2VQcm9wZXJ0eShvYnNlcnZlckZuKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zdGF0ZU1hY2hpbmUudHNcbnZhciBkZWJ1Z0NvbG9yID0gXCJjb2xvcjogZ3JlZW5cIjtcbnZhciBkZWJ1Z1F1aWV0Q29sb3IgPSBcImNvbG9yOiBncmV5XCI7XG52YXIgX1N0YXRlTWFjaGluZSA9IGNsYXNzIF9TdGF0ZU1hY2hpbmUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0U3RhdGUsIHN0YXRlcywgZW50ZXJFYWNoKSB7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgdGhpcy5lbnRlckVhY2ggPSBlbnRlckVhY2g7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLnN0YXRlID0gZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuZGVidWcoYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgaW5pdCAtPiAke2RlZmF1bHRTdGF0ZX1gLCBkZWJ1Z0NvbG9yKTtcbiAgfVxuICB0cmFuc2l0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc2hvdWxkVHJhbnNpdGlvblNlbGYgPSB0aGlzLnRyYW5zaXRpb25DaGlsZChldmVudCwgZGF0YSk7XG4gICAgaWYgKCFzaG91bGRUcmFuc2l0aW9uU2VsZiB8fCB0aGlzLnN0YXRlID09PSBfU3RhdGVNYWNoaW5lLmNoaWxkIHx8IHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY3VycmVudFN0YXRlQ29uZmlnID0gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZV07XG4gICAgbGV0IGRlc3RpbmF0aW9uID0gY3VycmVudFN0YXRlQ29uZmlnW2V2ZW50XTtcbiAgICBjb25zdCBkZWJ1Z1ByZWZpeCA9IGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7dGhpcy5zdGF0ZX0gLT4gJHtldmVudH0gLT5gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9uKSkge1xuICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5maW5kKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbi5ndWFyZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0cmFuc2l0aW9uLmd1YXJkKGRhdGEpO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHt0cmFuc2l0aW9uLnRhcmdldH0gKGd1YXJkZWQpYCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJvYmplY3RcIiAmJiAhKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkgJiYgZGVzdGluYXRpb24uZ3VhcmQgJiYgIWRlc3RpbmF0aW9uLmd1YXJkKGRhdGEpKSB7XG4gICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke2Rlc3RpbmF0aW9uLnRhcmdldH0gKGd1YXJkZWQpYCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHt0aGlzLnN0YXRlfWAsIGRlYnVnUXVpZXRDb2xvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9uU3RhdGUgPSB0aGlzLmdldERlc3RpbmF0aW9uU3RhdGUoZGVzdGluYXRpb24pO1xuICAgIGNvbnN0IGV4aXRGbiA9IGRlc3RpbmF0aW9uU3RhdGUgPT09IHRoaXMuc3RhdGUgPyB2b2lkIDAgOiBjdXJyZW50U3RhdGVDb25maWcub25FeGl0O1xuICAgIHRoaXMuZGVidWcoYCR7ZGVidWdQcmVmaXh9ICR7ZGVzdGluYXRpb25TdGF0ZX1gLCBkZWJ1Z0NvbG9yKTtcbiAgICB0aGlzLnN0YXRlID0gZGVzdGluYXRpb25TdGF0ZTtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlc3RpbmF0aW9uKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiICYmICEoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSkge1xuICAgICAgZGVzdGluYXRpb24uYWN0aW9uPy4oZGF0YSk7XG4gICAgfVxuICAgIGV4aXRGbj8uKCk7XG4gICAgdGhpcy5lbnRlckVhY2g/LihjdXJyZW50U3RhdGUsIGRlc3RpbmF0aW9uU3RhdGUpO1xuICAgIGlmIChkZXN0aW5hdGlvblN0YXRlICE9PSBjdXJyZW50U3RhdGUgJiYgZGVzdGluYXRpb25TdGF0ZSAhPT0gX1N0YXRlTWFjaGluZS5jaGlsZCAmJiBkZXN0aW5hdGlvblN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLnBhcmVudCkge1xuICAgICAgdGhpcy5zdGF0ZXNbZGVzdGluYXRpb25TdGF0ZV0ub25FbnRlcj8uKGN1cnJlbnRTdGF0ZSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIGlzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgJiYgdGhpcy5jaGlsZFN0YXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZFN0YXRlLmlzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHZhbHVlO1xuICB9XG4gIHJlc2V0SGllcmFyY2h5KCkge1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+IFtyZXNldEhpZXJhcmNoeV0gLT4gJHt0aGlzLmRlZmF1bHRTdGF0ZX1gLFxuICAgICAgXCJjb2xvcjogZ3JlZW5cIlxuICAgICk7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIHRyYW5zaXRpb25DaGlsZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLmNoaWxkIHx8ICF0aGlzLmNoaWxkU3RhdGUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0aGlzLmNoaWxkU3RhdGUudHJhbnNpdGlvbihldmVudCwgZGF0YSk7XG4gICAgaWYgKCF0aGlzLmNoaWxkU3RhdGUuaXMoX1N0YXRlTWFjaGluZS5wYXJlbnQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+ICR7ZXZlbnR9IC0+ICR7dGhpcy5kZWZhdWx0U3RhdGV9YCwgZGVidWdDb2xvcik7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVdLm9uRW50ZXI/LigpO1xuICAgIHRoaXMuY2hpbGRTdGF0ZS5yZXNldEhpZXJhcmNoeSgpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXREZXN0aW5hdGlvblN0YXRlKGRlc3RpbmF0aW9uKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdGF0ZSA9IGRlc3RpbmF0aW9uO1xuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSB7XG4gICAgICB0aGlzLmNoaWxkU3RhdGUgPSBkZXN0aW5hdGlvbjtcbiAgICAgIHN0YXRlID0gX1N0YXRlTWFjaGluZS5jaGlsZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uLnRhcmdldCBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgdGhpcy5jaGlsZFN0YXRlID0gZGVzdGluYXRpb24udGFyZ2V0O1xuICAgICAgICBzdGF0ZSA9IF9TdGF0ZU1hY2hpbmUuY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IGRlc3RpbmF0aW9uLnRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuX1N0YXRlTWFjaGluZS5jaGlsZCA9IFwiX19jaGlsZFwiO1xuX1N0YXRlTWFjaGluZS5wYXJlbnQgPSBcIl9fcGFyZW50XCI7XG52YXIgU3RhdGVNYWNoaW5lID0gX1N0YXRlTWFjaGluZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZXh0V3JhcHBlci50c1xudmFyIFRleHRXcmFwcGVyID0gY2xhc3Mge1xuICBzdGF0aWMgd3JhcFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLndyYXBMaW5lcyh0ZXh0LCBvcHRpb25zKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHN0YXRpYyB3cmFwTGluZXModGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNsaXBwZWRSZXN1bHQgPSB0aGlzLnRleHRXcmFwKHRleHQsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm92ZXJmbG93ID09PSBcImhpZGVcIiAmJiBjbGlwcGVkUmVzdWx0LnNvbWUoKGwpID0+IGwuZW5kc1dpdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcikpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjbGlwcGVkUmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhcHBlbmRFbGxpcHNpcyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy4sXXsxLDV9JC8sIFwiXCIpICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcjtcbiAgfVxuICBzdGF0aWMgdHJ1bmNhdGVMaW5lKHRleHQsIG1lYXN1cmVyLCBtYXhXaWR0aCwgZWxsaXBzaXNGb3JjZSkge1xuICAgIGNvbnN0IGVsbGlwc2lzV2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcik7XG4gICAgbGV0IGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgodGV4dC5jaGFyQXQoaSkpO1xuICAgICAgaWYgKGVzdGltYXRlZFdpZHRoICsgY2hhcldpZHRoID4gbWF4V2lkdGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZXN0aW1hdGVkV2lkdGggKz0gY2hhcldpZHRoO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPT09IGkgJiYgKCFlbGxpcHNpc0ZvcmNlIHx8IGVzdGltYXRlZFdpZHRoICsgZWxsaXBzaXNXaWR0aCA8PSBtYXhXaWR0aCkpIHtcbiAgICAgIHJldHVybiBlbGxpcHNpc0ZvcmNlID8gdGV4dCArIFRleHRVdGlscy5FbGxpcHNpc0NoYXIgOiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBpKS50cmltRW5kKCk7XG4gICAgd2hpbGUgKHRleHQubGVuZ3RoICYmIG1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0KSArIGVsbGlwc2lzV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpLnRyaW1FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQgKyBUZXh0VXRpbHMuRWxsaXBzaXNDaGFyO1xuICB9XG4gIHN0YXRpYyB0ZXh0V3JhcCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFRleHRVdGlscy5saW5lU3BsaXR0ZXIpO1xuICAgIGNvbnN0IG1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJuZXZlclwiKSB7XG4gICAgICByZXR1cm4gbGluZXMubWFwKChsaW5lKSA9PiB0aGlzLnRydW5jYXRlTGluZShsaW5lLnRyaW1FbmQoKSwgbWVhc3VyZXIsIG9wdGlvbnMubWF4V2lkdGgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgd3JhcEh5cGhlbmF0ZSA9IG9wdGlvbnMudGV4dFdyYXAgPT09IFwiaHlwaGVuYXRlXCI7XG4gICAgY29uc3Qgd3JhcE9uU3BhY2UgPSBvcHRpb25zLnRleHRXcmFwID09IG51bGwgfHwgb3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJvbi1zcGFjZVwiO1xuICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW1FbmQoKTtcbiAgICAgIGlmIChsaW5lID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBlc3RpbWF0ZWRXaWR0aCA9IDAsIGxhc3RTcGFjZUluZGV4ID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGxpbmUuY2hhckF0KGkpO1xuICAgICAgICBlc3RpbWF0ZWRXaWR0aCArPSBtZWFzdXJlci50ZXh0V2lkdGgoY2hhcik7XG4gICAgICAgIGlmIChjaGFyID09PSBcIiBcIikge1xuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXN0aW1hdGVkV2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aChsaW5lLnNsaWNlKDAsIGkgKyAxKSk7XG4gICAgICAgICAgaWYgKGFjdHVhbFdpZHRoIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZFdpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxhc3RTcGFjZUluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0V29yZCA9IHRoaXMuZ2V0V29yZEF0KGxpbmUsIGxhc3RTcGFjZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgobmV4dFdvcmQpO1xuICAgICAgICAgICAgaWYgKHRleHRXaWR0aCA8PSBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpLnRyaW1FbmQoKSk7XG4gICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGxhc3RTcGFjZUluZGV4KS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgICBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBPblNwYWNlICYmIHRleHRXaWR0aCA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgbGluZS5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCkudHJpbUVuZCgpLFxuICAgICAgICAgICAgICAgIHRoaXMudHJ1bmNhdGVMaW5lKFxuICAgICAgICAgICAgICAgICAgbGluZS5zbGljZShsYXN0U3BhY2VJbmRleCkudHJpbVN0YXJ0KCksXG4gICAgICAgICAgICAgICAgICBtZWFzdXJlcixcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAod3JhcE9uU3BhY2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMudHJ1bmNhdGVMaW5lKGxpbmUsIG1lYXN1cmVyLCBvcHRpb25zLm1heFdpZHRoLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3cmFwT25TcGFjZSkge1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcG9zdGZpeCA9IHdyYXBIeXBoZW5hdGUgPyBcIi1cIiA6IFwiXCI7XG4gICAgICAgICAgbGV0IG5ld0xpbmUgPSBsaW5lLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgICAgICB3aGlsZSAobmV3TGluZS5sZW5ndGggJiYgbWVhc3VyZXIudGV4dFdpZHRoKG5ld0xpbmUgKyBwb3N0Zml4KSA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIG5ld0xpbmUgPSBuZXdMaW5lLnNsaWNlKDAsIC0xKS50cmltRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld0xpbmUgKyBwb3N0Zml4KTtcbiAgICAgICAgICBpZiAoIW5ld0xpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShuZXdMaW5lLmxlbmd0aCkudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgIGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmF2b2lkT3JwaGFucyhyZXN1bHQsIG1lYXN1cmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGlwTGluZXMocmVzdWx0LCBtZWFzdXJlciwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGdldFdvcmRBdCh0ZXh0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IG5leHRTcGFjZUluZGV4ID0gdGV4dC5pbmRleE9mKFwiIFwiLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIG5leHRTcGFjZUluZGV4ID09PSAtMSA/IHRleHQuc2xpY2UocG9zaXRpb24pIDogdGV4dC5zbGljZShwb3NpdGlvbiwgbmV4dFNwYWNlSW5kZXgpO1xuICB9XG4gIHN0YXRpYyBjbGlwTGluZXMobGluZXMsIG1lYXN1cmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBjb25zdCB7IGhlaWdodCwgbGluZU1ldHJpY3MgfSA9IG1lYXN1cmVyLm1lYXN1cmVMaW5lcyhsaW5lcyk7XG4gICAgaWYgKGhlaWdodCA8PSBvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgY3VtdWxhdGl2ZUhlaWdodCA9IDA7IGkgPCBsaW5lTWV0cmljcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBsaW5lSGVpZ2h0IH0gPSBsaW5lTWV0cmljc1tpXTtcbiAgICAgIGN1bXVsYXRpdmVIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgIGlmIChjdW11bGF0aXZlSGVpZ2h0ID4gb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcmZsb3cgPT09IFwiaGlkZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaXBwZWRSZXN1bHRzID0gbGluZXMuc2xpY2UoMCwgaSB8fCAxKTtcbiAgICAgICAgY29uc3QgbGFzdExpbmUgPSBjbGlwcGVkUmVzdWx0cy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGNsaXBwZWRSZXN1bHRzLmNvbmNhdCh0aGlzLnRydW5jYXRlTGluZShsYXN0TGluZSwgbWVhc3VyZXIsIG9wdGlvbnMubWF4V2lkdGgsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIHN0YXRpYyBhdm9pZE9ycGhhbnMobGluZXMsIG1lYXN1cmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYXZvaWRPcnBoYW5zID09PSBmYWxzZSB8fCBsaW5lcy5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGVuZ3RoOiBsZW5ndGgyIH0gPSBsaW5lcztcbiAgICBjb25zdCBsYXN0TGluZSA9IGxpbmVzW2xlbmd0aDIgLSAxXTtcbiAgICBjb25zdCBiZWZvcmVMYXN0ID0gbGluZXNbbGVuZ3RoMiAtIDJdO1xuICAgIGlmIChiZWZvcmVMYXN0Lmxlbmd0aCA8IGxhc3RMaW5lLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsYXN0U3BhY2VJbmRleCA9IGJlZm9yZUxhc3QubGFzdEluZGV4T2YoXCIgXCIpO1xuICAgIGlmIChsYXN0U3BhY2VJbmRleCA9PT0gLTEgfHwgbGFzdFNwYWNlSW5kZXggPT09IGJlZm9yZUxhc3QuaW5kZXhPZihcIiBcIikgfHwgbGFzdExpbmUuaW5jbHVkZXMoXCIgXCIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxhc3RXb3JkID0gYmVmb3JlTGFzdC5zbGljZShsYXN0U3BhY2VJbmRleCArIDEpO1xuICAgIGlmIChtZWFzdXJlci50ZXh0V2lkdGgobGFzdExpbmUgKyBsYXN0V29yZCkgPD0gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgbGluZXNbbGVuZ3RoMiAtIDJdID0gYmVmb3JlTGFzdC5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCk7XG4gICAgICBsaW5lc1tsZW5ndGgyIC0gMV0gPSBsYXN0V29yZCArIFwiIFwiICsgbGFzdExpbmU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2F0dHJpYnV0ZVV0aWwudHNcbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlLCBxdWFsaWZpZWROYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgIGU/LnJlbW92ZUF0dHJpYnV0ZShxdWFsaWZpZWROYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlPy5zZXRBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZpc2liaWxpdHkoZWxlbWVudDIsIGhpZGRlblRva2VuLCBoaWRkZW4pIHtcbiAgZWxlbWVudDIuYXJpYUhpZGRlbiA9IGAke2hpZGRlbn1gO1xuICBlbGVtZW50Mi5jbGFzc0xpc3QudG9nZ2xlKGhpZGRlblRva2VuLCBoaWRkZW4pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3BsYWNlbWVudC50c1xuZnVuY3Rpb24gY2FsY3VsYXRlUGxhY2VtZW50KG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCwgY29udGFpbmVyLCBib3VuZHMpIHtcbiAgbGV0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBib3VuZHM7XG4gIGlmIChsZWZ0ICE9IG51bGwpIHtcbiAgICBpZiAod2lkdGggIT0gbnVsbCkge1xuICAgICAgcmlnaHQgPSBjb250YWluZXIud2lkdGggLSBsZWZ0ICsgd2lkdGg7XG4gICAgfSBlbHNlIGlmIChyaWdodCAhPSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGNvbnRhaW5lci53aWR0aCAtIGxlZnQgLSByaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmlnaHQgIT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsKSB7XG4gICAgbGVmdCA9IGNvbnRhaW5lci53aWR0aCAtIHJpZ2h0IC0gd2lkdGg7XG4gIH1cbiAgaWYgKHRvcCAhPSBudWxsKSB7XG4gICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICBib3R0b20gPSBjb250YWluZXIuaGVpZ2h0IC0gdG9wIC0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoYm90dG9tICE9IG51bGwpIHtcbiAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQgLSBib3R0b20gLSB0b3A7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJvdHRvbSAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdG9wID0gY29udGFpbmVyLmhlaWdodCAtIGJvdHRvbSAtIGhlaWdodDtcbiAgfVxuICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgd2lkdGggPSBuYXR1cmFsV2lkdGg7XG4gICAgICBoZWlnaHQgPSBuYXR1cmFsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IE1hdGguY2VpbChuYXR1cmFsV2lkdGggKiBoZWlnaHQgLyBuYXR1cmFsSGVpZ2h0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBNYXRoLmNlaWwobmF0dXJhbEhlaWdodCAqIHdpZHRoIC8gbmF0dXJhbFdpZHRoKTtcbiAgfVxuICBpZiAobGVmdCA9PSBudWxsKSB7XG4gICAgaWYgKHJpZ2h0ID09IG51bGwpIHtcbiAgICAgIGxlZnQgPSBNYXRoLmZsb29yKChjb250YWluZXIud2lkdGggLSB3aWR0aCkgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGNvbnRhaW5lci53aWR0aCAtIHJpZ2h0IC0gd2lkdGg7XG4gICAgfVxuICB9XG4gIGlmICh0b3AgPT0gbnVsbCkge1xuICAgIGlmIChib3R0b20gPT0gbnVsbCkge1xuICAgICAgdG9wID0gTWF0aC5mbG9vcigoY29udGFpbmVyLmhlaWdodCAtIGhlaWdodCkgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gY29udGFpbmVyLmhlaWdodCAtIGhlaWdodCAtIGJvdHRvbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgeDogbGVmdCwgeTogdG9wLCB3aWR0aCwgaGVpZ2h0IH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2x0aXAvdG9vbHRpcC50c1xudmFyIERFRkFVTFRfVE9PTFRJUF9DTEFTUyA9IFwiYWctY2hhcnQtdG9vbHRpcFwiO1xudmFyIERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTID0gXCJhZy1jaGFydC1kYXJrLXRvb2x0aXBcIjtcbnZhciBFTVBUWV9UT09MVElQX0NPTlRFTlQgPSB7IGh0bWw6IFwiXCIsIGFyaWFMYWJlbDogXCJcIiB9O1xuZnVuY3Rpb24gdG9BY2Nlc3NpYmxlVGV4dChpbnB1dEh0bWwpIHtcbiAgY29uc3QgbGluZUNvbnZlcnRlciA9IChfbWF0Y2gsIG9mZnNldDQsIHN0cikgPT4ge1xuICAgIGlmIChvZmZzZXQ0ID09PSAwIHx8IHN0cltvZmZzZXQ0IC0gMV0gIT09IFwiLlwiKSB7XG4gICAgICByZXR1cm4gXCIuIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIgXCI7XG4gIH07XG4gIHJldHVybiBpbnB1dEh0bWwucmVwbGFjZSgvPGJyXFxzKlxcLz8+L2csIGxpbmVDb252ZXJ0ZXIpLnJlcGxhY2UoLzxcXC9wXFxzKz4vZywgbGluZUNvbnZlcnRlcikucmVwbGFjZSgvPFxcL2xpXFxzKj4vZywgbGluZUNvbnZlcnRlcikucmVwbGFjZSgvPFtePD5dKz4vZywgXCJcIikucmVwbGFjZSgvXFxuKy9nLCBcIiBcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG59XG5mdW5jdGlvbiB0b1Rvb2x0aXBIdG1sKGlucHV0LCBkZWZhdWx0cykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgaHRtbDogaW5wdXQsIGFyaWFMYWJlbDogaW5wdXQgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29udGVudCA9IGRlZmF1bHRzPy5jb250ZW50ID8/IFwiXCIsXG4gICAgdGl0bGUgPSBkZWZhdWx0cz8udGl0bGUsXG4gICAgY29sb3IgPSBkZWZhdWx0cz8uY29sb3IgPz8gXCJ3aGl0ZVwiLFxuICAgIGJhY2tncm91bmRDb2xvciA9IGRlZmF1bHRzPy5iYWNrZ3JvdW5kQ29sb3IgPz8gXCIjODg4XCJcbiAgfSA9IGlucHV0O1xuICBjb25zdCB0aXRsZUh0bWwgPSB0aXRsZSA/IGA8ZGl2IGNsYXNzPVwiJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LXRpdGxlXCJcbiAgICAgICAgc3R5bGU9XCJjb2xvcjogJHtjb2xvcn07IGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfVwiPiR7dGl0bGV9PC9kaXY+YCA6IFwiXCI7XG4gIGNvbnN0IHRpdGxlQXJpYSA9IHRpdGxlID8gYCR7dGl0bGV9OiBgIDogXCJcIjtcbiAgY29uc3QgY29udGVudEh0bWwgPSBjb250ZW50ID8gYDxkaXYgY2xhc3M9XCIke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tY29udGVudFwiPiR7Y29udGVudH08L2Rpdj5gIDogXCJcIjtcbiAgcmV0dXJuIHtcbiAgICBodG1sOiBgJHt0aXRsZUh0bWx9JHtjb250ZW50SHRtbH1gLFxuICAgIGFyaWFMYWJlbDogdG9BY2Nlc3NpYmxlVGV4dChgJHt0aXRsZUFyaWF9JHtjb250ZW50fWApXG4gIH07XG59XG52YXIgVG9vbHRpcFBvc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqIFRoZSB0eXBlIG9mIHBvc2l0aW9uaW5nIGZvciB0aGUgdG9vbHRpcC4gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgZm9sbG93cyB0aGUgcG9pbnRlci4gKi9cbiAgICB0aGlzLnR5cGUgPSBcInBvaW50ZXJcIjtcbiAgICAvKiogVGhlIGhvcml6b250YWwgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwLiAqL1xuICAgIHRoaXMueE9mZnNldCA9IDA7XG4gICAgLyoqIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFxuICAgIFVOSU9OKFxuICAgICAgW1xuICAgICAgICBcInBvaW50ZXJcIixcbiAgICAgICAgXCJub2RlXCIsXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgXCJib3R0b21cIixcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwidG9wLWxlZnRcIixcbiAgICAgICAgXCJ0b3AtcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tbGVmdFwiXG4gICAgICBdLFxuICAgICAgXCJhIHBvc2l0aW9uIHR5cGVcIlxuICAgIClcbiAgKVxuXSwgVG9vbHRpcFBvc2l0aW9uLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgVG9vbHRpcFBvc2l0aW9uLnByb3RvdHlwZSwgXCJ4T2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgVG9vbHRpcFBvc2l0aW9uLnByb3RvdHlwZSwgXCJ5T2Zmc2V0XCIsIDIpO1xudmFyIFRvb2x0aXAgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIHRoaXMucmFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy53cmFwcGluZyA9IFwiaHlwaGVuYXRlXCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBUb29sdGlwUG9zaXRpb24oKTtcbiAgICB0aGlzLmRhcmtUaGVtZSA9IGZhbHNlO1xuICAgIHRoaXMuYm91bmRzID0gXCJleHRlbmRlZFwiO1xuICAgIHRoaXMuZW5hYmxlSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLndyYXBUeXBlcyA9IFtcImFsd2F5c1wiLCBcImh5cGhlbmF0ZVwiLCBcIm9uLXNwYWNlXCIsIFwibmV2ZXJcIl07XG4gICAgdGhpcy5zaG93VGltZW91dCA9IDA7XG4gICAgdGhpcy5fc2hvd0Fycm93ID0gdHJ1ZTtcbiAgfVxuICBnZXQgaW50ZXJhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlSW50ZXJhY3Rpb247XG4gIH1cbiAgc2V0dXAoZG9tTWFuYWdlcikge1xuICAgIHRoaXMuZWxlbWVudCA9IGRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBERUZBVUxUX1RPT0xUSVBfQ0xBU1MpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERFRkFVTFRfVE9PTFRJUF9DTEFTUyk7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbWVudCwgXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgfVxuICBkZXN0cm95KGRvbU1hbmFnZXIpIHtcbiAgICBkb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgfVxuICBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVsZW1lbnQ/LmNsYXNzTGlzdC5jb250YWlucyhERUZBVUxUX1RPT0xUSVBfQ0xBU1MgKyBcIi1oaWRkZW5cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRvb2x0aXAgYXQgdGhlIGdpdmVuIGV2ZW50J3MgY29vcmRpbmF0ZXMuXG4gICAqIElmIHRoZSBgaHRtbGAgcGFyYW1ldGVyIGlzIG1pc3NpbmcsIG1vdmVzIHRoZSBleGlzdGluZyB0b29sdGlwIHRvIHRoZSBuZXcgcG9zaXRpb24uXG4gICAqL1xuICBzaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgbWV0YSwgY29udGVudCwgaW5zdGFudGx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzO1xuICAgIGlmIChjb250ZW50ICE9IG51bGwgJiYgZWxlbWVudDIgIT0gbnVsbCkge1xuICAgICAgZWxlbWVudDIuaW5uZXJIVE1MID0gY29udGVudC5odG1sO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQyPy5pbm5lckhUTUwpIHtcbiAgICAgIHRoaXMudG9nZ2xlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25UeXBlID0gbWV0YS5wb3NpdGlvbj8udHlwZSA/PyB0aGlzLnBvc2l0aW9uLnR5cGU7XG4gICAgY29uc3QgeE9mZnNldCA9IG1ldGEucG9zaXRpb24/LnhPZmZzZXQgPz8gMDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gbWV0YS5wb3NpdGlvbj8ueU9mZnNldCA/PyAwO1xuICAgIGNvbnN0IHRvb2x0aXBCb3VuZHMgPSB0aGlzLmdldFRvb2x0aXBCb3VuZHMoeyBwb3NpdGlvblR5cGUsIG1ldGEsIHlPZmZzZXQsIHhPZmZzZXQsIGNhbnZhc1JlY3QgfSk7XG4gICAgY29uc3QgcmVsYXRpdmVSZWN0ID0ge1xuICAgICAgeDogYm91bmRpbmdSZWN0LnggLSBjYW52YXNSZWN0LngsXG4gICAgICB5OiBib3VuZGluZ1JlY3QueSAtIGNhbnZhc1JlY3QueSxcbiAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY2FsY3VsYXRlUGxhY2VtZW50KGVsZW1lbnQyLmNsaWVudFdpZHRoLCBlbGVtZW50Mi5jbGllbnRIZWlnaHQsIHJlbGF0aXZlUmVjdCwgdG9vbHRpcEJvdW5kcyk7XG4gICAgY29uc3QgbWluWCA9IHJlbGF0aXZlUmVjdC54O1xuICAgIGNvbnN0IG1pblkgPSByZWxhdGl2ZVJlY3QueTtcbiAgICBjb25zdCBtYXhYID0gcmVsYXRpdmVSZWN0LndpZHRoIC0gZWxlbWVudDIuY2xpZW50V2lkdGggLSAxICsgbWluWDtcbiAgICBjb25zdCBtYXhZID0gcmVsYXRpdmVSZWN0LmhlaWdodCAtIGVsZW1lbnQyLmNsaWVudEhlaWdodCArIG1pblk7XG4gICAgY29uc3QgbGVmdCA9IGNsYW1wKG1pblgsIHBvc2l0aW9uLngsIG1heFgpO1xuICAgIGNvbnN0IHRvcCA9IGNsYW1wKG1pblksIHBvc2l0aW9uLnksIG1heFkpO1xuICAgIGNvbnN0IGNvbnN0cmFpbmVkID0gbGVmdCAhPT0gcG9zaXRpb24ueCB8fCB0b3AgIT09IHBvc2l0aW9uLnk7XG4gICAgY29uc3QgZGVmYXVsdFNob3dBcnJvdyA9IChwb3NpdGlvblR5cGUgPT09IFwibm9kZVwiIHx8IHBvc2l0aW9uVHlwZSA9PT0gXCJwb2ludGVyXCIpICYmICFjb25zdHJhaW5lZCAmJiAheE9mZnNldCAmJiAheU9mZnNldDtcbiAgICBjb25zdCBzaG93QXJyb3cgPSBtZXRhLnNob3dBcnJvdyA/PyB0aGlzLnNob3dBcnJvdyA/PyBkZWZhdWx0U2hvd0Fycm93O1xuICAgIHRoaXMudXBkYXRlU2hvd0Fycm93KHNob3dBcnJvdyk7XG4gICAgZWxlbWVudDIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke01hdGgucm91bmQobGVmdCl9cHgsICR7TWF0aC5yb3VuZCh0b3ApfXB4KWA7XG4gICAgZWxlbWVudDIuc3R5bGUucG9pbnRlckV2ZW50cyA9IG1ldGEuZW5hYmxlSW50ZXJhY3Rpb24gPyBcImF1dG9cIiA6IFwibm9uZVwiO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImRhdGEtcG9pbnRlci1jYXB0dXJlXCIsIFwicmV0YWluXCIpO1xuICAgIHRoaXMuZW5hYmxlSW50ZXJhY3Rpb24gPSBtZXRhLmVuYWJsZUludGVyYWN0aW9uID8/IGZhbHNlO1xuICAgIGlmICh0aGlzLmRlbGF5ID4gMCAmJiAhaW5zdGFudGx5KSB7XG4gICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgICB0aGlzLnNob3dUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlKHRydWUpO1xuICAgICAgfSwgdGhpcy5kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9nZ2xlKHRydWUpO1xuICAgIH1cbiAgfVxuICB0b2dnbGUodmlzaWJsZSkge1xuICAgIGlmICghdGhpcy5lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0IH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgdG9nZ2xlQ2xhc3MgPSAobmFtZSwgaW5jbHVkZSkgPT4gY2xhc3NMaXN0LnRvZ2dsZShgJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LSR7bmFtZX1gLCBpbmNsdWRlKTtcbiAgICBjb25zdCB3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGUoKTtcbiAgICBsZXQgdGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA9IEluZmluaXR5O1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAod2FzVmlzaWJsZSAhPT0gdmlzaWJsZSkge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPSBub3cgLSB0aGlzLmxhc3RWaXNpYmlsaXR5Q2hhbmdlO1xuICAgICAgdGhpcy5sYXN0VmlzaWJpbGl0eUNoYW5nZSA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZWRNb3ZlVGhyZXNob2xkTXMgPSAxMDA7XG4gICAgY29uc3QgdGhyYXNoaW5nVGhyZXNob2xkTXMgPSA1O1xuICAgIGNvbnN0IG5vQW5pbWF0aW9uID0gIXdhc1Zpc2libGUgJiYgdmlzaWJsZSAmJiB0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID4gYW5pbWF0ZWRNb3ZlVGhyZXNob2xkTXM7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPiB0aHJhc2hpbmdUaHJlc2hvbGRNcykge1xuICAgICAgdG9nZ2xlQ2xhc3MoXCJuby1hbmltYXRpb25cIiwgbm9BbmltYXRpb24pO1xuICAgIH1cbiAgICB0b2dnbGVDbGFzcyhcIm5vLWludGVyYWN0aW9uXCIsICF0aGlzLmVuYWJsZUludGVyYWN0aW9uKTtcbiAgICB0b2dnbGVDbGFzcyhcImhpZGRlblwiLCAhdmlzaWJsZSk7XG4gICAgdG9nZ2xlQ2xhc3MoXCJhcnJvd1wiLCB0aGlzLl9zaG93QXJyb3cpO1xuICAgIGNsYXNzTGlzdC50b2dnbGUoREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1MsIHRoaXMuZGFya1RoZW1lKTtcbiAgICBmb3IgKGNvbnN0IHdyYXBUeXBlIG9mIHRoaXMud3JhcFR5cGVzKSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30td3JhcC0ke3dyYXBUeXBlfWAsIHdyYXBUeXBlID09PSB0aGlzLndyYXBwaW5nKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU2hvd0Fycm93KHNob3cpIHtcbiAgICB0aGlzLl9zaG93QXJyb3cgPSBzaG93O1xuICB9XG4gIGdldFRvb2x0aXBCb3VuZHMob3B0cykge1xuICAgIGlmICghdGhpcy5lbGVtZW50KVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgcG9zaXRpb25UeXBlLCBtZXRhLCB5T2Zmc2V0LCB4T2Zmc2V0LCBjYW52YXNSZWN0IH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgY2xpZW50V2lkdGg6IHRvb2x0aXBXaWR0aCwgY2xpZW50SGVpZ2h0OiB0b29sdGlwSGVpZ2h0IH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgYm91bmRzID0geyB3aWR0aDogdG9vbHRpcFdpZHRoLCBoZWlnaHQ6IHRvb2x0aXBIZWlnaHQgfTtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uVHlwZSkge1xuICAgICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgIGNhc2UgXCJwb2ludGVyXCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IG1ldGEub2Zmc2V0WSArIHlPZmZzZXQgLSB0b29sdGlwSGVpZ2h0IC0gODtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBtZXRhLm9mZnNldFggKyB4T2Zmc2V0IC0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b3BcIjoge1xuICAgICAgICBib3VuZHMudG9wID0geU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC8gMiAtIHRvb2x0aXBXaWR0aCAvIDIgKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJpZ2h0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC8gMiAtIHRvb2x0aXBIZWlnaHQgLyAyICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC0gdG9vbHRpcFdpZHRoIC8gMiArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGVmdFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAvIDIgLSB0b29sdGlwSGVpZ2h0IC8gMiArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0geE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b21cIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC8gMiAtIHRvb2x0aXBXaWR0aCAvIDIgKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0geE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0geU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC0gdG9vbHRpcFdpZHRoICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC0gdG9vbHRpcFdpZHRoICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJzaG93QXJyb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgIHRhcmdldC5lbGVtZW50Py5jbGFzc0xpc3QuYWRkKG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICB0YXJnZXQuZWxlbWVudD8uY2xhc3NMaXN0LnJlbW92ZShvbGRWYWx1ZSk7XG4gICAgfVxuICB9KSxcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJjbGFzc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImRlbGF5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJBQ1RJT05fUkFOR0UsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9XUkFQKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwid3JhcHBpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJkYXJrVGhlbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJleHRlbmRlZFwiLCBcImNhbnZhc1wiXSkpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJib3VuZHNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NhcHRpb24udHNcbnZhciBDYXB0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubm9kZSA9IG5ldyBUZXh0KHsgekluZGV4OiAxIH0pLnNldFByb3BlcnRpZXMoe1xuICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovXG4gICAgfSk7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLndyYXBwaW5nID0gXCJhbHdheXNcIjtcbiAgICB0aGlzLnRydW5jYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGF5b3V0U3R5bGUgPSBcImJsb2NrXCI7XG4gIH1cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDdHgpIHtcbiAgICBjb25zdCB7IHJlZ2lvbk1hbmFnZXIsIHByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLCBsYXlvdXRTZXJ2aWNlIH0gPSBtb2R1bGVDdHg7XG4gICAgY29uc3QgcmVnaW9uID0gcmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJyb290XCIpO1xuICAgIGNvbnN0IGRlc3Ryb3lGbnMgPSBbXG4gICAgICBsYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsICgpID0+IHRoaXMudXBkYXRlQTExeVRleHQocHJveHlJbnRlcmFjdGlvblNlcnZpY2UpKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZU1vdmUobW9kdWxlQ3R4LCBldmVudCkpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTGVhdmUobW9kdWxlQ3R4LCBldmVudCkpXG4gICAgXTtcbiAgICByZXR1cm4gam9pbkZ1bmN0aW9ucyguLi5kZXN0cm95Rm5zKTtcbiAgfVxuICBjb21wdXRlVGV4dFdyYXAoY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCkge1xuICAgIGNvbnN0IHsgdGV4dCwgd3JhcHBpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoID8/IEluZmluaXR5LCBjb250YWluZXJXaWR0aCk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgPz8gY29udGFpbmVySGVpZ2h0O1xuICAgIGlmICghaXNGaW5pdGUobWF4V2lkdGgpICYmICFpc0Zpbml0ZShtYXhIZWlnaHQpKSB7XG4gICAgICB0aGlzLm5vZGUudGV4dCA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRUZXh0ID0gVGV4dFdyYXBwZXIud3JhcFRleHQodGV4dCA/PyBcIlwiLCB7IG1heFdpZHRoLCBtYXhIZWlnaHQsIGZvbnQ6IHRoaXMsIHRleHRXcmFwOiB3cmFwcGluZyB9KTtcbiAgICB0aGlzLm5vZGUudGV4dCA9IHdyYXBwZWRUZXh0O1xuICAgIHRoaXMudHJ1bmNhdGVkID0gd3JhcHBlZFRleHQuaW5jbHVkZXMoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcik7XG4gIH1cbiAgdXBkYXRlQTExeVRleHQocHJveHlTZXJ2aWNlKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLnRleHQpIHtcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLm5vZGUuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgY29uc3QgeyBpZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm94eVRleHQgPz8gKHRoaXMucHJveHlUZXh0ID0gcHJveHlTZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7IHR5cGU6IFwidGV4dFwiLCBpZCwgcGFyZW50OiBcImNhbnZhcy1wcm94eVwiIH0pKTtcbiAgICAgICAgdGhpcy5wcm94eVRleHQudGV4dENvbnRlbnQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHRoaXMucHJveHlUZXh0LnVwZGF0ZUJvdW5kcyhiYm94KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm94eVRleHQ/LnJlbW92ZSgpO1xuICAgICAgdGhpcy5wcm94eVRleHQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGhhbmRsZU1vdXNlTW92ZShtb2R1bGVDdHgsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICE9PSB2b2lkIDAgJiYgdGhpcy5lbmFibGVkICYmIHRoaXMubm9kZS52aXNpYmxlICYmIHRoaXMudHJ1bmNhdGVkKSB7XG4gICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgICAgbW9kdWxlQ3R4LnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZVRvb2x0aXAoXG4gICAgICAgIHRoaXMuaWQsXG4gICAgICAgIHsgb2Zmc2V0WCwgb2Zmc2V0WSwgbGFzdFBvaW50ZXJFdmVudDogZXZlbnQsIHNob3dBcnJvdzogZmFsc2UgfSxcbiAgICAgICAgdG9Ub29sdGlwSHRtbCh7IGNvbnRlbnQ6IHRoaXMudGV4dCB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTW91c2VMZWF2ZShtb2R1bGVDdHgsIF9ldmVudCkge1xuICAgIG1vZHVsZUN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICB9XG59O1xuQ2FwdGlvbi5TTUFMTF9QQURESU5HID0gMTA7XG5DYXB0aW9uLkxBUkdFX1BBRERJTkcgPSAyMDtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX0FMSUdOLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInRleHRBbGlnblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiLCBcImZpbGxcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJsaW5lSGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibWF4SGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9XUkFQKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwid3JhcHBpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJsYXlvdXRTdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcmFuZ2UudHNcbnZhciBSYW5nZSA9IGNsYXNzIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLngxID0gMDtcbiAgICB0aGlzLnkxID0gMDtcbiAgICB0aGlzLngyID0gMDtcbiAgICB0aGlzLnkyID0gMDtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IGZhbHNlO1xuICAgIHRoaXMuZW5kTGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNSYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMucmVzdG9yZU93blN0eWxlcygpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBuZXcgQkJveCh0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyIC0gdGhpcy54MSwgdGhpcy55MiAtIHRoaXMueTEpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoX3gsIF95KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4KTtcbiAgICBsZXQgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcbiAgICB4MSA9IHRoaXMuYWxpZ24oeDEpO1xuICAgIHkxID0gdGhpcy5hbGlnbih5MSk7XG4gICAgeDIgPSB0aGlzLmFsaWduKHgyKTtcbiAgICB5MiA9IHRoaXMuYWxpZ24oeTIpO1xuICAgIGNvbnN0IHsgZmlsbCwgb3BhY2l0eSwgaXNSYW5nZSB9ID0gdGhpcztcbiAgICBjb25zdCBmaWxsQWN0aXZlID0gISEoaXNSYW5nZSAmJiBmaWxsKTtcbiAgICBpZiAoZmlsbEFjdGl2ZSkge1xuICAgICAgY29uc3QgeyBmaWxsT3BhY2l0eSB9ID0gdGhpcztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eSAqIGZpbGxPcGFjaXR5O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgY3R4LmxpbmVUbyh4MiwgeTEpO1xuICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgY3R4LmxpbmVUbyh4MSwgeTIpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdGFydExpbmUsIGVuZExpbmUgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3Ryb2tlQWN0aXZlID0gISEoKHN0YXJ0TGluZSB8fCBlbmRMaW5lKSAmJiBzdHJva2UgJiYgc3Ryb2tlV2lkdGgpO1xuICAgIGlmIChzdHJva2VBY3RpdmUpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBsaW5lQ2FwLCBsaW5lSm9pbiB9ID0gdGhpcztcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHkgKiBzdHJva2VPcGFjaXR5O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAobGluZUpvaW4pIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICB9XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBpZiAoc3RhcnRMaW5lKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTEpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZExpbmUpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MiwgeTIpO1xuICAgICAgICBjdHgubGluZVRvKHgxLCB5Mik7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIHRoaXMuZmlsbFNoYWRvdz8ubWFya0NsZWFuKCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbn07XG5SYW5nZS5jbGFzc05hbWUgPSBcIlJhbmdlXCI7XG5SYW5nZS5kZWZhdWx0U3R5bGVzID0ge1xuICAuLi5TaGFwZS5kZWZhdWx0U3R5bGVzLFxuICBzdHJva2VXaWR0aDogMVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieDFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcInkxXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ4MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieTJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcInN0YXJ0TGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwiZW5kTGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwiaXNSYW5nZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGFiZWwudHNcbnZhciBMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEyO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICB9XG4gIGdldEZvbnQoKSB7XG4gICAgcmV0dXJuIFRleHRVdGlscy50b0ZvbnRTdHJpbmcodGhpcyk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIDIpO1xuZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbihvcHRzKSB7XG4gIGNvbnN0IHsgcGFyYWxsZWxGbGlwUm90YXRpb24gPSAwLCByZWd1bGFyRmxpcFJvdGF0aW9uID0gMCB9ID0gb3B0cztcbiAgY29uc3QgY29uZmlndXJlZFJvdGF0aW9uID0gb3B0cy5yb3RhdGlvbiA/IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyhvcHRzLnJvdGF0aW9uKSkgOiAwO1xuICBjb25zdCBwYXJhbGxlbEZsaXBGbGFnID0gIWNvbmZpZ3VyZWRSb3RhdGlvbiAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA+PSAwICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uIDw9IE1hdGguUEkgPyAtMSA6IDE7XG4gIGNvbnN0IHJlZ3VsYXJGbGlwRmxhZyA9ICFjb25maWd1cmVkUm90YXRpb24gJiYgcmVndWxhckZsaXBSb3RhdGlvbiA+PSAwICYmIHJlZ3VsYXJGbGlwUm90YXRpb24gPD0gTWF0aC5QSSA/IC0xIDogMTtcbiAgbGV0IGRlZmF1bHRSb3RhdGlvbiA9IDA7XG4gIGlmIChvcHRzLnBhcmFsbGVsKSB7XG4gICAgZGVmYXVsdFJvdGF0aW9uID0gcGFyYWxsZWxGbGlwRmxhZyAqIE1hdGguUEkgLyAyO1xuICB9IGVsc2UgaWYgKHJlZ3VsYXJGbGlwRmxhZyA9PT0gLTEpIHtcbiAgICBkZWZhdWx0Um90YXRpb24gPSBNYXRoLlBJO1xuICB9XG4gIHJldHVybiB7IGNvbmZpZ3VyZWRSb3RhdGlvbiwgZGVmYXVsdFJvdGF0aW9uLCBwYXJhbGxlbEZsaXBGbGFnLCByZWd1bGFyRmxpcEZsYWcgfTtcbn1cbmZ1bmN0aW9uIGdldExhYmVsU3BhY2luZyhtaW5TcGFjaW5nLCByb3RhdGVkKSB7XG4gIGlmICghaXNOYU4obWluU3BhY2luZykpIHtcbiAgICByZXR1cm4gbWluU3BhY2luZztcbiAgfVxuICByZXR1cm4gcm90YXRlZCA/IDAgOiAxMDtcbn1cbmZ1bmN0aW9uIGdldFRleHRCYXNlbGluZShwYXJhbGxlbCwgbGFiZWxSb3RhdGlvbiwgc2lkZUZsYWcsIHBhcmFsbGVsRmxpcEZsYWcpIHtcbiAgaWYgKHBhcmFsbGVsICYmICFsYWJlbFJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIHNpZGVGbGFnICogcGFyYWxsZWxGbGlwRmxhZyA9PT0gLTEgPyBcImhhbmdpbmdcIiA6IFwiYm90dG9tXCI7XG4gIH1cbiAgcmV0dXJuIFwibWlkZGxlXCI7XG59XG5mdW5jdGlvbiBnZXRUZXh0QWxpZ24ocGFyYWxsZWwsIGxhYmVsUm90YXRpb24sIGxhYmVsQXV0b1JvdGF0aW9uLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKSB7XG4gIGNvbnN0IGxhYmVsUm90YXRlZCA9IGxhYmVsUm90YXRpb24gPiAwICYmIGxhYmVsUm90YXRpb24gPD0gTWF0aC5QSTtcbiAgY29uc3QgbGFiZWxBdXRvUm90YXRlZCA9IGxhYmVsQXV0b1JvdGF0aW9uID4gMCAmJiBsYWJlbEF1dG9Sb3RhdGlvbiA8PSBNYXRoLlBJO1xuICBjb25zdCBhbGlnbkZsYWcgPSBsYWJlbFJvdGF0ZWQgfHwgbGFiZWxBdXRvUm90YXRlZCA/IC0xIDogMTtcbiAgaWYgKHBhcmFsbGVsKSB7XG4gICAgaWYgKGxhYmVsUm90YXRpb24gfHwgbGFiZWxBdXRvUm90YXRpb24pIHtcbiAgICAgIGlmIChzaWRlRmxhZyAqIGFsaWduRmxhZyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImNlbnRlclwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzaWRlRmxhZyAqIHJlZ3VsYXJGbGlwRmxhZyA9PT0gLTEpIHtcbiAgICByZXR1cm4gXCJlbmRcIjtcbiAgfVxuICByZXR1cm4gXCJzdGFydFwiO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxCQm94KHRleHQsIGJib3gsIGxhYmVsTWF0cml4KSB7XG4gIGNvbnN0IHsgeDogbGFiZWxYLCB5OiBsYWJlbFksIHdpZHRoLCBoZWlnaHQgfSA9IGJib3g7XG4gIGNvbnN0IHRyYW5zbGF0ZWRCQm94ID0gbmV3IEJCb3gobGFiZWxYLCBsYWJlbFksIDAsIDApO1xuICBsYWJlbE1hdHJpeC50cmFuc2Zvcm1CQm94KHRyYW5zbGF0ZWRCQm94LCBiYm94KTtcbiAgY29uc3QgeyB4LCB5IH0gPSBiYm94O1xuICByZXR1cm4ge1xuICAgIHBvaW50OiB7IHgsIHkgfSxcbiAgICBsYWJlbDogeyB0ZXh0LCB3aWR0aCwgaGVpZ2h0IH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGF5ZXJzLnRzXG52YXIgTGF5ZXJzID0gLyogQF9fUFVSRV9fICovICgoTGF5ZXJzMikgPT4ge1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfQkFDS0dST1VORF9aSU5ERVhcIl0gPSAwXSA9IFwiU0VSSUVTX0JBQ0tHUk9VTkRfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkFYSVNfR1JJRF9aSU5ERVhcIl0gPSAxXSA9IFwiQVhJU19HUklEX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJBWElTX1pJTkRFWFwiXSA9IDJdID0gXCJBWElTX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfQ1JPU1NMSU5FX1JBTkdFX1pJTkRFWFwiXSA9IDNdID0gXCJTRVJJRVNfQ1JPU1NMSU5FX1JBTkdFX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfTEFZRVJfWklOREVYXCJdID0gNF0gPSBcIlNFUklFU19MQVlFUl9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0hJR0hMSUdIVF9aSU5ERVhcIl0gPSA1XSA9IFwiU0VSSUVTX0hJR0hMSUdIVF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiQVhJU19GT1JFR1JPVU5EX1pJTkRFWFwiXSA9IDZdID0gXCJBWElTX0ZPUkVHUk9VTkRfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19DUk9TU0hBSVJfWklOREVYXCJdID0gN10gPSBcIlNFUklFU19DUk9TU0hBSVJfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19MQUJFTF9aSU5ERVhcIl0gPSA4XSA9IFwiU0VSSUVTX0xBQkVMX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfQ1JPU1NMSU5FX0xJTkVfWklOREVYXCJdID0gOV0gPSBcIlNFUklFU19DUk9TU0xJTkVfTElORV9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0FOTk9UQVRJT05fWklOREVYXCJdID0gMTBdID0gXCJTRVJJRVNfQU5OT1RBVElPTl9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiQ0hBUlRfQU5OT1RBVElPTl9aSU5ERVhcIl0gPSAxMV0gPSBcIkNIQVJUX0FOTk9UQVRJT05fWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkNIQVJUX0FOTk9UQVRJT05fRk9DVVNFRF9aSU5ERVhcIl0gPSAxMl0gPSBcIkNIQVJUX0FOTk9UQVRJT05fRk9DVVNFRF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiTEVHRU5EX1pJTkRFWFwiXSA9IDEzXSA9IFwiTEVHRU5EX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJOQVZJR0FUT1JfWklOREVYXCJdID0gMTRdID0gXCJOQVZJR0FUT1JfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkZPUkVHUk9VTkRfWklOREVYXCJdID0gMTVdID0gXCJGT1JFR1JPVU5EX1pJTkRFWFwiO1xuICByZXR1cm4gTGF5ZXJzMjtcbn0pKExheWVycyB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdmFsdWUudHNcbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd24odmFsdWUsIFwidG9TdHJpbmdcIikgJiYgaXNTdHJpbmcodmFsdWUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duKHZhbHVlLCBcInZhbHVlT2ZcIikgJiYgaXNGaW5pdGVOdW1iZXIodmFsdWUudmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGludW91cyh2YWx1ZSkge1xuICByZXR1cm4gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHx8IGlzVmFsaWREYXRlKHZhbHVlKSB8fCBpc051bWJlck9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdHVtKHZhbHVlLCBpc0NvbnRpbnVvdXNTY2FsZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAoIWlzQ29udGludW91c1NjYWxlIHx8IGlzQ29udGludW91cyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbHVlKSAmJiBPYmplY3QuaGFzT3duKHZhbHVlLCBcImlkXCIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmlkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY3Jvc3NsaW5lL2Nyb3NzTGluZS50c1xudmFyIE1BVENISU5HX0NST1NTTElORV9UWVBFID0gKHByb3BlcnR5KSA9PiB7XG4gIHJldHVybiBwcm9wZXJ0eSA9PT0gXCJ2YWx1ZVwiID8gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKF8sIGN0eCkgPT4gY3R4LnRhcmdldFtcInR5cGVcIl0gPT09IFwibGluZVwiLFxuICAgIChjdHgpID0+IGN0eC50YXJnZXRbXCJ0eXBlXCJdID09PSBcInJhbmdlXCIgPyBgY3Jvc3NMaW5lIHR5cGUgJ3JhbmdlJyB0byBoYXZlIGEgJ3JhbmdlJyBwcm9wZXJ0eSBpbnN0ZWFkIG9mICd2YWx1ZSdgIDogYGNyb3NzTGluZSBwcm9wZXJ0eSAndHlwZScgdG8gYmUgJ2xpbmUnYFxuICApIDogcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKF8sIGN0eCkgPT4gY3R4LnRhcmdldFtcInR5cGVcIl0gPT09IFwicmFuZ2VcIixcbiAgICAoY3R4KSA9PiBjdHgudGFyZ2V0LnR5cGUgPT09IFwibGluZVwiID8gYGNyb3NzTGluZSB0eXBlICdsaW5lJyB0byBoYXZlIGEgJ3ZhbHVlJyBwcm9wZXJ0eSBpbnN0ZWFkIG9mICdyYW5nZSdgIDogYGNyb3NzTGluZSBwcm9wZXJ0eSAndHlwZScgdG8gYmUgJ3JhbmdlJ2BcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXMgPSAodHlwZSwgdmFsdWUsIHJhbmdlMywgc2NhbGUyKSA9PiB7XG4gIGNvbnN0IGxpbmVDcm9zc0xpbmUgPSB0eXBlID09PSBcImxpbmVcIiAmJiB2YWx1ZSAhPT0gdm9pZCAwO1xuICBjb25zdCByYW5nZUNyb3NzTGluZSA9IHR5cGUgPT09IFwicmFuZ2VcIiAmJiByYW5nZTMgIT09IHZvaWQgMDtcbiAgaWYgKCFsaW5lQ3Jvc3NMaW5lICYmICFyYW5nZUNyb3NzTGluZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9IHJhbmdlMyA/PyBbdmFsdWUsIHZvaWQgMF07XG4gIGNvbnN0IGlzQ29udGludW91czIgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gIGNvbnN0IHZhbGlkU3RhcnQgPSBjaGVja0RhdHVtKHN0YXJ0LCBpc0NvbnRpbnVvdXMyKSAmJiAhaXNOYU4oc2NhbGUyLmNvbnZlcnQoc3RhcnQpKTtcbiAgY29uc3QgdmFsaWRFbmQgPSBjaGVja0RhdHVtKGVuZCwgaXNDb250aW51b3VzMikgJiYgIWlzTmFOKHNjYWxlMi5jb252ZXJ0KGVuZCkpO1xuICBpZiAobGluZUNyb3NzTGluZSAmJiB2YWxpZFN0YXJ0IHx8IHJhbmdlQ3Jvc3NMaW5lICYmIHZhbGlkU3RhcnQgJiYgdmFsaWRFbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBtZXNzYWdlID0gW2BFeHBlY3RpbmcgY3Jvc3NMaW5lYF07XG4gIGlmIChyYW5nZUNyb3NzTGluZSkge1xuICAgIGlmICghdmFsaWRTdGFydCkge1xuICAgICAgbWVzc2FnZS5wdXNoKGByYW5nZSBzdGFydCAke3N0cmluZ2lmeShzdGFydCl9YCk7XG4gICAgfVxuICAgIGlmICghdmFsaWRFbmQpIHtcbiAgICAgIG1lc3NhZ2UucHVzaChgJHt2YWxpZFN0YXJ0ID8gXCJcIiA6IFwiYW5kIFwifXJhbmdlIGVuZCAke3N0cmluZ2lmeShlbmQpfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlLnB1c2goYHZhbHVlICR7c3RyaW5naWZ5KHN0YXJ0KX1gKTtcbiAgfVxuICBtZXNzYWdlLnB1c2goYHRvIG1hdGNoIHRoZSBheGlzIHNjYWxlIGRvbWFpbi5gKTtcbiAgTG9nZ2VyLndhcm5PbmNlKG1lc3NhZ2Uuam9pbihcIiBcIikpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jcm9zc2xpbmUvY3Jvc3NMaW5lTGFiZWxQb3NpdGlvbi50c1xudmFyIGhvcml6b250YWxDcm9zc2xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB7XG4gIHRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgYm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIHJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIHRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIHRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgYm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBib3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZVRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGluc2lkZVRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlVG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZUJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfVxufTtcbnZhciB2ZXJ0aWNhbENyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA9IHtcbiAgdG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgbGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgcmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgdG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIHRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBib3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBib3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGU6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlVG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVCb3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlVG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVUb3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGluc2lkZUJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbih7XG4gIHlEaXJlY3Rpb24sXG4gIHBhZGRpbmcgPSAwLFxuICBwb3NpdGlvbiA9IFwidG9wXCIsXG4gIGJib3hcbn0pIHtcbiAgY29uc3QgY3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zID0geURpcmVjdGlvbiA/IGhvcml6b250YWxDcm9zc2xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgOiB2ZXJ0aWNhbENyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucztcbiAgY29uc3QgeyB4VHJhbnNsYXRpb25EaXJlY3Rpb24sIHlUcmFuc2xhdGlvbkRpcmVjdGlvbiB9ID0gY3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zW3Bvc2l0aW9uXTtcbiAgY29uc3QgdyA9IHlEaXJlY3Rpb24gPyBiYm94LndpZHRoIDogYmJveC5oZWlnaHQ7XG4gIGNvbnN0IGggPSB5RGlyZWN0aW9uID8gYmJveC5oZWlnaHQgOiBiYm94LndpZHRoO1xuICBjb25zdCB4VHJhbnNsYXRpb24gPSB4VHJhbnNsYXRpb25EaXJlY3Rpb24gKiAocGFkZGluZyArIHcgLyAyKTtcbiAgY29uc3QgeVRyYW5zbGF0aW9uID0geVRyYW5zbGF0aW9uRGlyZWN0aW9uICogKHBhZGRpbmcgKyBoIC8gMik7XG4gIHJldHVybiB7XG4gICAgeFRyYW5zbGF0aW9uLFxuICAgIHlUcmFuc2xhdGlvblxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxDaGFydFBhZGRpbmcoe1xuICB5RGlyZWN0aW9uLFxuICBiYm94LFxuICBwYWRkaW5nID0gMCxcbiAgcG9zaXRpb24gPSBcInRvcFwiXG59KSB7XG4gIGNvbnN0IGNoYXJ0UGFkZGluZyA9IHt9O1xuICBpZiAocG9zaXRpb24uc3RhcnRzV2l0aChcImluc2lkZVwiKSlcbiAgICByZXR1cm4gY2hhcnRQYWRkaW5nO1xuICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIgJiYgIXlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcudG9wID0gcGFkZGluZyArIGJib3guaGVpZ2h0O1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImJvdHRvbVwiICYmICF5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLmJvdHRvbSA9IHBhZGRpbmcgKyBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJsZWZ0XCIgJiYgeURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5sZWZ0ID0gcGFkZGluZyArIGJib3gud2lkdGg7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIiAmJiB5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLnJpZ2h0ID0gcGFkZGluZyArIGJib3gud2lkdGg7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0UGFkZGluZztcbn1cbnZhciBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiB5U3RhcnQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9MRUZUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kIC8gMiwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0lOU0lERV9DT09SRElOQVRFUyA9ICh7IHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbn07XG52YXIgUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0IC8gMiwgeTogeVN0YXJ0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogeVN0YXJ0IH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fQk9UVE9NX0xFRlRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4U3RhcnQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IHlTdGFydCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX1RPUF9SSUdIVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogeVN0YXJ0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH1cbn07XG52YXIgbGFiZWxEaXJlY3Rpb25IYW5kbGluZyA9IHtcbiAgdG9wOiB7IGM6IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9LFxuICBib3R0b206IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXG4gIGxlZnQ6IHsgYzogUE9TSVRJT05fTEVGVF9DT09SRElOQVRFUyB9LFxuICByaWdodDogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxuICB0b3BMZWZ0OiB7IGM6IFBPU0lUSU9OX1RPUF9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIHRvcFJpZ2h0OiB7IGM6IFBPU0lUSU9OX1RPUF9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBib3R0b21MZWZ0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIGJvdHRvbVJpZ2h0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGU6IHsgYzogUE9TSVRJT05fSU5TSURFX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZUxlZnQ6IHsgYzogUE9TSVRJT05fTEVGVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVSaWdodDogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVUb3A6IHsgYzogUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZUJvdHRvbTogeyBjOiBQT1NJVElPTl9CT1RUT01fQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlVG9wTGVmdDogeyBjOiBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVCb3R0b21MZWZ0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZVRvcFJpZ2h0OiB7IGM6IFBPU0lUSU9OX1RPUF9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVCb3R0b21SaWdodDogeyBjOiBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY3Jvc3NsaW5lL2NhcnRlc2lhbkNyb3NzTGluZS50c1xudmFyIENST1NTTElORV9MQUJFTF9QT1NJVElPTiA9IFVOSU9OKFxuICBbXG4gICAgXCJ0b3BcIixcbiAgICBcImxlZnRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcInRvcExlZnRcIixcbiAgICBcInRvcFJpZ2h0XCIsXG4gICAgXCJib3R0b21MZWZ0XCIsXG4gICAgXCJib3R0b21SaWdodFwiLFxuICAgIFwiaW5zaWRlXCIsXG4gICAgXCJpbnNpZGVMZWZ0XCIsXG4gICAgXCJpbnNpZGVSaWdodFwiLFxuICAgIFwiaW5zaWRlVG9wXCIsXG4gICAgXCJpbnNpZGVCb3R0b21cIixcbiAgICBcImluc2lkZVRvcExlZnRcIixcbiAgICBcImluc2lkZUJvdHRvbUxlZnRcIixcbiAgICBcImluc2lkZVRvcFJpZ2h0XCIsXG4gICAgXCJpbnNpZGVCb3R0b21SaWdodFwiXG4gIF0sXG4gIFwiY3Jvc3NMaW5lIGxhYmVsIHBvc2l0aW9uXCJcbik7XG52YXIgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTQ7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLmNvbG9yID0gXCJyZ2JhKDg3LCA4NywgODcsIDEpXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ1JPU1NMSU5FX0xBQkVMX1BPU0lUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwYXJhbGxlbFwiLCAyKTtcbnZhciBfQ2FydGVzaWFuQ3Jvc3NMaW5lID0gY2xhc3MgX0NhcnRlc2lhbkNyb3NzTGluZSBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbCgpO1xuICAgIHRoaXMuc2NhbGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGlwcGVkUmFuZ2UgPSBbLUluZmluaXR5LCBJbmZpbml0eV07XG4gICAgdGhpcy5ncmlkTGVuZ3RoID0gMDtcbiAgICB0aGlzLnNpZGVGbGFnID0gLTE7XG4gICAgdGhpcy5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5yZWd1bGFyRmxpcFJvdGF0aW9uID0gMDtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IFwieFwiIC8qIFggKi87XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9YCwgbGF5ZXI6IHRydWUsIHpJbmRleDogX0NhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWCB9KTtcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfWAsIGxheWVyOiB0cnVlLCB6SW5kZXg6IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTEFCRUxfTEFZRVJfWklOREVYIH0pO1xuICAgIHRoaXMuY3Jvc3NMaW5lUmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICB0aGlzLmNyb3NzTGluZUxhYmVsID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmxhYmVsUG9pbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5zdGFydExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmVuZExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLmdyb3VwLmFwcGVuZCh0aGlzLmNyb3NzTGluZVJhbmdlKTtcbiAgICB0aGlzLmxhYmVsR3JvdXAuYXBwZW5kKHRoaXMuY3Jvc3NMaW5lTGFiZWwpO1xuICAgIHRoaXMuY3Jvc3NMaW5lUmFuZ2UucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgfVxuICB1cGRhdGUodmlzaWJsZSkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgZGF0YSwgdHlwZSwgdmFsdWUsIHJhbmdlOiByYW5nZTMsIHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgaWYgKCF0eXBlIHx8ICFzY2FsZTIgfHwgIWVuYWJsZWQgfHwgIXZpc2libGUgfHwgIXZhbGlkYXRlQ3Jvc3NMaW5lVmFsdWVzKHR5cGUsIHZhbHVlLCByYW5nZTMsIHNjYWxlMikgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB0aGlzLmxhYmVsR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5ncm91cC56SW5kZXggPSB0aGlzLmdldFpJbmRleCh0aGlzLmlzUmFuZ2UpO1xuICAgIHRoaXMudXBkYXRlTm9kZXMoKTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQodmlzaWJsZSwgcmV2ZXJzZWRBeGlzKSB7XG4gICAgaWYgKCF2aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjYWxlOiBzY2FsZTIsXG4gICAgICBncmlkTGVuZ3RoLFxuICAgICAgc2lkZUZsYWcsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBsYWJlbDogeyBwb3NpdGlvbiA9IFwidG9wXCIgfSxcbiAgICAgIGNsaXBwZWRSYW5nZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gMFxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIGlmICghc2NhbGUyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGJhbmR3aWR0aCA9IHNjYWxlMi5iYW5kd2lkdGggPz8gMDtcbiAgICBjb25zdCBzdGVwID0gc2NhbGUyLnN0ZXAgPz8gMDtcbiAgICBjb25zdCBwYWRkaW5nID0gKHJldmVyc2VkQXhpcyA/IC0xIDogMSkgKiAoc2NhbGUyIGluc3RhbmNlb2YgQmFuZFNjYWxlID8gKHN0ZXAgLSBiYW5kd2lkdGgpIC8gMiA6IDApO1xuICAgIGNvbnN0IFt4U3RhcnQsIHhFbmRdID0gWzAsIHNpZGVGbGFnICogZ3JpZExlbmd0aF07XG4gICAgbGV0IFt5U3RhcnQsIHlFbmRdID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgIGNvbnN0IG9yZGluYWxUaW1lU2NhbGVQYWRkaW5nID0geUVuZCA9PT0gdm9pZCAwICYmIE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKSA/IGJhbmR3aWR0aCAvIDIgKyBwYWRkaW5nIDogMDtcbiAgICBsZXQgW2NsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kXSA9IFtcbiAgICAgIE51bWJlcihzY2FsZTIuY29udmVydCh5U3RhcnQsIHsgY2xhbXBNb2RlOiBcImNsYW1wZWRcIiB9KSkgLSBwYWRkaW5nICsgb3JkaW5hbFRpbWVTY2FsZVBhZGRpbmcsXG4gICAgICBzY2FsZTIuY29udmVydCh5RW5kLCB7IGNsYW1wTW9kZTogXCJjbGFtcGVkXCIgfSkgKyBiYW5kd2lkdGggKyBwYWRkaW5nXG4gICAgXTtcbiAgICBjbGFtcGVkWVN0YXJ0ID0gY2xhbXBBcnJheShjbGFtcGVkWVN0YXJ0LCBjbGlwcGVkUmFuZ2UpO1xuICAgIGNsYW1wZWRZRW5kID0gY2xhbXBBcnJheShjbGFtcGVkWUVuZCwgY2xpcHBlZFJhbmdlKTtcbiAgICBbeVN0YXJ0LCB5RW5kXSA9IFtOdW1iZXIoc2NhbGUyLmNvbnZlcnQoeVN0YXJ0KSkgKyBvcmRpbmFsVGltZVNjYWxlUGFkZGluZywgc2NhbGUyLmNvbnZlcnQoeUVuZCkgKyBiYW5kd2lkdGhdO1xuICAgIGNvbnN0IHZhbGlkUmFuZ2UgPSAoeVN0YXJ0ID09PSBjbGFtcGVkWVN0YXJ0IHx8IHlFbmQgPT09IGNsYW1wZWRZRW5kIHx8IGNsYW1wZWRZU3RhcnQgIT09IGNsYW1wZWRZRW5kKSAmJiBNYXRoLmFicyhjbGFtcGVkWUVuZCAtIGNsYW1wZWRZU3RhcnQpID4gMDtcbiAgICBpZiAodmFsaWRSYW5nZSAmJiBjbGFtcGVkWVN0YXJ0ID4gY2xhbXBlZFlFbmQpIHtcbiAgICAgIFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF0gPSBbY2xhbXBlZFlFbmQsIGNsYW1wZWRZU3RhcnRdO1xuICAgICAgW3lTdGFydCwgeUVuZF0gPSBbeUVuZCwgeVN0YXJ0XTtcbiAgICB9XG4gICAgaWYgKHlTdGFydCAtIHBhZGRpbmcgPj0gY2xhbXBlZFlTdGFydClcbiAgICAgIHlTdGFydCAtPSBwYWRkaW5nO1xuICAgIGlmICh5RW5kICsgcGFkZGluZyA8PSBjbGFtcGVkWUVuZClcbiAgICAgIHlFbmQgKz0gcGFkZGluZztcbiAgICB0aGlzLmlzUmFuZ2UgPSB2YWxpZFJhbmdlO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gc3Ryb2tlV2lkdGggPiAwICYmIHlTdGFydCA+PSBjbGFtcGVkWVN0YXJ0ICYmIHlTdGFydCA8PSBjbGFtcGVkWVN0YXJ0ICsgcGFkZGluZztcbiAgICB0aGlzLmVuZExpbmUgPSBzdHJva2VXaWR0aCA+IDAgJiYgeUVuZCA+PSBjbGFtcGVkWUVuZCAtIGJhbmR3aWR0aCAtIHBhZGRpbmcgJiYgeUVuZCA8PSBjbGFtcGVkWUVuZDtcbiAgICBpZiAoIXZhbGlkUmFuZ2UgJiYgIXRoaXMuc3RhcnRMaW5lICYmICF0aGlzLmVuZExpbmUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kYXRhID0gW2NsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kXTtcbiAgICBpZiAodGhpcy5sYWJlbC5lbmFibGVkKSB7XG4gICAgICBjb25zdCB5RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgICAgY29uc3QgeyBjID0gUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTIH0gPSBsYWJlbERpcmVjdGlvbkhhbmRsaW5nW3Bvc2l0aW9uXSA/PyB7fTtcbiAgICAgIGNvbnN0IHsgeDogbGFiZWxYLCB5OiBsYWJlbFkgfSA9IGMoe1xuICAgICAgICB5RGlyZWN0aW9uLFxuICAgICAgICB4U3RhcnQsXG4gICAgICAgIHhFbmQsXG4gICAgICAgIHlTdGFydDogY2xhbXBlZFlTdGFydCxcbiAgICAgICAgeUVuZDogY2xhbXBlZFlFbmRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sYWJlbFBvaW50ID0ge1xuICAgICAgICB4OiBsYWJlbFgsXG4gICAgICAgIHk6IGxhYmVsWVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZXMoKSB7XG4gICAgdGhpcy51cGRhdGVSYW5nZU5vZGUoKTtcbiAgICBpZiAodGhpcy5sYWJlbC5lbmFibGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgICB0aGlzLnBvc2l0aW9uTGFiZWwoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmFuZ2VOb2RlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNyb3NzTGluZVJhbmdlLFxuICAgICAgc2lkZUZsYWcsXG4gICAgICBncmlkTGVuZ3RoLFxuICAgICAgZGF0YSxcbiAgICAgIHN0YXJ0TGluZSxcbiAgICAgIGVuZExpbmUsXG4gICAgICBpc1JhbmdlLFxuICAgICAgZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lRGFzaFxuICAgIH0gPSB0aGlzO1xuICAgIGNyb3NzTGluZVJhbmdlLngxID0gMDtcbiAgICBjcm9zc0xpbmVSYW5nZS54MiA9IHNpZGVGbGFnICogZ3JpZExlbmd0aDtcbiAgICBjcm9zc0xpbmVSYW5nZS55MSA9IGRhdGFbMF07XG4gICAgY3Jvc3NMaW5lUmFuZ2UueTIgPSBkYXRhWzFdO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0YXJ0TGluZSA9IHN0YXJ0TGluZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5lbmRMaW5lID0gZW5kTGluZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5pc1JhbmdlID0gaXNSYW5nZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5maWxsID0gZmlsbDtcbiAgICBjcm9zc0xpbmVSYW5nZS5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5ID8/IDE7XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlID0gc3Ryb2tlO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggPz8gMTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdHJva2VPcGFjaXR5ID0gdGhpcy5zdHJva2VPcGFjaXR5ID8/IDE7XG4gICAgY3Jvc3NMaW5lUmFuZ2UubGluZURhc2ggPSBsaW5lRGFzaDtcbiAgfVxuICB1cGRhdGVMYWJlbCgpIHtcbiAgICBjb25zdCB7IGNyb3NzTGluZUxhYmVsLCBsYWJlbCB9ID0gdGhpcztcbiAgICBpZiAoIWxhYmVsLnRleHQpXG4gICAgICByZXR1cm47XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZmlsbCA9IGxhYmVsLmNvbG9yO1xuICAgIGNyb3NzTGluZUxhYmVsLnRleHQgPSBsYWJlbC50ZXh0O1xuICB9XG4gIHBvc2l0aW9uTGFiZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3Jvc3NMaW5lTGFiZWwsXG4gICAgICBsYWJlbFBvaW50OiB7IHggPSB2b2lkIDAsIHkgPSB2b2lkIDAgfSA9IHt9LFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBwb3NpdGlvbiA9IFwidG9wXCIsIHBhZGRpbmcgPSAwIH0sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoeCA9PT0gdm9pZCAwIHx8IHkgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb25cbiAgICB9KTtcbiAgICBjcm9zc0xpbmVMYWJlbC5yb3RhdGlvbiA9IGRlZmF1bHRSb3RhdGlvbiArIGNvbmZpZ3VyZWRSb3RhdGlvbjtcbiAgICBjcm9zc0xpbmVMYWJlbC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIGNyb3NzTGluZUxhYmVsLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY29uc3QgYmJveCA9IGNyb3NzTGluZUxhYmVsLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICBpZiAoIWJib3gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICBjb25zdCB7IHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgICAgIHlEaXJlY3Rpb24sXG4gICAgICBwYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94XG4gICAgfSk7XG4gICAgY3Jvc3NMaW5lTGFiZWwudHJhbnNsYXRpb25YID0geCArIHhUcmFuc2xhdGlvbjtcbiAgICBjcm9zc0xpbmVMYWJlbC50cmFuc2xhdGlvblkgPSB5ICsgeVRyYW5zbGF0aW9uO1xuICB9XG4gIGdldFpJbmRleChpc1JhbmdlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gaXNSYW5nZSA/IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuUkFOR0VfTEFZRVJfWklOREVYIDogX0NhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWDtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCB7IHZhbHVlLCByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzQ29udGludW91czIgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZTM/LlswXSA/PyB2YWx1ZTtcbiAgICBsZXQgZW5kID0gcmFuZ2UzPy5bMV07XG4gICAgaWYgKCFpc0NvbnRpbnVvdXMyICYmIGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGlzQ29udGludW91czIgJiYgc3RhcnQgPT09IGVuZCkge1xuICAgICAgZW5kID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xuICB9XG4gIGNvbXB1dGVMYWJlbEJCb3goKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcztcbiAgICBpZiAoIWxhYmVsLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdGVtcFRleHQgPSBuZXcgVGV4dCgpO1xuICAgIHRlbXBUZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgIHRlbXBUZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgdGVtcFRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgIHRlbXBUZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgIHRlbXBUZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsUG9pbnQ6IHsgeCA9IHZvaWQgMCwgeSA9IHZvaWQgMCB9ID0ge30sXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIHBvc2l0aW9uID0gXCJ0b3BcIiwgcGFkZGluZyA9IDAgfSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb25cbiAgICB9KTtcbiAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbjtcbiAgICB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIHRlbXBUZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY29uc3QgYmJveCA9IHRlbXBUZXh0LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICBpZiAoIWJib3gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICBjb25zdCB7IHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgICAgIHlEaXJlY3Rpb24sXG4gICAgICBwYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94XG4gICAgfSk7XG4gICAgdGVtcFRleHQudHJhbnNsYXRpb25YID0geCArIHhUcmFuc2xhdGlvbjtcbiAgICB0ZW1wVGV4dC50cmFuc2xhdGlvblkgPSB5ICsgeVRyYW5zbGF0aW9uO1xuICAgIHJldHVybiB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gIH1cbiAgY2FsY3VsYXRlUGFkZGluZyhwYWRkaW5nKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNSYW5nZSxcbiAgICAgIHN0YXJ0TGluZSxcbiAgICAgIGVuZExpbmUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBsYWJlbDogeyBwYWRkaW5nOiBsYWJlbFBhZGRpbmcgPSAwLCBwb3NpdGlvbiA9IFwidG9wXCIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaXNSYW5nZSAmJiAhc3RhcnRMaW5lICYmICFlbmRMaW5lKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNyb3NzTGluZUxhYmVsQkJveCA9IHRoaXMuY29tcHV0ZUxhYmVsQkJveCgpO1xuICAgIGlmIChjcm9zc0xpbmVMYWJlbEJCb3g/LnggPT0gbnVsbCB8fCBjcm9zc0xpbmVMYWJlbEJCb3g/LnkgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGFydFBhZGRpbmcgPSBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyh7XG4gICAgICB5RGlyZWN0aW9uOiBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8sXG4gICAgICBwYWRkaW5nOiBsYWJlbFBhZGRpbmcsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGJib3g6IGNyb3NzTGluZUxhYmVsQkJveFxuICAgIH0pO1xuICAgIHBhZGRpbmcubGVmdCA9IE1hdGgubWF4KHBhZGRpbmcubGVmdCA/PyAwLCBjaGFydFBhZGRpbmcubGVmdCA/PyAwKTtcbiAgICBwYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgocGFkZGluZy5yaWdodCA/PyAwLCBjaGFydFBhZGRpbmcucmlnaHQgPz8gMCk7XG4gICAgcGFkZGluZy50b3AgPSBNYXRoLm1heChwYWRkaW5nLnRvcCA/PyAwLCBjaGFydFBhZGRpbmcudG9wID8/IDApO1xuICAgIHBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgocGFkZGluZy5ib3R0b20gPz8gMCwgY2hhcnRQYWRkaW5nLmJvdHRvbSA/PyAwKTtcbiAgfVxufTtcbl9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTElORV9MQVlFUl9aSU5ERVggPSA5IC8qIFNFUklFU19DUk9TU0xJTkVfTElORV9aSU5ERVggKi87XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLlJBTkdFX0xBWUVSX1pJTkRFWCA9IDMgLyogU0VSSUVTX0NST1NTTElORV9SQU5HRV9aSU5ERVggKi87XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLkxBQkVMX0xBWUVSX1pJTkRFWCA9IDggLyogU0VSSUVTX0xBQkVMX1pJTkRFWCAqLztcbl9DYXJ0ZXNpYW5Dcm9zc0xpbmUuY2xhc3NOYW1lID0gXCJDcm9zc0xpbmVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJyYW5nZVwiLCBcImxpbmVcIl0sIFwiYSBjcm9zc0xpbmUgdHlwZVwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChNQVRDSElOR19DUk9TU0xJTkVfVFlQRShcInJhbmdlXCIpLCBBUlJBWS5yZXN0cmljdCh7IGxlbmd0aDogMiB9KSksIHtcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNQVRDSElOR19DUk9TU0xJTkVfVFlQRShcInZhbHVlXCIpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNILCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xudmFyIENhcnRlc2lhbkNyb3NzTGluZSA9IF9DYXJ0ZXNpYW5Dcm9zc0xpbmU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3JlZ2lvbnMudHNcbnZhciBSRUdJT05TID0gLyogQF9fUFVSRV9fICovICgoUkVHSU9OUzIpID0+IHtcbiAgUkVHSU9OUzJbXCJUSVRMRVwiXSA9IFwidGl0bGVcIjtcbiAgUkVHSU9OUzJbXCJTVUJUSVRMRVwiXSA9IFwic3VidGl0bGVcIjtcbiAgUkVHSU9OUzJbXCJGT09UTk9URVwiXSA9IFwiZm9vdG5vdGVcIjtcbiAgUkVHSU9OUzJbXCJMRUdFTkRcIl0gPSBcImxlZ2VuZFwiO1xuICBSRUdJT05TMltcIk5BVklHQVRPUlwiXSA9IFwibmF2aWdhdG9yXCI7XG4gIFJFR0lPTlMyW1wiUEFHSU5BVElPTlwiXSA9IFwicGFnaW5hdGlvblwiO1xuICBSRUdJT05TMltcIlJPT1RcIl0gPSBcInJvb3RcIjtcbiAgUkVHSU9OUzJbXCJTRVJJRVNcIl0gPSBcInNlcmllc1wiO1xuICBSRUdJT05TMltcIkhPUklaT05UQUxfQVhFU1wiXSA9IFwiaG9yaXpvbnRhbC1heGVzXCI7XG4gIFJFR0lPTlMyW1wiVkVSVElDQUxfQVhFU1wiXSA9IFwidmVydGljYWwtYXhlc1wiO1xuICBSRUdJT05TMltcIlRPT0xCQVJcIl0gPSBcInRvb2xiYXJcIjtcbiAgcmV0dXJuIFJFR0lPTlMyO1xufSkoUkVHSU9OUyB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0dyaWRMaW5lLnRzXG52YXIgR1JJRF9TVFlMRV9LRVlTID0gW1wic3Ryb2tlXCIsIFwibGluZURhc2hcIl07XG52YXIgR1JJRF9TVFlMRSA9IEFSUkFZX09GKFxuICAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkuZXZlcnkoKGtleSkgPT4gR1JJRF9TVFlMRV9LRVlTLmluY2x1ZGVzKGtleSkpLFxuICBcIm9iamVjdHMgd2l0aCBncmlkbGluZSBzdHlsZSBwcm9wZXJ0aWVzIHN1Y2ggYXMgJ3N0cm9rZScgb3IgJ2xpbmVEYXNoJ1wiXG4pO1xudmFyIEF4aXNHcmlkTGluZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnN0eWxlID0gW1xuICAgICAge1xuICAgICAgICBzdHJva2U6IHZvaWQgMCxcbiAgICAgICAgbGluZURhc2g6IFtdXG4gICAgICB9XG4gICAgXTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoR1JJRF9TVFlMRSlcbl0sIEF4aXNHcmlkTGluZS5wcm90b3R5cGUsIFwic3R5bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVmYXVsdC50c1xuZnVuY3Rpb24gRGVmYXVsdChkZWZhdWx0VmFsdWUsIHJlcGxhY2VzID0gW3ZvaWQgMF0pIHtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgoXywgX18sIHYpID0+IHtcbiAgICBpZiAocmVwbGFjZXMuaW5jbHVkZXModikpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUodikgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzSW50ZXJ2YWwudHNcbnZhciBUSUNLX0lOVEVSVkFMID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmIHZhbHVlID4gMCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCxcbiAgYGEgbm9uLXplcm8gcG9zaXRpdmUgTnVtYmVyIHZhbHVlIG9yLCBmb3IgYSB0aW1lIGF4aXMsIGEgVGltZSBJbnRlcnZhbCBzdWNoIGFzICdhZ0NoYXJ0cy50aW1lLm1vbnRoJ2Bcbik7XG52YXIgQXhpc0ludGVydmFsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gTmFOO1xuICAgIHRoaXMubWF4U3BhY2luZyA9IE5hTjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRJQ0tfSU5URVJWQUwsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwic3RlcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcInZhbHVlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1JTl9TUEFDSU5HKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNQVhfU1BBQ0lORyksXG4gIERlZmF1bHQoTmFOKVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJtYXhTcGFjaW5nXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNMYWJlbC50c1xudmFyIEF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEyO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gTmFOO1xuICAgIHRoaXMuY29sb3IgPSBcIiM1NzU3NTdcIjtcbiAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XG4gICAgdGhpcy5taXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFyYWxsZWwgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNpZGUgb2YgdGhlIGF4aXMgbGluZSB0byBwb3NpdGlvbiB0aGUgbGFiZWxzIG9uLlxuICAgKiAtMSA9IGxlZnQgKGRlZmF1bHQpXG4gICAqIDEgPSByaWdodFxuICAgKi9cbiAgZ2V0U2lkZUZsYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlycm9yZWQgPyAxIDogLTE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxIH0pKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9PUl9OQU4pLFxuICBEZWZhdWx0KE5hTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImF2b2lkQ29sbGlzaW9uc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcIm1pcnJvcmVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicGFyYWxsZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNMaW5lLnRzXG52YXIgQXhpc0xpbmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2UgPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpY2sudHNcbnZhciBBeGlzVGljayA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDE7XG4gICAgdGhpcy5zaXplID0gNjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzVGljay5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGljay5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaXRsZS50c1xudmFyIEF4aXNUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3BhY2luZyA9IENhcHRpb24uU01BTExfUEFERElORztcbiAgICB0aGlzLmZvbnRTaXplID0gMTA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy53cmFwcGluZyA9IFwiYWx3YXlzXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX1dSQVApXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcIndyYXBwaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNVdGlsLnRzXG5mdW5jdGlvbiBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQoYXhpcykge1xuICBjb25zdCBbcmVxdWVzdGVkUmFuZ2VNaW4sIHJlcXVlc3RlZFJhbmdlTWF4XSA9IGZpbmRNaW5NYXgoYXhpcy5yYW5nZSk7XG4gIGNvbnN0IG1pbiA9IE1hdGguZmxvb3IocmVxdWVzdGVkUmFuZ2VNaW4pO1xuICBjb25zdCBtYXggPSBNYXRoLmNlaWwocmVxdWVzdGVkUmFuZ2VNYXgpO1xuICByZXR1cm4geyBtaW4sIG1heCwgdmlzaWJsZTogbWluICE9PSBtYXggfTtcbn1cbnZhciBmdWxsQ2lyY2xlID0gTWF0aC5QSSAqIDI7XG52YXIgaGFsZkNpcmNsZSA9IGZ1bGxDaXJjbGUgLyAyO1xuZnVuY3Rpb24gbm9ybWFsaXNlRW5kUm90YXRpb24oc3RhcnQsIGVuZCkge1xuICBjb25zdCBkaXJlY3REaXN0YW5jZSA9IE1hdGguYWJzKGVuZCAtIHN0YXJ0KTtcbiAgaWYgKGRpcmVjdERpc3RhbmNlIDwgaGFsZkNpcmNsZSlcbiAgICByZXR1cm4gZW5kO1xuICBpZiAoc3RhcnQgPiBlbmQpXG4gICAgcmV0dXJuIGVuZCArIGZ1bGxDaXJjbGU7XG4gIHJldHVybiBlbmQgLSBmdWxsQ2lyY2xlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnMoY3R4KSB7XG4gIGNvbnN0IG91dE9mQm91bmRzID0gKHksIHJhbmdlMykgPT4ge1xuICAgIGNvbnN0IFttaW4gPSBjdHgubWluLCBtYXggPSBjdHgubWF4XSA9IGZpbmRNaW5NYXgocmFuZ2UzID8/IFtdKTtcbiAgICByZXR1cm4geSA8IG1pbiB8fCB5ID4gbWF4O1xuICB9O1xuICBjb25zdCB0aWNrID0ge1xuICAgIGZyb21Gbihub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBsZXQgeSA9IG5vZGUueTEgKyBub2RlLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxldCBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiIHx8IG91dE9mQm91bmRzKG5vZGUuZGF0dW0udHJhbnNsYXRpb25ZLCBub2RlLmRhdHVtLnJhbmdlKSkge1xuICAgICAgICB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHk6IDAsIHRyYW5zbGF0aW9uWTogeSwgb3BhY2l0eSwgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXSB9O1xuICAgIH0sXG4gICAgdG9Gbihfbm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeTogMCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiB5LFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBmaW5pc2g6IHtcbiAgICAgICAgICAvLyBTZXQgZXhwbGljaXQgeSBhZnRlciBhbmltYXRpb24gc28gaXQncyBwaXhlbCBhbGlnbmVkXG4gICAgICAgICAgeSxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGludGVybWVkaWF0ZUZuKG5vZGUsIF9kYXR1bSwgX3N0YXR1cykge1xuICAgICAgcmV0dXJuIHsgdmlzaWJsZTogIW91dE9mQm91bmRzKG5vZGUueSkgfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxhYmVsID0ge1xuICAgIGZyb21Gbihub2RlLCBuZXdEYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IG5vZGUucHJldmlvdXNEYXR1bSA/PyBuZXdEYXR1bTtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS54O1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnk7XG4gICAgICBjb25zdCByb3RhdGlvbkNlbnRlclggPSBkYXR1bS5yb3RhdGlvbkNlbnRlclg7XG4gICAgICBsZXQgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChub2RlLnRyYW5zbGF0aW9uWSk7XG4gICAgICBsZXQgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIGxldCBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgb3V0T2ZCb3VuZHMoZGF0dW0ueSwgZGF0dW0ucmFuZ2UpKSB7XG4gICAgICAgIHJvdGF0aW9uID0gbmV3RGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiIHx8IG91dE9mQm91bmRzKG5vZGUuZGF0dW0ueSwgbm9kZS5kYXR1bS5yYW5nZSkpIHtcbiAgICAgICAgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpO1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgcm90YXRpb24gPSBuZXdEYXR1bS5yb3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4obm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgeCA9IGRhdHVtLng7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ueTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uQ2VudGVyWCA9IGRhdHVtLnJvdGF0aW9uQ2VudGVyWDtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKTtcbiAgICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIHJvdGF0aW9uID0gZGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICAgIHJvdGF0aW9uID0gZGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGlvbiA9IG5vcm1hbGlzZUVuZFJvdGF0aW9uKG5vZGUucHJldmlvdXNEYXR1bT8ucm90YXRpb24gPz8gZGF0dW0ucm90YXRpb24sIGRhdHVtLnJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHgsIHksIHJvdGF0aW9uQ2VudGVyWCwgdHJhbnNsYXRpb25ZLCByb3RhdGlvbiwgb3BhY2l0eSwgZmluaXNoOiB7IHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbiB9IH07XG4gICAgfVxuICB9O1xuICBjb25zdCBsaW5lID0ge1xuICAgIGZyb21Gbihub2RlLCBkYXR1bSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZS5wcmV2aW91c0RhdHVtID8/IGRhdHVtLFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcInVwZGF0ZWRcIl1cbiAgICAgIH07XG4gICAgfSxcbiAgICB0b0ZuKF9ub2RlLCBkYXR1bSkge1xuICAgICAgcmV0dXJuIHsgLi4uZGF0dW0gfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdyb3VwID0ge1xuICAgIGZyb21Gbihub2RlLCBfZGF0dW0pIHtcbiAgICAgIGNvbnN0IHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBub2RlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcInVwZGF0ZWRcIl1cbiAgICAgIH07XG4gICAgfSxcbiAgICB0b0ZuKF9ub2RlLCBkYXR1bSkge1xuICAgICAgY29uc3QgeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IGRhdHVtO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHsgdGljaywgbGluZSwgbGFiZWwsIGdyb3VwIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNHcm91cEZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogZGF0dW0ucm90YXRpb24sXG4gICAgICByb3RhdGlvbkNlbnRlclg6IGRhdHVtLnJvdGF0aW9uQ2VudGVyWCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWTogZGF0dW0ucm90YXRpb25DZW50ZXJZLFxuICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS50cmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNTZWxlY3Rpb25GbihjdHgpIHtcbiAgY29uc3QgeyB2aXNpYmxlOiByYW5nZVZpc2libGUsIG1pbiwgbWF4IH0gPSBjdHg7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICBjb25zdCB2aXNpYmxlID0gcmFuZ2VWaXNpYmxlICYmIHkgPj0gbWluICYmIHkgPD0gbWF4O1xuICAgIHJldHVybiB7XG4gICAgICB5LFxuICAgICAgdHJhbnNsYXRpb25ZOiAwLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHZpc2libGVcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbigpIHtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZGF0dW0ueCxcbiAgICAgIHk6IGRhdHVtLnksXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWSxcbiAgICAgIHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogZGF0dW0ucm90YXRpb25DZW50ZXJYXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbigpIHtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICByZXR1cm4geyAuLi5kYXR1bSB9O1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXMudHNcbnZhciBfQXhpcyA9IGNsYXNzIF9BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIpIHtcbiAgICB0aGlzLm1vZHVsZUN0eCA9IG1vZHVsZUN0eDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUyO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLm5pY2UgPSB0cnVlO1xuICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXcgQXhpc0ludGVydmFsKCk7XG4gICAgdGhpcy5kYXRhRG9tYWluID0geyBkb21haW46IFtdLCBjbGlwcGVkOiBmYWxzZSB9O1xuICAgIHRoaXMubGF5b3V0Q29uc3RyYWludHMgPSB7XG4gICAgICBzdGFja2VkOiB0cnVlLFxuICAgICAgYWxpZ246IFwic3RhcnRcIixcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICB1bml0OiBcInBlcmNlbnRcIlxuICAgIH07XG4gICAgdGhpcy5ib3VuZFNlcmllcyA9IFtdO1xuICAgIHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPSBmYWxzZTtcbiAgICB0aGlzLmludGVyYWN0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1heGlzYCwgekluZGV4OiAyIC8qIEFYSVNfWklOREVYICovIH0pO1xuICAgIHRoaXMubGluZU5vZGUgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChuZXcgTGluZSh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtbGluZWAgfSkpO1xuICAgIHRoaXMudGlja0xpbmVHcm91cCA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy10aWNrLWxpbmVzYCwgekluZGV4OiAyIC8qIEFYSVNfWklOREVYICovIH0pXG4gICAgKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwID0gdGhpcy5heGlzR3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLXRpY2stbGFiZWxzYCwgekluZGV4OiAyIC8qIEFYSVNfWklOREVYICovIH0pXG4gICAgKTtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQ3Jvc3NMaW5lc2AgfSk7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tTGFiZWxzYCwgekluZGV4OiAxMCAvKiBTRVJJRVNfQU5OT1RBVElPTl9aSU5ERVggKi8gfSk7XG4gICAgdGhpcy5ncmlkR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLWdyaWRgIH0pO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cCA9IHRoaXMuZ3JpZEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tZ3JpZExpbmVzYCxcbiAgICAgICAgekluZGV4OiAxIC8qIEFYSVNfR1JJRF9aSU5ERVggKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMudGlja0xpbmVHcm91cCwgTGluZSwgZmFsc2UpO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMudGlja0xhYmVsR3JvdXAsIFRleHQsIGZhbHNlKTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuZ3JpZExpbmVHcm91cCwgTGluZSwgZmFsc2UpO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMgPSBbXTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgQXhpc0xpbmUoKTtcbiAgICB0aGlzLnRpY2sgPSBuZXcgQXhpc1RpY2soKTtcbiAgICB0aGlzLmdyaWRMaW5lID0gbmV3IEF4aXNHcmlkTGluZSgpO1xuICAgIHRoaXMubGFiZWwgPSB0aGlzLmNyZWF0ZUxhYmVsKCk7XG4gICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSBfQXhpcy5kZWZhdWx0VGlja01pblNwYWNpbmc7XG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIC8vIGF4aXMgcm90YXRpb24gYW5nbGUgaW4gZGVncmVlc1xuICAgIHRoaXMubGF5b3V0ID0ge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICAgIHBhZGRpbmc6IHRoaXMubGFiZWwucGFkZGluZyxcbiAgICAgICAgZm9ybWF0OiB0aGlzLmxhYmVsLmZvcm1hdFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnZpc2libGVSYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IEF4aXNUaXRsZSgpO1xuICAgIHRoaXMuX3RpdGxlQ2FwdGlvbiA9IG5ldyBDYXB0aW9uKCk7XG4gICAgdGhpcy5ncmlkTGVuZ3RoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZ3JpZCB0aWNrcyBhbmQgdGhlIGF4aXMgdGlja3MuXG4gICAgICovXG4gICAgdGhpcy5ncmlkUGFkZGluZyA9IDA7XG4gICAgLyoqXG4gICAgICogSXMgdXNlZCB0byBhdm9pZCBjb2xsaXNpb25zIGJldHdlZW4gYXhpcyBsYWJlbHMgYW5kIHNlcmllcy5cbiAgICAgKi9cbiAgICB0aGlzLnNlcmllc0FyZWFQYWRkaW5nID0gMDtcbiAgICB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0ID0gdm9pZCAwO1xuICAgIHRoaXMubWF4VGhpY2tuZXNzID0gSW5maW5pdHk7XG4gICAgdGhpcy5tb2R1bGVNYXAgPSBuZXcgTW9kdWxlTWFwKCk7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuc2NhbGUucmFuZ2Uuc2xpY2UoKTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godGhpcy5fdGl0bGVDYXB0aW9uLnJlZ2lzdGVySW50ZXJhY3Rpb24odGhpcy5tb2R1bGVDdHgpKTtcbiAgICB0aGlzLl90aXRsZUNhcHRpb24ubm9kZS5yb3RhdGlvbiA9IC1NYXRoLlBJIC8gMjtcbiAgICB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZCh0aGlzLl90aXRsZUNhcHRpb24ubm9kZSk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbW9kdWxlQ3R4LmFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXCJlbXB0eVwiLCB7XG4gICAgICBlbXB0eToge1xuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICBhY3Rpb246ICgpID0+IHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpXG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgIH0sXG4gICAgICByZWFkeToge1xuICAgICAgICB1cGRhdGU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVVwZGF0ZShkYXRhKSxcbiAgICAgICAgcmVzaXplOiAoKSA9PiB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKSxcbiAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMgPSBbXTtcbiAgICBsZXQgcHJldmlvdXNTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgbW9kdWxlQ3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKHByZXZpb3VzU2l6ZSAhPSBudWxsICYmIGpzb25EaWZmKGUuY2hhcnQsIHByZXZpb3VzU2l6ZSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NpemUgPSB7IC4uLmUuY2hhcnQgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlID8/IFwiXCI7XG4gIH1cbiAgc2V0IGNyb3NzTGluZXModmFsdWUpIHtcbiAgICBjb25zdCB7IENyb3NzTGluZUNvbnN0cnVjdG9yIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmRldGFjaENyb3NzTGluZShjcm9zc0xpbmUpKTtcbiAgICB0aGlzLl9jcm9zc0xpbmVzID0gdmFsdWUubWFwKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENyb3NzTGluZUNvbnN0cnVjdG9yKCk7XG4gICAgICBpbnN0YW5jZS5zZXQoY3Jvc3NMaW5lKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9KTtcbiAgICB0aGlzLl9jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKTtcbiAgICAgIHRoaXMuaW5pdENyb3NzTGluZShjcm9zc0xpbmUpO1xuICAgIH0pO1xuICB9XG4gIGdldCBjcm9zc0xpbmVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jcm9zc0xpbmVzO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9uKHBoYXNlKSB7XG4gICAgaWYgKHBoYXNlID09PSBcImluaXRpYWxcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzZXRcIik7XG4gICAgfVxuICB9XG4gIGF0dGFjaENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLmFwcGVuZENoaWxkKGNyb3NzTGluZS5ncm91cCk7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5hcHBlbmRDaGlsZChjcm9zc0xpbmUubGFiZWxHcm91cCk7XG4gIH1cbiAgZGV0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSkge1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAucmVtb3ZlQ2hpbGQoY3Jvc3NMaW5lLmdyb3VwKTtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLnJlbW92ZUNoaWxkKGNyb3NzTGluZS5sYWJlbEdyb3VwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubW9kdWxlTWFwLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgfVxuICB1cGRhdGVSYW5nZSgpIHtcbiAgICBjb25zdCB7IHJhbmdlOiByciwgdmlzaWJsZVJhbmdlOiB2ciwgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBzcGFuID0gKHJyWzFdIC0gcnJbMF0pIC8gKHZyWzFdIC0gdnJbMF0pO1xuICAgIGNvbnN0IHNoaWZ0ID0gc3BhbiAqIHZyWzBdO1xuICAgIGNvbnN0IHN0YXJ0ID0gcnJbMF0gLSBzaGlmdDtcbiAgICBzY2FsZTIuc2V0VmlzaWJsZVJhbmdlPy4odnIpO1xuICAgIHNjYWxlMi5yYW5nZSA9IFtzdGFydCwgc3RhcnQgKyBzcGFuXTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICBjcm9zc0xpbmUuY2xpcHBlZFJhbmdlID0gW3JyWzBdLCByclsxXV07XG4gICAgfSk7XG4gIH1cbiAgc2V0Q3Jvc3NMaW5lc1Zpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgYXR0YWNoQXhpcyhheGlzTm9kZSwgZ3JpZE5vZGUpIHtcbiAgICBncmlkTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmdyaWRHcm91cCk7XG4gICAgYXhpc05vZGUuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuY3Jvc3NMaW5lR3JvdXApO1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMubGFiZWxHcm91cCk7XG4gIH1cbiAgYXR0YWNoTGFiZWwoYXhpc0xhYmVsTm9kZSkge1xuICAgIHRoaXMubGFiZWxHcm91cC5hcHBlbmQoYXhpc0xhYmVsTm9kZSk7XG4gIH1cbiAgZGV0YWNoQXhpcyhheGlzTm9kZSwgZ3JpZE5vZGUpIHtcbiAgICBncmlkTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmdyaWRHcm91cCk7XG4gICAgYXhpc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIGF4aXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3Jvc3NMaW5lR3JvdXApO1xuICAgIGF4aXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMubGFiZWxHcm91cCk7XG4gIH1cbiAgZ2V0QXhpc0dyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNHcm91cDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgcG9pbnQgb3IgYW4gb2JqZWN0IGlzIGluIHJhbmdlLlxuICAgKiBAcGFyYW0geCBBIHBvaW50IChvciBvYmplY3QncyBzdGFydGluZyBwb2ludCkuXG4gICAqIEBwYXJhbSB0b2xlcmFuY2UgRXhwYW5kcyB0aGUgcmFuZ2Ugb24gYm90aCBlbmRzIGJ5IHRoaXMgYW1vdW50LlxuICAgKi9cbiAgaW5SYW5nZSh4LCB0b2xlcmFuY2UgPSAwKSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgodGhpcy5yYW5nZSk7XG4gICAgcmV0dXJuIHggPj0gbWluIC0gdG9sZXJhbmNlICYmIHggPD0gbWF4ICsgdG9sZXJhbmNlO1xuICB9XG4gIG9uRm9ybWF0Q2hhbmdlKHRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgX2RvbWFpbiwgZm9ybWF0KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxvZ1NjYWxlID0gc2NhbGUyIGluc3RhbmNlb2YgTG9nU2NhbGU7XG4gICAgY29uc3QgZGVmYXVsdEZvcm1hdHRlciA9IChmb3JtYXRPZmZzZXQpID0+IGxvZ1NjYWxlID8gU3RyaW5nIDogKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiID8geC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzICsgZm9ybWF0T2Zmc2V0KSA6IFN0cmluZyh4KTtcbiAgICBpZiAoZm9ybWF0ICYmIHNjYWxlMiAmJiBzY2FsZTIudGlja0Zvcm1hdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gc2NhbGUyLnRpY2tGb3JtYXQoeyB0aWNrcywgc3BlY2lmaWVyOiBmb3JtYXQgfSk7XG4gICAgICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSBkZWZhdWx0Rm9ybWF0dGVyKDApO1xuICAgICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gZGVmYXVsdEZvcm1hdHRlcigxKTtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUgYXhpcyBsYWJlbCBmb3JtYXQgc3RyaW5nICR7Zm9ybWF0fSBpcyBpbnZhbGlkLiBObyBmb3JtYXR0aW5nIHdpbGwgYmUgYXBwbGllZGApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZGVmYXVsdEZvcm1hdHRlcigwKTtcbiAgICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSBkZWZhdWx0Rm9ybWF0dGVyKDEpO1xuICAgIH1cbiAgfVxuICBzZXRUaWNrSW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnNjYWxlLmludGVydmFsID0gdGhpcy5pbnRlcnZhbD8uc3RlcCA/PyBpbnRlcnZhbDtcbiAgfVxuICBvbkdyaWRMZW5ndGhDaGFuZ2UodmFsdWUsIHByZXZWYWx1ZSkge1xuICAgIGlmIChwcmV2VmFsdWUgJiYgIXZhbHVlIHx8ICFwcmV2VmFsdWUgJiYgdmFsdWUpIHtcbiAgICAgIHRoaXMub25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpO1xuICAgIH1cbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gIH1cbiAgb25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuICBjcmVhdGVMYWJlbCgpIHtcbiAgICByZXR1cm4gbmV3IEF4aXNMYWJlbCgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzL3JlbW92ZXMvdXBkYXRlcyB0aGUgc2NlbmUgZ3JhcGggbm9kZXMgdGhhdCBjb25zdGl0dXRlIHRoZSBheGlzLlxuICAgKi9cbiAgdXBkYXRlKF9wcmltYXJ5VGlja0NvdW50ID0gMCwgYW5pbWF0ZWQgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH0gPSB0aGlzLmNhbGN1bGF0ZVJvdGF0aW9ucygpO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICBjb25zdCBsaW5lRGF0YSA9IHRoaXMuZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHsgdGlja0RhdGEsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduLCBwcmltYXJ5VGlja0NvdW50IH0gPSB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0O1xuICAgIGNvbnN0IHByZXZpb3VzVGlja3MgPSB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLm5vZGVzKCkubWFwKChub2RlKSA9PiBub2RlLmRhdHVtLnRpY2tJZCk7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25zKGxpbmVEYXRhLCB0aWNrRGF0YS50aWNrcywge1xuICAgICAgY29tYmluZWRSb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHJhbmdlOiB0aGlzLnNjYWxlLnJhbmdlXG4gICAgfSk7XG4gICAgaWYgKCFhbmltYXRlZCB8fCB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaWZmMiA9IHRoaXMuY2FsY3VsYXRlVXBkYXRlRGlmZihwcmV2aW91c1RpY2tzLCB0aWNrRGF0YSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIiwgZGlmZjIpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF4aXNMaW5lKCk7XG4gICAgdGhpcy51cGRhdGVMYWJlbHMoKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLnVwZGF0ZUdyaWRMaW5lcyhzaWRlRmxhZyk7XG4gICAgdGhpcy51cGRhdGVUaWNrTGluZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlKHsgYW55VGlja1Zpc2libGU6IHRpY2tEYXRhLnRpY2tzLmxlbmd0aCA+IDAgfSk7XG4gICAgdGhpcy51cGRhdGVDcm9zc0xpbmVzKHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH0pO1xuICAgIHRoaXMudXBkYXRlTGF5b3V0U3RhdGUodGlja0RhdGEuZnJhY3Rpb25EaWdpdHMpO1xuICAgIHJldHVybiBwcmltYXJ5VGlja0NvdW50O1xuICB9XG4gIGdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgodGhpcy5yYW5nZSk7XG4gICAgcmV0dXJuIHsgeDogMCwgeTE6IG1pbiwgeTI6IG1heCB9O1xuICB9XG4gIGdldFRpY2tMaW5lQ29vcmRpbmF0ZXMoZGF0dW0pIHtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCB4ID0gc2lkZUZsYWcgKiB0aGlzLmdldFRpY2tTaXplKCk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbigwLCB4KTtcbiAgICBjb25zdCB4MiA9IHgxICsgTWF0aC5hYnMoeCk7XG4gICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICByZXR1cm4geyB4MSwgeDIsIHkgfTtcbiAgfVxuICBnZXRUaWNrTGFiZWxQcm9wcyhkYXR1bSwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduLCByYW5nZTogcmFuZ2UzIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdGV4dCA9IGRhdHVtLnRpY2tMYWJlbDtcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiAodGhpcy5nZXRUaWNrU2l6ZSgpICsgbGFiZWwucGFkZGluZyArIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xuICAgIGNvbnN0IHZpc2libGUgPSB0ZXh0ICE9PSBcIlwiICYmIHRleHQgIT0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgdGlja0lkOiBkYXR1bS50aWNrSWQsXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWSxcbiAgICAgIGZpbGw6IGxhYmVsLmNvbG9yLFxuICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplOiBsYWJlbC5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcbiAgICAgIHJvdGF0aW9uOiBjb21iaW5lZFJvdGF0aW9uLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiBsYWJlbFgsXG4gICAgICB0ZXh0LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIHg6IGxhYmVsWCxcbiAgICAgIHk6IDAsXG4gICAgICByYW5nZTogcmFuZ2UzXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrLmVuYWJsZWQgPyB0aGlzLnRpY2suc2l6ZSA6IDY7XG4gIH1cbiAgc2V0VGl0bGVQcm9wcyhjYXB0aW9uLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzO1xuICAgIGlmICghdGl0bGUuZW5hYmxlZCkge1xuICAgICAgY2FwdGlvbi5lbmFibGVkID0gZmFsc2U7XG4gICAgICBjYXB0aW9uLm5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXB0aW9uLmNvbG9yID0gdGl0bGUuY29sb3I7XG4gICAgY2FwdGlvbi5mb250RmFtaWx5ID0gdGl0bGUuZm9udEZhbWlseTtcbiAgICBjYXB0aW9uLmZvbnRTaXplID0gdGl0bGUuZm9udFNpemU7XG4gICAgY2FwdGlvbi5mb250U3R5bGUgPSB0aXRsZS5mb250U3R5bGU7XG4gICAgY2FwdGlvbi5mb250V2VpZ2h0ID0gdGl0bGUuZm9udFdlaWdodDtcbiAgICBjYXB0aW9uLmVuYWJsZWQgPSB0aXRsZS5lbmFibGVkO1xuICAgIGNhcHRpb24ud3JhcHBpbmcgPSB0aXRsZS53cmFwcGluZztcbiAgICBjb25zdCB0aXRsZU5vZGUgPSBjYXB0aW9uLm5vZGU7XG4gICAgY29uc3QgcGFkZGluZyA9ICh0aXRsZS5zcGFjaW5nID8/IDApICsgcGFyYW1zLnNwYWNpbmc7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgcGFyYWxsZWxGbGlwUm90YXRpb24gPSBub3JtYWxpemVBbmdsZTM2MCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0aXRsZVJvdGF0aW9uRmxhZyA9IHNpZGVGbGFnID09PSAtMSAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA+IE1hdGguUEkgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPCBNYXRoLlBJICogMiA/IC0xIDogMTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRpdGxlUm90YXRpb25GbGFnICogc2lkZUZsYWcgKiBNYXRoLlBJIC8gMjtcbiAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSB0aXRsZVJvdGF0aW9uRmxhZyA9PT0gMSA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCB4ID0gTWF0aC5mbG9vcih0aXRsZVJvdGF0aW9uRmxhZyAqIHNpZGVGbGFnICogKHJhbmdlM1swXSArIHJhbmdlM1sxXSkgLyAyKTtcbiAgICBjb25zdCB5ID0gc2lkZUZsYWcgPT09IC0xID8gTWF0aC5mbG9vcih0aXRsZVJvdGF0aW9uRmxhZyAqIC1wYWRkaW5nKSA6IE1hdGguZmxvb3IoLXBhZGRpbmcpO1xuICAgIGNvbnN0IHsgY2FsbGJhY2tDYWNoZSB9ID0gdGhpcy5tb2R1bGVDdHg7XG4gICAgY29uc3QgeyBmb3JtYXR0ZXIgPSAocCkgPT4gcC5kZWZhdWx0VmFsdWUgfSA9IHRpdGxlO1xuICAgIGNvbnN0IHRleHQgPSBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB0aGlzLmdldFRpdGxlRm9ybWF0dGVyUGFyYW1zKCkpO1xuICAgIHRpdGxlTm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dChwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgY29uc3QgeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiAodGhpcy5nZXRUaWNrU2l6ZSgpICsgdGhpcy5sYWJlbC5wYWRkaW5nICsgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgdGhpcy51cGRhdGVTY2FsZSgpO1xuICAgIHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQgPSB0aGlzLmdlbmVyYXRlVGlja3Moe1xuICAgICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIGxhYmVsWCxcbiAgICAgIHNpZGVGbGFnXG4gICAgfSk7XG4gICAgY29uc3QgeyB0aWNrRGF0YSwgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIC4uLnRpY2tzUmVzdWx0IH0gPSB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0O1xuICAgIHRoaXMudXBkYXRlTGF5b3V0U3RhdGUodGlja0RhdGEuZnJhY3Rpb25EaWdpdHMpO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgY29uc3QgeyB4LCB5MSwgeTIgfSA9IHRoaXMuZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IGxpbmVCb3ggPSBuZXcgQkJveChcbiAgICAgIHggKyBNYXRoLm1pbihzaWRlRmxhZyAqIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcsIDApLFxuICAgICAgeTEsXG4gICAgICB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLFxuICAgICAgeTIgLSB5MVxuICAgICk7XG4gICAgYm94ZXMucHVzaChsaW5lQm94KTtcbiAgICBpZiAodGhpcy50aWNrLmVuYWJsZWQpIHtcbiAgICAgIHRpY2tEYXRhLnRpY2tzLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeDEsIHgyLCB5IH0gPSB0aGlzLmdldFRpY2tMaW5lQ29vcmRpbmF0ZXMoZGF0dW0pO1xuICAgICAgICBjb25zdCB0aWNrTGluZUJveCA9IG5ldyBCQm94KHgxLCB5LCB4MiAtIHgxLCAwKTtcbiAgICAgICAgYm94ZXMucHVzaCh0aWNrTGluZUJveCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgY29uc3QgdGVtcFRleHQgPSBuZXcgVGV4dCgpO1xuICAgICAgdGlja0RhdGEudGlja3MuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWxQcm9wcyA9IHRoaXMuZ2V0VGlja0xhYmVsUHJvcHMoZGF0dW0sIHtcbiAgICAgICAgICBjb21iaW5lZFJvdGF0aW9uLFxuICAgICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgcmFuZ2U6IHRoaXMuc2NhbGUucmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbGFiZWxQcm9wcy52aXNpYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBUZXh0LnNldFByb3BlcnRpZXMoe1xuICAgICAgICAgIC4uLmxhYmVsUHJvcHMsXG4gICAgICAgICAgdHJhbnNsYXRpb25ZOiBNYXRoLnJvdW5kKGRhdHVtLnRyYW5zbGF0aW9uWSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJveCA9IHRlbXBUZXh0LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRpdGxlPy5lbmFibGVkKSB7XG4gICAgICBjb25zdCBjYXB0aW9uID0gbmV3IENhcHRpb24oKTtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSBCQm94Lm1lcmdlKGJveGVzKS53aWR0aDtcbiAgICAgIHRoaXMuc2V0VGl0bGVQcm9wcyhjYXB0aW9uLCB7IHNwYWNpbmcgfSk7XG4gICAgICBjb25zdCB0aXRsZU5vZGUgPSBjYXB0aW9uLm5vZGU7XG4gICAgICBjb25zdCB0aXRsZUJveCA9IHRpdGxlTm9kZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICBpZiAodGl0bGVCb3gpIHtcbiAgICAgICAgYm94ZXMucHVzaCh0aXRsZUJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSBCQm94Lm1lcmdlKGJveGVzKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJCb3ggPSB0aGlzLmdldFRyYW5zZm9ybUJveChiYm94KTtcbiAgICBjb25zdCBhbnlTZXJpZXNBY3RpdmUgPSB0aGlzLmlzQW55U2VyaWVzQWN0aXZlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY3Jvc3NMaW5lLnNpZGVGbGFnID0gLXNpZGVGbGFnO1xuICAgICAgY3Jvc3NMaW5lLmRpcmVjdGlvbiA9IHJvdGF0aW9uID09PSAtTWF0aC5QSSAvIDIgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgICAgIGlmIChjcm9zc0xpbmUgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5Dcm9zc0xpbmUpIHtcbiAgICAgICAgKF9hID0gY3Jvc3NMaW5lLmxhYmVsKS5wYXJhbGxlbCA/PyAoX2EucGFyYWxsZWwgPSB0aGlzLmxhYmVsLnBhcmFsbGVsKTtcbiAgICAgIH1cbiAgICAgIGNyb3NzTGluZS5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLnJlZ3VsYXJGbGlwUm90YXRpb24gPSByZWd1bGFyRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLmNhbGN1bGF0ZUxheW91dD8uKGFueVNlcmllc0FjdGl2ZSwgdGhpcy5yZXZlcnNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpbWFyeVRpY2tDb3VudDogdGlja3NSZXN1bHQucHJpbWFyeVRpY2tDb3VudCxcbiAgICAgIGJib3g6IHRyYW5zZm9ybWVkQkJveFxuICAgIH07XG4gIH1cbiAgdXBkYXRlTGF5b3V0U3RhdGUoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB0aGlzLmxheW91dC5sYWJlbCA9IHtcbiAgICAgIGZyYWN0aW9uRGlnaXRzLFxuICAgICAgcGFkZGluZzogdGhpcy5sYWJlbC5wYWRkaW5nLFxuICAgICAgZm9ybWF0OiB0aGlzLmxhYmVsLmZvcm1hdFxuICAgIH07XG4gIH1cbiAgZ2V0VHJhbnNmb3JtQm94KGJib3gpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb246IGF4aXNSb3RhdGlvbixcbiAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWSxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWVxuICAgIH0gPSB0aGlzLmdldEF4aXNUcmFuc2Zvcm0oKTtcbiAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgMSwgMSwgYXhpc1JvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwge1xuICAgICAgc2NhbGluZ0NlbnRlclg6IDAsXG4gICAgICBzY2FsaW5nQ2VudGVyWTogMCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWVxuICAgIH0pO1xuICAgIHJldHVybiBtYXRyaXgudHJhbnNmb3JtQkJveChiYm94KTtcbiAgfVxuICBzZXREb21haW4oZG9tYWluKSB7XG4gICAgdGhpcy5kYXRhRG9tYWluID0gdGhpcy5ub3JtYWxpc2VEYXRhRG9tYWluKGRvbWFpbik7XG4gICAgaWYgKHRoaXMucmV2ZXJzZSkge1xuICAgICAgdGhpcy5kYXRhRG9tYWluLmRvbWFpbi5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUuZG9tYWluID0gdGhpcy5kYXRhRG9tYWluLmRvbWFpbjtcbiAgfVxuICB1cGRhdGVTY2FsZSgpIHtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVEb21haW4oKTtcbiAgICB0aGlzLnNldFRpY2tJbnRlcnZhbCh0aGlzLmludGVydmFsLnN0ZXApO1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiwgbmljZSB9ID0gdGhpcztcbiAgICBpZiAoIUNvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjYWxlMi5uaWNlID0gbmljZTtcbiAgICBzY2FsZTIudXBkYXRlKCk7XG4gIH1cbiAgY2FsY3VsYXRlUm90YXRpb25zKCkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24pO1xuICAgIGNvbnN0IHJlZ3VsYXJGbGlwUm90YXRpb24gPSBub3JtYWxpemVBbmdsZTM2MChyb3RhdGlvbiAtIE1hdGguUEkgLyAyKTtcbiAgICByZXR1cm4geyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tzKHtcbiAgICBwcmltYXJ5VGlja0NvdW50LFxuICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgbGFiZWxYLFxuICAgIHNpZGVGbGFnXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgaW50ZXJ2YWw6IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9LFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBmb250RmFtaWx5LCBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0IH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZWNvbmRhcnlBeGlzID0gcHJpbWFyeVRpY2tDb3VudCAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IHsgZGVmYXVsdFJvdGF0aW9uLCBjb25maWd1cmVkUm90YXRpb24sIHBhcmFsbGVsRmxpcEZsYWcsIHJlZ3VsYXJGbGlwRmxhZyB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uXG4gICAgfSk7XG4gICAgY29uc3QgaW5pdGlhbFJvdGF0aW9uID0gY29uZmlndXJlZFJvdGF0aW9uICsgZGVmYXVsdFJvdGF0aW9uO1xuICAgIGNvbnN0IGxhYmVsTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50IH0gPSB0aGlzLmVzdGltYXRlVGlja0NvdW50KHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9KTtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAhY29udGludW91cyB8fCBpc05hTihtYXhUaWNrQ291bnQpID8gMTAgOiBtYXhUaWNrQ291bnQ7XG4gICAgbGV0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCAwLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcbiAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSBnZXRUZXh0QmFzZWxpbmUocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgc2lkZUZsYWcsIHBhcmFsbGVsRmxpcEZsYWcpO1xuICAgIGNvbnN0IGZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHsgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9KTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBjb25zdCB0ZXh0UHJvcHMgPSB7XG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udFNpemUsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgdGV4dEFsaWduXG4gICAgfTtcbiAgICBsZXQgdGlja0RhdGEgPSB7XG4gICAgICByYXdUaWNrczogW10sXG4gICAgICBmcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgIHRpY2tzOiBbXSxcbiAgICAgIGxhYmVsQ291bnQ6IDBcbiAgICB9O1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGF1dG9Sb3RhdGlvbiA9IDA7XG4gICAgbGV0IGxhYmVsT3ZlcmxhcCA9IHRydWU7XG4gICAgbGV0IHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChsYWJlbE92ZXJsYXAgJiYgaW5kZXggPD0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF1dG9Sb3RhdGlvbiA9IDA7XG4gICAgICB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ24ocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgMCwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZyk7XG4gICAgICBjb25zdCB0aWNrU3RyYXRlZ2llcyA9IHRoaXMuZ2V0VGlja1N0cmF0ZWdpZXMoeyBzZWNvbmRhcnlBeGlzLCBpbmRleCB9KTtcbiAgICAgIGZvciAoY29uc3Qgc3RyYXRlZ3kgb2YgdGlja1N0cmF0ZWdpZXMpIHtcbiAgICAgICAgKHsgdGlja0RhdGEsIGluZGV4LCBhdXRvUm90YXRpb24sIHRlcm1pbmF0ZSB9ID0gc3RyYXRlZ3koe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHRpY2tEYXRhLFxuICAgICAgICAgIHRleHRQcm9wcyxcbiAgICAgICAgICBsYWJlbE92ZXJsYXAsXG4gICAgICAgICAgdGVybWluYXRlLFxuICAgICAgICAgIHByaW1hcnlUaWNrQ291bnRcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCByb3RhdGVkID0gY29uZmlndXJlZFJvdGF0aW9uICE9PSAwIHx8IGF1dG9Sb3RhdGlvbiAhPT0gMDtcbiAgICAgICAgY29uc3QgbGFiZWxSb3RhdGlvbiA9IGluaXRpYWxSb3RhdGlvbiArIGF1dG9Sb3RhdGlvbjtcbiAgICAgICAgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIGF1dG9Sb3RhdGlvbiwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZyk7XG4gICAgICAgIGxhYmVsT3ZlcmxhcCA9IHRoaXMubGFiZWwuYXZvaWRDb2xsaXNpb25zID8gdGhpcy5jaGVja0xhYmVsT3ZlcmxhcChsYWJlbFJvdGF0aW9uLCByb3RhdGVkLCBsYWJlbE1hdHJpeCwgdGlja0RhdGEudGlja3MsIGxhYmVsWCwgdGV4dE1lYXN1cmVyKSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb21iaW5lZFJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uICsgY29uZmlndXJlZFJvdGF0aW9uICsgYXV0b1JvdGF0aW9uO1xuICAgIGlmICghc2Vjb25kYXJ5QXhpcyAmJiB0aWNrRGF0YS5yYXdUaWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmltYXJ5VGlja0NvdW50ID0gdGlja0RhdGEucmF3VGlja3MubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4geyB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfTtcbiAgfVxuICBnZXRUaWNrU3RyYXRlZ2llcyh7XG4gICAgaW5kZXg6IGl0ZXJhdGlvbixcbiAgICBzZWNvbmRhcnlBeGlzXG4gIH0pIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIsIGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbWluU3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IGF2b2lkTGFiZWxDb2xsaXNpb25zID0gbGFiZWwuZW5hYmxlZCAmJiBsYWJlbC5hdm9pZENvbGxpc2lvbnM7XG4gICAgY29uc3QgZmlsdGVyVGlja3MgPSAhY29udGludW91cyAmJiBpdGVyYXRpb24gIT09IDAgJiYgYXZvaWRMYWJlbENvbGxpc2lvbnM7XG4gICAgY29uc3QgYXV0b1JvdGF0ZSA9IGxhYmVsLmF1dG9Sb3RhdGUgPT09IHRydWUgJiYgbGFiZWwucm90YXRpb24gPT09IHZvaWQgMDtcbiAgICBjb25zdCBzdHJhdGVnaWVzID0gW107XG4gICAgbGV0IHRpY2tHZW5lcmF0aW9uVHlwZTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbC52YWx1ZXMpIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDMgLyogVkFMVUVTICovO1xuICAgIH0gZWxzZSBpZiAoc2Vjb25kYXJ5QXhpcykge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMSAvKiBDUkVBVEVfU0VDT05EQVJZICovO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyVGlja3MpIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDIgLyogRklMVEVSICovO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAwIC8qIENSRUFURSAqLztcbiAgICB9XG4gICAgY29uc3QgdGlja0dlbmVyYXRpb25TdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgdGVybWluYXRlIH0pID0+IHRoaXMuY3JlYXRlVGlja0RhdGEodGlja0dlbmVyYXRpb25UeXBlLCBpbmRleCwgdGlja0RhdGEsIHRlcm1pbmF0ZSwgcHJpbWFyeVRpY2tDb3VudCk7XG4gICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tHZW5lcmF0aW9uU3RyYXRlZ3kpO1xuICAgIGlmICghY29udGludW91cyAmJiAhaXNOYU4obWluU3BhY2luZykpIHtcbiAgICAgIGNvbnN0IHRpY2tGaWx0ZXJTdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgdGVybWluYXRlIH0pID0+IHRoaXMuY3JlYXRlVGlja0RhdGEoMiAvKiBGSUxURVIgKi8sIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgICAgIHN0cmF0ZWdpZXMucHVzaCh0aWNrRmlsdGVyU3RyYXRlZ3kpO1xuICAgIH1cbiAgICBpZiAoIWF2b2lkTGFiZWxDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4gc3RyYXRlZ2llcztcbiAgICB9XG4gICAgaWYgKGF1dG9Sb3RhdGUpIHtcbiAgICAgIGNvbnN0IGF1dG9Sb3RhdGVTdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgbGFiZWxPdmVybGFwLCB0ZXJtaW5hdGUgfSkgPT4gKHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHRpY2tEYXRhLFxuICAgICAgICBhdXRvUm90YXRpb246IHRoaXMuZ2V0QXV0b1JvdGF0aW9uKGxhYmVsT3ZlcmxhcCksXG4gICAgICAgIHRlcm1pbmF0ZVxuICAgICAgfSk7XG4gICAgICBzdHJhdGVnaWVzLnB1c2goYXV0b1JvdGF0ZVN0cmF0ZWd5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmF0ZWdpZXM7XG4gIH1cbiAgY3JlYXRlVGlja0RhdGEodGlja0dlbmVyYXRpb25UeXBlLCBpbmRleCwgdGlja0RhdGEsIHRlcm1pbmF0ZSwgcHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0ZXAsIHZhbHVlcywgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCwgbWluVGlja0NvdW50LCBkZWZhdWx0VGlja0NvdW50IH0gPSB0aGlzLmVzdGltYXRlVGlja0NvdW50KHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9KTtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAhY29udGludW91cyB8fCBpc05hTihtYXhUaWNrQ291bnQpID8gMTAgOiBtYXhUaWNrQ291bnQ7XG4gICAgbGV0IHRpY2tDb3VudCA9IGNvbnRpbnVvdXMgPyBNYXRoLm1heChkZWZhdWx0VGlja0NvdW50IC0gaW5kZXgsIG1pblRpY2tDb3VudCkgOiBtYXhUaWNrQ291bnQ7XG4gICAgY29uc3QgcmVnZW5lcmF0ZVRpY2tzID0gc3RlcCA9PT0gdm9pZCAwICYmIHZhbHVlcyA9PT0gdm9pZCAwICYmIHRpY2tDb3VudCA+IG1pblRpY2tDb3VudCAmJiAoY29udGludW91cyB8fCB0aWNrR2VuZXJhdGlvblR5cGUgPT09IDIgLyogRklMVEVSICovKTtcbiAgICBsZXQgdW5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB3aGlsZSAodW5jaGFuZ2VkICYmIGluZGV4IDw9IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHByZXZUaWNrcyA9IHRpY2tEYXRhLnJhd1RpY2tzO1xuICAgICAgdGlja0NvdW50ID0gY29udGludW91cyA/IE1hdGgubWF4KGRlZmF1bHRUaWNrQ291bnQgLSBpbmRleCwgbWluVGlja0NvdW50KSA6IG1heFRpY2tDb3VudDtcbiAgICAgIGNvbnN0IHsgcmF3VGlja3MsIGZyYWN0aW9uRGlnaXRzLCB0aWNrcywgbGFiZWxDb3VudCB9ID0gdGhpcy5nZXRUaWNrcyh7XG4gICAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSxcbiAgICAgICAgcHJldmlvdXNUaWNrczogcHJldlRpY2tzLFxuICAgICAgICB0aWNrQ291bnQsXG4gICAgICAgIG1pblRpY2tDb3VudCxcbiAgICAgICAgbWF4VGlja0NvdW50LFxuICAgICAgICBwcmltYXJ5VGlja0NvdW50XG4gICAgICB9KTtcbiAgICAgIHRpY2tEYXRhLnJhd1RpY2tzID0gcmF3VGlja3M7XG4gICAgICB0aWNrRGF0YS5mcmFjdGlvbkRpZ2l0cyA9IGZyYWN0aW9uRGlnaXRzO1xuICAgICAgdGlja0RhdGEudGlja3MgPSB0aWNrcztcbiAgICAgIHRpY2tEYXRhLmxhYmVsQ291bnQgPSBsYWJlbENvdW50O1xuICAgICAgdW5jaGFuZ2VkID0gcmVnZW5lcmF0ZVRpY2tzID8gYXJlQXJyYXlOdW1iZXJzRXF1YWwocmF3VGlja3MsIHByZXZUaWNrcykgOiBmYWxzZTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFRlcm1pbmF0ZSA9IHN0ZXAgIT09IHZvaWQgMCB8fCB2YWx1ZXMgIT09IHZvaWQgMDtcbiAgICB0ZXJtaW5hdGUgfHwgKHRlcm1pbmF0ZSA9IHNob3VsZFRlcm1pbmF0ZSk7XG4gICAgcmV0dXJuIHsgdGlja0RhdGEsIGluZGV4LCBhdXRvUm90YXRpb246IDAsIHRlcm1pbmF0ZSB9O1xuICB9XG4gIGNoZWNrTGFiZWxPdmVybGFwKHJvdGF0aW9uLCByb3RhdGVkLCBsYWJlbE1hdHJpeCwgdGlja0RhdGEsIGxhYmVsWCwgdGV4dE1lYXN1cmVyKSB7XG4gICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChsYWJlbE1hdHJpeCwgMSwgMSwgcm90YXRpb24sIDAsIDApO1xuICAgIGNvbnN0IGxhYmVsRGF0YSA9IHRoaXMuY3JlYXRlTGFiZWxEYXRhKHRpY2tEYXRhLCBsYWJlbFgsIGxhYmVsTWF0cml4LCB0ZXh0TWVhc3VyZXIpO1xuICAgIGNvbnN0IGxhYmVsU3BhY2luZyA9IGdldExhYmVsU3BhY2luZyh0aGlzLmxhYmVsLm1pblNwYWNpbmcsIHJvdGF0ZWQpO1xuICAgIHJldHVybiBheGlzTGFiZWxzT3ZlcmxhcChsYWJlbERhdGEsIGxhYmVsU3BhY2luZyk7XG4gIH1cbiAgY3JlYXRlTGFiZWxEYXRhKHRpY2tEYXRhLCBsYWJlbFgsIGxhYmVsTWF0cml4LCB0ZXh0TWVhc3VyZXIpIHtcbiAgICBjb25zdCBsYWJlbERhdGEgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgdGlja0xhYmVsLCB0cmFuc2xhdGlvblkgfSBvZiB0aWNrRGF0YSkge1xuICAgICAgaWYgKCF0aWNrTGFiZWwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRpY2tMYWJlbCk7XG4gICAgICBjb25zdCBiYm94ID0gbmV3IEJCb3gobGFiZWxYLCB0cmFuc2xhdGlvblksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbGFiZWxEYXR1bSA9IGNhbGN1bGF0ZUxhYmVsQkJveCh0aWNrTGFiZWwsIGJib3gsIGxhYmVsTWF0cml4KTtcbiAgICAgIGxhYmVsRGF0YS5wdXNoKGxhYmVsRGF0dW0pO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxEYXRhO1xuICB9XG4gIGdldEF1dG9Sb3RhdGlvbihsYWJlbE92ZXJsYXApIHtcbiAgICByZXR1cm4gbGFiZWxPdmVybGFwID8gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKHRoaXMubGFiZWwuYXV0b1JvdGF0ZUFuZ2xlID8/IDApKSA6IDA7XG4gIH1cbiAgZ2V0VGlja3Moe1xuICAgIHRpY2tHZW5lcmF0aW9uVHlwZSxcbiAgICBwcmV2aW91c1RpY2tzLFxuICAgIHRpY2tDb3VudCxcbiAgICBtaW5UaWNrQ291bnQsXG4gICAgbWF4VGlja0NvdW50LFxuICAgIHByaW1hcnlUaWNrQ291bnRcbiAgfSkge1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMywgc2NhbGU6IHNjYWxlMiwgdmlzaWJsZVJhbmdlIH0gPSB0aGlzO1xuICAgIGxldCByYXdUaWNrcztcbiAgICBzd2l0Y2ggKHRpY2tHZW5lcmF0aW9uVHlwZSkge1xuICAgICAgY2FzZSAzIC8qIFZBTFVFUyAqLzpcbiAgICAgICAgcmF3VGlja3MgPSB0aGlzLmludGVydmFsLnZhbHVlcztcbiAgICAgICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpKSB7XG4gICAgICAgICAgY29uc3QgW2QwLCBkMV0gPSBmaW5kTWluTWF4KHNjYWxlMi5nZXREb21haW4oKS5tYXAoTnVtYmVyKSk7XG4gICAgICAgICAgcmF3VGlja3MgPSByYXdUaWNrcy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSA+PSBkMCAmJiB2YWx1ZSA8PSBkMSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIENSRUFURV9TRUNPTkRBUlkgKi86XG4gICAgICAgIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgICAgICAgIHJhd1RpY2tzID0gdGhpcy51cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MocHJpbWFyeVRpY2tDb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3VGlja3MgPSB0aGlzLmNyZWF0ZVRpY2tzKHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIEZJTFRFUiAqLzpcbiAgICAgICAgcmF3VGlja3MgPSB0aGlzLmZpbHRlclRpY2tzKHByZXZpb3VzVGlja3MsIHRpY2tDb3VudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmF3VGlja3MgPSB0aGlzLmNyZWF0ZVRpY2tzKHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSByYXdUaWNrcy5yZWR1Y2UoKG1heCwgdGljaykgPT4gTWF0aC5tYXgobWF4LCBjb3VudEZyYWN0aW9uRGlnaXRzKHRpY2spKSwgMCk7XG4gICAgY29uc3QgaGFsZkJhbmR3aWR0aCA9IChzY2FsZTIuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbENvdW50ID0gMDtcbiAgICBjb25zdCB0aWNrSWRDb3VudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih2aXNpYmxlUmFuZ2VbMF0gKiByYXdUaWNrcy5sZW5ndGgpKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihyYXdUaWNrcy5sZW5ndGgsIE1hdGguY2VpbCh2aXNpYmxlUmFuZ2VbMV0gKiByYXdUaWNrcy5sZW5ndGgpKTtcbiAgICBjb25zdCBmaWx0ZXJlZFRpY2tzID0gcmF3VGlja3Muc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5vbkZvcm1hdENoYW5nZShmaWx0ZXJlZFRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgcmF3VGlja3MsIHRoaXMubGFiZWwuZm9ybWF0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkVGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpY2sgPSBmaWx0ZXJlZFRpY2tzW2ldO1xuICAgICAgY29uc3QgdHJhbnNsYXRpb25ZID0gc2NhbGUyLmNvbnZlcnQodGljaykgKyBoYWxmQmFuZHdpZHRoO1xuICAgICAgaWYgKHJhbmdlMy5sZW5ndGggPiAwICYmICF0aGlzLmluUmFuZ2UodHJhbnNsYXRpb25ZLCAxZS0zKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB0aWNrTGFiZWwgPSB0aGlzLmZvcm1hdFRpY2sodGljaywgZnJhY3Rpb25EaWdpdHMsIHN0YXJ0ICsgaSk7XG4gICAgICBsZXQgdGlja0lkID0gdGlja0xhYmVsO1xuICAgICAgaWYgKHRpY2tJZENvdW50cy5oYXModGlja0lkKSkge1xuICAgICAgICBjb25zdCBjb3VudCA9IHRpY2tJZENvdW50cy5nZXQodGlja0lkKTtcbiAgICAgICAgdGlja0lkQ291bnRzLnNldCh0aWNrSWQsIGNvdW50ICsgMSk7XG4gICAgICAgIHRpY2tJZCA9IGAke3RpY2tJZH1fJHtjb3VudH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlja0lkQ291bnRzLnNldCh0aWNrSWQsIDEpO1xuICAgICAgfVxuICAgICAgdGlja3MucHVzaCh7IHRpY2ssIHRpY2tJZCwgdGlja0xhYmVsLCB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IodHJhbnNsYXRpb25ZKSB9KTtcbiAgICAgIGlmICh0aWNrTGFiZWwgPT09IFwiXCIgfHwgdGlja0xhYmVsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsYWJlbENvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiB7IHJhd1RpY2tzLCBmcmFjdGlvbkRpZ2l0cywgdGlja3MsIGxhYmVsQ291bnQgfTtcbiAgfVxuICBmaWx0ZXJUaWNrcyh0aWNrcywgdGlja0NvdW50KSB7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IHRpY2tTcGFjaW5nID0gIWlzTmFOKG1pblNwYWNpbmcpIHx8ICFpc05hTihtYXhTcGFjaW5nKTtcbiAgICBjb25zdCBrZWVwRXZlcnkgPSB0aWNrU3BhY2luZyA/IE1hdGguY2VpbCh0aWNrcy5sZW5ndGggLyB0aWNrQ291bnQpIDogMjtcbiAgICByZXR1cm4gdGlja3MuZmlsdGVyKChfLCBpKSA9PiBpICUga2VlcEV2ZXJ5ID09PSAwKTtcbiAgfVxuICBjcmVhdGVUaWNrcyh0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmICh0aWNrQ291bnQgJiYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGlja0NvdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNjYWxlMi50aWNrQ291bnQgPSB0aWNrQ291bnQ7XG4gICAgICAgIHNjYWxlMi5taW5UaWNrQ291bnQgPSBtaW5UaWNrQ291bnQgPz8gMDtcbiAgICAgICAgc2NhbGUyLm1heFRpY2tDb3VudCA9IG1heFRpY2tDb3VudCA/PyBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAoc2NhbGUyIGluc3RhbmNlb2YgVGltZVNjYWxlKSB7XG4gICAgICAgIHRoaXMuc2V0VGlja0ludGVydmFsKHRpY2tDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTIudGlja3M/LigpID8/IFtdO1xuICB9XG4gIGVzdGltYXRlVGlja0NvdW50KHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9KSB7XG4gICAgaWYgKCF0aGlzLmxhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluVGlja0NvdW50OiBDb250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudCxcbiAgICAgICAgbWF4VGlja0NvdW50OiBDb250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudCxcbiAgICAgICAgZGVmYXVsdFRpY2tDb3VudDogQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlV2l0aEJsZWVkID0gdGhpcy5jYWxjdWxhdGVSYW5nZVdpdGhCbGVlZCgpO1xuICAgIGNvbnN0IGRlZmF1bHRNaW5TcGFjaW5nID0gTWF0aC5tYXgoXG4gICAgICB0aGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyxcbiAgICAgIHJhbmdlV2l0aEJsZWVkIC8gQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnRcbiAgICApO1xuICAgIGxldCBjbGFtcE1heFRpY2tDb3VudCA9ICFpc05hTihtYXhTcGFjaW5nKTtcbiAgICBpZiAoaXNOYU4obWluU3BhY2luZykpIHtcbiAgICAgIG1pblNwYWNpbmcgPSBkZWZhdWx0TWluU3BhY2luZztcbiAgICB9XG4gICAgaWYgKGlzTmFOKG1heFNwYWNpbmcpKSB7XG4gICAgICBtYXhTcGFjaW5nID0gcmFuZ2VXaXRoQmxlZWQ7XG4gICAgfVxuICAgIGlmIChtaW5TcGFjaW5nID4gbWF4U3BhY2luZykge1xuICAgICAgaWYgKG1pblNwYWNpbmcgPT09IGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gICAgICAgIG1pblNwYWNpbmcgPSBtYXhTcGFjaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U3BhY2luZyA9IG1pblNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pblJlY3REaXN0YW5jZSA9IDI7XG4gICAgY2xhbXBNYXhUaWNrQ291bnQgJiYgKGNsYW1wTWF4VGlja0NvdW50ID0gbWluUmVjdERpc3RhbmNlIDwgZGVmYXVsdE1pblNwYWNpbmcpO1xuICAgIGNvbnN0IG1heFRpY2tDb3VudCA9IGNsYW1wKFxuICAgICAgMSxcbiAgICAgIE1hdGguZmxvb3IocmFuZ2VXaXRoQmxlZWQgLyBtaW5TcGFjaW5nKSxcbiAgICAgIGNsYW1wTWF4VGlja0NvdW50ID8gTWF0aC5taW4oTWF0aC5mbG9vcihyYW5nZVdpdGhCbGVlZCAvIG1pblJlY3REaXN0YW5jZSksIDEwMCkgOiAxMDBcbiAgICApO1xuICAgIGNvbnN0IG1pblRpY2tDb3VudCA9IE1hdGgubWluKG1heFRpY2tDb3VudCwgTWF0aC5jZWlsKHJhbmdlV2l0aEJsZWVkIC8gbWF4U3BhY2luZykpO1xuICAgIGNvbnN0IGRlZmF1bHRUaWNrQ291bnQgPSBjbGFtcChtaW5UaWNrQ291bnQsIENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICAgIHJldHVybiB7IG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50LCBkZWZhdWx0VGlja0NvdW50IH07XG4gIH1cbiAgdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICBpZiAodGhpcy5tb2R1bGVDdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gICAgfVxuICAgIHRoaXMudGlja0xpbmVHcm91cC52aXNpYmxlID0gdGhpcy50aWNrLmVuYWJsZWQ7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwLnZpc2libGUgPSB0aGlzLmdyaWRMaW5lLmVuYWJsZWQ7XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cC52aXNpYmxlID0gdGhpcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIHVwZGF0ZUNyb3NzTGluZXMoe1xuICAgIHJvdGF0aW9uLFxuICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgIHJlZ3VsYXJGbGlwUm90YXRpb25cbiAgfSkge1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGFueVNlcmllc0FjdGl2ZSA9IHRoaXMuaXNBbnlTZXJpZXNBY3RpdmUoKTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICBjcm9zc0xpbmUuc2lkZUZsYWcgPSAtc2lkZUZsYWc7XG4gICAgICBjcm9zc0xpbmUuZGlyZWN0aW9uID0gcm90YXRpb24gPT09IC1NYXRoLlBJIC8gMiA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICAgICAgaWYgKGNyb3NzTGluZSBpbnN0YW5jZW9mIENhcnRlc2lhbkNyb3NzTGluZSkge1xuICAgICAgICBjcm9zc0xpbmUubGFiZWwucGFyYWxsZWwgPSBjcm9zc0xpbmUubGFiZWwucGFyYWxsZWwgPz8gdGhpcy5sYWJlbC5wYXJhbGxlbDtcbiAgICAgIH1cbiAgICAgIGNyb3NzTGluZS5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLnJlZ3VsYXJGbGlwUm90YXRpb24gPSByZWd1bGFyRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLnVwZGF0ZShhbnlTZXJpZXNBY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVRpY2tMaW5lcygpIHtcbiAgICBjb25zdCB7IHRpY2ssIGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaCgobGluZSkgPT4ge1xuICAgICAgbGluZS5zdHJva2VXaWR0aCA9IHRpY2sud2lkdGg7XG4gICAgICBsaW5lLnN0cm9rZSA9IHRpY2suc3Ryb2tlO1xuICAgICAgbGluZS54MSA9IHNpZGVGbGFnICogdGhpcy5nZXRUaWNrU2l6ZSgpO1xuICAgICAgbGluZS54MiA9IDA7XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlQXZhaWxhYmxlUmFuZ2UoKSB7XG4gICAgcmV0dXJuIGZpbmRSYW5nZUV4dGVudCh0aGlzLnJhbmdlKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIHJhbmdlIHdpdGggYW4gYWRkaXRpb25hbCBcImJsZWVkXCIgYmV5b25kIHRoZSBjYW52YXMgdGhhdCBlbmNvbXBhc3NlcyB0aGUgZnVsbCBheGlzIHdoZW5cbiAgICogdGhlIHZpc2libGUgcmFuZ2UgaXMgb25seSBhIHBvcnRpb24gb2YgdGhlIGF4aXMuXG4gICAqL1xuICBjYWxjdWxhdGVSYW5nZVdpdGhCbGVlZCgpIHtcbiAgICBjb25zdCB2aXNpYmxlU2NhbGUgPSAxIC8gZmluZFJhbmdlRXh0ZW50KHRoaXMudmlzaWJsZVJhbmdlKTtcbiAgICByZXR1cm4gcm91bmQodGhpcy5jYWxjdWxhdGVBdmFpbGFibGVSYW5nZSgpICogdmlzaWJsZVNjYWxlLCAyKTtcbiAgfVxuICBjYWxjdWxhdGVEb21haW4oKSB7XG4gICAgY29uc3QgdmlzaWJsZVNlcmllcyA9IHRoaXMuYm91bmRTZXJpZXMuZmlsdGVyKChzKSA9PiB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zIHx8IHMuaXNFbmFibGVkKCkpO1xuICAgIGNvbnN0IGRvbWFpbnMgPSB2aXNpYmxlU2VyaWVzLmZsYXRNYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldERvbWFpbih0aGlzLmRpcmVjdGlvbikpO1xuICAgIHRoaXMuc2V0RG9tYWluKGRvbWFpbnMpO1xuICB9XG4gIGdldEF4aXNUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiB0b1JhZGlhbnModGhpcy5yb3RhdGlvbiksXG4gICAgICByb3RhdGlvbkNlbnRlclg6IDAsXG4gICAgICByb3RhdGlvbkNlbnRlclk6IDAsXG4gICAgICB0cmFuc2xhdGlvblg6IE1hdGguZmxvb3IodGhpcy50cmFuc2xhdGlvbi54KSxcbiAgICAgIHRyYW5zbGF0aW9uWTogTWF0aC5mbG9vcih0aGlzLnRyYW5zbGF0aW9uLnkpXG4gICAgfTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IGNyb3NzTGluZUdyb3VwLCBheGlzR3JvdXAsIGdyaWRHcm91cCwgdHJhbnNsYXRpb24sIGdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIGdyaWRQYWRkaW5nLCBncmlkTGVuZ3RoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgdHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcih0cmFuc2xhdGlvbi54KTtcbiAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHRyYW5zbGF0aW9uLnkpO1xuICAgIGNyb3NzTGluZUdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgZ3JpZEdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgYXhpc0dyb3VwLmRhdHVtID0gdGhpcy5nZXRBeGlzVHJhbnNmb3JtKCk7XG4gICAgZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lKSA9PiB7XG4gICAgICBsaW5lLngxID0gZ3JpZFBhZGRpbmc7XG4gICAgICBsaW5lLngyID0gLXNpZGVGbGFnICogZ3JpZExlbmd0aCArIGdyaWRQYWRkaW5nO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcyhfcHJpbWFyeVRpY2tDb3VudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVuZXhwZWN0ZWQgY2FsbCB0byB1cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MoKSAtIGNoZWNrIGF4ZXMgY29uZmlndXJhdGlvbi5cIik7XG4gIH1cbiAgdXBkYXRlU2VsZWN0aW9ucyhsaW5lRGF0YSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgdGhpcy5saW5lTm9kZS5kYXR1bSA9IGxpbmVEYXRhO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICB0aGlzLmdyaWRMZW5ndGggPyBkYXRhIDogW10sXG4gICAgICAoZ3JvdXApID0+IGdyb3VwLmFwcGVuZChuZXcgTGluZSgpKSxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0udGlja0lkXG4gICAgKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgZGF0YSxcbiAgICAgIChncm91cCkgPT4gZ3JvdXAuYXBwZW5kQ2hpbGQobmV3IExpbmUoKSksXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZFxuICAgICk7XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBkYXRhLm1hcCgoZCkgPT4gdGhpcy5nZXRUaWNrTGFiZWxQcm9wcyhkLCBwYXJhbXMpKSxcbiAgICAgIChncm91cCkgPT4gZ3JvdXAuYXBwZW5kQ2hpbGQobmV3IFRleHQoKSksXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZFxuICAgICk7XG4gIH1cbiAgdXBkYXRlQXhpc0xpbmUoKSB7XG4gICAgY29uc3QgeyBsaW5lIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gbGluZS5lbmFibGVkID8gbGluZS53aWR0aCA6IDA7XG4gICAgdGhpcy5saW5lTm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHN0cm9rZTogbGluZS5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUdyaWRMaW5lcyhzaWRlRmxhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdyaWRMaW5lOiB7IHN0eWxlLCB3aWR0aCB9LFxuICAgICAgZ3JpZFBhZGRpbmcsXG4gICAgICBncmlkTGVuZ3RoXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGdyaWRMZW5ndGggPT09IDAgfHwgc3R5bGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lLCBfLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBzdHJva2UsIGxpbmVEYXNoIH0gPSBzdHlsZVtpbmRleCAlIHN0eWxlLmxlbmd0aF07XG4gICAgICBsaW5lLnNldFByb3BlcnRpZXMoe1xuICAgICAgICB4MTogZ3JpZFBhZGRpbmcsXG4gICAgICAgIHgyOiAtc2lkZUZsYWcgKiBncmlkTGVuZ3RoICsgZ3JpZFBhZGRpbmcsXG4gICAgICAgIGZpbGw6IHZvaWQgMCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogd2lkdGgsXG4gICAgICAgIGxpbmVEYXNoXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVMYWJlbHMoKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcztcbiAgICBpZiAoIWxhYmVsLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtLCBbXG4gICAgICAgIFwiZmlsbFwiLFxuICAgICAgICBcImZvbnRGYW1pbHlcIixcbiAgICAgICAgXCJmb250U2l6ZVwiLFxuICAgICAgICBcImZvbnRTdHlsZVwiLFxuICAgICAgICBcImZvbnRXZWlnaHRcIixcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwidGV4dEFsaWduXCIsXG4gICAgICAgIFwidGV4dEJhc2VsaW5lXCJcbiAgICAgIF0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVRpdGxlKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm90YXRpb24sIHRpdGxlLCBfdGl0bGVDYXB0aW9uLCBsaW5lTm9kZSwgdGlja0xpbmVHcm91cCwgdGlja0xhYmVsR3JvdXAgfSA9IHRoaXM7XG4gICAgbGV0IHNwYWNpbmcgPSAwO1xuICAgIGlmICh0aXRsZS5lbmFibGVkICYmIHBhcmFtcy5hbnlUaWNrVmlzaWJsZSkge1xuICAgICAgY29uc3QgdGlja0JCb3ggPSBHcm91cC5jb21wdXRlQkJveChbdGlja0xpbmVHcm91cCwgdGlja0xhYmVsR3JvdXAsIGxpbmVOb2RlXSk7XG4gICAgICBjb25zdCB0aWNrV2lkdGggPSByb3RhdGlvbiA9PT0gMCA/IHRpY2tCQm94LndpZHRoIDogdGlja0JCb3guaGVpZ2h0O1xuICAgICAgc3BhY2luZyArPSB0aWNrV2lkdGggKyAodGhpcy50aWNrTGFiZWxHcm91cC52aXNpYmxlID8gMCA6IHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xuICAgIH1cbiAgICB0aGlzLnNldFRpdGxlUHJvcHMoX3RpdGxlQ2FwdGlvbiwgeyBzcGFjaW5nIH0pO1xuICB9XG4gIC8vIEZvciBmb3JtYXR0aW5nIChuaWNlIHJvdW5kZWQpIHRpY2sgdmFsdWVzLlxuICBmb3JtYXRUaWNrKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cywgaW5kZXgpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0Rm9ybWF0dGVyKGluZGV4LCB0cnVlKShkYXR1bSwgZnJhY3Rpb25EaWdpdHMpKTtcbiAgfVxuICAvLyBGb3IgZm9ybWF0dGluZyBhcmJpdHJhcnkgdmFsdWVzIGJldHdlZW4gdGhlIHRpY2tzLlxuICBmb3JtYXREYXR1bShkYXR1bSkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRGb3JtYXR0ZXIoKShkYXR1bSkpO1xuICB9XG4gIGdldEZvcm1hdHRlcihpbmRleCA9IDAsIGlzVGlja0xhYmVsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEZvcm1hdHRlcixcbiAgICAgIGRhdHVtRm9ybWF0dGVyLFxuICAgICAgbW9kdWxlQ3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsYWJlbC5mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAoZGF0dW0sIGZyYWN0aW9uRGlnaXRzKSA9PiBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7IHZhbHVlOiBkYXR1bSwgaW5kZXgsIGZyYWN0aW9uRGlnaXRzIH0pID8/IGRhdHVtO1xuICAgIH0gZWxzZSBpZiAoIWlzVGlja0xhYmVsICYmIGRhdHVtRm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gKGRhdHVtKSA9PiBjYWxsYmFja0NhY2hlLmNhbGwoZGF0dW1Gb3JtYXR0ZXIsIGRhdHVtKSA/PyBTdHJpbmcoZGF0dW0pO1xuICAgIH0gZWxzZSBpZiAobGFiZWxGb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAoZGF0dW0pID0+IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbEZvcm1hdHRlciwgZGF0dW0pID8/IFN0cmluZyhkYXR1bSk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0dW0pID0+IFN0cmluZyhkYXR1bSk7XG4gIH1cbiAgZ2V0QkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzR3JvdXAuZ2V0QkJveCgpO1xuICB9XG4gIGdldFJlZ2lvbkJCb3hQcm92aWRlcigpIHtcbiAgICBjb25zdCB7IGF4aXNHcm91cCB9ID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xuICAgICAgICByZXR1cm4gYXhpc0dyb3VwLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlVHJhbnNmb3JtZWRSZWdpb25CQm94KCkge1xuICAgICAgICByZXR1cm4gYXhpc0dyb3VwLmNvbXB1dGVUcmFuc2Zvcm1lZFJlZ2lvbkJCb3goKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNHcm91cC52aXNpYmxlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaW5pdENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICBjcm9zc0xpbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGNyb3NzTGluZS5ncmlkTGVuZ3RoID0gdGhpcy5ncmlkTGVuZ3RoO1xuICB9XG4gIGlzQW55U2VyaWVzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kU2VyaWVzLnNvbWUoKHMpID0+IHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgfHwgcy5pc0VuYWJsZWQoKSk7XG4gIH1cbiAgY2xpcFRpY2tMaW5lcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwLnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgY2xpcEdyaWQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZ3JpZEdyb3VwLnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgY2FsY3VsYXRlUGFkZGluZyhtaW4sIG1heCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBNYXRoLmFicyh0aGlzLnJldmVyc2UgPyBtYXggOiBtaW4pICogMC4wMTtcbiAgICByZXR1cm4gW3BhZGRpbmcsIHBhZGRpbmddO1xuICB9XG4gIGdldFRpdGxlRm9ybWF0dGVyUGFyYW1zKCkge1xuICAgIGNvbnN0IGJvdW5kU2VyaWVzID0gdGhpcy5ib3VuZFNlcmllcy5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IG5leHQuZ2V0S2V5cyh0aGlzLmRpcmVjdGlvbik7XG4gICAgICBjb25zdCBuYW1lcyA9IG5leHQuZ2V0TmFtZXModGhpcy5kaXJlY3Rpb24pO1xuICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwga2V5cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGFjYy5wdXNoKHsga2V5OiBrZXlzW2lkeF0sIG5hbWU6IG5hbWVzW2lkeF0gfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbixcbiAgICAgIGJvdW5kU2VyaWVzLFxuICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLnRpdGxlPy50ZXh0XG4gICAgfTtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICByZXR1cm4geyBkb21haW46IFsuLi5kXSwgY2xpcHBlZDogZmFsc2UgfTtcbiAgfVxuICBnZXRMYXlvdXRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICByZWN0OiB0aGlzLmdldEJCb3goKSxcbiAgICAgIGdyaWRQYWRkaW5nOiB0aGlzLmdyaWRQYWRkaW5nLFxuICAgICAgc2VyaWVzQXJlYVBhZGRpbmc6IHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcsXG4gICAgICB0aWNrU2l6ZTogdGhpcy5nZXRUaWNrU2l6ZSgpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbixcbiAgICAgIGRvbWFpbjogdGhpcy5kYXRhRG9tYWluLmRvbWFpbixcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgLi4udGhpcy5sYXlvdXRcbiAgICB9O1xuICB9XG4gIGdldE1vZHVsZU1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXA7XG4gIH1cbiAgY3JlYXRlTW9kdWxlQ29udGV4dCgpIHtcbiAgICB0aGlzLmF4aXNDb250ZXh0ID8/ICh0aGlzLmF4aXNDb250ZXh0ID0gdGhpcy5jcmVhdGVBeGlzQ29udGV4dCgpKTtcbiAgICByZXR1cm4geyAuLi50aGlzLm1vZHVsZUN0eCwgcGFyZW50OiB0aGlzLmF4aXNDb250ZXh0IH07XG4gIH1cbiAgY3JlYXRlQXhpc0NvbnRleHQoKSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBheGlzSWQ6IHRoaXMuaWQsXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgY29udGludW91czogQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpLFxuICAgICAga2V5czogKCkgPT4gdGhpcy5ib3VuZFNlcmllcy5mbGF0TWFwKChzKSA9PiBzLmdldEtleXModGhpcy5kaXJlY3Rpb24pKSxcbiAgICAgIHNlcmllc0tleVByb3BlcnRpZXM6ICgpID0+IHRoaXMuYm91bmRTZXJpZXMucmVkdWNlKChrZXlzLCBzZXJpZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc2VyaWVzS2V5cyA9IHNlcmllcy5nZXRLZXlQcm9wZXJ0aWVzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgc2VyaWVzS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH0sIFtdKSxcbiAgICAgIHNjYWxlVmFsdWVGb3JtYXR0ZXI6IChzcGVjaWZpZXIpID0+IHRoaXMuZ2V0U2NhbGVWYWx1ZUZvcm1hdHRlcihzcGVjaWZpZXIpLFxuICAgICAgc2NhbGVCYW5kd2lkdGg6ICgpID0+IHNjYWxlMi5iYW5kd2lkdGggPz8gMCxcbiAgICAgIHNjYWxlRG9tYWluOiAoKSA9PiBzY2FsZTIuZ2V0RG9tYWluPy4oKSxcbiAgICAgIHNjYWxlQ29udmVydDogKHZhbCkgPT4gc2NhbGUyLmNvbnZlcnQodmFsKSxcbiAgICAgIHNjYWxlSW52ZXJ0OiBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikgPyAodmFsKSA9PiBzY2FsZTIuaW52ZXJ0TmVhcmVzdD8uKHZhbCkgOiAodmFsKSA9PiBzY2FsZTIuaW52ZXJ0Py4odmFsKSxcbiAgICAgIHNjYWxlSW52ZXJ0TmVhcmVzdDogKHZhbCkgPT4gc2NhbGUyLmludmVydE5lYXJlc3Q/Lih2YWwpLFxuICAgICAgYXR0YWNoTGFiZWw6IChub2RlKSA9PiB0aGlzLmF0dGFjaExhYmVsKG5vZGUpLFxuICAgICAgaW5SYW5nZTogKHgsIHRvbGVyYW5jZSkgPT4gdGhpcy5pblJhbmdlKHgsIHRvbGVyYW5jZSlcbiAgICB9O1xuICB9XG4gIGdldFNjYWxlVmFsdWVGb3JtYXR0ZXIoZm9ybWF0KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmIChmb3JtYXQgJiYgc2NhbGUyICYmIHNjYWxlMi50aWNrRm9ybWF0KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2NhbGUyLnRpY2tGb3JtYXQoeyBzcGVjaWZpZXI6IGZvcm1hdCB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUgZm9ybWF0IHN0cmluZyAke2Zvcm1hdH0gaXMgaW52YWxpZCwgaWdub3JpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlcigpO1xuICB9XG4gIGFuaW1hdGVSZWFkeVVwZGF0ZShkaWZmMikge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5tb2R1bGVDdHg7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ3R4ID0gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KHRoaXMpO1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zKHNlbGVjdGlvbkN0eCk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiYXhpcy1ncm91cFwiLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5heGlzR3JvdXBdLCBmbnMuZ3JvdXApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImxpbmVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMubGluZU5vZGVdLCBmbnMubGluZSk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibGluZS1wYXRoc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbl0sXG4gICAgICBmbnMudGljayxcbiAgICAgIChfLCBkKSA9PiBkLnRpY2tJZCxcbiAgICAgIGRpZmYyXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJ0aWNrLWxhYmVsc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSxcbiAgICAgIGZucy5sYWJlbCxcbiAgICAgIChfLCBkKSA9PiBkLnRpY2tJZCxcbiAgICAgIGRpZmYyXG4gICAgKTtcbiAgfVxuICByZXNldFNlbGVjdGlvbk5vZGVzKCkge1xuICAgIGNvbnN0IHsgZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xhYmVsR3JvdXBTZWxlY3Rpb24sIGxpbmVOb2RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlbGVjdGlvbkN0eCA9IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCh0aGlzKTtcbiAgICByZXNldE1vdGlvbihbdGhpcy5heGlzR3JvdXBdLCByZXNldEF4aXNHcm91cEZuKCkpO1xuICAgIHJlc2V0TW90aW9uKFtncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aWNrTGluZUdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzU2VsZWN0aW9uRm4oc2VsZWN0aW9uQ3R4KSk7XG4gICAgcmVzZXRNb3Rpb24oW3RpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbigpKTtcbiAgICByZXNldE1vdGlvbihbbGluZU5vZGVdLCByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4oKSk7XG4gIH1cbiAgY2FsY3VsYXRlVXBkYXRlRGlmZihwcmV2aW91cywgdGlja0RhdGEpIHtcbiAgICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgcmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdGlja01hcCA9IHt9O1xuICAgIGNvbnN0IHRpY2tDb3VudCA9IE1hdGgubWF4KHByZXZpb3VzLmxlbmd0aCwgdGlja0RhdGEudGlja3MubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0aWNrRGF0dW0gPSB0aWNrRGF0YS50aWNrc1tpXTtcbiAgICAgIGNvbnN0IHByZXYgPSBwcmV2aW91c1tpXTtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrRGF0dW0/LnRpY2tJZDtcbiAgICAgIHRpY2tNYXBbdGljayA/PyBwcmV2XSA9IHRpY2tEYXR1bTtcbiAgICAgIGlmIChwcmV2ID09PSB0aWNrKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWQuaGFzKHRpY2spKSB7XG4gICAgICAgIHJlbW92ZWQuZGVsZXRlKHRpY2spO1xuICAgICAgfSBlbHNlIGlmICh0aWNrKSB7XG4gICAgICAgIGFkZGVkLmFkZCh0aWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRlZC5oYXMocHJldikpIHtcbiAgICAgICAgYWRkZWQuZGVsZXRlKHByZXYpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICAgIHJlbW92ZWQuYWRkKHByZXYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjaGFuZ2VkOiBhZGRlZC5zaXplID4gMCB8fCByZW1vdmVkLnNpemUgPiAwLCBhZGRlZCwgcmVtb3ZlZCB9O1xuICB9XG4gIGlzUmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZTtcbiAgfVxufTtcbl9BeGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IDUwO1xuX0F4aXMuQ3Jvc3NMaW5lQ29uc3RydWN0b3IgPSBDYXJ0ZXNpYW5Dcm9zc0xpbmU7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcIm5pY2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcInJldmVyc2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkdfQVJSQVkpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwia2V5c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0F4aXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCwgdmFsdWUsIG9sZFZhbHVlKSA9PiB0YXJnZXQub25HcmlkTGVuZ3RoQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwiZ3JpZExlbmd0aFwiLCAyKTtcbnZhciBBeGlzID0gX0F4aXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvY2FydGVzaWFuQXhpc0xhYmVsLnRzXG52YXIgQ2FydGVzaWFuQXhpc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBBeGlzTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuYXV0b1JvdGF0ZUFuZ2xlID0gMzM1O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJhdXRvUm90YXRlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFKVxuXSwgQ2FydGVzaWFuQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJhdXRvUm90YXRlQW5nbGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvY2FydGVzaWFuQXhpcy50c1xudmFyIF9DYXJ0ZXNpYW5BeGlzID0gY2xhc3MgX0NhcnRlc2lhbkF4aXMgZXh0ZW5kcyBBeGlzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnRoaWNrbmVzcyA9IDA7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0NhcnRlc2lhbkF4aXM7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gW1widG9wXCIsIFwiYm90dG9tXCJdLmluY2x1ZGVzKHRoaXMucG9zaXRpb24pID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gIH1cbiAgdXBkYXRlRGlyZWN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gLTkwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IC05MDtcbiAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzQ29udGV4dCkge1xuICAgICAgdGhpcy5heGlzQ29udGV4dC5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLmF4aXNDb250ZXh0LmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgfVxuICB1cGRhdGUocHJpbWFyeVRpY2tDb3VudCwgYW5pbWF0ZWQpIHtcbiAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgIHJldHVybiBzdXBlci51cGRhdGUocHJpbWFyeVRpY2tDb3VudCwgYW5pbWF0ZWQpO1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dChwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gc3VwZXIuY2FsY3VsYXRlTGF5b3V0KHByaW1hcnlUaWNrQ291bnQpO1xuICB9XG4gIGNyZWF0ZUF4aXNDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5jcmVhdGVBeGlzQ29udGV4dCgpLFxuICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb25cbiAgICB9O1xuICB9XG4gIGNyZWF0ZUxhYmVsKCkge1xuICAgIHJldHVybiBuZXcgQ2FydGVzaWFuQXhpc0xhYmVsKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBfQ2FydGVzaWFuQXhpcy5wcm90b3R5cGUsIFwidGhpY2tuZXNzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJT04pXG5dLCBfQ2FydGVzaWFuQXhpcy5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG52YXIgQ2FydGVzaWFuQXhpcyA9IF9DYXJ0ZXNpYW5BeGlzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhdGVnb3J5QXhpcy50c1xudmFyIENhdGVnb3J5QXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCwgc2NhbGUyID0gbmV3IEJhbmRTY2FsZSgpKSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBzY2FsZTIpO1xuICAgIHRoaXMuX3BhZGRpbmdPdmVycmlkZUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmdyb3VwUGFkZGluZ0lubmVyID0gMC4xO1xuICAgIHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPSB0cnVlO1xuICB9XG4gIHNldCBwYWRkaW5nSW5uZXIodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlLnBhZGRpbmdJbm5lciA9IHZhbHVlO1xuICB9XG4gIGdldCBwYWRkaW5nSW5uZXIoKSB7XG4gICAgdGhpcy5fcGFkZGluZ092ZXJyaWRlRW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUucGFkZGluZ0lubmVyO1xuICB9XG4gIHNldCBwYWRkaW5nT3V0ZXIodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlLnBhZGRpbmdPdXRlciA9IHZhbHVlO1xuICB9XG4gIGdldCBwYWRkaW5nT3V0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUucGFkZGluZ091dGVyO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGNvbnN0IGRvbWFpbiA9IFtdO1xuICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB2IG9mIGQpIHtcbiAgICAgIGNvbnN0IGtleSA9IHYgaW5zdGFuY2VvZiBEYXRlID8gdi5nZXRUaW1lKCkgOiB2O1xuICAgICAgaWYgKCF1bmlxdWVWYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgdW5pcXVlVmFsdWVzLmFkZChrZXkpO1xuICAgICAgICBkb21haW4ucHVzaCh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tYWluLCBjbGlwcGVkOiBmYWxzZSB9O1xuICB9XG4gIGNhbGN1bGF0ZURvbWFpbigpIHtcbiAgICBpZiAoIXRoaXMuX3BhZGRpbmdPdmVycmlkZUVuYWJsZWQpIHtcbiAgICAgIGxldCBwYWRkaW5nSW5uZXIgPSBJbmZpbml0eTtcbiAgICAgIGxldCBwYWRkaW5nT3V0ZXIgPSAtSW5maW5pdHk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5ib3VuZFNlcmllcykge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gcy5nZXRCYW5kU2NhbGVQYWRkaW5nPy4oKTtcbiAgICAgICAgaWYgKHBhZGRpbmcgPT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcGFkZGluZ0lubmVyID0gTWF0aC5taW4ocGFkZGluZ0lubmVyLCBwYWRkaW5nLmlubmVyKTtcbiAgICAgICAgcGFkZGluZ091dGVyID0gTWF0aC5tYXgocGFkZGluZ091dGVyLCBwYWRkaW5nLm91dGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NhbGUucGFkZGluZ0lubmVyID0gTnVtYmVyLmlzRmluaXRlKHBhZGRpbmdJbm5lcikgPyBwYWRkaW5nSW5uZXIgOiAwO1xuICAgICAgdGhpcy5zY2FsZS5wYWRkaW5nT3V0ZXIgPSBOdW1iZXIuaXNGaW5pdGUocGFkZGluZ091dGVyKSA/IHBhZGRpbmdPdXRlciA6IDA7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5jYWxjdWxhdGVEb21haW4oKTtcbiAgfVxufTtcbkNhdGVnb3J5QXhpcy5jbGFzc05hbWUgPSBcIkNhdGVnb3J5QXhpc1wiO1xuQ2F0ZWdvcnlBeGlzLnR5cGUgPSBcImNhdGVnb3J5XCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIENhdGVnb3J5QXhpcy5wcm90b3R5cGUsIFwiZ3JvdXBQYWRkaW5nSW5uZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvdHJlZS50c1xudmFyIFRyZWVOb2RlID0gY2xhc3Mge1xuICAvLyBjdXJyZW50IG51bWJlciBpbiBzaWJsaW5nIGdyb3VwIChpbmRleClcbiAgY29uc3RydWN0b3IobGFiZWwgPSBcIlwiLCBwYXJlbnQsIG51bWJlcjIgPSAwKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuc3VidHJlZUxlZnQgPSBOYU47XG4gICAgdGhpcy5zdWJ0cmVlUmlnaHQgPSBOYU47XG4gICAgdGhpcy5zY3JlZW5YID0gMDtcbiAgICB0aGlzLnNjcmVlblkgPSAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmxlYWZDb3VudCA9IDA7XG4gICAgdGhpcy5wcmVsaW0gPSAwO1xuICAgIHRoaXMubW9kID0gMDtcbiAgICB0aGlzLmFuY2VzdG9yID0gdGhpcztcbiAgICB0aGlzLmNoYW5nZSA9IDA7XG4gICAgdGhpcy5zaGlmdCA9IDA7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICB0aGlzLm51bWJlciA9IG51bWJlcjI7XG4gIH1cbiAgZ2V0TGVmdFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyID4gMCAmJiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuW3RoaXMubnVtYmVyIC0gMV0gOiB2b2lkIDA7XG4gIH1cbiAgZ2V0TGVmdG1vc3RTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm51bWJlciA+IDAgJiYgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgfVxuICAvLyB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSwgcmV0dXJuIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXJcbiAgbmV4dExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuWzBdIDogdGhpcy50aHJlYWQ7XG4gIH1cbiAgLy8gdHJhdmVyc2UgdGhlIHJpZ2h0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91clxuICBuZXh0UmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB0aGlzLnRocmVhZDtcbiAgfVxuICBnZXRTaWJsaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlbi5maWx0ZXIoKF8sIGkpID0+IGkgIT09IHRoaXMubnVtYmVyKSA6IFtdO1xuICB9XG59O1xuZnVuY3Rpb24gdGlja3NUb1RyZWUodGlja3MsIHBhZDIgPSB0cnVlKSB7XG4gIGNvbnN0IHJvb3QgPSBuZXcgVHJlZU5vZGUoKTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgaWYgKHBhZDIpIHtcbiAgICB0aWNrcy5mb3JFYWNoKCh0aWNrKSA9PiBkZXB0aCA9IE1hdGgubWF4KGRlcHRoLCB0aWNrLmxhYmVscy5sZW5ndGgpKTtcbiAgfVxuICB0aWNrcy5mb3JFYWNoKCh0aWNrKSA9PiB7XG4gICAgaWYgKHBhZDIpIHtcbiAgICAgIHdoaWxlICh0aWNrLmxhYmVscy5sZW5ndGggPCBkZXB0aCkge1xuICAgICAgICB0aWNrLmxhYmVscy51bnNoaWZ0KFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRUaWNrKHJvb3QsIHRpY2spO1xuICB9KTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBpbnNlcnRUaWNrKHJvb3QsIHRpY2spIHtcbiAgY29uc3QgcGF0aFBhcnRzID0gdGljay5sYWJlbHMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGNvbnN0IGxhc3RQYXJ0SW5kZXggPSBwYXRoUGFydHMubGVuZ3RoIC0gMTtcbiAgcGF0aFBhcnRzLmZvckVhY2goKHBhdGhQYXJ0LCBwYXJ0SW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW47XG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IGNoaWxkLmxhYmVsID09PSBwYXRoUGFydCk7XG4gICAgY29uc3QgaXNOb3RMZWFmID0gcGFydEluZGV4ICE9PSBsYXN0UGFydEluZGV4O1xuICAgIGlmIChleGlzdGluZ05vZGUgJiYgaXNOb3RMZWFmKSB7XG4gICAgICByb290ID0gZXhpc3RpbmdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gbmV3IFRyZWVOb2RlKHBhdGhQYXJ0LCByb290KTtcbiAgICAgIG5vZGUubnVtYmVyID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgIGlmIChpc05vdExlYWYpIHtcbiAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHdtLCB3cCwgc2hpZnQpIHtcbiAgY29uc3Qgc3VidHJlZXMgPSB3cC5udW1iZXIgLSB3bS5udW1iZXI7XG4gIGNvbnN0IHJhdGlvMiA9IHNoaWZ0IC8gc3VidHJlZXM7XG4gIHdwLmNoYW5nZSAtPSByYXRpbzI7XG4gIHdwLnNoaWZ0ICs9IHNoaWZ0O1xuICB3bS5jaGFuZ2UgKz0gcmF0aW8yO1xuICB3cC5wcmVsaW0gKz0gc2hpZnQ7XG4gIHdwLm1vZCArPSBzaGlmdDtcbn1cbmZ1bmN0aW9uIGFuY2VzdG9yKHZpbSwgdiwgZGVmYXVsdEFuY2VzdG9yKSB7XG4gIHJldHVybiB2LmdldFNpYmxpbmdzKCkuaW5kZXhPZih2aW0uYW5jZXN0b3IpID49IDAgPyB2aW0uYW5jZXN0b3IgOiBkZWZhdWx0QW5jZXN0b3I7XG59XG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBsZXQgc2hpZnQgPSAwO1xuICAgIGxldCBjaGFuZ2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgdy5wcmVsaW0gKz0gc2hpZnQ7XG4gICAgICB3Lm1vZCArPSBzaGlmdDtcbiAgICAgIGNoYW5nZSArPSB3LmNoYW5nZTtcbiAgICAgIHNoaWZ0ICs9IHcuc2hpZnQgKyBjaGFuZ2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBvcnRpb24odiwgZGVmYXVsdEFuY2VzdG9yLCBkaXN0YW5jZTMpIHtcbiAgY29uc3QgdyA9IHYuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgaWYgKHcpIHtcbiAgICBsZXQgdm9wID0gdjtcbiAgICBsZXQgdmlwID0gdjtcbiAgICBsZXQgdmltID0gdztcbiAgICBsZXQgdm9tID0gdmlwLmdldExlZnRtb3N0U2libGluZygpO1xuICAgIGxldCBzaXAgPSB2aXAubW9kO1xuICAgIGxldCBzb3AgPSB2b3AubW9kO1xuICAgIGxldCBzaW0gPSB2aW0ubW9kO1xuICAgIGxldCBzb20gPSB2b20ubW9kO1xuICAgIHdoaWxlICh2aW0ubmV4dFJpZ2h0KCkgJiYgdmlwLm5leHRMZWZ0KCkpIHtcbiAgICAgIHZpbSA9IHZpbS5uZXh0UmlnaHQoKTtcbiAgICAgIHZpcCA9IHZpcC5uZXh0TGVmdCgpO1xuICAgICAgdm9tID0gdm9tLm5leHRMZWZ0KCk7XG4gICAgICB2b3AgPSB2b3AubmV4dFJpZ2h0KCk7XG4gICAgICB2b3AuYW5jZXN0b3IgPSB2O1xuICAgICAgY29uc3Qgc2hpZnQgPSB2aW0ucHJlbGltICsgc2ltIC0gKHZpcC5wcmVsaW0gKyBzaXApICsgZGlzdGFuY2UzO1xuICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICBtb3ZlU3VidHJlZShhbmNlc3Rvcih2aW0sIHYsIGRlZmF1bHRBbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICB9XG4gICAgICBzaW0gKz0gdmltLm1vZDtcbiAgICAgIHNpcCArPSB2aXAubW9kO1xuICAgICAgc29tICs9IHZvbS5tb2Q7XG4gICAgICBzb3AgKz0gdm9wLm1vZDtcbiAgICB9XG4gICAgaWYgKHZpbS5uZXh0UmlnaHQoKSAmJiAhdm9wLm5leHRSaWdodCgpKSB7XG4gICAgICB2b3AudGhyZWFkID0gdmltLm5leHRSaWdodCgpO1xuICAgICAgdm9wLm1vZCArPSBzaW0gLSBzb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2aXAubmV4dExlZnQoKSAmJiAhdm9tLm5leHRMZWZ0KCkpIHtcbiAgICAgICAgdm9tLnRocmVhZCA9IHZpcC5uZXh0TGVmdCgpO1xuICAgICAgICB2b20ubW9kICs9IHNpcCAtIHNvbTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRBbmNlc3RvciA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0QW5jZXN0b3I7XG59XG5mdW5jdGlvbiBmaXJzdFdhbGsobm9kZSwgZGlzdGFuY2UzKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGxldCBkZWZhdWx0QW5jZXN0b3IgPSBjaGlsZHJlblswXTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgZmlyc3RXYWxrKGNoaWxkLCBkaXN0YW5jZTMpO1xuICAgICAgZGVmYXVsdEFuY2VzdG9yID0gYXBwb3J0aW9uKGNoaWxkLCBkZWZhdWx0QW5jZXN0b3IsIGRpc3RhbmNlMyk7XG4gICAgfSk7XG4gICAgZXhlY3V0ZVNoaWZ0cyhub2RlKTtcbiAgICBjb25zdCBtaWRwb2ludCA9IChjaGlsZHJlblswXS5wcmVsaW0gKyBjaGlsZHJlbi5hdCgtMSkucHJlbGltKSAvIDI7XG4gICAgY29uc3QgbGVmdFNpYmxpbmcgPSBub2RlLmdldExlZnRTaWJsaW5nKCk7XG4gICAgaWYgKGxlZnRTaWJsaW5nKSB7XG4gICAgICBub2RlLnByZWxpbSA9IGxlZnRTaWJsaW5nLnByZWxpbSArIGRpc3RhbmNlMztcbiAgICAgIG5vZGUubW9kID0gbm9kZS5wcmVsaW0gLSBtaWRwb2ludDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcmVsaW0gPSBtaWRwb2ludDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVmdFNpYmxpbmcgPSBub2RlLmdldExlZnRTaWJsaW5nKCk7XG4gICAgbm9kZS5wcmVsaW0gPSBsZWZ0U2libGluZyA/IGxlZnRTaWJsaW5nLnByZWxpbSArIGRpc3RhbmNlMyA6IDA7XG4gIH1cbn1cbnZhciBEaW1lbnNpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRvcCA9IEluZmluaXR5O1xuICAgIHRoaXMucmlnaHQgPSAtSW5maW5pdHk7XG4gICAgdGhpcy5ib3R0b20gPSAtSW5maW5pdHk7XG4gICAgdGhpcy5sZWZ0ID0gSW5maW5pdHk7XG4gIH1cbiAgdXBkYXRlKG5vZGUsIHh5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB4eShub2RlKTtcbiAgICBpZiAoeCA+IHRoaXMucmlnaHQpIHtcbiAgICAgIHRoaXMucmlnaHQgPSB4O1xuICAgIH1cbiAgICBpZiAoeCA8IHRoaXMubGVmdCkge1xuICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICB9XG4gICAgaWYgKHkgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgdGhpcy5ib3R0b20gPSB5O1xuICAgIH1cbiAgICBpZiAoeSA8IHRoaXMudG9wKSB7XG4gICAgICB0aGlzLnRvcCA9IHk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2Vjb25kV2Fsayh2LCBtLCBsYXlvdXQpIHtcbiAgdi54ID0gdi5wcmVsaW0gKyBtO1xuICB2LnkgPSB2LmRlcHRoO1xuICBsYXlvdXQudXBkYXRlKHYpO1xuICB2LmNoaWxkcmVuLmZvckVhY2goKHcpID0+IHNlY29uZFdhbGsodywgbSArIHYubW9kLCBsYXlvdXQpKTtcbn1cbmZ1bmN0aW9uIHRoaXJkV2Fsayh2KSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgbGV0IGxlYWZDb3VudCA9IDA7XG4gIGNoaWxkcmVuLmZvckVhY2goKHcpID0+IHtcbiAgICB0aGlyZFdhbGsodyk7XG4gICAgaWYgKHcuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBsZWFmQ291bnQgKz0gdy5sZWFmQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYWZDb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHYubGVhZkNvdW50ID0gbGVhZkNvdW50O1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdi5zdWJ0cmVlTGVmdCA9IGNoaWxkcmVuWzBdLnN1YnRyZWVMZWZ0O1xuICAgIHYuc3VidHJlZVJpZ2h0ID0gY2hpbGRyZW5bdi5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdWJ0cmVlUmlnaHQ7XG4gICAgdi54ID0gKHYuc3VidHJlZUxlZnQgKyB2LnN1YnRyZWVSaWdodCkgLyAyO1xuICB9IGVsc2Uge1xuICAgIHYuc3VidHJlZUxlZnQgPSB2Lng7XG4gICAgdi5zdWJ0cmVlUmlnaHQgPSB2Lng7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyZWVMYXlvdXQocm9vdCkge1xuICBjb25zdCBsYXlvdXQgPSBuZXcgVHJlZUxheW91dCgpO1xuICBmaXJzdFdhbGsocm9vdCwgMSk7XG4gIHNlY29uZFdhbGsocm9vdCwgLXJvb3QucHJlbGltLCBsYXlvdXQpO1xuICB0aGlyZFdhbGsocm9vdCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG52YXIgVHJlZUxheW91dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmxlYWZDb3VudCA9IDA7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIC8vIE9uZSBtaWdodCB3YW50IHRvIHByb2Nlc3MgbGVhZiBub2RlcyBzZXBhcmF0ZWx5IGZyb20gdGhlIHJlc3Qgb2YgdGhlIHRyZWUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHBvc2l0aW9uIGxhYmVscyBjb3JyZXNwb25kaW5nIHRvIGxlYWZzIHZlcnRpY2FsbHksIHJhdGhlciB0aGFuIGhvcml6b250YWxseS5cbiAgICB0aGlzLmxlYWZOb2RlcyA9IFtdO1xuICAgIHRoaXMubm9uTGVhZk5vZGVzID0gW107XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gIH1cbiAgdXBkYXRlKG5vZGUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMudXBkYXRlKG5vZGUsIChuKSA9PiAoeyB4OiBuLngsIHk6IG4ueSB9KSk7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aGlzLm5vbkxlYWZOb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlYWZDb3VudCsrO1xuICAgICAgdGhpcy5sZWFmTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZGVwdGggPiB0aGlzLmRlcHRoKSB7XG4gICAgICB0aGlzLmRlcHRoID0gbm9kZS5kZXB0aDtcbiAgICB9XG4gICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBzaGlmdFggPSAwLCBzaGlmdFkgPSAwLCBmbGlwWCA9IGZhbHNlKSB7XG4gICAgY29uc3QgeFN0ZXBzID0gdGhpcy5sZWFmQ291bnQgLSAxO1xuICAgIGNvbnN0IHlTdGVwcyA9IHRoaXMuZGVwdGg7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICBsZXQgc2NhbGluZ1ggPSAxO1xuICAgIGxldCBzY2FsaW5nWSA9IDE7XG4gICAgaWYgKHdpZHRoID4gMCAmJiB4U3RlcHMpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nU3BhY2luZ1ggPSAoZGltZW5zaW9ucy5yaWdodCAtIGRpbWVuc2lvbnMubGVmdCkgLyB4U3RlcHM7XG4gICAgICBjb25zdCBkZXNpcmVkU3BhY2luZ1ggPSB3aWR0aCAvIHhTdGVwcztcbiAgICAgIHNjYWxpbmdYID0gZGVzaXJlZFNwYWNpbmdYIC8gZXhpc3RpbmdTcGFjaW5nWDtcbiAgICAgIGlmIChmbGlwWCkge1xuICAgICAgICBzY2FsaW5nWCA9IC1zY2FsaW5nWDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgeVN0ZXBzKSB7XG4gICAgICBjb25zdCBleGlzdGluZ1NwYWNpbmdZID0gKGRpbWVuc2lvbnMuYm90dG9tIC0gZGltZW5zaW9ucy50b3ApIC8geVN0ZXBzO1xuICAgICAgY29uc3QgZGVzaXJlZFNwYWNpbmdZID0gaGVpZ2h0IC8geVN0ZXBzO1xuICAgICAgc2NhbGluZ1kgPSBkZXNpcmVkU3BhY2luZ1kgLyBleGlzdGluZ1NwYWNpbmdZO1xuICAgIH1cbiAgICBjb25zdCBzY3JlZW5EaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuc2NyZWVuWCA9IG5vZGUueCAqIHNjYWxpbmdYO1xuICAgICAgbm9kZS5zY3JlZW5ZID0gbm9kZS55ICogc2NhbGluZ1k7XG4gICAgICBzY3JlZW5EaW1lbnNpb25zLnVwZGF0ZShub2RlLCAobikgPT4gKHsgeDogbi5zY3JlZW5YLCB5OiBuLnNjcmVlblkgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9mZnNldFggPSAtc2NyZWVuRGltZW5zaW9ucy5sZWZ0O1xuICAgIGNvbnN0IG9mZnNldFkgPSAtc2NyZWVuRGltZW5zaW9ucy50b3A7XG4gICAgdGhpcy5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLnNjcmVlblggKz0gb2Zmc2V0WCArIHNoaWZ0WDtcbiAgICAgIG5vZGUuc2NyZWVuWSArPSBvZmZzZXRZICsgc2hpZnRZO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2dyb3VwZWRDYXRlZ29yeUF4aXMudHNcbnZhciBHcm91cGVkQ2F0ZWdvcnlBeGlzTGFiZWwgPSBjbGFzcyBleHRlbmRzIEF4aXNMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ncmlkID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgR3JvdXBlZENhdGVnb3J5QXhpc0xhYmVsLnByb3RvdHlwZSwgXCJncmlkXCIsIDIpO1xudmFyIEdyb3VwZWRDYXRlZ29yeUF4aXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBjb25zdCBzY2FsZTIgPSBuZXcgQmFuZFNjYWxlKCk7XG4gICAgc2NhbGUyLnBhZGRpbmdPdXRlciA9IDAuMTtcbiAgICBzY2FsZTIucGFkZGluZ0lubmVyID0gc2NhbGUyLnBhZGRpbmdPdXRlciAqIDI7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBzY2FsZTIpO1xuICAgIC8vIExhYmVsIHNjYWxlIChsYWJlbHMgYXJlIHBvc2l0aW9uZWQgYmV0d2VlbiB0aWNrcywgdGljayBjb3VudCA9IGxhYmVsIGNvdW50ICsgMSkuXG4gICAgLy8gV2UgZG9uJ3QgY2FsbCBpcyBgbGFiZWxTY2FsZWAgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgYXhlcy5cbiAgICB0aGlzLnRpY2tTY2FsZSA9IG5ldyBCYW5kU2NhbGUoKTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgQXhpc0xpbmUoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEdyb3VwZWRDYXRlZ29yeUF4aXNMYWJlbCgpO1xuICAgIHRoaXMubGFiZWxDb2xvciA9IFwicmdiYSg4NywgODcsIDg3LCAxKVwiO1xuICAgIHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPSB0cnVlO1xuICAgIGNvbnN0IHsgdGlja0xpbmVHcm91cCwgdGlja0xhYmVsR3JvdXAsIGdyaWRMaW5lR3JvdXAsIHRpY2tTY2FsZSB9ID0gdGhpcztcbiAgICB0aWNrU2NhbGUucGFkZGluZ0lubmVyID0gMTtcbiAgICB0aWNrU2NhbGUucGFkZGluZ091dGVyID0gMDtcbiAgICB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChncmlkTGluZUdyb3VwLCBMaW5lKTtcbiAgICB0aGlzLmF4aXNMaW5lU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aWNrTGluZUdyb3VwLCBMaW5lKTtcbiAgICB0aGlzLnNlcGFyYXRvclNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGlja0xpbmVHcm91cCwgTGluZSk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGlja0xhYmVsR3JvdXAsIFRleHQpO1xuICAgIHRoaXMubGluZU5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIHVwZGF0ZVJhbmdlKCkge1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJyLCB2aXNpYmxlUmFuZ2U6IHZyLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNwYW4gPSAocnJbMV0gLSByclswXSkgLyAodnJbMV0gLSB2clswXSk7XG4gICAgY29uc3Qgc2hpZnQgPSBzcGFuICogdnJbMF07XG4gICAgY29uc3Qgc3RhcnQgPSByclswXSAtIHNoaWZ0O1xuICAgIHRoaXMudGlja1NjYWxlLnJhbmdlID0gc2NhbGUyLnJhbmdlID0gW3N0YXJ0LCBzdGFydCArIHNwYW5dO1xuICAgIHRoaXMucmVzaXplVGlja1RyZWUoKTtcbiAgfVxuICByZXNpemVUaWNrVHJlZSgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zY2FsZTtcbiAgICBjb25zdCByYW5nZTMgPSBzLmRvbWFpbi5sZW5ndGggPyBbcy5jb252ZXJ0KHMuZG9tYWluWzBdKSwgcy5jb252ZXJ0KHMuZG9tYWluW3MuZG9tYWluLmxlbmd0aCAtIDFdKV0gOiBzLnJhbmdlO1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMudGlja1RyZWVMYXlvdXQ7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBsYXlvdXQucmVzaXplKFxuICAgICAgICBNYXRoLmFicyhyYW5nZTNbMV0gLSByYW5nZTNbMF0pLFxuICAgICAgICBsYXlvdXQuZGVwdGggKiBsaW5lSGVpZ2h0LFxuICAgICAgICAoTWF0aC5taW4ocmFuZ2UzWzBdLCByYW5nZTNbMV0pIHx8IDApICsgKHMuYmFuZHdpZHRoID8/IDApIC8gMixcbiAgICAgICAgLWxheW91dC5kZXB0aCAqIGxpbmVIZWlnaHQsXG4gICAgICAgIHJhbmdlM1sxXSAtIHJhbmdlM1swXSA8IDBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGdldCBsaW5lSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsLmZvbnRTaXplICogMS41O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBncmlkLiBUaGUgZ3JpZCBpcyBvbmx5IHZpc2libGUgaW4gY2FzZSBvZiBhIG5vbi16ZXJvIHZhbHVlLlxuICAgKi9cbiAgb25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5jbGVhcigpO1xuICB9XG4gIGNhbGN1bGF0ZURvbWFpbigpIHtcbiAgICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gdGhpcztcbiAgICBsZXQgaXNOdW1lcmljWCA9IG51bGw7XG4gICAgY29uc3QgZmxhdERvbWFpbnMgPSB0aGlzLmJvdW5kU2VyaWVzLmZpbHRlcigocykgPT4gcy52aXNpYmxlKS5mbGF0TWFwKChzZXJpZXMpID0+IHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8gfHwgaXNOdW1lcmljWCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzLmdldERvbWFpbihkaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtZXJpY1ggPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZG9tYWluMiA9IHNlcmllcy5nZXREb21haW4oZGlyZWN0aW9uKTtcbiAgICAgICAgaXNOdW1lcmljWCA9IGlzTnVtYmVyKGRvbWFpbjJbMF0pO1xuICAgICAgICByZXR1cm4gZG9tYWluMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgICB0aGlzLnNldERvbWFpbihleHRlbnQoZmxhdERvbWFpbnMpID8/IHVuaXF1ZShmbGF0RG9tYWlucykpO1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSB0aGlzLmRhdGFEb21haW47XG4gICAgdGhpcy50aWNrVHJlZUxheW91dCA9IHRyZWVMYXlvdXQodGlja3NUb1RyZWUoZG9tYWluKSk7XG4gICAgdGhpcy50aWNrU2NhbGUuZG9tYWluID0gZG9tYWluLmNvbmNhdChcIlwiKTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tUcmVlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMvcmVtb3Zlcy91cGRhdGVzIHRoZSBzY2VuZSBncmFwaCBub2RlcyB0aGF0IGNvbnN0aXR1dGUgdGhlIGF4aXMuXG4gICAqIFN1cHBvc2VkIHRvIGJlIGNhbGxlZCBfbWFudWFsbHlfIGFmdGVyIGNoYW5naW5nIF9hbnlfIG9mIHRoZSBheGlzIHByb3BlcnRpZXMuXG4gICAqIFRoaXMgYWxsb3dzIHRvIGJ1bGsgc2V0IGF4aXMgcHJvcGVydGllcyBiZWZvcmUgdXBkYXRpbmcgdGhlIG5vZGVzLlxuICAgKiBUaGUgbm9kZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBtZXRob2QgYXJlIHJlbmRlcmVkIG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICogV2UgY291bGQgc2NoZWR1bGUgdGhpcyBtZXRob2QgY2FsbCBhdXRvbWF0aWNhbGx5IG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgKiB3aGVuIGFueSBvZiB0aGUgYXhpcyBwcm9wZXJ0aWVzIGNoYW5nZSAodGhlIHdheSB3ZSBkbyB3aGVuIHByb3BlcnRpZXMgb2Ygc2NlbmUgZ3JhcGgnc1xuICAgKiBub2RlcyBjaGFuZ2UpLCBidXQgdGhpcyB3aWxsIG1lYW4gdGhhdCB3ZSBmaXJzdCB3YWl0IGZvciB0aGUgbmV4dCBhbmltYXRpb25cbiAgICogZnJhbWUgdG8gbWFrZSBjaGFuZ2VzIHRvIHRoZSBub2RlcyBvZiB0aGUgYXhpcywgdGhlbiB3YWl0IGZvciBhbm90aGVyIGFuaW1hdGlvblxuICAgKiBmcmFtZSB0byByZW5kZXIgdGhvc2UgY2hhbmdlcy4gSXQncyBuaWNlIHRvIGhhdmUgZXZlcnl0aGluZyB1cGRhdGUgYXV0b21hdGljYWxseSxcbiAgICogYnV0IHRoaXMgZXh0cmEgbGV2ZWwgb2YgYXN5bmMgaW5kaXJlY3Rpb24gd2lsbCBub3QganVzdCBpbnRyb2R1Y2UgYW4gdW53YW50ZWQgZGVsYXksXG4gICAqIGl0IHdpbGwgYWxzbyBtYWtlIGl0IGhhcmRlciB0byByZWFzb24gYWJvdXQgdGhlIHByb2dyYW0uXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlQ2FwdGlvbigpO1xuICAgIHRoaXMudXBkYXRlQ2F0ZWdvcnlMYWJlbHMoKTtcbiAgICB0aGlzLnVwZGF0ZVNlcGFyYXRvcnMoKTtcbiAgICB0aGlzLnVwZGF0ZUF4aXNMaW5lcygpO1xuICAgIHRoaXMudXBkYXRlQ2F0ZWdvcnlHcmlkTGluZXMoKTtcbiAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcbiAgfVxuICB1cGRhdGVUaXRsZUNhcHRpb24oKSB7XG4gICAgY29uc3QgeyBfdGl0bGVDYXB0aW9uIH0gPSB0aGlzO1xuICAgIF90aXRsZUNhcHRpb24ubm9kZS52aXNpYmxlID0gZmFsc2U7XG4gIH1cbiAgdXBkYXRlQ2F0ZWdvcnlMYWJlbHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdGlja0xhYmVsTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xuICAgIGNvbnN0IGxhYmVsU2VsZWN0aW9uID0gdGhpcy5sYWJlbFNlbGVjdGlvbi51cGRhdGUodGlja0xhYmVsTGF5b3V0KTtcbiAgICBsYWJlbFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVTZXBhcmF0b3JzKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHNlcGFyYXRvckxheW91dCB9ID0gdGhpcy5jb21wdXRlZExheW91dDtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgZXBzaWxvbjIgPSAxZS03O1xuICAgIGNvbnN0IHNlcGFyYXRvclNlbGVjdGlvbiA9IHRoaXMuc2VwYXJhdG9yU2VsZWN0aW9uLnVwZGF0ZShzZXBhcmF0b3JMYXlvdXQpO1xuICAgIHNlcGFyYXRvclNlbGVjdGlvbi5lYWNoKChsaW5lLCBkYXR1bSkgPT4ge1xuICAgICAgbGluZS54MSA9IGRhdHVtLngxO1xuICAgICAgbGluZS54MiA9IGRhdHVtLngyO1xuICAgICAgbGluZS55MSA9IGRhdHVtLnk7XG4gICAgICBsaW5lLnkyID0gZGF0dW0ueTtcbiAgICAgIGxpbmUudmlzaWJsZSA9IHRoaXMudGljay5lbmFibGVkICYmIGRhdHVtLnkgPj0gcmFuZ2UzWzBdIC0gZXBzaWxvbjIgJiYgZGF0dW0ueSA8PSByYW5nZTNbMV0gKyBlcHNpbG9uMjtcbiAgICAgIGxpbmUuc3Ryb2tlID0gdGhpcy50aWNrLnN0cm9rZTtcbiAgICAgIGxpbmUuZmlsbCA9IHZvaWQgMDtcbiAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSAxO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUF4aXNMaW5lcygpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBheGlzTGluZUxheW91dCB9ID0gdGhpcy5jb21wdXRlZExheW91dDtcbiAgICBjb25zdCBheGlzTGluZVNlbGVjdGlvbiA9IHRoaXMuYXhpc0xpbmVTZWxlY3Rpb24udXBkYXRlKGF4aXNMaW5lTGF5b3V0KTtcbiAgICBheGlzTGluZVNlbGVjdGlvbi5lYWNoKChsaW5lLCBkYXR1bSkgPT4ge1xuICAgICAgbGluZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgIHN0cm9rZTogdGhpcy5saW5lLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMubGluZS53aWR0aFxuICAgICAgfSk7XG4gICAgICBsaW5lLngxID0gZGF0dW0ueDtcbiAgICAgIGxpbmUueDIgPSBkYXR1bS54O1xuICAgICAgbGluZS55MSA9IGRhdHVtLnkxO1xuICAgICAgbGluZS55MiA9IGRhdHVtLnkyO1xuICAgICAgbGluZS5zdHJva2VXaWR0aCA9IHRoaXMubGluZS53aWR0aDtcbiAgICAgIGxpbmUuc3Ryb2tlID0gdGhpcy5saW5lLnN0cm9rZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDYXRlZ29yeUdyaWRMaW5lcygpIHtcbiAgICBjb25zdCB7IGdyaWRMZW5ndGgsIGdyaWRMaW5lLCBsYWJlbCwgcmFuZ2U6IHJhbmdlMywgdGlja1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gdGlja1NjYWxlLnRpY2tzKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGdyaWRTZWxlY3Rpb24gPSB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uLnVwZGF0ZShncmlkTGVuZ3RoID8gdGlja3MgOiBbXSk7XG4gICAgaWYgKGdyaWRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIHN0eWxlIH0gPSBncmlkTGluZTtcbiAgICAgIGNvbnN0IHN0eWxlQ291bnQgPSBzdHlsZS5sZW5ndGg7XG4gICAgICBncmlkU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh0aWNrU2NhbGUuY29udmVydChkYXR1bSkpO1xuICAgICAgICBsaW5lLngxID0gMDtcbiAgICAgICAgbGluZS54MiA9IC1zaWRlRmxhZyAqIGdyaWRMZW5ndGg7XG4gICAgICAgIGxpbmUueTEgPSB5O1xuICAgICAgICBsaW5lLnkyID0geTtcbiAgICAgICAgbGluZS52aXNpYmxlID0gZ3JpZExpbmUuZW5hYmxlZCAmJiB5ID49IHJhbmdlM1swXSAmJiB5IDw9IHJhbmdlM1sxXTtcbiAgICAgICAgY29uc3QgeyBzdHJva2UsIGxpbmVEYXNoIH0gPSBzdHlsZVtpbmRleCAlIHN0eWxlQ291bnRdO1xuICAgICAgICBsaW5lLnN0cm9rZSA9IHN0cm9rZTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IHdpZHRoO1xuICAgICAgICBsaW5lLmxpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICAgIGxpbmUuZmlsbCA9IHZvaWQgMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wdXRlTGF5b3V0KCkge1xuICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVEb21haW4oKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwgfSxcbiAgICAgIG1vZHVsZUN0eDogeyBjYWxsYmFja0NhY2hlIH0sXG4gICAgICByYW5nZTogcmFuZ2UzLFxuICAgICAgdGl0bGUsXG4gICAgICB0aXRsZTogeyBmb3JtYXR0ZXIgPSAocCkgPT4gcC5kZWZhdWx0VmFsdWUgfSA9IHt9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZ2VTdGFydCA9IHNjYWxlMi5yYW5nZVswXTtcbiAgICBjb25zdCByYW5nZUVuZCA9IHNjYWxlMi5yYW5nZVsxXTtcbiAgICBjb25zdCByYW5nZUxlbmd0aCA9IE1hdGguYWJzKHJhbmdlRW5kIC0gcmFuZ2VTdGFydCk7XG4gICAgY29uc3QgYmFuZHdpZHRoID0gcmFuZ2VMZW5ndGggLyBzY2FsZTIuZG9tYWluLmxlbmd0aCB8fCAwO1xuICAgIGNvbnN0IGtlZXBFdmVyeSA9IE1hdGguY2VpbChsYWJlbC5mb250U2l6ZSAvIGJhbmR3aWR0aCk7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90YXRpb24pKSA8IDFlLTg7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3QgdGlja1RyZWVMYXlvdXQgPSB0aGlzLnRpY2tUcmVlTGF5b3V0O1xuICAgIGNvbnN0IGxhYmVscyA9IHNjYWxlMi50aWNrcygpO1xuICAgIGNvbnN0IHRyZWVMYWJlbHMgPSB0aWNrVHJlZUxheW91dCA/IHRpY2tUcmVlTGF5b3V0Lm5vZGVzIDogW107XG4gICAgY29uc3QgaXNMYWJlbFRyZWUgPSB0aWNrVHJlZUxheW91dCA/IHRpY2tUcmVlTGF5b3V0LmRlcHRoID4gMSA6IGZhbHNlO1xuICAgIGNvbnN0IHsgZGVmYXVsdFJvdGF0aW9uLCBjb25maWd1cmVkUm90YXRpb24sIHBhcmFsbGVsRmxpcEZsYWcgfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb246IGxhYmVsLnJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uOiBub3JtYWxpemVBbmdsZTM2MChyb3RhdGlvbiAtIE1hdGguUEkgLyAyKSxcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uOiBub3JtYWxpemVBbmdsZTM2MChyb3RhdGlvbilcbiAgICB9KTtcbiAgICBjb25zdCB0aWNrTGFiZWxMYXlvdXQgPSBbXTtcbiAgICBjb25zdCBjb3B5TGFiZWxQcm9wcyA9IChub2RlKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxsOiBub2RlLmZpbGwsXG4gICAgICAgIGZvbnRGYW1pbHk6IG5vZGUuZm9udEZhbWlseSxcbiAgICAgICAgZm9udFNpemU6IG5vZGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRTdHlsZTogbm9kZS5mb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IG5vZGUuZm9udFdlaWdodCxcbiAgICAgICAgcm90YXRpb246IG5vZGUucm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWDogbm9kZS5yb3RhdGlvbkNlbnRlclgsXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWTogbm9kZS5yb3RhdGlvbkNlbnRlclksXG4gICAgICAgIHRleHQ6IG5vZGUudGV4dCxcbiAgICAgICAgdGV4dEFsaWduOiBub2RlLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBub2RlLnRleHRCYXNlbGluZSxcbiAgICAgICAgdHJhbnNsYXRpb25YOiBub2RlLnRyYW5zbGF0aW9uWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiBub2RlLnRyYW5zbGF0aW9uWSxcbiAgICAgICAgdmlzaWJsZTogbm9kZS52aXNpYmxlLFxuICAgICAgICB4OiBub2RlLngsXG4gICAgICAgIHk6IG5vZGUueVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGxhYmVsQkJveGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgbWF4TGVhZkxhYmVsV2lkdGggPSAwO1xuICAgIGNvbnN0IHRlbXBUZXh0ID0gbmV3IFRleHQoKTtcbiAgICBjb25zdCBzZXRMYWJlbFByb3BzID0gKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgdGVtcFRleHQuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yLFxuICAgICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXG4gICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHRleHRCYXNlbGluZTogcGFyYWxsZWxGbGlwRmxhZyA9PT0gLTEgPyBcImJvdHRvbVwiIDogXCJoYW5naW5nXCIsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0uc2NyZWVuWSAtIGxhYmVsLmZvbnRTaXplICogMC4yNSxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5zY3JlZW5YXG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBpc0NhcHRpb25FbmFibGVkID0gdGl0bGU/LmVuYWJsZWQgJiYgbGFiZWxzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghaXNDYXB0aW9uRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwgdGhpcy5nZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpKTtcbiAgICAgICAgdGVtcFRleHQuc2V0UHJvcGVydGllcyh7XG4gICAgICAgICAgZmlsbDogdGl0bGUuY29sb3IsXG4gICAgICAgICAgZm9udEZhbWlseTogdGl0bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBmb250U2l6ZTogdGl0bGUuZm9udFNpemUsXG4gICAgICAgICAgZm9udFN0eWxlOiB0aXRsZS5mb250U3R5bGUsXG4gICAgICAgICAgZm9udFdlaWdodDogdGl0bGUuZm9udFdlaWdodCxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJoYW5naW5nXCIsXG4gICAgICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS5zY3JlZW5ZIC0gbGFiZWwuZm9udFNpemUgKiAwLjI1LFxuICAgICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0uc2NyZWVuWFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggJSBrZWVwRXZlcnkgPT09IDApIHtcbiAgICAgICAgY29uc3QgaXNJblJhbmdlID0gZGF0dW0uc2NyZWVuWCA+PSByYW5nZTNbMF0gJiYgZGF0dW0uc2NyZWVuWCA8PSByYW5nZTNbMV07XG4gICAgICAgIGlmICghaXNJblJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbC5mb3JtYXR0ZXIpIHtcbiAgICAgICAgICB0ZW1wVGV4dC50ZXh0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsLmZvcm1hdHRlciwge1xuICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkYXR1bS5sYWJlbCksXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICAgIH0pID8/IFN0cmluZyhkYXR1bS5sYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFRleHQudGV4dCA9IFN0cmluZyhkYXR1bS5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdHJlZUxhYmVscy5mb3JFYWNoKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IHNldExhYmVsUHJvcHMoZGF0dW0sIGluZGV4KTtcbiAgICAgIGlmICghaXNWaXNpYmxlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBiYm94MiA9IHRlbXBUZXh0LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgIGlmICghYmJveDIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxhYmVsQkJveGVzLnNldChpbmRleCwgYmJveDIpO1xuICAgICAgY29uc3QgaXNMZWFmID0gIWRhdHVtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGlmIChpc0xlYWYgJiYgYmJveDIud2lkdGggPiBtYXhMZWFmTGFiZWxXaWR0aCkge1xuICAgICAgICBtYXhMZWFmTGFiZWxXaWR0aCA9IGJib3gyLndpZHRoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGxhYmVsWCA9IHNpZGVGbGFnICogbGFiZWwucGFkZGluZztcbiAgICBjb25zdCBsYWJlbEdyaWQgPSB0aGlzLmxhYmVsLmdyaWQ7XG4gICAgY29uc3Qgc2VwYXJhdG9yRGF0YSA9IFtdO1xuICAgIHRyZWVMYWJlbHMuZm9yRWFjaCgoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBsZXQgdmlzaWJsZSA9IHNldExhYmVsUHJvcHMoZGF0dW0sIGluZGV4KTtcbiAgICAgIGNvbnN0IGlkID0gaW5kZXg7XG4gICAgICB0ZW1wVGV4dC54ID0gbGFiZWxYO1xuICAgICAgdGVtcFRleHQucm90YXRpb25DZW50ZXJYID0gbGFiZWxYO1xuICAgICAgY29uc3QgaXNMZWFmID0gIWRhdHVtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSBjb25maWd1cmVkUm90YXRpb247XG4gICAgICAgIHRlbXBUZXh0LnRleHRBbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIHRlbXBUZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wVGV4dC50cmFuc2xhdGlvblggLT0gbWF4TGVhZkxhYmVsV2lkdGggLSBsaW5lSGVpZ2h0ICsgdGhpcy5sYWJlbC5wYWRkaW5nO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVSYW5nZSA9IGRhdHVtLmxlYWZDb3VudCAqIGJhbmR3aWR0aDtcbiAgICAgICAgY29uc3QgYmJveDIgPSBsYWJlbEJCb3hlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoYmJveDIgJiYgYmJveDIud2lkdGggPiBhdmFpbGFibGVSYW5nZSkge1xuICAgICAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICBsYWJlbEJCb3hlcy5kZWxldGUoaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gLU1hdGguUEkgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGF0dW0ucGFyZW50ICYmIGlzTGFiZWxUcmVlKSB7XG4gICAgICAgIGNvbnN0IHkgPSBpc0xlYWYgPyBkYXR1bS5zY3JlZW5YIC0gYmFuZHdpZHRoIC8gMiA6IGRhdHVtLnNjcmVlblggLSBkYXR1bS5sZWFmQ291bnQgKiBiYW5kd2lkdGggLyAyO1xuICAgICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgICAgaWYgKGRhdHVtLm51bWJlciAhPT0gZGF0dW0uY2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBsYWJlbEdyaWQpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvckRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICB4MjogLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHggPSAtbWF4TGVhZkxhYmVsV2lkdGggLSB0aGlzLmxhYmVsLnBhZGRpbmcgKiAyICsgZGF0dW0uc2NyZWVuWTtcbiAgICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHgxOiB4ICsgbGluZUhlaWdodCxcbiAgICAgICAgICAgIHgyOiB4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBwcm9wcztcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGJib3gyID0gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgICBpZiAoYmJveDIpIHtcbiAgICAgICAgICBsYWJlbEJCb3hlcy5zZXQoaW5kZXgsIGJib3gyKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcyA9IHsgLi4uY29weUxhYmVsUHJvcHModGVtcFRleHQpLCB2aXNpYmxlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbEJCb3hlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICBwcm9wcyA9IHsgdmlzaWJsZSB9O1xuICAgICAgfVxuICAgICAgdGlja0xhYmVsTGF5b3V0LnB1c2gocHJvcHMpO1xuICAgIH0pO1xuICAgIGxldCBtaW5YID0gMDtcbiAgICBzZXBhcmF0b3JEYXRhLmZvckVhY2goKGQpID0+IG1pblggPSBNYXRoLm1pbihtaW5YLCBkLngyKSk7XG4gICAgc2VwYXJhdG9yRGF0YS5wdXNoKHtcbiAgICAgIHk6IE1hdGgubWF4KHJhbmdlU3RhcnQsIHJhbmdlRW5kKSxcbiAgICAgIHgxOiAwLFxuICAgICAgeDI6IG1pblhcbiAgICB9KTtcbiAgICBjb25zdCBzZXBhcmF0b3JMYXlvdXQgPSBbXTtcbiAgICBjb25zdCBzZXBhcmF0b3JCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGVwc2lsb24yID0gMWUtNztcbiAgICBzZXBhcmF0b3JEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBpZiAoZGF0dW0ueSA+PSByYW5nZTNbMF0gLSBlcHNpbG9uMiAmJiBkYXR1bS55IDw9IHJhbmdlM1sxXSArIGVwc2lsb24yKSB7XG4gICAgICAgIGNvbnN0IHsgeDEsIHgyLCB5IH0gPSBkYXR1bTtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yQm94ID0gbmV3IEJCb3goTWF0aC5taW4oeDEsIHgyKSwgeSwgTWF0aC5hYnMoeDEgLSB4MiksIDApO1xuICAgICAgICBzZXBhcmF0b3JCb3hlcy5wdXNoKHNlcGFyYXRvckJveCk7XG4gICAgICAgIHNlcGFyYXRvckxheW91dC5wdXNoKHsgeDEsIHgyLCB5IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGF4aXNMaW5lTGF5b3V0ID0gW107XG4gICAgY29uc3QgYXhpc0xpbmVCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRpY2tUcmVlTGF5b3V0ID8gdGlja1RyZWVMYXlvdXQuZGVwdGggKyAxIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB2aXNpYmxlID0gbGFiZWxzLmxlbmd0aCA+IDAgJiYgKGkgPT09IDAgfHwgbGFiZWxHcmlkICYmIGlzTGFiZWxUcmVlKTtcbiAgICAgIGNvbnN0IHggPSBpID4gMCA/IC1tYXhMZWFmTGFiZWxXaWR0aCAtIHRoaXMubGFiZWwucGFkZGluZyAqIDIgLSAoaSAtIDEpICogbGluZUhlaWdodCA6IDA7XG4gICAgICBjb25zdCBsaW5lQm94ID0gbmV3IEJCb3goeCwgTWF0aC5taW4oLi4ucmFuZ2UzKSwgMCwgTWF0aC5hYnMocmFuZ2UzWzFdIC0gcmFuZ2UzWzBdKSk7XG4gICAgICBheGlzTGluZUJveGVzLnB1c2gobGluZUJveCk7XG4gICAgICBheGlzTGluZUxheW91dC5wdXNoKHsgeCwgeTE6IHJhbmdlM1swXSwgeTI6IHJhbmdlM1sxXSwgdmlzaWJsZSB9KTtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IEJCb3gubWVyZ2UoWy4uLmxhYmVsQkJveGVzLnZhbHVlcygpLCAuLi5zZXBhcmF0b3JCb3hlcywgLi4uYXhpc0xpbmVCb3hlc10pO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQkJveCA9IHRoaXMuZ2V0VHJhbnNmb3JtQm94KGJib3gpO1xuICAgIHJldHVybiB7XG4gICAgICBiYm94OiB0cmFuc2Zvcm1lZEJCb3gsXG4gICAgICB0aWNrTGFiZWxMYXlvdXQsXG4gICAgICBzZXBhcmF0b3JMYXlvdXQsXG4gICAgICBheGlzTGluZUxheW91dFxuICAgIH07XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgIGNvbnN0IHsgYXhpc0xpbmVMYXlvdXQsIHNlcGFyYXRvckxheW91dCwgdGlja0xhYmVsTGF5b3V0LCBiYm94IH0gPSB0aGlzLmNvbXB1dGVMYXlvdXQoKTtcbiAgICB0aGlzLmNvbXB1dGVkTGF5b3V0ID0geyBheGlzTGluZUxheW91dCwgc2VwYXJhdG9yTGF5b3V0LCB0aWNrTGFiZWxMYXlvdXQgfTtcbiAgICByZXR1cm4geyBiYm94LCBwcmltYXJ5VGlja0NvdW50OiB2b2lkIDAgfTtcbiAgfVxufTtcbkdyb3VwZWRDYXRlZ29yeUF4aXMuY2xhc3NOYW1lID0gXCJHcm91cGVkQ2F0ZWdvcnlBeGlzXCI7XG5Hcm91cGVkQ2F0ZWdvcnlBeGlzLnR5cGUgPSBcImdyb3VwZWQtY2F0ZWdvcnlcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgR3JvdXBlZENhdGVnb3J5QXhpcy5wcm90b3R5cGUsIFwibGFiZWxDb2xvclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL21vZHVsZS50c1xudmFyIEJhc2VNb2R1bGVJbnN0YW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGRlc3Ryb3lGbiBvZiB0aGlzLmRlc3Ryb3lGbnMpIHtcbiAgICAgIGRlc3Ryb3lGbigpO1xuICAgIH1cbiAgfVxufTtcbnZhciBNb2R1bGVSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgdGhpcy5kZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVwZW5kZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIoLi4ubW9kdWxlcykge1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZXBlbmRlbmNpZXMobW9kdWxlKTtcbiAgICAgIGNvbnN0IG90aGVyTW9kdWxlID0gdGhpcy5tb2R1bGVzLmZpbmQoXG4gICAgICAgIChvdGhlcikgPT4gbW9kdWxlLnR5cGUgPT09IG90aGVyLnR5cGUgJiYgbW9kdWxlLm9wdGlvbnNLZXkgPT09IG90aGVyLm9wdGlvbnNLZXkgJiYgbW9kdWxlLmlkZW50aWZpZXIgPT09IG90aGVyLmlkZW50aWZpZXJcbiAgICAgICk7XG4gICAgICBpZiAob3RoZXJNb2R1bGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCIgJiYgb3RoZXJNb2R1bGUucGFja2FnZVR5cGUgPT09IFwiY29tbXVuaXR5XCIpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubW9kdWxlcy5pbmRleE9mKG90aGVyTW9kdWxlKTtcbiAgICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxLCBtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNFbnRlcnByaXNlTW9kdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVzLnNvbWUoKG0pID0+IG0ucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiKTtcbiAgfVxuICAqYnlUeXBlKC4uLnR5cGVzKSB7XG4gICAgY29uc3QgeyBkZXBlbmRlbnRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHlpZWxkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgbWF4Q291bnQgPSAzO1xuICAgIGNvbnN0IG1vZHVsZXNCeVR5cGUgPSB0aGlzLm1vZHVsZXMuZmlsdGVyKChtb2R1bGUpID0+IHR5cGVzLmluY2x1ZGVzKG1vZHVsZS50eXBlKSk7XG4gICAgZG8ge1xuICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlc0J5VHlwZSkge1xuICAgICAgICBpZiAoeWllbGRlZC5oYXMobW9kdWxlLm9wdGlvbnNLZXkpIHx8IGRlcGVuZGVudHMuaGFzKG1vZHVsZS5vcHRpb25zS2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIG1vZHVsZTtcbiAgICAgICAgeWllbGRlZC5hZGQobW9kdWxlLm9wdGlvbnNLZXkpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGRlcGVuZGVuY2llc10gb2YgZGVwZW5kZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMuZGVsZXRlKG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGRlcGVuZGVudHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb3VudCsrO1xuICAgIH0gd2hpbGUgKHlpZWxkZWQuc2l6ZSA8IG1vZHVsZXNCeVR5cGUubGVuZ3RoICYmIGNvdW50IDwgbWF4Q291bnQpO1xuICAgIGlmIChkZXBlbmRlbnRzLnNpemUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSBkZXBlbmRlbmNpZXM6IFske1suLi5kZXBlbmRlbnRzLmtleXMoKV19XWApO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckRlcGVuZGVuY2llcyhtb2R1bGUpIHtcbiAgICBpZiAobW9kdWxlLmRlcGVuZGVuY2llcyA9PSBudWxsIHx8IG1vZHVsZS5kZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG1vZHVsZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMuZGVwZW5kZW5jaWVzLmdldChrZXkpID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBkZXBlbmRlbmNpZXMuYWRkKG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnNldChrZXksIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW50cy5zZXQobW9kdWxlLm9wdGlvbnNLZXksIG5ldyBTZXQobW9kdWxlLmRlcGVuZGVuY2llcykpO1xuICB9XG59O1xudmFyIG1vZHVsZVJlZ2lzdHJ5ID0gbmV3IE1vZHVsZVJlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXN5bmMudHNcbmZ1bmN0aW9uIHNsZWVwKHNsZWVwVGltZW91dE1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh2b2lkIDApLCBzbGVlcFRpbWVvdXRNcyk7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL211dGV4LnRzXG52YXIgTXV0ZXggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmFjcXVpcmVRdWV1ZSA9IFtdO1xuICB9XG4gIGFjcXVpcmUoY2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuYWNxdWlyZVF1ZXVlLnB1c2goW2NiLCByZXNvbHZlXSk7XG4gICAgICBpZiAodGhpcy5hdmFpbGFibGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5leHQoKS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWNxdWlyZUltbWVkaWF0ZWx5KGNiKSB7XG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFjcXVpcmUoY2IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JDbGVhckFjcXVpcmVRdWV1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3F1aXJlKGFzeW5jICgpID0+IHZvaWQgMCk7XG4gIH1cbiAgYXN5bmMgZGlzcGF0Y2hOZXh0KCkge1xuICAgIHRoaXMuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgbGV0IFtuZXh0LCBkb25lXSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkgPz8gW107XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgZG9uZT8uKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBMb2dnZXIuZXJyb3IoXCJtdXRleCBjYWxsYmFjayBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgIGRvbmU/LigpO1xuICAgICAgfVxuICAgICAgW25leHQsIGRvbmVdID0gdGhpcy5hY3F1aXJlUXVldWUuc2hpZnQoKSA/PyBbXTtcbiAgICB9XG4gICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL29ic2VydmFibGUudHNcbnZhciBPYnNlcnZhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGxpc3RlbmVyIG11c3QgYmUgYSBGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRUeXBlTGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoZXZlbnRUeXBlTGlzdGVuZXJzKSB7XG4gICAgICBldmVudFR5cGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbbGlzdGVuZXJdKSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldCh0eXBlKT8uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5ldmVudExpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcbiAgICB9XG4gIH1cbiAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzKHR5cGUpO1xuICB9XG4gIGNsZWFyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5jbGVhcigpO1xuICB9XG4gIGZpcmVFdmVudChldmVudCkge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50LnR5cGUpPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9wYWRkaW5nLnRzXG52YXIgUGFkZGluZyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3Rvcih0b3AgPSAwLCByaWdodCA9IHRvcCwgYm90dG9tID0gdG9wLCBsZWZ0ID0gcmlnaHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMudG9wID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gdGhpcy5sZWZ0ID0gMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcInRvcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcInJpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwiYm90dG9tXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwibGVmdFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9yZW5kZXIudHNcbmZ1bmN0aW9uIGRlYm91bmNlZEFuaW1hdGlvbkZyYW1lKGNiKSB7XG4gIHJldHVybiBidWlsZFNjaGVkdWxlcigoaW5uZXJDYiwgX2RlbGF5TXMpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShpbm5lckNiKSwgY2IpO1xufVxuZnVuY3Rpb24gZGVib3VuY2VkQ2FsbGJhY2soY2IpIHtcbiAgcmV0dXJuIGJ1aWxkU2NoZWR1bGVyKChpbm5lckNiLCBkZWxheU1zID0gMCkgPT4gc2V0VGltZW91dChpbm5lckNiLCBkZWxheU1zKSwgY2IpO1xufVxuZnVuY3Rpb24gYnVpbGRTY2hlZHVsZXIoc2NoZWR1bGVGbiwgY2IpIHtcbiAgbGV0IHNjaGVkdWxlQ291bnQgPSAwO1xuICBsZXQgcHJvbWlzZVJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IGF3YWl0aW5nUHJvbWlzZTtcbiAgbGV0IGF3YWl0aW5nRG9uZTtcbiAgY29uc3QgYnVzeSA9ICgpID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZVJ1bm5pbmc7XG4gIH07XG4gIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgcHJvbWlzZVJ1bm5pbmcgPSBmYWxzZTtcbiAgICBhd2FpdGluZ0RvbmU/LigpO1xuICAgIGF3YWl0aW5nRG9uZSA9IHZvaWQgMDtcbiAgICBhd2FpdGluZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgaWYgKHNjaGVkdWxlQ291bnQgPiAwKSB7XG4gICAgICBzY2hlZHVsZUZuKHNjaGVkdWxlQ2IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2NoZWR1bGVDYiA9ICgpID0+IHtcbiAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlQ291bnQ7XG4gICAgc2NoZWR1bGVDb3VudCA9IDA7XG4gICAgcHJvbWlzZVJ1bm5pbmcgPSB0cnVlO1xuICAgIGNvbnN0IG1heWJlUHJvbWlzZSA9IGNiKHsgY291bnQgfSk7XG4gICAgaWYgKCFtYXliZVByb21pc2UpIHtcbiAgICAgIGRvbmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF5YmVQcm9taXNlLnRoZW4oZG9uZSwgZG9uZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgc2NoZWR1bGUoZGVsYXlNcykge1xuICAgICAgaWYgKHNjaGVkdWxlQ291bnQgPT09IDAgJiYgIWJ1c3koKSkge1xuICAgICAgICBzY2hlZHVsZUZuKHNjaGVkdWxlQ2IsIGRlbGF5TXMpO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGVDb3VudCsrO1xuICAgIH0sXG4gICAgYXN5bmMgYXdhaXQoKSB7XG4gICAgICBpZiAoIWJ1c3koKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRpbmdQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgYXdhaXRpbmdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBhd2FpdGluZ0RvbmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChidXN5KCkpIHtcbiAgICAgICAgYXdhaXQgYXdhaXRpbmdQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdmVyc2lvbi50c1xudmFyIFZFUlNJT04gPSBcIjEwLjEuMFwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvc3RhdGUvbWVtZW50by50c1xudmFyIE1lbWVudG9DYXJldGFrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uLnNwbGl0KFwiLVwiKVswXTtcbiAgfVxuICBzYXZlKC4uLm9yaWdpbmF0b3JzKSB7XG4gICAgY29uc3QgcGFja2V0ID0geyB2ZXJzaW9uOiB0aGlzLnZlcnNpb24gfTtcbiAgICBmb3IgKGNvbnN0IG9yaWdpbmF0b3Igb2YgT2JqZWN0LnZhbHVlcyhvcmlnaW5hdG9ycykpIHtcbiAgICAgIHBhY2tldFtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5XSA9IHRoaXMuZW5jb2RlKG9yaWdpbmF0b3IsIG9yaWdpbmF0b3IuY3JlYXRlTWVtZW50bygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXN0b3JlKGJsb2IsIC4uLm9yaWdpbmF0b3JzKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYENvdWxkIG5vdCByZXN0b3JlIGRhdGEgb2YgdHlwZSBbJHt0eXBlb2YgYmxvYn1dLCBleHBlY3RpbmcgYW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2IgPT0gbnVsbCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBDb3VsZCBub3QgcmVzdG9yZSBkYXRhIG9mIHR5cGUgW251bGxdLCBleHBlY3RpbmcgYW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoXCJ2ZXJzaW9uXCIgaW4gYmxvYikgfHwgdHlwZW9mIGJsb2IudmVyc2lvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBDb3VsZCBub3QgcmVzdG9yZSBkYXRhLCBtaXNzaW5nIFt2ZXJzaW9uXSBzdHJpbmcgaW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvcmlnaW5hdG9yIG9mIG9yaWdpbmF0b3JzKSB7XG4gICAgICBpZiAoIShvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5IGluIGJsb2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVtZW50byA9IHRoaXMuZGVjb2RlKG9yaWdpbmF0b3IsIGJsb2Jbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV0pO1xuICAgICAgaWYgKCFvcmlnaW5hdG9yLmd1YXJkTWVtZW50byhtZW1lbnRvKSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYENvdWxkIG5vdCByZXN0b3JlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSBkYXRhLCB2YWx1ZSB3YXMgaW52YWxpZCwgaWdub3JpbmcuYCxcbiAgICAgICAgICBtZW1lbnRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmF0b3IucmVzdG9yZU1lbWVudG8odGhpcy52ZXJzaW9uLCBibG9iLnZlcnNpb24sIG1lbWVudG8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5jb2RlIGEgbWVtZW50byBhcyBhIHNlcmlhbGl6YWJsZSBvYmplY3QsIGVuY29kaW5nIGFueSBub24tc2VyaWFsaXpibGUgdHlwZXMuXG4gICAqL1xuICBlbmNvZGUob3JpZ2luYXRvciwgbWVtZW50bykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZW1lbnRvLCB0aGlzLmVuY29kZVR5cGVzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVuY29kZSBbJHtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5fV0gdmFsdWUgWyR7ZXJyb3J9XS5gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gZW5jb2RlZCBtZW1lbnRvLCBkZWNvZGluZyBhbnkgbm9uLXNlcmlhbGl6YWJsZSB0eXBlcy5cbiAgICovXG4gIGRlY29kZShvcmlnaW5hdG9yLCBlbmNvZGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY29kZWQpLCB0aGlzLmRlY29kZVR5cGVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVjb2RlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSB2YWx1ZSBbJHtlcnJvcn1dLmAsIHtcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlVHlwZXMoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0RhdGUodGhpc1trZXldKSkge1xuICAgICAgcmV0dXJuIHsgX190eXBlOiBcImRhdGVcIiwgdmFsdWU6IFN0cmluZyh0aGlzW2tleV0pIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBkZWNvZGVUeXBlcyhrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzT2JqZWN0KHRoaXNba2V5XSkgJiYgXCJfX3R5cGVcIiBpbiB0aGlzW2tleV0gJiYgdGhpc1trZXldLl9fdHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzW2tleV0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9zdGF0ZS9zdGF0ZU1hbmFnZXIudHNcbnZhciBTdGF0ZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FyZXRha2VyID0gbmV3IE1lbWVudG9DYXJldGFrZXIoVkVSU0lPTik7XG4gICAgdGhpcy5zdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgc2V0U3RhdGUob3JpZ2luYXRvciwgdmFsdWUpIHtcbiAgICBpZiAoanNvbkRpZmYodGhpcy5zdGF0ZS5nZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSksIHZhbHVlKSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXksIHZhbHVlKTtcbiAgICB0aGlzLnJlc3RvcmVTdGF0ZShvcmlnaW5hdG9yKTtcbiAgfVxuICByZXN0b3JlU3RhdGUob3JpZ2luYXRvcikge1xuICAgIGNvbnN0IHsgY2FyZXRha2VyLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBpZiAoIXN0YXRlLmhhcyhvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YXRlLmdldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KTtcbiAgICBjYXJldGFrZXIucmVzdG9yZSh7IHZlcnNpb246IGNhcmV0YWtlci52ZXJzaW9uLCBbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV06IHZhbHVlIH0sIG9yaWdpbmF0b3IpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3VzZXJBZ2VudC50c1xuZnVuY3Rpb24gaGFzQ29uc3RyYWluZWRDYW52YXNNZW1vcnkoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlQaG9uZU9TTWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9cXChpUGhvbmU7IENQVSBpUGhvbmUgT1MgKFxcZCtfXFxkK19cXGQrKSBsaWtlIE1hYyBPUyBYXFwpLyk7XG4gIGlmIChpUGhvbmVPU01hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW21ham9yLCBtaW5vcl0gPSBpUGhvbmVPU01hdGNoWzFdLnNwbGl0KFwiX1wiKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIG1ham9yIDwgMTYgfHwgbWFqb3IgPT09IDE2ICYmIG1pbm9yIDwgNjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvY2FudmFzL2hkcGlDYW52YXMudHNcbnZhciBfSGRwaUNhbnZhcyA9IGNsYXNzIF9IZHBpQ2FudmFzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDYwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwMDtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8sIGNhbnZhc0NvbnN0cnVjdG9yLCB3aWxsUmVhZEZyZXF1ZW50bHkgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBoYXNDb25zdHJhaW5lZENhbnZhc01lbW9yeSgpID8gMSA6IHBpeGVsUmF0aW8gPz8gZ2V0V2luZG93KFwiZGV2aWNlUGl4ZWxSYXRpb1wiKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBjYW52YXNDb25zdHJ1Y3Rvcj8uKCkgPz8gY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAod2lkdGggPz8gdGhpcy53aWR0aCkgKyBcInB4XCI7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChoZWlnaHQgPz8gdGhpcy5oZWlnaHQpICsgXCJweFwiO1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IE1hdGgucm91bmQoKHdpZHRoID8/IHRoaXMud2lkdGgpICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmVsZW1lbnQuaGVpZ2h0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0ID8/IHRoaXMuaGVpZ2h0KSAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5lbGVtZW50LmdldENvbnRleHQoXCIyZFwiLCB7IHdpbGxSZWFkRnJlcXVlbnRseSB9KTtcbiAgICB0aGlzLm9uRW5hYmxlZENoYW5nZSgpO1xuICAgIHRoaXMucmVzaXplKHdpZHRoID8/IDAsIGhlaWdodCA/PyAwKTtcbiAgICBfSGRwaUNhbnZhcy5kZWJ1Z0NvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfSGRwaUNhbnZhcztcbiAgfVxuICBkcmF3SW1hZ2UoY29udGV4dCwgZHggPSAwLCBkeSA9IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jb250ZXh0LmNhbnZhcywgZHgsIGR5KTtcbiAgfVxuICB0b0RhdGFVUkwodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQudG9EYXRhVVJMKHR5cGUpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCEod2lkdGggPiAwICYmIGhlaWdodCA+IDApKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIsIGNvbnRleHQsIHBpeGVsUmF0aW8gfSA9IHRoaXM7XG4gICAgZWxlbWVudDIud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogcGl4ZWxSYXRpbyk7XG4gICAgZWxlbWVudDIuaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICBlbGVtZW50Mi5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIGVsZW1lbnQyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgc25hcHNob3QoKSB7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IDA7XG4gICAgdGhpcy5lbGVtZW50LmhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAwLCAwKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIG9uRW5hYmxlZENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHRoaXMuZW5hYmxlZCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbiAgc3RhdGljIGRlYnVnQ29udGV4dChjdHgpIHtcbiAgICBpZiAoRGVidWcuY2hlY2soXCJjYW52YXNcIikpIHtcbiAgICAgIGNvbnN0IHNhdmUgPSBjdHguc2F2ZS5iaW5kKGN0eCk7XG4gICAgICBjb25zdCByZXN0b3JlID0gY3R4LnJlc3RvcmUuYmluZChjdHgpO1xuICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgIE9iamVjdC5hc3NpZ24oY3R4LCB7XG4gICAgICAgIHNhdmUoKSB7XG4gICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RvcmUoKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBVbmFibGUgdG8gcmVzdG9yZSgpIHBhc3QgZGVwdGggMFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdG9yZSgpO1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH0sXG4gICAgICAgIHZlcmlmeURlcHRoWmVybygpIHtcbiAgICAgICAgICBpZiAoZGVwdGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gU2F2ZS9yZXN0b3JlIGRlcHRoIGlzIG5vbi16ZXJvOiAke2RlcHRofWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0Lm9uRW5hYmxlZENoYW5nZSgpKVxuXSwgX0hkcGlDYW52YXMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgSGRwaUNhbnZhcyA9IF9IZHBpQ2FudmFzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9sYXllcnNNYW5hZ2VyLnRzXG52YXIgTGF5ZXJzTWFuYWdlciA9IGNsYXNzIF9MYXllcnNNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FudmFzLCBtYXJrRGlydHkpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLm1hcmtEaXJ0eSA9IG1hcmtEaXJ0eTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwic2NlbmVcIik7XG4gICAgdGhpcy5sYXllcnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubmV4dFpJbmRleCA9IDA7XG4gICAgdGhpcy5uZXh0TGF5ZXJJZCA9IDA7XG4gIH1cbiAgc3RhdGljIHNvcnRMYXllcnMoYSwgYikge1xuICAgIHJldHVybiBjb21wb3VuZEFzY2VuZGluZyhcbiAgICAgIFthLnpJbmRleCwgLi4uYS56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBhLmlkXSxcbiAgICAgIFtiLnpJbmRleCwgLi4uYi56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBiLmlkXSxcbiAgICAgIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZFxuICAgICk7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzTWFwLnNpemU7XG4gIH1cbiAgZm9yRWFjaChjYWxsYmFjazIpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMubGF5ZXJzTWFwLnZhbHVlcygpKS5zb3J0KF9MYXllcnNNYW5hZ2VyLnNvcnRMYXllcnMpLmZvckVhY2goY2FsbGJhY2syKTtcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuY2FudmFzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmxheWVyc01hcC5mb3JFYWNoKCh7IGNhbnZhcyB9KSA9PiBjYW52YXMucmVzaXplKHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuICBhZGRMYXllcihvcHRzKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvIH0gPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCB7IHpJbmRleCA9IHRoaXMubmV4dFpJbmRleCsrLCBuYW1lLCB6SW5kZXhTdWJPcmRlciwgZ2V0Q29tcHV0ZWRPcGFjaXR5LCBnZXRWaXNpYmlsaXR5IH0gPSBvcHRzO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBIZHBpQ2FudmFzKHsgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyB9KTtcbiAgICBjb25zdCBuZXdMYXllciA9IHtcbiAgICAgIGlkOiB0aGlzLm5leHRMYXllcklkKyssXG4gICAgICBuYW1lLFxuICAgICAgY2FudmFzLFxuICAgICAgekluZGV4LFxuICAgICAgekluZGV4U3ViT3JkZXIsXG4gICAgICBnZXRDb21wdXRlZE9wYWNpdHksXG4gICAgICBnZXRWaXNpYmlsaXR5XG4gICAgfTtcbiAgICBpZiAoekluZGV4ID49IHRoaXMubmV4dFpJbmRleCkge1xuICAgICAgdGhpcy5uZXh0WkluZGV4ID0gekluZGV4ICsgMTtcbiAgICB9XG4gICAgdGhpcy5sYXllcnNNYXAuc2V0KGNhbnZhcywgbmV3TGF5ZXIpO1xuICAgIHRoaXMuZGVidWcoXCJTY2VuZS5hZGRMYXllcigpIC0gbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICByZXR1cm4gbmV3TGF5ZXIuY2FudmFzO1xuICB9XG4gIHJlbW92ZUxheWVyKGNhbnZhcykge1xuICAgIGlmICh0aGlzLmxheWVyc01hcC5oYXMoY2FudmFzKSkge1xuICAgICAgdGhpcy5sYXllcnNNYXAuZGVsZXRlKGNhbnZhcyk7XG4gICAgICBjYW52YXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW1vdmVMYXllcigpIC0gIGxheWVyc1wiLCB0aGlzLmxheWVyc01hcCk7XG4gICAgfVxuICB9XG4gIG1vdmVMYXllcihjYW52YXMsIG5ld1pJbmRleCwgbmV3WkluZGV4U3ViT3JkZXIpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzTWFwLmdldChjYW52YXMpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuekluZGV4ID0gbmV3WkluZGV4O1xuICAgICAgbGF5ZXIuekluZGV4U3ViT3JkZXIgPSBuZXdaSW5kZXhTdWJPcmRlcjtcbiAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUubW92ZUxheWVyKCkgLSAgbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5sYXllcnNNYXAuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2NlbmVEZWJ1Zy50c1xuZnVuY3Rpb24gZGVidWdTdGF0cyhsYXllcnNNYW5hZ2VyLCBkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgcmVuZGVyQ3R4U3RhdHMsIGV4dHJhRGVidWdTdGF0cyA9IHt9LCBzZXJpZXNSZWN0ID0gQkJveC56ZXJvKSB7XG4gIGlmICghRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0c1wiIC8qIFNDRU5FX1NUQVRTICovLCBcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgbGF5ZXJzUmVuZGVyZWQgPSAwLCBsYXllcnNTa2lwcGVkID0gMCwgbm9kZXNSZW5kZXJlZCA9IDAsIG5vZGVzU2tpcHBlZCA9IDAgfSA9IHJlbmRlckN0eFN0YXRzID8/IHt9O1xuICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgeyBzdGFydCwgLi4uZHVyYXRpb25zIH0gPSBkZWJ1Z1NwbGl0VGltZXM7XG4gIGNvbnN0IHNwbGl0cyA9IE9iamVjdC5lbnRyaWVzKGR1cmF0aW9ucykubWFwKChbbiwgdF0pID0+IHtcbiAgICByZXR1cm4gdGltZShuLCB0KTtcbiAgfSkuZmlsdGVyKCh2KSA9PiB2ICE9IG51bGwpLmpvaW4oXCIgKyBcIik7XG4gIGNvbnN0IGV4dHJhcyA9IE9iamVjdC5lbnRyaWVzKGV4dHJhRGVidWdTdGF0cykubWFwKChbaywgdl0pID0+IGAke2t9OiAke3Z9YCkuam9pbihcIiA7IFwiKTtcbiAgY29uc3QgZGV0YWlsZWRTdGF0cyA9IERlYnVnLmNoZWNrKFwic2NlbmU6c3RhdHM6dmVyYm9zZVwiIC8qIFNDRU5FX1NUQVRTX1ZFUkJPU0UgKi8pO1xuICBjb25zdCBzdGF0cyA9IFtcbiAgICBgJHt0aW1lKFwiXFx1MjNGMVxcdUZFMEZcIiwgc3RhcnQsIGVuZCl9ICgke3NwbGl0c30pYCxcbiAgICBgJHtleHRyYXN9YCxcbiAgICBgTGF5ZXJzOiAke2RldGFpbGVkU3RhdHMgPyBwY3QobGF5ZXJzUmVuZGVyZWQsIGxheWVyc1NraXBwZWQpIDogbGF5ZXJzTWFuYWdlci5zaXplfWAsXG4gICAgZGV0YWlsZWRTdGF0cyA/IGBOb2RlczogJHtwY3Qobm9kZXNSZW5kZXJlZCwgbm9kZXNTa2lwcGVkKX1gIDogbnVsbFxuICBdLmZpbHRlcihpc1N0cmluZyk7XG4gIGNvbnN0IG1lYXN1cmVyID0gbmV3IFNpbXBsZVRleHRNZWFzdXJlcigodCkgPT4gY3R4Lm1lYXN1cmVUZXh0KHQpKTtcbiAgY29uc3Qgc3RhdHNTaXplID0gbmV3IE1hcChzdGF0cy5tYXAoKHQpID0+IFt0LCBtZWFzdXJlci5tZWFzdXJlTGluZXModCldKSk7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbShzdGF0c1NpemUudmFsdWVzKCksIChzKSA9PiBzLndpZHRoKSk7XG4gIGNvbnN0IGhlaWdodCA9IGFjY3VtdWxhdGUoc3RhdHNTaXplLnZhbHVlcygpLCAocykgPT4gcy5oZWlnaHQpO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gIGxldCB5ID0gMDtcbiAgZm9yIChjb25zdCBbc3RhdCwgc2l6ZV0gb2Ygc3RhdHNTaXplLmVudHJpZXMoKSkge1xuICAgIHkgKz0gc2l6ZS5oZWlnaHQ7XG4gICAgY3R4LmZpbGxUZXh0KHN0YXQsIDIgKyBzZXJpZXNSZWN0LngsIHkpO1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkZWJ1Z1NjZW5lTm9kZUhpZ2hsaWdodChjdHgsIGRlYnVnTm9kZXMpIHtcbiAgY3R4LnNhdmUoKTtcbiAgZm9yIChjb25zdCBbbmFtZSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVidWdOb2RlcykpIHtcbiAgICBjb25zdCBiYm94ID0gbm9kZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgaWYgKCFiYm94KSB7XG4gICAgICBMb2dnZXIubG9nKGBTY2VuZS5yZW5kZXIoKSAtIG5vIGJib3ggZm9yIGRlYnVnZ2VkIG5vZGUgWyR7bmFtZX1dLmApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5zdHJva2VSZWN0KGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5mb250ID0gXCIxNnB4IHNhbnMtc2VyaWZcIjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgY3R4LnN0cm9rZVRleHQobmFtZSwgYmJveC54LCBiYm94LnksIGJib3gud2lkdGgpO1xuICAgIGN0eC5maWxsVGV4dChuYW1lLCBiYm94LngsIGJib3gueSwgYmJveC53aWR0aCk7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShub2RlKSB7XG4gIGlmICghRGVidWcuY2hlY2sodHJ1ZSwgXCJzY2VuZVwiIC8qIFNDRU5FICovKSlcbiAgICByZXR1cm4ge307XG4gIHJldHVybiB7XG4gICAgbm9kZSxcbiAgICBuYW1lOiBub2RlLm5hbWUgPz8gbm9kZS5pZCxcbiAgICBkaXJ0eTogUmVkcmF3VHlwZVtub2RlLmRpcnR5XSxcbiAgICAuLi5ub2RlLnBhcmVudD8uaXNWaXJ0dWFsID8ge1xuICAgICAgdmlydHVhbFBhcmVudERpcnR5OiBSZWRyYXdUeXBlW25vZGUucGFyZW50LmRpcnR5XSxcbiAgICAgIHZpcnR1YWxQYXJlbnQ6IG5vZGUucGFyZW50XG4gICAgfSA6IHt9LFxuICAgIC4uLm5vZGUuY2hpbGRyZW4ubWFwKChjKSA9PiBidWlsZFRyZWUoYykpLnJlZHVjZSgocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgIGxldCB7IG5hbWU6IHRyZWVOb2RlTmFtZSB9ID0gY2hpbGRUcmVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlOiB7XG4gICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICB6SW5kZXhTdWJPcmRlcixcbiAgICAgICAgICB0cmFuc2xhdGlvblgsXG4gICAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIHNjYWxpbmdYLFxuICAgICAgICAgIHNjYWxpbmdZXG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IGNoaWxkTm9kZSxcbiAgICAgICAgdmlydHVhbFBhcmVudFxuICAgICAgfSA9IGNoaWxkVHJlZTtcbiAgICAgIGlmICghdmlzaWJsZSB8fCBvcGFjaXR5IDw9IDApIHtcbiAgICAgICAgdHJlZU5vZGVOYW1lID0gYCgke3RyZWVOb2RlTmFtZX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBHcm91cCAmJiBjaGlsZE5vZGUuaXNMYXllcigpKSB7XG4gICAgICAgIHRyZWVOb2RlTmFtZSA9IGAqJHt0cmVlTm9kZU5hbWV9KmA7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBbXG4gICAgICAgIGAke3RyZWVOb2RlTmFtZSA/PyBcIjx1bmtub3duPlwifWAsXG4gICAgICAgIGB6OiAke3pJbmRleH1gLFxuICAgICAgICB6SW5kZXhTdWJPcmRlciAmJiBgem86ICR7ekluZGV4U3ViT3JkZXIubWFwKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gYCR7digpfSAoZm4pYCA6IHYpLmpvaW4oXCIgLyBcIil9YCxcbiAgICAgICAgdmlydHVhbFBhcmVudCAmJiBgKHZpcnR1YWwgcGFyZW50KWAsXG4gICAgICAgIHRyYW5zbGF0aW9uWCAmJiBgeDogJHt0cmFuc2xhdGlvblh9YCxcbiAgICAgICAgdHJhbnNsYXRpb25ZICYmIGB5OiAke3RyYW5zbGF0aW9uWX1gLFxuICAgICAgICByb3RhdGlvbiAmJiBgcjogJHtyb3RhdGlvbn1gLFxuICAgICAgICBzY2FsaW5nWCAhPT0gMSAmJiBgc3g6ICR7c2NhbGluZ1h9YCxcbiAgICAgICAgc2NhbGluZ1kgIT09IDEgJiYgYHN5OiAke3NjYWxpbmdZfWBcbiAgICAgIF0uZmlsdGVyKCh2KSA9PiAhIXYpLmpvaW4oXCIgXCIpO1xuICAgICAgbGV0IHNlbGVjdGVkS2V5ID0ga2V5O1xuICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgIHdoaWxlIChyZXN1bHRbc2VsZWN0ZWRLZXldICE9IG51bGwgJiYgaW5kZXggPCAxMDApIHtcbiAgICAgICAgc2VsZWN0ZWRLZXkgPSBgJHtrZXl9ICgke2luZGV4Kyt9KWA7XG4gICAgICB9XG4gICAgICByZXN1bHRbc2VsZWN0ZWRLZXldID0gY2hpbGRUcmVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGlydHlUcmVlKG5vZGUpIHtcbiAgaWYgKG5vZGUuZGlydHkgPT09IDAgLyogTk9ORSAqLykge1xuICAgIHJldHVybiB7IGRpcnR5VHJlZToge30sIHBhdGhzOiBbXSB9O1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuRGlydHlUcmVlID0gbm9kZS5jaGlsZHJlbi5tYXAoKGMpID0+IGJ1aWxkRGlydHlUcmVlKGMpKS5maWx0ZXIoKGMpID0+IGMucGF0aHMubGVuZ3RoID4gMCk7XG4gIGNvbnN0IG5hbWUgPSBHcm91cC5pcyhub2RlKSA/IG5vZGUubmFtZSA/PyBub2RlLmlkIDogbm9kZS5pZDtcbiAgY29uc3QgcGF0aHMgPSBjaGlsZHJlbkRpcnR5VHJlZS5sZW5ndGggPyBjaGlsZHJlbkRpcnR5VHJlZS5mbGF0TWFwKChjKSA9PiBjLnBhdGhzKS5tYXAoKHApID0+IGAke25hbWV9LiR7cH1gKSA6IFtuYW1lXTtcbiAgcmV0dXJuIHtcbiAgICBkaXJ0eVRyZWU6IHtcbiAgICAgIG5hbWUsXG4gICAgICBub2RlLFxuICAgICAgZGlydHk6IFJlZHJhd1R5cGVbbm9kZS5kaXJ0eV0sXG4gICAgICAuLi5jaGlsZHJlbkRpcnR5VHJlZS5tYXAoKGMpID0+IGMuZGlydHlUcmVlKS5maWx0ZXIoKHQpID0+IHQuZGlydHkgIT0gbnVsbCkucmVkdWNlKChyZXN1bHQsIGNoaWxkVHJlZSkgPT4ge1xuICAgICAgICByZXN1bHRbY2hpbGRUcmVlLm5hbWUgPz8gXCI8dW5rbm93bj5cIl0gPSBjaGlsZFRyZWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSlcbiAgICB9LFxuICAgIHBhdGhzXG4gIH07XG59XG5mdW5jdGlvbiBwY3QocmVuZGVyZWQsIHNraXBwZWQpIHtcbiAgY29uc3QgdG90YWwgPSByZW5kZXJlZCArIHNraXBwZWQ7XG4gIHJldHVybiBgJHtyZW5kZXJlZH0gLyAke3RvdGFsfSAoJHtNYXRoLnJvdW5kKDEwMCAqIHJlbmRlcmVkIC8gdG90YWwpfSUpYDtcbn1cbmZ1bmN0aW9uIHRpbWUobmFtZSwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBkdXJhdGlvbiA9IGVuZCAhPSBudWxsID8gZW5kIC0gc3RhcnQgOiBzdGFydDtcbiAgcmV0dXJuIGAke25hbWV9OiAke01hdGgucm91bmQoZHVyYXRpb24gKiAxMDApIC8gMTAwfW1zYDtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaXRlcmF0b3IsIG1hcHBlcikge1xuICBsZXQgc3VtMiA9IDA7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdGVyYXRvcikge1xuICAgIHN1bTIgKz0gbWFwcGVyKGl0ZW0pO1xuICB9XG4gIHJldHVybiBzdW0yO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zY2VuZS50c1xudmFyIFNjZW5lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8sIGRvbU1hbmFnZXIgfSkge1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJzY2VuZVwiIC8qIFNDRU5FICovKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIGNvbnN0IGNhbnZhc09wdHMgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBpeGVsUmF0aW9cbiAgICB9O1xuICAgIGlmIChkb21NYW5hZ2VyKSB7XG4gICAgICBjYW52YXNPcHRzLmNhbnZhc0NvbnN0cnVjdG9yID0gKCkgPT4gZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhc1wiLCBcInNjZW5lLWNhbnZhc1wiKTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXMgPSBuZXcgSGRwaUNhbnZhcyhjYW52YXNPcHRzKTtcbiAgICB0aGlzLmxheWVyc01hbmFnZXIgPSBuZXcgTGF5ZXJzTWFuYWdlcih0aGlzLmNhbnZhcywgKCkgPT4ge1xuICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1NpemU/LlswXSA/PyB0aGlzLmNhbnZhcy53aWR0aDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdTaXplPy5bMV0gPz8gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICB9XG4gIHNldENvbnRhaW5lcih2YWx1ZSkge1xuICAgIGNvbnN0IGlzRWxlbWVudCA9ICh2KSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIHYudGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9O1xuICAgIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzLmNhbnZhcztcbiAgICAgIGVsZW1lbnQyLnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKGVsZW1lbnQyKTtcbiAgICAgIHZhbHVlLmFwcGVuZENoaWxkKGVsZW1lbnQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb21NYW5hZ2VyID0gdmFsdWU7XG4gICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXNcIiwgXCJzY2VuZS1jYW52YXNcIiwgdGhpcy5jYW52YXMuZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFJvb3Qobm9kZSkge1xuICAgIGlmICh0aGlzLnJvb3QgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMucm9vdD8uX3NldExheWVyTWFuYWdlcigpO1xuICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUudmlzaWJsZSA9IHRydWU7XG4gICAgICBub2RlLl9zZXRMYXllck1hbmFnZXIodGhpcy5sYXllcnNNYW5hZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXR0YWNoTm9kZShub2RlLCByb290R3JvdXBOYW1lKSB7XG4gICAgaWYgKCFyb290R3JvdXBOYW1lKSB7XG4gICAgICB0aGlzLnJvb3Q/LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEdyb3VwID0gdGhpcy5yb290Py5jaGlsZHJlbi5maW5kKChnKSA9PiBnIGluc3RhbmNlb2YgR3JvdXAgJiYgZy5uYW1lID09PSByb290R3JvdXBOYW1lKTtcbiAgICBpZiAoIXBhcmVudEdyb3VwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gVW5yZWNvZ25pemVkIHJvb3QgZ3JvdXAgbmFtZTogXCIgKyByb290R3JvdXBOYW1lKTtcbiAgICBwYXJlbnRHcm91cC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gKCkgPT4gcGFyZW50R3JvdXAucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbiAgYXBwZW5kQ2hpbGQobm9kZSkge1xuICAgIHRoaXMucm9vdD8uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgIHRoaXMucm9vdD8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpIHtcbiAgICBkb3dubG9hZFVybCh0aGlzLmNhbnZhcy50b0RhdGFVUkwoZmlsZUZvcm1hdCksIGZpbGVOYW1lPy50cmltKCkgPz8gXCJpbWFnZVwiKTtcbiAgfVxuICAvKiogTk9URTogSW50ZWdyYXRlZCBDaGFydHMgdW5kb2N1bWVudGVkIGltYWdlIGRvd25sb2FkIG1ldGhvZC4gKi9cbiAgZ2V0RGF0YVVSTChmaWxlRm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTChmaWxlRm9ybWF0KTtcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCAmJiAod2lkdGggIT09IHRoaXMud2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkpIHtcbiAgICAgIHRoaXMucGVuZGluZ1NpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZW5kZXIob3B0cykge1xuICAgIGNvbnN0IHsgZGVidWdTcGxpdFRpbWVzID0geyBzdGFydDogcGVyZm9ybWFuY2Uubm93KCkgfSwgZXh0cmFEZWJ1Z1N0YXRzLCBzZXJpZXNSZWN0IH0gPSBvcHRzID8/IHt9O1xuICAgIGNvbnN0IHsgY2FudmFzLCBjYW52YXM6IHsgY29udGV4dDogY3R4IH0gPSB7fSwgcm9vdCwgcGVuZGluZ1NpemUgfSA9IHRoaXM7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHBlbmRpbmdTaXplKSB7XG4gICAgICB0aGlzLmxheWVyc01hbmFnZXIucmVzaXplKC4uLnBlbmRpbmdTaXplKTtcbiAgICAgIHRoaXMucGVuZGluZ1NpemUgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChyb290ICYmICFyb290LnZpc2libGUpIHtcbiAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiAhdGhpcy5pc0RpcnR5KSB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW5kZXIoKSAtIG5vLW9wXCIsIHtcbiAgICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxuICAgICAgICAgIHRyZWU6IGJ1aWxkVHJlZShyb290KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlYnVnU3RhdHModGhpcy5sYXllcnNNYW5hZ2VyLCBkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgdm9pZCAwLCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJDdHggPSB7XG4gICAgICBjdHgsXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvOiB0aGlzLmNhbnZhcy5waXhlbFJhdGlvID8/IDEsXG4gICAgICBmb3JjZVJlbmRlcjogdHJ1ZSxcbiAgICAgIHJlc2l6ZWQ6IEJvb2xlYW4ocGVuZGluZ1NpemUpLFxuICAgICAgZGVidWdOb2Rlczoge31cbiAgICB9O1xuICAgIGlmIChEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKSkge1xuICAgICAgcmVuZGVyQ3R4LnN0YXRzID0geyBsYXllcnNSZW5kZXJlZDogMCwgbGF5ZXJzU2tpcHBlZDogMCwgbm9kZXNSZW5kZXJlZDogMCwgbm9kZXNTa2lwcGVkOiAwIH07XG4gICAgfVxuICAgIGxldCBjYW52YXNDbGVhcmVkID0gZmFsc2U7XG4gICAgaWYgKCFyb290IHx8IHJvb3QuZGlydHkgPj0gMSAvKiBUUklWSUFMICovKSB7XG4gICAgICBjYW52YXNDbGVhcmVkID0gdHJ1ZTtcbiAgICAgIGNhbnZhcy5jbGVhcigpO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiBEZWJ1Zy5jaGVjayhcInNjZW5lOmRpcnR5VHJlZVwiIC8qIFNDRU5FX0RJUlRZX1RSRUUgKi8pKSB7XG4gICAgICBjb25zdCB7IGRpcnR5VHJlZSwgcGF0aHMgfSA9IGJ1aWxkRGlydHlUcmVlKHJvb3QpO1xuICAgICAgRGVidWcuY3JlYXRlKFwic2NlbmU6ZGlydHlUcmVlXCIgLyogU0NFTkVfRElSVFlfVFJFRSAqLykoXCJTY2VuZS5yZW5kZXIoKSAtIGRpcnR5VHJlZVwiLCB7IGRpcnR5VHJlZSwgcGF0aHMgfSk7XG4gICAgfVxuICAgIGlmIChyb290ICYmIGNhbnZhc0NsZWFyZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW5kZXIoKSAtIGJlZm9yZVwiLCB7XG4gICAgICAgIHJlZHJhd1R5cGU6IFJlZHJhd1R5cGVbcm9vdC5kaXJ0eV0sXG4gICAgICAgIGNhbnZhc0NsZWFyZWQsXG4gICAgICAgIHRyZWU6IGJ1aWxkVHJlZShyb290KVxuICAgICAgfSk7XG4gICAgICBpZiAocm9vdC52aXNpYmxlKSB7XG4gICAgICAgIHJvb3QucHJlUmVuZGVyKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHJvb3QucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnU3BsaXRUaW1lc1tcIlxcdTI3MERcXHVGRTBGXCJdID0gcGVyZm9ybWFuY2Uubm93KCkgLSByZW5kZXJTdGFydFRpbWU7XG4gICAgaWYgKHRoaXMubGF5ZXJzTWFuYWdlci5zaXplICYmIGNhbnZhc0NsZWFyZWQpIHtcbiAgICAgIGNvbnN0IGxheWVyUmVuZGVyU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMubGF5ZXJzTWFuYWdlci5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICBpZiAobGF5ZXIuY2FudmFzLmVuYWJsZWQgJiYgbGF5ZXIuZ2V0VmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGF5ZXIuZ2V0Q29tcHV0ZWRPcGFjaXR5KCk7XG4gICAgICAgICAgbGF5ZXIuY2FudmFzLmRyYXdJbWFnZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBkZWJ1Z1NwbGl0VGltZXNbXCJcXHUyNkQ5XCJdID0gcGVyZm9ybWFuY2Uubm93KCkgLSBsYXllclJlbmRlclN0YXJ0O1xuICAgIH1cbiAgICBjdHgudmVyaWZ5RGVwdGhaZXJvPy4oKTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICBkZWJ1Z1N0YXRzKHRoaXMubGF5ZXJzTWFuYWdlciwgZGVidWdTcGxpdFRpbWVzLCBjdHgsIHJlbmRlckN0eC5zdGF0cywgZXh0cmFEZWJ1Z1N0YXRzLCBzZXJpZXNSZWN0KTtcbiAgICBkZWJ1Z1NjZW5lTm9kZUhpZ2hsaWdodChjdHgsIHJlbmRlckN0eC5kZWJ1Z05vZGVzKTtcbiAgICBpZiAocm9vdCAmJiB0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW5kZXIoKSAtIGFmdGVyXCIsIHtcbiAgICAgICAgcmVkcmF3VHlwZTogUmVkcmF3VHlwZVtyb290LmRpcnR5XSxcbiAgICAgICAgdHJlZTogYnVpbGRUcmVlKHJvb3QpLFxuICAgICAgICBjYW52YXNDbGVhcmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqIEFsdGVybmF0aXZlIHRvIGRlc3Ryb3koKSB0aGF0IHByZXNlcnZlcyByZS11c2FibGUgcmVzb3VyY2VzLiAqL1xuICBzdHJpcCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHRoaXMubGF5ZXJzTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMuc2V0Um9vdChudWxsKTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB0aGlzLmNhbnZhcy5kZXN0cm95KCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IGNhbnZhczogdm9pZCAwIH0pO1xuICB9XG59O1xuU2NlbmUuY2xhc3NOYW1lID0gXCJTY2VuZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NhbGxiYWNrQ2FjaGUudHNcbnZhciBDYWxsYmFja0NhY2hlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgY2FsbChmbiwgLi4ucGFyYW1zKSB7XG4gICAgbGV0IHNlcmlhbGlzZWRQYXJhbXM7XG4gICAgbGV0IHBhcmFtQ2FjaGUgPSB0aGlzLmNhY2hlLmdldChmbik7XG4gICAgdHJ5IHtcbiAgICAgIHNlcmlhbGlzZWRQYXJhbXMgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmludm9rZShmbiwgcGFyYW1zLCBwYXJhbUNhY2hlKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgcGFyYW1DYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmNhY2hlLnNldChmbiwgcGFyYW1DYWNoZSk7XG4gICAgfVxuICAgIGlmICghcGFyYW1DYWNoZS5oYXMoc2VyaWFsaXNlZFBhcmFtcykpIHtcbiAgICAgIHJldHVybiB0aGlzLmludm9rZShmbiwgcGFyYW1zLCBwYXJhbUNhY2hlLCBzZXJpYWxpc2VkUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtQ2FjaGUuZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xuICB9XG4gIGludm9rZShmbiwgcGFyYW1zLCBwYXJhbUNhY2hlLCBzZXJpYWxpc2VkUGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLnBhcmFtcyk7XG4gICAgICBpZiAocGFyYW1DYWNoZSAmJiBzZXJpYWxpc2VkUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1DYWNoZS5zZXQoc2VyaWFsaXNlZFBhcmFtcywgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBVc2VyIGNhbGxiYWNrIGVycm9yZWQsIGlnbm9yaW5nYCwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGludmFsaWRhdGVDYWNoZSgpIHtcbiAgICB0aGlzLmNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbGlzdGVuZXJzLnRzXG52YXIgTGlzdGVuZXJzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IHJlY29yZCA9IHsgc3ltYm9sOiBTeW1ib2woZXZlbnRUeXBlKSwgaGFuZGxlciB9O1xuICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKS5wdXNoKHJlY29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCBbcmVjb3JkXSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUxpc3RlbmVyKHJlY29yZC5zeW1ib2wpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50U3ltYm9sKSB7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgbGlzdGVuZXJzXSBvZiB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBtYXRjaEluZGV4ID0gbGlzdGVuZXJzLmZpbmRJbmRleCgobGlzdGVuZXIpID0+IGxpc3RlbmVyLnN5bWJvbCA9PT0gZXZlbnRTeW1ib2wpO1xuICAgICAgaWYgKG1hdGNoSW5kZXggPj0gMCkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKG1hdGNoSW5kZXgsIDEpO1xuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc3BhdGNoKGV2ZW50VHlwZSwgLi4ucGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lci5oYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci5lcnJvck9uY2UoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc3BhdGNoV3JhcEhhbmRsZXJzKGV2ZW50VHlwZSwgd3JhcEZuLCAuLi5wYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdyYXBGbihsaXN0ZW5lci5oYW5kbGVyLCAuLi5wYXJhbXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRMaXN0ZW5lcnNCeVR5cGUoZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKSA/PyBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9iYXNlTWFuYWdlci50c1xudmFyIEJhc2VNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgfVxuICBhZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGVzdHJveSgpO1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Fubm90YXRpb24vYW5ub3RhdGlvbk1hbmFnZXIudHNcbnZhciBBbm5vdGF0aW9uTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihhbm5vdGF0aW9uUm9vdCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdCA9IGFubm90YXRpb25Sb290O1xuICAgIHRoaXMubWVtZW50b09yaWdpbmF0b3JLZXkgPSBcImFubm90YXRpb25zXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICB9XG4gIGNyZWF0ZU1lbWVudG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbnM7XG4gIH1cbiAgZ3VhcmRNZW1lbnRvKGJsb2IpIHtcbiAgICByZXR1cm4gaXNBcnJheShibG9iKTtcbiAgfVxuICByZXN0b3JlTWVtZW50byhfdmVyc2lvbiwgX21lbWVudG9WZXJzaW9uLCBtZW1lbnRvKSB7XG4gICAgY29uc3QgYW5ub3RhdGlvbnMyID0gdGhpcy5jbGVhbkRhdGEobWVtZW50bykubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9uVGhlbWUgPSB0aGlzLmdldEFubm90YXRpb25UeXBlU3R5bGVzKGFubm90YXRpb24udHlwZSk7XG4gICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhhbm5vdGF0aW9uLCBhbm5vdGF0aW9uVGhlbWUpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicmVzdG9yZS1hbm5vdGF0aW9uc1wiLCB7XG4gICAgICB0eXBlOiBcInJlc3RvcmUtYW5ub3RhdGlvbnNcIixcbiAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9uczJcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVEYXRhKGFubm90YXRpb25zMikge1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB0aGlzLmNsZWFuRGF0YShhbm5vdGF0aW9uczIgPz8gW10pO1xuICB9XG4gIGF0dGFjaE5vZGUobm9kZSkge1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QuYXBwZW5kKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmFubm90YXRpb25Sb290Py5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbiAgc2V0QW5ub3RhdGlvblN0eWxlcyhzdHlsZXMpIHtcbiAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgfVxuICBnZXRBbm5vdGF0aW9uVHlwZVN0eWxlcyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzPy5bdHlwZV07XG4gIH1cbiAgY2xlYW5EYXRhKGFubm90YXRpb25zMikge1xuICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9uczIpIHtcbiAgICAgIGlmIChcInRleHRBbGlnblwiIGluIGFubm90YXRpb24pXG4gICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uLnRleHRBbGlnbjtcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb25zMjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzTWFuYWdlci50c1xudmFyIEF4aXNNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY2VuZVJvb3QpIHtcbiAgICB0aGlzLnNjZW5lUm9vdCA9IHNjZW5lUm9vdDtcbiAgICB0aGlzLmF4ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXhpc0dyaWRHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwiQXhlcy1Hcmlkc1wiLCBsYXllcjogdHJ1ZSwgekluZGV4OiAxIC8qIEFYSVNfR1JJRF9aSU5ERVggKi8gfSk7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcIkF4ZXNcIiwgbGF5ZXI6IHRydWUsIHpJbmRleDogMiAvKiBBWElTX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLnNjZW5lUm9vdC5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JpZEdyb3VwKTtcbiAgfVxuICB1cGRhdGVBeGVzKG9sZEF4ZXMsIG5ld0F4ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2Ygb2xkQXhlcykge1xuICAgICAgaWYgKG5ld0F4ZXMuaW5jbHVkZXMoYXhpcykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgYXhpcy5kZXRhY2hBeGlzKHRoaXMuYXhpc0dyb3VwLCB0aGlzLmF4aXNHcmlkR3JvdXApO1xuICAgICAgYXhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXhpcyBvZiBuZXdBeGVzKSB7XG4gICAgICBpZiAob2xkQXhlcz8uaW5jbHVkZXMoYXhpcykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgYXhpcy5hdHRhY2hBeGlzKHRoaXMuYXhpc0dyb3VwLCB0aGlzLmF4aXNHcmlkR3JvdXApO1xuICAgIH1cbiAgICB0aGlzLmF4ZXMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgbmV3QXhlcykge1xuICAgICAgY29uc3QgY3R4ID0gYXhpcy5jcmVhdGVBeGlzQ29udGV4dCgpO1xuICAgICAgaWYgKHRoaXMuYXhlcy5oYXMoY3R4LmRpcmVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5heGVzLmdldChjdHguZGlyZWN0aW9uKT8ucHVzaChjdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5heGVzLnNldChjdHguZGlyZWN0aW9uLCBbY3R4XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEF4aXNDb250ZXh0KGRpcmVjdGlvbikge1xuICAgIHJldHVybiBbLi4udGhpcy5heGVzLmdldChkaXJlY3Rpb24pID8/IFtdXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYXhlcy5jbGVhcigpO1xuICAgIHRoaXMuc2NlbmVSb290LnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5yZW1vdmVDaGlsZCh0aGlzLmF4aXNHcmlkR3JvdXApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFTZXJ2aWNlLnRzXG52YXIgRGF0YVNlcnZpY2UgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kaXNwYXRjaE9ubHlMYXRlc3QgPSB0cnVlO1xuICAgIHRoaXMuZGlzcGF0Y2hUaHJvdHRsZSA9IDA7XG4gICAgdGhpcy5yZXF1ZXN0VGhyb3R0bGUgPSAzMDA7XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMucmVxdWVzdENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIsIFwiZGF0YS1zb3VyY2VcIik7XG4gICAgdGhpcy50aHJvdHRsZWRGZXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRmV0Y2godGhpcy5yZXF1ZXN0VGhyb3R0bGUpO1xuICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZERpc3BhdGNoKHRoaXMuZGlzcGF0Y2hUaHJvdHRsZSk7XG4gIH1cbiAgdXBkYXRlQ2FsbGJhY2soZGF0YVNvdXJjZUNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhU291cmNlQ2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YVNlcnZpY2UgLSB1cGRhdGVkIGRhdGEgc291cmNlIGNhbGxiYWNrXCIpO1xuICAgIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrID0gZGF0YVNvdXJjZUNhbGxiYWNrO1xuICAgIHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5za2lwKCk7XG4gICAgdGhpcy5kaXNwYXRjaChcImRhdGEtc291cmNlLWNoYW5nZVwiKTtcbiAgfVxuICBjbGVhckNhbGxiYWNrKCkge1xuICAgIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrID0gdm9pZCAwO1xuICB9XG4gIGxvYWQocGFyYW1zKSB7XG4gICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gdHJ1ZTtcbiAgICB0aGlzLnRocm90dGxlZEZldGNoKHBhcmFtcyk7XG4gIH1cbiAgaXNMYXp5KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2VDYWxsYmFjayAhPSBudWxsO1xuICB9XG4gIGlzTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xhenkoKSAmJiAodGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSB8fCB0aGlzLmlzTG9hZGluZ0RhdGEpO1xuICB9XG4gIGNyZWF0ZVRocm90dGxlZEZldGNoKHJlcXVlc3RUaHJvdHRsZSkge1xuICAgIHJldHVybiB0aHJvdHRsZSgocGFyYW1zKSA9PiB0aGlzLmZldGNoKHBhcmFtcyksIHJlcXVlc3RUaHJvdHRsZSwge1xuICAgICAgbGVhZGluZzogZmFsc2UsXG4gICAgICB0cmFpbGluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVRocm90dGxlZERpc3BhdGNoKGRpc3BhdGNoVGhyb3R0bGUpIHtcbiAgICByZXR1cm4gdGhyb3R0bGUoXG4gICAgICAoaWQsIGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSBkaXNwYXRjaGluZyAnZGF0YS1sb2FkJyB8ICR7aWR9YCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLWxvYWRcIiwgeyB0eXBlOiBcImRhdGEtbG9hZFwiLCBkYXRhIH0pO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoVGhyb3R0bGUsXG4gICAgICB7XG4gICAgICAgIGxlYWRpbmc6IHRydWUsXG4gICAgICAgIHRyYWlsaW5nOiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhU2VydmljZSAtIFtkYXRhU291cmNlLmdldERhdGFdIGNhbGxiYWNrIG5vdCBpbml0aWFsaXNlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBpZCA9IHRoaXMucmVxdWVzdENvdW50ZXIrKztcbiAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlcXVlc3RpbmcgfCAke2lkfWApO1xuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cy5wdXNoKGlkKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kYXRhU291cmNlQ2FsbGJhY2socGFyYW1zKTtcbiAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gcmVzcG9uc2UgfCAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXMgfCAke2lkfWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlcXVlc3QgZmFpbGVkIHwgJHtpZH1gKTtcbiAgICAgIExvZ2dlci5lcnJvck9uY2UoYERhdGFTZXJ2aWNlIC0gcmVxdWVzdCBmYWlsZWQgfCBbJHtlcnJvcn1dYCk7XG4gICAgfVxuICAgIHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgPSBmYWxzZTtcbiAgICBjb25zdCByZXF1ZXN0SW5kZXggPSB0aGlzLmZyZXNoUmVxdWVzdHMuZmluZEluZGV4KChyaWQpID0+IHJpZCA9PT0gaWQpO1xuICAgIGlmIChyZXF1ZXN0SW5kZXggPT09IC0xIHx8IHRoaXMuZGlzcGF0Y2hPbmx5TGF0ZXN0ICYmIHJlcXVlc3RJbmRleCAhPT0gdGhpcy5mcmVzaFJlcXVlc3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gZGlzY2FyZGluZyBzdGFsZSByZXF1ZXN0IHwgJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcmVzaFJlcXVlc3RzID0gdGhpcy5mcmVzaFJlcXVlc3RzLnNsaWNlKHJlcXVlc3RJbmRleCArIDEpO1xuICAgIGlmICh0aGlzLmZyZXNoUmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmlzTG9hZGluZ0RhdGEgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICB0aGlzLnRocm90dGxlZERpc3BhdGNoKGlkLCByZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLWVycm9yXCIpO1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShkaXNwYXRjaFRocm90dGxlKSB7XG4gICAgICB0aGlzLnRocm90dGxlZERpc3BhdGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWREaXNwYXRjaChkaXNwYXRjaFRocm90dGxlKTtcbiAgICB9XG4gIH0pXG5dLCBEYXRhU2VydmljZS5wcm90b3R5cGUsIFwiZGlzcGF0Y2hUaHJvdHRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShyZXF1ZXN0VGhyb3R0bGUpIHtcbiAgICAgIHRoaXMudGhyb3R0bGVkRmV0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZEZldGNoKHJlcXVlc3RUaHJvdHRsZSk7XG4gICAgfVxuICB9KVxuXSwgRGF0YVNlcnZpY2UucHJvdG90eXBlLCBcInJlcXVlc3RUaHJvdHRsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3R5bGVzLmNzc1xudmFyIHN0eWxlc19kZWZhdWx0ID0gJy5hZy1jaGFydHMtd3JhcHBlciwuYWctY2hhcnRzLXdyYXBwZXI6Zm9jdXMsLmFnLWNoYXJ0cy13cmFwcGVyOmFmdGVyLC5hZy1jaGFydHMtd3JhcHBlcjpiZWZvcmUsLmFnLWNoYXJ0cy13cmFwcGVyICosLmFnLWNoYXJ0cy13cmFwcGVyICo6Zm9jdXMsLmFnLWNoYXJ0cy13cmFwcGVyICo6YWZ0ZXIsLmFnLWNoYXJ0cy13cmFwcGVyICo6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdXRsaW5lOm5vbmV9LmFnLWNoYXJ0cy13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlfS5hZy1jaGFydHMtY2FudmFzLWNlbnRlcnt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3Bvc2l0aW9uOmFic29sdXRlO3RvdWNoLWFjdGlvbjphdXRvO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczp2YXIoLS1hZy1jaGFydHMtYWxpZ24pO2p1c3RpZnktY29udGVudDp2YXIoLS1hZy1jaGFydHMtanVzdGlmeSl9LmFnLWNoYXJ0cy1jYW52YXMtY29udGFpbmVyLC5hZy1jaGFydHMtY2FudmFze3Bvc2l0aW9uOnJlbGF0aXZlfS5hZy1jaGFydHMtY2FudmFzLWNvbnRhaW5lcj4qLC5hZy1jaGFydHMtY2FudmFzPip7ZGlzcGxheTpibG9ja30uYWctY2hhcnRzLWNhbnZhcy1wcm94eXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0cy10YWItZ3VhcmR7d2lkdGg6MDtoZWlnaHQ6MDtvcGFjaXR5OjB9LmFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheXtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO2luc2V0OjB9LmFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheT4qe3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOmF1dG99LmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0LC5hZy1jaGFydHMtdGhlbWUtZGVmYXVsdC1kYXJrey0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcjogdmFyKC0tYWctYWN0aXZlLWNvbG9yLCAjMjE5NmYzKTstLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKTstLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1mb3JlZ3JvdW5kLWNvbG9yLCAjMTgxZDFmKTstLWFnLWNoYXJ0cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWJvcmRlci1jb2xvciwgI2RkZGRkZCk7LS1hZy1jaGFydHMtZm9udC1mYW1pbHk6IFwiVmVyZGFuYVwiLCBzYW5zLXNlcmlmOy0tYWctY2hhcnRzLWZvbnQtc2l6ZTogdmFyKC0tYWctZm9udC1zaXplLCAxNHB4KTstLWFnLWNoYXJ0cy1zaXplOiB2YXIoLS1hZy1ncmlkLXNpemUsIDhweCk7LS1hZy1jaGFydHMtYm9yZGVyOiB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKSB2YXIoLS1hZy1ib3JkZXJzLCBzb2xpZCAxcHgpOy0tYWctY2hhcnRzLWJvcmRlci1jcml0aWNhbDogdmFyKC0tYWctYm9yZGVycy1jcml0aWNhbCwgc29saWQgMXB4KTstLWFnLWNoYXJ0cy1sYXllci11aS1vdmVybGF5OiA1Oy0tYWctY2hhcnRzLWxheWVyLXRvb2x0aXA6IDQ7LS1hZy1jaGFydHMtbGF5ZXItdG9vbGJhcjogMzstLWFnLWNoYXJ0cy1sYXllci1jcm9zc2hhaXI6IDI7LS1hZy1jaGFydHMtbGF5ZXItYW5ub3RhdGlvbnM6IDE7LS1hZy1jaGFydHMtYWxpZ246IGNlbnRlcjstLWFnLWNoYXJ0cy1qdXN0aWZ5OiBjZW50ZXI7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1iYWNrZ3JvdW5kLWNvbG9yOiAjNDc0NzQ3Oy0tYWctY2hhcnRzLWF4aXMtbGFiZWwtY29sb3I6ICNmZmZmZmY7LS1hZy1jaGFydHMtdG9vbGJhci1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1oZWFkZXItZm9yZWdyb3VuZC1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpKTstLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3I6IHZhciggLS1hZy1oZWFkZXItYmFja2dyb3VuZC1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpIDIlKSApOy0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZTogMzRweDstLWFnLWNoYXJ0cy10b29sYmFyLXNpemUtc21hbGw6IDI0cHg7LS1hZy1jaGFydHMtdG9vbGJhci1ib3JkZXI6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY3JpdGljYWwsIHNvbGlkIDFweCkgdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jb2xvcik7LS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpIDEyJSApOy0tYWctY2hhcnRzLXRvb2xiYXItZm9jdXMtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1jb2xvcjogdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcik7LS1hZy1jaGFydHMtdG9vbGJhci1kaXNhYmxlZC1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoIC0tYWctZGlzYWJsZWQtZm9yZWdyb3VuZC1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb3JlZ3JvdW5kLWNvbG9yKSA1MCUpICk7LS1hZy1jaGFydHMtdG9vbGJhci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb3JlZ3JvdW5kLWNvbG9yKSA2JSApOy0tYWctY2hhcnRzLXRvb2xiYXItZ2FwOiB2YXIoLS1hZy1jaGFydHMtc2l6ZSk7LS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemU6IDEzcHg7LS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemUtc21hbGw6IDEycHg7LS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZzogNnB4Oy0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmctc21hbGw6IDFweDstLWFnLWNoYXJ0cy1wb3BvdmVyLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1ib3JkZXI6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJvcmRlcik7LS1hZy1jaGFydHMtcG9wb3Zlci1hY3RpdmUtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1ob3Zlci1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWZvbnQtc2l6ZS1zbWFsbDogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplLXNtYWxsKTstLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzOiB2YXIoLS1hZy1ib3JkZXItcmFkaXVzLCA0cHgpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1jb2xvcjogdmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSk7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyOiBzb2xpZCAxcHggdmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1jb2xvcik7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdzogdmFyKCAtLWFnLWlucHV0LWZvY3VzLWJveC1zaGFkb3csIDAgMCAwIDNweCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikpIDIwJSkgKTstLWFnLWNoYXJ0cy1pY29uLWZvbnQtZmFtaWx5OiBcImFnQ2hhcnRzRGVmYXVsdFwiOy0tYWctY2hhcnRzLWljb24tZm9udC13ZWlnaHQ6IG5vcm1hbDstLWFnLWNoYXJ0cy1pY29uLWZvbnQtY29sb3I6IGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpLCA5MCUpOy0tYWctY2hhcnRzLWljb24tc2l6ZTogMjBweDstLWFnLWNoYXJ0cy10ZXh0LWFubm90YXRpb25zLXBsYWNlaG9sZGVyOiAjODg4ODg4fS5hZy1jaGFydHMtdGhlbWUtZGVmYXVsdC1kYXJrey0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCAjZmZmLCAjMTgyMjMwIDk3JSkpOy0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWZvcmVncm91bmQtY29sb3IsICNmZmYpOy0tYWctY2hhcnRzLWJvcmRlci1jb2xvcjogdmFyKC0tYWctYm9yZGVyLWNvbG9yLCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4xNikpOy0tYWctY2hhcnRzLWhvdmVyLWNvbG9yOiB2YXIoIC0tYWctcm93LWhvdmVyLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpIDIwJSkgKTstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWJhY2tncm91bmQtY29sb3I6ICM5Y2FlYmI7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1jb2xvcjogIzAwMDAwMDstLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgI2ZmZiwgIzE4MjIzMCA5MyUpKTstLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMTglICk7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdzogdmFyKCAtLWFnLWlucHV0LWZvY3VzLWJveC1zaGFkb3csIDAgMCAwIDNweCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikpIDIwJSkgKTstLWFnLWNoYXJ0cy10ZXh0LWFubm90YXRpb25zLXBsYWNlaG9sZGVyOiAjYWFhYWFhfS5hZy1jaGFydHMtaWNvbntkaXNwbGF5OmJsb2NrO3dpZHRoOnZhcigtLWFnLWNoYXJ0cy1pY29uLXNpemUpO2hlaWdodDp2YXIoLS1hZy1jaGFydHMtaWNvbi1zaXplKTtzcGVhazpub25lO3NwZWFrOm5ldmVyO21hc2s6dmFyKC0taWNvbikgY2VudGVyIC8gY29udGFpbiBuby1yZXBlYXQ7YmFja2dyb3VuZC1jb2xvcjpjdXJyZW50Q29sb3I7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXR9LmFnLWNoYXJ0cy1pY29uLWNhbGxvdXQtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk15QTBMalZCTVM0MUlERXVOU0F3SURBZ01TQTBMalVnTTJneE1VRXhMalVnTVM0MUlEQWdNQ0F4SURFM0lEUXVOWFk0WVRFdU5TQXhMalVnTUNBd0lERXRNUzQxSURFdU5XZ3ROQzQxTVRSaE1qWWdNallnTUNBd0lEQXRNaTR3TVRjZ01TNDFOR3d0TGpNeE5DNHlObU10TGpVMUxqUTFOeTB4TGpFeE5TNDVNall0TVM0M05pQXhMalF0TGpZMk9TNDBPVEV0TVM0MU5qSXRMakF4TWkweExqVTJNaTB1T0ZZeE5FZzBMalZCTVM0MUlERXVOU0F3SURBZ01TQXpJREV5TGpWNlRUUXVOU0EwWVM0MUxqVWdNQ0F3SURBdExqVXVOWFk0WVM0MUxqVWdNQ0F3SURBZ0xqVXVOV2d4TGpnek0zWXpMak0zTW1Fek5pQXpOaUF3SURBZ01DQXhMalkzT0MweExqTXpPR3d1TXpJdExqSTJOV0V5TmlBeU5pQXdJREFnTVNBeUxqSXlOUzB4TGpZNE5Xd3VNVEkyTFM0d09EUklNVFV1TldFdU5TNDFJREFnTUNBd0lDNDFMUzQxZGkwNFlTNDFMalVnTUNBd0lEQXRMalV0TGpWNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1jYW5kbGVzdGljay1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnlBeGRqTm9Nbll4TWtnM2RqTklObll0TTBnMFZqUm9NbFl4ZWswMUlEVm9NM1l4TUVnMWVrMHhNU0F4TkZZMmFESldNeTR5TldneFZqWm9Nblk0YUMweWRqSXVOelZvTFRGV01UUjZiVEV0TjJnemRqWm9MVE42SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWNvbW1lbnQtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55NDFNVE1nTXk0NU9UVmhOaTQxSURZdU5TQXdJREFnTVNBMkxqQTVPQ0F4TVM0ME1XTXRMalU0T0M0ek9UTXRNUzR5TVRjdU5UTTJMVEV1T0RJNUxqVTROV0V4TXlBeE15QXdJREFnTVMweExqSTNMakF4TjBFeU55QXlOeUF3SURBZ01DQXhNQ0F4TmtnMExqVmhMalV1TlNBd0lEQWdNUzB1TlMwdU5WWXhNSEV3TFM0eU5EY3RMakF3TnkwdU5URXpZeTB1TURBNExTNDBNVFl0TGpBeE5pMHVPRFUzTGpBeE55MHhMakkyT1M0d05TMHVOakV5TGpFNU1pMHhMakkwTGpVNE5TMHhMamd6WVRZdU5TQTJMalVnTUNBd0lERWdNaTQ1TVRndE1pNHpPVE50TXk0MU5pNDJNV0UxTGpVZ05TNDFJREFnTUNBd0xUVXVOalEySURJdU16UmpMUzR5TmpZdU16azNMUzR6TnprdU9EUXlMUzQwTWlBeExqTTFOQzB1TURNdU16WXRMakF5TWk0M01UZ3RMakF4TlNBeExqRXdPRkUxSURrdU5qZzVJRFVnTVRCMk5XZzFjUzR6TVRFdU1EQXhMalU1TXk0d01EaGpMak01TGpBd055NDNORGN1TURFMUlERXVNVEE0TFM0d01UVXVOVEV5TFM0d05ERXVPVFUzTFM0eE5UUWdNUzR6TlRVdExqUXlZVFV1TlNBMUxqVWdNQ0F3SURBdE1TNDVPRE10T1M0NU5qY2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tY3Jvc3NoYWlyLWFkZC1saW5ley0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVEV3SURVdU5XRXVOUzQxSURBZ01DQXhJQzQxTGpWMk15NDFhRE11T0RjMVlTNDFMalVnTUNBd0lERWdNQ0F4U0RFd0xqVjJOQzR5TldFdU5TNDFJREFnTVNBeExURWdNRll4TUM0MVNEVXVOakkxWVM0MUxqVWdNQ0F4SURFZ01DMHhTRGt1TlZZMllTNDFMalVnTUNBd0lERWdMalV0TGpVaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWRlbGV0ZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWkQwaVRUZ3VORGsySURndU9UazJRUzQxTGpVZ01DQXdJREVnT1NBNUxqUTVNblkwWVM0MUxqVWdNQ0F4SURFdE1TQXVNREE0ZGkwMFlTNDFMalVnTUNBd0lERWdMalE1TmkwdU5UQTBUVEV5SURrdU5XRXVOUzQxSURBZ01DQXdMVEVnTUhZMFlTNDFMalVnTUNBd0lEQWdNU0F3ZWlJdlBqeHdZWFJvSUdacGJHdzlJaU14TXpFM01qSWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUWWdOVll6TGpWQk1pNDFJREl1TlNBd0lEQWdNU0E0TGpVZ01XZ3pRVEl1TlNBeUxqVWdNQ0F3SURFZ01UUWdNeTQxVmpWb01pNDRNek5oTGpVdU5TQXdJREFnTVNBd0lERklNVFYyTVRBdU1qVmpNQ0F1TkRFMUxTNHdOall1T0RZekxTNHpJREV1TWpJeExTNHlOVGN1TXprMExTNDJOekl1TmpFeUxURXVNaTQyTVRKb0xUZGpMUzQxTWpnZ01DMHVPVFF6TFM0eU1UZ3RNUzR5TFM0Mk1USXRMakl6TkMwdU16VTRMUzR6TFM0NE1EWXRMak10TVM0eU1qRldOa2d6TGpNek0yRXVOUzQxSURBZ01DQXhJREF0TVhwdE1TMHhMalZCTVM0MUlERXVOU0F3SURBZ01TQTRMalVnTW1nelFURXVOU0F4TGpVZ01DQXdJREVnTVRNZ015NDFWalZJTjNwTk5pQXhOaTR5TlZZMmFEaDJNVEF1TWpWak1DQXVNek0xTFM0d05Ua3VOVFUwTFM0eE16Z3VOamMxTFM0d05UVXVNRGcxTFM0eE5DNHhOVGd0TGpNMk1pNHhOVGhvTFRkakxTNHlNaklnTUMwdU16QTNMUzR3TnpNdExqTTJNaTB1TVRVNExTNHdPQzB1TVRJeExTNHhNemd0TGpNMExTNHhNemd0TGpZM05TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLC5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRrdU1ESTRJREUzTGpRMllUSXVNalVnTWk0eU5TQXdJREFnTUMwMExqQTVNaTB4TGpnMWJDMDVMalV4TVMweUxqTTNPR0V5TGpJMUlESXVNalVnTUNBeElEQXRMakl5TlM0NU56UnNPUzQwTnpVZ01pNHpOamxoTWk0eU5URWdNaTR5TlRFZ01DQXdJREFnTkM0ek5UTXVPRGcyYlMweExqWTJNaTB4TGprMk5XRXhMakkxSURFdU1qVWdNQ0F4SURFdExqZzROU0F5TGpNek9DQXhMakkxSURFdU1qVWdNQ0F3SURFZ0xqZzROUzB5TGpNek9FMDBMak0wTXlBeE15NDJOamxoTVM0eU5TQXhMakkxSURBZ01TQXdMVEl1TXpNNExTNDRPRFVnTVM0eU5TQXhMakkxSURBZ01DQXdJREl1TXpNNExqZzROVTB6TGprM0lEZ3VOelk1WVRJdU1qVWdNaTR5TlNBd0lEQWdNQ0F4TGpRMU5TMHlMakV4YkRrdU5URXhMVEl1TXpjNFlUSXVNalVnTWk0eU5TQXdJREVnTUMwdU1qWXRMamsyTlV3MUxqSWdOUzQyT0RWaE1pNHlOU0F5TGpJMUlEQWdNU0F3TFRFdU1qTWdNeTR3T0RSdExqTTNNeTB5TGpVME4yRXhMakkxSURFdU1qVWdNQ0F4SURFdE1pNHpNemd1T0RnMUlERXVNalVnTVM0eU5TQXdJREFnTVNBeUxqTXpPQzB1T0RnMWJURXpMamMxTFRNdU5ETTRZVEV1TWpVZ01TNHlOU0F3SURFZ01TMHlMak16T0M0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBeElESXVNek00TFM0NE9EVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24taG9sbG93LWNhbmRsZXN0aWNrLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXZjR0ZqYVhSNVBTSXVNVFVpSUdROUlrMDFJRFZvTTNZeE1FZzFlaUl2UGp4d1lYUm9JR1pwYkd3OUlpTXhNekUzTWpJaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRjZ01YWXphREoyTVRKSU4zWXpTRFoyTFROSU5GWTBhREpXTVhwTk5TQTFhRE4yTVRCSU5YcHROeUF5YUROMk5tZ3RNM3B0TFRFZ04xWTJhREpXTXk0eU5XZ3hWalpvTW5ZNGFDMHlkakl1TnpWb0xURldNVFI2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWhvcml6b250YWwtbGluZSwuYWctY2hhcnRzLWljb24taG9yaXpvbnRhbC1saW5lLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTGpVZ09TNDFhRGN1TXpBMllUSXVNalVnTWk0eU5TQXdJREFnTVNBMExqTTRPQ0F3U0RFNUxqVjJNV2d0Tnk0ek1EWmhNaTR5TlNBeUxqSTFJREFnTUNBeExUUXVNemc0SURCSUxqVjZiVGt1TlNBeExqYzFZVEV1TWpVZ01TNHlOU0F3SURFZ01DQXdMVEl1TlNBeExqSTFJREV1TWpVZ01DQXdJREFnTUNBeUxqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tbGluZS1jb2xvcnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UUXVNalF5SURJdU56SXlZeTB1TmpFeUlEQXRNUzR5TGpJME15MHhMall6TWk0Mk56VnNMVEV1TXpReklERXVNelEwWVM0MUxqVWdNQ0F3SURBdExqRXhNaTR4TVRKTU5DNHdOU0F4TVM0NU5UbGpMUzR5TURjdU1qQTNMUzR6Tmk0ME5pMHVORFEyTGpjMGRpNHdNREZzTFM0Mk9TQXlMamMyTjNZdU1EQXlZUzQ0TWk0NE1pQXdJREFnTUNBeExqQXlNaUF4TGpBeU1XZ3VNREF5YkRJdU5qTTBMUzQ0TWpKakxqSTRMUzR3T0RVdU5UTTBMUzR5TXpjdU56UXRMalEwTTJ3M0xqRXdOeTAzTGpFd09HRXVOUzQxSURBZ01DQXdJQzR4TVRJdExqRXhNbXd4TGpNME15MHhMak0wTTJFeUxqTXdPQ0F5TGpNd09DQXdJREFnTUMweExqWXpNaTB6TGprMFRURTBMakV5TWlBM2JERXVNRFEwTFRFdU1EUTFZVEV1TXpBNElERXVNekE0SURBZ01TQXdMVEV1T0RRNUxURXVPRFZNTVRJdU1qY3hJRFV1TVRWNmJTMHlMalUxT0MweExqRTBNaTAyTGpnd055QTJMamd3T1dFdU9DNDRJREFnTUNBd0xTNHhPVFl1TXpJMWJDMHVOelVnTWk0ME5qZ2dNaTQwTnkwdU56UTVZUzQ0TGpnZ01DQXdJREFnTGpNeU5TMHVNVGswYkRZdU9EQTRMVFl1T0RGNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1saW5lLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRNVGN1TXpZeUlEUXVPRGN6TFRRdU5UazBJRFl1TmpVMExUUXVPRFV0TXk0ek1UY3ROQzR5TlRFZ05pNDVOemN0TGpnMU5DMHVOVEpNTnk0Mk1USWdOaTQzT1d3MExqZzVPU0F6TGpNMUlEUXVNREk0TFRVdU9ETTJlaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tbGluZS13aXRoLW1hcmtlcnMtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE1UZ3VNVGs0SURRdU9EZzRMVE11TlRVMklEUXVPVEU0WVRJdU1qVWdNaTR5TlNBd0lERWdNUzB6TGpnMk5pNDNOV3d0TVM0ME16SXRMamxoTWk0eU5DQXlMakkwSURBZ01DQXhMVEl1TURBNUxqUXpOV3d0TXk0NE1qZ2dOaTQwTWpndExqZzJMUzQxTVRKTU5pNDBOU0E1TGpZeU0yRXlMakkxSURJdU1qVWdNQ0F4SURFZ015NDFNUzB1TnpZeGJERXVNekk1TGpnek5XRXlMakkwSURJdU1qUWdNQ0F3SURFZ01pNDFOVGN0TGpRNU4yd3pMalUwTWkwMExqZzVPSHB0TFRRdU9UWWdOUzR4TlROaE1TNHlOU0F4TGpJMUlEQWdNU0F3TFM0Mk5DQXlMalF4T1NBeExqSTFJREV1TWpVZ01DQXdJREFnTGpZMExUSXVOREU1VFRrdU1TQTRMak15TVhFdU1EWTJMUzR4T1RJdU1EWTNMUzQwTURSaE1TNHlOU0F4TGpJMUlEQWdNU0F3TFM0d05qY3VOREEwSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxvY2ssLmFnLWNoYXJ0cy1pY29uLWxvY2tlZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UQXVNakEzSURNdU56WTBZVEl1T0RrMElESXVPRGswSURBZ01DQXdMVEl1T0RrMUlESXVPRGswVmpsb05TNDNPRGxXTmk0Mk5UaGhNaTQ0T1RRZ01pNDRPVFFnTUNBd0lEQXRNaTQ0T1RVdE1pNDRPVFJOTVRRdU1TQTVWall1TmpVNFlUTXVPRGswSURNdU9EazBJREFnTVNBd0xUY3VOemc1SURCMk1pNHpORGxCTWk0MUlESXVOU0F3SURBZ01DQTBJREV4TGpWMk0wRXlMalVnTWk0MUlEQWdNQ0F3SURZdU5TQXhOMmc0WVRJdU5TQXlMalVnTUNBd0lEQWdNaTQxTFRJdU5YWXRNMEV5TGpVZ01pNDFJREFnTUNBd0lERTBMalVnT1hwTk5pNDFJREV3UVRFdU5TQXhMalVnTUNBd0lEQWdOU0F4TVM0MWRqTkJNUzQxSURFdU5TQXdJREFnTUNBMkxqVWdNVFpvT0dFeExqVWdNUzQxSURBZ01DQXdJREV1TlMweExqVjJMVE5oTVM0MUlERXVOU0F3SURBZ01DMHhMalV0TVM0MWVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1ub3RlLWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NeUEwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0EwTGpVZ00yZ3hNVUV4TGpVZ01TNDFJREFnTUNBeElERTNJRFF1TlhZNFlURXVOU0F4TGpVZ01DQXdJREV0TVM0MUlERXVOV2d0TXk0eU1Xd3RNUzQwTmprZ01pNDFOMkV4SURFZ01DQXdJREV0TVM0Mk9ESXVNRGcxVERjdU1qUXpJREUwU0RRdU5VRXhMalVnTVM0MUlEQWdNQ0F4SURNZ01USXVOWHBOTkM0MUlEUmhMalV1TlNBd0lEQWdNQzB1TlM0MWRqaGhMalV1TlNBd0lEQWdNQ0F1TlM0MWFETXVNalUzYkRJdU1UazJJRE11TURjMFRERXhMamN4SURFemFETXVOemxoTGpVdU5TQXdJREFnTUNBdU5TMHVOWFl0T0dFdU5TNDFJREFnTUNBd0xTNDFMUzQxZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5pNDFJRFl1TlVFdU5TNDFJREFnTUNBeElEY2dObWcyWVM0MUxqVWdNQ0F3SURFZ01DQXhTRGRoTGpVdU5TQXdJREFnTVMwdU5TMHVOVTAyTGpVZ09TNDFRUzQxTGpVZ01DQXdJREVnTnlBNWFEWmhMalV1TlNBd0lEQWdNU0F3SURGSU4yRXVOUzQxSURBZ01DQXhMUzQxTFM0MUlpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1vaGxjLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWkQwaVRURXpJREV4YUMwemRpMHhhRE5XTTJneGRqSm9OSFl4YUMwMGRqRXhhQzB4ZWswMklERTNkaTB5YUROMkxURklObFkwU0RWMk1VZ3lkakZvTTNZeE1Yb2lMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1maWxsLWNvbG9yey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0T0M0d056RWdOQzR3TmkwdU9USTBMUzQ1TWpRdU56QTNMUzQzTURjZ055NHlPRGdnTnk0eU9EZ3ROQzQ1TlNBMExqazFZVE11TlNBekxqVWdNQ0F3SURFdE5DNDVOU0F3YkMweExqUXhOQzB4TGpReE5HRXpMalVnTXk0MUlEQWdNQ0F4SURBdE5DNDVOWHB0TGpjd055NDNNRGhNTkM0MU16WWdPUzR3TVdFeUxqVWdNaTQxSURBZ01DQXdJREFnTXk0MU16Wk1OUzQ1TlNBeE15NDVObUV5TGpVZ01pNDFJREFnTUNBd0lETXVOVE0xSURCc05DNHlORE10TkM0eU5ETjZiVFl1T1NBM0xqSXdNaTB1TXpRMUxqTTJNeTB1TXpRMExTNHpOak5oTGpVdU5TQXdJREFnTVNBdU5qZzRJREJ0TFM0ek5EVWdNUzR3T0dFNElEZ2dNQ0F3SURBdExqSTRMak15TXlBMExqTWdOQzR6SURBZ01DQXdMUzQwTURrdU5UZ3lZeTB1TVRFekxqSXdNUzB1TVRRMExqTXlOaTB1TVRRMExqTTNPR0V1T0RNekxqZ3pNeUF3SURBZ01DQXhMalkyTnlBd1l6QXRMakExTWkwdU1ETXhMUzR4TnpjdExqRTBOQzB1TXpjNFlUUXVNeUEwTGpNZ01DQXdJREF0TGpReExTNDFPRElnT0NBNElEQWdNQ0F3TFM0eU9DMHVNekl5YlMwdU16UTBMVEV1TURndU16UTBMak0yTXk0ek5EUXRMak0yTXk0d01ESXVNREF5TGpBd05DNHdNRFF1TURFekxqQXhNbUUySURZZ01DQXdJREVnTGpJd05pNHlNRGhqTGpFek1TNHhNell1TXpBNExqTXlOeTQwT0RVdU5UUTFMakUzTmk0eU1UVXVNell6TGpRMk55NDFNRGN1TnpJMExqRXpOeTR5TkRNdU1qY3pMalUxTXk0eU56TXVPRFk0WVRFdU9ETXpJREV1T0RNeklEQWdNU0F4TFRNdU5qWTNJREJqTUMwdU16RTFMakV6TmkwdU5qSTFMakkzTXkwdU9EWTRMakUwTkMwdU1qVTNMak16TFM0MU1Ea3VOVEEzTFM0M01qUmhPU0E1SURBZ01DQXhJQzQyTkRVdExqY3dPR3d1TURRMkxTNHdORFV1TURFekxTNHdNVEl1TURBMExTNHdNRFI2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1lbmR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaWJUWXVOalEySURFekxqZ3hNeTB1TXpVekxqTTFOQzQzTURjdU56QTNMak0xTkMwdU16VTBlazB4TVM0eE5qWWdNVEJzTGpNMU5DNHpOVFF1TXpVMExTNHpOVFF0TGpNMU5DMHVNelUwZWswM0xqTTFOU0ExTGpRNElEY2dOUzR4TWpac0xTNDNNRGN1TnpBM0xqTTFNeTR6TlRSNmJUQWdPUzR3TkNBMExqRTJOaTAwTGpFMk5pMHVOekEzTFM0M01EZ3ROQzR4TmpjZ05DNHhOamQ2YlRRdU1UWTJMVFF1T0RjMFREY3VNelUwSURVdU5EaHNMUzQzTURndU56QTNJRFF1TVRZM0lEUXVNVFkzZWsweE15NHdPRE1nTlhZeE1HZ3hWalY2SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcGFuLWxlZnR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEl1TnprZ05TNDRNek1nT0M0Mk1qVWdNVEJzTkM0eE5qWWdOQzR4TmpjdExqY3dOeTQzTURkTU55NHlNU0F4TUd3MExqZzNNeTAwTGpnM05Ib2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFuLXJpZ2h0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnk0eU1TQXhOQzR4TmpjZ01URXVNemMySURFd0lEY3VNakVnTlM0NE16TnNMamN3TnkwdU56QTNUREV5TGpjNUlERXdiQzAwTGpnM015QTBMamczTkhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tc3RhcnR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaVRUWWdOWFl4TUdneFZqVjZUVGt1TmpJMElERXdiRFF1TVRZMkxUUXVNVFkzTFM0M01EY3RMamN3TjB3NExqSXhJREV3YkRRdU9EYzBJRFF1T0RjMExqY3dOeTB1TnpBM2VpSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYXJhbGxlbC1jaGFubmVsLC5hZy1jaGFydHMtaWNvbi1wYXJhbGxlbC1jaGFubmVsLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRjdU56SWdOUzR6TXpGQk1pNHlOU0F5TGpJMUlEQWdNU0F3SURFMExqY3dOU0F6TGpac0xUa3VORGtnTkM0MU5qSmhNaTR5TlNBeUxqSTFJREFnTVNBd0lDNHlNRGtnTVM0d01XdzVMalkyTWkwMExqWTBObUV5TGpJMUlESXVNalVnTUNBd0lEQWdNaTQyTXpRdU9EQTFiUzR6TnpNdE1pNDFORGRoTVM0eU5TQXhMakkxSURBZ01TQXhMVEl1TXpNNExqZzROU0F4TGpJMUlERXVNalVnTUNBd0lERWdNaTR6TXpndExqZzROVTAwTGpNME15QTRMalkzWVRFdU1qVWdNUzR5TlNBd0lERWdNUzB5TGpNek9DNDRPRFVnTVM0eU5TQXhMakkxSURBZ01DQXhJREl1TXpNNExTNDRPRFZOTlM0ek1EY2dNVFl1TnpJNFlUSXVNalVnTWk0eU5TQXdJREVnTVMwdU5USTFMUzQ0TlRoc09TNDVNak10TkM0M04yRXlMakkxSURJdU1qVWdNQ0F4SURFZ0xqTTRNUzQ1TWpaNmJTMHVPVFkwTGpJM05HRXhMakkxSURFdU1qVWdNQ0F4SURFdE1pNHpNemd1T0RnMUlERXVNalVnTVM0eU5TQXdJREFnTVNBeUxqTXpPQzB1T0RnMWJURXpMakF5TXkwMUxqRXdObUV4TGpJMUlERXVNalVnTUNBeElEQXRMamc0TlMweUxqTXpPU0F4TGpJMUlERXVNalVnTUNBd0lEQWdMamc0TlNBeUxqTXpPU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcHJpY2UtbGFiZWwtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5DNDFJRE5CTVM0MUlERXVOU0F3SURBZ01DQXpJRFF1TlZZeE0yRXhMalVnTVM0MUlEQWdNQ0F3SURFdU5TQXhMalZvTGpnek0zWXVNRFUzWXk0eU5ESXRMakk1T1M0MU9UY3RMalV3TXlBeExTNDFORGhXTVRNdU5VZzBMalZCTGpVdU5TQXdJREFnTVNBMElERXpWalF1TldFdU5TNDFJREFnTUNBeElDNDFMUzQxYURFeFlTNDFMalVnTUNBd0lERWdMalV1TlhZNFlTNDFMalVnTUNBd0lERXRMalV1TldndE5DNDRNVGhzTFM0eE1qWXVNRGcwWVRJMklESTJJREFnTUNBd0xUSXVNakkxSURFdU5qZzFiQzB1TXpJdU1qWTFMUzR3TmpndU1EVTJZVEV1TlNBeExqVWdNQ0F3SURFdE1pNDJNRGtnTVM0ek5UUmpMakF6TXk0M05qTXVPVEExSURFdU1qTTRJREV1TlRZdU56VTJMalkwTmkwdU5EYzBJREV1TWpFdExqazBNeUF4TGpjMk1TMHhMalJzTGpNeE15MHVNalpCTWpZZ01qWWdNQ0F3SURFZ01UQXVPVGcySURFMFNERTFMalZoTVM0MUlERXVOU0F3SURBZ01DQXhMalV0TVM0MWRpMDRRVEV1TlNBeExqVWdNQ0F3SURBZ01UVXVOU0F6ZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5PQzQzTVRZZ01UUXVPREUxWVRJdU1qVWdNaTR5TlNBd0lERWdNUzAwTGpJeElERXVOVGt6SURJdU1qVWdNaTR5TlNBd0lEQWdNU0EwTGpJeExURXVOVGt6YlMweExqWTJNaUF4TGprMk5tRXhMakkxSURFdU1qVWdNQ0F4SURBdExqZzROUzB5TGpNek9TQXhMakkxSURFdU1qVWdNQ0F3SURBZ0xqZzROU0F5TGpNek9TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1yZXNldHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1USXVNRFFnTkM0ME5EVmhOUzQ0TVNBMUxqZ3hJREFnTUNBd0xUY3VNalUzSURJdU5EVXpMalV1TlNBd0lEQWdNUzB1T0RZMUxTNDFNREpCTmk0NE1TQTJMamd4SURBZ01TQXhJRE1nT1M0NE1UTmhMalV1TlNBd0lEQWdNU0F4SURBZ05TNDRNU0ExTGpneElEQWdNU0F3SURndU1EUXROUzR6TmpnaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQanh3WVhSb0lHWnBiR3c5SWlNd01EQWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUUXVNamc1SURNdU1EQXlZUzQxTGpVZ01DQXdJREVnTGpVdU5YWXlMalkxTldneUxqWTFOV0V1TlM0MUlEQWdNQ0F4SURBZ01VZzBMakk1WVM0MUxqVWdNQ0F3SURFdExqVXRMalZXTXk0MU1ESmhMalV1TlNBd0lEQWdNU0F1TlMwdU5TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1zdGVwLWxpbmUtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekU0TVVReFJpSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5pQTBhRFYyT0dnelZqaG9OWFl4YUMwMGRqUm9MVFZXTlVnM2RqRXdTREoyTFRGb05Ib2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdGV4dC1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMElEUklNVFpXTjBneE5WWTFTREV3TGpWV01UVklNVFJXTVRaSU5sWXhOVWc1TGpWV05VZzFWamRJTkZZMFdpSWdabWxzYkQwaVlteGhZMnNpTHo0S1BDOXpkbWMrQ2c9PSl9LmFnLWNoYXJ0cy1pY29uLXRyZW5kLWxpbmUsLmFnLWNoYXJ0cy1pY29uLXRyZW5kLWxpbmUtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OUzR6TVRRZ01UQXVPVE00WVRJdU1qVWdNaTR5TlNBd0lERWdNU0F1TURFdE1XZzVMak0xTW1FeUxqSTFJREl1TWpVZ01DQXhJREVnTGpBeElERjZiUzB5TGpFNE9TNDNNamxoTVM0eU5TQXhMakkxSURBZ01TQXdJREF0TWk0MUlERXVNalVnTVM0eU5TQXdJREFnTUNBd0lESXVOVzB4TXk0M05TQXdZVEV1TWpVZ01TNHlOU0F3SURFZ01DQXdMVEl1TlNBeExqSTFJREV1TWpVZ01DQXdJREFnTUNBeUxqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdW5sb2NrLC5hZy1jaGFydHMtaWNvbi11bmxvY2tlZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UQXVOalV4SURNdU5XRXlMamc1TkNBeUxqZzVOQ0F3SURBZ01DMHlMamc1TkNBeUxqZzVORlk1U0RFMExqVmhNaTQxSURJdU5TQXdJREFnTVNBeUxqVWdNaTQxZGpOaE1pNDFJREl1TlNBd0lEQWdNUzB5TGpVZ01pNDFhQzA0UVRJdU5TQXlMalVnTUNBd0lERWdOQ0F4TkM0MWRpMHpRVEl1TlNBeUxqVWdNQ0F3SURFZ05pNDFJRGxvTGpJMU4xWTJMak01TkdFekxqZzVOQ0F6TGpnNU5DQXdJREVnTVNBM0xqYzRPU0F3SUM0MUxqVWdNQ0F3SURFdE1TQXdRVEl1T0RrMElESXVPRGswSURBZ01DQXdJREV3TGpZMUlETXVOVTAyTGpVZ01UQkJNUzQxSURFdU5TQXdJREFnTUNBMUlERXhMalYyTTBFeExqVWdNUzQxSURBZ01DQXdJRFl1TlNBeE5tZzRZVEV1TlNBeExqVWdNQ0F3SURBZ01TNDFMVEV1TlhZdE0yRXhMalVnTVM0MUlEQWdNQ0F3TFRFdU5TMHhMalY2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXZlcnRpY2FsLWxpbmUsLmFnLWNoYXJ0cy1pY29uLXZlcnRpY2FsLWxpbmUtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEF1TlNBM0xqZ3dObUV5TGpJMUlESXVNalVnTUNBd0lERWdNQ0EwTGpNNE9GWXhPUzQxYUMweGRpMDNMak13Tm1FeUxqSTFJREl1TWpVZ01DQXdJREVnTUMwMExqTTRPRll1TldneGVtMHRMalV1T1RRMFlURXVNalVnTVM0eU5TQXdJREVnTVNBd0lESXVOU0F4TGpJMUlERXVNalVnTUNBd0lERWdNQzB5TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi16b29tLWluey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVEV3SURVdU5XRXVOUzQxSURBZ01DQXhJQzQxTGpWMk15NDFhRE11T0RjMVlTNDFMalVnTUNBd0lERWdNQ0F4U0RFd0xqVjJOQzR5TldFdU5TNDFJREFnTVNBeExURWdNRll4TUM0MVNEVXVOakkxWVM0MUxqVWdNQ0F4SURFZ01DMHhTRGt1TlZZMllTNDFMalVnTUNBd0lERWdMalV0TGpVaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTlM0MUlERXdZUzQxTGpVZ01DQXdJREVnTGpVdExqVm9PR0V1TlM0MUlEQWdNQ0F4SURBZ01VZzJZUzQxTGpVZ01DQXdJREV0TGpVdExqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24taGlnaC1sb3ctc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55QTBhREoyTVRKSU5GWTBhRE5OTlNBMWFETjJNVEJJTlhwTk1URWdNVFJXTm1nMWRqaG9MVFZ0TVMwM2FETjJObWd0TTNvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1obGMtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE1UZ3VNVFl6SURFdU9ETTNMVFV1TXpNMElERXhMall5TVV3MkxqazFOeUE0TGpFeWJDMDBMakU1T1NBNUxqWXlNaTB1T1RFMkxTNDBJRFF1TnpVMkxURXdMamxNTVRJdU5Ea2dNVEV1T0NBeE55NHlOVFFnTVM0ME1ub2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp4d1lYUm9JR1pwYkd3OUlpTXdNREFpSUdacGJHd3RiM0JoWTJsMGVUMGlMalFpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVFV1T0RJMUlESXVOekEwTGpVMUlERXpMamM0Tld3dU9UQXlMalF6SURRdU56STBMVGt1T1RFNUlEWXVNRE0wSURVdU1ESTVJRE11TWpVMUxUZ3VNVFF0TGpreU9DMHVNemN0TWk0M05EVWdOaTQ0Tm5wdE55NDROVElnTVRRdU5qTTJJRFV1TnpndE1UTXVNVE01TFM0NU1UVXRMalF3TWkwMUxqSXhPU0F4TVM0NE5pMDJMakF3TlMwMUxqVXdOQzB6TGpJM09DQTNMalkwT0M0NU1pNHpPVFFnTWk0M01qSXROaTR6TlRKNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLWluLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswNExqYzFJRFF1TldFdU56VXVOelVnTUNBd0lEQXRNUzQxSURCMk1pNDNOVWcwTGpWaExqYzFMamMxSURBZ01DQXdJREFnTVM0MWFESXVOelYyTWk0M05XRXVOelV1TnpVZ01DQXdJREFnTVM0MUlEQldPQzQzTldneUxqYzFZUzQzTlM0M05TQXdJREFnTUNBd0xURXVOVWc0TGpjMVZqUXVOVm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswekxqYzFJRGhoTGpjMUxqYzFJREFnTUNBeElDNDNOUzB1TnpWb04yRXVOelV1TnpVZ01DQXdJREVnTUNBeExqVm9MVGRCTGpjMUxqYzFJREFnTUNBeElETXVOelVnT0ZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLWluLWFsdCwuYWctY2hhcnRzLWljb24tem9vbS1pbi1hbHQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExYcHZiMjB0YVc0aVBqeGphWEpqYkdVZ1kzZzlJakV4SWlCamVUMGlNVEVpSUhJOUlqZ2lMejQ4YkdsdVpTQjRNVDBpTWpFaUlIZ3lQU0l4Tmk0Mk5TSWdlVEU5SWpJeElpQjVNajBpTVRZdU5qVWlMejQ4YkdsdVpTQjRNVDBpTVRFaUlIZ3lQU0l4TVNJZ2VURTlJamdpSUhreVBTSXhOQ0l2UGp4c2FXNWxJSGd4UFNJNElpQjRNajBpTVRRaUlIa3hQU0l4TVNJZ2VUSTlJakV4SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tem9vbS1vdXQtYWx0LC5hZy1jaGFydHMtaWNvbi16b29tLW91dC1hbHQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExYcHZiMjB0YjNWMElqNDhZMmx5WTJ4bElHTjRQU0l4TVNJZ1kzazlJakV4SWlCeVBTSTRJaTgrUEd4cGJtVWdlREU5SWpJeElpQjRNajBpTVRZdU5qVWlJSGt4UFNJeU1TSWdlVEk5SWpFMkxqWTFJaTgrUEd4cGJtVWdlREU5SWpnaUlIZ3lQU0l4TkNJZ2VURTlJakV4SWlCNU1qMGlNVEVpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcmVzZXQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAwTGpReE1pQTBMakExT0NBeUxqYzFJREl1TXprMlZqWXVOelZvTGpjME5HRXVOell1TnpZZ01DQXdJREFnTGpBeE1pQXdhRE11TlRrNFREVXVORGM0SURVdU1USTFZVFF1TVRJMUlEUXVNVEkxSURBZ01DQXhJREl1TlRJekxTNDROelVnTXk0M05TQXpMamMxSURBZ01TQXhMVE11TVRFNUlEVXVPRE16TGpjMUxqYzFJREFnTUNBd0xURXVNalEzTGpnek5FRTFMakkxSURVdU1qVWdNQ0F4SURBZ09DQXlMamMxYUMwdU1EQXpZVFV1TmpJMUlEVXVOakkxSURBZ01DQXdMVE11TlRnMUlERXVNekE0V2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tbGVmdC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhNQzR3TXlBMExqUTNZUzQzTlM0M05TQXdJREFnTVNBd0lERXVNRFpNTnk0MU5pQTRiREl1TkRjZ01pNDBOMkV1TnpVdU56VWdNQ0F4SURFdE1TNHdOaUF4TGpBMmJDMHpMVE5oTGpjMUxqYzFJREFnTUNBeElEQXRNUzR3Tm13ekxUTmhMamMxTGpjMUlEQWdNQ0F4SURFdU1EWWdNRm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1yaWdodC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDFMamszSURFeExqVXpZUzQzTlM0M05TQXdJREFnTVNBd0xURXVNRFpNT0M0ME5DQTRJRFV1T1RjZ05TNDFNMkV1TnpVdU56VWdNQ0F3SURFZ01TNHdOaTB4TGpBMmJETWdNMkV1TnpVdU56VWdNQ0F3SURFZ01DQXhMakEyYkMweklETmhMamMxTGpjMUlEQWdNQ0F4TFRFdU1EWWdNRm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1zdGFydC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFdOb1pYWnliMjR0Wm1seWMzUWlQanh3WVhSb0lHUTlJbTB4TnlBeE9DMDJMVFlnTmkwMklpOCtQSEJoZEdnZ1pEMGlUVGNnTm5ZeE1pSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tZW5kLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMV05vWlhaeWIyNHRiR0Z6ZENJK1BIQmhkR2dnWkQwaWJUY2dNVGdnTmkwMkxUWXROaUl2UGp4d1lYUm9JR1E5SWsweE55QTJkakV5SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tdHJlbmQtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEdOcGNtTnNaU0JqZUQwaU1pNDFJaUJqZVQwaU9DSWdjajBpTVM0M05TSWdjM1J5YjJ0bFBTSWpNREF3SWlCemRISnZhMlV0ZDJsa2RHZzlJakV1TlNJdlBqeGphWEpqYkdVZ1kzZzlJakV6TGpVaUlHTjVQU0k0SWlCeVBTSXhMamMxSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaTgrUEhCaGRHZ2djM1J5YjJ0bFBTSWpNREF3SWlCemRISnZhMlV0ZDJsa2RHZzlJakV1TlNJZ1pEMGlUVFFnT0dnNElpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWhvcml6b250YWwtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhNQzR6T0RZZ09DNDNOV0V5TGpVd01TQXlMalV3TVNBd0lEQWdNUzAwTGpjM01pQXdTQzQzTldFdU56VXVOelVnTUNBd0lERWdNQzB4TGpWb05DNDROalJoTWk0MU1ERWdNaTQxTURFZ01DQXdJREVnTkM0M056SWdNR2cwTGpnMk5HRXVOelV1TnpVZ01DQXdJREVnTUNBeExqVm9MVFF1T0RZMFdrMDVJRGhoTVNBeElEQWdNU0F4TFRJZ01DQXhJREVnTUNBd0lERWdNaUF3V2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi12ZXJ0aWNhbC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswNExqYzFJRFV1TmpFMFlUSXVOVEF4SURJdU5UQXhJREFnTUNBeElEQWdOQzQzTnpKMk5DNDROalJoTGpjMUxqYzFJREFnTUNBeExURXVOU0F3ZGkwMExqZzJOR0V5TGpVd01TQXlMalV3TVNBd0lEQWdNU0F3TFRRdU56Y3lWaTQzTldFdU56VXVOelVnTUNBd0lERWdNUzQxSURCMk5DNDROalJhVFRnZ04yRXhJREVnTUNBeElERWdNQ0F5SURFZ01TQXdJREFnTVNBd0xUSmFJaUJtYVd4c1BTSWpNREF3SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcGFyYWxsZWwtY2hhbm5lbC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRjaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhOQzQwTWpRZ05DNDVNbUV5TGpVZ01pNDFJREFnTVNBd0xUTXVNemMzTFRJdU1UUnNMVFl1TmpNZ01pNDVZVEl1TlRBeElESXVOVEF4SURBZ01TQXdJQzQyTURjZ01TNHpOekpzTmk0MU9EVXRNaTQ0T0dFeUxqVXdNU0F5TGpVd01TQXdJREFnTUNBeUxqZ3hOUzQzTkRoYWJTNHdOUzB5TGpZNU0yRXhJREVnTUNBeElERXRNUzQ0Tnk0M01EZ2dNU0F4SURBZ01DQXhJREV1T0RjdExqY3dPRnB0TFRFeElEUXVOelZoTVNBeElEQWdNU0F4TFRFdU9EY3VOekE0SURFZ01TQXdJREFnTVNBeExqZzNMUzQzTURoYWJURXVOVFVnTmk0d056VmhNaTQxTURFZ01pNDFNREVnTUNBeElERXRMall3TnkweExqTTNNbXcyTGpZekxUSXVPV0V5TGpVd01TQXlMalV3TVNBd0lERWdNU0F1TlRZeUlERXVNemt4YkMwMkxqVTROU0F5TGpnNFdtMHRNUzQxTlMwdU1EYzFZVEVnTVNBd0lERWdNUzB4TGpnM0xqY3dPQ0F4SURFZ01DQXdJREVnTVM0NE55MHVOekE0V20weE1DNDBNaTB6TGpRMllURWdNU0F3SURFZ01DMHVOekE1TFRFdU9EY2dNU0F4SURBZ01DQXdJQzQzTURnZ01TNDROMW9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWRpc2pvaW50LWNoYW5uZWwtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UY2lJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TkM0ME1qUWdOQzQ1TW1FeUxqVWdNaTQxSURBZ01TQXdMVE11TXpnekxUSXVORFV6VERRdU5qa2dOQzR3TlRWaE1pNDFJREl1TlNBd0lERWdNQ0F1TXpRMElERXVORFpzTmk0ek9USXRNUzQxT1RoaE1pNDFNREVnTWk0MU1ERWdNQ0F3SURBZ015QXhMakF3TTFwdExqQTFMVEl1TmprellURWdNU0F3SURFZ01TMHhMamczTGpjd09DQXhJREVnTUNBd0lERWdNUzQ0TnkwdU56QTRXbTB0TVRFZ01pNDNOV0V4SURFZ01DQXhJREV0TVM0NE55NDNNRGdnTVNBeElEQWdNQ0F4SURFdU9EY3RMamN3T0ZwdE1TNDFOaUExTGpReVlUSXVOU0F5TGpVZ01DQXhJREF0TGpNME5TQXhMalEyTVd3MkxqTTFNaUF4TGpVNE9HRXlMalVnTWk0MUlEQWdNU0F3SUM0ek9EUXRNUzQwTld3dE5pNHpPVEl0TVM0MU9UaGFiUzB4TGpVMkxqVXpPR0V4SURFZ01DQXhJREF0TVM0NE55MHVOekE0SURFZ01TQXdJREFnTUNBeExqZzNMamN3T0ZwdE1UQXVORElnTVM0ME5qRmhNU0F4SURBZ01TQXhMUzQzTURrZ01TNDROeUF4SURFZ01DQXdJREVnTGpjd09DMHhMamczV2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1saW5lLWNvbG9yLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR2NnWTJ4cGNDMXdZWFJvUFNKMWNtd29JMkVwSWo0OGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVEV5TGpjNE9DNDFPRE5oTWk0Mk15QXlMall6SURBZ01DQXdMVEV1T0RZdU56ZE1PUzQxTkRRZ01pNDNNemhoTGpjMU55NDNOVGNnTUNBd0lEQXRMakUwTGpFMFRESXVNRE15SURFd0xqSTFkaTR3TURGakxTNHlOREl1TWpReExTNDBNaTQxTXpndExqVXlMamcyTkd3dExqQXdNaTR3TURJdExqZzRJREl1T1RBeUxTNHdNREV1TURBellURXVNRGd6SURFdU1EZ3pJREFnTUNBd0lERXVNelVnTVM0ek5EZG9MakF3TVd3eUxqa3dNaTB1T0Rob0xqQXdNV011TXpJMkxTNHhMall5TXkwdU1qYzNMamcyTlMwdU5URTRkaTB1TURBeGJEY3VNemMxTFRjdU16YzJZUzQzTmpNdU56WXpJREFnTUNBd0lDNHhNemt0TGpFek9Xd3hMak00TkMweExqTTRORUV5TGpZeklESXVOak1nTUNBd0lEQWdNVEl1TnpnNExqVTRNMXB0TFM0eE1qWWdOQzR6TlRJdU9USTBMUzQ1TWpSaE1TNHhNeUF4TGpFeklEQWdNQ0F3TFRFdU5UazNMVEV1TlRrM2JDMHVPVEkwTGpreU5DQXhMalU1TnlBeExqVTVOMXB0TFRJdU5qVTNMUzQxTXpZdE5pNDVNVE1nTmk0NU1UUklNeTR3T1dFdU5UZ3pMalU0TXlBd0lEQWdNQzB1TVRRMkxqSTBNbXd0TGpZMU15QXlMakUxTXlBeUxqRTFOUzB1TmpVMFlTNDFPRE11TlRneklEQWdNQ0F3SUM0eU5ERXRMakUwTkd3Mkxqa3hOQzAyTGpreE5DMHhMalU1TnkweExqVTVOMW9pSUdacGJHdzlJaU13TURBaUx6NDhMMmMrUEdSbFpuTStQR05zYVhCUVlYUm9JR2xrUFNKaElqNDhjR0YwYUNCbWFXeHNQU0lqWm1abUlpQmtQU0pOTUNBd2FERTJkakUyU0RCNklpOCtQQzlqYkdsd1VHRjBhRDQ4TDJSbFpuTStQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWRlbGV0ZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDJMakE0TXlBeUxqWTJOMk13TFM0d09TNHdOVE10TGpJME1pNHhPVGN0TGpNNE55NHhORFV0TGpFME5DNHlPVGN0TGpFNU55NHpPRGN0TGpFNU4yZ3lMalkyTjJNdU1EZzVJREFnTGpJME1TNHdOVE11TXpnMkxqRTVOeTR4TkRVdU1UUTFMakU1Tnk0eU9UY3VNVGszTGpNNE4zWXVOVGd6U0RZdU1EZzBkaTB1TlRneldrMDFMak16SURRdU56VklNVEV1T1RFM2RqZ3VOVGd6WXpBZ0xqQTVMUzR3TlRJdU1qUXlMUzR4T1RjdU16ZzNMUzR4TkRVdU1UUTBMUzR5T1RjdU1UazNMUzR6T0RZdU1UazNTRFF1TmpZM1l5MHVNRGtnTUMwdU1qUXlMUzR3TlRNdExqTTROeTB1TVRrM0xTNHhORFF0TGpFME5TMHVNVGszTFM0eU9UY3RMakU1TnkwdU16ZzNWalF1TnpWSU5TNHpNMXB0TFM0M05EVXRNUzQxZGkwdU5UZ3pZekF0TGpVM09DNHlPQzB4TGpBNU1pNDJNell0TVM0ME5EY3VNelUxTFM0ek5UWXVPRGN0TGpZek55QXhMalEwTnkwdU5qTTNhREl1TmpZM1l5NDFOemNnTUNBeExqQTVNUzR5T0RFZ01TNDBORGN1TmpNM0xqTTFOUzR6TlRVdU5qTTJMamczTGpZek5pQXhMalEwTjNZdU5UZ3pTREUwWVM0M05TNDNOU0F3SURBZ01TQXdJREV1TldndExqVTRNM1k0TGpVNE0yTXdJQzQxTnpndExqSTRNU0F4TGpBNU1pMHVOak0ySURFdU5EUTNMUzR6TlRZdU16VTJMUzQ0Tnk0Mk16Y3RNUzQwTkRjdU5qTTNTRFF1TmpZM1l5MHVOVGMzSURBdE1TNHdPVEl0TGpJNE1TMHhMalEwTnkwdU5qTTNMUzR6TlRVdExqTTFOUzB1TmpNM0xTNDROeTB1TmpNM0xURXVORFEzVmpRdU56VklNbUV1TnpVdU56VWdNQ0F3SURFZ01DMHhMalZvTWk0MU9ETmFiVEl1TURneklETXVNek16WVM0M05TNDNOU0F3SURBZ01TQXVOelV1TnpWMk5HRXVOelV1TnpVZ01DQXhJREV0TVM0MUlEQjJMVFJoTGpjMUxqYzFJREFnTUNBeElDNDNOUzB1TnpWYWJUTXVOREUzTGpjMVlTNDNOUzQzTlNBd0lEQWdNQzB4TGpVZ01IWTBZUzQzTlM0M05TQXdJREVnTUNBeExqVWdNSFl0TkZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1sb2NrLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMkxqRTNNeUF5TGpnMFlUSXVOVGd6SURJdU5UZ3pJREFnTUNBeElEUXVOREVnTVM0NE1qZDJNUzQ1TVRaSU5TNDBNVFpXTkM0Mk5qZGpNQzB1TmpnMUxqSTNNeTB4TGpNME15NDNOVGN0TVM0NE1qZGFUVE11T1RFM0lEWXVOVGd6VmpRdU5qWTNZVFF1TURneklEUXVNRGd6SURBZ01DQXhJRGd1TVRZMklEQjJNUzQ1TVRab0xqVTROR014TGpFMUlEQWdNaTR3T0RNdU9UTXpJREl1TURneklESXVNRGcwZGpRdU5qWTJZekFnTVM0eE5TMHVPVE16SURJdU1EZzBMVEl1TURneklESXVNRGcwU0RNdU16TXpZVEl1TURneklESXVNRGd6SURBZ01DQXhMVEl1TURnekxUSXVNRGcwVmpndU5qWTNZekF0TVM0eE5URXVPVE16TFRJdU1EZzBJREl1TURnekxUSXVNRGcwYUM0MU9ETmFiVGN1TkRFMklERXVOV2d0T0dFdU5UZ3pMalU0TXlBd0lEQWdNQzB1TlRnekxqVTROSFkwTGpZMk5tTXdJQzR6TWpJdU1qWXhMalU0TkM0MU9ETXVOVGcwYURrdU16TTBZUzQxT0RNdU5UZ3pJREFnTUNBd0lDNDFPRE10TGpVNE5GWTRMalkyTjJFdU5UZ3pMalU0TXlBd0lEQWdNQzB1TlRnekxTNDFPRFJvTFRFdU16TTBXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXVubG9jay1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRjaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDJMamt5TXlBeUxqZzBZVEl1TlRneklESXVOVGd6SURBZ01DQXhJRE11TmpVeklEQWdNeUF6SURBZ01DQXhJQzQxTnk0M09UaGpMakV6TkM0eU56Z3VNVGN1TkRjMExqRTNMalUwTldFdU56VXVOelVnTUNBd0lEQWdNUzQxSURCak1DMHVNemd4TFM0eE16SXRMamd3T1MwdU16SXRNUzR4T1RoaE5DNDFNREVnTkM0MU1ERWdNQ0F3SURBdExqZzFPUzB4TGpJd05pQTBMakE0TXlBMExqQTRNeUF3SURBZ01DMDJMamszSURJdU9EZzRkakV1T1RFMmFDMHVOVGcwUXpJdU9UTXpJRFl1TlRneklESWdOeTQxTVRZZ01pQTRMalkyTjNZMExqWTJObU13SURFdU1UVXVPVE16SURJdU1EZzBJREl1TURneklESXVNRGcwYURrdU16TTBZekV1TVRVZ01DQXlMakE0TXkwdU9UTXpJREl1TURnekxUSXVNRGcwVmpndU5qWTNZekF0TVM0eE5URXRMamt6TXkweUxqQTROQzB5TGpBNE15MHlMakE0TkdndE55NHlOVlkwTGpZMk4yTXdMUzQyT0RVdU1qY3lMVEV1TXpRekxqYzFOaTB4TGpneU4xcE5OUzQwTVRjZ09DNHdPRE5JTkM0d09ESmhMalU0TXk0MU9ETWdNQ0F3SURBdExqVTRNeTQxT0RSMk5DNDJOalpqTUNBdU16SXlMakkyTVM0MU9EUXVOVGd6TGpVNE5HZzVMak16TkdFdU5UZ3pMalU0TXlBd0lEQWdNQ0F1TlRnekxTNDFPRFJXT0M0Mk5qZGhMalU0TXk0MU9ETWdNQ0F3SURBdExqVTRNeTB1TlRnMGFDMDRXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBsdXMtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExYQnNkWE1pUGp4d1lYUm9JR1E5SWswMUlERXlhREUwSWk4K1BIQmhkR2dnWkQwaVRURXlJRFYyTVRRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWNyb3NzbGluZS1hZGQtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l4TmlJZ2FHVnBaMmgwUFNJeE5pSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5PQzQzTlNBMExqVmhMamMxTGpjMUlEQWdNQ0F3TFRFdU5TQXdkakl1TnpWSU5DNDFZUzQzTlM0M05TQXdJREFnTUNBd0lERXVOV2d5TGpjMWRqSXVOelZoTGpjMUxqYzFJREFnTUNBd0lERXVOU0F3VmpndU56Vm9NaTQzTldFdU56VXVOelVnTUNBd0lEQWdNQzB4TGpWSU9DNDNOWG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1mb2N1cy5hZy1jaGFydHMtZm9jdXNfX2luZGljYXRvcntwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3BvaW50ZXItZXZlbnRzOm5vbmU7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS5hZy1jaGFydHMtZm9jdXMuYWctY2hhcnRzLWZvY3VzX19pbmRpY2F0b3I+ZGl2e3Bvc2l0aW9uOmFic29sdXRlO291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcik7b3V0bGluZS13aWR0aDoycHg7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyl9LmFnLWNoYXJ0cy1mb2N1cy5hZy1jaGFydHMtZm9jdXNfX2luZGljYXRvcj5zdmd7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmaWxsOm5vbmU7c3Ryb2tlOnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItY29sb3IpO3N0cm9rZS13aWR0aDoycHh9LmFnLWNoYXJ0cy1mb2N1cy0taGlkZGVue3Zpc2liaWxpdHk6aGlkZGVufS5hZy1jaGFydHMtdG9vbGJhcnthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZDpub25lO2JvcmRlcjpub25lO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6bm93cmFwO29wYWNpdHk6MTtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGVhc2UtaW4tb3V0LHRyYW5zZm9ybSAuMnMgZWFzZS1pbi1vdXR9LmFnLWNoYXJ0cy10b29sYmFyLS1oaWRkZW4sLmFnLWNoYXJ0cy10b29sYmFyLS1wcmV2ZW50LWZsYXNoe3Zpc2liaWxpdHk6aGlkZGVufS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctaGlkZGVue29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGVhc2UtaW4tb3V0fS5hZy1jaGFydHMtdG9vbGJhci0tc21hbGx7LS1hZy1jaGFydHMtdG9vbGJhci1zaXplOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplLXNtYWxsKTstLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZTogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplLXNtYWxsKTstLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZy1zbWFsbCl9LmFnLWNoYXJ0cy10b29sYmFyLS10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1ib3R0b217ZmxleC1kaXJlY3Rpb246cm93O3dpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0LC5hZy1jaGFydHMtdG9vbGJhci0tcmlnaHR7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmcsLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b217YmFja2dyb3VuZDpub25lO2JvcmRlcjpub25lO2ZsZXgtZGlyZWN0aW9uOnJvdztwb2ludGVyLWV2ZW50czpub25lO3dpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZ3twYWRkaW5nOjA7d2lkdGg6YXV0bzt6LWluZGV4OnZhcigtLWFnLWNoYXJ0cy1sYXllci10b29sYmFyKX0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcHtoZWlnaHQ6Y2FsYyh2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKSArIDEwcHgpO3BhZGRpbmctdG9wOjEwcHh9LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b217aGVpZ2h0OmNhbGModmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSkgKyAxMHB4KTtwYWRkaW5nLWJvdHRvbToxMHB4O292ZXJmbG93OmhpZGRlbn0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWdue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtd3JhcDppbmhlcml0O2dhcDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1nYXApO21heC13aWR0aDoxMDAlO3dpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tc3RhcnR7anVzdGlmeS1jb250ZW50OnN0YXJ0fS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlcntqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZHtqdXN0aWZ5LWNvbnRlbnQ6ZW5kfS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlciwuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmR7bWFyZ2luLWxlZnQ6YXV0b30uYWctY2hhcnRzLXRvb2xiYXItLWxlZnQgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyLC5hZy1jaGFydHMtdG9vbGJhci0tbGVmdCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmQsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXIsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmR7bWFyZ2luLWxlZnQ6MDttYXJnaW4tdG9wOmF1dG99LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3AgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbiwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbSAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWdue3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBlYXNlLWluLW91dDt3aWR0aDphdXRvfS5hZy1jaGFydHMtdG9vbGJhcl9fc2VjdGlvbntkaXNwbGF5OmluaGVyaXQ7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LXdyYXA6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDttYXgtd2lkdGg6aW5oZXJpdDt3aWR0aDppbmhlcml0fS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uey0tdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuMjVzIGVhc2UtaW4tb3V0LCBib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dCwgY29sb3IgLjI1cyBlYXNlLWluLW91dDthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXI6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYm9yZGVyKTtjb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb3JlZ3JvdW5kLWNvbG9yKTtkaXNwbGF5OmZsZXg7Zm9udDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemUpIHZhcigtLWFnLWNoYXJ0cy1mb250LWZhbWlseSk7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MCAwIDAgLTFweDttaW4taGVpZ2h0OnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUpO21pbi13aWR0aDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKTtwYWRkaW5nOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nKTtwb2ludGVyLWV2ZW50czphbGw7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTt3aGl0ZS1zcGFjZTpub3dyYXB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b25bZGF0YS10b29sYmFyLWdyb3VwPXJhbmdlc117cGFkZGluZzp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZykgY2FsYyh2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZykgKiAxLjUpfS5hZy1jaGFydHMtdG9vbGJhci0tdG9wLC5hZy1jaGFydHMtdG9vbGJhci0tYm90dG9tLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmcsLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b217LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246bnRoLWNoaWxkKDEgb2Y6bm90KC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZCkpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO21hcmdpbjowfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOm50aC1sYXN0LWNoaWxkKDEgb2Y6bm90KC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZCkpe2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyl9fS5hZy1jaGFydHMtdG9vbGJhci0tbGVmdCwuYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0ey5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9ue2JvcmRlci1yYWRpdXM6MDttYXJnaW46LTFweCAwIDA7bWF4LXdpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246bnRoLWNoaWxkKDEgb2Y6bm90KC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZCkpe2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTttYXJnaW46MH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpudGgtbGFzdC1jaGlsZCgxIG9mOm5vdCguYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWQpKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyl9fS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdmFsdWUsLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVke2Rpc3BsYXk6bm9uZX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yKTt6LWluZGV4OjF9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246Zm9jdXMtdmlzaWJsZXtib3JkZXItY29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9jdXMtY29sb3IpO2JveC1zaGFkb3c6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3cpO3otaW5kZXg6M30uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1hY3RpdmV7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1jb2xvcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yKTt6LWluZGV4OjJ9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b25bYXJpYS1kaXNhYmxlZD10cnVlXXtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3IpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWRpc2FibGVkLWZvcmVncm91bmQtY29sb3IpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOm5vdChbYXJpYS1kaXNhYmxlZD10cnVlXSl7Y3Vyc29yOnBvaW50ZXJ9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpbGwtdmlzaWJsZTphZnRlcntjb250ZW50OlwiXCI7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206M3B4O2xlZnQ6NXB4O3JpZ2h0OjVweDtoZWlnaHQ6NHB4O2JvcmRlci1yYWRpdXM6OTlweDtib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCBjb2xvci1taXgoaW4gc3JnYix2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgMTAlLHRyYW5zcGFyZW50KTtiYWNrZ3JvdW5kOnZhcigtLWZpbGwpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maWxsLXZpc2libGVbYXJpYS1kaXNhYmxlZD10cnVlXTphZnRlcntmaWx0ZXI6Z3JheXNjYWxlKDEpO29wYWNpdHk6LjV9LmFnLWNoYXJ0cy10b29sYmFyX19pY29uKy5hZy1jaGFydHMtdG9vbGJhcl9fbGFiZWx7bWFyZ2luLWxlZnQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZ2FwKX0uYWctY2hhcnRzLXRvb2xiYXJfX2ljb24sLmFnLWNoYXJ0cy10b29sYmFyX19sYWJlbHtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydC1vdmVybGF5e2NvbG9yOiMxODFkMWY7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnQtb3ZlcmxheS5hZy1jaGFydC1kYXJrLW92ZXJsYXl7Y29sb3I6I2ZmZn0uYWctY2hhcnQtb3ZlcmxheS0tbG9hZGluZ3tjb2xvcjojOGM4YzhjfS5hZy1jaGFydC1vdmVybGF5X19sb2FkaW5nLWJhY2tncm91bmR7YmFja2dyb3VuZDojZmZmO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0LW92ZXJsYXkuYWctY2hhcnQtZGFyay1vdmVybGF5IC5hZy1jaGFydC1vdmVybGF5X19sb2FkaW5nLWJhY2tncm91bmR7YmFja2dyb3VuZDojMTkyMjMyfS5hZy1jaGFydC10b29sdGlwe3RyYW5zaXRpb246dHJhbnNmb3JtIC4xcyBlYXNlO3dpZHRoOm1heC1jb250ZW50O3otaW5kZXg6OTk5OTk7Zm9udDoxMnB4IFZlcmRhbmEsc2Fucy1zZXJpZjtjb2xvcjojNDY0NjQ2O2JveC1zaGFkb3c6MCA0cHggOHB4ICMwMDAwMDAxNH0uYWctY2hhcnQtdG9vbHRpcC13cmFwLWFsd2F5c3tvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7d29yZC1icmVhazpicmVhay13b3JkO2h5cGhlbnM6bm9uZX0uYWctY2hhcnQtdG9vbHRpcC13cmFwLWh5cGhlbmF0ZXtvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7d29yZC1icmVhazpicmVhay13b3JkO2h5cGhlbnM6YXV0b30uYWctY2hhcnQtdG9vbHRpcC13cmFwLW9uLXNwYWNle292ZXJmbG93LXdyYXA6bm9ybWFsO3dvcmQtYnJlYWs6bm9ybWFsfS5hZy1jaGFydC10b29sdGlwLXdyYXAtbmV2ZXJ7d2hpdGUtc3BhY2U6cHJlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmFnLWNoYXJ0LXRvb2x0aXAtbm8taW50ZXJhY3Rpb257cG9pbnRlci1ldmVudHM6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5hZy1jaGFydC10b29sdGlwLW5vLWFuaW1hdGlvbnt0cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50fS5hZy1jaGFydC10b29sdGlwLWhpZGRlbnt2aXNpYmlsaXR5OmhpZGRlbn0uYWctY2hhcnQtdG9vbHRpcC10aXRsZXtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzo4cHggMTRweDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjJweDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czoycHg7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM4ODg7ei1pbmRleDoxO3RleHQtb3ZlcmZsb3c6aW5oZXJpdH0uYWctY2hhcnQtdG9vbHRpcC10aXRsZTpvbmx5LWNoaWxke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MnB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjJweH0uYWctY2hhcnQtdG9vbHRpcC1jb250ZW50e292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjZweCAxNHB4O2xpbmUtaGVpZ2h0OjEuN2VtO2JhY2tncm91bmQ6I2ZmZjtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjJweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czoycHg7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDAsMCwwLC4xNSk7dGV4dC1vdmVyZmxvdzppbmhlcml0fS5hZy1jaGFydC10b29sdGlwLWFycm93OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKTtib3JkZXI6NXB4IHNvbGlkICNkOWQ5ZDk7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7d2lkdGg6MDtoZWlnaHQ6MDttYXJnaW46MCBhdXRvfS5hZy1jaGFydC10b29sdGlwLWFycm93OmFmdGVye2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Y2FsYygxMDAlIC0gMXB4KTtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpO2JvcmRlcjo1cHggc29saWQgd2hpdGU7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7d2lkdGg6MDtoZWlnaHQ6MDttYXJnaW46MCBhdXRvfVxcbic7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZ3VhcmRlZEVsZW1lbnQudHNcbnZhciBHdWFyZGVkRWxlbWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudDIsIHRvcFRhYkd1YXJkLCBib3R0b21UYWJHdWFyZCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQyO1xuICAgIHRoaXMudG9wVGFiR3VhcmQgPSB0b3BUYWJHdWFyZDtcbiAgICB0aGlzLmJvdHRvbVRhYkd1YXJkID0gYm90dG9tVGFiR3VhcmQ7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5ndWFyZFRhYkluZGV4ID0gMDtcbiAgICB0aGlzLmVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICB0aGlzLmluaXRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXCJibHVyXCIsICgpID0+IHRoaXMub25CbHVyKCkpO1xuICAgIHRoaXMuaW5pdEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCBcImZvY3VzXCIsICgpID0+IHRoaXMub25Gb2N1cygpKTtcbiAgICB0aGlzLmluaXRFdmVudExpc3RlbmVyKHRoaXMudG9wVGFiR3VhcmQsIFwiZm9jdXNcIiwgKGV2KSA9PiB0aGlzLm9uVGFiU3RhcnQoZXYsIHRoaXMudG9wVGFiR3VhcmQpKTtcbiAgICB0aGlzLmluaXRFdmVudExpc3RlbmVyKHRoaXMuYm90dG9tVGFiR3VhcmQsIFwiZm9jdXNcIiwgKGV2KSA9PiB0aGlzLm9uVGFiU3RhcnQoZXYsIHRoaXMuYm90dG9tVGFiR3VhcmQpKTtcbiAgfVxuICBzZXQgdGFiSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5ndWFyZFRhYkluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHRoaXMudG9wVGFiR3VhcmQudGFiSW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuYm90dG9tVGFiR3VhcmQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvcFRhYkd1YXJkLnRhYkluZGV4ID0gaW5kZXg7XG4gICAgICB0aGlzLmJvdHRvbVRhYkd1YXJkLnRhYkluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLmRlc3Ryb3lGbnMpXG4gICAgICBmbigpO1xuICAgIHRoaXMuZGVzdHJveUZucy5sZW5ndGggPSAwO1xuICB9XG4gIGluaXRFdmVudExpc3RlbmVyKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goKCkgPT4gZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpKTtcbiAgfVxuICBvbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMudGFiSW5kZXggPSB0aGlzLmd1YXJkVGFiSW5kZXg7XG4gICAgICB0aGlzLmd1YXJkVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5ndWVzc2VkRGVsdGEgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIG9uRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cbiAgb25UYWJTdGFydChldmVudCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC50YWJJbmRleCA+IDApIHtcbiAgICAgIHRoaXMuZ3Vlc3NlZERlbHRhID0gMDtcbiAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgXCJ0YWJJbmRleFwiIGluIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgcHJldlRhYkluZGV4ID0gTnVtYmVyKGV2ZW50LnJlbGF0ZWRUYXJnZXRbXCJ0YWJJbmRleFwiXSk7XG4gICAgICAgIGlmICghaXNOYU4ocHJldlRhYkluZGV4KSAmJiBwcmV2VGFiSW5kZXggPiAwKSB7XG4gICAgICAgICAgdGhpcy5ndWVzc2VkRGVsdGEgPSBwcmV2VGFiSW5kZXggPCB0YXJnZXQudGFiSW5kZXggPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ndWFyZFRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICBnZXRCcm93c2VyRm9jdXNEZWx0YSgpIHtcbiAgICBjb25zdCB7IGd1ZXNzZWREZWx0YSwgZ3VhcmRUYXJnZXQsIHRvcFRhYkd1YXJkLCBib3R0b21UYWJHdWFyZDogYm90VGFiR3VhcmQgfSA9IHRoaXM7XG4gICAgaWYgKGd1ZXNzZWREZWx0YSAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGd1ZXNzZWREZWx0YTtcbiAgICBpZiAoZ3VhcmRUYXJnZXQgPT09IHRvcFRhYkd1YXJkKVxuICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGd1YXJkVGFyZ2V0ID09PSBib3RUYWJHdWFyZClcbiAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zaXplTW9uaXRvci50c1xudmFyIFNpemVNb25pdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMub25Mb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLmZvckVhY2goKFtlbCwgY2JdKSA9PiB0aGlzLm9ic2VydmUoZWwsIGNiKSk7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IFtdO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb250ZW50UmVjdDogeyB3aWR0aCwgaGVpZ2h0IH1cbiAgICAgIH0gb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZWxlbWVudHMuZ2V0KHRhcmdldCk7XG4gICAgICAgIHRoaXMuY2hlY2tTaXplKGVudHJ5LCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9jdW1lbnRSZWFkeSA9IGdldERvY3VtZW50KFwicmVhZHlTdGF0ZVwiKSA9PT0gXCJjb21wbGV0ZVwiO1xuICAgIGlmICghdGhpcy5kb2N1bWVudFJlYWR5KSB7XG4gICAgICBnZXRXaW5kb3coKT8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGdldFdpbmRvdygpPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uTG9hZCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICB9XG4gIGNoZWNrU2l6ZShlbnRyeSwgZWxlbWVudDIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWVudHJ5KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh3aWR0aCAhPT0gZW50cnkuc2l6ZT8ud2lkdGggfHwgaGVpZ2h0ICE9PSBlbnRyeS5zaXplPy5oZWlnaHQpIHtcbiAgICAgIGVudHJ5LnNpemUgPSB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICAgIGVudHJ5LmNiKGVudHJ5LnNpemUsIGVsZW1lbnQyKTtcbiAgICB9XG4gIH1cbiAgLy8gT25seSBhIHNpbmdsZSBjYWxsYmFjayBpcyBzdXBwb3J0ZWQuXG4gIG9ic2VydmUoZWxlbWVudDIsIGNiKSB7XG4gICAgaWYgKCF0aGlzLmRvY3VtZW50UmVhZHkpIHtcbiAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLnB1c2goW2VsZW1lbnQyLCBjYl0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbGVtZW50cy5oYXMoZWxlbWVudDIpKSB7XG4gICAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShlbGVtZW50Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUoZWxlbWVudDIpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHsgY2IgfTtcbiAgICB0aGlzLmVsZW1lbnRzLnNldChlbGVtZW50MiwgZW50cnkpO1xuICAgIHRoaXMuY2hlY2tTaXplKGVudHJ5LCBlbGVtZW50MiwgZWxlbWVudDIub2Zmc2V0V2lkdGgsIGVsZW1lbnQyLm9mZnNldEhlaWdodCk7XG4gIH1cbiAgdW5vYnNlcnZlKGVsZW1lbnQyKSB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKGVsZW1lbnQyKTtcbiAgICB0aGlzLmVsZW1lbnRzLmRlbGV0ZShlbGVtZW50Mik7XG4gICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZWxlbWVudDIpO1xuICAgIGlmICghdGhpcy5lbGVtZW50cy5zaXplKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlRnJvbVF1ZXVlKGVsZW1lbnQyKSB7XG4gICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMgPSB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5maWx0ZXIoKFtlbF0pID0+IGVsICE9PSBlbGVtZW50Mik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RvbS9kb21MYXlvdXQuaHRtbFxudmFyIGRvbUxheW91dF9kZWZhdWx0ID0gJzxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLXdyYXBwZXIgYWctY2hhcnRzLXN0eWxlc1wiIGRhdGEtYWctY2hhcnRzPjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJcIj48ZGl2IHJvbGU9XCJmaWd1cmVcIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtY29udGFpbmVyXCI+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtdGFiLWd1YXJkXCI+PC9kaXY+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzXCI+PC9kaXY+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLXByb3h5XCI+PC9kaXY+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtdGFiLWd1YXJkXCI+PC9kaXY+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLW92ZXJsYXlcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kb20vZG9tTWFuYWdlci50c1xudmFyIENBTlZBU19DRU5URVJfQ0xBU1MgPSBcImNhbnZhcy1jZW50ZXJcIjtcbnZhciBET01fRUxFTUVOVF9DTEFTU0VTID0gW1wic3R5bGVzXCIsIENBTlZBU19DRU5URVJfQ0xBU1MsIFwiY2FudmFzXCIsIFwiY2FudmFzLXByb3h5XCIsIFwiY2FudmFzLW92ZXJsYXlcIl07XG52YXIgZG9tRWxlbWVudENvbmZpZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wic3R5bGVzXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJzdHlsZVwiIH1dLFxuICBbXCJjYW52YXNcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImNhbnZhc1wiLCBldmVudFR5cGVzOiBbXCJmb2N1c1wiLCBcImJsdXJcIl0gfV0sXG4gIFtcImNhbnZhcy1wcm94eVwiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiZGl2XCIgfV0sXG4gIFtcImNhbnZhcy1vdmVybGF5XCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW0NBTlZBU19DRU5URVJfQ0xBU1MsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XVxuXSk7XG5mdW5jdGlvbiBzZXR1cE9ic2VydmVyKGVsZW1lbnQyLCBjYikge1xuICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSBlbGVtZW50Mikge1xuICAgICAgICAgIGNiKGVudHJ5LmludGVyc2VjdGlvblJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgeyByb290OiBlbGVtZW50MiB9XG4gICk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudDIpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG52YXIgTlVMTF9ET01SRUNUID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICB0b3A6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gTlVMTF9ET01SRUNUO1xuICB9XG59O1xudmFyIERPTU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgIHRoaXMuY29udGFpbmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemVNb25pdG9yID0gbmV3IFNpemVNb25pdG9yKCk7XG4gICAgY29uc3QgdGVtcGxhdGVFbCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGVtcGxhdGVFbC5pbm5lckhUTUwgPSBkb21MYXlvdXRfZGVmYXVsdDtcbiAgICB0aGlzLmVsZW1lbnQgPSB0ZW1wbGF0ZUVsLmNoaWxkcmVuLml0ZW0oMCk7XG4gICAgdGhpcy5yb290RWxlbWVudHMgPSBET01fRUxFTUVOVF9DTEFTU0VTLnJlZHVjZShcbiAgICAgIChyLCBjKSA9PiB7XG4gICAgICAgIGNvbnN0IGNzc0NsYXNzID0gYGFnLWNoYXJ0cy0ke2N9YDtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNzc0NsYXNzKSA/IHRoaXMuZWxlbWVudCA6IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuJHtjc3NDbGFzc31gKTtcbiAgICAgICAgaWYgKCFlbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVuYWJsZSB0byBmaW5kIERPTSBlbGVtZW50ICR7Y3NzQ2xhc3N9YCk7XG4gICAgICAgIHJbY10gPSB7IGVsZW1lbnQ6IGVsLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbGlzdGVuZXJzOiBbXSB9O1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG4gICAgbGV0IGhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBzZXR1cE9ic2VydmVyKHRoaXMuZWxlbWVudCwgKGludGVyc2VjdGlvblJhdGlvKSA9PiB7XG4gICAgICBpZiAoaW50ZXJzZWN0aW9uUmF0aW8gPT09IDAgJiYgIWhpZGRlbikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImhpZGRlblwiLCB7IHR5cGU6IFwiaGlkZGVuXCIgfSk7XG4gICAgICB9XG4gICAgICBoaWRkZW4gPSBpbnRlcnNlY3Rpb25SYXRpbyA9PT0gMDtcbiAgICB9KTtcbiAgICB0aGlzLnNldFNpemVPcHRpb25zKCk7XG4gICAgdGhpcy5hZGRTdHlsZXMoXCJhZy1jaGFydHMtY29tbXVuaXR5XCIsIHN0eWxlc19kZWZhdWx0KTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICB0aGlzLnNldENvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm9ic2VydmVyPy51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2l6ZU1vbml0b3IudW5vYnNlcnZlKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLnJvb3RFbGVtZW50cykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IGMucmVtb3ZlKCkpO1xuICAgICAgZWwuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmd1YXJkZWRFbGVtZW50Py5kZXN0cm95KCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xuICB9XG4gIHNldFNpemVPcHRpb25zKG1pbldpZHRoID0gMzAwLCBtaW5IZWlnaHQgPSAzMDAsIG9wdGlvbnNXaWR0aCwgb3B0aW9uc0hlaWdodCkge1xuICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBzdHlsZS53aWR0aCA9IGAke29wdGlvbnNXaWR0aCA/PyBtaW5XaWR0aH1weGA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7b3B0aW9uc0hlaWdodCA/PyBtaW5IZWlnaHR9cHhgO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lclNpemUoKSB7XG4gICAgY29uc3QgeyBzdHlsZTogY2VudGVyU3R5bGUgfSA9IHRoaXMucm9vdEVsZW1lbnRzW0NBTlZBU19DRU5URVJfQ0xBU1NdLmVsZW1lbnQ7XG4gICAgY2VudGVyU3R5bGUud2lkdGggPSBgJHt0aGlzLmNvbnRhaW5lclNpemU/LndpZHRoID8/IDB9cHhgO1xuICAgIGNlbnRlclN0eWxlLmhlaWdodCA9IGAke3RoaXMuY29udGFpbmVyU2l6ZT8uaGVpZ2h0ID8/IDB9cHhgO1xuICB9XG4gIHNldENvbnRhaW5lcihuZXdDb250YWluZXIpIHtcbiAgICBpZiAobmV3Q29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLnNpemVNb25pdG9yLnVub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGNvbnN0IGlzU2hhZG93RG9tID0gdGhpcy5nZXREb2N1bWVudFJvb3QobmV3Q29udGFpbmVyKSAhPSBudWxsO1xuICAgIGlmICghaXNTaGFkb3dEb20pIHtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5yb290RWxlbWVudHNbXCJzdHlsZXNcIl0uY2hpbGRyZW4ua2V5cygpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoXCJzdHlsZXNcIiwgaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXdDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLnNpemVNb25pdG9yLm9ic2VydmUobmV3Q29udGFpbmVyLCAoc2l6ZSkgPT4ge1xuICAgICAgdGhpcy5jb250YWluZXJTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJyZXNpemVcIiwgeyB0eXBlOiBcInJlc2l6ZVwiIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyID0gbmV3Q29udGFpbmVyO1xuICAgIGZvciAoY29uc3QgW2lkLCBzdHlsZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc3R5bGVzKSkge1xuICAgICAgdGhpcy5hZGRTdHlsZXMoaWQsIHN0eWxlcyk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiY29udGFpbmVyLWNoYW5nZWRcIiwgeyB0eXBlOiBcImNvbnRhaW5lci1jaGFuZ2VkXCIgfSk7XG4gIH1cbiAgc2V0VGhlbWVDbGFzcyh0aGVtZUNsYXNzTmFtZSkge1xuICAgIGNvbnN0IHRoZW1lQ2xhc3NOYW1lUHJlZml4ID0gXCJhZy1jaGFydHMtdGhlbWUtXCI7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5mb3JFYWNoKChjbGFzc05hbWUpID0+IHtcbiAgICAgIGlmIChjbGFzc05hbWUuc3RhcnRzV2l0aCh0aGVtZUNsYXNzTmFtZVByZWZpeCkgJiYgY2xhc3NOYW1lICE9PSB0aGVtZUNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoZW1lQ2xhc3NOYW1lKTtcbiAgfVxuICBjcmVhdGVUYWJHdWFyZHMoKSB7XG4gICAgY29uc3QgY2FudmFzRWxlbWVudCA9IHRoaXMucm9vdEVsZW1lbnRzW1wiY2FudmFzXCJdLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhc1wiKTtcbiAgICBjb25zdCB0YWJHdWFyZHMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5hZy1jaGFydHMtdGFiLWd1YXJkXCIpO1xuICAgIGlmIChjYW52YXNFbGVtZW50ID09IG51bGwgfHwgdGFiR3VhcmRzWzBdID09IG51bGwgfHwgdGFiR3VhcmRzWzFdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGVycm9yIGluaXRpYWxpc2luZyBjYW52YXMgdGFiIGd1YXJkc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHdWFyZGVkRWxlbWVudChjYW52YXNFbGVtZW50LCB0YWJHdWFyZHNbMF0sIHRhYkd1YXJkc1sxXSk7XG4gIH1cbiAgc2V0VGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICB0aGlzLmd1YXJkZWRFbGVtZW50ID8/ICh0aGlzLmd1YXJkZWRFbGVtZW50ID0gdGhpcy5jcmVhdGVUYWJHdWFyZHMoKSk7XG4gICAgdGhpcy5ndWFyZGVkRWxlbWVudC50YWJJbmRleCA9IHRhYkluZGV4O1xuICB9XG4gIGdldEJyb3dzZXJGb2N1c0RlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLmd1YXJkZWRFbGVtZW50Py5nZXRCcm93c2VyRm9jdXNEZWx0YSgpID8/IDA7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lck9uRWxlbWVudChlbGVtZW50VHlwZSwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tlbGVtZW50VHlwZV07XG4gICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsZW1lbnQyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBkb21FbGVtZW50Q29uZmlnLmZvckVhY2goKGNvbmZpZywgZWxUeXBlKSA9PiB7XG4gICAgICBpZiAoIWNvbmZpZy5ldmVudFR5cGVzPy5pbmNsdWRlcyh0eXBlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZWxzID0gdGhpcy5yb290RWxlbWVudHNbZWxUeXBlXTtcbiAgICAgIGVscy5saXN0ZW5lcnMucHVzaChbdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnNdKTtcbiAgICAgIGVscy5jaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgZG9tRWxlbWVudENvbmZpZy5mb3JFYWNoKChjb25maWcsIGVsVHlwZSkgPT4ge1xuICAgICAgaWYgKCFjb25maWcuZXZlbnRUeXBlcz8uaW5jbHVkZXModHlwZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGVscyA9IHRoaXMucm9vdEVsZW1lbnRzW2VsVHlwZV07XG4gICAgICBlbHMubGlzdGVuZXJzID0gZWxzLmxpc3RlbmVycy5maWx0ZXIoKFt0LCBsXSkgPT4gdCAhPT0gdHlwZSAmJiBsICE9PSBsaXN0ZW5lcik7XG4gICAgICBlbHMuY2hpbGRyZW4uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKiogR2V0IHRoZSBtYWluIGNoYXJ0IGFyZWEgY2xpZW50IGJvdW5kIHJlY3QuICovXG4gIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb290RWxlbWVudHNbXCJjYW52YXNcIl0uZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjbGllbnQgYm91bmRpbmcgcmVjdCBmb3Igb3ZlcmxheSBlbGVtZW50cyB0aGF0IG1pZ2h0IGZsb2F0IG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGVcbiAgICogbWFpbiBjaGFydCBhcmVhLlxuICAgKi9cbiAgZ2V0T3ZlcmxheUNsaWVudFJlY3QoKSB7XG4gICAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdygpO1xuICAgIGNvbnN0IHdpbmRvd0JCb3ggPSBuZXcgQkJveCgwLCAwLCB3aW5kb3cyLmlubmVyV2lkdGgsIHdpbmRvdzIuaW5uZXJIZWlnaHQpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZ2V0UmF3T3ZlcmxheUNsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250YWluZXJCQm94ID0gQkJveC5mcm9tRE9NUmVjdChjb250YWluZXIgPz8gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgcmV0dXJuIHdpbmRvd0JCb3guaW50ZXJzZWN0aW9uKGNvbnRhaW5lckJCb3gpPy50b0RPTVJlY3QoKSA/PyBOVUxMX0RPTVJFQ1Q7XG4gIH1cbiAgZ2V0UmF3T3ZlcmxheUNsaWVudFJlY3QoKSB7XG4gICAgbGV0IGVsZW1lbnQyID0gdGhpcy5lbGVtZW50O1xuICAgIHdoaWxlIChlbGVtZW50MiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzdHlsZU1hcCA9IGVsZW1lbnQyLmNvbXB1dGVkU3R5bGVNYXA/LigpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dYID0gc3R5bGVNYXA/LmdldChcIm92ZXJmbG93LXhcIik/LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBvdmVyZmxvd1kgPSBzdHlsZU1hcD8uZ2V0KFwib3ZlcmZsb3cteVwiKT8udG9TdHJpbmcoKTtcbiAgICAgIGlmIChvdmVyZmxvd1ggIT0gbnVsbCAmJiBvdmVyZmxvd1ggIT09IFwidmlzaWJsZVwiIHx8IG92ZXJmbG93WSAmJiBvdmVyZmxvd1kgIT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Mi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQyID0gZWxlbWVudDIucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgY29uc3QgZG9jUm9vdCA9IHRoaXMuZ2V0RG9jdW1lbnRSb290KCk7XG4gICAgaWYgKGRvY1Jvb3QpIHtcbiAgICAgIHJldHVybiBkb2NSb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfVxuICBnZXREb2N1bWVudFJvb3QoY3VycmVudCA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgY29uc3QgZG9jUm9vdCA9IGN1cnJlbnQ/Lm93bmVyRG9jdW1lbnQ/LmJvZHkgPz8gZ2V0RG9jdW1lbnQoXCJib2R5XCIpO1xuICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBkb2NSb290KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5wYXJlbnROb2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0Q2hpbGRCb3VuZGluZ0NsaWVudFJlY3QodHlwZSkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW3R5cGVdO1xuICAgIGNvbnN0IGNoaWxkUmVjdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICBjaGlsZFJlY3RzLnB1c2goQkJveC5mcm9tRE9NUmVjdChjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gQkJveC5tZXJnZShjaGlsZFJlY3RzKTtcbiAgfVxuICBjYWxjdWxhdGVDYW52YXNQb3NpdGlvbihlbCkge1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgY29uc3QgeyB4OiBjeCA9IDAsIHk6IGN5ID0gMCB9ID0gdGhpcy5nZXRDaGlsZEJvdW5kaW5nQ2xpZW50UmVjdChcImNhbnZhc1wiKSA/PyB7fTtcbiAgICBjb25zdCBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gZWxSZWN0LnggLSBjeDtcbiAgICB5ID0gZWxSZWN0LnkgLSBjeTtcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH1cbiAgaXNNYW5hZ2VkQ2hpbGRET01FbGVtZW50KGVsLCBkb21FbGVtZW50Q2xhc3MsIGlkKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5yb290RWxlbWVudHNbZG9tRWxlbWVudENsYXNzXTtcbiAgICBjb25zdCBzZWFyY2ggPSBjaGlsZHJlbj8uZ2V0KGlkKTtcbiAgICByZXR1cm4gc2VhcmNoICE9IG51bGwgJiYgZWwuY29udGFpbnMoc2VhcmNoKTtcbiAgfVxuICBpc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IGV2ZW50LnRhcmdldDtcbiAgICByZXR1cm4gZWxlbWVudDIgIT0gbnVsbCAmJiB0aGlzLmVsZW1lbnQuY29udGFpbnMoZWxlbWVudDIpO1xuICB9XG4gIGFkZFN0eWxlcyhpZCwgc3R5bGVzKSB7XG4gICAgdGhpcy5zdHlsZXNbaWRdID0gc3R5bGVzO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGUgPSBcImRhdGEtYWctY2hhcnRzXCI7XG4gICAgY29uc3QgZG9jdW1lbnRSb290ID0gdGhpcy5nZXREb2N1bWVudFJvb3QoKTtcbiAgICBsZXQgc3R5bGVFbGVtZW50O1xuICAgIGlmIChkb2N1bWVudFJvb3QgIT0gbnVsbCkge1xuICAgICAgc3R5bGVFbGVtZW50ID0gdGhpcy5hZGRDaGlsZChcInN0eWxlc1wiLCBpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlYWQgPSBnZXREb2N1bWVudChcImhlYWRcIik7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGhlYWQuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlKSA9PT0gaWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoc3R5bGVFbGVtZW50LmdldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlKSA9PT0gaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlLCBpZCk7XG4gICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IHN0eWxlcztcbiAgfVxuICByZW1vdmVTdHlsZXMoaWQpIHtcbiAgICB0aGlzLnJlbW92ZUNoaWxkKFwic3R5bGVzXCIsIGlkKTtcbiAgfVxuICB1cGRhdGVDdXJzb3Ioc3R5bGUpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gIH1cbiAgZ2V0Q3Vyc29yKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yO1xuICB9XG4gIGFkZENoaWxkKGRvbUVsZW1lbnRDbGFzcywgaWQsIGNoaWxkKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiwgY2hpbGRyZW4sIGxpc3RlbmVycyB9ID0gdGhpcy5yb290RWxlbWVudHNbZG9tRWxlbWVudENsYXNzXTtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gY3JlYXRlIERPTSBlbGVtZW50cyBhZnRlciBkZXN0cm95KClcIik7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nID0gY2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT0gbnVsbClcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICBjb25zdCB7IGNoaWxkRWxlbWVudFR5cGUgPSBcImRpdlwiIH0gPSBkb21FbGVtZW50Q29uZmlnLmdldChkb21FbGVtZW50Q2xhc3MpID8/IHt9O1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IGNoaWxkRWxlbWVudFR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gbWlzbWF0Y2hpbmcgRE9NIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZCA/PyBjcmVhdGVFbGVtZW50KGNoaWxkRWxlbWVudFR5cGUpO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIGZuLCBvcHRzXSBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgIG5ld0NoaWxkLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdHMpO1xuICAgIH1cbiAgICBjaGlsZHJlbi5zZXQoaWQsIG5ld0NoaWxkKTtcbiAgICBlbGVtZW50Mj8uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgIHJldHVybiBuZXdDaGlsZDtcbiAgfVxuICByZW1vdmVDaGlsZChkb21FbGVtZW50Q2xhc3MsIGlkKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5yb290RWxlbWVudHNbZG9tRWxlbWVudENsYXNzXTtcbiAgICBpZiAoIWNoaWxkcmVuKVxuICAgICAgcmV0dXJuO1xuICAgIGNoaWxkcmVuLmdldChpZCk/LnJlbW92ZSgpO1xuICAgIGNoaWxkcmVuLmRlbGV0ZShpZCk7XG4gIH1cbiAgaW5jcmVtZW50RGF0YUNvdW50ZXIobmFtZSkge1xuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpcy5lbGVtZW50O1xuICAgIGRhdGFzZXRbbmFtZV0gPz8gKGRhdGFzZXRbbmFtZV0gPSBcIjBcIik7XG4gICAgZGF0YXNldFtuYW1lXSA9IFN0cmluZyhOdW1iZXIoZGF0YXNldFtuYW1lXSkgKyAxKTtcbiAgfVxuICBnZXRJY29uQ2xhc3NOYW1lcyhpY29uKSB7XG4gICAgcmV0dXJuIGBhZy1jaGFydHMtaWNvbiBhZy1jaGFydHMtaWNvbi0ke2ljb259YDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvcG9seVJvb3RzLnRzXG5mdW5jdGlvbiBsaW5lYXJSb290KGEsIGIpIHtcbiAgY29uc3QgdCA9IC1iIC8gYTtcbiAgcmV0dXJuIGEgIT09IDAgJiYgdCA+PSAwICYmIHQgPD0gMSA/IFt0XSA6IFtdO1xufVxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdHMoYSwgYiwgYykge1xuICBpZiAoYSA9PT0gMCkge1xuICAgIHJldHVybiBsaW5lYXJSb290KGIsIGMpO1xuICB9XG4gIGNvbnN0IEQgPSBiICogYiAtIDQgKiBhICogYztcbiAgY29uc3Qgcm9vdHMgPSBbXTtcbiAgaWYgKEQgPT09IDApIHtcbiAgICBjb25zdCB0ID0gLWIgLyAoMiAqIGEpO1xuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChEID4gMCkge1xuICAgIGNvbnN0IHJEID0gTWF0aC5zcXJ0KEQpO1xuICAgIGNvbnN0IHQxID0gKC1iIC0gckQpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB0MiA9ICgtYiArIHJEKSAvICgyICogYSk7XG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0MSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdHM7XG59XG5mdW5jdGlvbiBjdWJpY1Jvb3RzKGEsIGIsIGMsIGQpIHtcbiAgaWYgKGEgPT09IDApIHtcbiAgICByZXR1cm4gcXVhZHJhdGljUm9vdHMoYiwgYywgZCk7XG4gIH1cbiAgY29uc3QgQSA9IGIgLyBhO1xuICBjb25zdCBCID0gYyAvIGE7XG4gIGNvbnN0IEMgPSBkIC8gYTtcbiAgY29uc3QgUSA9ICgzICogQiAtIEEgKiBBKSAvIDk7XG4gIGNvbnN0IFIgPSAoOSAqIEEgKiBCIC0gMjcgKiBDIC0gMiAqIEEgKiBBICogQSkgLyA1NDtcbiAgY29uc3QgRCA9IFEgKiBRICogUSArIFIgKiBSO1xuICBjb25zdCB0aGlyZCA9IDEgLyAzO1xuICBjb25zdCByb290cyA9IFtdO1xuICBpZiAoRCA+PSAwKSB7XG4gICAgY29uc3QgckQgPSBNYXRoLnNxcnQoRCk7XG4gICAgY29uc3QgUyA9IE1hdGguc2lnbihSICsgckQpICogTWF0aC5wb3coTWF0aC5hYnMoUiArIHJEKSwgdGhpcmQpO1xuICAgIGNvbnN0IFQgPSBNYXRoLnNpZ24oUiAtIHJEKSAqIE1hdGgucG93KE1hdGguYWJzKFIgLSByRCksIHRoaXJkKTtcbiAgICBjb25zdCBJbSA9IE1hdGguYWJzKE1hdGguc3FydCgzKSAqIChTIC0gVCkgLyAyKTtcbiAgICBjb25zdCB0ID0gLXRoaXJkICogQSArIChTICsgVCk7XG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godCk7XG4gICAgfVxuICAgIGlmIChJbSA9PT0gMCkge1xuICAgICAgY29uc3QgdDIgPSAtdGhpcmQgKiBBIC0gKFMgKyBUKSAvIDI7XG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0aGV0YSA9IE1hdGguYWNvcyhSIC8gTWF0aC5zcXJ0KC1RICogUSAqIFEpKTtcbiAgICBjb25zdCB0aGlyZEEgPSB0aGlyZCAqIEE7XG4gICAgY29uc3QgdHdvU3FydFEgPSAyICogTWF0aC5zcXJ0KC1RKTtcbiAgICBjb25zdCB0MSA9IHR3b1NxcnRRICogTWF0aC5jb3ModGhpcmQgKiB0aGV0YSkgLSB0aGlyZEE7XG4gICAgY29uc3QgdDIgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogKHRoZXRhICsgMiAqIE1hdGguUEkpKSAtIHRoaXJkQTtcbiAgICBjb25zdCB0MyA9IHR3b1NxcnRRICogTWF0aC5jb3ModGhpcmQgKiAodGhldGEgKyA0ICogTWF0aC5QSSkpIC0gdGhpcmRBO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDEpO1xuICAgIH1cbiAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQyKTtcbiAgICB9XG4gICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0Myk7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290cztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvaW50ZXJzZWN0aW9uLnRzXG5mdW5jdGlvbiBzZWdtZW50SW50ZXJzZWN0aW9uKGF4MSwgYXkxLCBheDIsIGF5MiwgYngxLCBieTEsIGJ4MiwgYnkyKSB7XG4gIGNvbnN0IGQgPSAoYXgyIC0gYXgxKSAqIChieTIgLSBieTEpIC0gKGF5MiAtIGF5MSkgKiAoYngyIC0gYngxKTtcbiAgaWYgKGQgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCB1YSA9ICgoYngyIC0gYngxKSAqIChheTEgLSBieTEpIC0gKGF4MSAtIGJ4MSkgKiAoYnkyIC0gYnkxKSkgLyBkO1xuICBjb25zdCB1YiA9ICgoYXgyIC0gYXgxKSAqIChheTEgLSBieTEpIC0gKGF5MiAtIGF5MSkgKiAoYXgxIC0gYngxKSkgLyBkO1xuICBpZiAodWEgPj0gMCAmJiB1YSA8PSAxICYmIHViID49IDAgJiYgdWIgPD0gMSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY3ViaWNTZWdtZW50SW50ZXJzZWN0aW9ucyhweDEsIHB5MSwgcHgyLCBweTIsIHB4MywgcHkzLCBweDQsIHB5NCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgbGV0IGludGVyc2VjdGlvbnMgPSAwO1xuICBjb25zdCBBID0geTEgLSB5MjtcbiAgY29uc3QgQiA9IHgyIC0geDE7XG4gIGNvbnN0IEMgPSB4MSAqICh5MiAtIHkxKSAtIHkxICogKHgyIC0geDEpO1xuICBjb25zdCBieCA9IGJlemllckNvZWZmaWNpZW50cyhweDEsIHB4MiwgcHgzLCBweDQpO1xuICBjb25zdCBieSA9IGJlemllckNvZWZmaWNpZW50cyhweTEsIHB5MiwgcHkzLCBweTQpO1xuICBjb25zdCBhID0gQSAqIGJ4WzBdICsgQiAqIGJ5WzBdO1xuICBjb25zdCBiID0gQSAqIGJ4WzFdICsgQiAqIGJ5WzFdO1xuICBjb25zdCBjID0gQSAqIGJ4WzJdICsgQiAqIGJ5WzJdO1xuICBjb25zdCBkID0gQSAqIGJ4WzNdICsgQiAqIGJ5WzNdICsgQztcbiAgY29uc3Qgcm9vdHMgPSBjdWJpY1Jvb3RzKGEsIGIsIGMsIGQpO1xuICBmb3IgKGNvbnN0IHQgb2Ygcm9vdHMpIHtcbiAgICBjb25zdCB0dCA9IHQgKiB0O1xuICAgIGNvbnN0IHR0dCA9IHQgKiB0dDtcbiAgICBjb25zdCB4ID0gYnhbMF0gKiB0dHQgKyBieFsxXSAqIHR0ICsgYnhbMl0gKiB0ICsgYnhbM107XG4gICAgY29uc3QgeSA9IGJ5WzBdICogdHR0ICsgYnlbMV0gKiB0dCArIGJ5WzJdICogdCArIGJ5WzNdO1xuICAgIGxldCBzO1xuICAgIGlmICh4MSA9PT0geDIpIHtcbiAgICAgIHMgPSAoeSAtIHkxKSAvICh5MiAtIHkxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9ICh4IC0geDEpIC8gKHgyIC0geDEpO1xuICAgIH1cbiAgICBpZiAocyA+PSAwICYmIHMgPD0gMSkge1xuICAgICAgaW50ZXJzZWN0aW9ucysrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn1cbmZ1bmN0aW9uIGJlemllckNvZWZmaWNpZW50cyhQMSwgUDIsIFAzLCBQNCkge1xuICByZXR1cm4gW1xuICAgIC8vIELDqXppZXIgZXhwcmVzc2VkIGFzIG1hdHJpeCBvcGVyYXRpb25zOlxuICAgIC1QMSArIDMgKiBQMiAtIDMgKiBQMyArIFA0LFxuICAgIC8vICAgICAgICAgICAgICAgICB8LTEgIDMgLTMgIDF8IHxQMXxcbiAgICAzICogUDEgLSA2ICogUDIgKyAzICogUDMsXG4gICAgLy8gICBbdF4zIHReMiB0IDFdIHwgMyAtNiAgMyAgMHwgfFAyfFxuICAgIC0zICogUDEgKyAzICogUDIsXG4gICAgLy8gICAgICAgICAgICAgICAgIHwtMyAgMyAgMCAgMHwgfFAzfFxuICAgIFAxXG4gICAgLy8gICAgICAgICAgICAgICAgIHwgMSAgMCAgMCAgMHwgfFA0fFxuICBdO1xufVxuZnVuY3Rpb24gYXJjSW50ZXJzZWN0aW9ucyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlLCB4MSwgeTEsIHgyLCB5Mikge1xuICBpZiAoaXNOYU4oY3gpIHx8IGlzTmFOKGN5KSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgW2VuZEFuZ2xlLCBzdGFydEFuZ2xlXSA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gIH1cbiAgY29uc3QgayA9ICh5MiAtIHkxKSAvICh4MiAtIHgxKTtcbiAgY29uc3QgeTAgPSB5MSAtIGsgKiB4MTtcbiAgY29uc3QgYSA9IE1hdGgucG93KGssIDIpICsgMTtcbiAgY29uc3QgYiA9IDIgKiAoayAqICh5MCAtIGN5KSAtIGN4KTtcbiAgY29uc3QgYyA9IE1hdGgucG93KGN4LCAyKSArIE1hdGgucG93KHkwIC0gY3ksIDIpIC0gTWF0aC5wb3cociwgMik7XG4gIGNvbnN0IGQgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcbiAgaWYgKGQgPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgaTF4ID0gKC1iICsgTWF0aC5zcXJ0KGQpKSAvIDIgLyBhO1xuICBjb25zdCBpMnggPSAoLWIgLSBNYXRoLnNxcnQoZCkpIC8gMiAvIGE7XG4gIGxldCBpbnRlcnNlY3Rpb25zID0gMDtcbiAgW2kxeCwgaTJ4XS5mb3JFYWNoKCh4KSA9PiB7XG4gICAgY29uc3QgaXNYSW5zaWRlTGluZSA9IHggPj0gTWF0aC5taW4oeDEsIHgyKSAmJiB4IDw9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgaWYgKCFpc1hJbnNpZGVMaW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHkgPSBrICogeCArIHkwO1xuICAgIGNvbnN0IGFkamFjZW50ID0geCAtIGN4O1xuICAgIGNvbnN0IG9wcG9zaXRlID0geSAtIGN5O1xuICAgIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIob3Bwb3NpdGUsIGFkamFjZW50KTtcbiAgICBpZiAoaXNCZXR3ZWVuQW5nbGVzKGFuZ2xlMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zKys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2V4dGVuZGVkUGF0aDJELnRzXG52YXIgRXh0ZW5kZWRQYXRoMkQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIFRoZSBtZXRob2RzIG9mIHRoaXMgY2xhc3Mgd2lsbCBsaWtlbHkgYmUgY2FsbGVkIG1hbnkgdGltZXMgcGVyIGFuaW1hdGlvbiBmcmFtZSxcbiAgICAvLyBhbmQgYW55IGFsbG9jYXRpb24gY2FuIHRyaWdnZXIgYSBHQyBjeWNsZSBkdXJpbmcgYW5pbWF0aW9uLCBzbyB3ZSBhdHRlbXB0XG4gICAgLy8gdG8gbWluaW1pemUgdGhlIG51bWJlciBvZiBhbGxvY2F0aW9ucy5cbiAgICB0aGlzLnBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzUGFyYW1zID0gW107XG4gICAgdGhpcy5wcmV2aW91c0Nsb3NlZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNsb3NlZFBhdGggPSBmYWxzZTtcbiAgfVxuICBpc0RpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLmNsb3NlZFBhdGggIT09IHRoaXMucHJldmlvdXNDbG9zZWRQYXRoIHx8IHRoaXMucHJldmlvdXNDb21tYW5kcy5sZW5ndGggIT09IHRoaXMuY29tbWFuZHMubGVuZ3RoIHx8IHRoaXMucHJldmlvdXNQYXJhbXMubGVuZ3RoICE9PSB0aGlzLnBhcmFtcy5sZW5ndGggfHwgdGhpcy5wcmV2aW91c0NvbW1hbmRzLnRvU3RyaW5nKCkgIT09IHRoaXMuY29tbWFuZHMudG9TdHJpbmcoKSB8fCB0aGlzLnByZXZpb3VzUGFyYW1zLnRvU3RyaW5nKCkgIT09IHRoaXMucGFyYW1zLnRvU3RyaW5nKCk7XG4gIH1cbiAgZ2V0UGF0aDJEKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGgyZDtcbiAgfVxuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMub3BlbmVkUGF0aCA9IHRydWU7XG4gICAgdGhpcy5wYXRoMmQubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgwIC8qIE1vdmUgKi8pO1xuICAgIHRoaXMucGFyYW1zLnB1c2goeCwgeSk7XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICBpZiAodGhpcy5vcGVuZWRQYXRoKSB7XG4gICAgICB0aGlzLnBhdGgyZC5saW5lVG8oeCwgeSk7XG4gICAgICB0aGlzLmNvbW1hbmRzLnB1c2goMSAvKiBMaW5lICovKTtcbiAgICAgIHRoaXMucGFyYW1zLnB1c2goeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuICByZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIGhlaWdodCk7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgfVxuICByb3VuZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaWkpIHtcbiAgICByYWRpaSA9IE1hdGgubWluKHJhZGlpLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIHRoaXMubW92ZVRvKHgsIHkgKyByYWRpaSk7XG4gICAgdGhpcy5hcmMoeCArIHJhZGlpLCB5ICsgcmFkaWksIHJhZGlpLCBNYXRoLlBJLCAxLjUgKiBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaWksIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCAtIHJhZGlpLCB5KTtcbiAgICB0aGlzLmFyYyh4ICsgd2lkdGggLSByYWRpaSwgeSArIHJhZGlpLCByYWRpaSwgMS41ICogTWF0aC5QSSwgMiAqIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCwgeSArIHJhZGlpKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpaSk7XG4gICAgdGhpcy5hcmMoeCArIHdpZHRoIC0gcmFkaWksIHkgKyBoZWlnaHQgLSByYWRpaSwgcmFkaWksIDAsIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpaSwgeSArIGhlaWdodCk7XG4gICAgdGhpcy5saW5lVG8oeCArIHJhZGlpLCB5ICsgaGVpZ2h0KTtcbiAgICB0aGlzLmFyYyh4ICsgK3JhZGlpLCB5ICsgaGVpZ2h0IC0gcmFkaWksIHJhZGlpLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSk7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIGhlaWdodCAtIHJhZGlpKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9XG4gIGFyYyh4LCB5LCByLCBzQW5nbGUsIGVBbmdsZSwgY291bnRlckNsb2Nrd2lzZSkge1xuICAgIHRoaXMub3BlbmVkUGF0aCA9IHRydWU7XG4gICAgdGhpcy5wYXRoMmQuYXJjKHgsIHksIHIsIHNBbmdsZSwgZUFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlKTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMiAvKiBBcmMgKi8pO1xuICAgIHRoaXMucGFyYW1zLnB1c2goeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UgPyAxIDogMCk7XG4gIH1cbiAgY3ViaWNDdXJ2ZVRvKGN4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeSkge1xuICAgIGlmICghdGhpcy5vcGVuZWRQYXRoKSB7XG4gICAgICB0aGlzLm1vdmVUbyhjeDEsIGN5MSk7XG4gICAgfVxuICAgIHRoaXMucGF0aDJkLmJlemllckN1cnZlVG8oY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMyAvKiBDdXJ2ZSAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaChjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHkpO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBpZiAodGhpcy5vcGVuZWRQYXRoKSB7XG4gICAgICB0aGlzLnBhdGgyZC5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuY29tbWFuZHMucHVzaCg0IC8qIENsb3NlUGF0aCAqLyk7XG4gICAgICB0aGlzLm9wZW5lZFBhdGggPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xvc2VkUGF0aCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNsZWFyKHRyYWNrQ2hhbmdlcykge1xuICAgIGlmICh0cmFja0NoYW5nZXMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgICB0aGlzLnByZXZpb3VzUGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCA9IHRoaXMuY2xvc2VkUGF0aDtcbiAgICB9XG4gICAgdGhpcy5wYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucGFyYW1zID0gW107XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGNvbnN0IG94ID0gLTFlNDtcbiAgICBjb25zdCBveSA9IC0xZTQ7XG4gICAgbGV0IHN4ID0gTmFOO1xuICAgIGxldCBzeSA9IE5hTjtcbiAgICBsZXQgcHggPSAwO1xuICAgIGxldCBweSA9IDA7XG4gICAgbGV0IGludGVyc2VjdGlvbkNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBjaSA9IDAsIHBpID0gMDsgY2kgPCBjbjsgY2krKykge1xuICAgICAgc3dpdGNoIChjb21tYW5kc1tjaV0pIHtcbiAgICAgICAgY2FzZSAwIC8qIE1vdmUgKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihzeCwgc3ksIHB4LCBweSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBzeCA9IHB4O1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHN5ID0gcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24ocHgsIHB5LCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSAtIDJdO1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBjdWJpY1NlZ21lbnRJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgcHgsXG4gICAgICAgICAgICBweSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG94LFxuICAgICAgICAgICAgb3ksXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgICk7XG4gICAgICAgICAgcHggPSBwYXJhbXNbcGkgLSAyXTtcbiAgICAgICAgICBweSA9IHBhcmFtc1twaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOlxuICAgICAgICAgIGNvbnN0IGN4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGN5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHIgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjb3VudGVyQ2xvY2t3aXNlID0gQm9vbGVhbihwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IGFyY0ludGVyc2VjdGlvbnMoXG4gICAgICAgICAgICBjeCxcbiAgICAgICAgICAgIGN5LFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgICAgIGNvdW50ZXJDbG9ja3dpc2UsXG4gICAgICAgICAgICBveCxcbiAgICAgICAgICAgIG95LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghaXNOYU4oc3gpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihweCwgcHksIHN0YXJ0WCwgc3RhcnRZLCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBweCA9IGN4ICsgTWF0aC5jb3MoZW5kQW5nbGUpICogcjtcbiAgICAgICAgICBweSA9IGN5ICsgTWF0aC5zaW4oZW5kQW5nbGUpICogcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uQ291bnQgJSAyID09PSAxO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgbGV0IGJlc3QgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY24gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN4ID0gTmFOO1xuICAgIGxldCBzeSA9IE5hTjtcbiAgICBsZXQgcHggPSAwO1xuICAgIGxldCBweSA9IDA7XG4gICAgZm9yIChsZXQgY2kgPSAwLCBwaSA9IDA7IGNpIDwgY247IGNpKyspIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIHB4ID0gc3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgcHkgPSBzeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86IHtcbiAgICAgICAgICBjb25zdCBueCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBueSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIG54LCBueSwgYmVzdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIExvZ2dlci5lcnJvcihcIkNvbW1hbmQuQ3VydmUgZGlzdGFuY2VTcXVhcmUgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOiB7XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgIGNvbnN0IGNvdW50ZXJDbG9ja3dpc2UgPSBCb29sZWFuKHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYmVzdCA9IGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgcHgsIHB5LCBzdGFydFgsIHN0YXJ0WSwgYmVzdCk7XG4gICAgICAgICAgYmVzdCA9IGFyY0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlLCBiZXN0KTtcbiAgICAgICAgICBweCA9IGN4ICsgTWF0aC5jb3MoZW5kQW5nbGUpICogcjtcbiAgICAgICAgICBweSA9IGN5ICsgTWF0aC5zaW4oZW5kQW5nbGUpICogcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGJlc3QgPSBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHB4LCBweSwgc3gsIHN5LCBiZXN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cbiAgZ2V0UG9pbnRzKCkge1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIHBhcmFtcyB9ID0gdGhpcztcbiAgICBjb25zdCBjb29yZHMgPSBbXTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBjb21tYW5kcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICBjYXNlIDEgLyogTGluZSAqLzpcbiAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgcGkgKz0gNDtcbiAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOlxuICAgICAgICAgIGNvb3Jkcy5wdXNoKHsgeDogcGFyYW1zW3BpKytdLCB5OiBwYXJhbXNbcGkrK10gfSk7XG4gICAgICAgICAgcGkgKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2RcbiAgY29tcHV0ZVNWR0RhdGFQYXRoKG94LCBveSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIHBhcmFtcyB9ID0gdGhpcztcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBjb21tYW5kcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiTVwiLCBveCArIHBhcmFtc1twaSsrXSwgb3kgKyBwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTGluZSAqLzpcbiAgICAgICAgICBidWZmZXIucHVzaChcIkxcIiwgb3ggKyBwYXJhbXNbcGkrK10sIG95ICsgcGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgXCJDXCIsXG4gICAgICAgICAgICBveCArIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG95ICsgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3ggKyBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBveSArIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG94ICsgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3kgKyBwYXJhbXNbcGkrK11cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOlxuICAgICAgICAgIGNvbnN0IFtjeCwgY3ksIHIsIGEwLCBhMSwgY2N3XSA9IFtcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXVxuICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3QgeDAgPSBveCArIGN4ICsgTWF0aC5jb3MoYTApICogcjtcbiAgICAgICAgICBjb25zdCB5MCA9IG95ICsgY3kgKyBNYXRoLnNpbihhMCkgKiByO1xuICAgICAgICAgIGNvbnN0IHgxID0gb3ggKyBjeCArIE1hdGguY29zKGExKSAqIHI7XG4gICAgICAgICAgY29uc3QgeTEgPSBveSArIGN5ICsgTWF0aC5zaW4oYTEpICogcjtcbiAgICAgICAgICBjb25zdCBsYXJnZUFyY0ZsYWcgPSBhbmdsZURpZmYoYTAsIGExLCAhIWNjdykgPiBNYXRoLlBJID8gMSA6IDA7XG4gICAgICAgICAgY29uc3Qgc3dlZXBGbGFnID0gKGNjdyArIDEpICUgMjtcbiAgICAgICAgICBjb25zdCBtb3ZlID0gYnVmZmVyLmxlbmd0aCA9PT0gMCA/IFwiTVwiIDogXCJMXCI7XG4gICAgICAgICAgYnVmZmVyLnB1c2gobW92ZSwgeDAsIHkwLCBcIkFcIiwgciwgciwgMCwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgxLCB5MSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9wYXRoLnRzXG5mdW5jdGlvbiBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDMgLyogTUFKT1IgKi8sIGNoYW5nZUNiLCBjb252ZXJ0b3IgfSA9IG9wdHMgPz8ge307XG4gIHJldHVybiBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdywgdHlwZTogXCJwYXRoXCIsIGNvbnZlcnRvciwgY2hhbmdlQ2IgfSk7XG59XG52YXIgUGF0aCA9IGNsYXNzIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIERlY2xhcmUgYSBwYXRoIHRvIHJldGFpbiBmb3IgbGF0ZXIgcmVuZGVyaW5nIGFuZCBoaXQgdGVzdGluZ1xuICAgICAqIHVzaW5nIGN1c3RvbSBQYXRoMkQgY2xhc3MuIFRoaW5rIG9mIGl0IGFzIGEgVHlwZVNjcmlwdCB2ZXJzaW9uXG4gICAgICogb2YgdGhlIG5hdGl2ZSBQYXRoMkQgKHdpdGggc29tZSBkaWZmZXJlbmNlcykgdGhhdCB3b3JrcyBpbiBhbGwgYnJvd3NlcnMuXG4gICAgICovXG4gICAgdGhpcy5wYXRoID0gbmV3IEV4dGVuZGVkUGF0aDJEKCk7XG4gICAgdGhpcy5fY2xpcFggPSBOYU47XG4gICAgdGhpcy5fY2xpcFkgPSBOYU47XG4gICAgLyoqXG4gICAgICogVGhlIHBhdGggb25seSBoYXMgdG8gYmUgdXBkYXRlZCB3aGVuIGNlcnRhaW4gYXR0cmlidXRlcyBjaGFuZ2UuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRyYW5zZm9ybSBhdHRyaWJ1dGVzIChzdWNoIGFzIGB0cmFuc2xhdGlvblhgKVxuICAgICAqIGFyZSBjaGFuZ2VkLCB3ZSBkb24ndCBoYXZlIHRvIHVwZGF0ZSB0aGUgcGF0aC4gVGhlIGBkaXJ0eVBhdGhgIGZsYWdcbiAgICAgKiBpcyBob3cgd2Uga2VlcCB0cmFjayBpZiB0aGUgcGF0aCBoYXMgdG8gYmUgdXBkYXRlZCBvciBub3QuXG4gICAgICovXG4gICAgdGhpcy5fZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgY2xpcFgodmFsdWUpIHtcbiAgICB0aGlzLl9jbGlwWCA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgY2xpcFkodmFsdWUpIHtcbiAgICB0aGlzLl9jbGlwWSA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgZGlydHlQYXRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5UGF0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2RpcnR5UGF0aCA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIDMgLyogTUFKT1IgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgZGlydHlQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eVBhdGg7XG4gIH1cbiAgY2hlY2tQYXRoRGlydHkoKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5UGF0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRoaXMucGF0aC5pc0RpcnR5KCkgfHwgKHRoaXMuZmlsbFNoYWRvdz8uaXNEaXJ0eSgpID8/IGZhbHNlKSB8fCAodGhpcy5fY2xpcFBhdGg/LmlzRGlydHkoKSA/PyBmYWxzZSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIHJldHVybiB0aGlzLnBhdGguY2xvc2VkUGF0aCAmJiB0aGlzLnBhdGguaXNQb2ludEluUGF0aChwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIGNvbXB1dGVTVkdEYXRhUGF0aCgpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuaW52ZXJzZVRyYW5zZm9ybVBvaW50KDAsIDApO1xuICAgIGlmICh0aGlzLmRpcnR5UGF0aCkge1xuICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICB0aGlzLmRpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoLmNvbXB1dGVTVkdEYXRhUGF0aCh4LCB5KTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50KHgsIHkpIHtcbiAgICBpZiAodGhpcy5wYXRoLmNsb3NlZFBhdGggJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgoeCwgeSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoLmRpc3RhbmNlU3F1YXJlZCh4LCB5KTtcbiAgfVxuICBpc0RpcnR5UGF0aCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCk7XG4gICAgaWYgKHRoaXMuZGlydHlQYXRoIHx8IHRoaXMuaXNEaXJ0eVBhdGgoKSkge1xuICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICB0aGlzLmRpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHRoaXMuX2NsaXBYKSAmJiAhaXNOYU4odGhpcy5fY2xpcFkpICYmIHRoaXMuY2xpcE1vZGUgIT0gbnVsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgdGhpcy5fY2xpcFBhdGggPz8gKHRoaXMuX2NsaXBQYXRoID0gbmV3IEV4dGVuZGVkUGF0aDJEKCkpO1xuICAgICAgdGhpcy5fY2xpcFBhdGguY2xlYXIoKTtcbiAgICAgIHRoaXMuX2NsaXBQYXRoLnJlY3QoLW1hcmdpbiwgLW1hcmdpbiwgdGhpcy5fY2xpcFggKyBtYXJnaW4sIHRoaXMuX2NsaXBZICsgbWFyZ2luICsgbWFyZ2luKTtcbiAgICAgIGlmICh0aGlzLmNsaXBNb2RlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIGN0eC5jbGlwKHRoaXMuX2NsaXBQYXRoPy5nZXRQYXRoMkQoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2xpcFggPiAwICYmIHRoaXMuX2NsaXBZID4gMCkge1xuICAgICAgICB0aGlzLmRyYXdQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGlwTW9kZSA9PT0gXCJwdW5jaC1vdXRcIikge1xuICAgICAgICBjdHguY2xpcCh0aGlzLl9jbGlwUGF0aD8uZ2V0UGF0aDJEKCkpO1xuICAgICAgICBjb25zdCB7IHggPSAtMWU0LCB5ID0gLTFlNCwgd2lkdGggPSAyZTQsIGhlaWdodCA9IDJlNCB9ID0gdGhpcy5nZXRCQm94KCkgPz8ge307XG4gICAgICAgIGN0eC5jbGVhclJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXdQYXRoKGN0eCk7XG4gICAgfVxuICAgIHRoaXMuZmlsbFNoYWRvdz8ubWFya0NsZWFuKCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbiAgZHJhd1BhdGgoY3R4KSB7XG4gICAgdGhpcy5maWxsU3Ryb2tlKGN0eCwgdGhpcy5wYXRoLmdldFBhdGgyRCgpKTtcbiAgfVxufTtcblBhdGguY2xhc3NOYW1lID0gXCJQYXRoXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUGF0aC5wcm90b3R5cGUsIFwiY2xpcE1vZGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUGF0aC5wcm90b3R5cGUsIFwiY2xpcFhcIiwgMSk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUGF0aC5wcm90b3R5cGUsIFwiY2xpcFlcIiwgMSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RvbS9mb2N1c1N0eWxlcy50c1xudmFyIGZvY3VzU3R5bGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZvY3VzU3R5bGVzX2V4cG9ydHMsIHtcbiAgYmxvY2s6ICgpID0+IGJsb2NrLFxuICBlbGVtZW50czogKCkgPT4gZWxlbWVudHMsXG4gIG1vZGlmaWVyczogKCkgPT4gbW9kaWZpZXJzXG59KTtcbnZhciBibG9jayA9IFwiYWctY2hhcnRzLWZvY3VzXCI7XG52YXIgZWxlbWVudHMgPSB7IGluZGljYXRvcjogXCJhZy1jaGFydHMtZm9jdXNfX2luZGljYXRvclwiLCBzdmc6IFwiYWctY2hhcnRzLWZvY3VzX19zdmdcIiB9O1xudmFyIG1vZGlmaWVycyA9IHsgaGlkZGVuOiBcImFnLWNoYXJ0cy1mb2N1cy0taGlkZGVuXCIgfTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZG9tL2ZvY3VzSW5kaWNhdG9yLnRzXG52YXIgRm9jdXNJbmRpY2F0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIGNvbnN0IHsgYmxvY2s6IGJsb2NrMywgZWxlbWVudHM6IGVsZW1lbnRzMywgbW9kaWZpZXJzOiBtb2RpZmllcnMzIH0gPSBmb2N1c1N0eWxlc19leHBvcnRzO1xuICAgIHRoaXMuZGl2ID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuc3ZnID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICB0aGlzLnBhdGggPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICB0aGlzLnN2Zy5hcHBlbmQodGhpcy5wYXRoKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYmxvY2szKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChibG9jazMsIGVsZW1lbnRzMy5pbmRpY2F0b3IsIG1vZGlmaWVyczMuaGlkZGVuKTtcbiAgICB0aGlzLmVsZW1lbnQuYXJpYUhpZGRlbiA9IFwidHJ1ZVwiO1xuICAgIHRoaXMuZWxlbWVudC5hcHBlbmQodGhpcy5zdmcpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhibG9jayk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYmxvY2spO1xuICB9XG4gIHVwZGF0ZUJvdW5kcyhib3VuZHMpIHtcbiAgICBpZiAoYm91bmRzID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG1vZGlmaWVycy5oaWRkZW4pO1xuICAgIH0gZWxzZSBpZiAoYm91bmRzIGluc3RhbmNlb2YgUGF0aCkge1xuICAgICAgdGhpcy5wYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgYm91bmRzLmNvbXB1dGVTVkdEYXRhUGF0aCgpKTtcbiAgICAgIHRoaXMuc2hvdyh0aGlzLnN2Zyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEVsZW1lbnRCQm94KHRoaXMuZGl2LCBib3VuZHMpO1xuICAgICAgdGhpcy5zaG93KHRoaXMuZGl2KTtcbiAgICB9XG4gIH1cbiAgc2hvdyhjaGlsZCkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKG1vZGlmaWVycy5oaWRkZW4pO1xuICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIHRoaXMuZWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kb20vYm91bmRlZFRleHQudHNcbnZhciBCb3VuZGVkVGV4dCA9IGNsYXNzIHtcbiAgc2V0IHRleHRDb250ZW50KHRleHQpIHtcbiAgICB0aGlzLnRleHRFbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICBjb25zdCBiYm94Q2FsY3VsYXRvciA9IHRoaXMudGV4dEVsZW1lbnQ7XG4gICAgY29uc3QgYmJveCA9IGJib3hDYWxjdWxhdG9yLmdldEJCb3g/LigpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgJHtiYm94Lnh9ICR7YmJveC55fSAke2Jib3gud2lkdGh9ICR7YmJveC5oZWlnaHR9YCk7XG4gICAgfVxuICB9XG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RWxlbWVudC50ZXh0Q29udGVudDtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRleHRFbGVtZW50ID0gY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0ZXh0XCIpO1xuICAgIHRoaXMudGV4dEVsZW1lbnQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudGV4dEVsZW1lbnQpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmJvdW5kZWRDb250YWluZXIucmVtb3ZlKCk7XG4gIH1cbiAgZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kZWRDb250YWluZXI7XG4gIH1cbiAgdXBkYXRlQm91bmRzKGJvdW5kcykge1xuICAgIHNldEVsZW1lbnRCQm94KHRoaXMuYm91bmRlZENvbnRhaW5lciwgYm91bmRzKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZG9tL3Byb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLnRzXG5mdW5jdGlvbiBjaGVja1R5cGUodHlwZSwgbWV0YSkge1xuICByZXR1cm4gbWV0YS5wYXJhbXM/LnR5cGUgPT09IHR5cGU7XG59XG5mdW5jdGlvbiBhbGxvY2F0ZVJlc3VsdCh0eXBlKSB7XG4gIGlmIChcImJ1dHRvblwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIH0gZWxzZSBpZiAoXCJzbGlkZXJcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gIH0gZWxzZSBpZiAoXCJ0b29sYmFyXCIgPT09IHR5cGUgfHwgXCJncm91cFwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIH0gZWxzZSBpZiAoXCJ0ZXh0XCIgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kZWRUZXh0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJBRyBDaGFydHMgLSBlcnJvciBhbGxvY2F0aW5nIG1ldGFcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbG9jYXRlTWV0YShwYXJhbXMpIHtcbiAgY29uc3QgbWV0YSA9IHsgcGFyYW1zLCByZXN1bHQ6IHZvaWQgMCB9O1xuICBtZXRhLnJlc3VsdCA9IGFsbG9jYXRlUmVzdWx0KG1ldGEucGFyYW1zLnR5cGUpO1xuICByZXR1cm4gbWV0YTtcbn1cbnZhciBQcm94eUludGVyYWN0aW9uU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodXBkYXRlU2VydmljZSwgbG9jYWxlTWFuYWdlciwgZG9tTWFuYWdlciwgZm9jdXNJbmRpY2F0b3IpIHtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvciA9IGZvY3VzSW5kaWNhdG9yO1xuICAgIC8vIFRoaXMgZGVidWcgb3B0aW9uIG1ha2UgdGhlIHByb3hpZXMgYnV0dG9uIHBhcnRpYWxseSB0cmFuc3BhcmVudCBpbnN0ZWFkIG9mIGZ1bGx5IHRyYW5zcGFyZW50LlxuICAgIC8vIFRvIGVuYWJsZWQgdGhpcyBvcHRpb24sIHNldCB3aW5kb3cuYWdDaGFydHNEZWJ1ZyA9IFsnc2hvd0RPTVByb3hpZXMnXS5cbiAgICB0aGlzLmRlYnVnU2hvd0RPTVByb3hpZXMgPSBEZWJ1Zy5jaGVjayhcInNob3dET01Qcm94aWVzXCIpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHVwZGF0ZVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJ1cGRhdGUtY29tcGxldGVcIiwgKCkgPT4gdGhpcy51cGRhdGUoKSkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNhYmxlKSB7XG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh0aGlzLmZvY3VzYWJsZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCkpO1xuICAgIH1cbiAgfVxuICBhZGRMb2NhbGlzYXRpb24oZm4pIHtcbiAgICBmbigpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHRoaXMubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsIGZuKSk7XG4gIH1cbiAgY3JlYXRlUHJveHlDb250YWluZXIoYXJncykge1xuICAgIGNvbnN0IG1ldGEgPSBhbGxvY2F0ZU1ldGEoYXJncyk7XG4gICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdDogZGl2IH0gPSBtZXRhO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIHBhcmFtcy5pZCwgZGl2KTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCguLi5wYXJhbXMuY2xhc3NMaXN0KTtcbiAgICBkaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIGRpdi5yb2xlID0gcGFyYW1zLnR5cGU7XG4gICAgZGl2LmFyaWFPcmllbnRhdGlvbiA9IHBhcmFtcy5hcmlhT3JpZW50YXRpb247XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuYXJpYUhpZGRlbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGRpdi5hcmlhSGlkZGVuID0gcGFyYW1zLmFyaWFIaWRkZW4udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5hZGRMb2NhbGlzYXRpb24oKCkgPT4ge1xuICAgICAgZGl2LmFyaWFMYWJlbCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHBhcmFtcy5hcmlhTGFiZWwuaWQsIHBhcmFtcy5hcmlhTGFiZWwucGFyYW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIGNyZWF0ZVByb3h5RWxlbWVudChhcmdzKSB7XG4gICAgY29uc3QgbWV0YSA9IGFsbG9jYXRlTWV0YShhcmdzKTtcbiAgICBpZiAoY2hlY2tUeXBlKFwiYnV0dG9uXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBidXR0b24gfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIGJ1dHRvbik7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRleHRDb250ZW50IH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuYWRkTG9jYWxpc2F0aW9uKCgpID0+IHtcbiAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmxvY2FsZU1hbmFnZXIudCh0ZXh0Q29udGVudC5pZCwgdGV4dENvbnRlbnQucGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGVja1R5cGUoXCJzbGlkZXJcIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IHNsaWRlciB9ID0gbWV0YTtcbiAgICAgIHRoaXMuaW5pdEludGVyYWN0KHBhcmFtcywgc2xpZGVyKTtcbiAgICAgIHNsaWRlci50eXBlID0gXCJyYW5nZVwiO1xuICAgICAgc2xpZGVyLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgc2xpZGVyLnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gICAgICBzbGlkZXIuYXJpYU9yaWVudGF0aW9uID0gcGFyYW1zLmFyaWFPcmllbnRhdGlvbjtcbiAgICAgIHRoaXMuYWRkTG9jYWxpc2F0aW9uKCgpID0+IHtcbiAgICAgICAgc2xpZGVyLmFyaWFMYWJlbCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHBhcmFtcy5hcmlhTGFiZWwuaWQsIHBhcmFtcy5hcmlhTGFiZWwucGFyYW1zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2hlY2tUeXBlKFwidGV4dFwiLCBtZXRhKSkge1xuICAgICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdDogdGV4dCB9ID0gbWV0YTtcbiAgICAgIHRoaXMuaW5pdEVsZW1lbnQocGFyYW1zLCB0ZXh0LmdldENvbnRhaW5lcigpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGEucmVzdWx0O1xuICB9XG4gIGluaXRFbGVtZW50KHBhcmFtcywgZWxlbWVudDIpIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnQgfSA9IHBhcmFtcztcbiAgICBlbGVtZW50Mi5pZCA9IGlkO1xuICAgIGVsZW1lbnQyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBlbGVtZW50Mi5zdHlsZS5vcGFjaXR5ID0gdGhpcy5kZWJ1Z1Nob3dET01Qcm94aWVzID8gXCIwLjI1XCIgOiBcIjBcIjtcbiAgICBlbGVtZW50Mi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBlbGVtZW50Mi5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChwYXJlbnQsIGlkLCBlbGVtZW50Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gICAgfVxuICB9XG4gIGluaXRJbnRlcmFjdChwYXJhbXMsIGVsZW1lbnQyKSB7XG4gICAgY29uc3QgeyBmb2N1c2FibGUsIG9uY2xpY2ssIG9uY2hhbmdlLCBvbmZvY3VzLCBvbmJsdXIsIHRhYkluZGV4IH0gPSBwYXJhbXM7XG4gICAgdGhpcy5pbml0RWxlbWVudChwYXJhbXMsIGVsZW1lbnQyKTtcbiAgICBpZiAodGFiSW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgZWxlbWVudDIudGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChfZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZm9jdXNhYmxlID0gZm9jdXNhYmxlO1xuICAgICAgZWxlbWVudDIuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyRXZlbnRzXCIsIG51bGwpO1xuICAgICAgdGhpcy5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHMoZm9jdXNhYmxlLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSk7XG4gICAgfSk7XG4gICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKF9ldmVudCkgPT4ge1xuICAgICAgdGhpcy5mb2N1c2FibGUgPSB2b2lkIDA7XG4gICAgICBlbGVtZW50Mi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh2b2lkIDApO1xuICAgIH0pO1xuICAgIGlmIChvbmNsaWNrKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25jbGljayk7XG4gICAgfVxuICAgIGlmIChvbmZvY3VzKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgb25mb2N1cyk7XG4gICAgfVxuICAgIGlmIChvbmJsdXIpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG9uYmx1cik7XG4gICAgfVxuICAgIGlmIChvbmNoYW5nZSkge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvbmNoYW5nZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9hbmltYXRpb25CYXRjaC50c1xudmFyIEFuaW1hdGlvbkJhdGNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXhBbmltYXRpb25UaW1lKSB7XG4gICAgdGhpcy5tYXhBbmltYXRpb25UaW1lID0gbWF4QW5pbWF0aW9uVGltZTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYW5pbWF0aW9uXCIpO1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3RvcHBlZENicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5jdXJyZW50UGhhc2UgPSAwO1xuICAgIHRoaXMucGhhc2VzID0gbmV3IE1hcChQSEFTRV9PUkRFUi5tYXAoKHApID0+IFtwLCBbXV0pKTtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgPSAwO1xuICAgIC8qKiBHdWFyZCBhZ2FpbnN0IHByZW1hdHVyZSBhbmltYXRpb24gZXhlY3V0aW9uLiAqL1xuICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzLnNpemU7XG4gIH1cbiAgZ2V0IGNvbnN1bWVkVGltZU1zKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZDtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sbGVycy5zaXplID4gMDtcbiAgfVxuICBnZXRBY3RpdmVDb250cm9sbGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5waGFzZXMuZ2V0KFBIQVNFX09SREVSW3RoaXMuY3VycmVudFBoYXNlXSkgPz8gW107XG4gIH1cbiAgY2hlY2tPdmVybGFwcGluZ0lkKGlkKSB7XG4gICAgaWYgKGlkICE9IG51bGwgJiYgdGhpcy5jb250cm9sbGVycy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXJzLmdldChpZCkuc3RvcCgpO1xuICAgICAgdGhpcy5kZWJ1ZyhgU2tpcHBpbmcgYW5pbWF0aW9uIGJhdGNoIGR1ZSB0byB1cGRhdGUgb2YgZXhpc3RpbmcgYW5pbWF0aW9uOiAke2lkfWApO1xuICAgICAgdGhpcy5za2lwKCk7XG4gICAgfVxuICB9XG4gIGFkZEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICBpZiAoYW5pbWF0aW9uLmlzQ29tcGxldGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYW5pbWF0aW9uUGhhc2VJZHggPSBQSEFTRV9PUkRFUi5pbmRleE9mKGFuaW1hdGlvbi5waGFzZSk7XG4gICAgaWYgKGFuaW1hdGlvblBoYXNlSWR4IDwgdGhpcy5jdXJyZW50UGhhc2UpIHtcbiAgICAgIHRoaXMuZGVidWcoYFNraXBwaW5nIGFuaW1hdGlvbiBkdWUgdG8gYmVpbmcgZm9yIGFuIGVhcmxpZXIgcGhhc2VgLCBhbmltYXRpb24uaWQpO1xuICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVycy5zZXQoYW5pbWF0aW9uLmlkLCBhbmltYXRpb24pO1xuICAgIHRoaXMucGhhc2VzLmdldChhbmltYXRpb24ucGhhc2UpPy5wdXNoKGFuaW1hdGlvbik7XG4gIH1cbiAgcmVtb3ZlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgIHRoaXMuY29udHJvbGxlcnMuZGVsZXRlKGFuaW1hdGlvbi5pZCk7XG4gICAgY29uc3QgcGhhc2UgPSB0aGlzLnBoYXNlcy5nZXQoYW5pbWF0aW9uLnBoYXNlKTtcbiAgICBjb25zdCBpbmRleCA9IHBoYXNlPy5pbmRleE9mKGFuaW1hdGlvbik7XG4gICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXggPj0gMCkge1xuICAgICAgcGhhc2U/LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIHByb2dyZXNzKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB1bnVzZWRUaW1lID0gZGVsdGFUaW1lID09PSAwID8gMC4wMSA6IGRlbHRhVGltZTtcbiAgICBjb25zdCByZWZyZXNoID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGhhc2UyID0gUEhBU0VfT1JERVJbdGhpcy5jdXJyZW50UGhhc2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGhhc2VDb250cm9sbGVyczogWy4uLnRoaXMuZ2V0QWN0aXZlQ29udHJvbGxlcnMoKV0sXG4gICAgICAgIHBoYXNlOiBwaGFzZTIsXG4gICAgICAgIHBoYXNlTWV0YTogUEhBU0VfTUVUQURBVEFbcGhhc2UyXVxuICAgICAgfTtcbiAgICB9O1xuICAgIGxldCB7IHBoYXNlLCBwaGFzZUNvbnRyb2xsZXJzLCBwaGFzZU1ldGEgfSA9IHJlZnJlc2goKTtcbiAgICBjb25zdCBhcmVQaGFzZXNDb21wbGV0ZSA9ICgpID0+IFBIQVNFX09SREVSW3RoaXMuY3VycmVudFBoYXNlXSA9PSBudWxsO1xuICAgIGNvbnN0IHByb2dyZXNzUGhhc2UgPSAoKSA9PiB7XG4gICAgICAoeyBwaGFzZSwgcGhhc2VDb250cm9sbGVycywgcGhhc2VNZXRhIH0gPSByZWZyZXNoKCkpO1xuICAgICAgd2hpbGUgKCFhcmVQaGFzZXNDb21wbGV0ZSgpICYmIHBoYXNlQ29udHJvbGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBoYXNlKys7XG4gICAgICAgICh7IHBoYXNlLCBwaGFzZUNvbnRyb2xsZXJzLCBwaGFzZU1ldGEgfSA9IHJlZnJlc2goKSk7XG4gICAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gcGhhc2UgY2hhbmdpbmcgdG8gJHtwaGFzZX1gLCB7IHVudXNlZFRpbWUgfSwgcGhhc2VDb250cm9sbGVycyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuY29udHJvbGxlcnMuc2l6ZTtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtICR7ZGVsdGFUaW1lfW1zOyBwaGFzZSAke3BoYXNlfSB3aXRoICR7cGhhc2VDb250cm9sbGVycz8ubGVuZ3RofSBvZiAke3RvdGFsfWApO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHBoYXNlRGVsdGFUaW1lID0gdW51c2VkVGltZTtcbiAgICAgIGNvbnN0IHNraXBQaGFzZSA9IHBoYXNlTWV0YS5za2lwSWZOb0VhcmxpZXJBbmltYXRpb25zICYmIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkID09PSAwO1xuICAgICAgbGV0IGNvbXBsZXRlQ291bnQgPSAwO1xuICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHBoYXNlQ29udHJvbGxlcnMpIHtcbiAgICAgICAgaWYgKHNraXBQaGFzZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVudXNlZFRpbWUgPSBNYXRoLm1pbihjb250cm9sbGVyLnVwZGF0ZShwaGFzZURlbHRhVGltZSksIHVudXNlZFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICBjb21wbGV0ZUNvdW50Kys7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24oY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkICs9IHBoYXNlRGVsdGFUaW1lIC0gdW51c2VkVGltZTtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gdXBkYXRlZCAke3BoYXNlQ29udHJvbGxlcnMubGVuZ3RofSBjb250cm9sbGVyczsgJHtjb21wbGV0ZUNvdW50fSBjb21wbGV0ZWRgKTtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gYW5pbWF0aW9uVGltZUNvbnN1bWVkOiAke3RoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkfWApO1xuICAgICAgcHJvZ3Jlc3NQaGFzZSgpO1xuICAgIH0gd2hpbGUgKHVudXNlZFRpbWUgPiAwICYmICFhcmVQaGFzZXNDb21wbGV0ZSgpKTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgPiB0aGlzLm1heEFuaW1hdGlvblRpbWUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgXCJBbmltYXRpb24gYmF0Y2ggZXhjZWVkZWQgbWF4IGFuaW1hdGlvbiB0aW1lLCBza2lwcGluZy5cIixcbiAgICAgICAgbmV3IE1hcCh0aGlzLmNvbnRyb2xsZXJzLmVudHJpZXMoKSlcbiAgICAgICk7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgcmVhZHkoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gcmVhZHk7IHNraXBwZWQ6ICR7dGhpcy5za2lwQW5pbWF0aW9uc31gLCBbLi4udGhpcy5jb250cm9sbGVyc10pO1xuICAgIGxldCBza2lwQWxsID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IFssIGNvbnRyb2xsZXJdIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgIGlmIChjb250cm9sbGVyLmR1cmF0aW9uID4gMCAmJiBQSEFTRV9NRVRBREFUQVtjb250cm9sbGVyLnBoYXNlXS5za2lwSWZOb0VhcmxpZXJBbmltYXRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgIHNraXBBbGwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2tpcEFsbCkge1xuICAgICAgZm9yIChjb25zdCBbLCBjb250cm9sbGVyXSBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLmF1dG9wbGF5KSB7XG4gICAgICAgICAgY29udHJvbGxlci5wbGF5KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNraXAoc2tpcCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5za2lwQW5pbWF0aW9ucyA9PT0gZmFsc2UgJiYgc2tpcCA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBza2lwO1xuICB9XG4gIHBsYXkoKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnRyb2xsZXIucGxheSgpO1xuICAgIH1cbiAgfVxuICBwYXVzZSgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgY29udHJvbGxlci5wYXVzZSgpO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24oY29udHJvbGxlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBMb2dnZXIuZXJyb3IoXCJFcnJvciBkdXJpbmcgYW5pbWF0aW9uIHN0b3BcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoU3RvcHBlZCgpO1xuICB9XG4gIHN0b3BCeUFuaW1hdGlvbklkKGlkKSB7XG4gICAgaWYgKGlkICE9IG51bGwgJiYgdGhpcy5jb250cm9sbGVycy5oYXMoaWQpKSB7XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVycy5nZXQoaWQpO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5pbWF0aW9uKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChjb250cm9sbGVyLmdyb3VwSWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuc3RvcEJ5QW5pbWF0aW9uSWQoY29udHJvbGxlci5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc3BhdGNoU3RvcHBlZCgpIHtcbiAgICB0aGlzLnN0b3BwZWRDYnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIHRoaXMuc3RvcHBlZENicy5jbGVhcigpO1xuICB9XG4gIGlzU2tpcHBlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5za2lwQW5pbWF0aW9ucztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuY29udHJvbGxlcnMuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vcHJldmVudGFibGVFdmVudC50c1xuZnVuY3Rpb24gYnVpbGRQcmV2ZW50YWJsZShvYmopIHtcbiAgY29uc3Qgc2VsZiA9IHtcbiAgICAuLi5vYmosXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICBzZWxmLnNvdXJjZUV2ZW50Py5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBkaXNwYXRjaFR5cGVkRXZlbnQobGlzdGVuZXJzLCBldmVudCkge1xuICBsaXN0ZW5lcnMuZGlzcGF0Y2hXcmFwSGFuZGxlcnMoZXZlbnQudHlwZSwgKGhhbmRsZXIsIGUpID0+IGhhbmRsZXIoZSksIGJ1aWxkUHJldmVudGFibGUoZXZlbnQpKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vaW50ZXJhY3Rpb25NYW5hZ2VyLnRzXG52YXIgUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUyA9IFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwiY29udGV4dG1lbnVcIixcbiAgXCJob3ZlclwiLFxuICBcImRyYWctc3RhcnRcIixcbiAgXCJkcmFnXCIsXG4gIFwiZHJhZy1lbmRcIixcbiAgXCJsZWF2ZVwiLFxuICBcImVudGVyXCIsXG4gIFwicGFnZS1sZWZ0XCIsXG4gIFwid2hlZWxcIlxuXTtcbnZhciBGT0NVU19JTlRFUkFDVElPTl9UWVBFUyA9IFtcImJsdXJcIiwgXCJmb2N1c1wiXTtcbnZhciBLRVlfSU5URVJBQ1RJT05fVFlQRVMgPSBbXCJrZXlkb3duXCIsIFwia2V5dXBcIl07XG52YXIgU0hBRE9XX0RPTV9IQU5ETEVSUyA9IFtcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIl07XG52YXIgV0lORE9XX0VWRU5UX0hBTkRMRVJTID0gW1wicGFnZWhpZGVcIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCJdO1xudmFyIEVWRU5UX0hBTkRMRVJTID0gW1xuICBcImNsaWNrXCIsXG4gIFwiZGJsY2xpY2tcIixcbiAgXCJjb250ZXh0bWVudVwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcIm1vdXNlbGVhdmVcIixcbiAgXCJtb3VzZWVudGVyXCIsXG4gIFwidG91Y2hzdGFydFwiLFxuICBcInRvdWNobW92ZVwiLFxuICBcInRvdWNoZW5kXCIsXG4gIFwidG91Y2hjYW5jZWxcIixcbiAgXCJ3aGVlbFwiLFxuICBcImJsdXJcIixcbiAgXCJmb2N1c1wiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXl1cFwiXG5dO1xudmFyIEludGVyYWN0aW9uU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gKChJbnRlcmFjdGlvblN0YXRlMikgPT4ge1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkRlZmF1bHRcIl0gPSAxNl0gPSBcIkRlZmF1bHRcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJab29tRHJhZ1wiXSA9IDhdID0gXCJab29tRHJhZ1wiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkFubm90YXRpb25zXCJdID0gNF0gPSBcIkFubm90YXRpb25zXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQ29udGV4dE1lbnVcIl0gPSAyXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbmltYXRpb25cIl0gPSAxXSA9IFwiQW5pbWF0aW9uXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQWxsXCJdID0gMzFdID0gXCJBbGxcIjtcbiAgcmV0dXJuIEludGVyYWN0aW9uU3RhdGUyO1xufSkoSW50ZXJhY3Rpb25TdGF0ZSB8fCB7fSk7XG52YXIgUG9pbnRlckNhcHR1cmUgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyQ2FwdHVyZTIpID0+IHtcbiAgUG9pbnRlckNhcHR1cmUyW1wiUmV0YWluXCJdID0gXCJyZXRhaW5cIjtcbiAgUG9pbnRlckNhcHR1cmUyW1wiRXhjbHVzaXZlXCJdID0gXCJleGNsdXNpdmVcIjtcbiAgcmV0dXJuIFBvaW50ZXJDYXB0dXJlMjtcbn0pKFBvaW50ZXJDYXB0dXJlIHx8IHt9KTtcbnZhciBwb2ludGVyQ2FwdHVyZXMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoUG9pbnRlckNhcHR1cmUpKTtcbmZ1bmN0aW9uIGlzUG9pbnRlckV2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMuaW5jbHVkZXModHlwZSk7XG59XG5mdW5jdGlvbiBpc0ZvY3VzRXZlbnQodHlwZSkge1xuICByZXR1cm4gRk9DVVNfSU5URVJBQ1RJT05fVFlQRVMuaW5jbHVkZXModHlwZSk7XG59XG5mdW5jdGlvbiBpc0tleUV2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIEtFWV9JTlRFUkFDVElPTl9UWVBFUy5pbmNsdWRlcyh0eXBlKTtcbn1cbnZhciBfSW50ZXJhY3Rpb25NYW5hZ2VyID0gY2xhc3MgX0ludGVyYWN0aW9uTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioa2V5Ym9hcmRPcHRpb25zLCBkb21NYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleWJvYXJkT3B0aW9ucyA9IGtleWJvYXJkT3B0aW9ucztcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJpbnRlcmFjdGlvblwiKTtcbiAgICB0aGlzLmV2ZW50SGFuZGxlciA9IChldmVudCkgPT4gdGhpcy5wcm9jZXNzRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMub3ZlcmxheUV2ZW50SGFuZGxlciA9IChldmVudCkgPT4gdGhpcy5wcm9jZXNzQ2FudmFzT3ZlcmxheUV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMudG91Y2hEb3duID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGlja0hpc3RvcnkgPSBbeyBvZmZzZXRYOiBOYU4sIG9mZnNldFk6IE5hTiwgdHlwZTogXCJtb3VzZWRvd25cIiB9XTtcbiAgICB0aGlzLmRibGNsaWNrSGlzdG9yeSA9IFtcbiAgICAgIHsgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2Vkb3duXCIgfSxcbiAgICAgIHsgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2V1cFwiIH0sXG4gICAgICB7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNlZG93blwiIH1cbiAgICBdO1xuICAgIHRoaXMuc3RhdGVRdWV1ZSA9IDE2IC8qIERlZmF1bHQgKi8gfCAxIC8qIEFuaW1hdGlvbiAqLztcbiAgICB0aGlzLnJvb3RFbGVtZW50ID0gdGhpcy5kb21NYW5hZ2VyLmdldERvY3VtZW50Um9vdCgpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBFVkVOVF9IQU5ETEVSUykge1xuICAgICAgaWYgKHR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpIHx8IHR5cGUgPT09IFwid2hlZWxcIikge1xuICAgICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFdJTkRPV19FVkVOVF9IQU5ETEVSUykge1xuICAgICAgZ2V0V2luZG93KCkuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXJPbkVsZW1lbnQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm1vdXNlb3ZlclwiLCB0aGlzLm92ZXJsYXlFdmVudEhhbmRsZXIpLFxuICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXJPbkVsZW1lbnQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm1vdXNlb3V0XCIsIHRoaXMub3ZlcmxheUV2ZW50SGFuZGxlcilcbiAgICApO1xuICAgIHRoaXMuY29udGFpbmVyQ2hhbmdlZCh0cnVlKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJjb250YWluZXItY2hhbmdlZFwiLCAoKSA9PiB0aGlzLmNvbnRhaW5lckNoYW5nZWQoKSk7XG4gIH1cbiAgY29udGFpbmVyQ2hhbmdlZChmb3JjZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbmV3Um9vdCA9IHRoaXMuZG9tTWFuYWdlci5nZXREb2N1bWVudFJvb3QoKTtcbiAgICBpZiAoIWZvcmNlICYmIG5ld1Jvb3QgPT09IHRoaXMucm9vdEVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFNIQURPV19ET01fSEFORExFUlMpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICB0aGlzLnJvb3RFbGVtZW50ID0gbmV3Um9vdDtcbiAgICB0aGlzLmRlYnVnKFwiW0ludGVyYWN0aW9uTWFuYWdlcl0gU3dpdGNoaW5nIHJvb3RFbGVtZW50IHRvOlwiLCB0aGlzLnJvb3RFbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgU0hBRE9XX0RPTV9IQU5ETEVSUykge1xuICAgICAgdGhpcy5yb290RWxlbWVudD8uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBXSU5ET1dfRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIGdldFdpbmRvdygpLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgU0hBRE9XX0RPTV9IQU5ETEVSUykge1xuICAgICAgdGhpcy5yb290RWxlbWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBFVkVOVF9IQU5ETEVSUykge1xuICAgICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKFwiaW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuICB9XG4gIC8vIFdyYXBwZXIgdG8gb25seSBicm9hZGNhc3QgZXZlbnRzIHdoZW4gdGhlIEludGVyYWN0aW9uTWFuYWdlciBpcyBhIGdpdmVuIHN0YXRlLlxuICBhZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMTYgLyogRGVmYXVsdCAqLykge1xuICAgIHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcih0eXBlLCAoZSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmIHRyaWdnZXJpbmdTdGF0ZXMpIHtcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUgfD0gc3RhdGU7XG4gIH1cbiAgcG9wU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUgJj0gfnN0YXRlO1xuICB9XG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlUXVldWUgJiAtdGhpcy5zdGF0ZVF1ZXVlO1xuICB9XG4gIHByb2Nlc3NDYW52YXNPdmVybGF5RXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBjb29yZHMgPSB0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICBpZiAoY29vcmRzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBsZXQgcG9pbnRlckNhcHR1cmUgPSBudWxsO1xuICAgIHdoaWxlICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgcG9pbnRlckNhcHR1cmUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wb2ludGVyLWNhcHR1cmVcIik7XG4gICAgICBpZiAocG9pbnRlckNhcHR1cmUgPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgcG9pbnRlckNhcHR1cmUgPT0gbnVsbCB8fCAhcG9pbnRlckNhcHR1cmVzLmhhcyhwb2ludGVyQ2FwdHVyZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNPdmVyQ2FudmFzT3ZlcmxheSA9IGV2ZW50LnR5cGUgPT09IFwibW91c2VvdmVyXCI7XG4gICAgY29uc3QgcG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50ID0gaXNPdmVyQ2FudmFzT3ZlcmxheSA/IHRhcmdldCA6IHZvaWQgMDtcbiAgICBpZiAodGhpcy5wb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQgPT09IHBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudCA9IHBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudDtcbiAgICBpZiAocG9pbnRlckNhcHR1cmUgPT09IFwiZXhjbHVzaXZlXCIgLyogRXhjbHVzaXZlICovKSB7XG4gICAgICBkaXNwYXRjaFR5cGVkRXZlbnQoXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLFxuICAgICAgICB0aGlzLmJ1aWxkUG9pbnRlckV2ZW50KHsgdHlwZTogaXNPdmVyQ2FudmFzT3ZlcmxheSA/IFwibGVhdmVcIiA6IFwiZW50ZXJcIiwgZXZlbnQsIC4uLmNvb3JkcyB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZGVjaWRlSW50ZXJhY3Rpb25FdmVudFR5cGVzKGV2ZW50KTtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiB0YXJnZXQ/LmFyaWFEaXNhYmxlZCA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZSkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNwYXRjaEV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gICAgaWYgKGlzUG9pbnRlckV2ZW50KHR5cGUpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoUG9pbnRlckV2ZW50KGV2ZW50LCB0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9ID0gdGhpcy5leHRyYWN0RWxlbWVudHMoZXZlbnQpO1xuICAgIGlmIChpc0ZvY3VzRXZlbnQodHlwZSkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQ7XG4gICAgICBkaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHsgdHlwZSwgc291cmNlRXZlbnQsIHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0pO1xuICAgIH0gZWxzZSBpZiAoaXNLZXlFdmVudCh0eXBlKSkge1xuICAgICAgY29uc3Qgc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIGRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgeyB0eXBlLCBzb3VyY2VFdmVudCwgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSk7XG4gICAgfVxuICB9XG4gIGV4dHJhY3RFbGVtZW50cyhldmVudCkge1xuICAgIGxldCByZWxhdGVkRWxlbWVudDtcbiAgICBsZXQgdGFyZ2V0RWxlbWVudDtcbiAgICBpZiAoXCJyZWxhdGVkVGFyZ2V0XCIgaW4gZXZlbnQgJiYgZXZlbnRbXCJyZWxhdGVkVGFyZ2V0XCJdIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJlbGF0ZWRFbGVtZW50ID0gZXZlbnRbXCJyZWxhdGVkVGFyZ2V0XCJdO1xuICAgIH1cbiAgICBpZiAoXCJ0YXJnZXRcIiBpbiBldmVudCAmJiBldmVudFtcInRhcmdldFwiXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0YXJnZXRFbGVtZW50ID0gZXZlbnRbXCJ0YXJnZXRcIl07XG4gICAgfVxuICAgIHJldHVybiB7IHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH07XG4gIH1cbiAgZGlzcGF0Y2hQb2ludGVyRXZlbnQoZXZlbnQsIHR5cGUpIHtcbiAgICBjb25zdCBjb29yZHMgPSB0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICBpZiAoY29vcmRzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hUeXBlZEV2ZW50KHRoaXMubGlzdGVuZXJzLCB0aGlzLmJ1aWxkUG9pbnRlckV2ZW50KHsgdHlwZSwgZXZlbnQsIC4uLmNvb3JkcyB9KSk7XG4gIH1cbiAgZ2V0RXZlbnRIVE1MVGFyZ2V0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZWNvcmREb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgcGFydGlhbEFzc2lnbihbXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiXSwgdGhpcy5jbGlja0hpc3RvcnlbMF0sIGV2ZW50KTtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVswXSk7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVswXSwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdTdGFydEVsZW1lbnQgPSB0aGlzLmdldEV2ZW50SFRNTFRhcmdldChldmVudCk7XG4gIH1cbiAgcmVjb3JkVXAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVsxXSwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdTdGFydEVsZW1lbnQgPSB2b2lkIDA7XG4gIH1cbiAgZGVjaWRlSW50ZXJhY3Rpb25FdmVudFR5cGVzKGV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ1N0YXJ0ID0gXCJkcmFnLXN0YXJ0XCI7XG4gICAgaWYgKHRoaXMucG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50Py5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50ID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5Ym9hcmRPcHRpb25zLmVuYWJsZWQgPyBldmVudC50eXBlIDogdm9pZCAwO1xuICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICBjYXNlIFwiZGJsY2xpY2tcIjpcbiAgICAgIGNhc2UgXCJjb250ZXh0bWVudVwiOlxuICAgICAgY2FzZSBcIndoZWVsXCI6XG4gICAgICAgIHJldHVybiBldmVudC50eXBlO1xuICAgICAgY2FzZSBcIm1vdXNlZG93blwiOlxuICAgICAgICBpZiAoIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIHRoaXMucmVjb3JkRG93bihldmVudCk7XG4gICAgICAgIHJldHVybiBkcmFnU3RhcnQ7XG4gICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICBpZiAoIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoRG93biA9IHRydWU7XG4gICAgICAgIHRoaXMucmVjb3JkRG93bihldmVudCk7XG4gICAgICAgIHJldHVybiBkcmFnU3RhcnQ7XG4gICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgIGlmICghdGhpcy5tb3VzZURvd24gJiYgIXRoaXMudG91Y2hEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duIHx8IHRoaXMudG91Y2hEb3duID8gXCJkcmFnXCIgOiBcImhvdmVyXCI7XG4gICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvcmRVcChldmVudCk7XG4gICAgICAgIHJldHVybiBcImRyYWctZW5kXCI7XG4gICAgICBjYXNlIFwidG91Y2hlbmRcIjpcbiAgICAgICAgaWYgKCF0aGlzLnRvdWNoRG93biAmJiAhdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb3JkVXAoZXZlbnQpO1xuICAgICAgICByZXR1cm4gXCJkcmFnLWVuZFwiO1xuICAgICAgY2FzZSBcIm1vdXNlbGVhdmVcIjpcbiAgICAgIGNhc2UgXCJ0b3VjaGNhbmNlbFwiOlxuICAgICAgICByZXR1cm4gXCJsZWF2ZVwiO1xuICAgICAgY2FzZSBcIm1vdXNlZW50ZXJcIjpcbiAgICAgICAgcmV0dXJuIFwiZW50ZXJcIjtcbiAgICAgIGNhc2UgXCJwYWdlaGlkZVwiOlxuICAgICAgICByZXR1cm4gXCJwYWdlLWxlZnRcIjtcbiAgICB9XG4gIH1cbiAgaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tTWFuYWdlci5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpO1xuICB9XG4gIGNhbGN1bGF0ZUNvb3JkaW5hdGVzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TW91c2VFdmVudENvb3JkcyhldmVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgVG91Y2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgIGNvbnN0IGxhc3RUb3VjaCA9IGV2ZW50LnRvdWNoZXNbMF0gPz8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9ID0gbGFzdFRvdWNoO1xuICAgICAgcmV0dXJuIHsgLi4uX0ludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUywgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZIH07XG4gICAgfSBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIFBhZ2VUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5wZXJzaXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9JbnRlcmFjdGlvbk1hbmFnZXIuTlVMTF9DT09SRFM7XG4gICAgfVxuICB9XG4gIGdldE1vdXNlRXZlbnRDb29yZHMoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQ7XG4gICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRFdmVudEhUTUxUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IHsgeCA9IDAsIHkgPSAwIH0gPSB0YXJnZXQgPyB0aGlzLmRvbU1hbmFnZXIuY2FsY3VsYXRlQ2FudmFzUG9zaXRpb24odGFyZ2V0KSA6IHt9O1xuICAgIGlmICh0aGlzLmRyYWdTdGFydEVsZW1lbnQgIT0gbnVsbCAmJiBldmVudC50YXJnZXQgIT09IHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0RHJhZ1N0YXJ0ID0gdGhpcy5kb21NYW5hZ2VyLmNhbGN1bGF0ZUNhbnZhc1Bvc2l0aW9uKHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCk7XG4gICAgICBvZmZzZXRYIC09IG9mZnNldERyYWdTdGFydC54IC0geDtcbiAgICAgIG9mZnNldFkgLT0gb2Zmc2V0RHJhZ1N0YXJ0LnkgLSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRYICs9IHg7XG4gICAgICBvZmZzZXRZICs9IHk7XG4gICAgfVxuICAgIHJldHVybiB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSwgb2Zmc2V0WCwgb2Zmc2V0WSB9O1xuICB9XG4gIGlzV2hlZWxFdmVudChldmVudCkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSBcIndoZWVsXCI7XG4gIH1cbiAgYnVpbGRQb2ludGVyRXZlbnQob3B0cykge1xuICAgIGNvbnN0IHsgdHlwZSwgZXZlbnQsIGNsaWVudFgsIGNsaWVudFkgfSA9IG9wdHM7XG4gICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgcGFnZVgsIHBhZ2VZIH0gPSBvcHRzO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIob2Zmc2V0WCkgfHwgIWlzRmluaXRlTnVtYmVyKG9mZnNldFkpKSB7XG4gICAgICBjb25zdCByZWN0ID0gdGhpcy5kb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgb2Zmc2V0WCA9IGNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICBvZmZzZXRZID0gY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHBhZ2VYKSB8fCAhaXNGaW5pdGVOdW1iZXIocGFnZVkpKSB7XG4gICAgICBjb25zdCBwYWdlUmVjdCA9IHRoaXMucm9vdEVsZW1lbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcGFnZVggPSBjbGllbnRYIC0gKHBhZ2VSZWN0Py5sZWZ0ID8/IDApO1xuICAgICAgcGFnZVkgPSBjbGllbnRZIC0gKHBhZ2VSZWN0Py50b3AgPz8gMCk7XG4gICAgfVxuICAgIGxldCBbZGVsdGFYLCBkZWx0YVldID0gW05hTiwgTmFOXTtcbiAgICBpZiAodGhpcy5pc1doZWVsRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBldmVudC5kZWx0YU1vZGUgPT09IDAgPyAwLjAxIDogMTtcbiAgICAgIGRlbHRhWCA9IGV2ZW50LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgIGRlbHRhWSA9IGV2ZW50LmRlbHRhWSAqIGZhY3RvcjtcbiAgICB9XG4gICAgbGV0IHBvaW50ZXJIaXN0b3J5ID0gW107XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgcG9pbnRlckhpc3RvcnkgPSB0aGlzLmNsaWNrSGlzdG9yeTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwiZGJsY2xpY2tcIikge1xuICAgICAgcG9pbnRlckhpc3RvcnkgPSB0aGlzLmRibGNsaWNrSGlzdG9yeTtcbiAgICB9XG4gICAgY29uc3QgeyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9ID0gdGhpcy5leHRyYWN0RWxlbWVudHMoZXZlbnQpO1xuICAgIGNvbnN0IGJ1dHRvbiA9IFwiYnV0dG9uXCIgaW4gZXZlbnQgPyBOdW1iZXIoZXZlbnQuYnV0dG9uKSA6IDA7XG4gICAgY29uc3QgYnVpbHRFdmVudCA9IHtcbiAgICAgIHR5cGUsXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVksXG4gICAgICBkZWx0YVgsXG4gICAgICBkZWx0YVksXG4gICAgICBidXR0b24sXG4gICAgICBwb2ludGVySGlzdG9yeSxcbiAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgIHJlbGF0ZWRFbGVtZW50LFxuICAgICAgdGFyZ2V0RWxlbWVudFxuICAgIH07XG4gICAgdGhpcy5kZWJ1ZyhcIkludGVyYWN0aW9uTWFuYWdlciAtIGJ1aWx0RXZlbnQ6IFwiLCBidWlsdEV2ZW50KTtcbiAgICByZXR1cm4gYnVpbHRFdmVudDtcbiAgfVxufTtcbl9JbnRlcmFjdGlvbk1hbmFnZXIuTlVMTF9DT09SRFMgPSB7XG4gIGNsaWVudFg6IC1JbmZpbml0eSxcbiAgY2xpZW50WTogLUluZmluaXR5LFxuICBwYWdlWDogLUluZmluaXR5LFxuICBwYWdlWTogLUluZmluaXR5LFxuICBvZmZzZXRYOiAtSW5maW5pdHksXG4gIG9mZnNldFk6IC1JbmZpbml0eVxufTtcbnZhciBJbnRlcmFjdGlvbk1hbmFnZXIgPSBfSW50ZXJhY3Rpb25NYW5hZ2VyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9hbmltYXRpb25NYW5hZ2VyLnRzXG5mdW5jdGlvbiB2YWxpZEFuaW1hdGlvbkR1cmF0aW9uKHRlc3RlZSkge1xuICBpZiAodGVzdGVlID09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiAhaXNOYU4odGVzdGVlKSAmJiB0ZXN0ZWUgPj0gMCAmJiB0ZXN0ZWUgPD0gMjtcbn1cbnZhciBBbmltYXRpb25NYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlciwgY2hhcnRVcGRhdGVNdXRleCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBpbnRlcmFjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5jaGFydFVwZGF0ZU11dGV4ID0gY2hhcnRVcGRhdGVNdXRleDtcbiAgICB0aGlzLmRlZmF1bHREdXJhdGlvbiA9IDFlMztcbiAgICB0aGlzLmJhdGNoID0gbmV3IEFuaW1hdGlvbkJhdGNoKHRoaXMuZGVmYXVsdER1cmF0aW9uICogMS41KTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYW5pbWF0aW9uXCIpO1xuICAgIHRoaXMucmFmQXZhaWxhYmxlID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50QW5vbnltb3VzQW5pbWF0aW9uSWQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIHRvIHR3ZWVuIGEgdmFsdWUgYmV0d2VlbiB0aGUgYGZyb21gIGFuZCBgdG9gIHByb3BlcnRpZXMuIElmIGFuIGFuaW1hdGlvbiBhbHJlYWR5IGV4aXN0c1xuICAgKiB3aXRoIHRoZSBzYW1lIGBpZGAsIGltbWVkaWF0ZWx5IHN0b3AgaXQuXG4gICAqL1xuICBhbmltYXRlKHsgLi4ub3B0cyB9KSB7XG4gICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoO1xuICAgIHRyeSB7XG4gICAgICBiYXRjaC5jaGVja092ZXJsYXBwaW5nSWQob3B0cy5pZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgaWQgfSA9IG9wdHM7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIGlkID0gYF9fJHt0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZH1gO1xuICAgICAgdGhpcy5jdXJyZW50QW5vbnltb3VzQW5pbWF0aW9uSWQgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgc2tpcCA9IHRoaXMuaXNTa2lwcGVkKCkgfHwgb3B0cy5waGFzZSA9PT0gXCJub25lXCI7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyIC0gc2tpcHBpbmcgYW5pbWF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGRlbGF5LCBkdXJhdGlvbiB9ID0gb3B0cztcbiAgICBpZiAoIXZhbGlkQW5pbWF0aW9uRHVyYXRpb24oZGVsYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuaW1hdGlvbiBkZWxheSBvZiAke2RlbGF5fSBpcyB1bnN1cHBvcnRlZCAoJHtpZH0pYCk7XG4gICAgfVxuICAgIGlmICghdmFsaWRBbmltYXRpb25EdXJhdGlvbihkdXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5pbWF0aW9uIGR1cmF0aW9uIG9mICR7ZHVyYXRpb259IGlzIHVuc3VwcG9ydGVkICgke2lkfSlgKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgaWQsXG4gICAgICBza2lwLFxuICAgICAgYXV0b3BsYXk6IHRoaXMuaXNQbGF5aW5nID8gb3B0cy5hdXRvcGxheSA6IGZhbHNlLFxuICAgICAgcGhhc2U6IG9wdHMucGhhc2UsXG4gICAgICBkZWZhdWx0RHVyYXRpb246IHRoaXMuZGVmYXVsdER1cmF0aW9uXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZm9yY2VUaW1lSnVtcChhbmltYXRpb24sIHRoaXMuZGVmYXVsdER1cmF0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoLmFkZEFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyLnBsYXkoKVwiKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5wbGF5KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKCk7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIucGF1c2UoKVwiKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5wYXVzZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyLnN0b3AoKVwiKTtcbiAgICB0aGlzLmJhdGNoLnN0b3AoKTtcbiAgfVxuICBzdG9wQnlBbmltYXRpb25JZChpZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnN0b3BCeUFuaW1hdGlvbklkKGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBzdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmF0Y2guc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZChpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgc2tpcChza2lwID0gdHJ1ZSkge1xuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBza2lwO1xuICB9XG4gIGlzU2tpcHBlZCgpIHtcbiAgICByZXR1cm4gIXRoaXMucmFmQXZhaWxhYmxlIHx8IHRoaXMuc2tpcEFuaW1hdGlvbnMgfHwgdGhpcy5iYXRjaC5pc1NraXBwZWQoKTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5iYXRjaC5pc0FjdGl2ZSgpO1xuICB9XG4gIHNraXBDdXJyZW50QmF0Y2goKSB7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uTWFuYWdlciAtIHNraXBDdXJyZW50QmF0Y2goKWAsIHsgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIH0pO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoLnNraXAoKTtcbiAgfVxuICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gZ3VhcmFudGVlIHRoYXQgYW5pbWF0aW9uIHVwZGF0ZXMgaGFwcGVuLiAqL1xuICBpc1NraXBwaW5nRnJhbWVzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBNb2NraW5nIHBvaW50IGZvciB0ZXN0cyB0byBjYXB0dXJlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxsYmFja3MuICovXG4gIHNjaGVkdWxlQW5pbWF0aW9uRnJhbWUoY2IpIHtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIHNraXAgYW5pbWF0aW9ucyB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuICovXG4gIGZvcmNlVGltZUp1bXAoX2FuaW1hdGlvbiwgX2RlZmF1bHREdXJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5yYWZBdmFpbGFibGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmJhdGNoLmlzQWN0aXZlKCkgfHwgdGhpcy5yZXF1ZXN0SWQgIT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHByZXZUaW1lO1xuICAgIGNvbnN0IG9uQW5pbWF0aW9uRnJhbWUgPSBhc3luYyAodGltZTIpID0+IHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVBbmltYXRpb25GcmFtZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGltZTIgLSAocHJldlRpbWUgPz8gdGltZTIpO1xuICAgICAgICBwcmV2VGltZSA9IHRpbWUyO1xuICAgICAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlciAtIG9uQW5pbWF0aW9uRnJhbWUoKVwiLCB7XG4gICAgICAgICAgY29udHJvbGxlcnNDb3VudDogdGhpcy5iYXRjaC5zaXplLFxuICAgICAgICAgIGRlbHRhVGltZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIucHVzaFN0YXRlKDEgLyogQW5pbWF0aW9uICovKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmJhdGNoLnByb2dyZXNzKGRlbHRhVGltZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYW5pbWF0aW9uLWZyYW1lXCIsIHtcbiAgICAgICAgICB0eXBlOiBcImFuaW1hdGlvbi1mcmFtZVwiLFxuICAgICAgICAgIGRlbHRhTXM6IGRlbHRhVGltZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5pc1NraXBwaW5nRnJhbWVzKCkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGFydFVwZGF0ZU11dGV4LmFjcXVpcmVJbW1lZGlhdGVseShleGVjdXRlQW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGFydFVwZGF0ZU11dGV4LmFjcXVpcmUoZXhlY3V0ZUFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJhdGNoLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUFuaW1hdGlvbkZyYW1lKG9uQW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXRjaC5zdG9wKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYW5pbWF0aW9uLXN0b3BcIiwge1xuICAgICAgICAgIHR5cGU6IFwiYW5pbWF0aW9uLXN0b3BcIixcbiAgICAgICAgICBkZWx0YU1zOiB0aGlzLmJhdGNoLmNvbnN1bWVkVGltZU1zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJhbmltYXRpb24tc3RhcnRcIiwge1xuICAgICAgdHlwZTogXCJhbmltYXRpb24tc3RhcnRcIixcbiAgICAgIGRlbHRhTXM6IDBcbiAgICB9KTtcbiAgICB0aGlzLnNjaGVkdWxlQW5pbWF0aW9uRnJhbWUob25BbmltYXRpb25GcmFtZSk7XG4gIH1cbiAgY2FuY2VsQW5pbWF0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlcXVlc3RJZCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RJZCk7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICB9XG4gIGZhaWxzYWZlT25FcnJvcihlcnJvciwgY2FuY2VsQW5pbWF0aW9uID0gdHJ1ZSkge1xuICAgIExvZ2dlci5lcnJvcihcIkVycm9yIGR1cmluZyBhbmltYXRpb24sIHNraXBwaW5nIGFuaW1hdGlvbnNcIiwgZXJyb3IpO1xuICAgIGlmIChjYW5jZWxBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0QmF0Y2goc2tpcEFuaW1hdGlvbnMpIHtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc3RhcnRCYXRjaCgpIHdpdGggc2tpcEFuaW1hdGlvbnM9JHtza2lwQW5pbWF0aW9uc30uYCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuYmF0Y2guc3RvcCgpO1xuICAgIHRoaXMuYmF0Y2guZGVzdHJveSgpO1xuICAgIHRoaXMuYmF0Y2ggPSBuZXcgQW5pbWF0aW9uQmF0Y2godGhpcy5kZWZhdWx0RHVyYXRpb24gKiAxLjUpO1xuICAgIGlmIChza2lwQW5pbWF0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5iYXRjaC5za2lwKCk7XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCkge1xuICAgIGlmICh0aGlzLmJhdGNoLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuYmF0Y2gucmVhZHkoKTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5wb3BTdGF0ZSgxIC8qIEFuaW1hdGlvbiAqLyk7XG4gICAgICBpZiAodGhpcy5iYXRjaC5pc1NraXBwZWQoKSkge1xuICAgICAgICB0aGlzLmJhdGNoLnNraXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJhdGNoU3RvcChjYikge1xuICAgIHRoaXMuYmF0Y2guc3RvcHBlZENicy5hZGQoY2IpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9hcmlhQW5ub3VuY2VtZW50U2VydmljZXMudHNcbnZhciBBcmlhQW5ub3VuY2VtZW50U2VydmljZSA9IGNsYXNzIF9BcmlhQW5ub3VuY2VtZW50U2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKGxvY2FsZU1hbmFnZXIsIGRvbU1hbmFnZXIsIGxheW91dFNlcnZpY2UpIHtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5sYXlvdXRTZXJ2aWNlID0gbGF5b3V0U2VydmljZTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYXJpYVwiKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmxpdmVFbGVtID0gX0FyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlLmNyZWF0ZUFubm91bmNlcigpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1wcm94eVwiLCBcImFnLWNoYXJ0cy1jYW52YXMtcHJveHlcIiwgdGhpcy5saXZlRWxlbSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGV2KSA9PiB0aGlzLm9uUmVzaXplKGV2KSksXG4gICAgICAoKSA9PiB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtcHJveHlcIiwgXCJhZy1jaGFydHMtY2FudmFzLXByb3h5XCIpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQW5ub3VuY2VyKCkge1xuICAgIGNvbnN0IGUgPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZS5jbGFzc0xpc3QuYWRkKFwiYWctY2hhcnRzLWFyaWEtYW5ub3VuY2VyXCIpO1xuICAgIHNldEF0dHJpYnV0ZShlLCBcInJvbGVcIiwgXCJzdGF0dXNcIik7XG4gICAgc2V0QXR0cmlidXRlKGUsIFwiYXJpYS1saXZlXCIsIFwiYXNzZXJ0aXZlXCIpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfVxuICBvblJlc2l6ZShldmVudCkge1xuICAgIHRoaXMubGl2ZUVsZW0uc3R5bGUud2lkdGggPSBgJHtldmVudC5jaGFydC53aWR0aH1weGA7XG4gICAgdGhpcy5saXZlRWxlbS5zdHlsZS5oZWlnaHQgPSBgJHtldmVudC5jaGFydC5oZWlnaHR9cHhgO1xuICB9XG4gIGFubm91bmNlVmFsdWUoaWQsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgbG9jYWxlTWFuYWdlciwgbGl2ZUVsZW0gfSA9IHRoaXM7XG4gICAgY29uc3QgdmFsdWUgPSBsb2NhbGVNYW5hZ2VyLnQoaWQsIHBhcmFtcyk7XG4gICAgdGhpcy5kZWJ1ZyhgQXJpYUFubm91bmNlbWVudFNlcnZpY2UgLSBhbm5vdW5jZVZhbHVlOiAke3ZhbHVlfWApO1xuICAgIGxpdmVFbGVtLnRleHRDb250ZW50ID0gXCJcXHhBMFwiO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gbGl2ZUVsZW0uaW5uZXJUZXh0ID0gdmFsdWUsIDE2KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY2hhcnRFdmVudE1hbmFnZXIudHNcbnZhciBDaGFydEV2ZW50TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBsZWdlbmRJdGVtQ2xpY2soc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQsIGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImxlZ2VuZC1pdGVtLWNsaWNrXCIsXG4gICAgICBzZXJpZXMsXG4gICAgICBpdGVtSWQsXG4gICAgICBlbmFibGVkLFxuICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgZXZlbnQpO1xuICB9XG4gIGxlZ2VuZEl0ZW1Eb3VibGVDbGljayhzZXJpZXMsIGl0ZW1JZCwgZW5hYmxlZCwgbnVtVmlzaWJsZUl0ZW1zLCBsZWdlbmRJdGVtTmFtZSkge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJsZWdlbmQtaXRlbS1kb3VibGUtY2xpY2tcIixcbiAgICAgIHNlcmllcyxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGVuYWJsZWQsXG4gICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgIG51bVZpc2libGVJdGVtc1xuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJsZWdlbmQtaXRlbS1kb3VibGUtY2xpY2tcIiwgZXZlbnQpO1xuICB9XG4gIGF4aXNIb3ZlcihheGlzSWQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJheGlzLWhvdmVyXCIsXG4gICAgICBheGlzSWQsXG4gICAgICBkaXJlY3Rpb25cbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYXhpcy1ob3ZlclwiLCBldmVudCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2NvbnRleHRNZW51UmVnaXN0cnkudHNcbnZhciBDb250ZXh0TWVudVJlZ2lzdHJ5ID0gY2xhc3MgX0NvbnRleHRNZW51UmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcihyZWdpb25NYW5hZ2VyKSB7XG4gICAgdGhpcy5kZWZhdWx0QWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuZGlzYWJsZWRBY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmhpZGRlbkFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIGNvbnN0IHsgRGVmYXVsdDogRGVmYXVsdDIsIENvbnRleHRNZW51IH0gPSBJbnRlcmFjdGlvblN0YXRlO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtyZWdpb25NYW5hZ2VyLmxpc3RlbkFsbChcImNvbnRleHRtZW51XCIsIChlKSA9PiB0aGlzLm9uQ29udGV4dE1lbnUoZSksIERlZmF1bHQyIHwgQ29udGV4dE1lbnUpXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChkKSA9PiBkKCkpO1xuICB9XG4gIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICBjb25zdCB0eXBlID0gX0NvbnRleHRNZW51UmVnaXN0cnkudG9Db250ZXh0VHlwZShldmVudC5yZWdpb24pO1xuICAgIGlmICh0eXBlID09PSBcImFsbFwiKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoQ29udGV4dChcImFsbFwiLCBldmVudCwge30pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdG9Db250ZXh0VHlwZShyZWdpb24pIHtcbiAgICBpZiAocmVnaW9uID09PSBcImxlZ2VuZFwiIHx8IHJlZ2lvbiA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIFwiYWxsXCI7XG4gIH1cbiAgc3RhdGljIGNoZWNrKHR5cGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IHR5cGU7XG4gIH1cbiAgc3RhdGljIGNoZWNrQ2FsbGJhY2soZGVzaXJlZFR5cGUsIHR5cGUsIF9jYWxsYmFjaykge1xuICAgIHJldHVybiBkZXNpcmVkVHlwZSA9PT0gdHlwZTtcbiAgfVxuICBkaXNwYXRjaENvbnRleHQodHlwZSwgcG9pbnRlckV2ZW50LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBvZmZzZXRYOiB4LCBvZmZzZXRZOiB5LCBzb3VyY2VFdmVudCB9ID0gcG9pbnRlckV2ZW50O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiXCIsIGJ1aWxkUHJldmVudGFibGUoeyB0eXBlLCB4LCB5LCBjb250ZXh0LCBzb3VyY2VFdmVudCB9KSk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hZGRMaXN0ZW5lcihcIlwiLCBoYW5kbGVyKTtcbiAgfVxuICBmaWx0ZXJBY3Rpb25zKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0QWN0aW9ucy5maWx0ZXIoKGFjdGlvbikgPT4ge1xuICAgICAgcmV0dXJuIGFjdGlvbi5pZCAmJiAhdGhpcy5oaWRkZW5BY3Rpb25zLmhhcyhhY3Rpb24uaWQpICYmIFtcImFsbFwiLCB0eXBlXS5pbmNsdWRlcyhhY3Rpb24udHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJEZWZhdWx0QWN0aW9uKGFjdGlvbikge1xuICAgIGlmIChhY3Rpb24uaWQgJiYgdGhpcy5kZWZhdWx0QWN0aW9ucy5maW5kKCh7IGlkIH0pID0+IGlkID09PSBhY3Rpb24uaWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVmYXVsdEFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9XG4gIGVuYWJsZUFjdGlvbihhY3Rpb25JZCkge1xuICAgIHRoaXMuZGlzYWJsZWRBY3Rpb25zLmRlbGV0ZShhY3Rpb25JZCk7XG4gIH1cbiAgZGlzYWJsZUFjdGlvbihhY3Rpb25JZCkge1xuICAgIHRoaXMuZGlzYWJsZWRBY3Rpb25zLmFkZChhY3Rpb25JZCk7XG4gIH1cbiAgc2V0QWN0aW9uVmlzaWJsaXR5KGFjdGlvbklkLCB2aXNpYmxlKSB7XG4gICAgaWYgKHZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZGVuQWN0aW9ucy5kZWxldGUoYWN0aW9uSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGRlbkFjdGlvbnMuYWRkKGFjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgaXNEaXNhYmxlZChhY3Rpb25JZCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkQWN0aW9ucy5oYXMoYWN0aW9uSWQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3N0YXRlVHJhY2tlci50c1xudmFyIFN0YXRlVHJhY2tlciA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlLCBkZWZhdWx0U3RhdGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRlSWQoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlzKCkpLnBvcCgpID8/IHRoaXMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIHN0YXRlVmFsdWUoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSkucG9wKCkgPz8gdGhpcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2N1cnNvck1hbmFnZXIudHNcbnZhciBDdXJzb3IgPSAvKiBAX19QVVJFX18gKi8gKChDdXJzb3IyKSA9PiB7XG4gIEN1cnNvcjJbXCJBdXRvXCJdID0gXCJhdXRvXCI7XG4gIEN1cnNvcjJbXCJEZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XG4gIEN1cnNvcjJbXCJHcmFiXCJdID0gXCJncmFiXCI7XG4gIEN1cnNvcjJbXCJHcmFiYmluZ1wiXSA9IFwiZ3JhYmJpbmdcIjtcbiAgQ3Vyc29yMltcIk1vdmVcIl0gPSBcIm1vdmVcIjtcbiAgQ3Vyc29yMltcIk5vdEFsbG93ZWRcIl0gPSBcIm5vdC1hbGxvd2VkXCI7XG4gIEN1cnNvcjJbXCJQb2ludGVyXCJdID0gXCJwb2ludGVyXCI7XG4gIEN1cnNvcjJbXCJFV1Jlc2l6ZVwiXSA9IFwiZXctcmVzaXplXCI7XG4gIEN1cnNvcjJbXCJOU1Jlc2l6ZVwiXSA9IFwibnMtcmVzaXplXCI7XG4gIEN1cnNvcjJbXCJab29tSW5cIl0gPSBcInpvb20taW5cIjtcbiAgQ3Vyc29yMltcIlpvb21PdXRcIl0gPSBcInpvb20tb3V0XCI7XG4gIHJldHVybiBDdXJzb3IyO1xufSkoQ3Vyc29yIHx8IHt9KTtcbnZhciBDdXJzb3JNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLnN0YXRlVHJhY2tlciA9IG5ldyBTdGF0ZVRyYWNrZXIoXCJkZWZhdWx0XCIpO1xuICB9XG4gIHVwZGF0ZUN1cnNvcihjYWxsZXJJZCwgc3R5bGUpIHtcbiAgICB0aGlzLnN0YXRlVHJhY2tlci5zZXQoY2FsbGVySWQsIHN0eWxlKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuc3RhdGVUcmFja2VyLnN0YXRlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0Q3Vyc29yKCkge1xuICAgIHJldHVybiB0aGlzLmRvbU1hbmFnZXIuZ2V0Q3Vyc29yKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2dlc3R1cmVEZXRlY3Rvci50c1xuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmVkKGZpbmdlcjEsIGZpbmdlcjIpIHtcbiAgY29uc3QgZHggPSBmaW5nZXIxLnNjcmVlblggLSBmaW5nZXIyLnNjcmVlblg7XG4gIGNvbnN0IGR5ID0gZmluZ2VyMS5zY3JlZW5ZIC0gZmluZ2VyMi5zY3JlZW5ZO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZShmaW5nZXIxLCBmaW5nZXIyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZGlzdGFuY2VTcXVhcmVkKGZpbmdlcjEsIGZpbmdlcjIpKTtcbn1cbnZhciBNSU5fRElTVEFOQ0VfVE9fU1RBUlRfUElOQ0ggPSAxO1xudmFyIEdlc3R1cmVEZXRlY3RvciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihkb21NYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMudG91Y2hzdGFydCA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoU3RhcnQoZXZlbnQpO1xuICAgIHRoaXMudG91Y2htb3ZlID0gKGV2ZW50KSA9PiB0aGlzLm9uVG91Y2hNb3ZlKGV2ZW50KTtcbiAgICB0aGlzLnRvdWNoZW5kID0gKGV2ZW50KSA9PiB0aGlzLm9uVG91Y2hFbmQoZXZlbnQpO1xuICAgIHRoaXMudG91Y2hjYW5jZWwgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaENhbmNlbChldmVudCk7XG4gICAgdGhpcy5waW5jaCA9IHtcbiAgICAgIGZpbmdlcjE6IHsgaWRlbnRpZmllcjogTmFOLCBzY3JlZW5YOiBOYU4sIHNjcmVlblk6IE5hTiB9LFxuICAgICAgZmluZ2VyMjogeyBpZGVudGlmaWVyOiBOYU4sIHNjcmVlblg6IE5hTiwgc2NyZWVuWTogTmFOIH0sXG4gICAgICBvcmlnaW46IHsgeDogTmFOLCB5OiBOYU4gfSxcbiAgICAgIGRpc3RhbmNlOiBOYU4sXG4gICAgICBzdGF0dXM6IDAgLyogT2ZmICovXG4gICAgfTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy50b3VjaHN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy50b3VjaG1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMudG91Y2hjYW5jZWwpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMudG91Y2hzdGFydCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy50b3VjaG1vdmUpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy50b3VjaGVuZCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLnRvdWNoY2FuY2VsKTtcbiAgfVxuICBmaW5kUGluY2hUb3VjaGVzKG1vdmVFdmVudCkge1xuICAgIGNvbnN0IHsgdG91Y2hlcyB9ID0gbW92ZUV2ZW50O1xuICAgIGNvbnN0IHsgZmluZ2VyMSwgZmluZ2VyMiB9ID0gdGhpcy5waW5jaDtcbiAgICBpZiAodGhpcy5waW5jaC5zdGF0dXMgIT09IDAgLyogT2ZmICovICYmIHRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAodG91Y2hlc1swXS5pZGVudGlmaWVyID09PSBmaW5nZXIxLmlkZW50aWZpZXIgJiYgdG91Y2hlc1sxXS5pZGVudGlmaWVyID09PSBmaW5nZXIyLmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIFt0b3VjaGVzWzBdLCB0b3VjaGVzWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmICh0b3VjaGVzWzBdLmlkZW50aWZpZXIgPT09IGZpbmdlcjIuaWRlbnRpZmllciAmJiB0b3VjaGVzWzFdLmlkZW50aWZpZXIgPT09IGZpbmdlcjEuaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gW3RvdWNoZXNbMV0sIHRvdWNoZXNbMF1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb3B5VG91Y2hEYXRhKGV2ZW50KSB7XG4gICAgY29uc3Qga2V5cyA9IFtcImlkZW50aWZpZXJcIiwgXCJzY3JlZW5YXCIsIFwic2NyZWVuWVwiXTtcbiAgICBwYXJ0aWFsQXNzaWduKGtleXMsIHRoaXMucGluY2guZmluZ2VyMSwgZXZlbnQudG91Y2hlc1swXSk7XG4gICAgcGFydGlhbEFzc2lnbihrZXlzLCB0aGlzLnBpbmNoLmZpbmdlcjIsIGV2ZW50LnRvdWNoZXNbMV0pO1xuICAgIHRoaXMucGluY2guZGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLnBpbmNoLmZpbmdlcjEsIHRoaXMucGluY2guZmluZ2VyMik7XG4gIH1cbiAgZGlzcGF0Y2hQaW5jaEV2ZW50KHR5cGUsIGRlbHRhRGlzdGFuY2UsIHNvdXJjZUV2ZW50KSB7XG4gICAgY29uc3QgeyBmaW5nZXIxLCBmaW5nZXIyLCBvcmlnaW4gfSA9IHRoaXMucGluY2g7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2godHlwZSwgYnVpbGRQcmV2ZW50YWJsZSh7IHNvdXJjZUV2ZW50LCB0eXBlLCBmaW5nZXIxLCBmaW5nZXIyLCBkZWx0YURpc3RhbmNlLCBvcmlnaW4gfSkpO1xuICB9XG4gIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgIHRoaXMuc3RvcFBpbmNoVHJhY2tpbmcoZXZlbnQpO1xuICAgIGNvbnN0IHsgcGluY2ggfSA9IHRoaXM7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICBwaW5jaC5zdGF0dXMgPSAxIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgdGhpcy5jb3B5VG91Y2hEYXRhKGV2ZW50KTtcbiAgICAgIHBpbmNoLm9yaWdpbi54ID0gKGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCArIGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WCkgLyAyO1xuICAgICAgcGluY2gub3JpZ2luLnkgPSAoZXZlbnQudG91Y2hlc1swXS5jbGllbnRZICsgZXZlbnQudG91Y2hlc1sxXS5jbGllbnRZKSAvIDI7XG4gICAgfVxuICB9XG4gIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3QgcGluY2hUb3VjaGVzID0gdGhpcy5maW5kUGluY2hUb3VjaGVzKGV2ZW50KTtcbiAgICBpZiAocGluY2hUb3VjaGVzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IFt0b3VjaDEsIHRvdWNoMl0gPSBwaW5jaFRvdWNoZXM7XG4gICAgICBjb25zdCB7IHBpbmNoIH0gPSB0aGlzO1xuICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0b3VjaDEsIHRvdWNoMik7XG4gICAgICBjb25zdCBkZWx0YURpc3RhbmNlID0gbmV3RGlzdGFuY2UgLSBwaW5jaC5kaXN0YW5jZTtcbiAgICAgIGlmIChwaW5jaC5zdGF0dXMgPT09IDEgLyogSW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhRGlzdGFuY2UpID4gTUlOX0RJU1RBTkNFX1RPX1NUQVJUX1BJTkNIKSB7XG4gICAgICAgICAgcGluY2guc3RhdHVzID0gMiAvKiBSdW5uaW5nICovO1xuICAgICAgICAgIHRoaXMuY29weVRvdWNoRGF0YShldmVudCk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFBpbmNoRXZlbnQoXCJwaW5jaC1zdGFydFwiLCAwLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGluY2guc3RhdHVzID09PSAyIC8qIFJ1bm5pbmcgKi8pIHtcbiAgICAgICAgcGluY2guZGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5jb3B5VG91Y2hEYXRhKGV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFBpbmNoRXZlbnQoXCJwaW5jaC1tb3ZlXCIsIGRlbHRhRGlzdGFuY2UsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExvZ2dlci5lcnJvcihgdW5leHBlY3RlZCBwaW5jaC5zdGF0dXM6ICR7cGluY2guc3RhdHVzfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvblRvdWNoRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wUGluY2hUcmFja2luZyhldmVudCk7XG4gIH1cbiAgb25Ub3VjaENhbmNlbChldmVudCkge1xuICAgIHRoaXMuc3RvcFBpbmNoVHJhY2tpbmcoZXZlbnQpO1xuICB9XG4gIHN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KSB7XG4gICAgY29uc3QgeyBwaW5jaCB9ID0gdGhpcztcbiAgICBpZiAocGluY2guc3RhdHVzID09PSAyIC8qIFJ1bm5pbmcgKi8pIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hQaW5jaEV2ZW50KFwicGluY2gtZW5kXCIsIDAsIGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5waW5jaC5zdGF0dXMgPSAwIC8qIE9mZiAqLztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vaGlnaGxpZ2h0TWFuYWdlci50c1xudmFyIEhpZ2hsaWdodE1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmhpZ2hsaWdodFN0YXRlcyA9IG5ldyBTdGF0ZVRyYWNrZXIoKTtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHQoY2FsbGVySWQsIGhpZ2hsaWdodGVkRGF0dW0pIHtcbiAgICBjb25zdCB7IGFjdGl2ZUhpZ2hsaWdodDogcHJldmlvdXNIaWdobGlnaHQgfSA9IHRoaXM7XG4gICAgdGhpcy5oaWdobGlnaHRTdGF0ZXMuc2V0KGNhbGxlcklkLCBoaWdobGlnaHRlZERhdHVtKTtcbiAgICB0aGlzLmFjdGl2ZUhpZ2hsaWdodCA9IHRoaXMuaGlnaGxpZ2h0U3RhdGVzLnN0YXRlVmFsdWUoKTtcbiAgICBpZiAoIXRoaXMuaXNFcXVhbCh0aGlzLmFjdGl2ZUhpZ2hsaWdodCwgcHJldmlvdXNIaWdobGlnaHQpKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImhpZ2hsaWdodC1jaGFuZ2VcIiwge1xuICAgICAgICB0eXBlOiBcImhpZ2hsaWdodC1jaGFuZ2VcIixcbiAgICAgICAgY3VycmVudEhpZ2hsaWdodDogdGhpcy5hY3RpdmVIaWdobGlnaHQsXG4gICAgICAgIHByZXZpb3VzSGlnaGxpZ2h0LFxuICAgICAgICBjYWxsZXJJZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUhpZ2hsaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVIaWdobGlnaHQ7XG4gIH1cbiAgaXNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgYSAhPSBudWxsICYmIGIgIT0gbnVsbCAmJiBhPy5zZXJpZXMgPT09IGI/LnNlcmllcyAmJiBhPy5pdGVtSWQgPT09IGI/Lml0ZW1JZCAmJiBhPy5kYXR1bSA9PT0gYj8uZGF0dW07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2tleU5hdk1hbmFnZXIudHNcbnZhciBLZXlOYXZNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlciwgZG9tTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmhhc0Jyb3dzZXJGb2N1cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNNb3VzZUJsdXJyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImRyYWctc3RhcnRcIiwgKGUpID0+IHRoaXMub25DbGlja1N0YXJ0KGUpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMub25DbGlja1N0b3AoZSksIDMxIC8qIEFsbCAqLyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJkcmFnLWVuZFwiLCAoZSkgPT4gdGhpcy5vbkNsaWNrU3RvcChlKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcIndoZWVsXCIsIChlKSA9PiB0aGlzLm1vdXNlQmx1cihlKSksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZSkgPT4gdGhpcy5tb3VzZUJsdXIoZSkpLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiZHJhZ1wiLCAoZSkgPT4gdGhpcy5tb3VzZUJsdXIoZSkpLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoZSkgPT4gdGhpcy5vbkJsdXIoZSksIDMxIC8qIEFsbCAqLyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJmb2N1c1wiLCAoZSkgPT4gdGhpcy5vbkZvY3VzKGUpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4gdGhpcy5vbktleURvd24oZSksIDMxIC8qIEFsbCAqLylcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIG9uQ2xpY2tTdGFydChldmVudCkge1xuICAgIHRoaXMuaXNDbGlja2luZyA9IHRydWU7XG4gICAgdGhpcy5tb3VzZUJsdXIoZXZlbnQpO1xuICB9XG4gIG9uQ2xpY2tTdG9wKGV2ZW50KSB7XG4gICAgdGhpcy5tb3VzZUJsdXIoZXZlbnQpO1xuICAgIHRoaXMuaXNDbGlja2luZyA9IGZhbHNlO1xuICB9XG4gIG1vdXNlQmx1cihldmVudCkge1xuICAgIGlmICghdGhpcy5oYXNCcm93c2VyRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmlzTW91c2VCbHVycmVkKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwiYmx1clwiLCAwLCBldmVudCk7XG4gICAgICB0aGlzLmlzTW91c2VCbHVycmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgb25CbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5oYXNCcm93c2VyRm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzTW91c2VCbHVycmVkID0gZmFsc2U7XG4gICAgdGhpcy5kaXNwYXRjaChcImJsdXJcIiwgMCwgZXZlbnQpO1xuICB9XG4gIG9uRm9jdXMoZXZlbnQpIHtcbiAgICBjb25zdCBkZWx0YTMgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0QnJvd3NlckZvY3VzRGVsdGEoKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwiYnJvd3NlcmZvY3VzXCIsIGRlbHRhMywgZXZlbnQpO1xuICAgIHRoaXMuaGFzQnJvd3NlckZvY3VzID0gdHJ1ZTtcbiAgICBjb25zdCB0YWJGb2N1c0Zyb21DbGljayA9IGV2ZW50LnJlbGF0ZWRFbGVtZW50ID09IG51bGwgJiYgZXZlbnQudGFyZ2V0RWxlbWVudD8udGFnTmFtZSA9PT0gXCJDQU5WQVNcIjtcbiAgICBpZiAodGhpcy5pc0NsaWNraW5nIHx8IHRhYkZvY3VzRnJvbUNsaWNrKSB7XG4gICAgICB0aGlzLmlzTW91c2VCbHVycmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaChcInRhYlwiLCBkZWx0YTMsIGV2ZW50KTtcbiAgfVxuICBvbktleURvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaGFzQnJvd3NlckZvY3VzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNNb3VzZUJsdXJyZWQgPSBmYWxzZTtcbiAgICBjb25zdCB7IGNvZGUsIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkgfSA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgIGlmIChjb2RlID09PSBcIlRhYlwiKSB7XG4gICAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJ0YWJcIiwgLTEsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwidGFiXCIsIDEsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdEtleSB8fCBzaGlmdEtleSB8fCBtZXRhS2V5IHx8IGN0cmxLZXkpXG4gICAgICByZXR1cm47XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXZlcnRcIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtdmVydFwiLCAtMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi1ob3JpXCIsIC0xLCBldmVudCk7XG4gICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi1ob3JpXCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJab29tSW5cIjpcbiAgICAgIGNhc2UgXCJBZGRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtem9vbVwiLCAxLCBldmVudCk7XG4gICAgICBjYXNlIFwiWm9vbU91dFwiOlxuICAgICAgY2FzZSBcIlN1YnN0cmFjdFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi16b29tXCIsIC0xLCBldmVudCk7XG4gICAgICBjYXNlIFwiU3BhY2VcIjpcbiAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInN1Ym1pdFwiLCAwLCBldmVudCk7XG4gICAgICBjYXNlIFwiRXNjYXBlXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiY2FuY2VsXCIsIDAsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgIGNhc2UgXCJEZWxldGVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgMCwgZXZlbnQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV2ZW50LnNvdXJjZUV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtem9vbVwiLCAxLCBldmVudCk7XG4gICAgICBjYXNlIFwiLVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi16b29tXCIsIC0xLCBldmVudCk7XG4gICAgfVxuICB9XG4gIGRpc3BhdGNoKHR5cGUsIGRlbHRhMywgc291cmNlRXZlbnQpIHtcbiAgICBkaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHsgdHlwZSwgZGVsdGE6IGRlbHRhMywgc291cmNlRXZlbnQgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3JlZ2lvbk1hbmFnZXIudHNcbnZhciBSRUdJT05fVEFCX09SREVSSU5HID0gW1wic2VyaWVzXCJdO1xudmFyIFJlZ2lvbkxpc3RlbmVycyA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbn07XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGxpc3RlbmVycywgaW50ZXJhY3Rpb25NYW5hZ2VyLCB0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMTYgLyogRGVmYXVsdCAqLykge1xuICByZXR1cm4gbGlzdGVuZXJzPy5hZGRMaXN0ZW5lcih0eXBlLCAoZSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChjdXJyZW50U3RhdGUgJiB0cmlnZ2VyaW5nU3RhdGVzKSB7XG4gICAgICBoYW5kbGVyKGUpO1xuICAgIH1cbiAgfSkgPz8gKCgpID0+IHtcbiAgfSk7XG59XG52YXIgUmVnaW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb25NYW5hZ2VyLCBrZXlOYXZNYW5hZ2VyLCBmb2N1c0luZGljYXRvcikge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gaW50ZXJhY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMua2V5TmF2TWFuYWdlciA9IGtleU5hdk1hbmFnZXI7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvciA9IGZvY3VzSW5kaWNhdG9yO1xuICAgIHRoaXMuY3VycmVudFRhYkluZGV4ID0gMDtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxlZnRDYW52YXMgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuYWxsUmVnaW9uc0xpc3RlbmVycyA9IG5ldyBSZWdpb25MaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIC4uLlBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMubWFwKFxuICAgICAgICAoZXZlbnROYW1lKSA9PiBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLnByb2Nlc3NQb2ludGVyRXZlbnQuYmluZCh0aGlzKSwgMzEgLyogQWxsICovKVxuICAgICAgKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImJyb3dzZXJmb2N1c1wiLCB0aGlzLm9uQnJvd3NlckZvY3VzLmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwidGFiXCIsIHRoaXMub25UYWIuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJuYXYtdmVydFwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwibmF2LWhvcmlcIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcIm5hdi16b29tXCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJzdWJtaXRcIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImNhbmNlbFwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiZGVsZXRlXCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSlcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICB0aGlzLmN1cnJlbnRSZWdpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCByZWdpb24gb2YgdGhpcy5yZWdpb25zLnZhbHVlcygpKSB7XG4gICAgICByZWdpb24ubGlzdGVuZXJzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5yZWdpb25zLmNsZWFyKCk7XG4gIH1cbiAgYWRkUmVnaW9uKG5hbWUsIC4uLmJib3hwcm92aWRlcnMpIHtcbiAgICBpZiAodGhpcy5yZWdpb25zLmhhcyhuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBSZWdpb246ICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgY29uc3QgcmVnaW9uID0ge1xuICAgICAgcHJvcGVydGllczogeyBuYW1lLCBiYm94cHJvdmlkZXJzOiBbLi4uYmJveHByb3ZpZGVyc10gfSxcbiAgICAgIGxpc3RlbmVyczogbmV3IFJlZ2lvbkxpc3RlbmVycygpXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lvbnMuc2V0KG5hbWUsIHJlZ2lvbik7XG4gICAgcmV0dXJuIHRoaXMubWFrZU9ic2VydmVyKHJlZ2lvbik7XG4gIH1cbiAgdXBkYXRlUmVnaW9uKG5hbWUsIC4uLmJib3hwcm92aWRlcikge1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMucmVnaW9ucy5nZXQobmFtZSk7XG4gICAgaWYgKHJlZ2lvbikge1xuICAgICAgcmVnaW9uLnByb3BlcnRpZXMuYmJveHByb3ZpZGVycyA9IFsuLi5iYm94cHJvdmlkZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmtub3duIHJlZ2lvbjogXCIgKyBuYW1lKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVnaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlT2JzZXJ2ZXIodGhpcy5yZWdpb25zLmdldChuYW1lKSk7XG4gIH1cbiAgbGlzdGVuQWxsKHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMgPSAxNiAvKiBEZWZhdWx0ICovKSB7XG4gICAgcmV0dXJuIGFkZEhhbmRsZXIodGhpcy5hbGxSZWdpb25zTGlzdGVuZXJzLCB0aGlzLmludGVyYWN0aW9uTWFuYWdlciwgdHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyk7XG4gIH1cbiAgLy8gVGhpcyBtZXRob2QgcmV0dXJuIGEgd3JhcHBlciBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBpbnRlcmZhY2Ugb2YgSW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyLlxuICAvLyBUaGUgaW50ZW50IGlzIHRvIGFsbG93IHRoZSBJbnRlcmFjdGlvbk1hbmFnZXIgYW5kIFJlZ2lvbk1hbmFnZXIgdG8gYmUgdXNlZCBhbG1vc3QgaW50ZXJjaGFuZ2VhYmx5LlxuICBtYWtlT2JzZXJ2ZXIocmVnaW9uKSB7XG4gICAgY29uc3QgeyBpbnRlcmFjdGlvbk1hbmFnZXIgfSA9IHRoaXM7XG4gICAgY2xhc3MgT2JzZXJ2YWJsZVJlZ2lvbkltcGxlbWVudGF0aW9uIHtcbiAgICAgIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMgPSAxNiAvKiBEZWZhdWx0ICovKSB7XG4gICAgICAgIHJldHVybiBhZGRIYW5kbGVyKHJlZ2lvbj8ubGlzdGVuZXJzLCBpbnRlcmFjdGlvbk1hbmFnZXIsIHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVSZWdpb25JbXBsZW1lbnRhdGlvbigpO1xuICB9XG4gIGNoZWNrUG9pbnRlckhpc3RvcnkodGFyZ2V0UmVnaW9uLCBldmVudCkge1xuICAgIGZvciAoY29uc3QgaGlzdG9yeUV2ZW50IG9mIGV2ZW50LnBvaW50ZXJIaXN0b3J5KSB7XG4gICAgICBjb25zdCB7IHJlZ2lvbjogaGlzdG9yeVJlZ2lvbiB9ID0gdGhpcy5waWNrUmVnaW9uKGhpc3RvcnlFdmVudC5vZmZzZXRYLCBoaXN0b3J5RXZlbnQub2Zmc2V0WSk7XG4gICAgICBpZiAodGFyZ2V0UmVnaW9uLnByb3BlcnRpZXMubmFtZSAhPT0gaGlzdG9yeVJlZ2lvbj8ucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gQ3JlYXRlIGFuZCBkaXNwYXRjaCBhIGNvcHkgb2YgdGhlIEludGVyYWN0aW9uRXZlbnQuXG4gIGRpc3BhdGNoKHJlZ2lvbiwgcGFydGlhbEV2ZW50LCBiYm94UHJvdmlkZXJJZCkge1xuICAgIGlmIChyZWdpb24gPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBldmVudCA9IGJ1aWxkUHJldmVudGFibGUoe1xuICAgICAgLi4ucGFydGlhbEV2ZW50LFxuICAgICAgcmVnaW9uOiByZWdpb24ucHJvcGVydGllcy5uYW1lLFxuICAgICAgYmJveFByb3ZpZGVySWRcbiAgICB9KTtcbiAgICB0aGlzLmFsbFJlZ2lvbnNMaXN0ZW5lcnMuZGlzcGF0Y2goZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIHJlZ2lvbi5saXN0ZW5lcnMuZGlzcGF0Y2goZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG4gIC8vIFByb2Nlc3MgZXZlbnRzIGR1cmluZyBhIGRyYWcgYWN0aW9uLiBSZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGZvbGxvdyB0aGUgc3RhbmRhcmRcbiAgLy8gUmVnaW9uTWFuYWdlci5wcm9jZXNzRXZlbnQgZmxvdywgb3IgdHJ1ZSBpZiB0aGlzIGV2ZW50IGFscmVhZHkgcHJvY2Vzc2VkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gIGhhbmRsZURyYWdnaW5nKGV2ZW50KSB7XG4gICAgY29uc3QgeyBjdXJyZW50UmVnaW9uIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcImRyYWctc3RhcnRcIjpcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZWZ0Q2FudmFzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgIHRoaXMubGVmdENhbnZhcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICBjYXNlIFwiZW50ZXJcIjpcbiAgICAgICAgdGhpcy5sZWZ0Q2FudmFzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICBjYXNlIFwiZHJhZ1wiOlxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50UmVnaW9uLCBldmVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZHJhZy1lbmRcIjpcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudFJlZ2lvbiwgZXZlbnQpO1xuICAgICAgICAgIGlmICh0aGlzLmxlZnRDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudFJlZ2lvbiwgeyAuLi5ldmVudCwgdHlwZTogXCJsZWF2ZVwiIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb2Nlc3NQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVEcmFnZ2luZyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50UmVnaW9uIH0gPSB0aGlzO1xuICAgIGlmIChldmVudC50eXBlID09PSBcImxlYXZlXCIpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudFJlZ2lvbiwgeyAuLi5ldmVudCwgdHlwZTogXCJsZWF2ZVwiIH0pO1xuICAgICAgdGhpcy5jdXJyZW50UmVnaW9uID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJlZ2lvbjogbmV3UmVnaW9uLCBiYm94UHJvdmlkZXJJZCB9ID0gdGhpcy5waWNrUmVnaW9uKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIGlmIChjdXJyZW50UmVnaW9uICE9PSB2b2lkIDAgJiYgbmV3UmVnaW9uPy5wcm9wZXJ0aWVzLm5hbWUgIT09IGN1cnJlbnRSZWdpb24ucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnRSZWdpb24sIHsgLi4uZXZlbnQsIHR5cGU6IFwibGVhdmVcIiB9LCB0aGlzLmN1cnJlbnRCQm94UHJvdmlkZXJJZCk7XG4gICAgfVxuICAgIGlmIChuZXdSZWdpb24gIT09IHZvaWQgMCAmJiBuZXdSZWdpb24ucHJvcGVydGllcy5uYW1lICE9PSBjdXJyZW50UmVnaW9uPy5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2gobmV3UmVnaW9uLCB7IC4uLmV2ZW50LCB0eXBlOiBcImVudGVyXCIgfSwgYmJveFByb3ZpZGVySWQpO1xuICAgIH1cbiAgICBpZiAobmV3UmVnaW9uICE9PSB2b2lkIDAgJiYgdGhpcy5jaGVja1BvaW50ZXJIaXN0b3J5KG5ld1JlZ2lvbiwgZXZlbnQpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKG5ld1JlZ2lvbiwgZXZlbnQsIGJib3hQcm92aWRlcklkKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UmVnaW9uID0gbmV3UmVnaW9uO1xuICAgIHRoaXMuY3VycmVudEJCb3hQcm92aWRlcklkID0gYmJveFByb3ZpZGVySWQ7XG4gIH1cbiAgcGlja1JlZ2lvbih4LCB5KSB7XG4gICAgbGV0IGN1cnJlbnRBcmVhID0gSW5maW5pdHk7XG4gICAgbGV0IGN1cnJlbnRSZWdpb247XG4gICAgbGV0IGN1cnJlbnRCQm94UHJvdmlkZXJJZDtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcmVnaW9uLnByb3BlcnRpZXMuYmJveHByb3ZpZGVycykge1xuICAgICAgICBpZiAocHJvdmlkZXIudmlzaWJsZSA9PT0gZmFsc2UpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGJib3ggPSBwcm92aWRlci5jb21wdXRlVHJhbnNmb3JtZWRSZWdpb25CQm94Py4oKSA/PyBwcm92aWRlci5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICAgIGNvbnN0IGFyZWEyID0gYmJveC53aWR0aCAqIGJib3guaGVpZ2h0O1xuICAgICAgICBpZiAoYXJlYTIgPCBjdXJyZW50QXJlYSAmJiBiYm94LmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgICAgICBjdXJyZW50QXJlYSA9IGFyZWEyO1xuICAgICAgICAgIGN1cnJlbnRSZWdpb24gPSByZWdpb247XG4gICAgICAgICAgY3VycmVudEJCb3hQcm92aWRlcklkID0gcHJvdmlkZXIuaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVnaW9uOiBjdXJyZW50UmVnaW9uLCBiYm94UHJvdmlkZXJJZDogY3VycmVudEJCb3hQcm92aWRlcklkIH07XG4gIH1cbiAgZ2V0VGFiUmVnaW9uKHRhYkluZGV4KSB7XG4gICAgaWYgKHRhYkluZGV4ICE9PSB2b2lkIDAgJiYgdGFiSW5kZXggPj0gMCAmJiB0YWJJbmRleCA8IFJFR0lPTl9UQUJfT1JERVJJTkcubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpb25zLmdldChSRUdJT05fVEFCX09SREVSSU5HW3RhYkluZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0TmV4dEludGVyYWN0YWJsZVRhYkluZGV4KGN1cnJlbnRJbmRleCwgZGVsdGEzKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGVsdGEzIDwgMCA/IC0xIDogMTtcbiAgICBsZXQgaSA9IGN1cnJlbnRJbmRleDtcbiAgICB3aGlsZSAoZGVsdGEzICE9PSAwKSB7XG4gICAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFRhYlJlZ2lvbihpICsgZGlyZWN0aW9uKTtcbiAgICAgIGlmIChyZWdpb24gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEzID0gZGVsdGEzIC0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgaSA9IGkgKyBkaXJlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIHZhbGlkYXRlQ3VycmVudFRhYkluZGV4KCkge1xuICAgIGNvbnN0IGZvY3VzZWRSZWdpb24gPSB0aGlzLmdldFRhYlJlZ2lvbih0aGlzLmN1cnJlbnRUYWJJbmRleCk7XG4gICAgaWYgKGZvY3VzZWRSZWdpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jdXJyZW50VGFiSW5kZXggPSB0aGlzLmdldE5leHRJbnRlcmFjdGFibGVUYWJJbmRleCgtMSwgMSkgPz8gMDtcbiAgICB9XG4gIH1cbiAgb25Ccm93c2VyRm9jdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGVsdGEgPiAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUYWJJbmRleCA9IC0xO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuZGVsdGEgPCAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUYWJJbmRleCA9IFJFR0lPTl9UQUJfT1JERVJJTkcubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBvblRhYihldmVudCkge1xuICAgIHRoaXMudmFsaWRhdGVDdXJyZW50VGFiSW5kZXgoKTtcbiAgICBjb25zdCBuZXdUYWJJbmRleCA9IHRoaXMuZ2V0TmV4dEludGVyYWN0YWJsZVRhYkluZGV4KHRoaXMuY3VycmVudFRhYkluZGV4LCBldmVudC5kZWx0YSk7XG4gICAgY29uc3QgbmV3UmVnaW9uID0gdGhpcy5nZXRUYWJSZWdpb24obmV3VGFiSW5kZXgpO1xuICAgIGNvbnN0IGZvY3VzZWRSZWdpb24gPSB0aGlzLmdldFRhYlJlZ2lvbih0aGlzLmN1cnJlbnRUYWJJbmRleCk7XG4gICAgaWYgKG5ld1RhYkluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY3VycmVudFRhYkluZGV4ID0gbmV3VGFiSW5kZXg7XG4gICAgfVxuICAgIGlmIChmb2N1c2VkUmVnaW9uICE9PSB2b2lkIDAgJiYgbmV3UmVnaW9uPy5wcm9wZXJ0aWVzLm5hbWUgIT09IGZvY3VzZWRSZWdpb24ucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICBjb25zdCB7IGRlbHRhOiBkZWx0YTMsIHNvdXJjZUV2ZW50IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGJsdXJFdmVudCA9IGJ1aWxkUHJldmVudGFibGUoeyB0eXBlOiBcImJsdXJcIiwgZGVsdGE6IGRlbHRhMywgc291cmNlRXZlbnQgfSk7XG4gICAgICB0aGlzLmRpc3BhdGNoKGZvY3VzZWRSZWdpb24sIGJsdXJFdmVudCk7XG4gICAgfVxuICAgIGlmIChuZXdSZWdpb24gPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwYXRjaChuZXdSZWdpb24sIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgb25OYXYoZXZlbnQpIHtcbiAgICBjb25zdCBmb2N1c2VkUmVnaW9uID0gdGhpcy5nZXRUYWJSZWdpb24odGhpcy5jdXJyZW50VGFiSW5kZXgpO1xuICAgIHRoaXMuZGlzcGF0Y2goZm9jdXNlZFJlZ2lvbiwgZXZlbnQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sYmFyL3Rvb2xiYXJUeXBlcy50c1xudmFyIFRPT0xCQVJfQUxJR05NRU5UUyA9IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCJdO1xudmFyIFRPT0xCQVJfR1JPVVBTID0gW1wic2VyaWVzVHlwZVwiLCBcImFubm90YXRpb25zXCIsIFwiYW5ub3RhdGlvbk9wdGlvbnNcIiwgXCJyYW5nZXNcIiwgXCJ6b29tXCJdO1xudmFyIFRPT0xCQVJfR1JPVVBfT1JERVJJTkcgPSB7XG4gIHNlcmllc1R5cGU6IDAsXG4gIGFubm90YXRpb25zOiAxLFxuICBhbm5vdGF0aW9uT3B0aW9uczogMixcbiAgcmFuZ2VzOiAzLFxuICB6b29tOiA0XG59O1xudmFyIFRvb2xiYXJQb3NpdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFRvb2xiYXJQb3NpdGlvbjIpID0+IHtcbiAgVG9vbGJhclBvc2l0aW9uMltcIlRvcFwiXSA9IFwidG9wXCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJGbG9hdGluZ1wiXSA9IFwiZmxvYXRpbmdcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkZsb2F0aW5nVG9wXCJdID0gXCJmbG9hdGluZy10b3BcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkZsb2F0aW5nQm90dG9tXCJdID0gXCJmbG9hdGluZy1ib3R0b21cIjtcbiAgcmV0dXJuIFRvb2xiYXJQb3NpdGlvbjI7XG59KShUb29sYmFyUG9zaXRpb24gfHwge30pO1xudmFyIFRPT0xCQVJfUE9TSVRJT05TID0gT2JqZWN0LnZhbHVlcyhUb29sYmFyUG9zaXRpb24pO1xuZnVuY3Rpb24gaXNBbmltYXRpbmdGbG9hdGluZ1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIHJldHVybiBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqLywgXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqL10uaW5jbHVkZXMocG9zaXRpb24pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi90b29sYmFyTWFuYWdlci50c1xudmFyIFRvb2xiYXJNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIHN0YXRpYyBpc0dyb3VwKGdyb3VwLCBldmVudCkge1xuICAgIHJldHVybiBldmVudC5ncm91cCA9PT0gZ3JvdXA7XG4gIH1cbiAgc3RhdGljIGlzQ2hpbGRFbGVtZW50KGRvbU1hbmFnZXIsIGVsZW1lbnQyKSB7XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgaWYgKGRvbU1hbmFnZXIuaXNNYW5hZ2VkQ2hpbGRET01FbGVtZW50KGVsZW1lbnQyLCBcImNhbnZhcy1vdmVybGF5XCIsIGB0b29sYmFyLSR7cG9zaXRpb259YCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcmVzc0J1dHRvbihncm91cCwgaWQsIHZhbHVlLCByZWN0KSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tcHJlc3NlZFwiLCB7IHR5cGU6IFwiYnV0dG9uLXByZXNzZWRcIiwgZ3JvdXAsIGlkLCB2YWx1ZSwgcmVjdCB9KTtcbiAgfVxuICBjYW5jZWwoZ3JvdXApIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImNhbmNlbGxlZFwiLCB7IHR5cGU6IFwiY2FuY2VsbGVkXCIsIGdyb3VwIH0pO1xuICB9XG4gIHRvZ2dsZUJ1dHRvbihncm91cCwgaWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSA9IGZhbHNlLCBlbmFibGVkID0gdHJ1ZSwgdmlzaWJsZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tdG9nZ2xlZFwiLCB7IHR5cGU6IFwiYnV0dG9uLXRvZ2dsZWRcIiwgZ3JvdXAsIGlkLCBhY3RpdmUsIGVuYWJsZWQsIHZpc2libGUgfSk7XG4gIH1cbiAgdXBkYXRlQnV0dG9uKGdyb3VwLCBpZCwgb3B0aW9ucykge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYnV0dG9uLXVwZGF0ZWRcIiwgeyB0eXBlOiBcImJ1dHRvbi11cGRhdGVkXCIsIGdyb3VwLCBpZCwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuICB0b2dnbGVHcm91cChjYWxsZXIsIGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIHZpc2libGUgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJncm91cC10b2dnbGVkXCIsIHsgdHlwZTogXCJncm91cC10b2dnbGVkXCIsIGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgdmlzaWJsZSB9KTtcbiAgfVxuICBjaGFuZ2VGbG9hdGluZ0FuY2hvcihncm91cCwgYW5jaG9yKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJmbG9hdGluZy1hbmNob3ItY2hhbmdlZFwiLCB7IHR5cGU6IFwiZmxvYXRpbmctYW5jaG9yLWNoYW5nZWRcIiwgZ3JvdXAsIGFuY2hvciB9KTtcbiAgfVxuICBidXR0b25Nb3ZlZChncm91cCwgdmFsdWUsIHJlY3QsIGdyb3VwUmVjdCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYnV0dG9uLW1vdmVkXCIsIHsgdHlwZTogXCJidXR0b24tbW92ZWRcIiwgZ3JvdXAsIHZhbHVlLCByZWN0LCBncm91cFJlY3QgfSk7XG4gIH1cbiAgcHJveHlHcm91cE9wdGlvbnMoY2FsbGVyLCBncm91cCwgb3B0aW9ucykge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicHJveHktZ3JvdXAtb3B0aW9uc1wiLCB7IHR5cGU6IFwicHJveHktZ3JvdXAtb3B0aW9uc1wiLCBjYWxsZXIsIGdyb3VwLCBvcHRpb25zIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi90b29sdGlwTWFuYWdlci50c1xudmFyIFRvb2x0aXBNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihkb21NYW5hZ2VyLCB0b29sdGlwKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyID0gbmV3IFN0YXRlVHJhY2tlcigpO1xuICAgIHRoaXMuc3VwcHJlc3NTdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIoZmFsc2UpO1xuICAgIHRoaXMuYXBwbGllZFN0YXRlID0gbnVsbDtcbiAgICB0b29sdGlwLnNldHVwKGRvbU1hbmFnZXIpO1xuICAgIGRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJoaWRkZW5cIiwgKCkgPT4gdGhpcy50b29sdGlwLnRvZ2dsZShmYWxzZSkpO1xuICB9XG4gIHVwZGF0ZVRvb2x0aXAoY2FsbGVySWQsIG1ldGEsIGNvbnRlbnQpIHtcbiAgICBpZiAoIXRoaXMudG9vbHRpcC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRlbnQgPz8gKGNvbnRlbnQgPSB0aGlzLnN0YXRlVHJhY2tlci5nZXQoY2FsbGVySWQpPy5jb250ZW50KTtcbiAgICB0aGlzLnN0YXRlVHJhY2tlci5zZXQoY2FsbGVySWQsIHsgY29udGVudCwgbWV0YSB9KTtcbiAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gIH1cbiAgcmVtb3ZlVG9vbHRpcChjYWxsZXJJZCkge1xuICAgIGlmICghdGhpcy50b29sdGlwLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIuZGVsZXRlKGNhbGxlcklkKTtcbiAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gIH1cbiAgc3VwcHJlc3NUb29sdGlwKGNhbGxlcklkKSB7XG4gICAgdGhpcy5zdXBwcmVzc1N0YXRlLnNldChjYWxsZXJJZCwgdHJ1ZSk7XG4gIH1cbiAgdW5zdXBwcmVzc1Rvb2x0aXAoY2FsbGVySWQpIHtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUuZGVsZXRlKGNhbGxlcklkKTtcbiAgfVxuICBnZXRUb29sdGlwTWV0YShjYWxsZXJJZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlVHJhY2tlci5nZXQoY2FsbGVySWQpPy5tZXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcInRvb2x0aXBcIik7XG4gIH1cbiAgYXBwbHlTdGF0ZXMoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnN0YXRlVHJhY2tlci5zdGF0ZUlkKCk7XG4gICAgY29uc3Qgc3RhdGUgPSBpZCA/IHRoaXMuc3RhdGVUcmFja2VyLmdldChpZCkgOiBudWxsO1xuICAgIGlmICh0aGlzLnN1cHByZXNzU3RhdGUuc3RhdGVWYWx1ZSgpIHx8IHN0YXRlPy5tZXRhID09IG51bGwgfHwgc3RhdGU/LmNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy50b29sdGlwLnRvZ2dsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy50b29sdGlwLmJvdW5kcyA9PT0gXCJleHRlbmRlZFwiID8gdGhpcy5kb21NYW5hZ2VyLmdldE92ZXJsYXlDbGllbnRSZWN0KCkgOiBjYW52YXNSZWN0O1xuICAgIGlmICh0aGlzLmFwcGxpZWRTdGF0ZT8uY29udGVudCA9PT0gc3RhdGU/LmNvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHJlbmRlckluc3RhbnRseSA9IHRoaXMudG9vbHRpcC5pc1Zpc2libGUoKTtcbiAgICAgIHRoaXMudG9vbHRpcC5zaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgc3RhdGU/Lm1ldGEsIG51bGwsIHJlbmRlckluc3RhbnRseSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9vbHRpcC5zaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgc3RhdGU/Lm1ldGEsIHN0YXRlPy5jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBzdGF0ZTtcbiAgfVxuICBzdGF0aWMgbWFrZVRvb2x0aXBNZXRhKGV2ZW50LCBkYXR1bSkge1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyB0b29sdGlwIH0gPSBkYXR1bS5zZXJpZXMucHJvcGVydGllcztcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBlbmFibGVJbnRlcmFjdGlvbjogdG9vbHRpcC5pbnRlcmFjdGlvbj8uZW5hYmxlZCA/PyBmYWxzZSxcbiAgICAgIGxhc3RQb2ludGVyRXZlbnQ6IHsgdHlwZTogZXZlbnQudHlwZSwgb2Zmc2V0WCwgb2Zmc2V0WSB9LFxuICAgICAgc2hvd0Fycm93OiB0b29sdGlwLnNob3dBcnJvdyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHR5cGU6IHRvb2x0aXAucG9zaXRpb24udHlwZSxcbiAgICAgICAgeE9mZnNldDogdG9vbHRpcC5wb3NpdGlvbi54T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiB0b29sdGlwLnBvc2l0aW9uLnlPZmZzZXRcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZlBvaW50ID0gZGF0dW0ueUJhcj8udXBwZXJQb2ludCA/PyBkYXR1bS5taWRQb2ludCA/PyBkYXR1bS5zZXJpZXMuZGF0dW1NaWRQb2ludD8uKGRhdHVtKTtcbiAgICBpZiAodG9vbHRpcC5wb3NpdGlvbi50eXBlID09PSBcIm5vZGVcIiAmJiByZWZQb2ludCkge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSByZWZQb2ludDtcbiAgICAgIGNvbnN0IHBvaW50ID0gZGF0dW0uc2VyaWVzLmNvbnRlbnRHcm91cC5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhLFxuICAgICAgICBvZmZzZXRYOiBNYXRoLnJvdW5kKHBvaW50LngpLFxuICAgICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKHBvaW50LnkpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGF5b3V0L2xheW91dFNlcnZpY2UudHNcbnZhciBMYXlvdXRTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGF5b3V0Q29tcGxldGUgPSBcImxheW91dC1jb21wbGV0ZVwiO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJsYXlvdXRcIik7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMuaXNMYXlvdXRTdGFnZShldmVudFR5cGUpIHx8IHRoaXMuaXNMYXlvdXRDb21wbGV0ZShldmVudFR5cGUpKSB7XG4gICAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bnN1cHBvcnRlZCBsaXN0ZW5lciB0eXBlOiAke2V2ZW50VHlwZX1gKTtcbiAgfVxuICBkaXNwYXRjaFBlcmZvcm1MYXlvdXQoc3RhZ2UsIGN0eCkge1xuICAgIGlmICh0aGlzLmlzTGF5b3V0U3RhZ2Uoc3RhZ2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMaXN0ZW5lcnNCeVR5cGUoc3RhZ2UpLnJlZHVjZSgocmVzdWx0LCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG5ld0N0eCA9IGxpc3RlbmVyLmhhbmRsZXIocmVzdWx0KTtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiW0xheW91dFNlcnZpY2VdIENvbnRleHQgdXBkYXRlZCB0bzogXCIsIHsgLi4ubmV3Q3R4IH0sIGxpc3RlbmVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3Q3R4O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgTG9nZ2VyLmVycm9yT25jZShlKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9LCBjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIGRpc3BhdGNoTGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoKHRoaXMubGF5b3V0Q29tcGxldGUsIGV2ZW50KTtcbiAgfVxuICBpc0xheW91dFN0YWdlKGV2ZW50VHlwZSkge1xuICAgIHJldHVybiBldmVudFR5cGUgIT09IHRoaXMubGF5b3V0Q29tcGxldGU7XG4gIH1cbiAgaXNMYXlvdXRDb21wbGV0ZShldmVudFR5cGUpIHtcbiAgICByZXR1cm4gZXZlbnRUeXBlID09PSB0aGlzLmxheW91dENvbXBsZXRlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sb2NhbGUvZGVmYXVsdE1lc3NhZ2VGb3JtYXR0ZXIudHNcbnZhciBtZXNzYWdlUmVnRXhwID0gL1xcJFxceyhcXHcrKX0oPzpcXFsoXFx3KyldKT8vZ2k7XG52YXIgZm9ybWF0dGVycyA9IHtcbiAgbnVtYmVyOiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiKSxcbiAgcGVyY2VudDogbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW4tVVNcIiwgeyBzdHlsZTogXCJwZXJjZW50XCIgfSksXG4gIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyBkYXRlU3R5bGU6IFwiZnVsbFwiIH0pLFxuICB0aW1lOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVN0eWxlOiBcImZ1bGxcIiB9KSxcbiAgZGF0ZXRpbWU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyBkYXRlU3R5bGU6IFwiZnVsbFwiLCB0aW1lU3R5bGU6IFwiZnVsbFwiIH0pXG59O1xudmFyIGRlZmF1bHRNZXNzYWdlRm9ybWF0dGVyID0gKHsgZGVmYXVsdFZhbHVlLCB2YXJpYWJsZXMgfSkgPT4ge1xuICByZXR1cm4gZGVmYXVsdFZhbHVlPy5yZXBsYWNlQWxsKG1lc3NhZ2VSZWdFeHAsIChfLCBtYXRjaCwgZm9ybWF0KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB2YXJpYWJsZXNbbWF0Y2hdO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdCAhPSBudWxsID8gZm9ybWF0dGVyc1tmb3JtYXRdIDogdm9pZCAwO1xuICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXR0ZXIgPT0gbnVsbCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBGb3JtYXQgc3R5bGUgWyR7Zm9ybWF0fV0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0dGVyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtYmVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmRhdGV0aW1lLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9KTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xvY2FsZS9sb2NhbGVNYW5hZ2VyLnRzXG52YXIgTG9jYWxlTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxvY2FsZVRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5nZXRMb2NhbGVUZXh0ID0gdm9pZCAwO1xuICB9XG4gIHNldExvY2FsZVRleHQobG9jYWxlVGV4dCkge1xuICAgIGlmICh0aGlzLmxvY2FsZVRleHQgIT09IGxvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMubG9jYWxlVGV4dCA9IGxvY2FsZVRleHQ7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwibG9jYWxlLWNoYW5nZWRcIik7XG4gICAgfVxuICB9XG4gIHNldExvY2FsZVRleHRGb3JtYXR0ZXIoZ2V0TG9jYWxlVGV4dCkge1xuICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IGdldExvY2FsZVRleHQ7XG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxlVGV4dCAhPT0gZ2V0TG9jYWxlVGV4dCkge1xuICAgICAgdGhpcy5nZXRMb2NhbGVUZXh0ID0gZ2V0TG9jYWxlVGV4dDtcbiAgICAgIHRoaXMuZGlzcGF0Y2goXCJsb2NhbGUtY2hhbmdlZFwiKTtcbiAgICB9XG4gIH1cbiAgdChrZXksIHZhcmlhYmxlcyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGVUZXh0ID0gQUdfQ0hBUlRTX0xPQ0FMRV9FTl9VUywgZ2V0TG9jYWxlVGV4dCB9ID0gdGhpcztcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBsb2NhbGVUZXh0W2tleV07XG4gICAgcmV0dXJuIGdldExvY2FsZVRleHQ/Lih7IGtleSwgZGVmYXVsdFZhbHVlLCB2YXJpYWJsZXMgfSkgPz8gZGVmYXVsdE1lc3NhZ2VGb3JtYXR0ZXIoeyBrZXksIGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID8/IGtleTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1N0YXRlTWFuYWdlci50c1xudmFyIFNlcmllc1N0YXRlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgfVxuICByZWdpc3RlclNlcmllcyh7XG4gICAgaWQsXG4gICAgc2VyaWVzR3JvdXBpbmcsXG4gICAgdmlzaWJsZSxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzZXJpZXNHcm91cGluZylcbiAgICAgIHJldHVybjtcbiAgICAoX2EgPSB0aGlzLmdyb3VwcylbdHlwZV0gPz8gKF9hW3R5cGVdID0ge30pO1xuICAgIHRoaXMuZ3JvdXBzW3R5cGVdW2lkXSA9IHsgZ3JvdXBpbmc6IHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlIH07XG4gIH1cbiAgZGVyZWdpc3RlclNlcmllcyh7IGlkLCB0eXBlIH0pIHtcbiAgICBpZiAodGhpcy5ncm91cHNbdHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXVtpZF07XG4gICAgfVxuICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXSAmJiBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwc1t0eXBlXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV07XG4gICAgfVxuICB9XG4gIGdldFZpc2libGVQZWVyR3JvdXBJbmRleCh7XG4gICAgdHlwZSxcbiAgICBzZXJpZXNHcm91cGluZyxcbiAgICB2aXNpYmxlXG4gIH0pIHtcbiAgICBpZiAoIXNlcmllc0dyb3VwaW5nKVxuICAgICAgcmV0dXJuIHsgdmlzaWJsZUdyb3VwQ291bnQ6IHZpc2libGUgPyAxIDogMCwgdmlzaWJsZVNhbWVTdGFja0NvdW50OiB2aXNpYmxlID8gMSA6IDAsIGluZGV4OiAwIH07XG4gICAgY29uc3QgdmlzaWJsZUdyb3Vwc1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmlzaWJsZVNhbWVTdGFja1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBzW3R5cGVdID8/IHt9KSkge1xuICAgICAgaWYgKCFlbnRyeS52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZpc2libGVHcm91cHNTZXQuYWRkKGVudHJ5Lmdyb3VwaW5nLmdyb3VwSW5kZXgpO1xuICAgICAgaWYgKGVudHJ5Lmdyb3VwaW5nLmdyb3VwSW5kZXggPT09IHNlcmllc0dyb3VwaW5nLmdyb3VwSW5kZXgpIHtcbiAgICAgICAgdmlzaWJsZVNhbWVTdGFja1NldC5hZGQoZW50cnkuZ3JvdXBpbmcuc3RhY2tJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpc2libGVHcm91cHMgPSBBcnJheS5mcm9tKHZpc2libGVHcm91cHNTZXQpO1xuICAgIHZpc2libGVHcm91cHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlR3JvdXBDb3VudDogdmlzaWJsZUdyb3Vwcy5sZW5ndGgsXG4gICAgICB2aXNpYmxlU2FtZVN0YWNrQ291bnQ6IHZpc2libGVTYW1lU3RhY2tTZXQuc2l6ZSxcbiAgICAgIGluZGV4OiB2aXNpYmxlR3JvdXBzLmluZGV4T2Yoc2VyaWVzR3JvdXBpbmcuZ3JvdXBJbmRleClcbiAgICB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydFVwZGF0ZVR5cGUudHNcbnZhciBDaGFydFVwZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDaGFydFVwZGF0ZVR5cGUzKSA9PiB7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIkZVTExcIl0gPSAwXSA9IFwiRlVMTFwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJVUERBVEVfREFUQVwiXSA9IDFdID0gXCJVUERBVEVfREFUQVwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJQUk9DRVNTX0RBVEFcIl0gPSAyXSA9IFwiUFJPQ0VTU19EQVRBXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIlBFUkZPUk1fTEFZT1VUXCJdID0gM10gPSBcIlBFUkZPUk1fTEFZT1VUXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIlNFUklFU19VUERBVEVcIl0gPSA0XSA9IFwiU0VSSUVTX1VQREFURVwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJQUkVfU0NFTkVfUkVOREVSXCJdID0gNV0gPSBcIlBSRV9TQ0VORV9SRU5ERVJcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiU0NFTkVfUkVOREVSXCJdID0gNl0gPSBcIlNDRU5FX1JFTkRFUlwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJOT05FXCJdID0gN10gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIENoYXJ0VXBkYXRlVHlwZTM7XG59KShDaGFydFVwZGF0ZVR5cGUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGVTZXJ2aWNlLnRzXG52YXIgVXBkYXRlU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IodXBkYXRlQ2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSB1cGRhdGVDYWxsYmFjaztcbiAgfVxuICB1cGRhdGUodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0aW9ucykge1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodHlwZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGlzcGF0Y2hVcGRhdGVDb21wbGV0ZShyZWN0cykge1xuICAgIHRoaXMuZGlzcGF0Y2goXCJ1cGRhdGUtY29tcGxldGVcIiwge1xuICAgICAgdHlwZTogXCJ1cGRhdGUtY29tcGxldGVcIixcbiAgICAgIG1pblJlY3Q6IHJlY3RzPy5taW5SZWN0LFxuICAgICAgbWluVmlzaWJsZVJlY3Q6IHJlY3RzPy5taW5WaXNpYmxlUmVjdFxuICAgIH0pO1xuICB9XG4gIGRpc3BhdGNoUHJlU2NlbmVSZW5kZXIocmVjdHMpIHtcbiAgICB0aGlzLmRpc3BhdGNoKFwicHJlLXNjZW5lLXJlbmRlclwiLCB7IHR5cGU6IFwicHJlLXNjZW5lLXJlbmRlclwiLCAuLi5yZWN0cyB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRDb250ZXh0LnRzXG52YXIgQ2hhcnRDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgdmFycykge1xuICAgIGNvbnN0IHsgc2NlbmUsIHJvb3QsIHN5bmNNYW5hZ2VyLCBjb250YWluZXIsIHVwZGF0ZUNhbGxiYWNrLCB1cGRhdGVNdXRleCwgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvIH0gPSB2YXJzO1xuICAgIHRoaXMuY2hhcnRTZXJ2aWNlID0gY2hhcnQ7XG4gICAgdGhpcy5zeW5jTWFuYWdlciA9IHN5bmNNYW5hZ2VyO1xuICAgIHRoaXMuem9vbU1hbmFnZXIgPSBjaGFydC56b29tTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBuZXcgRE9NTWFuYWdlcihjb250YWluZXIpO1xuICAgIHNjZW5lPy5zZXRDb250YWluZXIodGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmUgPz8gbmV3IFNjZW5lKHsgcGl4ZWxSYXRpbzogb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLCBkb21NYW5hZ2VyOiB0aGlzLmRvbU1hbmFnZXIgfSk7XG4gICAgdGhpcy5zY2VuZS5zZXRSb290KHJvb3QpO1xuICAgIHRoaXMuYXhpc01hbmFnZXIgPSBuZXcgQXhpc01hbmFnZXIocm9vdCk7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbmV3IExvY2FsZU1hbmFnZXIoKTtcbiAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyID0gbmV3IEFubm90YXRpb25NYW5hZ2VyKGNoYXJ0LmFubm90YXRpb25Sb290KTtcbiAgICB0aGlzLmNoYXJ0RXZlbnRNYW5hZ2VyID0gbmV3IENoYXJ0RXZlbnRNYW5hZ2VyKCk7XG4gICAgdGhpcy5jdXJzb3JNYW5hZ2VyID0gbmV3IEN1cnNvck1hbmFnZXIodGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIgPSBuZXcgSGlnaGxpZ2h0TWFuYWdlcigpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gbmV3IEludGVyYWN0aW9uTWFuYWdlcihjaGFydC5rZXlib2FyZCwgdGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmtleU5hdk1hbmFnZXIgPSBuZXcgS2V5TmF2TWFuYWdlcih0aGlzLmludGVyYWN0aW9uTWFuYWdlciwgdGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yID0gbmV3IEZvY3VzSW5kaWNhdG9yKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5yZWdpb25NYW5hZ2VyID0gbmV3IFJlZ2lvbk1hbmFnZXIodGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHRoaXMua2V5TmF2TWFuYWdlciwgdGhpcy5mb2N1c0luZGljYXRvcik7XG4gICAgdGhpcy5jb250ZXh0TWVudVJlZ2lzdHJ5ID0gbmV3IENvbnRleHRNZW51UmVnaXN0cnkodGhpcy5yZWdpb25NYW5hZ2VyKTtcbiAgICB0aGlzLnRvb2xiYXJNYW5hZ2VyID0gbmV3IFRvb2xiYXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5sYXlvdXRTZXJ2aWNlID0gbmV3IExheW91dFNlcnZpY2UoKTtcbiAgICB0aGlzLmFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlID0gbmV3IEFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlKFxuICAgICAgdGhpcy5sb2NhbGVNYW5hZ2VyLFxuICAgICAgdGhpcy5kb21NYW5hZ2VyLFxuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlXG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UgPSBuZXcgVXBkYXRlU2VydmljZSh1cGRhdGVDYWxsYmFjayk7XG4gICAgdGhpcy5wcm94eUludGVyYWN0aW9uU2VydmljZSA9IG5ldyBQcm94eUludGVyYWN0aW9uU2VydmljZShcbiAgICAgIHRoaXMudXBkYXRlU2VydmljZSxcbiAgICAgIHRoaXMubG9jYWxlTWFuYWdlcixcbiAgICAgIHRoaXMuZG9tTWFuYWdlcixcbiAgICAgIHRoaXMuZm9jdXNJbmRpY2F0b3JcbiAgICApO1xuICAgIHRoaXMuc2VyaWVzU3RhdGVNYW5hZ2VyID0gbmV3IFNlcmllc1N0YXRlTWFuYWdlcigpO1xuICAgIHRoaXMuc3RhdGVNYW5hZ2VyID0gbmV3IFN0YXRlTWFuYWdlcigpO1xuICAgIHRoaXMuY2FsbGJhY2tDYWNoZSA9IG5ldyBDYWxsYmFja0NhY2hlKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHVwZGF0ZU11dGV4KTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2tpcCgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5wbGF5KCk7XG4gICAgdGhpcy5kYXRhU2VydmljZSA9IG5ldyBEYXRhU2VydmljZSh0aGlzLmFuaW1hdGlvbk1hbmFnZXIpO1xuICAgIHRoaXMudG9vbHRpcE1hbmFnZXIgPSBuZXcgVG9vbHRpcE1hbmFnZXIodGhpcy5kb21NYW5hZ2VyLCBjaGFydC50b29sdGlwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudG9vbHRpcE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY29udGV4dE1lbnVSZWdpc3RyeS5kZXN0cm95KCk7XG4gICAgdGhpcy5yZWdpb25NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLmRlc3Ryb3koKTtcbiAgICB0aGlzLmtleU5hdk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc3RvcCgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hcmlhQW5ub3VuY2VtZW50U2VydmljZS5kZXN0cm95KCk7XG4gICAgdGhpcy5jaGFydEV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5oaWdobGlnaHRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FjaGUuaW52YWxpZGF0ZUNhY2hlKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnJlc2V0KCk7XG4gICAgdGhpcy5zeW5jTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRIaWdobGlnaHQudHNcbnZhciBDaGFydEhpZ2hsaWdodCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucmFuZ2UgPSBcInRvb2x0aXBcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInRvb2x0aXBcIiwgXCJub2RlXCJdLCBcImEgcmFuZ2VcIikpXG5dLCBDaGFydEhpZ2hsaWdodC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YURvbWFpbi50c1xudmFyIERpc2NyZXRlRG9tYWluID0gY2xhc3MgX0Rpc2NyZXRlRG9tYWluIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21haW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9EaXNjcmV0ZURvbWFpbjtcbiAgfVxuICBleHRlbmQodmFsKSB7XG4gICAgdGhpcy5kb21haW4uYWRkKHZhbCk7XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZG9tYWluKTtcbiAgfVxufTtcbnZhciBDb250aW51b3VzRG9tYWluID0gY2xhc3MgX0NvbnRpbnVvdXNEb21haW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ29udGludW91c0RvbWFpbjtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kRG9tYWluKHZhbHVlcywgZG9tYWluID0gW0luZmluaXR5LCAtSW5maW5pdHldKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZG9tYWluWzBdID4gdmFsdWUpIHtcbiAgICAgICAgZG9tYWluWzBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZG9tYWluWzFdIDwgdmFsdWUpIHtcbiAgICAgICAgZG9tYWluWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgZXh0ZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9tYWluWzBdID4gdmFsdWUpIHtcbiAgICAgIHRoaXMuZG9tYWluWzBdID0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmRvbWFpblsxXSA8IHZhbHVlKSB7XG4gICAgICB0aGlzLmRvbWFpblsxXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXREb21haW4oKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmRvbWFpbl07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YU1vZGVsLnRzXG5mdW5jdGlvbiB0b0tleVN0cmluZyhrZXlzKSB7XG4gIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBpc09iamVjdChrZXkpID8gSlNPTi5zdHJpbmdpZnkoa2V5KSA6IGtleSkuam9pbihcIi1cIik7XG59XG5mdW5jdGlvbiByb3VuZDIodmFsKSB7XG4gIGNvbnN0IGFjY3VyYWN5ID0gMWU0O1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID4gYWNjdXJhY3kpIHtcbiAgICByZXR1cm4gTWF0aC50cnVuYyh2YWwpO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIGFjY3VyYWN5KSAvIGFjY3VyYWN5O1xufVxuZnVuY3Rpb24gZml4TnVtZXJpY0V4dGVudEludGVybmFsKGV4dGVudDIpIHtcbiAgaWYgKGV4dGVudDIgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgW21pbiwgbWF4XSA9IGV4dGVudDIubWFwKE51bWJlcik7XG4gIGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAwKSB7XG4gICAgcmV0dXJuIFswLCAxXTtcbiAgfVxuICBpZiAobWluID09PSBJbmZpbml0eSAmJiBtYXggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmIChtaW4gPT09IEluZmluaXR5KSB7XG4gICAgbWluID0gMDtcbiAgfSBlbHNlIGlmIChtYXggPT09IC1JbmZpbml0eSkge1xuICAgIG1heCA9IDA7XG4gIH1cbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKG1pbikgJiYgaXNGaW5pdGVOdW1iZXIobWF4KSA/IFttaW4sIG1heF0gOiBbXTtcbn1cbmZ1bmN0aW9uIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50MiwgYXhpcykge1xuICBjb25zdCBmaXhlZEV4dGVudCA9IGZpeE51bWVyaWNFeHRlbnRJbnRlcm5hbChleHRlbnQyKTtcbiAgaWYgKGZpeGVkRXh0ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmaXhlZEV4dGVudDtcbiAgfVxuICBsZXQgW21pbiwgbWF4XSA9IGZpeGVkRXh0ZW50O1xuICBpZiAobWluID09PSBtYXgpIHtcbiAgICBjb25zdCBbcGFkZGluZ01pbiwgcGFkZGluZ01heF0gPSBheGlzPy5jYWxjdWxhdGVQYWRkaW5nKG1pbiwgbWF4KSA/PyBbMSwgMV07XG4gICAgbWluIC09IHBhZGRpbmdNaW47XG4gICAgbWF4ICs9IHBhZGRpbmdNYXg7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5mdW5jdGlvbiBnZXRNaXNzQ291bnQoc2NvcGVQcm92aWRlciwgbWlzc01hcCkge1xuICByZXR1cm4gbWlzc01hcD8uZ2V0KHNjb3BlUHJvdmlkZXIuaWQpID8/IDA7XG59XG52YXIgSU5WQUxJRF9WQUxVRSA9IFN5bWJvbChcImludmFsaWRcIik7XG5mdW5jdGlvbiBnZXRQYXRoQ29tcG9uZW50cyhwYXRoKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgbGV0IG1hdGNoSW5kZXggPSAwO1xuICBsZXQgbWF0Y2hHcm91cDtcbiAgY29uc3QgcmVnRXhwID0gLygoPzooPzpefFxcLilcXHMqXFx3K3xcXFtcXHMqKD86Jyg/OlteJ118XFxcXCcpKid8XCIoPzpbXlwiXXxcXFxcXCIpKlwifC0/XFxkKylcXHMqXFxdKVxccyopL2c7XG4gIHdoaWxlIChtYXRjaEdyb3VwID0gcmVnRXhwLmV4ZWMocGF0aCkpIHtcbiAgICBpZiAobWF0Y2hHcm91cC5pbmRleCAhPT0gbWF0Y2hJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaEluZGV4ID0gbWF0Y2hHcm91cC5pbmRleCArIG1hdGNoR3JvdXBbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hHcm91cFsxXS50cmltKCk7XG4gICAgaWYgKG1hdGNoLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2gobWF0Y2guc2xpY2UoMSkudHJpbSgpKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoLnN0YXJ0c1dpdGgoXCJbXCIpKSB7XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IG1hdGNoLnNsaWNlKDEsIC0xKS50cmltKCk7XG4gICAgICBpZiAoYWNjZXNzb3Iuc3RhcnRzV2l0aChgJ2ApKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChhY2Nlc3Nvci5zbGljZSgxLCAtMSkucmVwbGFjZSgvKD88IVxcXFwpXFxcXCcvZywgYCdgKSk7XG4gICAgICB9IGVsc2UgaWYgKGFjY2Vzc29yLnN0YXJ0c1dpdGgoYFwiYCkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGFjY2Vzc29yLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC8oPzwhXFxcXClcXFxcXCIvZywgYFwiYCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGFjY2Vzc29yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wdXNoKG1hdGNoKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoSW5kZXggIT09IHBhdGgubGVuZ3RoKVxuICAgIHJldHVybjtcbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoQWNjZXNzb3IoY29tcG9uZW50cykge1xuICByZXR1cm4gKGRhdHVtKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSBkYXR1bTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBjb21wb25lbnRzKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudFtjb21wb25lbnRdO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfTtcbn1cbnZhciBEYXRhTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMsIG1vZGUgPSBcInN0YW5kYWxvbmVcIikge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiZGF0YS1tb2RlbFwiKTtcbiAgICB0aGlzLnNjb3BlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgdGhpcy5hZ2dyZWdhdGVzID0gW107XG4gICAgdGhpcy5ncm91cFByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMucmVkdWNlcnMgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NvcnMgPSBbXTtcbiAgICBsZXQga2V5cyA9IHRydWU7XG4gICAgZm9yIChjb25zdCBuZXh0IG9mIG9wdHMucHJvcHMpIHtcbiAgICAgIGlmIChuZXh0LnR5cGUgPT09IFwia2V5XCIgJiYgIWtleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlnIGVycm9yOiBrZXlzIG11c3QgY29tZSBiZWZvcmUgdmFsdWVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0LnR5cGUgPT09IFwidmFsdWVcIiAmJiBrZXlzKSB7XG4gICAgICAgIGtleXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmVyaWZ5TWF0Y2hHcm91cElkID0gKHsgbWF0Y2hHcm91cElkcyA9IFtdIH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWF0Y2hHcm91cElkIG9mIG1hdGNoR3JvdXBJZHMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmV2ZXJ5KChkZWYpID0+IGRlZi5ncm91cElkICE9PSBtYXRjaEdyb3VwSWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjogbWF0Y2hHcm91cElkcyBwcm9wZXJ0aWVzIG11c3QgbWF0Y2ggZGVmaW5lZCBncm91cHMgKCR7bWF0Y2hHcm91cElkfSkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGVmIG9mIG9wdHMucHJvcHMpIHtcbiAgICAgIHN3aXRjaCAoZGVmLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICAgIHRoaXMua2V5cy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5rZXlzLmxlbmd0aCwgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgaWYgKGRlZi5wcm9wZXJ0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IG5vIHByb3BlcnRpZXMgc3BlY2lmaWVkIGZvciB2YWx1ZSBkZWZpbml0aW9uczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBkZWZcbiAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy52YWx1ZXMubGVuZ3RoLCBtaXNzaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWdncmVnYXRlXCI6XG4gICAgICAgICAgdmVyaWZ5TWF0Y2hHcm91cElkKGRlZik7XG4gICAgICAgICAgdGhpcy5hZ2dyZWdhdGVzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCI6XG4gICAgICAgICAgdmVyaWZ5TWF0Y2hHcm91cElkKGRlZik7XG4gICAgICAgICAgdGhpcy5ncm91cFByb2Nlc3NvcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMuZ3JvdXBQcm9jZXNzb3JzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInByb3BlcnR5LXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICAgIHRoaXMucHJvcGVydHlQcm9jZXNzb3JzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWR1Y2VyXCI6XG4gICAgICAgICAgdGhpcy5yZWR1Y2Vycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5yZWR1Y2Vycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcm9jZXNzb3JcIjpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NvcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMucHJvY2Vzc29ycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZChzY29wZSwgc2VhcmNoSWQpIHtcbiAgICBjb25zdCBkZWYgPSB0aGlzLnNjb3BlQ2FjaGUuZ2V0KHNjb3BlLmlkKT8uZ2V0KHNlYXJjaElkKTtcbiAgICBpZiAoIWRlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkaWRuJ3QgZmluZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGZvciBbJHtzZWFyY2hJZH0sICR7c2NvcGUuaWR9XWApO1xuICAgIH1cbiAgICByZXR1cm4geyBpbmRleDogZGVmLmluZGV4LCBkZWYgfTtcbiAgfVxuICByZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZChzY29wZSwgc2VhcmNoSWQpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKS5pbmRleDtcbiAgfVxuICByZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNCeUlkcyhzY29wZSwgc2VhcmNoSWRzKSB7XG4gICAgcmV0dXJuIHNlYXJjaElkcy5tYXAoKHNlYXJjaElkKSA9PiBbc2VhcmNoSWQsIHRoaXMucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHNjb3BlLCBzZWFyY2hJZCldKTtcbiAgfVxuICByZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNWYWx1ZXMoZGVmcywgeyBrZXlzLCB2YWx1ZXMgfSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgW3NlYXJjaElkLCB7IGluZGV4LCBkZWYgfV0gb2YgZGVmcykge1xuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGRlZi50eXBlID09PSBcImtleVwiID8ga2V5cyA6IHZhbHVlcztcbiAgICAgIHJlc3VsdFtzZWFyY2hJZF0gPSBwcm9jZXNzZWREYXRhW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXREb21haW4oc2NvcGUsIHNlYXJjaElkLCB0eXBlID0gXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgZG9tYWlucyA9IHRoaXMuZ2V0RG9tYWluc0J5VHlwZSh0eXBlLCBwcm9jZXNzZWREYXRhKTtcbiAgICByZXR1cm4gZG9tYWlucz8uW3RoaXMucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQoc2NvcGUsIHNlYXJjaElkKV0gPz8gW107XG4gIH1cbiAgZ2V0RG9tYWluc0J5VHlwZSh0eXBlLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwia2V5XCI6XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWREYXRhLmRvbWFpbi5rZXlzO1xuICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXM7XG4gICAgICBjYXNlIFwiYWdncmVnYXRlXCI6XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXM7XG4gICAgICBjYXNlIFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCI6XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWREYXRhLmRvbWFpbi5ncm91cHM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc0RhdGEoZGF0YSwgc291cmNlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdHM6IHsgZ3JvdXBCeUtleXMsIGdyb3VwQnlGbiB9LFxuICAgICAgYWdncmVnYXRlcyxcbiAgICAgIGdyb3VwUHJvY2Vzc29ycyxcbiAgICAgIHJlZHVjZXJzLFxuICAgICAgcHJvY2Vzc29ycyxcbiAgICAgIHByb3BlcnR5UHJvY2Vzc29yc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGdyb3VwQnlLZXlzICYmIHRoaXMua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZERhdGEgPSB0aGlzLmV4dHJhY3REYXRhKGRhdGEsIHNvdXJjZXMpO1xuICAgIGlmIChncm91cEJ5S2V5cykge1xuICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZ3JvdXBEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBCeUZuKSB7XG4gICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5ncm91cERhdGEocHJvY2Vzc2VkRGF0YSwgZ3JvdXBCeUZuKHByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwUHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc3RQcm9jZXNzR3JvdXBzKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAoYWdncmVnYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eVByb2Nlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc1Byb3BlcnRpZXMocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChyZWR1Y2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnJlZHVjZURhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGRlZiBvZiBpdGVyYXRlKHRoaXMua2V5cywgdGhpcy52YWx1ZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBtaXNzQ291bnRdIG9mIGRlZi5taXNzaW5nKSB7XG4gICAgICAgICAgaWYgKG1pc3NDb3VudCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVIaW50ID0gc2NvcGUgPT0gbnVsbCA/IFwiXCIgOiBgIGZvciAke3Njb3BlfWA7XG4gICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSBrZXkgJyR7ZGVmLnByb3BlcnR5fScgd2FzIG5vdCBmb3VuZCBpbiBhbnkgZGF0YSBlbGVtZW50JHtzY29wZUhpbnR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBwcm9jZXNzZWREYXRhLnRpbWUgPSBlbmQgLSBzdGFydDtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICBsb2dQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICB0aGlzLnNjb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBpdGVyYXRlKHRoaXMua2V5cywgdGhpcy52YWx1ZXMsIHRoaXMuYWdncmVnYXRlcykpIHtcbiAgICAgIGlmICghZGVmLmlkc01hcClcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBkZWYuaWRzTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnNjb3BlQ2FjaGUuaGFzKHNjb3BlKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZUNhY2hlLnNldChzY29wZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tpZCwgZGVmXV0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUpPy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiBpZHMgb24gdGhlIHNhbWUgc2NvcGUgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29wZUNhY2hlLmdldChzY29wZSkuc2V0KGlkLCBkZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YTtcbiAgfVxuICB2YWx1ZUdyb3VwSWR4TG9va3VwKHsgbWF0Y2hHcm91cElkcyB9KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGRlZl0gb2YgdGhpcy52YWx1ZXMuZW50cmllcygpKSB7XG4gICAgICBpZiAoIW1hdGNoR3JvdXBJZHMgfHwgZGVmLmdyb3VwSWQgJiYgbWF0Y2hHcm91cElkcy5pbmNsdWRlcyhkZWYuZ3JvdXBJZCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhbHVlSWR4TG9va3VwKHNjb3BlcywgcHJvcCkge1xuICAgIGNvbnN0IG5vU2NvcGVzVG9NYXRjaCA9IHNjb3BlcyA9PSBudWxsIHx8IHNjb3Blcy5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgcHJvcElkID0gdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgPyBwcm9wIDogcHJvcC5pZDtcbiAgICBjb25zdCBoYXNNYXRjaGluZ1Njb3BlSWQgPSAoZGVmKSA9PiB7XG4gICAgICBpZiAoZGVmLmlkc01hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBkZWYuaWRzTWFwKSB7XG4gICAgICAgICAgaWYgKHNjb3Blcz8uaW5jbHVkZXMoc2NvcGUpICYmIGlkcy5oYXMocHJvcElkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlcy5maW5kSW5kZXgoKGRlZikgPT4ge1xuICAgICAgY29uc3QgdmFsaWREZWZTY29wZXMgPSBkZWYuc2NvcGVzID09IG51bGwgfHwgbm9TY29wZXNUb01hdGNoICYmICFkZWYuc2NvcGVzLmxlbmd0aCB8fCBkZWYuc2NvcGVzLnNvbWUoKHMpID0+IHNjb3Blcz8uaW5jbHVkZXMocykpO1xuICAgICAgcmV0dXJuIHZhbGlkRGVmU2NvcGVzICYmIChkZWYucHJvcGVydHkgPT09IHByb3BJZCB8fCBkZWYuaWQgPT09IHByb3BJZCB8fCBoYXNNYXRjaGluZ1Njb3BlSWQoZGVmKSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFHIENoYXJ0cyAtIGNvbmZpZ3VyYXRpb24gZXJyb3IsIHVua25vd24gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShwcm9wKX0gaW4gc2NvcGUocykgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzY29wZXNcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGV4dHJhY3REYXRhKGRhdGEsIHNvdXJjZXMpIHtcbiAgICBjb25zdCB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgc2NvcGVzLCBhbGxTY29wZXNIYXZlU2FtZURlZnMgfSA9IHRoaXMuaW5pdERhdGFEb21haW5Qcm9jZXNzb3IoKTtcbiAgICBjb25zdCBzb3VyY2VzQnlJZCA9IG5ldyBNYXAoc291cmNlcz8ubWFwKChzKSA9PiBbcy5pZCwgc10pKTtcbiAgICBjb25zdCB7IGtleXM6IGtleURlZnMsIHZhbHVlczogdmFsdWVEZWZzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdERhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGxldCByZXN1bHREYXRhSWR4ID0gMDtcbiAgICBsZXQgcGFydGlhbFZhbGlkRGF0YUNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IFtkYXR1bUlkeCwgZGF0dW1dIG9mIGRhdGEuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBzb3VyY2VEYXR1bXMgPSB7fTtcbiAgICAgIGNvbnN0IHZhbGlkU2NvcGVzID0gc2NvcGVzLnNpemUgPiAwID8gbmV3IFNldChzY29wZXMpIDogdm9pZCAwO1xuICAgICAgY29uc3Qga2V5cyA9IG5ldyBBcnJheShrZXlEZWZzLmxlbmd0aCk7XG4gICAgICBsZXQga2V5SWR4ID0gMDtcbiAgICAgIGxldCBrZXk7XG4gICAgICBmb3IgKGNvbnN0IGRlZiBvZiBrZXlEZWZzKSB7XG4gICAgICAgIGtleSA9IHByb2Nlc3NWYWx1ZShkZWYsIGRhdHVtLCBrZXkpO1xuICAgICAgICBpZiAoa2V5ID09PSBJTlZBTElEX1ZBTFVFKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgIGtleXNba2V5SWR4KytdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBJTlZBTElEX1ZBTFVFKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlRGVmcy5sZW5ndGggPiAwID8gbmV3IEFycmF5KHZhbHVlRGVmcy5sZW5ndGgpIDogdm9pZCAwO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgZm9yIChjb25zdCBbdmFsdWVEZWZJZHgsIGRlZl0gb2YgdmFsdWVEZWZzLmVudHJpZXMoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGRlZi5zY29wZXMgPz8gc2NvcGVzKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc0J5SWQuZ2V0KHNjb3BlKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZURhdHVtID0gc291cmNlPy5kYXRhW2RhdHVtSWR4XSA/PyBkYXR1bTtcbiAgICAgICAgICB2YWx1ZSA9IHByb2Nlc3NWYWx1ZShkZWYsIHZhbHVlRGF0dW0sIHZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBJTlZBTElEX1ZBTFVFIHx8ICF2YWx1ZXMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgZGVmLmluY2x1ZGVQcm9wZXJ0eSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gZGVmLmluY2x1ZGVQcm9wZXJ0eSAmJiBkZWYuaWQgIT0gbnVsbCA/IGRlZi5pZCA6IGRlZi5wcm9wZXJ0eTtcbiAgICAgICAgICAgIHNvdXJjZURhdHVtc1tzY29wZV0gPz8gKHNvdXJjZURhdHVtc1tzY29wZV0gPSB7fSk7XG4gICAgICAgICAgICBzb3VyY2VEYXR1bXNbc2NvcGVdW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXNbdmFsdWVEZWZJZHhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBJTlZBTElEX1ZBTFVFKSB7XG4gICAgICAgICAgaWYgKGFsbFNjb3Blc0hhdmVTYW1lRGVmcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgZGVmLnNjb3BlcyA/PyBzY29wZXMpIHtcbiAgICAgICAgICAgIHZhbGlkU2NvcGVzPy5kZWxldGUoc2NvcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWRTY29wZXM/LnNpemUgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBJTlZBTElEX1ZBTFVFICYmIGFsbFNjb3Blc0hhdmVTYW1lRGVmcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodmFsaWRTY29wZXM/LnNpemUgPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXR1bTogeyAuLi5kYXR1bSwgLi4uc291cmNlRGF0dW1zIH0sIGtleXMsIHZhbHVlcyB9O1xuICAgICAgaWYgKCFhbGxTY29wZXNIYXZlU2FtZURlZnMgJiYgdmFsaWRTY29wZXMgJiYgdmFsaWRTY29wZXMuc2l6ZSA8IHNjb3Blcy5zaXplKSB7XG4gICAgICAgIHBhcnRpYWxWYWxpZERhdGFDb3VudCsrO1xuICAgICAgICByZXN1bHQudmFsaWRTY29wZXMgPSBuZXcgU2V0KHZhbGlkU2NvcGVzKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdERhdGFbcmVzdWx0RGF0YUlkeCsrXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0RGF0YS5sZW5ndGggPSByZXN1bHREYXRhSWR4O1xuICAgIGNvbnN0IHByb3BlcnR5RG9tYWluID0gKGRlZikgPT4ge1xuICAgICAgY29uc3QgZGVmRG9tYWluID0gZGF0YURvbWFpbi5nZXQoZGVmKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZkRvbWFpbi5nZXREb21haW4oKTtcbiAgICAgIGlmIChDb250aW51b3VzRG9tYWluLmlzKGRlZkRvbWFpbikgJiYgcmVzdWx0WzBdID4gcmVzdWx0WzFdKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1bmdyb3VwZWRcIixcbiAgICAgIGlucHV0OiB7IGNvdW50OiBkYXRhLmxlbmd0aCB9LFxuICAgICAgZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgIGRvbWFpbjoge1xuICAgICAgICBrZXlzOiBrZXlEZWZzLm1hcChwcm9wZXJ0eURvbWFpbiksXG4gICAgICAgIHZhbHVlczogdmFsdWVEZWZzLm1hcChwcm9wZXJ0eURvbWFpbilcbiAgICAgIH0sXG4gICAgICBkZWZzOiB7XG4gICAgICAgIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyxcbiAgICAgICAga2V5czoga2V5RGVmcyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZURlZnNcbiAgICAgIH0sXG4gICAgICBwYXJ0aWFsVmFsaWREYXRhQ291bnQsXG4gICAgICB0aW1lOiAwXG4gICAgfTtcbiAgfVxuICBncm91cERhdGEoZGF0YSwgZ3JvdXBpbmdGbikge1xuICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZGF0YUVudHJ5IG9mIGRhdGEuZGF0YSkge1xuICAgICAgY29uc3QgeyBrZXlzLCB2YWx1ZXMsIGRhdHVtLCB2YWxpZFNjb3BlcyB9ID0gZGF0YUVudHJ5O1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cGluZ0ZuPy4oZGF0YUVudHJ5KSA/PyBrZXlzO1xuICAgICAgY29uc3QgZ3JvdXBTdHIgPSB0b0tleVN0cmluZyhncm91cCk7XG4gICAgICBpZiAocHJvY2Vzc2VkRGF0YS5oYXMoZ3JvdXBTdHIpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IHByb2Nlc3NlZERhdGEuZ2V0KGdyb3VwU3RyKTtcbiAgICAgICAgZXhpc3RpbmdEYXRhLnZhbHVlcy5wdXNoKHZhbHVlcyk7XG4gICAgICAgIGV4aXN0aW5nRGF0YS5kYXR1bS5wdXNoKGRhdHVtKTtcbiAgICAgICAgaWYgKHZhbGlkU2NvcGVzICE9IG51bGwgJiYgZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGV4aXN0aW5nRGF0YS52YWxpZFNjb3Blcykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZFNjb3Blcy5oYXMoc2NvcGUpKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nRGF0YS52YWxpZFNjb3Blcy5kZWxldGUoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkRGF0YS5zZXQoZ3JvdXBTdHIsIHtcbiAgICAgICAgICBrZXlzOiBncm91cCxcbiAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZXNdLFxuICAgICAgICAgIGRhdHVtOiBbZGF0dW1dLFxuICAgICAgICAgIHZhbGlkU2NvcGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHREYXRhID0gbmV3IEFycmF5KHByb2Nlc3NlZERhdGEuc2l6ZSk7XG4gICAgY29uc3QgcmVzdWx0R3JvdXBzID0gbmV3IEFycmF5KHByb2Nlc3NlZERhdGEuc2l6ZSk7XG4gICAgbGV0IGRhdGFJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCB7IGtleXMsIHZhbHVlcywgZGF0dW0sIHZhbGlkU2NvcGVzIH0gb2YgcHJvY2Vzc2VkRGF0YS52YWx1ZXMoKSkge1xuICAgICAgaWYgKHZhbGlkU2NvcGVzPy5zaXplID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlc3VsdEdyb3Vwc1tkYXRhSW5kZXhdID0ga2V5cztcbiAgICAgIHJlc3VsdERhdGFbZGF0YUluZGV4KytdID0ge1xuICAgICAgICBrZXlzLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB2YWxpZFNjb3Blc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICB0eXBlOiBcImdyb3VwZWRcIixcbiAgICAgIGRhdGE6IHJlc3VsdERhdGEsXG4gICAgICBkb21haW46IHtcbiAgICAgICAgLi4uZGF0YS5kb21haW4sXG4gICAgICAgIGdyb3VwczogcmVzdWx0R3JvdXBzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhZ2dyZWdhdGVEYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBpc1VuZ3JvdXBlZCA9IHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJ1bmdyb3VwZWRcIjtcbiAgICBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGVmXSBvZiB0aGlzLmFnZ3JlZ2F0ZXMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy52YWx1ZUdyb3VwSWR4TG9va3VwKGRlZik7XG4gICAgICBjb25zdCBkb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIHByb2Nlc3NlZERhdGEuZGF0YSkge1xuICAgICAgICBkYXR1bS5hZ2dWYWx1ZXMgPz8gKGRhdHVtLmFnZ1ZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoKSk7XG4gICAgICAgIGlmIChkYXR1bS52YWxpZFNjb3BlcylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXNVbmdyb3VwZWQgPyBbZGF0dW0udmFsdWVzXSA6IGRhdHVtLnZhbHVlcztcbiAgICAgICAgbGV0IGdyb3VwQWdnVmFsdWVzID0gZGVmLmdyb3VwQWdncmVnYXRlRnVuY3Rpb24/LigpID8/IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgZm9yIChjb25zdCBkaXN0aW5jdFZhbHVlcyBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXNUb0FnZyA9IGluZGljZXMubWFwKCh2YWx1ZUlkeCkgPT4gZGlzdGluY3RWYWx1ZXNbdmFsdWVJZHhdKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZXNBZ2cgPSBkZWYuYWdncmVnYXRlRnVuY3Rpb24odmFsdWVzVG9BZ2csIGRhdHVtLmtleXMpO1xuICAgICAgICAgIGlmICh2YWx1ZXNBZ2cpIHtcbiAgICAgICAgICAgIGdyb3VwQWdnVmFsdWVzID0gZGVmLmdyb3VwQWdncmVnYXRlRnVuY3Rpb24/Lih2YWx1ZXNBZ2csIGdyb3VwQWdnVmFsdWVzKSA/PyBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbih2YWx1ZXNBZ2csIGdyb3VwQWdnVmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxWYWx1ZXMgPSAoZGVmLmZpbmFsRnVuY3Rpb24/Lihncm91cEFnZ1ZhbHVlcykgPz8gZ3JvdXBBZ2dWYWx1ZXMpLm1hcCgodikgPT4gcm91bmQyKHYpKTtcbiAgICAgICAgZGF0dW0uYWdnVmFsdWVzW2luZGV4XSA9IGZpbmFsVmFsdWVzO1xuICAgICAgICBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbihmaW5hbFZhbHVlcywgZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcy5wdXNoKGRvbWFpbik7XG4gICAgfVxuICB9XG4gIHBvc3RQcm9jZXNzR3JvdXBzKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCB7IGdyb3VwUHJvY2Vzc29ycyB9ID0gdGhpcztcbiAgICBjb25zdCBhZmZlY3RlZEluZGljZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVwZGF0ZWREb21haW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBncm91cFByb2Nlc3NvckluZGljZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdyb3VwUHJvY2Vzc29ySW5pdEZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgZ3JvdXBQcm9jZXNzb3JzKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy52YWx1ZUdyb3VwSWR4TG9va3VwKHByb2Nlc3Nvcik7XG4gICAgICBncm91cFByb2Nlc3NvckluZGljZXMuc2V0KHByb2Nlc3NvciwgaW5kaWNlcyk7XG4gICAgICBncm91cFByb2Nlc3NvckluaXRGbnMuc2V0KHByb2Nlc3NvciwgcHJvY2Vzc29yLmFkanVzdCgpKTtcbiAgICAgIGZvciAoY29uc3QgaWR4IG9mIGluZGljZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVEZWYgPSB0aGlzLnZhbHVlc1tpZHhdO1xuICAgICAgICBjb25zdCBpc0Rpc2NyZXRlID0gdmFsdWVEZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCI7XG4gICAgICAgIGFmZmVjdGVkSW5kaWNlcy5hZGQoaWR4KTtcbiAgICAgICAgdXBkYXRlZERvbWFpbnMuc2V0KGlkeCwgaXNEaXNjcmV0ZSA/IG5ldyBEaXNjcmV0ZURvbWFpbigpIDogbmV3IENvbnRpbnVvdXNEb21haW4oKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURvbWFpbnMgPSAodmFsdWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5kZXggb2YgYWZmZWN0ZWRJbmRpY2VzKSB7XG4gICAgICAgIHVwZGF0ZWREb21haW5zLmdldCh2YWx1ZUluZGV4KT8uZXh0ZW5kKHZhbHVlc1t2YWx1ZUluZGV4XSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHByb2Nlc3NlZERhdGEuZGF0YSkge1xuICAgICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgZ3JvdXBQcm9jZXNzb3JzKSB7XG4gICAgICAgIGlmIChncm91cC52YWxpZFNjb3BlcylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdmFsdWVJbmRleGVzID0gZ3JvdXBQcm9jZXNzb3JJbmRpY2VzLmdldChwcm9jZXNzb3IpID8/IFtdO1xuICAgICAgICBjb25zdCBhZGp1c3RGbiA9IGdyb3VwUHJvY2Vzc29ySW5pdEZucy5nZXQocHJvY2Vzc29yKT8uKCk7XG4gICAgICAgIGlmICghYWRqdXN0Rm4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB2YWx1ZXMgb2YgZ3JvdXAudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgIGFkanVzdEZuKHZhbHVlcywgdmFsdWVJbmRleGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWVzKSB7XG4gICAgICAgICAgYWRqdXN0Rm4oZ3JvdXAudmFsdWVzLCB2YWx1ZUluZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cC52YWx1ZXMpIHtcbiAgICAgICAgICB1cGRhdGVEb21haW5zKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZURvbWFpbnMoZ3JvdXAudmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWR4LCBkYXRhRG9tYWluXSBvZiB1cGRhdGVkRG9tYWlucykge1xuICAgICAgcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW2lkeF0gPSBkYXRhRG9tYWluLmdldERvbWFpbigpO1xuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc1Byb3BlcnRpZXMocHJvY2Vzc2VkRGF0YSkge1xuICAgIGZvciAoY29uc3QgeyBhZGp1c3QsIHByb3BlcnR5LCBzY29wZXMgfSBvZiB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycykge1xuICAgICAgYWRqdXN0KCkocHJvY2Vzc2VkRGF0YSwgdGhpcy52YWx1ZUlkeExvb2t1cChzY29wZXMsIHByb3BlcnR5KSk7XG4gICAgfVxuICB9XG4gIHJlZHVjZURhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZCA/PyAocHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID0ge30pO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMucmVkdWNlcnMpIHtcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSBkZWYucmVkdWNlcigpO1xuICAgICAgbGV0IGFjY1ZhbHVlID0gZGVmLmluaXRpYWxWYWx1ZTtcbiAgICAgIGZvciAoY29uc3QgZGF0dW0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XG4gICAgICAgIGlmICghZGF0dW0udmFsaWRTY29wZXMgfHwgZGVmLnNjb3Blcz8uc29tZSgocykgPT4gZGF0dW0udmFsaWRTY29wZXM/LmhhcyhzKSkpIHtcbiAgICAgICAgICBhY2NWYWx1ZSA9IHJlZHVjZXIoYWNjVmFsdWUsIGRhdHVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkW2RlZi5wcm9wZXJ0eV0gPSBhY2NWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcG9zdFByb2Nlc3NEYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWQgPz8gKHByb2Nlc3NlZERhdGEucmVkdWNlZCA9IHt9KTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLnByb2Nlc3NvcnMpIHtcbiAgICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZFtkZWYucHJvcGVydHldID0gZGVmLmNhbGN1bGF0ZShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gIH1cbiAgaW5pdERhdGFEb21haW5Qcm9jZXNzb3IoKSB7XG4gICAgY29uc3QgeyBrZXlzOiBrZXlEZWZzLCB2YWx1ZXM6IHZhbHVlRGVmcyB9ID0gdGhpcztcbiAgICBjb25zdCBzY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdmFsdWVEZWZzKSB7XG4gICAgICBpZiAoIXZhbHVlRGVmLnNjb3BlcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHZhbHVlRGVmLnNjb3Blcykge1xuICAgICAgICBzY29wZXMuYWRkKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YURvbWFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvY2Vzc29yRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzID0gdHJ1ZTtcbiAgICBjb25zdCBpbml0RGF0YURvbWFpbiA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUoa2V5RGVmcywgdmFsdWVEZWZzKSkge1xuICAgICAgICBpZiAoZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgICAgZGF0YURvbWFpbi5zZXQoZGVmLCBuZXcgRGlzY3JldGVEb21haW4oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YURvbWFpbi5zZXQoZGVmLCBuZXcgQ29udGludW91c0RvbWFpbigpKTtcbiAgICAgICAgICBhbGxTY29wZXNIYXZlU2FtZURlZnMgJiYgKGFsbFNjb3Blc0hhdmVTYW1lRGVmcyA9IChkZWYuc2NvcGVzID8/IFtdKS5sZW5ndGggPT09IHNjb3Blcy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5pdERhdGFEb21haW4oKTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLmJ1aWxkQWNjZXNzb3JzKGl0ZXJhdGUoa2V5RGVmcywgdmFsdWVEZWZzKSk7XG4gICAgY29uc3QgcHJvY2Vzc1ZhbHVlID0gKGRlZiwgZGF0dW0sIHByZXZpb3VzRGF0dW0sIHNjb3BlKSA9PiB7XG4gICAgICBsZXQgdmFsdWVJbkRhdHVtO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgaWYgKGFjY2Vzc29ycy5oYXMoZGVmLnByb3BlcnR5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gYWNjZXNzb3JzLmdldChkZWYucHJvcGVydHkpKGRhdHVtKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUluRGF0dW0gPSB2YWx1ZSAhPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVJbkRhdHVtID0gZGVmLnByb3BlcnR5IGluIGRhdHVtO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlSW5EYXR1bSA/IGRhdHVtW2RlZi5wcm9wZXJ0eV0gOiBkZWYubWlzc2luZ1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlZi5mb3JjZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlSW5EYXR1bSAmJiBpc05lZ2F0aXZlKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZU5lZ2F0aXZlID8gLTEgKiBkZWYuZm9yY2VWYWx1ZSA6IGRlZi5mb3JjZVZhbHVlO1xuICAgICAgICB2YWx1ZUluRGF0dW0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlRGVmID0gXCJtaXNzaW5nVmFsdWVcIiBpbiBkZWY7XG4gICAgICBpZiAoIXZhbHVlSW5EYXR1bSAmJiAhbWlzc2luZ1ZhbHVlRGVmKSB7XG4gICAgICAgIGNvbnN0IG1pc3NDb3VudCA9IGRlZi5taXNzaW5nLmdldChzY29wZSkgPz8gMDtcbiAgICAgICAgZGVmLm1pc3Npbmcuc2V0KHNjb3BlLCBtaXNzQ291bnQgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YURvbWFpbi5oYXMoZGVmKSkge1xuICAgICAgICBpbml0RGF0YURvbWFpbigpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlSW5EYXR1bSAmJiBkZWYudmFsaWRhdGlvbj8uKHZhbHVlLCBkYXR1bSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChcImludmFsaWRWYWx1ZVwiIGluIGRlZikge1xuICAgICAgICAgIHZhbHVlID0gZGVmLmludmFsaWRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlICE9PSBcImludGVncmF0ZWRcIikge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgICAgICBgaW52YWxpZCB2YWx1ZSBvZiB0eXBlIFske3R5cGVvZiB2YWx1ZX1dIGZvciBbJHtkZWYuc2NvcGVzfSAvICR7ZGVmLmlkfV0gaWdub3JlZDpgLFxuICAgICAgICAgICAgICBgWyR7dmFsdWV9XWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBJTlZBTElEX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmLnByb2Nlc3Nvcikge1xuICAgICAgICBpZiAoIXByb2Nlc3NvckZucy5oYXMoZGVmKSkge1xuICAgICAgICAgIHByb2Nlc3NvckZucy5zZXQoZGVmLCBkZWYucHJvY2Vzc29yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gcHJvY2Vzc29yRm5zLmdldChkZWYpPy4odmFsdWUsIHByZXZpb3VzRGF0dW0gPT09IElOVkFMSURfVkFMVUUgPyB2b2lkIDAgOiBwcmV2aW91c0RhdHVtKTtcbiAgICAgIH1cbiAgICAgIGRhdGFEb21haW4uZ2V0KGRlZik/LmV4dGVuZCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4geyBkYXRhRG9tYWluLCBwcm9jZXNzVmFsdWUsIGluaXREYXRhRG9tYWluLCBzY29wZXMsIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyB9O1xuICB9XG4gIGJ1aWxkQWNjZXNzb3JzKGRlZnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICBjb25zdCBpc1BhdGggPSBkZWYucHJvcGVydHkuaW5jbHVkZXMoXCIuXCIpIHx8IGRlZi5wcm9wZXJ0eS5pbmNsdWRlcyhcIltcIik7XG4gICAgICBpZiAoIWlzUGF0aClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0UGF0aENvbXBvbmVudHMoZGVmLnByb3BlcnR5KTtcbiAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiSW52YWxpZCBwcm9wZXJ0eSBwYXRoIFslc11cIiwgZGVmLnByb3BlcnR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IGNyZWF0ZVBhdGhBY2Nlc3Nvcihjb21wb25lbnRzKTtcbiAgICAgIHJlc3VsdC5zZXQoZGVmLnByb3BlcnR5LCBhY2Nlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBsb2dQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgY29uc3QgbG9nVmFsdWVzID0gKG5hbWUsIGRhdGEpID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBMb2dnZXIubG9nKGBEYXRhTW9kZWwucHJvY2Vzc0RhdGEoKSAtICR7bmFtZX1gKTtcbiAgICAgIExvZ2dlci50YWJsZShkYXRhKTtcbiAgICB9XG4gIH07XG4gIExvZ2dlci5sb2coXCJEYXRhTW9kZWwucHJvY2Vzc0RhdGEoKSAtIHByb2Nlc3NlZERhdGFcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gIGxvZ1ZhbHVlcyhcIktleSBEb21haW5zXCIsIHByb2Nlc3NlZERhdGEuZG9tYWluLmtleXMpO1xuICBsb2dWYWx1ZXMoXCJHcm91cCBEb21haW5zXCIsIHByb2Nlc3NlZERhdGEuZG9tYWluLmdyb3VwcyA/PyBbXSk7XG4gIGxvZ1ZhbHVlcyhcIlZhbHVlIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzKTtcbiAgbG9nVmFsdWVzKFwiQWdncmVnYXRlIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzID8/IFtdKTtcbiAgaWYgKHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJncm91cGVkXCIpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRhdGEucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXh0LmtleXMgPz8gW107XG4gICAgICBjb25zdCBhZ2dWYWx1ZXMgPSBuZXh0LmFnZ1ZhbHVlcyA/PyBbXTtcbiAgICAgIGNvbnN0IHNraXBLZXlzID0gbmV4dC5rZXlzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgICAgY29uc3Qgc2tpcEFnZ1ZhbHVlcyA9IGFnZ1ZhbHVlcz8ubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgICBhY2MucHVzaChcbiAgICAgICAgLi4ubmV4dC52YWx1ZXMubWFwKCh2LCBpKSA9PiBbXG4gICAgICAgICAgLi4uaSA9PT0gMCA/IGtleXMgOiBza2lwS2V5cyxcbiAgICAgICAgICAuLi52ID8/IFtdLFxuICAgICAgICAgIC4uLmkgPT0gMCA/IGFnZ1ZhbHVlcyA6IHNraXBBZ2dWYWx1ZXNcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICBsb2dWYWx1ZXMoXCJWYWx1ZXNcIiwgZmxhdHRlbmVkVmFsdWVzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmbGF0dGVuZWRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRhdGEucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGFnZ1ZhbHVlcyA9IG5leHQuYWdnVmFsdWVzID8/IFtdO1xuICAgICAgYWNjLnB1c2goWy4uLm5leHQua2V5cywgLi4ubmV4dC52YWx1ZXMsIC4uLmFnZ1ZhbHVlc10pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgbG9nVmFsdWVzKFwiVmFsdWVzXCIsIGZsYXR0ZW5lZFZhbHVlcyk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9kYXRhQ29udHJvbGxlci50c1xudmFyIF9EYXRhQ29udHJvbGxlciA9IGNsYXNzIF9EYXRhQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKG1vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIpO1xuICAgIHRoaXMucmVxdWVzdGVkID0gW107XG4gICAgdGhpcy5zdGF0dXMgPSBcInNldHVwXCI7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChpZCwgZGF0YSwgb3B0cykge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzZXR1cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRhdGEgcmVxdWVzdCBhZnRlciBkYXRhIHNldHVwIHBoYXNlLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0ZWQucHVzaCh7IGlkLCBvcHRzLCBkYXRhLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwic2V0dXBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkYXRhIHJlcXVlc3QgYWZ0ZXIgZGF0YSBzZXR1cCBwaGFzZS5gKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSBcImV4ZWN1dGVkXCI7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIHJlcXVlc3RlZFwiLCB0aGlzLnJlcXVlc3RlZCk7XG4gICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlUmVxdWVzdHModGhpcy5yZXF1ZXN0ZWQpO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhQ29udHJvbGxlci5leGVjdXRlKCkgLSB2YWxpZGF0ZWRcIiwgdmFsaWQpO1xuICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWVyZ2VSZXF1ZXN0ZWQodmFsaWQpO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhQ29udHJvbGxlci5leGVjdXRlKCkgLSBtZXJnZWRcIiwgbWVyZ2VkKTtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICBnZXRXaW5kb3coKS5wcm9jZXNzZWREYXRhID0gW107XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMucmVxdWVzdGVkLm1hcCgoeyBpZCB9KSA9PiBpZCk7XG4gICAgY29uc3QgbmVlZHNWYWx1ZUV4dHJhY3Rpb24gPSB0aGlzLmhhc011bHRpcGxlRGF0YVNvdXJjZXModmFsaWQpO1xuICAgIGZvciAoY29uc3QgeyBvcHRzLCBkYXRhLCByZXNvbHZlcywgcmVqZWN0cywgaWRzIH0gb2YgbWVyZ2VkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhTW9kZWwgPSBuZXcgRGF0YU1vZGVsKG9wdHMsIHRoaXMubW9kZSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBkYXRhTW9kZWwucHJvY2Vzc0RhdGEoZGF0YSwgdmFsaWQpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgICAgZ2V0V2luZG93KFwicHJvY2Vzc2VkRGF0YVwiKS5wdXNoKHByb2Nlc3NlZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzZWREYXRhPy5wYXJ0aWFsVmFsaWREYXRhQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlcy5mb3JFYWNoKFxuICAgICAgICAgICAgKHJlc29sdmUsIHJlcXVlc3RJZHgpID0+IHJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhTW9kZWwsXG4gICAgICAgICAgICAgIHByb2Nlc3NlZERhdGE6IHRoaXMucHJvY2Vzc1Njb3BlZERhdGEoXG4gICAgICAgICAgICAgICAgaWRzW3JlcXVlc3RJZHhdLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICAgICAgICAgICAgc2NvcGVzLFxuICAgICAgICAgICAgICAgIG5lZWRzVmFsdWVFeHRyYWN0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5zcGxpdFJlc3VsdChkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGlkcywgcmVzb2x2ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdHMuZm9yRWFjaCgoY2IpID0+IGNiKG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gbm8gcHJvY2Vzc2VkIGRhdGEgZ2VuZXJhdGVkYCkpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0cy5mb3JFYWNoKChjYikgPT4gY2IoZXJyb3IpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzTXVsdGlwbGVEYXRhU291cmNlcyh2YWxpZFJlcXVlc3RzKSB7XG4gICAgaWYgKHZhbGlkUmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBbeyBkYXRhIH0sIC4uLnJlc3RSZXF1ZXN0c10gPSB2YWxpZFJlcXVlc3RzO1xuICAgICAgcmV0dXJuIHJlc3RSZXF1ZXN0cy5zb21lKCh2KSA9PiBkYXRhICE9PSB2LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzc1Njb3BlZERhdGEoaWQsIHByb2Nlc3NlZERhdGEsIGlkcywgbmVlZHNWYWx1ZUV4dHJhY3Rpb24pIHtcbiAgICBjb25zdCBleHRyYWN0RGF0dW0gPSAoZGF0dW0pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdHVtKSkge1xuICAgICAgICByZXR1cm4gZGF0dW0ubWFwKGV4dHJhY3REYXR1bSk7XG4gICAgICB9XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSBuZWVkc1ZhbHVlRXh0cmFjdGlvbiA/IHsgLi4uZGF0dW0sIC4uLmRhdHVtW2lkXSB9IDogZGF0dW07XG4gICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgaWRzKSB7XG4gICAgICAgIGRlbGV0ZSBleHRyYWN0ZWRbb3RoZXJJZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0cmFjdGVkO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdFZhbHVlcyA9ICh2YWx1ZXMpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZXh0cmFjdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzPy5baWRdID8/IHZhbHVlcztcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wcm9jZXNzZWREYXRhLFxuICAgICAgZGF0YTogcHJvY2Vzc2VkRGF0YS5kYXRhLm1hcCgoZGF0dW0pID0+ICh7XG4gICAgICAgIC4uLmRhdHVtLFxuICAgICAgICBkYXR1bTogZXh0cmFjdERhdHVtKGRhdHVtLmRhdHVtKSxcbiAgICAgICAgdmFsdWVzOiBuZWVkc1ZhbHVlRXh0cmFjdGlvbiA/IGRhdHVtLnZhbHVlcz8ubWFwKGV4dHJhY3RWYWx1ZXMpIDogZGF0dW0udmFsdWVzXG4gICAgICB9KSlcbiAgICB9O1xuICB9XG4gIHZhbGlkYXRlUmVxdWVzdHMocmVxdWVzdGVkKSB7XG4gICAgY29uc3QgdmFsaWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgcmVxdWVzdF0gb2YgcmVxdWVzdGVkLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGluZGV4ID4gMCAmJiByZXF1ZXN0LmRhdGEubGVuZ3RoICE9PSByZXF1ZXN0ZWRbMF0uZGF0YS5sZW5ndGggJiYgcmVxdWVzdC5vcHRzLmdyb3VwQnlEYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXF1ZXN0LnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXCJhbGwgc2VyaWVzW10uZGF0YSBhcnJheXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGggYW5kIGhhdmUgbWF0Y2hpbmcga2V5cy5cIilcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkLnB1c2gocmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuICBtZXJnZVJlcXVlc3RlZChyZXF1ZXN0ZWQpIHtcbiAgICBjb25zdCBncm91cGVkID0gW107XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RlZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBncm91cGVkLmZpbmQoX0RhdGFDb250cm9sbGVyLmdyb3VwTWF0Y2gocmVxdWVzdCkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLnB1c2gocmVxdWVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cGVkLnB1c2goW3JlcXVlc3RdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwZWQubWFwKF9EYXRhQ29udHJvbGxlci5tZXJnZVJlcXVlc3RzKTtcbiAgfVxuICBzcGxpdFJlc3VsdChkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIHNjb3BlcywgcmVzb2x2ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2NvcGUgPSBzY29wZXNbaV07XG4gICAgICBjb25zdCByZXNvbHZlID0gcmVzb2x2ZXNbaV07XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgZGF0YU1vZGVsLFxuICAgICAgICBwcm9jZXNzZWREYXRhOiB7XG4gICAgICAgICAgLi4ucHJvY2Vzc2VkRGF0YSxcbiAgICAgICAgICBkYXRhOiBwcm9jZXNzZWREYXRhLmRhdGEuZmlsdGVyKCh7IHZhbGlkU2NvcGVzIH0pID0+IHZhbGlkU2NvcGVzPy5oYXMoc2NvcGUpID8/IHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ3JvdXBNYXRjaCh7IGRhdGEsIG9wdHMgfSkge1xuICAgIGZ1bmN0aW9uIGtleXMocHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm9wcy5maWx0ZXIoKHApID0+IHAudHlwZSA9PT0gXCJrZXlcIikubWFwKChwKSA9PiBwLnByb3BlcnR5KS5qb2luKFwiO1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIChbZ3JvdXBdKSA9PiAob3B0cy5ncm91cEJ5RGF0YSA9PT0gZmFsc2UgfHwgZ3JvdXAuZGF0YSA9PT0gZGF0YSkgJiYgZ3JvdXAub3B0cy5ncm91cEJ5S2V5cyA9PT0gb3B0cy5ncm91cEJ5S2V5cyAmJiBncm91cC5vcHRzLmdyb3VwQnlGbiA9PT0gb3B0cy5ncm91cEJ5Rm4gJiYga2V5cyhncm91cC5vcHRzLnByb3BzKSA9PT0ga2V5cyhvcHRzLnByb3BzKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VSZXF1ZXN0cyhyZXF1ZXN0cykge1xuICAgIHJldHVybiByZXF1ZXN0cy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCB7IGlkLCBkYXRhLCByZXNvbHZlLCByZWplY3QsIG9wdHM6IHsgcHJvcHMsIC4uLm9wdHMgfSB9KSA9PiB7XG4gICAgICAgIHJlc3VsdC5pZHMucHVzaChpZCk7XG4gICAgICAgIHJlc3VsdC5yZWplY3RzLnB1c2gocmVqZWN0KTtcbiAgICAgICAgcmVzdWx0LnJlc29sdmVzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgIHJlc3VsdC5kYXRhID8/IChyZXN1bHQuZGF0YSA9IGRhdGEpO1xuICAgICAgICByZXN1bHQub3B0cyA/PyAocmVzdWx0Lm9wdHMgPSB7IC4uLm9wdHMsIHByb3BzOiBbXSB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgICAgICAgY29uc3QgY2xvbmUgPSB7IC4uLnByb3AsIHNjb3BlczogW2lkXSB9O1xuICAgICAgICAgIF9EYXRhQ29udHJvbGxlci5jcmVhdGVJZHNNYXAoaWQsIGNsb25lKTtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlc3VsdC5vcHRzLnByb3BzLmZpbmQoXG4gICAgICAgICAgICAoZXhpc3RpbmcpID0+IGV4aXN0aW5nLnR5cGUgPT09IGNsb25lLnR5cGUgJiYgX0RhdGFDb250cm9sbGVyLmRlZXBFcXVhbChleGlzdGluZywgY2xvbmUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0cy5wcm9wcy5wdXNoKGNsb25lKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaC5zY29wZXMgPz8gKG1hdGNoLnNjb3BlcyA9IFtdKTtcbiAgICAgICAgICBtYXRjaC5zY29wZXMucHVzaCguLi5jbG9uZS5zY29wZXMgPz8gW10pO1xuICAgICAgICAgIGlmICgobWF0Y2gudHlwZSA9PT0gXCJrZXlcIiB8fCBtYXRjaC50eXBlID09PSBcInZhbHVlXCIpICYmIGNsb25lLmlkc01hcD8uc2l6ZSkge1xuICAgICAgICAgICAgX0RhdGFDb250cm9sbGVyLm1lcmdlSWRzTWFwKGNsb25lLmlkc01hcCwgbWF0Y2guaWRzTWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB7IGlkczogW10sIHJlamVjdHM6IFtdLCByZXNvbHZlczogW10sIGRhdGE6IG51bGwsIG9wdHM6IG51bGwgfVxuICAgICk7XG4gIH1cbiAgc3RhdGljIG1lcmdlSWRzTWFwKGZyb21NYXAsIHRvTWFwKSB7XG4gICAgZm9yIChjb25zdCBbc2NvcGUsIGlkc10gb2YgZnJvbU1hcCkge1xuICAgICAgY29uc3QgdG9NYXBWYWx1ZSA9IHRvTWFwLmdldChzY29wZSk7XG4gICAgICBpZiAodG9NYXBWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgICAgdG9NYXBWYWx1ZS5hZGQoaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b01hcC5zZXQoc2NvcGUsIG5ldyBTZXQoaWRzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVJZHNNYXAoc2NvcGUsIHByb3ApIHtcbiAgICBpZiAocHJvcC5pZCA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHByb3AuaWRzTWFwID8/IChwcm9wLmlkc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGlmIChwcm9wLmlkc01hcC5oYXMoc2NvcGUpKSB7XG4gICAgICBwcm9wLmlkc01hcC5nZXQoc2NvcGUpLmFkZChwcm9wLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5pZHNNYXAuc2V0KHNjb3BlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcHJvcC5pZF0pKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IGksIGxlbmd0aDI7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBsZW5ndGgyID0gYS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGgyICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBsZW5ndGgyIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoIV9EYXRhQ29udHJvbGxlci5kZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICBsZW5ndGgyID0ga2V5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoMiAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IGxlbmd0aDIgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIV9EYXRhQ29udHJvbGxlci5za2lwS2V5cy5oYXMoa2V5KSAmJiAoIU9iamVjdC5oYXNPd24oYiwga2V5KSB8fCAhX0RhdGFDb250cm9sbGVyLmRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuLy8gb3B0aW1pemVkIHZlcnNpb24gb2YgZGVlcCBlcXVhbGl0eSBmb3IgYG1lcmdlUmVxdWVzdHNgIHdoaWNoIGNhbiBwb3RlbnRpYWxseSBsb29wIG92ZXIgMU0gdGltZXNcbl9EYXRhQ29udHJvbGxlci5za2lwS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImlkXCIsIFwiaWRzTWFwXCIsIFwidHlwZVwiLCBcInNjb3Blc1wiXSk7XG52YXIgRGF0YUNvbnRyb2xsZXIgPSBfRGF0YUNvbnRyb2xsZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvYXhpc1JlZ2lzdHJ5LnRzXG52YXIgQXhpc1JlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmF4ZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGlkZGVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlcihheGlzVHlwZSwgbW9kdWxlKSB7XG4gICAgdGhpcy5heGVzTWFwLnNldChheGlzVHlwZSwgbW9kdWxlLm1vZHVsZUZhY3RvcnkpO1xuICAgIGlmIChtb2R1bGUudGhlbWVUZW1wbGF0ZSkge1xuICAgICAgdGhpcy5zZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlLCBtb2R1bGUudGhlbWVUZW1wbGF0ZSk7XG4gICAgfVxuICAgIGlmIChtb2R1bGUuaGlkZGVuKSB7XG4gICAgICB0aGlzLmhpZGRlbi5hZGQoYXhpc1R5cGUpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUoYXhpc1R5cGUsIG1vZHVsZUNvbnRleHQpIHtcbiAgICBjb25zdCBheGlzRmFjdG9yeSA9IHRoaXMuYXhlc01hcC5nZXQoYXhpc1R5cGUpO1xuICAgIGlmIChheGlzRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGF4aXNGYWN0b3J5KG1vZHVsZUNvbnRleHQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gYXhpcyB0eXBlOiAke2F4aXNUeXBlfWApO1xuICB9XG4gIGhhcyhheGlzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmF4ZXNNYXAuaGFzKGF4aXNUeXBlKTtcbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmF4ZXNNYXAua2V5cygpO1xuICB9XG4gIHB1YmxpY0tleXMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmtleXMoKV0uZmlsdGVyKChrKSA9PiAhdGhpcy5oaWRkZW4uaGFzKGspKTtcbiAgfVxuICBzZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlLCB0aGVtZVRlbXBsYXRlKSB7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcy5zZXQoYXhpc1R5cGUsIHRoZW1lVGVtcGxhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVtZVRlbXBsYXRlcy5nZXQoYXhpc1R5cGUpO1xuICB9XG59O1xudmFyIGF4aXNSZWdpc3RyeSA9IG5ldyBBeGlzUmVnaXN0cnkoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9leHBlY3RlZEVudGVycHJpc2VNb2R1bGVzLnRzXG52YXIgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJhbmltYXRpb25cIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwiYW5ub3RhdGlvbnNcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImJhY2tncm91bmRcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdLFxuICAgIG9wdGlvbnNJbm5lcktleTogXCJpbWFnZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImZvcmVncm91bmRcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdLFxuICAgIG9wdGlvbnNJbm5lcktleTogXCJpbWFnZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImNoYXJ0VG9vbGJhclwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXVxuICB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJjb250ZXh0TWVudVwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl1cbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJzdGF0dXNCYXJcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcInN0YXR1cy1iYXJcIiB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJkYXRhU291cmNlXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXVxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcInN5bmNcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwiem9vbVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJ0b3BvbG9neVwiXSB9LFxuICB7XG4gICAgdHlwZTogXCJsZWdlbmRcIixcbiAgICBvcHRpb25zS2V5OiBcImdyYWRpZW50TGVnZW5kXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXSxcbiAgICBpZGVudGlmaWVyOiBcImdyYWRpZW50XCJcbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJuYXZpZ2F0b3JcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBvcHRpb25zSW5uZXJLZXk6IFwibWluaUNoYXJ0XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwiYW5nbGUtY2F0ZWdvcnlcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJhbmdsZS1udW1iZXJcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpdXMtY2F0ZWdvcnlcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpdXMtbnVtYmVyXCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcIm9yZGluYWwtdGltZVwiIH0sXG4gIHsgdHlwZTogXCJheGlzLW9wdGlvblwiLCBvcHRpb25zS2V5OiBcImNyb3NzaGFpclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJib3gtcGxvdFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiY2FuZGxlc3RpY2tcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcIm9obGNcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImJ1bGxldFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiaGVhdG1hcFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwicmFuZ2UtYXJlYVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwicmFuZ2UtYmFyXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJ3YXRlcmZhbGxcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwibmlnaHRpbmdhbGVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkYXItYXJlYVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRhci1saW5lXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGlhbC1iYXJcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaWFsLWNvbHVtblwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJoaWVyYXJjaHlcIl0sIGlkZW50aWZpZXI6IFwic3VuYnVyc3RcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiaGllcmFyY2h5XCJdLCBpZGVudGlmaWVyOiBcInRyZWVtYXBcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLXNoYXBlXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1saW5lXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1tYXJrZXJcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLXNoYXBlLWJhY2tncm91bmRcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLWxpbmUtYmFja2dyb3VuZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJmbG93LXByb3BvcnRpb25cIl0sIGlkZW50aWZpZXI6IFwiY2hvcmRcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiZmxvdy1wcm9wb3J0aW9uXCJdLCBpZGVudGlmaWVyOiBcInNhbmtleVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXMtb3B0aW9uXCIsIG9wdGlvbnNLZXk6IFwiZXJyb3JCYXJcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImVycm9yLWJhcnNcIiB9XG5dO1xuZnVuY3Rpb24gaXNFbnRlcnByaXNlU2VyaWVzVHlwZSh0eXBlKSB7XG4gIHJldHVybiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuc29tZSgocykgPT4gcy50eXBlID09PSBcInNlcmllc1wiICYmIHMuaWRlbnRpZmllciA9PT0gdHlwZSk7XG59XG5mdW5jdGlvbiBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyh0eXBlKSB7XG4gIHJldHVybiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmluZCgocykgPT4gcy50eXBlID09PSBcInNlcmllc1wiICYmIHMuaWRlbnRpZmllciA9PT0gdHlwZSk/LmNoYXJ0VHlwZXM7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VDYXJ0ZXNpYW4oc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJjYXJ0ZXNpYW5cIik7XG4gIHJldHVybiB0eXBlID09PSBcImNhcnRlc2lhblwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlUG9sYXIoc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJwb2xhclwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwicG9sYXJcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZUhpZXJhcmNoeShzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcImhpZXJhcmNoeVwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiaGllcmFyY2h5XCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VUb3BvbG9neShzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcInRvcG9sb2d5XCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0b3BvbG9neVwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlRmxvd1Byb3BvcnRpb24oc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJmbG93LXByb3BvcnRpb25cIik7XG4gIHJldHVybiB0eXBlID09PSBcImZsb3ctcHJvcG9ydGlvblwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlTW9kdWxlKG1vZHVsZSkge1xuICByZXR1cm4gbW9kdWxlLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIjtcbn1cbmZ1bmN0aW9uIHZlcmlmeUlmTW9kdWxlRXhwZWN0ZWQobW9kdWxlKSB7XG4gIGlmICghaXNFbnRlcnByaXNlTW9kdWxlKG1vZHVsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWd1cmF0aW9uIGVycm9yLCBvbmx5IGVudGVycHJpc2UgbW9kdWxlcyBuZWVkIHZlcmlmaWNhdGlvbi5cIik7XG4gIH1cbiAgY29uc3Qgc3R1YiA9IEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5maW5kKChzKSA9PiB7XG4gICAgcmV0dXJuIHMudHlwZSA9PT0gbW9kdWxlLnR5cGUgJiYgcy5vcHRpb25zS2V5ID09PSBtb2R1bGUub3B0aW9uc0tleSAmJiBzLmlkZW50aWZpZXIgPT09IG1vZHVsZS5pZGVudGlmaWVyICYmIG1vZHVsZS5jaGFydFR5cGVzLmV2ZXJ5KCh0KSA9PiBzLmNoYXJ0VHlwZXMuaW5jbHVkZXModCkpO1xuICB9KTtcbiAgaWYgKHN0dWIpIHtcbiAgICBzdHViLnVzZUNvdW50ID8/IChzdHViLnVzZUNvdW50ID0gMCk7XG4gICAgc3R1Yi51c2VDb3VudCsrO1xuICB9XG4gIHJldHVybiBzdHViICE9IG51bGw7XG59XG5mdW5jdGlvbiBnZXRVbnVzZWRFeHBlY3RlZE1vZHVsZXMoKSB7XG4gIHJldHVybiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmlsdGVyKCh7IHVzZUNvdW50IH0pID0+IHVzZUNvdW50ID09IG51bGwgfHwgdXNlQ291bnQgPT09IDApO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2xlZ2VuZFJlZ2lzdHJ5LnRzXG52YXIgTGVnZW5kUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGVnZW5kTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlcihsZWdlbmRUeXBlLCB7IG9wdGlvbnNLZXksIG1vZHVsZUZhY3RvcnksIHRoZW1lVGVtcGxhdGUgfSkge1xuICAgIHRoaXMubGVnZW5kTWFwLnNldChsZWdlbmRUeXBlLCB7IG9wdGlvbnNLZXksIG1vZHVsZUZhY3RvcnkgfSk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcy5zZXQob3B0aW9uc0tleSwgdGhlbWVUZW1wbGF0ZSk7XG4gIH1cbiAgY3JlYXRlKGxlZ2VuZFR5cGUsIG1vZHVsZUNvbnRleHQpIHtcbiAgICBjb25zdCBsZWdlbmRGYWN0b3J5ID0gdGhpcy5sZWdlbmRNYXAuZ2V0KGxlZ2VuZFR5cGUpPy5tb2R1bGVGYWN0b3J5O1xuICAgIGlmIChsZWdlbmRGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gbGVnZW5kRmFjdG9yeShtb2R1bGVDb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmtub3duIGxlZ2VuZCB0eXBlOiAke2xlZ2VuZFR5cGV9YCk7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnRoZW1lVGVtcGxhdGVzKTtcbiAgfVxuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGVnZW5kTWFwLmVudHJpZXMoKSkucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgW2xlZ2VuZFR5cGUsIHJlY29yZF0pID0+IHtcbiAgICAgICAgcmVzdWx0W2xlZ2VuZFR5cGVdID0gcmVjb3JkLm9wdGlvbnNLZXk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAge31cbiAgICApO1xuICB9XG59O1xudmFyIGxlZ2VuZFJlZ2lzdHJ5ID0gbmV3IExlZ2VuZFJlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvY2hhcnRUeXBlcy50c1xudmFyIENoYXJ0VHlwZXMgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gIGdldChzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiBzdXBlci5nZXQoc2VyaWVzVHlwZTIpID8/IFwidW5rbm93blwiO1xuICB9XG4gIGlzQ2FydGVzaWFuKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJjYXJ0ZXNpYW5cIjtcbiAgfVxuICBpc1BvbGFyKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJwb2xhclwiO1xuICB9XG4gIGlzSGllcmFyY2h5KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJoaWVyYXJjaHlcIjtcbiAgfVxuICBpc1RvcG9sb2d5KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJ0b3BvbG9neVwiO1xuICB9XG4gIGlzRmxvd1Byb3BvcnRpb24oc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcImZsb3ctcHJvcG9ydGlvblwiO1xuICB9XG4gIGdldCBzZXJpZXNUeXBlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSk7XG4gIH1cbiAgZ2V0IGNhcnRlc2lhblR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0NhcnRlc2lhbih0KSk7XG4gIH1cbiAgZ2V0IHBvbGFyVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzUG9sYXIodCkpO1xuICB9XG4gIGdldCBoaWVyYXJjaHlUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNIaWVyYXJjaHkodCkpO1xuICB9XG4gIGdldCB0b3BvbG9neVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc1RvcG9sb2d5KHQpKTtcbiAgfVxuICBnZXQgZmxvd1Byb3BvcnRpb25UeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNGbG93UHJvcG9ydGlvbih0KSk7XG4gIH1cbn07XG52YXIgQ2hhcnREZWZhdWx0cyA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgc2V0KGNoYXJ0VHlwZTIsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldChjaGFydFR5cGUyLCBtZXJnZURlZmF1bHRzKGRlZmF1bHRzLCB0aGlzLmdldChjaGFydFR5cGUyKSkpO1xuICB9XG59O1xudmFyIGNoYXJ0VHlwZXMgPSBuZXcgQ2hhcnRUeXBlcygpO1xudmFyIHB1YmxpY0NoYXJ0VHlwZXMgPSBuZXcgQ2hhcnRUeXBlcygpO1xudmFyIGNoYXJ0RGVmYXVsdHMgPSBuZXcgQ2hhcnREZWZhdWx0cygpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3Nlcmllc1JlZ2lzdHJ5LnRzXG52YXIgU2VyaWVzUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VyaWVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlcihzZXJpZXNUeXBlMiwge1xuICAgIGNoYXJ0VHlwZXM6IFtjaGFydFR5cGUyXSxcbiAgICBtb2R1bGVGYWN0b3J5LFxuICAgIHRvb2x0aXBEZWZhdWx0cyxcbiAgICBkZWZhdWx0QXhlcyxcbiAgICB0aGVtZVRlbXBsYXRlLFxuICAgIHBhbGV0dGVGYWN0b3J5LFxuICAgIHNvbG8sXG4gICAgc3RhY2thYmxlLFxuICAgIGdyb3VwYWJsZSxcbiAgICBzdGFja2VkQnlEZWZhdWx0LFxuICAgIHN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvbixcbiAgICBoaWRkZW5cbiAgfSkge1xuICAgIHRoaXMuc2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiwgdGhlbWVUZW1wbGF0ZSk7XG4gICAgdGhpcy5zZXJpZXNNYXAuc2V0KHNlcmllc1R5cGUyLCB7XG4gICAgICBtb2R1bGVGYWN0b3J5LFxuICAgICAgdG9vbHRpcERlZmF1bHRzLFxuICAgICAgZGVmYXVsdEF4ZXMsXG4gICAgICBwYWxldHRlRmFjdG9yeSxcbiAgICAgIHNvbG8sXG4gICAgICBzdGFja2FibGUsXG4gICAgICBncm91cGFibGUsXG4gICAgICBzdGFja2VkQnlEZWZhdWx0LFxuICAgICAgc3dhcERlZmF1bHRBeGVzQ29uZGl0aW9uXG4gICAgfSk7XG4gICAgY2hhcnRUeXBlcy5zZXQoc2VyaWVzVHlwZTIsIGNoYXJ0VHlwZTIpO1xuICAgIGlmICghaGlkZGVuKSB7XG4gICAgICBwdWJsaWNDaGFydFR5cGVzLnNldChzZXJpZXNUeXBlMiwgY2hhcnRUeXBlMik7XG4gICAgfVxuICB9XG4gIGNyZWF0ZShzZXJpZXNUeXBlMiwgbW9kdWxlQ29udGV4dCkge1xuICAgIGNvbnN0IHNlcmllc0ZhY3RvcnkgPSB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5tb2R1bGVGYWN0b3J5O1xuICAgIGlmIChzZXJpZXNGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gc2VyaWVzRmFjdG9yeShtb2R1bGVDb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmtub3duIHNlcmllcyB0eXBlOiAke3Nlcmllc1R5cGUyfWApO1xuICB9XG4gIGNsb25lRGVmYXVsdEF4ZXMoc2VyaWVzVHlwZTIpIHtcbiAgICBjb25zdCBkZWZhdWx0QXhlcyA9IHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LmRlZmF1bHRBeGVzO1xuICAgIHJldHVybiBkZWZhdWx0QXhlcyA/IHsgYXhlczogZGVlcENsb25lKGRlZmF1bHRBeGVzKSB9IDogbnVsbDtcbiAgfVxuICBzZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyLCB0aGVtZVRlbXBsYXRlKSB7XG4gICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gdGhpcy50aGVtZVRlbXBsYXRlcy5nZXQoc2VyaWVzVHlwZTIpO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMuc2V0KHNlcmllc1R5cGUyLCBtZXJnZURlZmF1bHRzKHRoZW1lVGVtcGxhdGUsIGN1cnJlbnRUZW1wbGF0ZSkpO1xuICB9XG4gIGdldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy50aGVtZVRlbXBsYXRlcy5nZXQoc2VyaWVzVHlwZTIpO1xuICB9XG4gIGdldFBhbGV0dGVGYWN0b3J5KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnBhbGV0dGVGYWN0b3J5O1xuICB9XG4gIGdldFRvb2x0aXBEZWZhdWxzKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnRvb2x0aXBEZWZhdWx0cztcbiAgfVxuICBpc1NvbG8oc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uc29sbyA/PyBmYWxzZTtcbiAgfVxuICBpc0dyb3VwYWJsZShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5ncm91cGFibGUgPz8gZmFsc2U7XG4gIH1cbiAgaXNTdGFja2FibGUoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uc3RhY2thYmxlID8/IGZhbHNlO1xuICB9XG4gIGlzU3RhY2tlZEJ5RGVmYXVsdChzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5zdGFja2VkQnlEZWZhdWx0ID8/IGZhbHNlO1xuICB9XG4gIGlzRGVmYXVsdEF4aXNTd2FwTmVlZGVkKG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIG9wdGlvbnMuc2VyaWVzID8/IFtdKSB7XG4gICAgICBjb25zdCB7IHR5cGUgPSBcImxpbmVcIiB9ID0gc2VyaWVzO1xuICAgICAgY29uc3QgaXNEZWZhdWx0QXhpc1N3YXBwZWQgPSB0aGlzLnNlcmllc01hcC5nZXQodHlwZSk/LnN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvbj8uKHNlcmllcyk7XG4gICAgICBpZiAoaXNEZWZhdWx0QXhpc1N3YXBwZWQgIT0gbnVsbCkge1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgcmVzdWx0ICE9IGlzRGVmYXVsdEF4aXNTd2FwcGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gVGhlIHByb3ZpZGVkIHNlcmllcyBoYXZlIGluY29tcGF0aWJsZSBkaXJlY3Rpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGlzRGVmYXVsdEF4aXNTd2FwcGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIHNlcmllc1JlZ2lzdHJ5ID0gbmV3IFNlcmllc1JlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3N5bmNNYW5hZ2VyLnRzXG52YXIgX1N5bmNNYW5hZ2VyID0gY2xhc3MgX1N5bmNNYW5hZ2VyIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICB9XG4gIHN1YnNjcmliZShncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICBsZXQgc3luY0dyb3VwID0gdGhpcy5nZXQoZ3JvdXBJZCk7XG4gICAgaWYgKCFzeW5jR3JvdXApIHtcbiAgICAgIHN5bmNHcm91cCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBfU3luY01hbmFnZXIuY2hhcnRzR3JvdXBzLnNldChncm91cElkLCBzeW5jR3JvdXApO1xuICAgIH1cbiAgICBzeW5jR3JvdXAuYWRkKHRoaXMuY2hhcnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVuc3Vic2NyaWJlKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIHRoaXMuZ2V0KGdyb3VwSWQpPy5kZWxldGUodGhpcy5jaGFydCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0Q2hhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQ7XG4gIH1cbiAgZ2V0R3JvdXAoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgY29uc3Qgc3luY0dyb3VwID0gdGhpcy5nZXQoZ3JvdXBJZCk7XG4gICAgcmV0dXJuIHN5bmNHcm91cCA/IEFycmF5LmZyb20oc3luY0dyb3VwKSA6IFtdO1xuICB9XG4gIGdldEdyb3VwU2libGluZ3MoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R3JvdXAoZ3JvdXBJZCkuZmlsdGVyKChjaGFydCkgPT4gY2hhcnQgIT09IHRoaXMuY2hhcnQpO1xuICB9XG4gIGdldChncm91cElkKSB7XG4gICAgcmV0dXJuIF9TeW5jTWFuYWdlci5jaGFydHNHcm91cHMuZ2V0KGdyb3VwSWQpO1xuICB9XG59O1xuX1N5bmNNYW5hZ2VyLmNoYXJ0c0dyb3VwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5fU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCA9IFN5bWJvbChcInN5bmMtZ3JvdXAtZGVmYXVsdFwiKTtcbnZhciBTeW5jTWFuYWdlciA9IF9TeW5jTWFuYWdlcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vem9vbU1hbmFnZXIudHNcbnZhciBab29tTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIodm9pZCAwLCBcImluaXRpYWxcIik7XG4gICAgdGhpcy5yZWplY3RDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHVwZGF0ZUF4ZXMoYXhlcykge1xuICAgIGNvbnN0IHpvb21NYW5hZ2VycyA9IG5ldyBNYXAoYXhlcy5tYXAoKGF4aXMpID0+IFtheGlzLmlkLCB0aGlzLmF4aXNab29tTWFuYWdlcnMuZ2V0KGF4aXMuaWQpXSkpO1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuc2V0KGF4aXMuaWQsIHpvb21NYW5hZ2Vycy5nZXQoYXhpcy5pZCkgPz8gbmV3IEF4aXNab29tTWFuYWdlcihheGlzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnNpemUgPiAwICYmIGF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy51cGRhdGVab29tKHRoaXMuc3RhdGUuc3RhdGVJZCgpLCB0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVpvb20oY2FsbGVySWQsIG5ld1pvb20sIGNhbkNoYW5nZUluaXRpYWwgPSB0cnVlLCByZWplY3RDYWxsYmFjaykge1xuICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZWplY3RDYWxsYmFja3Muc2V0KGNhbGxlcklkLCByZWplY3RDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNab29tTWFuYWdlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgY29uc3Qgc3RhdGVJZCA9IHRoaXMuc3RhdGUuc3RhdGVJZCgpO1xuICAgICAgaWYgKHN0YXRlSWQgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXRlSWQgPT09IGNhbGxlcklkIHx8IGNhbkNoYW5nZUluaXRpYWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXQoY2FsbGVySWQsIG5ld1pvb20pO1xuICAgICAgICBpZiAoc3RhdGVJZCAhPT0gY2FsbGVySWQpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdENhbGxiYWNrcy5nZXQoc3RhdGVJZCk/LihjYWxsZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdENhbGxiYWNrPy4oc3RhdGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy51cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tPy5bYXhpcy5nZXREaXJlY3Rpb24oKV0pO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlDaGFuZ2VzKGNhbGxlcklkKTtcbiAgfVxuICB1cGRhdGVBeGlzWm9vbShjYWxsZXJJZCwgYXhpc0lkLCBuZXdab29tKSB7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzSWQpPy51cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tKTtcbiAgICB0aGlzLmFwcGx5Q2hhbmdlcyhjYWxsZXJJZCk7XG4gIH1cbiAgLy8gRmlyZSB0aGlzIGV2ZW50IHRvIHNpZ25hbCB0byBsaXN0ZW5lcnMgdGhhdCB0aGUgdmlldyBpcyBjaGFuZ2luZyB0aHJvdWdoIGEgem9vbSBhbmQvb3IgcGFuIGNoYW5nZS5cbiAgZmlyZVpvb21QYW5TdGFydEV2ZW50KGNhbGxlcklkKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJ6b29tLXBhbi1zdGFydFwiLCB7IHR5cGU6IFwiem9vbS1wYW4tc3RhcnRcIiwgY2FsbGVySWQgfSk7XG4gIH1cbiAgZ2V0Wm9vbSgpIHtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgaWYgKGF4aXMuZ2V0RGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgeCA/PyAoeCA9IGF4aXMuZ2V0Wm9vbSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcy5nZXREaXJlY3Rpb24oKSA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgICAgICB5ID8/ICh5ID0gYXhpcy5nZXRab29tKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gIH1cbiAgZ2V0QXhpc1pvb20oYXhpc0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpc0lkKT8uZ2V0Wm9vbSgpID8/IHsgbWluOiAwLCBtYXg6IDEgfTtcbiAgfVxuICBnZXRBeGlzWm9vbXMoKSB7XG4gICAgY29uc3QgYXhlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2F4aXNJZCwgYXhpc10gb2YgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmVudHJpZXMoKSkge1xuICAgICAgYXhlc1theGlzSWRdID0ge1xuICAgICAgICBkaXJlY3Rpb246IGF4aXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgIHpvb206IGF4aXMuZ2V0Wm9vbSgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYXhlcztcbiAgfVxuICBhcHBseUNoYW5nZXMoY2FsbGVySWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gQXJyYXkuZnJvbSh0aGlzLmF4aXNab29tTWFuYWdlcnMudmFsdWVzKCksIChheGlzKSA9PiBheGlzLmFwcGx5Q2hhbmdlcygpKS5zb21lKEJvb2xlYW4pO1xuICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheGVzID0ge307XG4gICAgZm9yIChjb25zdCBbYXhpc0lkLCBheGlzXSBvZiB0aGlzLmF4aXNab29tTWFuYWdlcnMuZW50cmllcygpKSB7XG4gICAgICBheGVzW2F4aXNJZF0gPSBheGlzLmdldFpvb20oKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJ6b29tLWNoYW5nZVwiLCB7IHR5cGU6IFwiem9vbS1jaGFuZ2VcIiwgLi4udGhpcy5nZXRab29tKCksIGF4ZXMsIGNhbGxlcklkIH0pO1xuICB9XG59O1xudmFyIEF4aXNab29tTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXhpcykge1xuICAgIHRoaXMuYXhpcyA9IGF4aXM7XG4gICAgY29uc3QgW21pbiA9IDAsIG1heCA9IDFdID0gYXhpcy52aXNpYmxlUmFuZ2U7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIoeyBtaW4sIG1heCB9KTtcbiAgICB0aGlzLmN1cnJlbnRab29tID0gdGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCk7XG4gIH1cbiAgZ2V0RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF4aXMuZGlyZWN0aW9uO1xuICB9XG4gIHVwZGF0ZVpvb20oY2FsbGVySWQsIG5ld1pvb20pIHtcbiAgICB0aGlzLnN0YXRlLnNldChjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gIH1cbiAgZ2V0Wm9vbSgpIHtcbiAgICByZXR1cm4gZGVlcENsb25lKHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpKTtcbiAgfVxuICBhcHBseUNoYW5nZXMoKSB7XG4gICAgY29uc3QgcHJldlpvb20gPSB0aGlzLmN1cnJlbnRab29tO1xuICAgIHRoaXMuY3VycmVudFpvb20gPSB0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKTtcbiAgICByZXR1cm4gcHJldlpvb20ubWluICE9PSB0aGlzLmN1cnJlbnRab29tLm1pbiB8fCBwcmV2Wm9vbS5tYXggIT09IHRoaXMuY3VycmVudFpvb20ubWF4O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9rZXlib2FyZC50c1xudmFyIEtleWJvYXJkID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgS2V5Ym9hcmQucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBLZXlib2FyZC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvcHJlcGFyZUF4aXMudHNcbnZhciBDYXJ0ZXNpYW5BeGlzUG9zaXRpb25zID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xuZnVuY3Rpb24gaXNBeGlzUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJzdHJpbmdcIiAmJiBDYXJ0ZXNpYW5BeGlzUG9zaXRpb25zLmluY2x1ZGVzKHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGd1ZXNzSW52YWxpZFBvc2l0aW9ucyhheGVzKSB7XG4gIGNvbnN0IGludmFsaWRBeGVzID0gW107XG4gIGNvbnN0IHVzZWRQb3NpdGlvbnMgPSBbXTtcbiAgY29uc3QgZ3Vlc3NlcyA9IFsuLi5DYXJ0ZXNpYW5BeGlzUG9zaXRpb25zXTtcbiAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICBpZiAoYXhpcyBpbnN0YW5jZW9mIENhcnRlc2lhbkF4aXMpIHtcbiAgICAgIGlmIChpc0F4aXNQb3NpdGlvbihheGlzLnBvc2l0aW9uKSkge1xuICAgICAgICB1c2VkUG9zaXRpb25zLnB1c2goYXhpcy5wb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkQXhlcy5wdXNoKGF4aXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF4aXMgb2YgaW52YWxpZEF4ZXMpIHtcbiAgICBsZXQgbmV4dEd1ZXNzO1xuICAgIGRvIHtcbiAgICAgIG5leHRHdWVzcyA9IGd1ZXNzZXMucG9wKCk7XG4gICAgfSB3aGlsZSAobmV4dEd1ZXNzICYmIHVzZWRQb3NpdGlvbnMuaW5jbHVkZXMobmV4dEd1ZXNzKSk7XG4gICAgaWYgKG5leHRHdWVzcyA9PSBudWxsKVxuICAgICAgYnJlYWs7XG4gICAgYXhpcy5wb3NpdGlvbiA9IG5leHRHdWVzcztcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXBwaW5nL3ByZXBhcmVTZXJpZXMudHNcbnZhciBNQVRDSElOR19LRVlTID0gW1wiZGlyZWN0aW9uXCIsIFwieEtleVwiLCBcInlLZXlcIiwgXCJzaXplS2V5XCIsIFwiYW5nbGVLZXlcIiwgXCJyYWRpdXNLZXlcIiwgXCJub3JtYWxpemVkVG9cIl07XG5mdW5jdGlvbiBtYXRjaFNlcmllc09wdGlvbnMoc2VyaWVzLCBvcHRTZXJpZXMsIG9sZE9wdHNTZXJpZXMpIHtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodHlwZSwgaSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFt0eXBlXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBNQVRDSElOR19LRVlTKSB7XG4gICAgICBpZiAoa2V5IGluIGkgJiYgaVtrZXldICE9IG51bGwpXG4gICAgICAgIHJlc3VsdC5wdXNoKGAke2tleX09JHtpW2tleV19YCk7XG4gICAgfVxuICAgIGlmIChvcHRzPy5zZXJpZXNHcm91cGluZykge1xuICAgICAgcmVzdWx0LnB1c2goYHNlcmllc0dyb3VwaW5nLmdyb3VwSWQ9JHtvcHRzPy5zZXJpZXNHcm91cGluZy5ncm91cElkfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCI7XCIpO1xuICB9O1xuICBjb25zdCBzZXJpZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIChjb25zdCBzIG9mIHNlcmllcykge1xuICAgIGNvbnN0IGtleSA9IGdlbmVyYXRlS2V5KHMudHlwZSwgcy5wcm9wZXJ0aWVzLCBvbGRPcHRzU2VyaWVzPy5baWR4XSk7XG4gICAgaWYgKCFzZXJpZXNNYXAuaGFzKGtleSkpIHtcbiAgICAgIHNlcmllc01hcC5zZXQoa2V5LCBbXSk7XG4gICAgfVxuICAgIHNlcmllc01hcC5nZXQoa2V5KT8ucHVzaChbcywgaWR4KytdKTtcbiAgfVxuICBjb25zdCBvcHRzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBvIG9mIG9wdFNlcmllcykge1xuICAgIGNvbnN0IGtleSA9IGdlbmVyYXRlS2V5KG8udHlwZSwgbywgbyk7XG4gICAgaWYgKCFvcHRzTWFwLmhhcyhrZXkpKSB7XG4gICAgICBvcHRzTWFwLnNldChrZXksIFtdKTtcbiAgICB9XG4gICAgb3B0c01hcC5nZXQoa2V5KT8ucHVzaChvKTtcbiAgfVxuICBjb25zdCBvdmVybGFwID0gWy4uLnNlcmllc01hcC5rZXlzKCldLnNvbWUoKGspID0+IG9wdHNNYXAuaGFzKGspKTtcbiAgaWYgKCFvdmVybGFwKSB7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcIm5vLW92ZXJsYXBcIiwgb2xkS2V5czogc2VyaWVzTWFwLmtleXMoKSwgbmV3S2V5czogb3B0c01hcC5rZXlzKCkgfTtcbiAgfVxuICBjb25zdCBjaGFuZ2VzID0gW107XG4gIGxldCB0YXJnZXRJZHggPSAtMTtcbiAgZm9yIChjb25zdCBba2V5LCBvcHRBcnJheV0gb2Ygb3B0c01hcC5lbnRyaWVzKCkpIHtcbiAgICBmb3IgKGNvbnN0IG9wdHMgb2Ygb3B0QXJyYXkpIHtcbiAgICAgIHRhcmdldElkeCsrO1xuICAgICAgY29uc3Qgc2VyaWVzQXJyYXkgPSBzZXJpZXNNYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoc2VyaWVzQXJyYXkgPT0gbnVsbCB8fCBzZXJpZXNBcnJheS5sZW5ndGggPCAxKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIGlkeDogdGFyZ2V0SWR4LCBzdGF0dXM6IFwiYWRkXCIgfSk7XG4gICAgICAgIHNlcmllc01hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBbb3V0cHV0U2VyaWVzLCBvdXRwdXRJZHhdID0gc2VyaWVzQXJyYXkuc2hpZnQoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzT3B0cyA9IG9sZE9wdHNTZXJpZXM/LltvdXRwdXRJZHhdID8/IHt9O1xuICAgICAgY29uc3QgZGlmZjIgPSBqc29uRGlmZihwcmV2aW91c09wdHMsIG9wdHMgPz8ge30pO1xuICAgICAgY29uc3QgeyBncm91cEluZGV4LCBzdGFja0luZGV4IH0gPSBkaWZmMj8uc2VyaWVzR3JvdXBpbmcgPz8ge307XG4gICAgICBpZiAoZ3JvdXBJbmRleCAhPSBudWxsIHx8IHN0YWNrSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcHRzLCBzZXJpZXM6IG91dHB1dFNlcmllcywgZGlmZjogZGlmZjIsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwic2VyaWVzLWdyb3VwaW5nXCIgfSk7XG4gICAgICB9IGVsc2UgaWYgKGRpZmYyKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHNlcmllczogb3V0cHV0U2VyaWVzLCBkaWZmOiBkaWZmMiwgaWR4OiBvdXRwdXRJZHgsIHN0YXR1czogXCJ1cGRhdGVcIiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHNlcmllczogb3V0cHV0U2VyaWVzLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcIm5vLW9wXCIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWVzQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlcmllc01hcC5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzZXJpZXNBcnJheSBvZiBzZXJpZXNNYXAudmFsdWVzKCkpIHtcbiAgICBmb3IgKGNvbnN0IFtvdXRwdXRTZXJpZXMsIG91dHB1dElkeF0gb2Ygc2VyaWVzQXJyYXkpIHtcbiAgICAgIGNoYW5nZXMucHVzaCh7IHNlcmllczogb3V0cHV0U2VyaWVzLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcInJlbW92ZVwiIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdGF0dXM6IFwib3ZlcmxhcFwiLCBjaGFuZ2VzIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvdHlwZXMudHNcbmZ1bmN0aW9uIG9wdGlvbnNUeXBlKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5zZXJpZXM/LlswXT8udHlwZSA/PyBcImxpbmVcIjtcbn1cbmZ1bmN0aW9uIGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcImNhcnRlc2lhblwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNDYXJ0ZXNpYW4oc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlQ2FydGVzaWFuKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwicG9sYXJcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzUG9sYXIoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlUG9sYXIoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwiaGllcmFyY2h5XCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc0hpZXJhcmNoeShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VIaWVyYXJjaHkoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJ0b3BvbG9neVwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNUb3BvbG9neShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VUb3BvbG9neShzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcImZsb3ctcHJvcG9ydGlvblwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNGbG93UHJvcG9ydGlvbihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VGbG93UHJvcG9ydGlvbihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdQb2xhckNoYXJ0T3B0aW9uc1dpdGhTZXJpZXNCYXNlZExlZ2VuZChpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICByZXR1cm4gaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKGlucHV0KSAmJiBzcGVjaWZpZWRUeXBlICE9PSBcInBpZVwiICYmIHNwZWNpZmllZFR5cGUgIT09IFwiZG9udXRcIjtcbn1cbmZ1bmN0aW9uIGlzU2VyaWVzT3B0aW9uVHlwZShpbnB1dCkge1xuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5oYXMoaW5wdXQpO1xufVxuZnVuY3Rpb24gaXNBeGlzT3B0aW9uVHlwZShpbnB1dCkge1xuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gYXhpc1JlZ2lzdHJ5LmhhcyhpbnB1dCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21vZHVsZXNNYW5hZ2VyLnRzXG52YXIgTW9kdWxlc01hbmFnZXIgPSBjbGFzcyBleHRlbmRzIE1vZHVsZU1hcCB7XG4gIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBtIG9mIHRoaXMubW9kdWxlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAobS5tb2R1bGUub3B0aW9uc0tleSBpbiBvcHRpb25zICYmIGlzUHJvcGVydGllcyhtLm1vZHVsZUluc3RhbmNlKSkge1xuICAgICAgICBtLm1vZHVsZUluc3RhbmNlLnNldChvcHRpb25zW20ubW9kdWxlLm9wdGlvbnNLZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKmxlZ2VuZHMoKSB7XG4gICAgZm9yIChjb25zdCB7IG1vZHVsZSwgbW9kdWxlSW5zdGFuY2UgfSBvZiB0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKG1vZHVsZS50eXBlICE9PSBcImxlZ2VuZFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgbGVnZW5kVHlwZTogbW9kdWxlLmlkZW50aWZpZXIsXG4gICAgICAgIGxlZ2VuZDogbW9kdWxlSW5zdGFuY2VcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9vdmVybGF5L292ZXJsYXkudHNcbnZhciBERUZBVUxUX09WRVJMQVlfQ0xBU1MgPSBcImFnLWNoYXJ0LW92ZXJsYXlcIjtcbnZhciBERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyA9IFwiYWctY2hhcnQtZGFyay1vdmVybGF5XCI7XG52YXIgT3ZlcmxheSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIGRlZmF1bHRNZXNzYWdlSWQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIHRoaXMuZGVmYXVsdE1lc3NhZ2VJZCA9IGRlZmF1bHRNZXNzYWdlSWQ7XG4gIH1cbiAgZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGxvY2FsZU1hbmFnZXIudCh0aGlzLnRleHQgPz8gdGhpcy5kZWZhdWx0TWVzc2FnZUlkKTtcbiAgfVxuICBnZXRFbGVtZW50KGFuaW1hdGlvbk1hbmFnZXIsIGxvY2FsZU1hbmFnZXIsIHJlY3QpIHtcbiAgICB0aGlzLmNvbnRlbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuZm9jdXNCb3ggPSByZWN0O1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBjb25zdCBodG1sQ29udGVudCA9IHRoaXMucmVuZGVyZXIoKTtcbiAgICAgIGlmIChodG1sQ29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGh0bWxDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcERpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gaHRtbENvbnRlbnQ7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRlbXBEaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBtYXJnaW46IFwiOHB4XCIsXG4gICAgICAgIGZvbnQ6IFwiMTJweCBWZXJkYW5hLCBzYW5zLXNlcmlmXCJcbiAgICAgIH0pO1xuICAgICAgY29udGVudC5pbm5lclRleHQgPSB0aGlzLmdldFRleHQobG9jYWxlTWFuYWdlcik7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgYW5pbWF0aW9uTWFuYWdlcj8uYW5pbWF0ZSh7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAxLFxuICAgICAgICBpZDogXCJvdmVybGF5XCIsXG4gICAgICAgIHBoYXNlOiBcImFkZFwiLFxuICAgICAgICBncm91cElkOiBcIm9wYWNpdHlcIixcbiAgICAgICAgb25VcGRhdGUodmFsdWUpIHtcbiAgICAgICAgICBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0b3AoKSB7XG4gICAgICAgICAgY29udGVudC5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG4gIHJlbW92ZUVsZW1lbnQoY2xlYW51cCA9ICgpID0+IHRoaXMuY29udGVudD8ucmVtb3ZlKCksIGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoYW5pbWF0aW9uTWFuYWdlcikge1xuICAgICAgY29uc3QgeyBjb250ZW50IH0gPSB0aGlzO1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgICAgZnJvbTogMSxcbiAgICAgICAgdG86IDAsXG4gICAgICAgIHBoYXNlOiBcInJlbW92ZVwiLFxuICAgICAgICBpZDogXCJvdmVybGF5XCIsXG4gICAgICAgIGdyb3VwSWQ6IFwib3BhY2l0eVwiLFxuICAgICAgICBvblVwZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgICBjbGVhbnVwPy4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFudXA/LigpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb2N1c0JveCA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT3ZlcmxheS5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBPdmVybGF5LnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvb3ZlcmxheS9jaGFydE92ZXJsYXlzLnRzXG52YXIgQ2hhcnRPdmVybGF5cyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZGFya1RoZW1lID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkaW5nID0gbmV3IE92ZXJsYXkoXCJhZy1jaGFydC1sb2FkaW5nLW92ZXJsYXlcIiwgXCJvdmVybGF5TG9hZGluZ0RhdGFcIik7XG4gICAgdGhpcy5ub0RhdGEgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0LW5vLWRhdGEtb3ZlcmxheVwiLCBcIm92ZXJsYXlOb0RhdGFcIik7XG4gICAgdGhpcy5ub1Zpc2libGVTZXJpZXMgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0LW5vLXZpc2libGUtc2VyaWVzXCIsIFwib3ZlcmxheU5vVmlzaWJsZVNlcmllc1wiKTtcbiAgfVxuICBnZXRGb2N1c0luZm8obG9jYWxlTWFuYWdlcikge1xuICAgIGZvciAoY29uc3Qgb3ZlcmxheSBvZiBbdGhpcy5sb2FkaW5nLCB0aGlzLm5vRGF0YSwgdGhpcy5ub1Zpc2libGVTZXJpZXNdKSB7XG4gICAgICBpZiAob3ZlcmxheS5mb2N1c0JveCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG92ZXJsYXkuZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKSwgcmVjdDogb3ZlcmxheS5mb2N1c0JveCB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5sb2FkaW5nLnJlbW92ZUVsZW1lbnQoKTtcbiAgICB0aGlzLm5vRGF0YS5yZW1vdmVFbGVtZW50KCk7XG4gICAgdGhpcy5ub1Zpc2libGVTZXJpZXMucmVtb3ZlRWxlbWVudCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcImRhcmtUaGVtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcImxvYWRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJub0RhdGFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJub1Zpc2libGVTZXJpZXNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvbG9hZGluZ1NwaW5uZXIudHNcbmZ1bmN0aW9uIGdldExvYWRpbmdTcGlubmVyKHRleHQsIGRlZmF1bHREdXJhdGlvbikge1xuICBjb25zdCB7IGFuaW1hdGlvbkR1cmF0aW9uIH0gPSBQSEFTRV9NRVRBREFUQVtcImFkZFwiXTtcbiAgY29uc3QgZHVyYXRpb24gPSBhbmltYXRpb25EdXJhdGlvbiAqIGRlZmF1bHREdXJhdGlvbjtcbiAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBgJHtERUZBVUxUX09WRVJMQVlfQ0xBU1N9LS1sb2FkaW5nYCwge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgZm9udDogXCIxM3B4IFZlcmRhbmEsIHNhbnMtc2VyaWZcIixcbiAgICAvLyBGT05UX1NJWkUuTUVESVVNXG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgYW5pbWF0aW9uOiBgYWctY2hhcnRzLWxvYWRpbmcgJHtkdXJhdGlvbn1tcyBsaW5lYXIgNTBtcyBib3RoYFxuICB9KTtcbiAgY29uc3QgbWF0cml4ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHdpZHRoOiBcIjQ1cHhcIixcbiAgICBoZWlnaHQ6IFwiNDBweFwiLFxuICAgIGJhY2tncm91bmRJbWFnZTogW1xuICAgICAgXCJsaW5lYXItZ3JhZGllbnQoIzAwMDAgY2FsYygxICogMTAwJSAvIDYpLCAjY2NjIDAgY2FsYygzICogMTAwJSAvIDYpLCAjMDAwMCAwKSwgXCIsXG4gICAgICBcImxpbmVhci1ncmFkaWVudCgjMDAwMCBjYWxjKDIgKiAxMDAlIC8gNiksICNjY2MgMCBjYWxjKDQgKiAxMDAlIC8gNiksICMwMDAwIDApLCBcIixcbiAgICAgIFwibGluZWFyLWdyYWRpZW50KCMwMDAwIGNhbGMoMyAqIDEwMCUgLyA2KSwgI2NjYyAwIGNhbGMoNSAqIDEwMCUgLyA2KSwgIzAwMDAgMClcIlxuICAgIF0uam9pbihcIlwiKSxcbiAgICBiYWNrZ3JvdW5kU2l6ZTogXCIxMHB4IDQwMCVcIixcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgIGFuaW1hdGlvbjogXCJhZy1jaGFydHMtbG9hZGluZy1tYXRyaXggMXMgaW5maW5pdGUgbGluZWFyXCJcbiAgfSk7XG4gIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudChcInBcIiwgeyBtYXJnaW5Ub3A6IFwiMWVtXCIgfSk7XG4gIGxhYmVsLmlubmVyVGV4dCA9IHRleHQ7XG4gIGNvbnN0IGJhY2tncm91bmQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIGAke0RFRkFVTFRfT1ZFUkxBWV9DTEFTU31fX2xvYWRpbmctYmFja2dyb3VuZGAsIHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGluc2V0OiBcIjBcIixcbiAgICBvcGFjaXR5OiBcIjAuNVwiLFxuICAgIHpJbmRleDogXCItMVwiXG4gIH0pO1xuICBjb25zdCBhbmltYXRpb25TdHlsZXMgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIGFuaW1hdGlvblN0eWxlcy5pbm5lclRleHQgPSBbXG4gICAgXCJAa2V5ZnJhbWVzIGFnLWNoYXJ0cy1sb2FkaW5nIHsgZnJvbSB7IG9wYWNpdHk6IDAgfSB0byB7IG9wYWNpdHk6IDEgfSB9XCIsXG4gICAgXCJAa2V5ZnJhbWVzIGFnLWNoYXJ0cy1sb2FkaW5nLW1hdHJpeCB7XCIsXG4gICAgXCIwJSB7IGJhY2tncm91bmQtcG9zaXRpb246IDAlIDAlLCA1MCUgMCUsIDEwMCUgMCU7IH1cIixcbiAgICBcIjEwMCUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSAxMDAlLCA1MCUgMTAwJSwgMTAwJSAxMDAlOyB9XCIsXG4gICAgXCJ9XCJcbiAgXS5qb2luKFwiIFwiKTtcbiAgY29udGFpbmVyLnJlcGxhY2VDaGlsZHJlbihhbmltYXRpb25TdHlsZXMsIG1hdHJpeCwgbGFiZWwsIGJhY2tncm91bmQpO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2FnZ3JlZ2F0ZUZ1bmN0aW9ucy50c1xuZnVuY3Rpb24gc3VtVmFsdWVzKHZhbHVlcywgYWNjdW11bGF0b3IgPSBbMCwgMF0pIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgYWNjdW11bGF0b3JbMF0gKz0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgIGFjY3VtdWxhdG9yWzFdICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5mdW5jdGlvbiBzdW0oaWQsIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcylcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwU3VtKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKSxcbiAgICBncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uOiAobmV4dCwgYWNjID0gWzAsIDBdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlMihpZCwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbih2YWx1ZXMpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cENvdW50KGlkKSB7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKCkgPT4gWzAsIDFdLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ3JvdXBBdmVyYWdlKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgZGVmID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMCwgLTFdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICBhY2NbMl0rKztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBmaW5hbEZ1bmN0aW9uOiAoYWNjID0gWzAsIDAsIDBdKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY2NbMF0gKyBhY2NbMV07XG4gICAgICBpZiAocmVzdWx0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCByZXN1bHQgLyBhY2NbMl1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXN1bHQgLyBhY2NbMl0sIDBdO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGFyZWEoaWQsIGFnZ0ZuLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMsIGtleVJhbmdlID0gW10pID0+IHtcbiAgICAgIGNvbnN0IGtleVdpZHRoID0ga2V5UmFuZ2VbMV0gLSBrZXlSYW5nZVswXTtcbiAgICAgIHJldHVybiBhZ2dGbi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXMpLm1hcCgodikgPT4gdiAvIGtleVdpZHRoKTtcbiAgICB9XG4gIH07XG4gIGlmIChhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uKSB7XG4gICAgcmVzdWx0Lmdyb3VwQWdncmVnYXRlRnVuY3Rpb24gPSBhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgfVxuICAgICAgdmFsdWUgKz0gb25seVBvc2l0aXZlID8gTWF0aC5tYXgoMCwgZGF0dW0pIDogZGF0dW07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZGF0dW0pKSB7XG4gICAgICAgIHJldHVybiBkYXR1bTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWlsaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHZhbHVlICs9IGRhdHVtO1xuICAgICAgcmV0dXJuIHRyYWlsaW5nVmFsdWU7XG4gICAgfTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9tZW1vLnRzXG52YXIgbWVtb3JpemVkRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtZW1vKHBhcmFtcywgZm5HZW5lcmF0b3IpIHtcbiAgY29uc3Qgc2VyaWFsaXNlZFBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgMCk7XG4gIGlmICghbWVtb3JpemVkRm5zLmhhcyhmbkdlbmVyYXRvcikpIHtcbiAgICBtZW1vcml6ZWRGbnMuc2V0KGZuR2VuZXJhdG9yLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBpZiAoIW1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5oYXMoc2VyaWFsaXNlZFBhcmFtcykpIHtcbiAgICBtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uc2V0KHNlcmlhbGlzZWRQYXJhbXMsIGZuR2VuZXJhdG9yKHBhcmFtcykpO1xuICB9XG4gIHJldHVybiBtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL3Byb2Nlc3NvcnMudHNcbnZhciBTTUFMTEVTVF9LRVlfSU5URVJWQUwgPSB7XG4gIHR5cGU6IFwicmVkdWNlclwiLFxuICBwcm9wZXJ0eTogXCJzbWFsbGVzdEtleUludGVydmFsXCIsXG4gIGluaXRpYWxWYWx1ZTogSW5maW5pdHksXG4gIHJlZHVjZXI6ICgpID0+IHtcbiAgICBsZXQgcHJldlggPSBOYU47XG4gICAgcmV0dXJuIChzbWFsbGVzdFNvRmFyID0gSW5maW5pdHksIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IG5leHRYID0gbmV4dC5rZXlzWzBdO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLmFicyhuZXh0WCAtIHByZXZYKTtcbiAgICAgIHByZXZYID0gbmV4dFg7XG4gICAgICBpZiAoIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgaW50ZXJ2YWwgPCBzbWFsbGVzdFNvRmFyKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbWFsbGVzdFNvRmFyO1xuICAgIH07XG4gIH1cbn07XG52YXIgTEFSR0VTVF9LRVlfSU5URVJWQUwgPSB7XG4gIHR5cGU6IFwicmVkdWNlclwiLFxuICBwcm9wZXJ0eTogXCJsYXJnZXN0S2V5SW50ZXJ2YWxcIixcbiAgaW5pdGlhbFZhbHVlOiAtSW5maW5pdHksXG4gIHJlZHVjZXI6ICgpID0+IHtcbiAgICBsZXQgcHJldlggPSBOYU47XG4gICAgcmV0dXJuIChsYXJnZXN0U29GYXIgPSAtSW5maW5pdHksIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IG5leHRYID0gbmV4dC5rZXlzWzBdO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLmFicyhuZXh0WCAtIHByZXZYKTtcbiAgICAgIHByZXZYID0gbmV4dFg7XG4gICAgICBpZiAoIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgaW50ZXJ2YWwgPiBsYXJnZXN0U29GYXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhcmdlc3RTb0ZhcjtcbiAgICB9O1xuICB9XG59O1xudmFyIFNPUlRfRE9NQUlOX0dST1VQUyA9IHtcbiAgdHlwZTogXCJwcm9jZXNzb3JcIixcbiAgcHJvcGVydHk6IFwic29ydGVkR3JvdXBEb21haW5cIixcbiAgY2FsY3VsYXRlOiAoeyBkb21haW46IHsgZ3JvdXBzIH0gfSkgPT4gZ3JvdXBzPy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFbaV0gLSBiW2ldO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSlcbn07XG5mdW5jdGlvbiBub3JtYWxpc2VGbkJ1aWxkZXIoeyBub3JtYWxpc2VUbywgbW9kZSB9KSB7XG4gIGNvbnN0IG5vcm1hbGlzZSA9ICh2YWwsIGV4dGVudDIpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWwgKiBub3JtYWxpc2VUbyAvIGV4dGVudDI7XG4gICAgaWYgKHJlc3VsdCA+PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obm9ybWFsaXNlVG8sIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgtbm9ybWFsaXNlVG8sIHJlc3VsdCk7XG4gIH07XG4gIHJldHVybiAoKSA9PiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICBjb25zdCB2YWx1ZXNFeHRlbnQgPSBbMCwgMF07XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgIGNvbnN0IHZhbHVlRXh0ZW50ID0gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiBNYXRoLm1heCguLi52YWx1ZSk7XG4gICAgICBjb25zdCB2YWxJZHggPSB2YWx1ZUV4dGVudCA8IDAgPyAwIDogMTtcbiAgICAgIGlmIChtb2RlID09PSBcInN1bVwiKSB7XG4gICAgICAgIHZhbHVlc0V4dGVudFt2YWxJZHhdICs9IHZhbHVlRXh0ZW50O1xuICAgICAgfSBlbHNlIGlmICh2YWxJZHggPT09IDApIHtcbiAgICAgICAgdmFsdWVzRXh0ZW50W3ZhbElkeF0gPSBNYXRoLm1pbih2YWx1ZXNFeHRlbnRbdmFsSWR4XSwgdmFsdWVFeHRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzRXh0ZW50W3ZhbElkeF0gPSBNYXRoLm1heCh2YWx1ZXNFeHRlbnRbdmFsSWR4XSwgdmFsdWVFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRlbnQyID0gTWF0aC5tYXgoTWF0aC5hYnModmFsdWVzRXh0ZW50WzBdKSwgdmFsdWVzRXh0ZW50WzFdKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IG5vcm1hbGlzZSh2YWx1ZSwgZXh0ZW50MikgOiB2YWx1ZS5tYXAoKHYpID0+IG5vcm1hbGlzZSh2LCBleHRlbnQyKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlR3JvdXBUbyhtYXRjaEdyb3VwSWRzLCBub3JtYWxpc2VUbywgbW9kZSA9IFwic3VtXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIG1hdGNoR3JvdXBJZHMsXG4gICAgYWRqdXN0OiBtZW1vKHsgbm9ybWFsaXNlVG8sIG1vZGUgfSwgbm9ybWFsaXNlRm5CdWlsZGVyKVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlUHJvcGVydHlGbkJ1aWxkZXIoe1xuICBub3JtYWxpc2VUbyxcbiAgemVyb0RvbWFpbixcbiAgcmFuZ2VNaW4sXG4gIHJhbmdlTWF4XG59KSB7XG4gIGNvbnN0IG5vcm1hbGlzZVNwYW4gPSBub3JtYWxpc2VUb1sxXSAtIG5vcm1hbGlzZVRvWzBdO1xuICBjb25zdCBub3JtYWxpc2UgPSAodmFsLCBzdGFydCwgc3BhbikgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5vcm1hbGlzZVRvWzBdICsgKHZhbCAtIHN0YXJ0KSAvIHNwYW4gKiBub3JtYWxpc2VTcGFuO1xuICAgIGlmIChzcGFuID09PSAwKSB7XG4gICAgICByZXR1cm4gemVyb0RvbWFpbjtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA+PSBub3JtYWxpc2VUb1sxXSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGlzZVRvWzFdO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0IDwgbm9ybWFsaXNlVG9bMF0pIHtcbiAgICAgIHJldHVybiBub3JtYWxpc2VUb1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICgpID0+IChwRGF0YSwgcElkeCkgPT4ge1xuICAgIGxldCBbc3RhcnQsIGVuZF0gPSBwRGF0YS5kb21haW4udmFsdWVzW3BJZHhdO1xuICAgIGlmIChyYW5nZU1pbiAhPSBudWxsKVxuICAgICAgc3RhcnQgPSByYW5nZU1pbjtcbiAgICBpZiAocmFuZ2VNYXggIT0gbnVsbClcbiAgICAgIGVuZCA9IHJhbmdlTWF4O1xuICAgIGNvbnN0IHNwYW4gPSBlbmQgLSBzdGFydDtcbiAgICBwRGF0YS5kb21haW4udmFsdWVzW3BJZHhdID0gW25vcm1hbGlzZVRvWzBdLCBub3JtYWxpc2VUb1sxXV07XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBwRGF0YS5kYXRhKSB7XG4gICAgICBsZXQgZ3JvdXBWYWx1ZXMgPSBncm91cC52YWx1ZXM7XG4gICAgICBpZiAocERhdGEudHlwZSA9PT0gXCJ1bmdyb3VwZWRcIikge1xuICAgICAgICBncm91cFZhbHVlcyA9IFtncm91cFZhbHVlc107XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cFZhbHVlcykge1xuICAgICAgICB2YWx1ZXNbcElkeF0gPSBub3JtYWxpc2UodmFsdWVzW3BJZHhdLCBzdGFydCwgc3Bhbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlUHJvcGVydHlUbyhwcm9wZXJ0eSwgbm9ybWFsaXNlVG8sIHplcm9Eb21haW4sIHJhbmdlTWluLCByYW5nZU1heCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvcGVydHktdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHksXG4gICAgYWRqdXN0OiBtZW1vKHsgbm9ybWFsaXNlVG8sIHJhbmdlTWluLCByYW5nZU1heCwgemVyb0RvbWFpbiB9LCBub3JtYWxpc2VQcm9wZXJ0eUZuQnVpbGRlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGlvblZhbGlkYXRpb24odmFsdWVLZXlJZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInByb2Nlc3NvclwiLFxuICAgIHByb3BlcnR5OiBcImFuaW1hdGlvblZhbGlkYXRpb25cIixcbiAgICBjYWxjdWxhdGUocmVzdWx0KSB7XG4gICAgICBjb25zdCB7IGtleXMsIHZhbHVlcyB9ID0gcmVzdWx0LmRlZnM7XG4gICAgICBjb25zdCB7IGlucHV0LCBkYXRhIH0gPSByZXN1bHQ7XG4gICAgICBsZXQgdW5pcXVlS2V5cyA9IHRydWU7XG4gICAgICBsZXQgb3JkZXJlZEtleXMgPSB0cnVlO1xuICAgICAgY29uc3QgdmFsdWVLZXlzID0gW107XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHZhbHVlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBpZiAoIXZhbHVlS2V5SWRzPy5pbmNsdWRlcyh2YWx1ZXNba10uaWQpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZUtleXMucHVzaChbaywgdmFsdWVzW2tdXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9jZXNzS2V5ID0gKGlkeCwgZGVmLCB0eXBlKSA9PiB7XG4gICAgICAgIGlmIChkZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgICBjb25zdCBrZXlWYWx1ZXMgPSByZXN1bHQuZG9tYWluW3R5cGVdW2lkeF07XG4gICAgICAgICAgdW5pcXVlS2V5cyAmJiAodW5pcXVlS2V5cyA9IGtleVZhbHVlcy5sZW5ndGggPT09IGlucHV0LmNvdW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RWYWx1ZSA9IGRhdGFbMF0/Llt0eXBlXVtpZHhdO1xuICAgICAgICBmb3IgKGxldCBkID0gMTsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSBkYXRhW2RdW3R5cGVdW2lkeF07XG4gICAgICAgICAgb3JkZXJlZEtleXMgJiYgKG9yZGVyZWRLZXlzID0gbGFzdFZhbHVlIDw9IGtleVZhbHVlKTtcbiAgICAgICAgICB1bmlxdWVLZXlzICYmICh1bmlxdWVLZXlzID0gbGFzdFZhbHVlICE9PSBrZXlWYWx1ZSk7XG4gICAgICAgICAgbGFzdFZhbHVlID0ga2V5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBrID0gMDsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHByb2Nlc3NLZXkoaywga2V5c1trXSwgXCJrZXlzXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgayA9IDA7ICh1bmlxdWVLZXlzIHx8IG9yZGVyZWRLZXlzKSAmJiBrIDwgdmFsdWVLZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IFtpZHgsIGtleV0gPSB2YWx1ZUtleXNba107XG4gICAgICAgIHByb2Nlc3NLZXkoaWR4LCBrZXksIFwidmFsdWVzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdW5pcXVlS2V5cywgb3JkZXJlZEtleXMgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEdyb3VwQWNjRm4oeyBtb2RlLCBzZXBhcmF0ZU5lZ2F0aXZlIH0pIHtcbiAgcmV0dXJuICgpID0+ICgpID0+ICh2YWx1ZXMsIHZhbHVlSW5kZXhlcykgPT4ge1xuICAgIGNvbnN0IGFjYyA9IFswLCAwXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgY29uc3QgY3VycmVudFZhbCA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICBjb25zdCBhY2NJbmRleCA9IGlzTmVnYXRpdmUoY3VycmVudFZhbCkgJiYgc2VwYXJhdGVOZWdhdGl2ZSA/IDAgOiAxO1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihjdXJyZW50VmFsKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAobW9kZSA9PT0gXCJub3JtYWxcIilcbiAgICAgICAgYWNjW2FjY0luZGV4XSArPSBjdXJyZW50VmFsO1xuICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjY1thY2NJbmRleF07XG4gICAgICBpZiAobW9kZSA9PT0gXCJ0cmFpbGluZ1wiKVxuICAgICAgICBhY2NbYWNjSW5kZXhdICs9IGN1cnJlbnRWYWw7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRHcm91cFdpbmRvd0FjY0ZuKHsgbW9kZSwgc3VtOiBzdW0yIH0pIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBsYXN0VmFsdWVzID0gW107XG4gICAgbGV0IGZpcnN0Um93ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmV0dXJuICh2YWx1ZXMsIHZhbHVlSW5kZXhlcykgPT4ge1xuICAgICAgICBsZXQgYWNjID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSBmaXJzdFJvdyAmJiBzdW0yID09PSBcImN1cnJlbnRcIiA/IDAgOiBsYXN0VmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgICAgICBsYXN0VmFsdWVzW3ZhbHVlSWR4XSA9IGN1cnJlbnRWYWw7XG4gICAgICAgICAgY29uc3Qgc3VtVmFsdWUgPSBzdW0yID09PSBcImN1cnJlbnRcIiA/IGN1cnJlbnRWYWwgOiBsYXN0VmFsdWU7XG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihjdXJyZW50VmFsKSB8fCAhaXNGaW5pdGVOdW1iZXIobGFzdFZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjYztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgYWNjICs9IHN1bVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjO1xuICAgICAgICAgIGlmIChtb2RlID09PSBcInRyYWlsaW5nXCIpIHtcbiAgICAgICAgICAgIGFjYyArPSBzdW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RSb3cgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVHcm91cChtYXRjaEdyb3VwSWQsIG1vZGUsIHN1bTIsIHNlcGFyYXRlTmVnYXRpdmUgPSBmYWxzZSkge1xuICBsZXQgYWRqdXN0O1xuICBpZiAobW9kZS5zdGFydHNXaXRoKFwid2luZG93XCIpKSB7XG4gICAgY29uc3QgbW9kZVBhcmFtID0gbW9kZS5lbmRzV2l0aChcIi10cmFpbGluZ1wiKSA/IFwidHJhaWxpbmdcIiA6IFwibm9ybWFsXCI7XG4gICAgYWRqdXN0ID0gbWVtbyh7IG1vZGU6IG1vZGVQYXJhbSwgc3VtOiBzdW0yIH0sIGJ1aWxkR3JvdXBXaW5kb3dBY2NGbik7XG4gIH0gZWxzZSB7XG4gICAgYWRqdXN0ID0gbWVtbyh7IG1vZGUsIHNlcGFyYXRlTmVnYXRpdmUgfSwgYnVpbGRHcm91cEFjY0ZuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgYWRqdXN0XG4gIH07XG59XG5mdW5jdGlvbiBncm91cFN0YWNrQWNjRm4oKSB7XG4gIHJldHVybiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICBjb25zdCBhY2MgPSBuZXcgRmxvYXQ2NEFycmF5KDMyKTtcbiAgICBsZXQgc3RhY2tDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICBhY2Nbc3RhY2tDb3VudF0gPSBOdW1iZXIuaXNGaW5pdGUoY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IE5hTjtcbiAgICAgIHN0YWNrQ291bnQgKz0gMTtcbiAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2Muc3ViYXJyYXkoMCwgc3RhY2tDb3VudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZVN0YWNrKG1hdGNoR3JvdXBJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgYWRqdXN0OiBncm91cFN0YWNrQWNjRm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmYocHJldmlvdXNEYXRhLCB1cGRhdGVNb3ZlZERhdGEgPSB0cnVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwcm9jZXNzb3JcIixcbiAgICBwcm9wZXJ0eTogXCJkaWZmXCIsXG4gICAgY2FsY3VsYXRlOiAocHJvY2Vzc2VkRGF0YSkgPT4ge1xuICAgICAgY29uc3QgbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByZW1vdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLm1heChwcmV2aW91c0RhdGEuZGF0YS5sZW5ndGgsIHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHByZXZpb3VzRGF0YS5kYXRhW2ldO1xuICAgICAgICBjb25zdCBkYXR1bSA9IHByb2Nlc3NlZERhdGEuZGF0YVtpXTtcbiAgICAgICAgY29uc3QgcHJldklkID0gcHJldiA/IGNyZWF0ZURhdHVtSWQocHJldi5rZXlzKSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGRhdHVtSWQgPSBkYXR1bSA/IGNyZWF0ZURhdHVtSWQoZGF0dW0ua2V5cykgOiBcIlwiO1xuICAgICAgICBpZiAoZGF0dW0gJiYgcHJldiAmJiBwcmV2SWQgPT09IGRhdHVtSWQpIHtcbiAgICAgICAgICBpZiAoIWFycmF5c0VxdWFsKHByZXYudmFsdWVzLCBkYXR1bS52YWx1ZXMpKSB7XG4gICAgICAgICAgICB1cGRhdGVkLnNldChkYXR1bUlkLCBkYXR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVkLmhhcyhkYXR1bUlkKSkge1xuICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdGEgfHwgIWFycmF5c0VxdWFsKHJlbW92ZWQuZ2V0KGRhdHVtSWQpLnZhbHVlcywgZGF0dW0udmFsdWVzKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICAgICAgbW92ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlZC5kZWxldGUoZGF0dW1JZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0dW0pIHtcbiAgICAgICAgICBhZGRlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRlZC5oYXMocHJldklkKSkge1xuICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdGEgfHwgIWFycmF5c0VxdWFsKGFkZGVkLmdldChwcmV2SWQpLnZhbHVlcywgcHJldi52YWx1ZXMpKSB7XG4gICAgICAgICAgICB1cGRhdGVkLnNldChwcmV2SWQsIHByZXYpO1xuICAgICAgICAgICAgbW92ZWQuc2V0KHByZXZJZCwgcHJldik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLmRlbGV0ZShwcmV2SWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgICAgICB1cGRhdGVkLmRlbGV0ZShwcmV2SWQpO1xuICAgICAgICAgIHJlbW92ZWQuc2V0KHByZXZJZCwgcHJldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZWQgPSBhZGRlZC5zaXplID4gMCB8fCB1cGRhdGVkLnNpemUgPiAwIHx8IHJlbW92ZWQuc2l6ZSA+IDA7XG4gICAgICByZXR1cm4geyBjaGFuZ2VkLCBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCwgbW92ZWQgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVEYXR1bUlkKGtleXMsIC4uLmV4dHJhS2V5cykge1xuICBsZXQgcmVzdWx0O1xuICBpZiAoaXNBcnJheShrZXlzKSkge1xuICAgIHJlc3VsdCA9IGtleXMubWFwKChrZXkpID0+IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGtleSkpLmpvaW4oXCJfX19cIik7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoa2V5cyk7XG4gIH1cbiAgY29uc3QgcHJpbWl0aXZlVHlwZSA9IHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHJlc3VsdCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcmVzdWx0ID09PSBcImJvb2xlYW5cIiB8fCByZXN1bHQgaW5zdGFuY2VvZiBEYXRlO1xuICBpZiAocHJpbWl0aXZlVHlwZSAmJiBleHRyYUtleXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCArPSBgX19fJHtleHRyYUtleXMuam9pbihcIl9fX1wiKX1gO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXMudHNcbnZhciBTZXJpZXNOb2RlUGlja01vZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJpZXNOb2RlUGlja01vZGUyKSA9PiB7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIkVYQUNUX1NIQVBFX01BVENIXCJdID0gMF0gPSBcIkVYQUNUX1NIQVBFX01BVENIXCI7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIk5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUXCJdID0gMV0gPSBcIk5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUXCI7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIk5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUXCJdID0gMl0gPSBcIk5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUXCI7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIk5FQVJFU1RfTk9ERVwiXSA9IDNdID0gXCJORUFSRVNUX05PREVcIjtcbiAgcmV0dXJuIFNlcmllc05vZGVQaWNrTW9kZTI7XG59KShTZXJpZXNOb2RlUGlja01vZGUgfHwge30pO1xuZnVuY3Rpb24gYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNDb250aW51b3VzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJhc2ljRGlzY3JldGVDaGVja0RhdHVtVmFsaWRhdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkYXRpb25GbihzY2FsZVR5cGUpIHtcbiAgc3dpdGNoIChzY2FsZVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImxvZ1wiOlxuICAgIGNhc2UgXCJvcmRpbmFsLXRpbWVcIjpcbiAgICBjYXNlIFwidGltZVwiOlxuICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgcmV0dXJuIGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYmFzaWNEaXNjcmV0ZUNoZWNrRGF0dW1WYWxpZGF0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVR5cGUoc2NhbGVUeXBlKSB7XG4gIHN3aXRjaCAoc2NhbGVUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJsb2dcIjpcbiAgICBjYXNlIFwidGltZVwiOlxuICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgcmV0dXJuIFwicmFuZ2VcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiY2F0ZWdvcnlcIjtcbiAgfVxufVxuZnVuY3Rpb24ga2V5UHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgdHlwZTogXCJrZXlcIixcbiAgICB2YWx1ZVR5cGU6IGdldFZhbHVlVHlwZShzY2FsZVR5cGUpLFxuICAgIHZhbGlkYXRpb246IGdldFZhbGlkYXRpb25GbihzY2FsZVR5cGUpLFxuICAgIC4uLm9wdHNcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlVHlwZTogZ2V0VmFsdWVUeXBlKHNjYWxlVHlwZSksXG4gICAgdmFsaWRhdGlvbjogZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSksXG4gICAgLi4ub3B0c1xuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmFuZ2VkVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgbWluID0gLUluZmluaXR5LCBtYXggPSBJbmZpbml0eSwgLi4uZGVmT3B0cyB9ID0gb3B0cztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInZhbHVlXCIsXG4gICAgcHJvcGVydHk6IHByb3BOYW1lLFxuICAgIHZhbHVlVHlwZTogXCJyYW5nZVwiLFxuICAgIHZhbGlkYXRpb246IGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uLFxuICAgIHByb2Nlc3NvcjogKCkgPT4gKGRhdHVtKSA9PiBpc0Zpbml0ZU51bWJlcihkYXR1bSkgPyBjbGFtcChtaW4sIGRhdHVtLCBtYXgpIDogZGF0dW0sXG4gICAgLi4uZGVmT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBvbmx5UG9zaXRpdmUsIC4uLmRlZk9wdHMgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi52YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIGRlZk9wdHMpLFxuICAgIHByb2Nlc3NvcjogYWNjdW11bGF0ZWRWYWx1ZShvbmx5UG9zaXRpdmUpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyksXG4gICAgcHJvY2Vzc29yOiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWUoKVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBtb2RlLCBzdW0yID0gXCJjdXJyZW50XCIsIG9wdHMsIHNjYWxlVHlwZSkge1xuICByZXR1cm4gW1xuICAgIHZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyksXG4gICAgYWNjdW11bGF0ZUdyb3VwKG9wdHMuZ3JvdXBJZCwgbW9kZSwgc3VtMiwgb3B0cy5zZXBhcmF0ZU5lZ2F0aXZlKSxcbiAgICAuLi5vcHRzLnJhbmdlSWQgIT0gbnVsbCA/IFtyYW5nZTIob3B0cy5yYW5nZUlkLCBvcHRzLmdyb3VwSWQpXSA6IFtdXG4gIF07XG59XG5mdW5jdGlvbiBncm91cFN0YWNrVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSB7XG4gIHJldHVybiBbdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSwgYWNjdW11bGF0ZVN0YWNrKG9wdHMuZ3JvdXBJZCldO1xufVxudmFyIFNlcmllc05vZGVFdmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgZXZlbnQsIHsgZGF0dW0gfSwgc2VyaWVzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5kYXR1bSA9IGRhdHVtO1xuICAgIHRoaXMuc2VyaWVzSWQgPSBzZXJpZXMuaWQ7XG4gIH1cbn07XG52YXIgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNlcmllcywgc2VyaWVzR3JvdXBpbmcsIG9sZEdyb3VwaW5nKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZyA9IHNlcmllc0dyb3VwaW5nO1xuICAgIHRoaXMub2xkR3JvdXBpbmcgPSBvbGRHcm91cGluZztcbiAgICB0aGlzLnR5cGUgPSBcImdyb3VwaW5nQ2hhbmdlZFwiO1xuICB9XG59O1xudmFyIFNlcmllcyA9IGNsYXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yKHNlcmllc09wdHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuc2VyaWVzR3JvdXBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5pbnRlcm5hbElkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyBhbGwgdGhlIG5vZGVzIHVzZWQgdG8gcmVuZGVyIHRoaXMgc2VyaWVzLlxuICAgIHRoaXMucm9vdEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJzZXJpZXNSb290XCIsIGlzVmlydHVhbDogdHJ1ZSB9KTtcbiAgICB0aGlzLmF4ZXMgPSB7XG4gICAgICBbXCJ4XCIgLyogWCAqL106IHZvaWQgMCxcbiAgICAgIFtcInlcIiAvKiBZICovXTogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLmRpcmVjdGlvbnMgPSBbXCJ4XCIgLyogWCAqLywgXCJ5XCIgLyogWSAqL107XG4gICAgLy8gRmxhZyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGUgZGF0YS5cbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5tb2R1bGVNYXAgPSBuZXcgTW9kdWxlTWFwKCk7XG4gICAgdGhpcy5fZGVjbGFyYXRpb25PcmRlciA9IC0xO1xuICAgIHRoaXMuc2VyaWVzTGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIHRoaXMuX3BpY2tOb2RlQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcbiAgICBjb25zdCB7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXMgPSBbMSAvKiBORUFSRVNUX0JZX01BSU5fQVhJU19GSVJTVCAqL10sXG4gICAgICBkaXJlY3Rpb25LZXlzID0ge30sXG4gICAgICBkaXJlY3Rpb25OYW1lcyA9IHt9LFxuICAgICAgY29udGVudEdyb3VwVmlydHVhbCA9IHRydWUsXG4gICAgICBjYW5IYXZlQXhlcyA9IGZhbHNlXG4gICAgfSA9IHNlcmllc09wdHM7XG4gICAgdGhpcy5jdHggPSBtb2R1bGVDdHg7XG4gICAgdGhpcy5kaXJlY3Rpb25LZXlzID0gZGlyZWN0aW9uS2V5cztcbiAgICB0aGlzLmRpcmVjdGlvbk5hbWVzID0gZGlyZWN0aW9uTmFtZXM7XG4gICAgdGhpcy5jYW5IYXZlQXhlcyA9IGNhbkhhdmVBeGVzO1xuICAgIHRoaXMuY29udGVudEdyb3VwID0gdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmludGVybmFsSWR9LWNvbnRlbnRgLFxuICAgICAgICBpc1ZpcnR1YWw6IGNvbnRlbnRHcm91cFZpcnR1YWwsXG4gICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1oaWdobGlnaHRgLFxuICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxuICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiaGlnaGxpZ2h0XCIpXG4gICAgfSk7XG4gICAgdGhpcy5oaWdobGlnaHROb2RlID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImhpZ2hsaWdodE5vZGVcIiwgekluZGV4OiAwIH0pKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImhpZ2hsaWdodExhYmVsXCIsIHpJbmRleDogMTAgfSkpO1xuICAgIHRoaXMucGlja01vZGVzID0gcGlja01vZGVzO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1zZXJpZXMtbGFiZWxzYCxcbiAgICAgICAgekluZGV4OiA4IC8qIFNFUklFU19MQUJFTF9aSU5ERVggKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmFubm90YXRpb25Hcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmlkfS1hbm5vdGF0aW9uYCxcbiAgICAgIGlzVmlydHVhbDogY29udGVudEdyb3VwVmlydHVhbCxcbiAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImFubm90YXRpb25cIilcbiAgICB9KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcz8uaWQgPz8gdGhpcy5pbnRlcm5hbElkO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGUgPz8gXCJcIjtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YSA/PyB0aGlzLl9jaGFydERhdGE7XG4gIH1cbiAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICB0aGlzLnByb3BlcnRpZXMudmlzaWJsZSA9IHZhbHVlO1xuICAgIHRoaXMudmlzaWJsZU1heWJlQ2hhbmdlZCgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudmlzaWJsZTtcbiAgfVxuICBnZXQgaGFzRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhICE9IG51bGwgJiYgdGhpcy5kYXRhLmxlbmd0aCA+IDA7XG4gIH1cbiAgZ2V0IHRvb2x0aXBFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudG9vbHRpcD8uZW5hYmxlZCA/PyBmYWxzZTtcbiAgfVxuICBvbkRhdGFDaGFuZ2UoKSB7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIHRoaXMuX3BpY2tOb2RlQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBzZXRPcHRpb25zRGF0YShpbnB1dCkge1xuICAgIHRoaXMuX2RhdGEgPSBpbnB1dDtcbiAgICB0aGlzLm9uRGF0YUNoYW5nZSgpO1xuICB9XG4gIHNldENoYXJ0RGF0YShpbnB1dCkge1xuICAgIHRoaXMuX2NoYXJ0RGF0YSA9IGlucHV0O1xuICAgIGlmICh0aGlzLmRhdGEgPT09IGlucHV0KSB7XG4gICAgICB0aGlzLm9uRGF0YUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBvblNlcmllc0dyb3VwaW5nQ2hhbmdlKHByZXYsIG5leHQpIHtcbiAgICBjb25zdCB7IGludGVybmFsSWQsIHR5cGUsIHZpc2libGUgfSA9IHRoaXM7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5kZXJlZ2lzdGVyU2VyaWVzKHsgaWQ6IGludGVybmFsSWQsIHR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIucmVnaXN0ZXJTZXJpZXMoeyBpZDogaW50ZXJuYWxJZCwgdHlwZSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IG5leHQgfSk7XG4gICAgfVxuICAgIHRoaXMuZmlyZUV2ZW50KG5ldyBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCh0aGlzLCBuZXh0LCBwcmV2KSk7XG4gIH1cbiAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4geyBpbm5lcjogMSwgb3V0ZXI6IDAgfTtcbiAgfVxuICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4ID0gMCkge1xuICAgIGxldCBtYWluQWRqdXN0ID0gMDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICBjYXNlIFwicGF0aHNcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGFiZWxzXCI6XG4gICAgICAgIG1haW5BZGp1c3QgKz0gMmU0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXJrZXJcIjpcbiAgICAgICAgbWFpbkFkanVzdCArPSAxZTQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhpZ2hsaWdodFwiOlxuICAgICAgICBzdWJJbmRleCArPSAxNWUzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbm5vdGF0aW9uXCI6XG4gICAgICAgIG1haW5BZGp1c3QgKz0gMTVlMztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG1haW4gPSAoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyICsgbWFpbkFkanVzdDtcbiAgICByZXR1cm4gW21haW4sIHN1YkluZGV4XTtcbiAgfVxuICBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc0xpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgZGlzcGF0Y2godHlwZSwgZXZlbnQpIHtcbiAgICB0aGlzLnNlcmllc0xpc3RlbmVycy5kaXNwYXRjaCh0eXBlLCBldmVudCk7XG4gIH1cbiAgYWRkQ2hhcnRFdmVudExpc3RlbmVycygpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIuZGVyZWdpc3RlclNlcmllcyh0aGlzKTtcbiAgfVxuICBnZXREaXJlY3Rpb25WYWx1ZXMoZGlyZWN0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXJlY3Rpb24gPSB0aGlzLnJlc29sdmVLZXlEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBjb25zdCBrZXlzID0gcHJvcGVydGllcz8uW3Jlc29sdmVkRGlyZWN0aW9uXTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBpZiAoIWtleXMpIHtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGFkZFZhbHVlcyA9ICguLi5pdGVtcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVtcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBhZGRWYWx1ZXMoLi4udmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGFkZFZhbHVlcyguLi5PYmplY3QudmFsdWVzKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhZGRWYWx1ZXMoLi4ua2V5cy5tYXAoKGtleSkgPT4gdGhpcy5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIGdldEtleXMoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgdGhpcy5kaXJlY3Rpb25LZXlzKTtcbiAgfVxuICBnZXRLZXlQcm9wZXJ0aWVzKGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbktleXNbdGhpcy5yZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbildID8/IFtdO1xuICB9XG4gIGdldE5hbWVzKGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHRoaXMuZGlyZWN0aW9uTmFtZXMpO1xuICB9XG4gIHJlc29sdmVLZXlEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuICAvLyBUaGUgdW5pb24gb2YgdGhlIHNlcmllcyBkb21haW4gKCdjb21tdW5pdHknKSBhbmQgc2VyaWVzLW9wdGlvbiBkb21haW5zICgnZW50ZXJwcmlzZScpLlxuICBnZXREb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKTtcbiAgICBjb25zdCBtb2R1bGVEb21haW5zID0gdGhpcy5tb2R1bGVNYXAubWFwTW9kdWxlcygobW9kdWxlKSA9PiBtb2R1bGUuZ2V0RG9tYWluKGRpcmVjdGlvbikpO1xuICAgIHJldHVybiBzZXJpZXNEb21haW4uY29uY2F0KG1vZHVsZURvbWFpbnMuZmxhdCgpKTtcbiAgfVxuICAvLyBJbmRpY2F0ZSB0aGF0IHNvbWV0aGluZyBleHRlcm5hbCBjaGFuZ2VkIGFuZCB3ZSBzaG91bGQgcmVjYWxjdWxhdGUgbm9kZURhdGEuXG4gIG1hcmtOb2RlRGF0YURpcnR5KCkge1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy52aXNpYmxlTWF5YmVDaGFuZ2VkKCk7XG4gIH1cbiAgdmlzaWJsZU1heWJlQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIucmVnaXN0ZXJTZXJpZXModGhpcyk7XG4gIH1cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBjb25zdCBkZWZhdWx0T3BhY2l0eSA9IDE7XG4gICAgY29uc3QgeyBkaW1PcGFjaXR5ID0gMSwgZW5hYmxlZCA9IHRydWUgfSA9IHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5zZXJpZXM7XG4gICAgaWYgKCFlbmFibGVkIHx8IGRpbU9wYWNpdHkgPT09IGRlZmF1bHRPcGFjaXR5KSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE9wYWNpdHk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5pc0l0ZW1JZEhpZ2hsaWdodGVkKCkpIHtcbiAgICAgIGNhc2UgMCAvKiBOb25lICovOlxuICAgICAgY2FzZSAxIC8qIFRoaXMgKi86XG4gICAgICAgIHJldHVybiBkZWZhdWx0T3BhY2l0eTtcbiAgICAgIGNhc2UgMiAvKiBPdGhlciAqLzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkaW1PcGFjaXR5O1xuICAgIH1cbiAgfVxuICBnZXRTdHJva2VXaWR0aChkZWZhdWx0U3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCB7IHN0cm9rZVdpZHRoLCBlbmFibGVkID0gdHJ1ZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLnNlcmllcztcbiAgICBpZiAoIWVuYWJsZWQgfHwgc3Ryb2tlV2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRTdHJva2VXaWR0aDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLmlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSkge1xuICAgICAgY2FzZSAxIC8qIFRoaXMgKi86XG4gICAgICAgIHJldHVybiBzdHJva2VXaWR0aDtcbiAgICAgIGNhc2UgMCAvKiBOb25lICovOlxuICAgICAgY2FzZSAyIC8qIE90aGVyICovOlxuICAgICAgICByZXR1cm4gZGVmYXVsdFN0cm9rZVdpZHRoO1xuICAgIH1cbiAgfVxuICBpc0l0ZW1JZEhpZ2hsaWdodGVkKCkge1xuICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpPy5zZXJpZXM7XG4gICAgaWYgKHNlcmllcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICBpZiAoc2VyaWVzICE9PSB0aGlzKSB7XG4gICAgICByZXR1cm4gMiAvKiBPdGhlciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDEgLyogVGhpcyAqLztcbiAgfVxuICBnZXRNb2R1bGVUb29sdGlwUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5tYXBNb2R1bGVzKChtb2R1bGUpID0+IG1vZHVsZS5nZXRUb29sdGlwUGFyYW1zKCkpLnJlZHVjZSgodG90YWwsIGN1cnJlbnQpID0+IE9iamVjdC5hc3NpZ24odG90YWwsIGN1cnJlbnQpLCB7fSk7XG4gIH1cbiAgcGlja05vZGUocG9pbnQsIGludGVudCwgZXhhY3RNYXRjaE9ubHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgcGlja01vZGVzLCB2aXNpYmxlLCByb290R3JvdXAgfSA9IHRoaXM7XG4gICAgaWYgKCF2aXNpYmxlIHx8ICFyb290R3JvdXAudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaW50ZW50ID09PSBcImhpZ2hsaWdodFwiICYmICF0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0LmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGludGVudCA9PT0gXCJoaWdobGlnaHQtdG9vbHRpcFwiICYmICF0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0LmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGludGVudCA9PT0gXCJoaWdobGlnaHRcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGlmIChpbnRlbnQgPT09IFwidG9vbHRpcFwiIHx8IGludGVudCA9PT0gXCJoaWdobGlnaHQtdG9vbHRpcFwiKSB7XG4gICAgICBjb25zdCB7IHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIG1heERpc3RhbmNlID0gdHlwZW9mIHRvb2x0aXAucmFuZ2UgPT09IFwibnVtYmVyXCIgPyB0b29sdGlwLnJhbmdlIDogSW5maW5pdHk7XG4gICAgICBleGFjdE1hdGNoT25seSB8fCAoZXhhY3RNYXRjaE9ubHkgPSB0b29sdGlwLnJhbmdlID09PSBcImV4YWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZW50ID09PSBcImV2ZW50XCIpIHtcbiAgICAgIGNvbnN0IHsgbm9kZUNsaWNrUmFuZ2UgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIG1heERpc3RhbmNlID0gdHlwZW9mIG5vZGVDbGlja1JhbmdlID09PSBcIm51bWJlclwiID8gbm9kZUNsaWNrUmFuZ2UgOiBJbmZpbml0eTtcbiAgICAgIGV4YWN0TWF0Y2hPbmx5IHx8IChleGFjdE1hdGNoT25seSA9IG5vZGVDbGlja1JhbmdlID09PSBcImV4YWN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZFBpY2tNb2RlcyA9IHBpY2tNb2Rlcy5maWx0ZXIoXG4gICAgICAobSkgPT4gIWV4YWN0TWF0Y2hPbmx5IHx8IG0gPT09IDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICApO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoeyB4LCB5LCBtYXhEaXN0YW5jZSwgc2VsZWN0ZWRQaWNrTW9kZXMgfSk7XG4gICAgaWYgKHRoaXMuX3BpY2tOb2RlQ2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waWNrTm9kZUNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBpY2tNb2RlIG9mIHNlbGVjdGVkUGlja01vZGVzKSB7XG4gICAgICBsZXQgbWF0Y2g7XG4gICAgICBzd2l0Y2ggKHBpY2tNb2RlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqLzpcbiAgICAgICAgICBtYXRjaCA9IHRoaXMucGlja05vZGVFeGFjdFNoYXBlKHBvaW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIE5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUICovOlxuICAgICAgICBjYXNlIDIgLyogTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1QgKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlTWFpbkF4aXNGaXJzdChcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgcGlja01vZGUgPT09IDIgLyogTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1QgKi9cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogTkVBUkVTVF9OT0RFICovOlxuICAgICAgICAgIG1hdGNoID0gdGhpcy5waWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZGlzdGFuY2UgPD0gbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tOb2RlQ2FjaGUuc2V0KGtleSwgeyBwaWNrTW9kZSwgbWF0Y2g6IG1hdGNoLmRhdHVtLCBkaXN0YW5jZTogbWF0Y2guZGlzdGFuY2UgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9waWNrTm9kZUNhY2hlLnNldChrZXksIHZvaWQgMCk7XG4gIH1cbiAgcGlja05vZGVFeGFjdFNoYXBlKHBvaW50KSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNvbnRlbnRHcm91cC5waWNrTm9kZShwb2ludC54LCBwb2ludC55KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLmRhdHVtLCBkaXN0YW5jZTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKF9wb2ludCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIFNlcmllcy5waWNrTm9kZUNsb3Nlc3REYXR1bSgpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBwaWNrTm9kZU5lYXJlc3REaXN0YW50T2JqZWN0KHBvaW50LCBpdGVtcykge1xuICAgIGNvbnN0IG1hdGNoID0gbmVhcmVzdFNxdWFyZWQocG9pbnQueCwgcG9pbnQueSwgaXRlbXMpO1xuICAgIGlmIChtYXRjaC5uZWFyZXN0ICE9PSB2b2lkIDAgJiYgbWF0Y2gubmVhcmVzdC5kYXR1bS5taXNzaW5nICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4geyBkYXR1bTogbWF0Y2gubmVhcmVzdC5kYXR1bSwgZGlzdGFuY2U6IE1hdGguc3FydChtYXRjaC5kaXN0YW5jZVNxdWFyZWQpIH07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcGlja05vZGVNYWluQXhpc0ZpcnN0KF9wb2ludCwgX3JlcXVpcmVDYXRlZ29yeUF4aXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBTZXJpZXMucGlja05vZGVNYWluQXhpc0ZpcnN0KCkgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGZpcmVOb2RlQ2xpY2tFdmVudChldmVudCwgZGF0dW0pIHtcbiAgICB0aGlzLmZpcmVFdmVudChuZXcgdGhpcy5Ob2RlRXZlbnQoXCJub2RlQ2xpY2tcIiwgZXZlbnQsIGRhdHVtLCB0aGlzKSk7XG4gIH1cbiAgZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LCBkYXR1bSkge1xuICAgIHRoaXMuZmlyZUV2ZW50KG5ldyB0aGlzLk5vZGVFdmVudChcIm5vZGVEb3VibGVDbGlja1wiLCBldmVudCwgZGF0dW0sIHRoaXMpKTtcbiAgfVxuICBjcmVhdGVOb2RlQ29udGV4dE1lbnVBY3Rpb25FdmVudChldmVudCwgZGF0dW0pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuTm9kZUV2ZW50KFwibm9kZUNvbnRleHRNZW51QWN0aW9uXCIsIGV2ZW50LCBkYXR1bSwgdGhpcyk7XG4gIH1cbiAgdG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpIHtcbiAgICB0aGlzLnZpc2libGUgPSBlbmFibGVkO1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5kaXNwYXRjaChcInZpc2liaWxpdHktY2hhbmdlZFwiLCB7IGl0ZW1JZCwgZW5hYmxlZCB9KTtcbiAgfVxuICBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgfVxuICBnZXRNb2R1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwO1xuICB9XG4gIGNyZWF0ZU1vZHVsZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jdHgsIHNlcmllczogdGhpcyB9O1xuICB9XG4gIGdldExhYmVsVGV4dChsYWJlbCwgcGFyYW1zLCBkZWZhdWx0Rm9ybWF0dGVyID0gU3RyaW5nKSB7XG4gICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY3R4LmNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHsgc2VyaWVzSWQ6IHRoaXMuaWQsIC4uLnBhcmFtcyB9KSA/PyBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSk7XG4gIH1cbiAgZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSA9IG1hcmtlci5nZXRTdHlsZSgpKSB7XG4gICAgY29uc3QgZGVmYXVsdFNpemUgPSB7IHNpemU6IHBhcmFtcy5kYXR1bS5wb2ludD8uc2l6ZSA/PyAwIH07XG4gICAgY29uc3QgbWFya2VyU3R5bGUgPSBtZXJnZURlZmF1bHRzKGRlZmF1bHRTaXplLCBkZWZhdWx0U3R5bGUpO1xuICAgIGlmIChtYXJrZXIuaXRlbVN0eWxlcikge1xuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmN0eC5jYWxsYmFja0NhY2hlLmNhbGwobWFya2VyLml0ZW1TdHlsZXIsIHtcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIC4uLm1hcmtlclN0eWxlLFxuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIGRhdHVtOiBwYXJhbXMuZGF0dW0uZGF0dW1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoc3R5bGUsIG1hcmtlclN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclN0eWxlO1xuICB9XG4gIHVwZGF0ZU1hcmtlclN0eWxlKG1hcmtlck5vZGUsIG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUgPSBtYXJrZXIuZ2V0U3R5bGUoKSwgeyBhcHBseVRyYW5zbGF0aW9uID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCB7IHBvaW50IH0gPSBwYXJhbXMuZGF0dW07XG4gICAgY29uc3QgYWN0aXZlU3R5bGUgPSB0aGlzLmdldE1hcmtlclN0eWxlKG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUpO1xuICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgYWN0aXZlU3R5bGUuc2l6ZSA+IDAgJiYgcG9pbnQgJiYgIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KTtcbiAgICBpZiAoYXBwbHlUcmFuc2xhdGlvbikge1xuICAgICAgbWFya2VyTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZSwgLi4uYWN0aXZlU3R5bGUsIHRyYW5zbGF0aW9uWDogcG9pbnQ/LngsIHRyYW5zbGF0aW9uWTogcG9pbnQ/LnkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlck5vZGUuc2V0UHJvcGVydGllcyh7IHZpc2libGUsIC4uLmFjdGl2ZVN0eWxlIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hcmtlci5zaGFwZSA9PT0gXCJmdW5jdGlvblwiICYmICFtYXJrZXJOb2RlLmRpcnR5UGF0aCkge1xuICAgICAgbWFya2VyTm9kZS5wYXRoLmNsZWFyKHRydWUpO1xuICAgICAgbWFya2VyTm9kZS51cGRhdGVQYXRoKCk7XG4gICAgICBtYXJrZXJOb2RlLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgfVxuICB9XG4gIGdldE1pblJlY3RzKF93aWR0aCwgX2hlaWdodCkge1xuICAgIHJldHVybjtcbiAgfVxuICBnZXQgbm9kZURhdGFEZXBlbmRlbmNpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID8/IHsgc2VyaWVzUmVjdFdpZHRoOiBOYU4sIHNlcmllc1JlY3RIZWlnaHQ6IE5hTiB9O1xuICB9XG4gIGNoZWNrUmVzaXplKG5ld1Nlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IHdpZHRoOiBzZXJpZXNSZWN0V2lkdGgsIGhlaWdodDogc2VyaWVzUmVjdEhlaWdodCB9ID0gbmV3U2VyaWVzUmVjdCA/PyB7IHdpZHRoOiBOYU4sIGhlaWdodDogTmFOIH07XG4gICAgY29uc3QgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdTZXJpZXNSZWN0ID8geyBzZXJpZXNSZWN0V2lkdGgsIHNlcmllc1JlY3RIZWlnaHQgfSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXNpemUgPSBqc29uRGlmZih0aGlzLm5vZGVEYXRhRGVwZW5kZW5jaWVzLCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcykgIT0gbnVsbDtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICAgICAgdGhpcy5tYXJrTm9kZURhdGFEaXJ0eSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzaXplO1xuICB9XG4gIHBpY2tGb2N1cyhfb3B0cykge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5TZXJpZXMuaGlnaGxpZ2h0ZWRaSW5kZXggPSAxZTEyO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlOiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgdGhpcy5vblNlcmllc0dyb3VwaW5nQ2hhbmdlKG9sZFZhbCwgbmV3VmFsKTtcbiAgICB9XG4gIH0pXG5dLCBTZXJpZXMucHJvdG90eXBlLCBcInNlcmllc0dyb3VwaW5nXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvdXRpbC50c1xuZnVuY3Rpb24gY29udmVydFZhbHVlc1RvU2NhbGVCeURlZnMoe1xuICBkZWZzLFxuICB2YWx1ZXMsXG4gIHhBeGlzLFxuICB5QXhpc1xufSkge1xuICBpZiAoISh4QXhpcyAmJiB5QXhpcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBeGVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBbc2VhcmNoSWQsIHsgZGVmIH1dIG9mIGRlZnMpIHtcbiAgICBpZiAoT2JqZWN0Lmhhc093bih2YWx1ZXMsIHNlYXJjaElkKSkge1xuICAgICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSBkZWYudHlwZSA9PT0gXCJrZXlcIiA/IHhBeGlzIDogeUF4aXM7XG4gICAgICByZXN1bHRbc2VhcmNoSWRdID0gTWF0aC5yb3VuZChzY2FsZTIuY29udmVydCh2YWx1ZXNbc2VhcmNoSWRdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwaWNrTm9kZShpbnB1dFNlcmllcywgcG9pbnQsIGludGVudCwgZXhhY3RNYXRjaE9ubHkpIHtcbiAgY29uc3QgcmV2ZXJzZVNlcmllcyA9IFsuLi5pbnB1dFNlcmllc10ucmV2ZXJzZSgpO1xuICBsZXQgcmVzdWx0O1xuICBmb3IgKGNvbnN0IHNlcmllcyBvZiByZXZlcnNlU2VyaWVzKSB7XG4gICAgaWYgKCFzZXJpZXMudmlzaWJsZSB8fCAhc2VyaWVzLnJvb3RHcm91cC52aXNpYmxlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeyBtYXRjaCwgZGlzdGFuY2U6IGRpc3RhbmNlMyB9ID0gc2VyaWVzLnBpY2tOb2RlKHBvaW50LCBpbnRlbnQsIGV4YWN0TWF0Y2hPbmx5KSA/PyB7fTtcbiAgICBpZiAoIW1hdGNoIHx8IGRpc3RhbmNlMyA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0LmRpc3RhbmNlID4gZGlzdGFuY2UzKSB7XG4gICAgICByZXN1bHQgPSB7IHNlcmllcywgZGlzdGFuY2U6IGRpc3RhbmNlMywgZGF0dW06IG1hdGNoIH07XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZTMgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzQXJlYUNsaWNrTWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFDbGlja01hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoaWQsIGNoYXJ0LCBjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICBjb25zdCBzZXJpZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLyk7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4ZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcImhvcml6b250YWwtYXhlc1wiIC8qIEhPUklaT05UQUxfQVhFUyAqLyk7XG4gICAgY29uc3QgdmVydGljYWxBeGVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmxpc3RlbkFsbChcImNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkNsaWNrKGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmxpc3RlbkFsbChcImRibGNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkNsaWNrKGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChldmVudCkgPT4gdGhpcy5sYXlvdXRDb21wbGV0ZShldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMub25MZWF2ZSgpKSxcbiAgICAgIGhvcml6b250YWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5vbkxlYXZlKCkpLFxuICAgICAgdmVydGljYWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5vbkxlYXZlKCkpXG4gICAgKTtcbiAgfVxuICBzZXJpZXNDaGFuZ2VkKHNlcmllcykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICB9XG4gIGRhdGFDaGFuZ2VkKCkge1xuICAgIHRoaXMubGFzdEhvdmVyID0gdm9pZCAwO1xuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmxhc3RIb3Zlcikge1xuICAgICAgdGhpcy5vbkhvdmVyKHRoaXMubGFzdEhvdmVyKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHR5cGUsIG9wdHMpIHtcbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSh0eXBlLCBvcHRzKTtcbiAgfVxuICBsYXlvdXRDb21wbGV0ZShldmVudCkge1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IGV2ZW50LnNlcmllcy5wYWRkZWRSZWN0O1xuICB9XG4gIG9uTGVhdmUoKSB7XG4gICAgdGhpcy5sYXN0SG92ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gIH1cbiAgb25Ib3Zlcih7IG9mZnNldFgsIG9mZnNldFkgfSkge1xuICAgIGNvbnN0IGZvdW5kID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9LCBcImV2ZW50XCIpO1xuICAgIGlmIChmb3VuZD8uc2VyaWVzLmhhc0V2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIikgfHwgZm91bmQ/LnNlcmllcy5oYXNFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIpKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkLCBcInBvaW50ZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICAgIH1cbiAgfVxuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc2VyaWVzUmVjdD8uY29udGFpbnNQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKSAmJiB0aGlzLmNoZWNrU2VyaWVzTm9kZUNsaWNrKGV2ZW50KSkge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0V2ZW50ID0geyB0eXBlOiBldmVudC50eXBlID09PSBcImNsaWNrXCIgPyBcImNsaWNrXCIgOiBcImRvdWJsZUNsaWNrXCIsIGV2ZW50OiBldmVudC5zb3VyY2VFdmVudCB9O1xuICAgIHRoaXMuY2hhcnQuZmlyZUV2ZW50KG5ld0V2ZW50KTtcbiAgfVxuICBjaGVja1Nlcmllc05vZGVDbGljayhldmVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IGV2ZW50Lm9mZnNldFgsIHk6IGV2ZW50Lm9mZnNldFkgfSwgXCJldmVudFwiKTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgcmVzdWx0LnNlcmllcy5maXJlTm9kZUNsaWNrRXZlbnQoZXZlbnQuc291cmNlRXZlbnQsIHJlc3VsdC5kYXR1bSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiZGJsY2xpY2tcIikge1xuICAgICAgZXZlbnQucHJldmVudFpvb21EYmxDbGljayA9IHJlc3VsdC5kaXN0YW5jZSA9PT0gMDtcbiAgICAgIHJlc3VsdC5zZXJpZXMuZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LnNvdXJjZUV2ZW50LCByZXN1bHQuZGF0dW0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQva2V5Ym9hcmRVdGlsLnRzXG5mdW5jdGlvbiBjb21wdXRlQ2VudGVyKGJib3hPclBhdGgpIHtcbiAgaWYgKGJib3hPclBhdGggaW5zdGFuY2VvZiBCQm94KSB7XG4gICAgcmV0dXJuIGJib3hPclBhdGguY29tcHV0ZUNlbnRlcigpO1xuICB9XG4gIHJldHVybiBiYm94T3JQYXRoPy5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk/LmNvbXB1dGVDZW50ZXIoKTtcbn1cbmZ1bmN0aW9uIGRyYXdQaWNrZWRGb2N1cyhmb2N1c0luZGljYXRvciwgcGljaykge1xuICBjb25zdCB7IGJvdW5kcywgc2hvd0ZvY3VzQm94IH0gPSBwaWNrO1xuICBpZiAoc2hvd0ZvY3VzQm94KSB7XG4gICAgZm9jdXNJbmRpY2F0b3I/LnVwZGF0ZUJvdW5kcyhib3VuZHMpO1xuICB9XG59XG5mdW5jdGlvbiBtYWtlS2V5Ym9hcmRQb2ludGVyRXZlbnQoZm9jdXNJbmRpY2F0b3IsIHBpY2spIHtcbiAgZHJhd1BpY2tlZEZvY3VzKGZvY3VzSW5kaWNhdG9yLCBwaWNrKTtcbiAgY29uc3QgeyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH0gPSBjb21wdXRlQ2VudGVyKHBpY2suYm91bmRzKSA/PyB7fTtcbiAgaWYgKG9mZnNldFggIT09IHZvaWQgMCAmJiBvZmZzZXRZICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImtleWJvYXJkXCIsIG9mZnNldFgsIG9mZnNldFkgfTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzQXJlYUZvY3VzTWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFGb2N1c01hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoaWQsIGNoYXJ0LCBjdHgsIGNoYXJ0VHlwZTIsIG92ZXJsYXlzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY2hhcnRUeXBlID0gY2hhcnRUeXBlMjtcbiAgICB0aGlzLm92ZXJsYXlzID0gb3ZlcmxheXM7XG4gICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICB0aGlzLmZvY3VzID0ge1xuICAgICAgaGFzRm9jdXM6IGZhbHNlLFxuICAgICAgc2VyaWVzOiB2b2lkIDAsXG4gICAgICBzZXJpZXNJbmRleDogMCxcbiAgICAgIGRhdHVtSW5kZXg6IDAsXG4gICAgICBkYXR1bTogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBzZXJpZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChldmVudCkgPT4gdGhpcy5sYXlvdXRDb21wbGV0ZShldmVudCkpLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdGFydFwiLCAoKSA9PiB0aGlzLm9uQW5pbWF0aW9uU3RhcnQoKSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMub25CbHVyKCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwidGFiXCIsIChldmVudCkgPT4gdGhpcy5vblRhYihldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwibmF2LXZlcnRcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTmF2VmVydChldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwibmF2LWhvcmlcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTmF2SG9yaShldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwic3VibWl0XCIsIChldmVudCkgPT4gdGhpcy5vblN1Ym1pdChldmVudCkpLFxuICAgICAgdGhpcy5jdHgua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImJyb3dzZXJmb2N1c1wiLCAoZXZlbnQpID0+IHRoaXMub25Ccm93c2VyRm9jdXMoZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBzZXJpZXNDaGFuZ2VkKHNlcmllcykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgIHRoaXMub25CbHVyKCk7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdGhpcy5jdHguZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHZvaWQgMCk7XG4gIH1cbiAgcHJlU2NlbmVSZW5kZXIoKSB7XG4gICAgdGhpcy5yZWZyZXNoRm9jdXMoKTtcbiAgfVxuICBsYXlvdXRDb21wbGV0ZShldmVudCkge1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IGV2ZW50LnNlcmllcy5yZWN0O1xuICB9XG4gIHJlZnJlc2hGb2N1cygpIHtcbiAgICBpZiAodGhpcy5mb2N1cy5oYXNGb2N1cykge1xuICAgICAgdGhpcy5oYW5kbGVTZXJpZXNGb2N1cygwLCAwKTtcbiAgICB9XG4gIH1cbiAgb25UYWIoZXZlbnQpIHtcbiAgICB0aGlzLmhhbmRsZUZvY3VzKDAsIDApO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5mb2N1cy5oYXNGb2N1cyA9IHRydWU7XG4gIH1cbiAgb25OYXZWZXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1cy5zZXJpZXNJbmRleCArPSBldmVudC5kZWx0YTtcbiAgICB0aGlzLmhhbmRsZUZvY3VzKGV2ZW50LmRlbHRhLCAwKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIG9uTmF2SG9yaShldmVudCkge1xuICAgIHRoaXMuZm9jdXMuZGF0dW1JbmRleCArPSBldmVudC5kZWx0YTtcbiAgICB0aGlzLmhhbmRsZUZvY3VzKDAsIGV2ZW50LmRlbHRhKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIG9uQnJvd3NlckZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRlbHRhID4gMCkge1xuICAgICAgdGhpcy5mb2N1cy5kYXR1bSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZm9jdXMuc2VyaWVzID0gdm9pZCAwO1xuICAgICAgdGhpcy5mb2N1cy5kYXR1bUluZGV4ID0gMDtcbiAgICAgIHRoaXMuZm9jdXMuc2VyaWVzSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuZGVsdGEgPCAwKSB7XG4gICAgICB0aGlzLmZvY3VzLmRhdHVtID0gdm9pZCAwO1xuICAgICAgdGhpcy5mb2N1cy5zZXJpZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmZvY3VzLmRhdHVtSW5kZXggPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuZm9jdXMuc2VyaWVzSW5kZXggPSBJbmZpbml0eTtcbiAgICB9XG4gIH1cbiAgb25BbmltYXRpb25TdGFydCgpIHtcbiAgICBpZiAodGhpcy5mb2N1cy5oYXNGb2N1cykge1xuICAgICAgdGhpcy5vbkJsdXIoKTtcbiAgICB9XG4gIH1cbiAgb25CbHVyKCkge1xuICAgIHRoaXMuY3R4LmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh2b2lkIDApO1xuICAgIHRoaXMuZm9jdXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVGb2N1cyhzZXJpZXNJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpIHtcbiAgICB0aGlzLmZvY3VzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICBjb25zdCBvdmVybGF5Rm9jdXMgPSB0aGlzLm92ZXJsYXlzLmdldEZvY3VzSW5mbyh0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyKTtcbiAgICBpZiAob3ZlcmxheUZvY3VzID09IG51bGwpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VyaWVzRm9jdXMoc2VyaWVzSW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKG92ZXJsYXlGb2N1cy5yZWN0KTtcbiAgICAgIHRoaXMuY3R4LmFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlLmFubm91bmNlVmFsdWUob3ZlcmxheUZvY3VzLnRleHQpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVTZXJpZXNGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIGlmICh0aGlzLmNoYXJ0VHlwZSA9PT0gXCJoaWVyYXJjaHlcIikge1xuICAgICAgdGhpcy5oYW5kbGVIaWVyYXJjaHlTZXJpZXNGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZm9jdXMsIHNlcmllc1JlY3QsIHNlcmllcyB9ID0gdGhpcztcbiAgICBjb25zdCB2aXNpYmxlU2VyaWVzID0gc2VyaWVzLmZpbHRlcigocykgPT4gcy52aXNpYmxlKTtcbiAgICBpZiAodmlzaWJsZVNlcmllcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgZm9jdXMuc2VyaWVzSW5kZXggPSBjbGFtcCgwLCBmb2N1cy5zZXJpZXNJbmRleCwgdmlzaWJsZVNlcmllcy5sZW5ndGggLSAxKTtcbiAgICBmb2N1cy5zZXJpZXMgPSB2aXNpYmxlU2VyaWVzW2ZvY3VzLnNlcmllc0luZGV4XTtcbiAgICBjb25zdCB7IGRhdHVtSW5kZXgsIHNlcmllc0luZGV4OiBvdGhlckluZGV4IH0gPSBmb2N1cztcbiAgICBjb25zdCBwaWNrID0gZm9jdXMuc2VyaWVzLnBpY2tGb2N1cyh7IGRhdHVtSW5kZXgsIGRhdHVtSW5kZXhEZWx0YSwgb3RoZXJJbmRleCwgb3RoZXJJbmRleERlbHRhLCBzZXJpZXNSZWN0IH0pO1xuICAgIHRoaXMudXBkYXRlUGlja2VkRm9jdXMocGljayk7XG4gIH1cbiAgaGFuZGxlSGllcmFyY2h5U2VyaWVzRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpIHtcbiAgICB0aGlzLmZvY3VzLnNlcmllcyA9IHRoaXMuc2VyaWVzWzBdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvY3VzOiB7IHNlcmllcywgc2VyaWVzSW5kZXg6IG90aGVySW5kZXgsIGRhdHVtSW5kZXggfSxcbiAgICAgIHNlcmllc1JlY3RcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc2VyaWVzID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcGljayA9IHNlcmllcy5waWNrRm9jdXMoeyBkYXR1bUluZGV4LCBkYXR1bUluZGV4RGVsdGEsIG90aGVySW5kZXgsIG90aGVySW5kZXhEZWx0YSwgc2VyaWVzUmVjdCB9KTtcbiAgICB0aGlzLnVwZGF0ZVBpY2tlZEZvY3VzKHBpY2spO1xuICB9XG4gIHVwZGF0ZVBpY2tlZEZvY3VzKHBpY2spIHtcbiAgICBjb25zdCB7IGZvY3VzIH0gPSB0aGlzO1xuICAgIGlmIChwaWNrID09PSB2b2lkIDAgfHwgZm9jdXMuc2VyaWVzID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkYXR1bSwgZGF0dW1JbmRleCB9ID0gcGljaztcbiAgICBmb2N1cy5kYXR1bUluZGV4ID0gZGF0dW1JbmRleDtcbiAgICBmb2N1cy5kYXR1bSA9IGRhdHVtO1xuICAgIGNvbnN0IGtleWJvYXJkRXZlbnQgPSBtYWtlS2V5Ym9hcmRQb2ludGVyRXZlbnQodGhpcy5jdHguZm9jdXNJbmRpY2F0b3IsIHBpY2spO1xuICAgIGlmIChrZXlib2FyZEV2ZW50ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGh0bWwgPSBmb2N1cy5zZXJpZXMuZ2V0VG9vbHRpcEh0bWwoZGF0dW0pO1xuICAgICAgY29uc3QgbWV0YSA9IFRvb2x0aXBNYW5hZ2VyLm1ha2VUb29sdGlwTWV0YShrZXlib2FyZEV2ZW50LCBkYXR1bSk7XG4gICAgICBjb25zdCBhcmlhID0gdGhpcy5nZXREYXR1bUFyaWFUZXh0KGRhdHVtLCBodG1sKTtcbiAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIGRhdHVtKTtcbiAgICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZVRvb2x0aXAodGhpcy5pZCwgbWV0YSwgaHRtbCk7XG4gICAgICB0aGlzLmN0eC5hcmlhQW5ub3VuY2VtZW50U2VydmljZS5hbm5vdW5jZVZhbHVlKFwiYXJpYUFubm91bmNlSG92ZXJEYXR1bVwiLCB7IGRhdHVtOiBhcmlhIH0pO1xuICAgIH1cbiAgfVxuICBvblN1Ym1pdChldmVudCkge1xuICAgIGNvbnN0IHsgc2VyaWVzLCBkYXR1bSB9ID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50LnNvdXJjZUV2ZW50O1xuICAgIGlmIChzZXJpZXMgIT09IHZvaWQgMCAmJiBkYXR1bSAhPT0gdm9pZCAwKSB7XG4gICAgICBzZXJpZXMuZmlyZU5vZGVDbGlja0V2ZW50KHNvdXJjZUV2ZW50LCBkYXR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhcnQuZmlyZUV2ZW50KHtcbiAgICAgICAgdHlwZTogXCJjbGlja1wiLFxuICAgICAgICBldmVudDogc291cmNlRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGdldERhdHVtQXJpYVRleHQoZGF0dW0sIGh0bWwpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGh0bWwuYXJpYUxhYmVsO1xuICAgIHJldHVybiBkYXR1bS5zZXJpZXMuZ2V0RGF0dW1BcmlhVGV4dD8uKGRhdHVtLCBkZXNjcmlwdGlvbikgPz8gZGVzY3JpcHRpb247XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhSGlnaGxpZ2h0TWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFIaWdobGlnaHRNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGlkLCBjaGFydCwgY3R4LCBoaWdobGlnaHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICB0aGlzLmhvdmVyU2NoZWR1bGVyID0gZGVib3VuY2VkQW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdIb3ZlckV2ZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5jaGFydC5wZXJmb3JtVXBkYXRlVHlwZSA8PSA0IC8qIFNFUklFU19VUERBVEUgKi8pIHtcbiAgICAgICAgdGhpcy5ob3ZlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZUhvdmVyKGZhbHNlKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXJpZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLyk7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4ZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcImhvcml6b250YWwtYXhlc1wiIC8qIEhPUklaT05UQUxfQVhFUyAqLyk7XG4gICAgY29uc3QgdmVydGljYWxBeGVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLyk7XG4gICAgY29uc3QgbW91c2VNb3ZlU3RhdGVzID0gMTYgLyogRGVmYXVsdCAqLyB8IDQgLyogQW5ub3RhdGlvbnMgKi87XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChldmVudCkgPT4gdGhpcy5sYXlvdXRDb21wbGV0ZShldmVudCkpLFxuICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5hZGRMaXN0ZW5lcihcImhpZ2hsaWdodC1jaGFuZ2VcIiwgKGV2ZW50KSA9PiB0aGlzLmNoYW5nZUhpZ2hsaWdodERhdHVtKGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSwgbW91c2VNb3ZlU3RhdGVzKSxcbiAgICAgIGhvcml6b250YWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpKSxcbiAgICAgIHZlcnRpY2FsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSksXG4gICAgICAvLyBDYXNlcyB3aGVyZSBoaWdobGlnaHQgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHRoaXMuY2xlYXJIaWdobGlnaHQoKSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLmNsZWFySGlnaGxpZ2h0KCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMuY2xlYXJIaWdobGlnaHQoKSksXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLXN0YXJ0XCIsICgpID0+IHRoaXMuY2xlYXJIaWdobGlnaHQoKSksXG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tcGFuLXN0YXJ0XCIsICgpID0+IHRoaXMuY2xlYXJIaWdobGlnaHQoKSksXG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHRoaXMuY2xlYXJIaWdobGlnaHQoKSlcbiAgICApO1xuICB9XG4gIHNlcmllc0NoYW5nZWQoc2VyaWVzKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdGhpcy5zdGFzaGVkSG92ZXJFdmVudCA/PyAodGhpcy5zdGFzaGVkSG92ZXJFdmVudCA9IHRoaXMuYXBwbGllZEhvdmVyRXZlbnQpO1xuICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgfVxuICBwcmVTY2VuZVJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGFzaGVkSG92ZXJFdmVudCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnBlbmRpbmdIb3ZlckV2ZW50ID0gdGhpcy5zdGFzaGVkSG92ZXJFdmVudDtcbiAgICAgIHRoaXMuc3Rhc2hlZEhvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhhbmRsZUhvdmVyKHRydWUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUodHlwZSwgb3B0cykge1xuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKHR5cGUsIG9wdHMpO1xuICB9XG4gIGxheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlclJlY3QgPSBldmVudC5zZXJpZXMucGFkZGVkUmVjdDtcbiAgfVxuICBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICB0aGlzLnBlbmRpbmdIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuYXBwbGllZEhvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIHRoaXMucGVuZGluZ0hvdmVyRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmhvdmVyU2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gIH1cbiAgaGFuZGxlSG92ZXIocmVkaXNwbGF5KSB7XG4gICAgdGhpcy5hcHBsaWVkSG92ZXJFdmVudCA9IHRoaXMucGVuZGluZ0hvdmVyRXZlbnQ7XG4gICAgdGhpcy5wZW5kaW5nSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuYXBwbGllZEhvdmVyRXZlbnQ7XG4gICAgaWYgKCFldmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSAhPT0gMTYgLyogRGVmYXVsdCAqLyAmJiBzdGF0ZSAhPT0gNCAvKiBBbm5vdGF0aW9ucyAqLylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGlmIChyZWRpc3BsYXkgPyB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzQWN0aXZlKCkgOiAhdGhpcy5ob3ZlclJlY3Q/LmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzLmhpZ2hsaWdodDtcbiAgICBjb25zdCBpbnRlbnQgPSByYW5nZTMgPT09IFwidG9vbHRpcFwiID8gXCJoaWdobGlnaHQtdG9vbHRpcFwiIDogXCJoaWdobGlnaHRcIjtcbiAgICBjb25zdCBmb3VuZCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IGV2ZW50Lm9mZnNldFgsIHk6IGV2ZW50Lm9mZnNldFkgfSwgaW50ZW50KTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIGZvdW5kLmRhdHVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gIH1cbiAgY2hhbmdlSGlnaGxpZ2h0RGF0dW0oZXZlbnQpIHtcbiAgICBjb25zdCBzZXJpZXNUb1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgeyBzZXJpZXM6IG5ld1NlcmllcyA9IHZvaWQgMCwgZGF0dW06IG5ld0RhdHVtIH0gPSBldmVudC5jdXJyZW50SGlnaGxpZ2h0ID8/IHt9O1xuICAgIGNvbnN0IHsgc2VyaWVzOiBsYXN0U2VyaWVzID0gdm9pZCAwLCBkYXR1bTogbGFzdERhdHVtIH0gPSBldmVudC5wcmV2aW91c0hpZ2hsaWdodCA/PyB7fTtcbiAgICBpZiAobGFzdFNlcmllcykge1xuICAgICAgc2VyaWVzVG9VcGRhdGUuYWRkKGxhc3RTZXJpZXMpO1xuICAgIH1cbiAgICBpZiAobmV3U2VyaWVzKSB7XG4gICAgICBzZXJpZXNUb1VwZGF0ZS5hZGQobmV3U2VyaWVzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RTZXJpZXM/LnByb3BlcnRpZXMuY3Vyc29yICYmIGxhc3REYXR1bSkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IobGFzdFNlcmllcy5pZCk7XG4gICAgfVxuICAgIGlmIChuZXdTZXJpZXM/LnByb3BlcnRpZXMuY3Vyc29yICYmIG5ld1Nlcmllcz8ucHJvcGVydGllcy5jdXJzb3IgIT09IFwiZGVmYXVsdFwiICYmIG5ld0RhdHVtKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihuZXdTZXJpZXMuaWQsIG5ld1Nlcmllcy5wcm9wZXJ0aWVzLmN1cnNvcik7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZUFsbCA9IG5ld1NlcmllcyA9PSBudWxsIHx8IGxhc3RTZXJpZXMgPT0gbnVsbDtcbiAgICBpZiAodXBkYXRlQWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZSg0IC8qIFNFUklFU19VUERBVEUgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZSg0IC8qIFNFUklFU19VUERBVEUgKi8sIHsgc2VyaWVzVG9VcGRhdGUgfSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzQXJlYVRvb2x0aXBNYW5hZ2VyLnRzXG52YXIgU2VyaWVzQXJlYVRvb2x0aXBNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGlkLCBjaGFydCwgY3R4LCB0b29sdGlwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICB0aGlzLmhvdmVyU2NoZWR1bGVyID0gZGVib3VuY2VkQW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmxhc3RIb3ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuY2hhcnQucGVyZm9ybVVwZGF0ZVR5cGUgPD0gNCAvKiBTRVJJRVNfVVBEQVRFICovKSB7XG4gICAgICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVIb3Zlcih0aGlzLmxhc3RIb3ZlciwgZmFsc2UpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovKTtcbiAgICBjb25zdCBob3Jpem9udGFsQXhlc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEF4ZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGV2ZW50KSA9PiB0aGlzLmxheW91dENvbXBsZXRlKGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXG4gICAgICAgIFwiaG92ZXJcIixcbiAgICAgICAgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLFxuICAgICAgICAxNiAvKiBEZWZhdWx0ICovIHwgNCAvKiBBbm5vdGF0aW9ucyAqL1xuICAgICAgKSxcbiAgICAgIGhvcml6b250YWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpKSxcbiAgICAgIHZlcnRpY2FsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSksXG4gICAgICAvLyBFdmVudHMgdGhhdCBjbGVhciB0b29sdGlwLlxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGhvcml6b250YWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICB2ZXJ0aWNhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tc3RhcnRcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLXBhbi1zdGFydFwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSlcbiAgICApO1xuICB9XG4gIHNlcmllc0NoYW5nZWQoc2VyaWVzKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgfVxuICBwcmVTY2VuZVJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5sYXN0SG92ZXIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVIb3Zlcih0aGlzLmxhc3RIb3ZlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGxheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlclJlY3QgPSBldmVudC5zZXJpZXMucGFkZGVkUmVjdDtcbiAgfVxuICBvbkhvdmVyKGV2ZW50KSB7XG4gICAgdGhpcy5sYXN0SG92ZXIgPSBldmVudDtcbiAgICB0aGlzLmhvdmVyU2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gIH1cbiAgY2xlYXJUb29sdGlwKCkge1xuICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgdGhpcy5sYXN0SG92ZXIgPSB2b2lkIDA7XG4gIH1cbiAgaGFuZGxlSG92ZXIoZXZlbnQsIHJlZGlzcGxheSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlICE9PSAxNiAvKiBEZWZhdWx0ICovICYmIHN0YXRlICE9PSA0IC8qIEFubm90YXRpb25zICovKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgdGFyZ2V0RWxlbWVudCB9ID0gZXZlbnQ7XG4gICAgaWYgKHJlZGlzcGxheSA/IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSA6ICF0aGlzLmhvdmVyUmVjdD8uY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRhcmdldEVsZW1lbnQgJiYgdGhpcy50b29sdGlwLmludGVyYWN0aXZlICYmIHRoaXMuY3R4LmRvbU1hbmFnZXIuaXNNYW5hZ2VkQ2hpbGRET01FbGVtZW50KHRhcmdldEVsZW1lbnQsIFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwaWNrID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9LCBcInRvb2x0aXBcIik7XG4gICAgaWYgKCFwaWNrKSB7XG4gICAgICB0aGlzLmNsZWFyVG9vbHRpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBodG1sID0gcGljay5zZXJpZXMuZ2V0VG9vbHRpcEh0bWwocGljay5kYXR1bSk7XG4gICAgY29uc3QgdG9vbHRpcEVuYWJsZWQgPSB0aGlzLnRvb2x0aXAuZW5hYmxlZCAmJiBwaWNrLnNlcmllcy50b29sdGlwRW5hYmxlZDtcbiAgICBjb25zdCBzaG91bGRVcGRhdGVUb29sdGlwID0gdG9vbHRpcEVuYWJsZWQgJiYgaHRtbCAhPSBudWxsO1xuICAgIGlmIChzaG91bGRVcGRhdGVUb29sdGlwKSB7XG4gICAgICBjb25zdCBtZXRhID0gVG9vbHRpcE1hbmFnZXIubWFrZVRvb2x0aXBNZXRhKGV2ZW50LCBwaWNrLmRhdHVtKTtcbiAgICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZVRvb2x0aXAodGhpcy5pZCwgbWV0YSwgaHRtbCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzQXJlYU1hbmFnZXIudHNcbnZhciBTZXJpZXNBcmVhTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY3R4LCBjaGFydFR5cGUyLCB0b29sdGlwLCBoaWdobGlnaHQsIG92ZXJsYXlzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICB0aGlzLnN1Yk1hbmFnZXJzID0gW1xuICAgICAgbmV3IFNlcmllc0FyZWFGb2N1c01hbmFnZXIodGhpcy5pZCwgY2hhcnQsIGN0eCwgY2hhcnRUeXBlMiwgb3ZlcmxheXMpLFxuICAgICAgbmV3IFNlcmllc0FyZWFIaWdobGlnaHRNYW5hZ2VyKHRoaXMuaWQsIGNoYXJ0LCBjdHgsIGhpZ2hsaWdodCksXG4gICAgICBuZXcgU2VyaWVzQXJlYVRvb2x0aXBNYW5hZ2VyKHRoaXMuaWQsIGNoYXJ0LCBjdHgsIHRvb2x0aXApLFxuICAgICAgbmV3IFNlcmllc0FyZWFDbGlja01hbmFnZXIodGhpcy5pZCwgY2hhcnQsIGN0eClcbiAgICBdO1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgICgpID0+IHRoaXMuc3ViTWFuYWdlcnMuZm9yRWFjaCgocykgPT4gcy5kZXN0cm95KCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGV2ZW50KSA9PiB0aGlzLm9uQ29udGV4dE1lbnUoZXZlbnQpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcihcInByZS1zY2VuZS1yZW5kZXJcIiwgKCkgPT4gdGhpcy5wcmVTY2VuZVJlbmRlcigpKVxuICAgICk7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgZm9yIChjb25zdCBtYW5hZ2VyIG9mIHRoaXMuc3ViTWFuYWdlcnMpIHtcbiAgICAgIG1hbmFnZXIuZGF0YUNoYW5nZWQ/LigpO1xuICAgIH1cbiAgfVxuICBwcmVTY2VuZVJlbmRlcigpIHtcbiAgICBmb3IgKGNvbnN0IG1hbmFnZXIgb2YgdGhpcy5zdWJNYW5hZ2Vycykge1xuICAgICAgbWFuYWdlci5wcmVTY2VuZVJlbmRlcj8uKCk7XG4gICAgfVxuICB9XG4gIHNlcmllc0NoYW5nZWQoc2VyaWVzKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgZm9yIChjb25zdCBtYW5hZ2VyIG9mIHRoaXMuc3ViTWFuYWdlcnMpIHtcbiAgICAgIG1hbmFnZXIuc2VyaWVzQ2hhbmdlZChzZXJpZXMpO1xuICAgIH1cbiAgfVxuICBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgY29uc3QgeyBEZWZhdWx0OiBEZWZhdWx0MiwgQ29udGV4dE1lbnUgfSA9IEludGVyYWN0aW9uU3RhdGU7XG4gICAgbGV0IHBpY2tlZE5vZGU7XG4gICAgaWYgKHRoaXMuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpICYgKERlZmF1bHQyIHwgQ29udGV4dE1lbnUpKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IGV2ZW50Lm9mZnNldFgsIHk6IGV2ZW50Lm9mZnNldFkgfSwgXCJjb250ZXh0LW1lbnVcIik7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gICAgICAgIHBpY2tlZE5vZGUgPSBtYXRjaC5kYXR1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNwYXRjaENvbnRleHQoXCJzZXJpZXNcIiwgZXZlbnQsIHsgcGlja2VkTm9kZSB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0xheWVyTWFuYWdlci50c1xudmFyIFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OID0gMzA7XG52YXIgU2VyaWVzTGF5ZXJNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXJpZXNSb290LCBoaWdobGlnaHRSb290LCBhbm5vdGF0aW9uUm9vdCkge1xuICAgIHRoaXMuc2VyaWVzUm9vdCA9IHNlcmllc1Jvb3Q7XG4gICAgdGhpcy5oaWdobGlnaHRSb290ID0gaGlnaGxpZ2h0Um9vdDtcbiAgICB0aGlzLmFubm90YXRpb25Sb290ID0gYW5ub3RhdGlvblJvb3Q7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLnNlcmllcyA9IHt9O1xuICAgIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA9IDE7XG4gICAgdGhpcy5tb2RlID0gXCJub3JtYWxcIjtcbiAgfVxuICBzZXRTZXJpZXNDb3VudChjb3VudCkge1xuICAgIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA9IGNvdW50O1xuICB9XG4gIHJlcXVlc3RHcm91cChzZXJpZXNDb25maWcpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsSWQsXG4gICAgICB0eXBlLFxuICAgICAgcm9vdEdyb3VwOiBzZXJpZXNSb290R3JvdXAsXG4gICAgICBoaWdobGlnaHRHcm91cDogc2VyaWVzSGlnaGxpZ2h0R3JvdXAsXG4gICAgICBhbm5vdGF0aW9uR3JvdXA6IHNlcmllc0Fubm90YXRpb25Hcm91cCxcbiAgICAgIHNlcmllc0dyb3VwaW5nXG4gICAgfSA9IHNlcmllc0NvbmZpZztcbiAgICBjb25zdCB7IGdyb3VwSW5kZXggPSBpbnRlcm5hbElkIH0gPSBzZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICBpZiAodGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBzZXJpZXMgYWxyZWFkeSBoYXMgYW4gYWxsb2NhdGVkIGxheWVyOiAke3RoaXMuc2VyaWVzW2ludGVybmFsSWRdfWApO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zZXJpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5tb2RlID0gdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID49IFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OID8gXCJhZ2dyZXNzaXZlLWdyb3VwaW5nXCIgOiBcIm5vcm1hbFwiO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLmdyb3VwcylbdHlwZV0gPz8gKF9hW3R5cGVdID0ge30pO1xuICAgIGNvbnN0IGxvb2t1cEluZGV4ID0gdGhpcy5sb29rdXBJZHgoZ3JvdXBJbmRleCk7XG4gICAgbGV0IGdyb3VwSW5mbyA9IHRoaXMuZ3JvdXBzW3R5cGVdW2xvb2t1cEluZGV4XTtcbiAgICBpZiAoIWdyb3VwSW5mbykge1xuICAgICAgZ3JvdXBJbmZvID0gKF9iID0gdGhpcy5ncm91cHNbdHlwZV0pW2xvb2t1cEluZGV4XSA/PyAoX2JbbG9va3VwSW5kZXhdID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBpZDogbG9va3VwSW5kZXgsXG4gICAgICAgIHNlcmllc0lkczogW10sXG4gICAgICAgIGdyb3VwOiB0aGlzLnNlcmllc1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWNvbnRlbnRgLFxuICAgICAgICAgICAgbGF5ZXI6IHRydWUsXG4gICAgICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIilcbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICBoaWdobGlnaHQ6IHRoaXMuaGlnaGxpZ2h0Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBuZXcgR3JvdXAoe1xuICAgICAgICAgICAgbmFtZTogYCR7dHlwZX0taGlnaGxpZ2h0YCxcbiAgICAgICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgICAgICAgekluZGV4U3ViT3JkZXI6IHNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgYW5ub3RhdGlvbjogdGhpcy5hbm5vdGF0aW9uUm9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBuZXcgR3JvdXAoe1xuICAgICAgICAgICAgbmFtZTogYCR7dHlwZX0tYW5ub3RhdGlvbmAsXG4gICAgICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImFubm90YXRpb25cIilcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0gPSB7IGxheWVyU3RhdGU6IGdyb3VwSW5mbywgc2VyaWVzQ29uZmlnIH07XG4gICAgZ3JvdXBJbmZvLnNlcmllc0lkcy5wdXNoKGludGVybmFsSWQpO1xuICAgIGdyb3VwSW5mby5ncm91cC5hcHBlbmRDaGlsZChzZXJpZXNSb290R3JvdXApO1xuICAgIGdyb3VwSW5mby5oaWdobGlnaHQuYXBwZW5kQ2hpbGQoc2VyaWVzSGlnaGxpZ2h0R3JvdXApO1xuICAgIGdyb3VwSW5mby5hbm5vdGF0aW9uLmFwcGVuZENoaWxkKHNlcmllc0Fubm90YXRpb25Hcm91cCk7XG4gICAgcmV0dXJuIGdyb3VwSW5mby5ncm91cDtcbiAgfVxuICBjaGFuZ2VHcm91cChzZXJpZXNDb25maWcpIHtcbiAgICBjb25zdCB7IGludGVybmFsSWQsIHNlcmllc0dyb3VwaW5nLCB0eXBlLCByb290R3JvdXAsIGhpZ2hsaWdodEdyb3VwLCBhbm5vdGF0aW9uR3JvdXAsIG9sZEdyb3VwaW5nIH0gPSBzZXJpZXNDb25maWc7XG4gICAgY29uc3QgeyBncm91cEluZGV4ID0gaW50ZXJuYWxJZCB9ID0gc2VyaWVzR3JvdXBpbmcgPz8ge307XG4gICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdPy5bZ3JvdXBJbmRleF0/LnNlcmllc0lkcy5pbmNsdWRlcyhpbnRlcm5hbElkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0gIT0gbnVsbCkge1xuICAgICAgdGhpcy5yZWxlYXNlR3JvdXAoe1xuICAgICAgICBpbnRlcm5hbElkLFxuICAgICAgICBzZXJpZXNHcm91cGluZzogb2xkR3JvdXBpbmcsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3RHcm91cCxcbiAgICAgICAgaGlnaGxpZ2h0R3JvdXAsXG4gICAgICAgIGFubm90YXRpb25Hcm91cFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdEdyb3VwKHNlcmllc0NvbmZpZyk7XG4gIH1cbiAgcmVsZWFzZUdyb3VwKHNlcmllc0NvbmZpZykge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxJZCwgcm9vdEdyb3VwLCBoaWdobGlnaHRHcm91cCwgYW5ub3RhdGlvbkdyb3VwLCB0eXBlIH0gPSBzZXJpZXNDb25maWc7XG4gICAgaWYgKHRoaXMuc2VyaWVzW2ludGVybmFsSWRdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gc2VyaWVzIGRvZXNuJ3QgaGF2ZSBhbiBhbGxvY2F0ZWQgbGF5ZXI6ICR7aW50ZXJuYWxJZH1gKTtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBJbmZvID0gdGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0/LmxheWVyU3RhdGU7XG4gICAgaWYgKGdyb3VwSW5mbykge1xuICAgICAgZ3JvdXBJbmZvLnNlcmllc0lkcyA9IGdyb3VwSW5mby5zZXJpZXNJZHMuZmlsdGVyKCh2KSA9PiB2ICE9PSBpbnRlcm5hbElkKTtcbiAgICAgIGdyb3VwSW5mby5ncm91cC5yZW1vdmVDaGlsZChyb290R3JvdXApO1xuICAgICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC5yZW1vdmVDaGlsZChoaWdobGlnaHRHcm91cCk7XG4gICAgICBncm91cEluZm8uYW5ub3RhdGlvbi5yZW1vdmVDaGlsZChhbm5vdGF0aW9uR3JvdXApO1xuICAgIH1cbiAgICBpZiAoZ3JvdXBJbmZvPy5zZXJpZXNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnNlcmllc1Jvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmdyb3VwKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uaGlnaGxpZ2h0KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmFubm90YXRpb24pO1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2dyb3VwSW5mby50eXBlXVtncm91cEluZm8uaWRdO1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW3R5cGVdW2ludGVybmFsSWRdO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBJbmZvPy5zZXJpZXNJZHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGVhZFNlcmllc0NvbmZpZyA9IHRoaXMuc2VyaWVzW2dyb3VwSW5mbz8uc2VyaWVzSWRzPy5bMF1dPy5zZXJpZXNDb25maWc7XG4gICAgICBncm91cEluZm8uZ3JvdXAuekluZGV4U3ViT3JkZXIgPSBsZWFkU2VyaWVzQ29uZmlnPy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKTtcbiAgICAgIGdyb3VwSW5mby5oaWdobGlnaHQuekluZGV4U3ViT3JkZXIgPSBsZWFkU2VyaWVzQ29uZmlnPy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiaGlnaGxpZ2h0XCIpO1xuICAgICAgZ3JvdXBJbmZvLmFubm90YXRpb24uekluZGV4U3ViT3JkZXIgPSBsZWFkU2VyaWVzQ29uZmlnPy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiYW5ub3RhdGlvblwiKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuc2VyaWVzW2ludGVybmFsSWRdO1xuICB9XG4gIGxvb2t1cElkeChncm91cEluZGV4KSB7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgcmV0dXJuIGdyb3VwSW5kZXg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ3JvdXBJbmRleCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZ3JvdXBJbmRleCA9IE51bWJlcihncm91cEluZGV4LnNwbGl0KFwiLVwiKS5hdCgtMSkpO1xuICAgICAgaWYgKCFncm91cEluZGV4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihcbiAgICAgIGNsYW1wKDAsIGdyb3VwSW5kZXggLyB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQsIDEpICogU0VSSUVTX1RIUkVTSE9MRF9GT1JfQUdHUkVTU0lWRV9MQVlFUl9SRURVQ1RJT05cbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBncm91cHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmdyb3VwcykpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXBJbmZvIG9mIE9iamVjdC52YWx1ZXMoZ3JvdXBzKSkge1xuICAgICAgICB0aGlzLnNlcmllc1Jvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmdyb3VwKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5oaWdobGlnaHQpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Sb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5hbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLnNlcmllcyA9IHt9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGUvYmFzZUxheW91dFByb2Nlc3Nvci50c1xudmFyIEJhc2VMYXlvdXRQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0TGlrZSwgbGF5b3V0U2VydmljZSkge1xuICAgIHRoaXMuY2hhcnRMaWtlID0gY2hhcnRMaWtlO1xuICAgIHRoaXMubGF5b3V0U2VydmljZSA9IGxheW91dFNlcnZpY2U7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nXG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJzdGFydC1sYXlvdXRcIiwgKGUpID0+IHRoaXMucG9zaXRpb25QYWRkaW5nKGUpKSxcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5hbGlnbkNhcHRpb25zKGUpKSxcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcInN0YXJ0LWxheW91dFwiLCAoZSkgPT4gdGhpcy5wb3NpdGlvbkNhcHRpb25zKGUpKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICB9XG4gIHBvc2l0aW9uUGFkZGluZyhjdHgpIHtcbiAgICBjb25zdCB7IHNocmlua1JlY3QgfSA9IGN0eDtcbiAgICBjb25zdCB7IHBhZGRpbmcgfSA9IHRoaXMuY2hhcnRMaWtlO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcubGVmdCwgXCJsZWZ0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcudG9wLCBcInRvcFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCBcInJpZ2h0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcuYm90dG9tLCBcImJvdHRvbVwiKTtcbiAgICByZXR1cm4geyAuLi5jdHgsIHNocmlua1JlY3QgfTtcbiAgfVxuICBwb3NpdGlvbkNhcHRpb25zKGN0eCkge1xuICAgIGNvbnN0IHsgc2hyaW5rUmVjdCwgcG9zaXRpb25zLCBwYWRkaW5nIH0gPSBjdHg7XG4gICAgY29uc3QgeyB0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlLCB0aXRsZVBhZGRpbmcgfSA9IHRoaXMuY2hhcnRMaWtlO1xuICAgIGNvbnN0IHBhZGRlZFNocmlua1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCkuc2hyaW5rKHRpdGxlUGFkZGluZyk7XG4gICAgY29uc3QgbmV3U2hyaW5rUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcbiAgICBjb25zdCB1cGRhdGVDYXB0aW9uID0gKGNhcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRDYXB0aW9uSGVpZ2h0ID0gc2hyaW5rUmVjdC5oZWlnaHQgLyAxMDtcbiAgICAgIGNvbnN0IGNhcHRpb25MaW5lSGVpZ2h0ID0gY2FwdGlvbi5saW5lSGVpZ2h0ID8/IGNhcHRpb24uZm9udFNpemUgKiBUZXh0LmRlZmF1bHRMaW5lSGVpZ2h0UmF0aW87XG4gICAgICBjb25zdCBtYXhXaWR0aCA9IHNocmlua1JlY3Qud2lkdGg7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heChjYXB0aW9uTGluZUhlaWdodCwgZGVmYXVsdENhcHRpb25IZWlnaHQpO1xuICAgICAgY2FwdGlvbi5jb21wdXRlVGV4dFdyYXAobWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgfTtcbiAgICBjb25zdCBjb21wdXRlWCA9IChhbGlnbikgPT4ge1xuICAgICAgaWYgKGFsaWduID09PSBcImxlZnRcIikge1xuICAgICAgICByZXR1cm4gcGFkZGVkU2hyaW5rUmVjdC54O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIHJldHVybiBwYWRkZWRTaHJpbmtSZWN0LnggKyBwYWRkZWRTaHJpbmtSZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gXCJjZW50ZXJcIikge1xuICAgICAgICBMb2dnZXIuZXJyb3IoYGludmFsaWQgdGV4dEFsaWduIHZhbHVlOiAke2FsaWdufWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZGRlZFNocmlua1JlY3QueCArIHBhZGRlZFNocmlua1JlY3Qud2lkdGggLyAyO1xuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb25Ub3BBbmRTaHJpbmtCQm94ID0gKGNhcHRpb24sIHNwYWNpbmcpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VZID0gcGFkZGVkU2hyaW5rUmVjdC55O1xuICAgICAgY2FwdGlvbi5ub2RlLnggPSBjb21wdXRlWChjYXB0aW9uLnRleHRBbGlnbik7XG4gICAgICBjYXB0aW9uLm5vZGUueSA9IGJhc2VZO1xuICAgICAgY2FwdGlvbi5ub2RlLnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgICB1cGRhdGVDYXB0aW9uKGNhcHRpb24pO1xuICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5nZXRCQm94KCk7XG4gICAgICBjb25zdCBiYm94SGVpZ2h0ID0gTWF0aC5jZWlsKGJib3gueSAtIGJhc2VZICsgYmJveC5oZWlnaHQgKyBzcGFjaW5nKTtcbiAgICAgIGlmIChjYXB0aW9uLmxheW91dFN0eWxlID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgbmV3U2hyaW5rUmVjdC5zaHJpbmsoYmJveEhlaWdodCArIDIgKiB0aXRsZVBhZGRpbmcsIFwidG9wXCIpO1xuICAgICAgICBwYWRkZWRTaHJpbmtSZWN0LnNocmluayhiYm94SGVpZ2h0LCBcInRvcFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYm94O1xuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb25Cb3R0b21BbmRTaHJpbmtCQm94ID0gKGNhcHRpb24sIHNwYWNpbmcpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VZID0gcGFkZGVkU2hyaW5rUmVjdC55ICsgcGFkZGVkU2hyaW5rUmVjdC5oZWlnaHQ7XG4gICAgICBjYXB0aW9uLm5vZGUueCA9IGNvbXB1dGVYKGNhcHRpb24udGV4dEFsaWduKTtcbiAgICAgIGNhcHRpb24ubm9kZS55ID0gYmFzZVk7XG4gICAgICBjYXB0aW9uLm5vZGUudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcbiAgICAgIHVwZGF0ZUNhcHRpb24oY2FwdGlvbik7XG4gICAgICBjb25zdCBiYm94ID0gY2FwdGlvbi5ub2RlLmdldEJCb3goKTtcbiAgICAgIGNvbnN0IGJib3hIZWlnaHQgPSBNYXRoLmNlaWwoYmFzZVkgLSBiYm94LnkgKyBzcGFjaW5nKTtcbiAgICAgIGlmIChjYXB0aW9uLmxheW91dFN0eWxlID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgbmV3U2hyaW5rUmVjdC5zaHJpbmsoYmJveEhlaWdodCArIDIgKiB0aXRsZVBhZGRpbmcsIFwiYm90dG9tXCIpO1xuICAgICAgICBwYWRkZWRTaHJpbmtSZWN0LnNocmluayhiYm94SGVpZ2h0LCBcImJvdHRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYm94O1xuICAgIH07XG4gICAgdGl0bGUubm9kZS52aXNpYmxlID0gdGl0bGUuZW5hYmxlZDtcbiAgICBzdWJ0aXRsZS5ub2RlLnZpc2libGUgPSBzdWJ0aXRsZS5lbmFibGVkO1xuICAgIGZvb3Rub3RlLm5vZGUudmlzaWJsZSA9IGZvb3Rub3RlLmVuYWJsZWQ7XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHsgc3BhY2luZyA9IHN1YnRpdGxlLmVuYWJsZWQgPyBDYXB0aW9uLlNNQUxMX1BBRERJTkcgOiBDYXB0aW9uLkxBUkdFX1BBRERJTkcgfSA9IHRpdGxlO1xuICAgICAgcG9zaXRpb25zLnRpdGxlID0gcG9zaXRpb25Ub3BBbmRTaHJpbmtCQm94KHRpdGxlLCBzcGFjaW5nKTtcbiAgICB9XG4gICAgaWYgKHN1YnRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIHBvc2l0aW9ucy5zdWJ0aXRsZSA9IHBvc2l0aW9uVG9wQW5kU2hyaW5rQkJveChzdWJ0aXRsZSwgc3VidGl0bGUuc3BhY2luZyA/PyAwKTtcbiAgICB9XG4gICAgaWYgKGZvb3Rub3RlLmVuYWJsZWQpIHtcbiAgICAgIHBvc2l0aW9ucy5mb290bm90ZSA9IHBvc2l0aW9uQm90dG9tQW5kU2hyaW5rQkJveChmb290bm90ZSwgZm9vdG5vdGUuc3BhY2luZyA/PyAwKTtcbiAgICB9XG4gICAgcGFkZGluZy50aXRsZSA9IHRpdGxlUGFkZGluZztcbiAgICByZXR1cm4geyAuLi5jdHgsIHNocmlua1JlY3Q6IG5ld1Nocmlua1JlY3QsIHBvc2l0aW9ucyB9O1xuICB9XG4gIGFsaWduQ2FwdGlvbnMoY3R4KSB7XG4gICAgY29uc3QgeyByZWN0IH0gPSBjdHguc2VyaWVzO1xuICAgIGNvbnN0IHsgdGl0bGUsIHN1YnRpdGxlLCBmb290bm90ZSwgdGl0bGVQYWRkaW5nIH0gPSB0aGlzLmNoYXJ0TGlrZTtcbiAgICBmb3IgKGNvbnN0IGNhcHRpb24gb2YgW3RpdGxlLCBzdWJ0aXRsZSwgZm9vdG5vdGVdKSB7XG4gICAgICBpZiAoY2FwdGlvbi5sYXlvdXRTdHlsZSAhPT0gXCJvdmVybGF5XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNhcHRpb24udGV4dEFsaWduID09PSBcImxlZnRcIikge1xuICAgICAgICBjYXB0aW9uLm5vZGUueCA9IHJlY3QueCArIHRpdGxlUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoY2FwdGlvbi50ZXh0QWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICBjb25zdCBiYm94ID0gY2FwdGlvbi5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgY2FwdGlvbi5ub2RlLnggPSByZWN0LnggKyByZWN0LndpZHRoIC0gYmJveC53aWR0aCAtIHRpdGxlUGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZS9kYXRhV2luZG93UHJvY2Vzc29yLnRzXG52YXIgRGF0YVdpbmRvd1Byb2Nlc3NvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFTZXJ2aWNlLCB1cGRhdGVTZXJ2aWNlLCB6b29tTWFuYWdlcikge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlID0gdXBkYXRlU2VydmljZTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyID0gem9vbU1hbmFnZXI7XG4gICAgdGhpcy5kaXJ0eVpvb20gPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEF4aXNab29tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1zb3VyY2UtY2hhbmdlXCIsICgpID0+IHRoaXMub25EYXRhU291cmNlQ2hhbmdlKCkpLFxuICAgICAgdGhpcy5kYXRhU2VydmljZS5hZGRMaXN0ZW5lcihcImRhdGEtbG9hZFwiLCAoKSA9PiB0aGlzLm9uRGF0YUxvYWQoKSksXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1lcnJvclwiLCAoKSA9PiB0aGlzLm9uRGF0YUVycm9yKCkpLFxuICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwidXBkYXRlLWNvbXBsZXRlXCIsICgpID0+IHRoaXMub25VcGRhdGVDb21wbGV0ZSgpKSxcbiAgICAgIHRoaXMuem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB0aGlzLm9uWm9vbUNoYW5nZSgpKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICB9XG4gIG9uRGF0YUxvYWQoKSB7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgxIC8qIFVQREFURV9EQVRBICovKTtcbiAgfVxuICBvbkRhdGFFcnJvcigpIHtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8pO1xuICB9XG4gIG9uRGF0YVNvdXJjZUNoYW5nZSgpIHtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IHRydWU7XG4gIH1cbiAgb25VcGRhdGVDb21wbGV0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZGlydHlab29tICYmICF0aGlzLmRpcnR5RGF0YVNvdXJjZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZVdpbmRvdygpLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgfVxuICBvblpvb21DaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXJ0eVpvb20gPSB0cnVlO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVdpbmRvdygpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVNlcnZpY2UuaXNMYXp5KCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuZ2V0VmFsaWRBeGlzKCk7XG4gICAgbGV0IHdpbmRvdzI7XG4gICAgbGV0IHNob3VsZFJlZnJlc2ggPSB0cnVlO1xuICAgIGlmIChheGlzKSB7XG4gICAgICBjb25zdCB6b29tMiA9IHRoaXMuem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20oYXhpcy5pZCk7XG4gICAgICB3aW5kb3cyID0gdGhpcy5nZXRBeGlzV2luZG93KGF4aXMsIHpvb20yKTtcbiAgICAgIHNob3VsZFJlZnJlc2ggPSB0aGlzLnNob3VsZFJlZnJlc2goYXhpcywgem9vbTIpO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5Wm9vbSA9IGZhbHNlO1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gZmFsc2U7XG4gICAgaWYgKCFzaG91bGRSZWZyZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UubG9hZCh7IHdpbmRvd1N0YXJ0OiB3aW5kb3cyPy5taW4sIHdpbmRvd0VuZDogd2luZG93Mj8ubWF4IH0pO1xuICB9XG4gIGdldFZhbGlkQXhpcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMudHlwZSA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIHNob3VsZFJlZnJlc2goYXhpcywgem9vbTIpIHtcbiAgICBpZiAodGhpcy5kaXJ0eURhdGFTb3VyY2UpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuZGlydHlab29tKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxhc3Rab29tID0gdGhpcy5sYXN0QXhpc1pvb21zLmdldChheGlzLmlkKTtcbiAgICBpZiAobGFzdFpvb20gJiYgem9vbTIubWluID09PSBsYXN0Wm9vbS5taW4gJiYgem9vbTIubWF4ID09PSBsYXN0Wm9vbS5tYXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QXhpc1pvb21zLnNldChheGlzLmlkLCB6b29tMik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0QXhpc1dpbmRvdyhheGlzLCB6b29tMikge1xuICAgIGNvbnN0IGRvbWFpbiA9IGF4aXMuc2NhbGUuZ2V0RG9tYWluPy4oKTtcbiAgICBpZiAoIXpvb20yIHx8ICFkb21haW4gfHwgZG9tYWluLmxlbmd0aCA9PT0gMCB8fCBpc05hTihOdW1iZXIoZG9tYWluWzBdKSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZGlmZjIgPSBOdW1iZXIoZG9tYWluWzFdKSAtIE51bWJlcihkb21haW5bMF0pO1xuICAgIGNvbnN0IG1pbiA9IG5ldyBEYXRlKE51bWJlcihkb21haW5bMF0pICsgZGlmZjIgKiB6b29tMi5taW4pO1xuICAgIGNvbnN0IG1heCA9IG5ldyBEYXRlKE51bWJlcihkb21haW5bMF0pICsgZGlmZjIgKiB6b29tMi5tYXgpO1xuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZS9vdmVybGF5c1Byb2Nlc3Nvci50c1xudmFyIE92ZXJsYXlzUHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydExpa2UsIG92ZXJsYXlzLCBkYXRhU2VydmljZSwgbGF5b3V0U2VydmljZSwgbG9jYWxlTWFuYWdlciwgYW5pbWF0aW9uTWFuYWdlciwgZG9tTWFuYWdlcikge1xuICAgIHRoaXMuY2hhcnRMaWtlID0gY2hhcnRMaWtlO1xuICAgIHRoaXMub3ZlcmxheXMgPSBvdmVybGF5cztcbiAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgdGhpcy5sYXlvdXRTZXJ2aWNlID0gbGF5b3V0U2VydmljZTtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLm92ZXJsYXlFbGVtID0gdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgXCJvdmVybGF5XCIpO1xuICAgIHRoaXMub3ZlcmxheUVsZW0ucm9sZSA9IFwic3RhdHVzXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcmlhQXRvbWljID0gXCJmYWxzZVwiO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uYXJpYUxpdmUgPSBcInBvbGl0ZVwiO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LnRvZ2dsZShERUZBVUxUX09WRVJMQVlfQ0xBU1MpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHRoaXMubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5vbkxheW91dENvbXBsZXRlKGUpKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoXCJvdmVybGF5c1wiKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm92ZXJsYXlcIik7XG4gIH1cbiAgb25MYXlvdXRDb21wbGV0ZSh7IHNlcmllczogeyByZWN0IH0gfSkge1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IHRoaXMuZGF0YVNlcnZpY2UuaXNMb2FkaW5nKCk7XG4gICAgY29uc3QgaGFzRGF0YSA9IHRoaXMuY2hhcnRMaWtlLnNlcmllcy5zb21lKChzKSA9PiBzLmhhc0RhdGEpO1xuICAgIGNvbnN0IGFueVNlcmllc1Zpc2libGUgPSB0aGlzLmNoYXJ0TGlrZS5zZXJpZXMuc29tZSgocykgPT4gcy52aXNpYmxlKTtcbiAgICBpZiAodGhpcy5vdmVybGF5cy5kYXJrVGhlbWUpIHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LmFkZChERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyk7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICB0aGlzLnRvZ2dsZU92ZXJsYXkodGhpcy5vdmVybGF5cy5sb2FkaW5nLCByZWN0LCBpc0xvYWRpbmcpO1xuICAgIHRoaXMudG9nZ2xlT3ZlcmxheSh0aGlzLm92ZXJsYXlzLm5vRGF0YSwgcmVjdCwgIWlzTG9hZGluZyAmJiAhaGFzRGF0YSk7XG4gICAgdGhpcy50b2dnbGVPdmVybGF5KHRoaXMub3ZlcmxheXMubm9WaXNpYmxlU2VyaWVzLCByZWN0LCBoYXNEYXRhICYmICFhbnlTZXJpZXNWaXNpYmxlKTtcbiAgfVxuICB0b2dnbGVPdmVybGF5KG92ZXJsYXksIHNlcmllc1JlY3QsIHZpc2libGUpIHtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmFyaWFIaWRkZW4gPSAoIXZpc2libGUpLnRvU3RyaW5nKCk7XG4gICAgaWYgKHZpc2libGUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQyID0gb3ZlcmxheS5nZXRFbGVtZW50KHRoaXMuYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sb2NhbGVNYW5hZ2VyLCBzZXJpZXNSZWN0KTtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdmVybGF5LnJlbW92ZUVsZW1lbnQoKCkgPT4ge1xuICAgICAgICB0aGlzLm92ZXJsYXlFbGVtLmlubmVyVGV4dCA9IFwiXFx4QTBcIjtcbiAgICAgIH0sIHRoaXMuYW5pbWF0aW9uTWFuYWdlcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydC50c1xudmFyIGRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwib3B0c1wiKTtcbnZhciBTZXJpZXNBcmVhID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYWRkaW5nID0gbmV3IFBhZGRpbmcoMCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNBcmVhLnByb3RvdHlwZSwgXCJjbGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzQXJlYS5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbnZhciBfQ2hhcnQgPSBjbGFzcyBfQ2hhcnQgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuc2VyaWVzUm9vdCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1yb290YCB9KTtcbiAgICB0aGlzLmhpZ2hsaWdodFJvb3QgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0taGlnaGxpZ2h0LXJvb3RgLFxuICAgICAgbGF5ZXI6IHRydWUsXG4gICAgICB6SW5kZXg6IDUgLyogU0VSSUVTX0hJR0hMSUdIVF9aSU5ERVggKi8sXG4gICAgICBub25FbXB0eUNoaWxkRGVyaXZlZFpJbmRleDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYW5ub3RhdGlvbi1yb290YCxcbiAgICAgIGxheWVyOiB0cnVlLFxuICAgICAgekluZGV4OiAxMCAvKiBTRVJJRVNfQU5OT1RBVElPTl9aSU5ERVggKi9cbiAgICB9KTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKCk7XG4gICAgdGhpcy5leHRyYURlYnVnU3RhdHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLl9maXJzdEF1dG9TaXplID0gdHJ1ZTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZygyMCk7XG4gICAgdGhpcy50aXRsZVBhZGRpbmcgPSAwO1xuICAgIHRoaXMuc2VyaWVzQXJlYSA9IG5ldyBTZXJpZXNBcmVhKCk7XG4gICAgdGhpcy50aXRsZSA9IG5ldyBDYXB0aW9uKCk7XG4gICAgdGhpcy5zdWJ0aXRsZSA9IG5ldyBDYXB0aW9uKCk7XG4gICAgdGhpcy5mb290bm90ZSA9IG5ldyBDYXB0aW9uKCk7XG4gICAgdGhpcy5rZXlib2FyZCA9IG5ldyBLZXlib2FyZCgpO1xuICAgIHRoaXMubW9kZSA9IFwic3RhbmRhbG9uZVwiO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2tpcFN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLl9kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlID0gXCJpbml0aWFsXCI7XG4gICAgdGhpcy5tb2R1bGVzTWFuYWdlciA9IG5ldyBNb2R1bGVzTWFuYWdlcigpO1xuICAgIC8vIEZJWE1FOiB6b29tTWFuYWdlciBzaG91bGQgYmUgb3duZWQgYnkgY3R4LCBidXQgaXQgY2FuJ3QgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IENhcnRlc2lhbkNoYXJ0Lm9uQXhpc0NoYW5nZSBiZWZvcmUgY3R4IGlzIGluaXRpYWxpc2VkXG4gICAgdGhpcy56b29tTWFuYWdlciA9IG5ldyBab29tTWFuYWdlcigpO1xuICAgIHRoaXMucHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMucXVldWVkVXNlck9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCA9IDA7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZU5vUmVuZGVyQ291bnQgPSAwO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPSA3IC8qIE5PTkUgKi87XG4gICAgdGhpcy51cGRhdGVTaG9ydGN1dENvdW50ID0gMDtcbiAgICB0aGlzLnNlcmllc1RvVXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLnVwZGF0ZU11dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzID0ge307XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHJpZ2dlciA9IGRlYm91bmNlZENhbGxiYWNrKGFzeW5jICh7IGNvdW50IH0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVNdXRleC5hY3F1aXJlKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBlcmZvcm1VcGRhdGUoY291bnQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIExvZ2dlci5lcnJvcihcInVwZGF0ZSBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU3BsaXRzID0ge307XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICB0aGlzLm9uU2VyaWVzTm9kZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNOb2RlQ2xpY2tFdmVudCA9IHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwic2VyaWVzTm9kZUNsaWNrXCJcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VyaWVzTm9kZUNsaWNrRXZlbnQsIFwic2VyaWVzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIC8vIFNob3VsZCBkaXNwbGF5IHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nXG4gICAgICAgIGdldDogKCkgPT4gZXZlbnQuc2VyaWVzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KHNlcmllc05vZGVDbGlja0V2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc05vZGVEb3VibGVDbGljayA9IHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwic2VyaWVzTm9kZURvdWJsZUNsaWNrXCJcbiAgICAgIH07XG4gICAgICB0aGlzLmZpcmVFdmVudChzZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xuICAgIH07XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHNlcmllcywgc2VyaWVzR3JvdXBpbmcsIG9sZEdyb3VwaW5nIH0gPSBldmVudDtcbiAgICAgIGlmIChzZXJpZXMucm9vdEdyb3VwLnBhcmVudCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5jaGFuZ2VHcm91cCh7XG4gICAgICAgIGludGVybmFsSWQ6IHNlcmllcy5pbnRlcm5hbElkLFxuICAgICAgICB0eXBlOiBzZXJpZXMudHlwZSxcbiAgICAgICAgcm9vdEdyb3VwOiBzZXJpZXMucm9vdEdyb3VwLFxuICAgICAgICBoaWdobGlnaHRHcm91cDogc2VyaWVzLmhpZ2hsaWdodEdyb3VwLFxuICAgICAgICBhbm5vdGF0aW9uR3JvdXA6IHNlcmllcy5hbm5vdGF0aW9uR3JvdXAsXG4gICAgICAgIGdldEdyb3VwWkluZGV4U3ViT3JkZXI6ICh0eXBlKSA9PiBzZXJpZXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlKSxcbiAgICAgICAgc2VyaWVzR3JvdXBpbmcsXG4gICAgICAgIG9sZEdyb3VwaW5nXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuZGF0YVByb2Nlc3NMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuY2hhcnRPcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBzY2VuZSA9IHJlc291cmNlcz8uc2NlbmU7XG4gICAgY29uc3QgY29udGFpbmVyID0gcmVzb3VyY2VzPy5jb250YWluZXI7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBHcm91cCh7IG5hbWU6IFwicm9vdFwiIH0pO1xuICAgIGNvbnN0IHRpdGxlR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInRpdGxlc1wiLCBsYXllcjogdHJ1ZSwgekluZGV4OiA4IC8qIFNFUklFU19MQUJFTF9aSU5ERVggKi8gfSk7XG4gICAgcm9vdC52aXNpYmxlID0gZmFsc2U7XG4gICAgcm9vdC5hcHBlbmQodGl0bGVHcm91cCk7XG4gICAgcm9vdC5hcHBlbmQodGhpcy5zZXJpZXNSb290KTtcbiAgICByb290LmFwcGVuZCh0aGlzLmhpZ2hsaWdodFJvb3QpO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMuYW5ub3RhdGlvblJvb3QpO1xuICAgIHRpdGxlR3JvdXAuYXBwZW5kKHRoaXMudGl0bGUubm9kZSk7XG4gICAgdGl0bGVHcm91cC5hcHBlbmQodGhpcy5zdWJ0aXRsZS5ub2RlKTtcbiAgICB0aXRsZUdyb3VwLmFwcGVuZCh0aGlzLmZvb3Rub3RlLm5vZGUpO1xuICAgIGNvbnN0IHsgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvIH0gPSBvcHRpb25zLnNwZWNpYWxPdmVycmlkZXM7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFRvb2x0aXAoKTtcbiAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlciA9IG5ldyBTZXJpZXNMYXllck1hbmFnZXIodGhpcy5zZXJpZXNSb290LCB0aGlzLmhpZ2hsaWdodFJvb3QsIHRoaXMuYW5ub3RhdGlvblJvb3QpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4ID0gbmV3IENoYXJ0Q29udGV4dCh0aGlzLCB7XG4gICAgICBzY2VuZSxcbiAgICAgIHJvb3QsXG4gICAgICBzeW5jTWFuYWdlcjogbmV3IFN5bmNNYW5hZ2VyKHRoaXMpLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgdXBkYXRlQ2FsbGJhY2s6ICh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRzKSA9PiB0aGlzLnVwZGF0ZSh0eXBlLCBvcHRzKSxcbiAgICAgIHVwZGF0ZU11dGV4OiB0aGlzLnVwZGF0ZU11dGV4LFxuICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvXG4gICAgfSk7XG4gICAgdGhpcy5fZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5wYXJlbnRSZXNpemUoY3R4LmRvbU1hbmFnZXIuY29udGFpbmVyU2l6ZSkpXG4gICAgKTtcbiAgICB0aGlzLm92ZXJsYXlzID0gbmV3IENoYXJ0T3ZlcmxheXMoKTtcbiAgICAoX2EgPSB0aGlzLm92ZXJsYXlzLmxvYWRpbmcpLnJlbmRlcmVyID8/IChfYS5yZW5kZXJlciA9ICgpID0+IGdldExvYWRpbmdTcGlubmVyKHRoaXMub3ZlcmxheXMubG9hZGluZy5nZXRUZXh0KGN0eC5sb2NhbGVNYW5hZ2VyKSwgY3R4LmFuaW1hdGlvbk1hbmFnZXIuZGVmYXVsdER1cmF0aW9uKSk7XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW1xuICAgICAgbmV3IEJhc2VMYXlvdXRQcm9jZXNzb3IodGhpcywgY3R4LmxheW91dFNlcnZpY2UpLFxuICAgICAgbmV3IERhdGFXaW5kb3dQcm9jZXNzb3IodGhpcywgY3R4LmRhdGFTZXJ2aWNlLCBjdHgudXBkYXRlU2VydmljZSwgY3R4Lnpvb21NYW5hZ2VyKSxcbiAgICAgIG5ldyBPdmVybGF5c1Byb2Nlc3NvcihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5vdmVybGF5cyxcbiAgICAgICAgY3R4LmRhdGFTZXJ2aWNlLFxuICAgICAgICBjdHgubGF5b3V0U2VydmljZSxcbiAgICAgICAgY3R4LmxvY2FsZU1hbmFnZXIsXG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgICBjdHguZG9tTWFuYWdlclxuICAgICAgKVxuICAgIF07XG4gICAgdGhpcy5oaWdobGlnaHQgPSBuZXcgQ2hhcnRIaWdobGlnaHQoKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gdGhpcy5nZXRNb2R1bGVDb250ZXh0KCk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovLCB0aGlzLnNlcmllc1Jvb3QsIHRoaXMuY3R4LmF4aXNNYW5hZ2VyLmF4aXNHcmlkR3JvdXApO1xuICAgIGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcImhvcml6b250YWwtYXhlc1wiIC8qIEhPUklaT05UQUxfQVhFUyAqLyk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8pO1xuICAgIGNvbnN0IHRoaXNDaGFydCA9IHRoaXM7XG4gICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlciA9IG5ldyBTZXJpZXNBcmVhTWFuYWdlcihcbiAgICAgIHtcbiAgICAgICAgZmlyZUV2ZW50OiB0aGlzLmZpcmVFdmVudC5iaW5kKHRoaXNDaGFydCksXG4gICAgICAgIGdldCBwZXJmb3JtVXBkYXRlVHlwZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0NoYXJ0LnBlcmZvcm1VcGRhdGVUeXBlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3R4LFxuICAgICAgdGhpcy5nZXRDaGFydFR5cGUoKSxcbiAgICAgIHRoaXMudG9vbHRpcCxcbiAgICAgIHRoaXMuaGlnaGxpZ2h0LFxuICAgICAgdGhpcy5vdmVybGF5c1xuICAgICk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwicm9vdFwiLCByb290KTtcbiAgICB0aGlzLl9kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHguZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLWxvYWRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICB9KSxcbiAgICAgIHRoaXMudGl0bGUucmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDb250ZXh0KSxcbiAgICAgIHRoaXMuc3VidGl0bGUucmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDb250ZXh0KSxcbiAgICAgIHRoaXMuZm9vdG5vdGUucmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDb250ZXh0KSxcbiAgICAgIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJwYWdlLWxlZnRcIiwgKCkgPT4gdGhpcy5kZXN0cm95KCkpLFxuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tZnJhbWVcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZSg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gICAgICB9KSxcbiAgICAgIGN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXJpZXMubWFwKChzKSA9PiBzLmFuaW1hdGlvblN0YXRlPy50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKSk7XG4gICAgICAgIGNvbnN0IHNraXBBbmltYXRpb25zID0gdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlICE9PSBcImluaXRpYWxcIjtcbiAgICAgICAgdGhpcy51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSwgc2tpcEFuaW1hdGlvbnMgfSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5wYXJlbnRSZXNpemUoY3R4LmRvbU1hbmFnZXIuY29udGFpbmVyU2l6ZSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQyKSB7XG4gICAgcmV0dXJuIF9DaGFydC5jaGFydHNJbnN0YW5jZXMuZ2V0KGVsZW1lbnQyKTtcbiAgfVxuICAvKiogTk9URTogVGhpcyBpcyBleHBvc2VkIGZvciB1c2UgYnkgSW50ZWdyYXRlZCBjaGFydHMgb25seS4gKi9cbiAgZ2V0IGNhbnZhc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LnNjZW5lLmNhbnZhcy5lbGVtZW50O1xuICB9XG4gIGRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KSB7XG4gICAgdGhpcy5jdHguc2NlbmUuZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpO1xuICB9XG4gIGdldENhbnZhc0RhdGFVUkwoZmlsZUZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5zY2VuZS5nZXREYXRhVVJMKGZpbGVGb3JtYXQpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVkVXNlck9wdGlvbnMuYXQoLTEpID8/IHRoaXMuY2hhcnRPcHRpb25zLnVzZXJPcHRpb25zO1xuICB9XG4gIGdldE1vZHVsZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4O1xuICB9XG4gIGdldENhcHRpb25UZXh0KCkge1xuICAgIHJldHVybiBbdGhpcy50aXRsZSwgdGhpcy5zdWJ0aXRsZSwgdGhpcy5mb290bm90ZV0uZmlsdGVyKChjYXB0aW9uKSA9PiBjYXB0aW9uLmVuYWJsZWQgJiYgY2FwdGlvbi50ZXh0KS5tYXAoKGNhcHRpb24pID0+IGNhcHRpb24udGV4dCkuam9pbihcIi4gXCIpO1xuICB9XG4gIGdldEFyaWFMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYUFubm91bmNlQ2hhcnRcIiwgeyBzZXJpZXNDb3VudDogdGhpcy5zZXJpZXMubGVuZ3RoIH0pO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgPSBcImluaXRpYWxcIjtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiB0aGlzLnNlcmllcykge1xuICAgICAgc2VyaWVzLnJlc2V0QW5pbWF0aW9uKHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXhpcyBvZiB0aGlzLmF4ZXMpIHtcbiAgICAgIGF4aXMucmVzZXRBbmltYXRpb24odGhpcy5jaGFydEFuaW1hdGlvblBoYXNlKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgfVxuICBza2lwQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICB9XG4gIGRlc3Ryb3kob3B0cykge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzID0gb3B0cz8ua2VlcFRyYW5zZmVyYWJsZVJlc291cmNlcztcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPSA3IC8qIE5PTkUgKi87XG4gICAgdGhpcy5fZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgdGhpcy5wcm9jZXNzb3JzLmZvckVhY2goKHApID0+IHAuZGVzdHJveSgpKTtcbiAgICB0aGlzLnRvb2x0aXAuZGVzdHJveSh0aGlzLmN0eC5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLm92ZXJsYXlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICBpZiAoa2VlcFRyYW5zZmVyYWJsZVJlc291cmNlcykge1xuICAgICAgdGhpcy5jdHguc2NlbmUuc3RyaXAoKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgc2NlbmU6IHRoaXMuY3R4LnNjZW5lXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5zY2VuZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95U2VyaWVzKHRoaXMuc2VyaWVzKTtcbiAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGEpID0+IGEuZGVzdHJveSgpKTtcbiAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguZGVzdHJveSgpO1xuICAgIHRoaXMuem9vbU1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVxdWVzdEZhY3RvcnlVcGRhdGUoY2IpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQrKztcbiAgICB0aGlzLnVwZGF0ZU11dGV4LmFjcXVpcmUoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBhd2FpdCBjYih0aGlzKTtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQtLTtcbiAgICB9KS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gIH1cbiAgdXBkYXRlKHR5cGUgPSAwIC8qIEZVTEwgKi8sIG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlLFxuICAgICAgc2tpcEFuaW1hdGlvbnMsXG4gICAgICBzZXJpZXNUb1VwZGF0ZSA9IHRoaXMuc2VyaWVzLFxuICAgICAgbmV3QW5pbWF0aW9uQmF0Y2hcbiAgICB9ID0gb3B0cyA/PyB7fTtcbiAgICBpZiAoZm9yY2VOb2RlRGF0YVJlZnJlc2gpIHtcbiAgICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4gc2VyaWVzLm1hcmtOb2RlRGF0YURpcnR5KCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBzZXJpZXNUb1VwZGF0ZSkge1xuICAgICAgdGhpcy5zZXJpZXNUb1VwZGF0ZS5hZGQoc2VyaWVzKTtcbiAgICB9XG4gICAgaWYgKHNraXBBbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZXdBbmltYXRpb25CYXRjaCAmJiB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3NraXBTeW5jID0gb3B0cz8uc2tpcFN5bmMgPz8gZmFsc2U7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgbGV0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sgPz8gXCI8dW5rbm93bj5cIjtcbiAgICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXFwoW14pXSovZywgXCJcIik7XG4gICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnNbc3RhY2tdID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPCB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlKSB7XG4gICAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gdHlwZTtcbiAgICAgIHRoaXMucGVyZm9ybVVwZGF0ZVRyaWdnZXIuc2NoZWR1bGUob3B0cz8uYmFja09mZk1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcGVyZm9ybVVwZGF0ZShjb3VudCkge1xuICAgIGNvbnN0IHsgcGVyZm9ybVVwZGF0ZVR5cGUsIGV4dHJhRGVidWdTdGF0cywgX3BlcmZvcm1VcGRhdGVTcGxpdHM6IHNwbGl0cywgY3R4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmllc1RvVXBkYXRlID0gWy4uLnRoaXMuc2VyaWVzVG9VcGRhdGVdO1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPSA3IC8qIE5PTkUgKi87XG4gICAgdGhpcy5zZXJpZXNUb1VwZGF0ZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPT09IDAgJiYgcGVyZm9ybVVwZGF0ZVR5cGUgPCA2IC8qIFNDRU5FX1JFTkRFUiAqLykge1xuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RhcnRCYXRjaCh0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMpO1xuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIub25CYXRjaFN0b3AoKCkgPT4gdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlID0gXCJyZWFkeVwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LnBlcmZvcm1VcGRhdGUoKSAtIHN0YXJ0XCIsIENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV0pO1xuICAgIGxldCBwcmV2aW91c1NwbGl0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgc3BsaXRzLnN0YXJ0ID8/IChzcGxpdHMuc3RhcnQgPSBwcmV2aW91c1NwbGl0KTtcbiAgICBjb25zdCB1cGRhdGVTcGxpdHMgPSAoc3BsaXROYW1lKSA9PiB7XG4gICAgICBzcGxpdHNbc3BsaXROYW1lXSA/PyAoc3BsaXRzW3NwbGl0TmFtZV0gPSAwKTtcbiAgICAgIHNwbGl0c1tzcGxpdE5hbWVdICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJldmlvdXNTcGxpdDtcbiAgICAgIHByZXZpb3VzU3BsaXQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIGxldCB1cGRhdGVEZWZlcnJlZCA9IGZhbHNlO1xuICAgIHN3aXRjaCAocGVyZm9ybVVwZGF0ZVR5cGUpIHtcbiAgICAgIGNhc2UgMCAvKiBGVUxMICovOlxuICAgICAgICB0aGlzLnVwZGF0ZURPTSgpO1xuICAgICAgY2FzZSAxIC8qIFVQREFURV9EQVRBICovOlxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1MkIwN1xcdUZFMEZcIik7XG4gICAgICBjYXNlIDIgLyogUFJPQ0VTU19EQVRBICovOlxuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NEYXRhKCk7XG4gICAgICAgIHRoaXMuc2VyaWVzQXJlYU1hbmFnZXIuZGF0YUNoYW5nZWQoKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1ezFGM0VEfVwiKTtcbiAgICAgIGNhc2UgMyAvKiBQRVJGT1JNX0xBWU9VVCAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCgzIC8qIFBFUkZPUk1fTEFZT1VUICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrRmlyc3RBdXRvU2l6ZShzZXJpZXNUb1VwZGF0ZSkpIHtcbiAgICAgICAgICB1cGRhdGVEZWZlcnJlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzTGF5b3V0KCk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdTIzMTZcIik7XG4gICAgICBjYXNlIDQgLyogU0VSSUVTX1VQREFURSAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCg0IC8qIFNFUklFU19VUERBVEUgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNlcmllc1RvVXBkYXRlLm1hcCgoc2VyaWVzKSA9PiBzZXJpZXMudXBkYXRlKHsgc2VyaWVzUmVjdCB9KSkpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHV7MUY5MTR9XCIpO1xuICAgICAgY2FzZSA1IC8qIFBSRV9TQ0VORV9SRU5ERVIgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNSAvKiBQUkVfU0NFTkVfUkVOREVSICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY3R4LnVwZGF0ZVNlcnZpY2UuZGlzcGF0Y2hQcmVTY2VuZVJlbmRlcih0aGlzLmdldE1pblJlY3RzKCkpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHUyMTk2XCIpO1xuICAgICAgY2FzZSA2IC8qIFNDRU5FX1JFTkRFUiAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCg2IC8qIFNDRU5FX1JFTkRFUiAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmVuZEJhdGNoKCk7XG4gICAgICAgIGV4dHJhRGVidWdTdGF0c1tcInVwZGF0ZVNob3J0Y3V0Q291bnRcIl0gPSB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQ7XG4gICAgICAgIGF3YWl0IGN0eC5zY2VuZS5yZW5kZXIoeyBkZWJ1Z1NwbGl0VGltZXM6IHNwbGl0cywgZXh0cmFEZWJ1Z1N0YXRzLCBzZXJpZXNSZWN0OiB0aGlzLnNlcmllc1JlY3QgfSk7XG4gICAgICAgIHRoaXMuZXh0cmFEZWJ1Z1N0YXRzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNwbGl0cykge1xuICAgICAgICAgIGRlbGV0ZSBzcGxpdHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLmluY3JlbWVudERhdGFDb3VudGVyKFwic2NlbmVSZW5kZXJzXCIpO1xuICAgICAgY2FzZSA3IC8qIE5PTkUgKi86XG4gICAgICAgIHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlUmVxdWVzdG9ycyA9IHt9O1xuICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgaWYgKCF1cGRhdGVEZWZlcnJlZCkge1xuICAgICAgY3R4LnVwZGF0ZVNlcnZpY2UuZGlzcGF0Y2hVcGRhdGVDb21wbGV0ZSh0aGlzLmdldE1pblJlY3RzKCkpO1xuICAgIH1cbiAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmRlYnVnKFwiQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gZW5kXCIsIHtcbiAgICAgIGNoYXJ0OiB0aGlzLFxuICAgICAgZHVyYXRpb25NczogTWF0aC5yb3VuZCgoZW5kIC0gc3BsaXRzW1wic3RhcnRcIl0pICogMTAwKSAvIDEwMCxcbiAgICAgIGNvdW50LFxuICAgICAgcGVyZm9ybVVwZGF0ZVR5cGU6IENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaGVtZUNsYXNzTmFtZSgpIHtcbiAgICBjb25zdCB7IHRoZW1lIH0gPSB0aGlzLmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zO1xuICAgIGNvbnN0IHRoZW1lQ2xhc3NOYW1lUHJlZml4ID0gXCJhZy1jaGFydHMtdGhlbWUtXCI7XG4gICAgY29uc3QgdmFsaWRUaGVtZUNsYXNzTmFtZXMgPSBbYCR7dGhlbWVDbGFzc05hbWVQcmVmaXh9ZGVmYXVsdGAsIGAke3RoZW1lQ2xhc3NOYW1lUHJlZml4fWRlZmF1bHQtZGFya2BdO1xuICAgIGxldCB0aGVtZUNsYXNzTmFtZSA9IHZhbGlkVGhlbWVDbGFzc05hbWVzWzBdO1xuICAgIGxldCBpc0RhcmsgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGVtZUNsYXNzTmFtZSA9IHRoZW1lLnJlcGxhY2UoXCJhZy1cIiwgdGhlbWVDbGFzc05hbWVQcmVmaXgpO1xuICAgICAgaXNEYXJrID0gdGhlbWUuaW5jbHVkZXMoXCItZGFya1wiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVtZT8uYmFzZVRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGVtZUNsYXNzTmFtZSA9IHRoZW1lLmJhc2VUaGVtZS5yZXBsYWNlKFwiYWctXCIsIHRoZW1lQ2xhc3NOYW1lUHJlZml4KTtcbiAgICAgIGlzRGFyayA9IHRoZW1lLmJhc2VUaGVtZS5pbmNsdWRlcyhcIi1kYXJrXCIpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkVGhlbWVDbGFzc05hbWVzLmluY2x1ZGVzKHRoZW1lQ2xhc3NOYW1lKSkge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSBpc0RhcmsgPyB2YWxpZFRoZW1lQ2xhc3NOYW1lc1sxXSA6IHZhbGlkVGhlbWVDbGFzc05hbWVzWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldFRoZW1lQ2xhc3ModGhlbWVDbGFzc05hbWUpO1xuICB9XG4gIHVwZGF0ZURPTSgpIHtcbiAgICB0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NOYW1lKCk7XG4gICAgY29uc3QgeyBlbmFibGVkLCB0YWJJbmRleCB9ID0gdGhpcy5rZXlib2FyZDtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldFRhYkluZGV4KGVuYWJsZWQgPyB0YWJJbmRleCA/PyAwIDogLTEpO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmN0eC5zY2VuZS5jYW52YXMuZWxlbWVudCwgXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmN0eC5zY2VuZS5jYW52YXMuZWxlbWVudCwgXCJhcmlhLWxhYmVsXCIsIHRoaXMuZ2V0QXJpYUxhYmVsKCkpO1xuICB9XG4gIGNoZWNrVXBkYXRlU2hvcnRjdXQoY2hlY2tVcGRhdGVUeXBlKSB7XG4gICAgY29uc3QgbWF4U2hvcnRjdXRzID0gMztcbiAgICBpZiAodGhpcy51cGRhdGVTaG9ydGN1dENvdW50ID4gbWF4U2hvcnRjdXRzKSB7XG4gICAgICBMb2dnZXIud2FybihcbiAgICAgICAgYGV4Y2VlZGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXMgdXBkYXRlcyAoJHttYXhTaG9ydGN1dHMgKyAxfSksIGRpc2NhcmRpbmcgY2hhbmdlcyBhbmQgcmVuZGVyaW5nYCxcbiAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA8PSBjaGVja1VwZGF0ZVR5cGUpIHtcbiAgICAgIHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCsrO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaGVja0ZpcnN0QXV0b1NpemUoc2VyaWVzVG9VcGRhdGUpIHtcbiAgICBpZiAodGhpcy53aWR0aCAhPSBudWxsICYmIHRoaXMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9sYXN0QXV0b1NpemUpIHtcbiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fcGVyZm9ybVVwZGF0ZU5vUmVuZGVyQ291bnQrKztcbiAgICAgIGNvbnN0IGJhY2tPZmZNcyA9IChjb3VudCArIDEpICoqIDIgKiA0MDtcbiAgICAgIGlmIChjb3VudCA8IDgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLywgeyBzZXJpZXNUb1VwZGF0ZSwgYmFja09mZk1zIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKFwiQ2hhcnQuY2hlY2tGaXJzdEF1dG9TaXplKCkgLSBiYWNraW5nIG9mZiB1bnRpbCBmaXJzdCBzaXplIHVwZGF0ZVwiLCBiYWNrT2ZmTXMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmRlYnVnKFwiQ2hhcnQuY2hlY2tGaXJzdEF1dG9TaXplKCkgLSB0aW1lb3V0IGZvciBmaXJzdCBzaXplIHVwZGF0ZS5cIik7XG4gICAgfVxuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVOb1JlbmRlckNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgaWYgKG9sZFZhbHVlID09IG51bGwgJiYgbmV3VmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY3R4LmF4aXNNYW5hZ2VyLnVwZGF0ZUF4ZXMob2xkVmFsdWUgPz8gW10sIG5ld1ZhbHVlKTtcbiAgfVxuICBvblNlcmllc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBjb25zdCBzZXJpZXNUb0Rlc3Ryb3kgPSBvbGRWYWx1ZT8uZmlsdGVyKChzZXJpZXMpID0+ICFuZXdWYWx1ZS5pbmNsdWRlcyhzZXJpZXMpKSA/PyBbXTtcbiAgICB0aGlzLmRlc3Ryb3lTZXJpZXMoc2VyaWVzVG9EZXN0cm95KTtcbiAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlcj8uc2V0U2VyaWVzQ291bnQobmV3VmFsdWUubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBuZXdWYWx1ZSkge1xuICAgICAgaWYgKG9sZFZhbHVlPy5pbmNsdWRlcyhzZXJpZXMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChzZXJpZXMucm9vdEdyb3VwLnBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLnJlcXVlc3RHcm91cChzZXJpZXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhcnQgPSB0aGlzO1xuICAgICAgc2VyaWVzLmNoYXJ0ID0ge1xuICAgICAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnQubW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzTWluaUNoYXJ0KCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNlcmllc1JlY3QoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0LnNlcmllc1JlY3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlTGFiZWxzKCkge1xuICAgICAgICAgIHJldHVybiBjaGFydC5wbGFjZUxhYmVscygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2VyaWVzLnJlc2V0QW5pbWF0aW9uKHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSk7XG4gICAgICB0aGlzLmFkZFNlcmllc0xpc3RlbmVycyhzZXJpZXMpO1xuICAgICAgc2VyaWVzLmFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlcj8uc2VyaWVzQ2hhbmdlZChuZXdWYWx1ZSk7XG4gIH1cbiAgZGVzdHJveVNlcmllcyhhbGxTZXJpZXMpIHtcbiAgICBhbGxTZXJpZXM/LmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVDbGljayk7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5vZGVEb3VibGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ3JvdXBpbmdDaGFuZ2VkXCIsIHRoaXMuc2VyaWVzR3JvdXBpbmdDaGFuZ2VkKTtcbiAgICAgIHNlcmllcy5kZXN0cm95KCk7XG4gICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5yZWxlYXNlR3JvdXAoc2VyaWVzKTtcbiAgICAgIHNlcmllcy5jaGFydCA9IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuICBhZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKSB7XG4gICAgaWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInNlcmllc05vZGVDbGlja1wiKSkge1xuICAgICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVDbGljayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJzZXJpZXNOb2RlRG91YmxlQ2xpY2tcIikpIHtcbiAgICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xuICAgIH1cbiAgICBzZXJpZXMuYWRkRXZlbnRMaXN0ZW5lcihcImdyb3VwaW5nQ2hhbmdlZFwiLCB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCk7XG4gIH1cbiAgdXBkYXRlQWxsU2VyaWVzTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVDbGljayk7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5vZGVEb3VibGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMuYWRkU2VyaWVzTGlzdGVuZXJzKHNlcmllcyk7XG4gICAgfSk7XG4gIH1cbiAgYXNzaWduU2VyaWVzVG9BeGVzKCkge1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLmJvdW5kU2VyaWVzID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlcmllc0F4aXMgPSBzLmF4ZXNbYXhpcy5kaXJlY3Rpb25dO1xuICAgICAgICByZXR1cm4gc2VyaWVzQXhpcyA9PT0gYXhpcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzc2lnbkF4ZXNUb1NlcmllcygpIHtcbiAgICBjb25zdCBkaXJlY3Rpb25Ub0F4ZXNNYXAgPSBncm91cEJ5KHRoaXMuYXhlcywgKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uKTtcbiAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5kaXJlY3Rpb25zLmZvckVhY2goKGRpcmVjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb25BeGVzID0gZGlyZWN0aW9uVG9BeGVzTWFwW2RpcmVjdGlvbl07XG4gICAgICAgIGlmICghZGlyZWN0aW9uQXhlcykge1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICAgIGBubyBhdmFpbGFibGUgYXhpcyBmb3IgZGlyZWN0aW9uIFske2RpcmVjdGlvbn1dOyBjaGVjayBzZXJpZXMgYW5kIGF4ZXMgY29uZmlndXJhdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWVzS2V5cyA9IHNlcmllcy5nZXRLZXlzKGRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IG5ld0F4aXMgPSBkaXJlY3Rpb25BeGVzLmZpbmQoXG4gICAgICAgICAgKGF4aXMpID0+ICFheGlzLmtleXMubGVuZ3RoIHx8IHNlcmllc0tleXMuc29tZSgoa2V5KSA9PiBheGlzLmtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFuZXdBeGlzKSB7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgICAgYG5vIG1hdGNoaW5nIGF4aXMgZm9yIGRpcmVjdGlvbiBbJHtkaXJlY3Rpb259XSBhbmQga2V5cyBbJHtzZXJpZXNLZXlzfV07IGNoZWNrIHNlcmllcyBhbmQgYXhlcyBjb25maWd1cmF0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXJpZXMuYXhlc1tkaXJlY3Rpb25dID0gbmV3QXhpcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHBhcmVudFJlc2l6ZShzaXplKSB7XG4gICAgaWYgKHNpemUgPT0gbnVsbCB8fCB0aGlzLndpZHRoICE9IG51bGwgJiYgdGhpcy5oZWlnaHQgIT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzaXplO1xuICAgIHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQpO1xuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2F1dG9XaWR0aCA9IDAsIGF1dGhIZWlnaHQgPSAwXSA9IHRoaXMuX2xhc3RBdXRvU2l6ZSA/PyBbXTtcbiAgICBpZiAoYXV0b1dpZHRoID09PSB3aWR0aCAmJiBhdXRoSGVpZ2h0ID09PSBoZWlnaHQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fbGFzdEF1dG9TaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHRoaXMucmVzaXplKFwiU2l6ZU1vbml0b3JcIiwge30pO1xuICB9XG4gIHJlc2l6ZShzb3VyY2UsIG9wdHMpIHtcbiAgICBjb25zdCB7IHNjZW5lLCBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IGluV2lkdGgsIGluSGVpZ2h0LCBpbk1pbldpZHRoLCBpbk1pbkhlaWdodCB9ID0gb3B0cztcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldFNpemVPcHRpb25zKFxuICAgICAgaW5NaW5XaWR0aCA/PyB0aGlzLm1pbldpZHRoLFxuICAgICAgaW5NaW5IZWlnaHQgPz8gdGhpcy5taW5IZWlnaHQsXG4gICAgICBpbldpZHRoID8/IHRoaXMud2lkdGgsXG4gICAgICBpbkhlaWdodCA/PyB0aGlzLmhlaWdodFxuICAgICk7XG4gICAgY29uc3Qgd2lkdGggPSBpbldpZHRoID8/IHRoaXMud2lkdGggPz8gdGhpcy5fbGFzdEF1dG9TaXplPy5bMF07XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5IZWlnaHQgPz8gdGhpcy5oZWlnaHQgPz8gdGhpcy5fbGFzdEF1dG9TaXplPy5bMV07XG4gICAgdGhpcy5kZWJ1ZyhgQ2hhcnQucmVzaXplKCkgZnJvbSAke3NvdXJjZX1gLCB7IHdpZHRoLCBoZWlnaHQsIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcbiAgICBpZiAod2lkdGggPT0gbnVsbCB8fCBoZWlnaHQgPT0gbnVsbCB8fCAhaXNGaW5pdGVOdW1iZXIod2lkdGgpIHx8ICFpc0Zpbml0ZU51bWJlcihoZWlnaHQpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzY2VuZS5yZXNpemUod2lkdGgsIGhlaWdodCkpIHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgICAgIGxldCBza2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICBpZiAoKHRoaXMud2lkdGggPT0gbnVsbCB8fCB0aGlzLmhlaWdodCA9PSBudWxsKSAmJiB0aGlzLl9maXJzdEF1dG9TaXplKSB7XG4gICAgICAgIHNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpcnN0QXV0b1NpemUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUsIHNraXBBbmltYXRpb25zIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVEYXRhKCkge1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHMpID0+IHMuc2V0Q2hhcnREYXRhKHRoaXMuZGF0YSkpO1xuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gdGhpcy5tb2R1bGVzTWFuYWdlci5tYXBNb2R1bGVzKChtKSA9PiBtLnVwZGF0ZURhdGE/Lih7IGRhdGE6IHRoaXMuZGF0YSB9KSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUHJvbWlzZXMpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKCkge1xuICAgIGlmICh0aGlzLnNlcmllcy5zb21lKChzKSA9PiBzLmNhbkhhdmVBeGVzKSkge1xuICAgICAgdGhpcy5hc3NpZ25BeGVzVG9TZXJpZXMoKTtcbiAgICAgIGNvbnN0IHN5bmNNb2R1bGUgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcInN5bmNcIik7XG4gICAgICBpZiAoc3luY01vZHVsZT8uZW5hYmxlZCkge1xuICAgICAgICBzeW5jTW9kdWxlLnN5bmNBeGVzKHRoaXMuX3NraXBTeW5jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXNzaWduU2VyaWVzVG9BeGVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGFDb250cm9sbGVyID0gbmV3IERhdGFDb250cm9sbGVyKHRoaXMubW9kZSk7XG4gICAgY29uc3Qgc2VyaWVzUHJvbWlzZXMgPSB0aGlzLnNlcmllcy5tYXAoKHMpID0+IHMucHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpKTtcbiAgICBjb25zdCBtb2R1bGVQcm9taXNlcyA9IHRoaXMubW9kdWxlc01hbmFnZXIubWFwTW9kdWxlcygobSkgPT4gbS5wcm9jZXNzRGF0YT8uKHsgZGF0YUNvbnRyb2xsZXIgfSkpO1xuICAgIGRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbLi4uc2VyaWVzUHJvbWlzZXMsIC4uLm1vZHVsZVByb21pc2VzXSk7XG4gICAgZm9yIChjb25zdCB7IGxlZ2VuZFR5cGUsIGxlZ2VuZCB9IG9mIHRoaXMubW9kdWxlc01hbmFnZXIubGVnZW5kcygpKSB7XG4gICAgICBsZWdlbmQuZGF0YSA9IHRoaXMuZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlLCB0aGlzLm1vZGUgIT09IFwiaW50ZWdyYXRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xpc3RlbmVycy5mb3JFYWNoKChyZXNvbHZlKSA9PiByZXNvbHZlKCkpO1xuICAgIHRoaXMuZGF0YVByb2Nlc3NMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBwbGFjZUxhYmVscygpIHtcbiAgICBjb25zdCB2aXNpYmxlU2VyaWVzID0gW107XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBpZiAoIXNlcmllcy52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IHNlcmllcy5nZXRMYWJlbERhdGEoKTtcbiAgICAgIGlmIChpc1BvaW50TGFiZWxEYXR1bShsYWJlbERhdGE/LlswXSkpIHtcbiAgICAgICAgZGF0YS5wdXNoKGxhYmVsRGF0YSk7XG4gICAgICAgIHZpc2libGVTZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nO1xuICAgIGNvbnN0IGxhYmVscyA9IHNlcmllc1JlY3QgJiYgZGF0YS5sZW5ndGggPiAwID8gcGxhY2VMYWJlbHMoZGF0YSwge1xuICAgICAgeDogLWxlZnQsXG4gICAgICB5OiAtdG9wLFxuICAgICAgd2lkdGg6IHNlcmllc1JlY3Qud2lkdGggKyBsZWZ0ICsgcmlnaHQsXG4gICAgICBoZWlnaHQ6IHNlcmllc1JlY3QuaGVpZ2h0ICsgdG9wICsgYm90dG9tXG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4gbmV3IE1hcChsYWJlbHMubWFwKChsLCBpKSA9PiBbdmlzaWJsZVNlcmllc1tpXSwgbF0pKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUsIHdhcm5Db25mbGljdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbGVnZW5kRGF0YSA9IHRoaXMuc2VyaWVzLmZpbHRlcigocykgPT4gcy5wcm9wZXJ0aWVzLnNob3dJbkxlZ2VuZCkuZmxhdE1hcCgocykgPT4gcy5nZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpKTtcbiAgICBjb25zdCBpc0NhdGVnb3J5TGVnZW5kRGF0YSA9IChkYXRhKSA9PiBkYXRhLmV2ZXJ5KChkKSA9PiBkLmxlZ2VuZFR5cGUgPT09IFwiY2F0ZWdvcnlcIik7XG4gICAgaWYgKHdhcm5Db25mbGljdHMgJiYgaXNDYXRlZ29yeUxlZ2VuZERhdGEobGVnZW5kRGF0YSkpIHtcbiAgICAgIGNvbnN0IHNlcmllc01hcmtlckZpbGxzID0ge307XG4gICAgICBjb25zdCBzZXJpZXNUeXBlTWFwID0gbmV3IE1hcCh0aGlzLnNlcmllcy5tYXAoKHMpID0+IFtzLmlkLCBzLnR5cGVdKSk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIHN5bWJvbHM6IFt7IG1hcmtlciB9XSxcbiAgICAgICAgbGFiZWxcbiAgICAgIH0gb2YgbGVnZW5kRGF0YSkge1xuICAgICAgICBpZiAobWFya2VyLmZpbGwgPT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZTIgPSBzZXJpZXNUeXBlTWFwLmdldChzZXJpZXNJZCk7XG4gICAgICAgIGNvbnN0IG1hcmtlckZpbGwgPSBzZXJpZXNNYXJrZXJGaWxsc1tzZXJpZXNUeXBlMl0gPz8gKHNlcmllc01hcmtlckZpbGxzW3Nlcmllc1R5cGUyXSA9IHt9KTtcbiAgICAgICAgbWFya2VyRmlsbFtfYSA9IGxhYmVsLnRleHRdID8/IChtYXJrZXJGaWxsW19hXSA9IG1hcmtlci5maWxsKTtcbiAgICAgICAgaWYgKG1hcmtlckZpbGxbbGFiZWwudGV4dF0gIT09IG1hcmtlci5maWxsKSB7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgICAgYGxlZ2VuZCBpdGVtICcke2xhYmVsLnRleHR9JyBoYXMgbXVsdGlwbGUgZmlsbCBjb2xvcnMsIHRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmREYXRhO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NMYXlvdXQoKSB7XG4gICAgY29uc3Qgb2xkUmVjdCA9IHRoaXMuYW5pbWF0aW9uUmVjdDtcbiAgICBhd2FpdCB0aGlzLnBlcmZvcm1MYXlvdXQoKTtcbiAgICBpZiAob2xkUmVjdCAmJiAhdGhpcy5hbmltYXRpb25SZWN0Py5lcXVhbHMob2xkUmVjdCkpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gc2VyaWVzUmVjdFwiLCB0aGlzLnNlcmllc1JlY3QpO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmN0eC5zY2VuZTtcbiAgICBsZXQgY3R4ID0geyBzaHJpbmtSZWN0OiBuZXcgQkJveCgwLCAwLCB3aWR0aCwgaGVpZ2h0KSwgcG9zaXRpb25zOiB7fSwgcGFkZGluZzoge30gfTtcbiAgICBjdHggPSB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoUGVyZm9ybUxheW91dChcInN0YXJ0LWxheW91dFwiLCBjdHgpO1xuICAgIGN0eCA9IHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hQZXJmb3JtTGF5b3V0KFwiYmVmb3JlLXNlcmllc1wiLCBjdHgpO1xuICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1vZHVsZXMoKSkge1xuICAgICAgaWYgKG0ucGVyZm9ybUxheW91dCAhPSBudWxsKSB7XG4gICAgICAgIGN0eCA9IGF3YWl0IG0ucGVyZm9ybUxheW91dChjdHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3R4LnNocmlua1JlY3Q7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclVwZGF0ZSh0aW1lb3V0TXMgPSAxZTQsIGZhaWxPblRpbWVvdXQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50ID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVNdXRleC53YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKTtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgIT09IDcgLyogTk9ORSAqLykge1xuICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDaGFydC53YWl0Rm9yVXBkYXRlKCkgdGltZW91dCBvZiAke3RpbWVvdXRNc30gcmVhY2hlZCAtIGZpcnN0IGNoYXJ0IHVwZGF0ZSB0YWtpbmcgdG9vIGxvbmcuYDtcbiAgICAgICAgaWYgKGZhaWxPblRpbWVvdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBzbGVlcCg1MCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlTXV0ZXgud2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCk7XG4gIH1cbiAgd2FpdEZvckRhdGFQcm9jZXNzKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuZGF0YVByb2Nlc3NMaXN0ZW5lcnMuYWRkKHJlc29sdmUpO1xuICAgICAgaWYgKGlzTnVtYmVyKHRpbWVvdXQpKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRhdGFQcm9jZXNzTGlzdGVuZXJzLmhhcyhyZXNvbHZlKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc0xpc3RlbmVycy5kZWxldGUocmVzb2x2ZSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRNaW5SZWN0cygpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY3R4LnNjZW5lO1xuICAgIGNvbnN0IG1pblJlY3RzID0gdGhpcy5zZXJpZXMubWFwKChzZXJpZXMpID0+IHNlcmllcy5nZXRNaW5SZWN0cyh3aWR0aCwgaGVpZ2h0KSkuZmlsdGVyKGlzRGVmaW5lZCk7XG4gICAgaWYgKG1pblJlY3RzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGxldCBtYXhWaXNpYmxlV2lkdGggPSAwO1xuICAgIGxldCBtYXhWaXNpYmxlSGVpZ2h0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHsgbWluUmVjdDogbWluUmVjdDIsIG1pblZpc2libGVSZWN0OiBtaW5WaXNpYmxlUmVjdDIgfSBvZiBtaW5SZWN0cykge1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgbWluUmVjdDIud2lkdGgpO1xuICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgobWF4SGVpZ2h0LCBtaW5SZWN0Mi5oZWlnaHQpO1xuICAgICAgbWF4VmlzaWJsZVdpZHRoID0gTWF0aC5tYXgobWF4VmlzaWJsZVdpZHRoLCBtaW5WaXNpYmxlUmVjdDIud2lkdGgpO1xuICAgICAgbWF4VmlzaWJsZUhlaWdodCA9IE1hdGgubWF4KG1heFZpc2libGVIZWlnaHQsIG1pblZpc2libGVSZWN0Mi5oZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBtaW5SZWN0ID0gbmV3IEJCb3goMCwgMCwgbWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgbGV0IG1pblZpc2libGVSZWN0ID0gbWluUmVjdC5jbG9uZSgpO1xuICAgIGlmIChtYXhWaXNpYmxlV2lkdGggPiAwICYmIG1heFZpc2libGVIZWlnaHQgPiAwKSB7XG4gICAgICBtaW5WaXNpYmxlUmVjdCA9IG5ldyBCQm94KDAsIDAsIG1heFZpc2libGVXaWR0aCwgbWF4VmlzaWJsZUhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB7IG1pblJlY3QsIG1pblZpc2libGVSZWN0IH07XG4gIH1cbiAgZmlsdGVyTWluaUNoYXJ0U2VyaWVzKHNlcmllcykge1xuICAgIHJldHVybiBzZXJpZXM/LmZpbHRlcigocykgPT4gcy5zaG93SW5NaW5pQ2hhcnQgIT09IGZhbHNlKTtcbiAgfVxuICBhcHBseU9wdGlvbnMobmV3Q2hhcnRPcHRpb25zKSB7XG4gICAgY29uc3QgaXNEaWZmZXJlbnRPcHRzID0gbmV3Q2hhcnRPcHRpb25zICE9PSB0aGlzLmNoYXJ0T3B0aW9ucztcbiAgICBjb25zdCBvbGRPcHRzID0gaXNEaWZmZXJlbnRPcHRzID8gdGhpcy5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucyA6IHt9O1xuICAgIGNvbnN0IG5ld09wdHMgPSBuZXdDaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucztcbiAgICBjb25zdCBkZWx0YU9wdGlvbnMgPSBuZXdDaGFydE9wdGlvbnMuZGlmZk9wdGlvbnMob2xkT3B0cyk7XG4gICAgaWYgKGRlbHRhT3B0aW9ucyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGRlYnVnKFwiQ2hhcnQuYXBwbHlPcHRpb25zKCkgLSBhcHBseWluZyBkZWx0YVwiLCBkZWx0YU9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZHVsZXNDaGFuZ2VkID0gdGhpcy5hcHBseU1vZHVsZXMobmV3T3B0cyk7XG4gICAgY29uc3Qgc2tpcCA9IFtcbiAgICAgIFwidHlwZVwiLFxuICAgICAgXCJkYXRhXCIsXG4gICAgICBcInNlcmllc1wiLFxuICAgICAgXCJsaXN0ZW5lcnNcIixcbiAgICAgIFwicHJlc2V0XCIsXG4gICAgICBcInRoZW1lXCIsXG4gICAgICBcImxlZ2VuZC5saXN0ZW5lcnNcIixcbiAgICAgIFwibmF2aWdhdG9yLm1pbmlDaGFydC5zZXJpZXNcIixcbiAgICAgIFwibmF2aWdhdG9yLm1pbmlDaGFydC5sYWJlbFwiLFxuICAgICAgXCJsb2NhbGUubG9jYWxlVGV4dFwiLFxuICAgICAgXCJheGVzXCIsXG4gICAgICBcInRvcG9sb2d5XCIsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBcImluaXRpYWxTdGF0ZVwiXG4gICAgXTtcbiAgICBpZiAoZGVsdGFPcHRpb25zLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycyh0aGlzLCBkZWx0YU9wdGlvbnMubGlzdGVuZXJzKTtcbiAgICB9XG4gICAganNvbkFwcGx5KHRoaXMsIGRlbHRhT3B0aW9ucywgeyBza2lwIH0pO1xuICAgIGxldCBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlO1xuICAgIGxldCBzZXJpZXNTdGF0dXMgPSBcIm5vLW9wXCI7XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5zZXJpZXMgIT0gbnVsbCkge1xuICAgICAgc2VyaWVzU3RhdHVzID0gdGhpcy5hcHBseVNlcmllcyh0aGlzLCBkZWx0YU9wdGlvbnMuc2VyaWVzLCBvbGRPcHRzPy5zZXJpZXMpO1xuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2VyaWVzU3RhdHVzID09PSBcInJlcGxhY2VkXCIpIHtcbiAgICAgIHRoaXMucmVzZXRBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFwcGx5QXhlcyh0aGlzLCBuZXdPcHRzLCBvbGRPcHRzLCBzZXJpZXNTdGF0dXMsIFtdLCB0cnVlKSkge1xuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGVsdGFPcHRpb25zLmRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRlbHRhT3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBpZiAoZGVsdGFPcHRpb25zLmxlZ2VuZD8ubGlzdGVuZXJzICYmIHRoaXMubW9kdWxlc01hbmFnZXIuaXNFbmFibGVkKFwibGVnZW5kXCIpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMubGVnZW5kLmxpc3RlbmVycywgZGVsdGFPcHRpb25zLmxlZ2VuZC5saXN0ZW5lcnMpO1xuICAgIH1cbiAgICBpZiAoZGVsdGFPcHRpb25zLmxpc3RlbmVycykge1xuICAgICAgdGhpcy51cGRhdGVBbGxTZXJpZXNMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5sb2NhbGU/LmxvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwibG9jYWxlXCIpLmxvY2FsZVRleHQgPSBkZWx0YU9wdGlvbnMubG9jYWxlPy5sb2NhbGVUZXh0O1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IG5ld0NoYXJ0T3B0aW9ucztcbiAgICBjb25zdCBuYXZpZ2F0b3JNb2R1bGUgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcIm5hdmlnYXRvclwiKTtcbiAgICBjb25zdCB6b29tTW9kdWxlID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJ6b29tXCIpO1xuICAgIGlmICghbmF2aWdhdG9yTW9kdWxlPy5lbmFibGVkICYmICF6b29tTW9kdWxlPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwiY2hhcnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG1pbmlDaGFydCA9IG5hdmlnYXRvck1vZHVsZT8ubWluaUNoYXJ0O1xuICAgIGNvbnN0IG1pbmlDaGFydFNlcmllcyA9IG5ld09wdHMubmF2aWdhdG9yPy5taW5pQ2hhcnQ/LnNlcmllcyA/PyBuZXdPcHRzLnNlcmllcztcbiAgICBpZiAobWluaUNoYXJ0Py5lbmFibGVkID09PSB0cnVlICYmIG1pbmlDaGFydFNlcmllcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFwcGx5TWluaUNoYXJ0T3B0aW9ucyhtaW5pQ2hhcnQsIG1pbmlDaGFydFNlcmllcywgbmV3T3B0cywgb2xkT3B0cyk7XG4gICAgfSBlbHNlIGlmIChtaW5pQ2hhcnQ/LmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICBtaW5pQ2hhcnQuc2VyaWVzID0gW107XG4gICAgICBtaW5pQ2hhcnQuYXhlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmN0eC5hbm5vdGF0aW9uTWFuYWdlci5zZXRBbm5vdGF0aW9uU3R5bGVzKG5ld0NoYXJ0T3B0aW9ucy5hbm5vdGF0aW9uVGhlbWVzKTtcbiAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCB8fCAoZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSB0aGlzLnNob3VsZEZvcmNlTm9kZURhdGFSZWZyZXNoKGRlbHRhT3B0aW9ucywgc2VyaWVzU3RhdHVzKSk7XG4gICAgY29uc3QgbWFqb3JDaGFuZ2UgPSBmb3JjZU5vZGVEYXRhUmVmcmVzaCB8fCBtb2R1bGVzQ2hhbmdlZDtcbiAgICBjb25zdCB1cGRhdGVUeXBlID0gbWFqb3JDaGFuZ2UgPyAwIC8qIEZVTEwgKi8gOiAzIC8qIFBFUkZPUk1fTEFZT1VUICovO1xuICAgIHRoaXMubWF5YmVSZXNldEFuaW1hdGlvbnMoc2VyaWVzU3RhdHVzKTtcbiAgICBkZWJ1ZyhcIkNoYXJ0LmFwcGx5T3B0aW9ucygpIC0gdXBkYXRlIHR5cGVcIiwgQ2hhcnRVcGRhdGVUeXBlW3VwZGF0ZVR5cGVdLCB7XG4gICAgICBzZXJpZXNTdGF0dXMsXG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKHVwZGF0ZVR5cGUsIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2gsIG5ld0FuaW1hdGlvbkJhdGNoOiB0cnVlIH0pO1xuICAgIGlmIChkZWx0YU9wdGlvbnMuaW5pdGlhbFN0YXRlKSB7XG4gICAgICB0aGlzLmFwcGx5SW5pdGlhbFN0YXRlKG5ld0NoYXJ0T3B0aW9ucy51c2VyT3B0aW9ucy5pbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgfVxuICBhcHBseUluaXRpYWxTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHg6IHsgYW5ub3RhdGlvbk1hbmFnZXIsIHN0YXRlTWFuYWdlciB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGluaXRpYWxTdGF0ZT8uYW5ub3RhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5ub3RhdGlvbnMyID0gaW5pdGlhbFN0YXRlLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uVGhlbWUgPSBhbm5vdGF0aW9uTWFuYWdlci5nZXRBbm5vdGF0aW9uVHlwZVN0eWxlcyhhbm5vdGF0aW9uLnR5cGUpO1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhhbm5vdGF0aW9uLCBhbm5vdGF0aW9uVGhlbWUpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZU1hbmFnZXIuc2V0U3RhdGUoYW5ub3RhdGlvbk1hbmFnZXIsIGFubm90YXRpb25zMik7XG4gICAgfVxuICB9XG4gIG1heWJlUmVzZXRBbmltYXRpb25zKHNlcmllc1N0YXR1cykge1xuICAgIGlmICh0aGlzLm1vZGUgIT09IFwic3RhbmRhbG9uZVwiKVxuICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoc2VyaWVzU3RhdHVzKSB7XG4gICAgICBjYXNlIFwic2VyaWVzLWdyb3VwaW5nLWNoYW5nZVwiOlxuICAgICAgY2FzZSBcInJlcGxhY2VkXCI6XG4gICAgICAgIHRoaXMucmVzZXRBbmltYXRpb25zKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cbiAgc2hvdWxkRm9yY2VOb2RlRGF0YVJlZnJlc2goZGVsdGFPcHRpb25zLCBzZXJpZXNTdGF0dXMpIHtcbiAgICBjb25zdCBzZXJpZXNEYXRhVXBkYXRlID0gISFkZWx0YU9wdGlvbnMuZGF0YSB8fCBzZXJpZXNTdGF0dXMgPT09IFwiZGF0YS1jaGFuZ2VcIiB8fCBzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIjtcbiAgICBjb25zdCBsZWdlbmRLZXlzID0gbGVnZW5kUmVnaXN0cnkuZ2V0S2V5cygpO1xuICAgIGNvbnN0IG9wdGlvbnNIYXZlTGVnZW5kID0gT2JqZWN0LnZhbHVlcyhsZWdlbmRLZXlzKS5zb21lKFxuICAgICAgKGxlZ2VuZEtleSkgPT4gZGVsdGFPcHRpb25zW2xlZ2VuZEtleV0gIT0gbnVsbFxuICAgICk7XG4gICAgY29uc3Qgb3RoZXJSZWZyZXNoVXBkYXRlID0gZGVsdGFPcHRpb25zLnRpdGxlICE9IG51bGwgJiYgZGVsdGFPcHRpb25zLnN1YnRpdGxlICE9IG51bGw7XG4gICAgcmV0dXJuIHNlcmllc0RhdGFVcGRhdGUgfHwgb3B0aW9uc0hhdmVMZWdlbmQgfHwgb3RoZXJSZWZyZXNoVXBkYXRlO1xuICB9XG4gIGFwcGx5TWluaUNoYXJ0T3B0aW9ucyhtaW5pQ2hhcnQsIG1pbmlDaGFydFNlcmllcywgY29tcGxldGVPcHRpb25zLCBvbGRPcHRzKSB7XG4gICAgY29uc3Qgb2xkU2VyaWVzID0gb2xkT3B0cz8ubmF2aWdhdG9yPy5taW5pQ2hhcnQ/LnNlcmllcyA/PyBvbGRPcHRzPy5zZXJpZXM7XG4gICAgY29uc3QgbWluaUNoYXJ0U2VyaWVzU3RhdHVzID0gdGhpcy5hcHBseVNlcmllcyhcbiAgICAgIG1pbmlDaGFydCxcbiAgICAgIHRoaXMuZmlsdGVyTWluaUNoYXJ0U2VyaWVzKG1pbmlDaGFydFNlcmllcyksXG4gICAgICB0aGlzLmZpbHRlck1pbmlDaGFydFNlcmllcyhvbGRTZXJpZXMpXG4gICAgKTtcbiAgICB0aGlzLmFwcGx5QXhlcyhtaW5pQ2hhcnQsIGNvbXBsZXRlT3B0aW9ucywgb2xkT3B0cywgbWluaUNoYXJ0U2VyaWVzU3RhdHVzLCBbXG4gICAgICBcImF4ZXNbXS50aWNrXCIsXG4gICAgICBcImF4ZXNbXS50aGlja25lc3NcIixcbiAgICAgIFwiYXhlc1tdLnRpdGxlXCIsXG4gICAgICBcImF4ZXNbXS5jcm9zc2hhaXJcIixcbiAgICAgIFwiYXhlc1tdLmdyaWRMaW5lXCIsXG4gICAgICBcImF4ZXNbXS5sYWJlbFwiXG4gICAgXSk7XG4gICAgY29uc3QgYXhlcyA9IG1pbmlDaGFydC5heGVzO1xuICAgIGNvbnN0IGhvcml6b250YWxBeGlzID0gYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIGF4aXMuZ3JpZExpbmUuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgYXhpcy5sYWJlbC5lbmFibGVkID0gYXhpcyA9PT0gaG9yaXpvbnRhbEF4aXM7XG4gICAgICBheGlzLnRpY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgYXhpcy5pbnRlcmFjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvcml6b250YWxBeGlzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG1pbmlDaGFydE9wdHMgPSBjb21wbGV0ZU9wdGlvbnMubmF2aWdhdG9yPy5taW5pQ2hhcnQ7XG4gICAgICBjb25zdCBsYWJlbE9wdGlvbnMgPSBtaW5pQ2hhcnRPcHRzPy5sYWJlbDtcbiAgICAgIGNvbnN0IGludGVydmFsT3B0aW9ucyA9IG1pbmlDaGFydE9wdHM/LmxhYmVsPy5pbnRlcnZhbDtcbiAgICAgIGhvcml6b250YWxBeGlzLmxpbmUuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaG9yaXpvbnRhbEF4aXMubGFiZWwuc2V0KFxuICAgICAgICB3aXRob3V0KGxhYmVsT3B0aW9ucywgW1wiaW50ZXJ2YWxcIiwgXCJyb3RhdGlvblwiLCBcIm1pblNwYWNpbmdcIiwgXCJhdXRvUm90YXRlXCIsIFwiYXV0b1JvdGF0ZUFuZ2xlXCJdKVxuICAgICAgKTtcbiAgICAgIGhvcml6b250YWxBeGlzLnRpY2suc2V0KFxuICAgICAgICB3aXRob3V0KGludGVydmFsT3B0aW9ucywgW1wiZW5hYmxlZFwiLCBcIndpZHRoXCIsIFwic2l6ZVwiLCBcImNvbG9yXCIsIFwiaW50ZXJ2YWxcIiwgXCJzdGVwXCJdKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSBpbnRlcnZhbE9wdGlvbnM/LnN0ZXA7XG4gICAgICBpZiAoc3RlcCAhPSBudWxsKSB7XG4gICAgICAgIGhvcml6b250YWxBeGlzLmludGVydmFsLnN0ZXAgPSBzdGVwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcHBseU1vZHVsZXMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdHlwZTogY2hhcnRUeXBlMiB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBsZXQgbW9kdWxlc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJyb290XCIsIFwibGVnZW5kXCIpKSB7XG4gICAgICBjb25zdCBpc0NvbmZpZ3VyZWQgPSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsO1xuICAgICAgY29uc3Qgc2hvdWxkQmVFbmFibGVkID0gaXNDb25maWd1cmVkICYmIG1vZHVsZS5jaGFydFR5cGVzLmluY2x1ZGVzKGNoYXJ0VHlwZTIpO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCA9PT0gdGhpcy5tb2R1bGVzTWFuYWdlci5pc0VuYWJsZWQobW9kdWxlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkKSB7XG4gICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuYWRkTW9kdWxlKG1vZHVsZSwgKG0pID0+IG0ubW9kdWxlRmFjdG9yeSh0aGlzLmdldE1vZHVsZUNvbnRleHQoKSkpO1xuICAgICAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwibGVnZW5kXCIpIHtcbiAgICAgICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShtb2R1bGUpPy5hdHRhY2hMZWdlbmQodGhpcy5jdHguc2NlbmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbbW9kdWxlLm9wdGlvbnNLZXldID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUobW9kdWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIucmVtb3ZlTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICAgIH1cbiAgICAgIG1vZHVsZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZXNDaGFuZ2VkO1xuICB9XG4gIGFwcGx5U2VyaWVzKGNoYXJ0LCBvcHRTZXJpZXMsIG9sZE9wdFNlcmllcykge1xuICAgIGlmICghb3B0U2VyaWVzKSB7XG4gICAgICByZXR1cm4gXCJuby1jaGFuZ2VcIjtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSBtYXRjaFNlcmllc09wdGlvbnMoY2hhcnQuc2VyaWVzLCBvcHRTZXJpZXMsIG9sZE9wdFNlcmllcyk7XG4gICAgaWYgKG1hdGNoUmVzdWx0LnN0YXR1cyA9PT0gXCJuby1vdmVybGFwXCIpIHtcbiAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gY3JlYXRpbmcgbmV3IHNlcmllcyBpbnN0YW5jZXMsIHN0YXR1czogJHttYXRjaFJlc3VsdC5zdGF0dXN9YCwgbWF0Y2hSZXN1bHQpO1xuICAgICAgY2hhcnQuc2VyaWVzID0gb3B0U2VyaWVzLm1hcCgob3B0cykgPT4gdGhpcy5jcmVhdGVTZXJpZXMob3B0cykpO1xuICAgICAgcmV0dXJuIFwicmVwbGFjZWRcIjtcbiAgICB9XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBtYXRjaFJlc3VsdGAsIG1hdGNoUmVzdWx0KTtcbiAgICBjb25zdCBzZXJpZXNJbnN0YW5jZXMgPSBbXTtcbiAgICBsZXQgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgZ3JvdXBpbmdDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IGlzVXBkYXRlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIG1hdGNoUmVzdWx0LmNoYW5nZXMpIHtcbiAgICAgIGdyb3VwaW5nQ2hhbmdlZCB8fCAoZ3JvdXBpbmdDaGFuZ2VkID0gY2hhbmdlLnN0YXR1cyA9PT0gXCJzZXJpZXMtZ3JvdXBpbmdcIik7XG4gICAgICBkYXRhQ2hhbmdlZCB8fCAoZGF0YUNoYW5nZWQgPSBjaGFuZ2UuZGlmZj8uZGF0YSAhPSBudWxsKTtcbiAgICAgIGlzVXBkYXRlZCB8fCAoaXNVcGRhdGVkID0gY2hhbmdlLnN0YXR1cyAhPT0gXCJuby1vcFwiKTtcbiAgICAgIHN3aXRjaCAoY2hhbmdlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgY29uc3QgbmV3U2VyaWVzID0gdGhpcy5jcmVhdGVTZXJpZXMoY2hhbmdlLm9wdHMpO1xuICAgICAgICAgIHNlcmllc0luc3RhbmNlcy5wdXNoKG5ld1Nlcmllcyk7XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBjcmVhdGVkIG5ldyBzZXJpZXNgLCBuZXdTZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSByZW1vdmluZyBzZXJpZXMgYXQgcHJldmlvdXMgaWR4ICR7Y2hhbmdlLmlkeH1gLCBjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vLW9wXCI6XG4gICAgICAgICAgc2VyaWVzSW5zdGFuY2VzLnB1c2goY2hhbmdlLnNlcmllcyk7XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBubyBjaGFuZ2UgdG8gc2VyaWVzIGF0IHByZXZpb3VzIGlkeCAke2NoYW5nZS5pZHh9YCwgY2hhbmdlLnNlcmllcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXJpZXMtZ3JvdXBpbmdcIjpcbiAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnN0IHsgc2VyaWVzLCBkaWZmOiBkaWZmMiwgaWR4IH0gPSBjaGFuZ2U7XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBhcHBseWluZyBzZXJpZXMgZGlmZiBwcmV2aW91cyBpZHggJHtpZHh9YCwgZGlmZjIsIHNlcmllcyk7XG4gICAgICAgICAgdGhpcy5hcHBseVNlcmllc1ZhbHVlcyhzZXJpZXMsIGRpZmYyKTtcbiAgICAgICAgICBzZXJpZXMubWFya05vZGVEYXRhRGlydHkoKTtcbiAgICAgICAgICBzZXJpZXNJbnN0YW5jZXMucHVzaChzZXJpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZXJpZXNJbnN0YW5jZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgc2VyaWVzSW5zdGFuY2VzW2lkeF0uX2RlY2xhcmF0aW9uT3JkZXIgPSBpZHg7XG4gICAgfVxuICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gZmluYWwgc2VyaWVzIGluc3RhbmNlc2AsIHNlcmllc0luc3RhbmNlcyk7XG4gICAgY2hhcnQuc2VyaWVzID0gc2VyaWVzSW5zdGFuY2VzO1xuICAgIGlmIChncm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiBcInNlcmllcy1ncm91cGluZy1jaGFuZ2VcIjtcbiAgICB9XG4gICAgaWYgKGRhdGFDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gXCJkYXRhLWNoYW5nZVwiO1xuICAgIH1cbiAgICByZXR1cm4gaXNVcGRhdGVkID8gXCJ1cGRhdGVkXCIgOiBcIm5vLW9wXCI7XG4gIH1cbiAgYXBwbHlBeGVzKGNoYXJ0LCBvcHRpb25zLCBvbGRPcHRzLCBzZXJpZXNTdGF0dXMsIHNraXAgPSBbXSwgcmVnaXN0ZXJSZWdpb25zID0gZmFsc2UpIHtcbiAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSB8fCAhb3B0aW9ucy5heGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNraXAgPSBbXCJheGVzW10udHlwZVwiLCAuLi5za2lwXTtcbiAgICBjb25zdCB7IGF4ZXMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZm9yY2VSZWNyZWF0ZSA9IHNlcmllc1N0YXR1cyA9PT0gXCJyZXBsYWNlZFwiO1xuICAgIGNvbnN0IG1hdGNoaW5nVHlwZXMgPSAhZm9yY2VSZWNyZWF0ZSAmJiBjaGFydC5heGVzLmxlbmd0aCA9PT0gYXhlcy5sZW5ndGggJiYgY2hhcnQuYXhlcy5ldmVyeSgoYSwgaSkgPT4gYS50eXBlID09PSBheGVzW2ldLnR5cGUpO1xuICAgIGlmIChtYXRjaGluZ1R5cGVzICYmIGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob2xkT3B0cykpIHtcbiAgICAgIGNoYXJ0LmF4ZXMuZm9yRWFjaCgoYXhpcywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNPcHRzID0gb2xkT3B0cy5heGVzPy5baW5kZXhdID8/IHt9O1xuICAgICAgICBjb25zdCBheGlzRGlmZiA9IGpzb25EaWZmKHByZXZpb3VzT3B0cywgYXhlc1tpbmRleF0pO1xuICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlBeGVzKCkgLSBhcHBseWluZyBheGlzIGRpZmYgaWR4ICR7aW5kZXh9YCwgYXhpc0RpZmYpO1xuICAgICAgICBjb25zdCBwYXRoID0gYGF4ZXNbJHtpbmRleH1dYDtcbiAgICAgICAganNvbkFwcGx5KGF4aXMsIGF4aXNEaWZmLCB7IHBhdGgsIHNraXAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlBeGVzKCkgLSBjcmVhdGluZyBuZXcgYXhlcyBpbnN0YW5jZXM7IHNlcmllc1N0YXR1czogJHtzZXJpZXNTdGF0dXN9YCk7XG4gICAgY2hhcnQuYXhlcyA9IHRoaXMuY3JlYXRlQXhpcyhheGVzLCBza2lwKTtcbiAgICBjb25zdCBheGlzR3JvdXBzID0ge1xuICAgICAgW1wieFwiIC8qIFggKi9dOiBbXSxcbiAgICAgIFtcInlcIiAvKiBZICovXTogW11cbiAgICB9O1xuICAgIGNoYXJ0LmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gYXhpc0dyb3Vwc1theGlzLmRpcmVjdGlvbl0ucHVzaChheGlzLmdldFJlZ2lvbkJCb3hQcm92aWRlcigpKSk7XG4gICAgaWYgKHJlZ2lzdGVyUmVnaW9ucykge1xuICAgICAgdGhpcy5jdHgucmVnaW9uTWFuYWdlci51cGRhdGVSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8sIC4uLmF4aXNHcm91cHNbXCJ4XCIgLyogWCAqL10pO1xuICAgICAgdGhpcy5jdHgucmVnaW9uTWFuYWdlci51cGRhdGVSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLywgLi4uYXhpc0dyb3Vwc1tcInlcIiAvKiBZICovXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVNlcmllcyhzZXJpZXNPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWVzSW5zdGFuY2UgPSBzZXJpZXNSZWdpc3RyeS5jcmVhdGUoc2VyaWVzT3B0aW9ucy50eXBlLCB0aGlzLmdldE1vZHVsZUNvbnRleHQoKSk7XG4gICAgdGhpcy5hcHBseVNlcmllc09wdGlvbk1vZHVsZXMoc2VyaWVzSW5zdGFuY2UsIHNlcmllc09wdGlvbnMpO1xuICAgIHRoaXMuYXBwbHlTZXJpZXNWYWx1ZXMoc2VyaWVzSW5zdGFuY2UsIHNlcmllc09wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpZXNJbnN0YW5jZTtcbiAgfVxuICBhcHBseVNlcmllc09wdGlvbk1vZHVsZXMoc2VyaWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHNlcmllcy5jcmVhdGVNb2R1bGVDb250ZXh0KCk7XG4gICAgY29uc3QgbW9kdWxlTWFwID0gc2VyaWVzLmdldE1vZHVsZU1hcCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcInNlcmllcy1vcHRpb25cIikpIHtcbiAgICAgIGlmIChtb2R1bGUub3B0aW9uc0tleSBpbiBvcHRpb25zICYmIG1vZHVsZS5zZXJpZXNUeXBlcy5pbmNsdWRlcyhzZXJpZXMudHlwZSkpIHtcbiAgICAgICAgbW9kdWxlTWFwLmFkZE1vZHVsZShtb2R1bGUsIChtKSA9PiBtLm1vZHVsZUZhY3RvcnkobW9kdWxlQ29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcHBseVNlcmllc1ZhbHVlcyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2R1bGVNYXAgPSB0YXJnZXQuZ2V0TW9kdWxlTWFwKCk7XG4gICAgY29uc3QgeyB0eXBlOiBfLCBkYXRhLCBsaXN0ZW5lcnMsIHNlcmllc0dyb3VwaW5nLCBzaG93SW5NaW5pQ2hhcnQ6IF9fLCAuLi5zZXJpZXNPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIGZvciAoY29uc3QgbW9kdWxlRGVmIG9mIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUykge1xuICAgICAgaWYgKG1vZHVsZURlZi50eXBlICE9PSBcInNlcmllcy1vcHRpb25cIilcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAobW9kdWxlRGVmLm9wdGlvbnNLZXkgaW4gc2VyaWVzT3B0aW9ucykge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBtb2R1bGVNYXAuZ2V0TW9kdWxlKG1vZHVsZURlZi5vcHRpb25zS2V5KTtcbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgIGNvbnN0IG1vZHVsZU9wdGlvbnMgPSBzZXJpZXNPcHRpb25zW21vZHVsZURlZi5vcHRpb25zS2V5XTtcbiAgICAgICAgICBkZWxldGUgc2VyaWVzT3B0aW9uc1ttb2R1bGVEZWYub3B0aW9uc0tleV07XG4gICAgICAgICAgbW9kdWxlLnByb3BlcnRpZXMuc2V0KG1vZHVsZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldC5wcm9wZXJ0aWVzLnNldChzZXJpZXNPcHRpb25zKTtcbiAgICBpZiAoXCJkYXRhXCIgaW4gb3B0aW9ucykge1xuICAgICAgdGFyZ2V0LnNldE9wdGlvbnNEYXRhKGRhdGEpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKHRhcmdldCwgbGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKFwic2VyaWVzR3JvdXBpbmdcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoc2VyaWVzR3JvdXBpbmcgPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuc2VyaWVzR3JvdXBpbmcgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuc2VyaWVzR3JvdXBpbmcgPSB7IC4uLnRhcmdldC5zZXJpZXNHcm91cGluZywgLi4uc2VyaWVzR3JvdXBpbmcgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlQXhpcyhvcHRpb25zLCBza2lwKSB7XG4gICAgY29uc3QgbmV3QXhlcyA9IFtdO1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSB0aGlzLmdldE1vZHVsZUNvbnRleHQoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGF4aXNPcHRpb25zID0gb3B0aW9uc1tpbmRleF07XG4gICAgICBjb25zdCBheGlzID0gYXhpc1JlZ2lzdHJ5LmNyZWF0ZShheGlzT3B0aW9ucy50eXBlLCBtb2R1bGVDb250ZXh0KTtcbiAgICAgIHRoaXMuYXBwbHlBeGlzTW9kdWxlcyhheGlzLCBheGlzT3B0aW9ucyk7XG4gICAgICBqc29uQXBwbHkoYXhpcywgYXhpc09wdGlvbnMsIHsgcGF0aDogYGF4ZXNbJHtpbmRleH1dYCwgc2tpcCB9KTtcbiAgICAgIG5ld0F4ZXMucHVzaChheGlzKTtcbiAgICB9XG4gICAgZ3Vlc3NJbnZhbGlkUG9zaXRpb25zKG5ld0F4ZXMpO1xuICAgIHJldHVybiBuZXdBeGVzO1xuICB9XG4gIGFwcGx5QXhpc01vZHVsZXMoYXhpcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSBheGlzLmNyZWF0ZU1vZHVsZUNvbnRleHQoKTtcbiAgICBjb25zdCBtb2R1bGVNYXAgPSBheGlzLmdldE1vZHVsZU1hcCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcImF4aXMtb3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBzaG91bGRCZUVuYWJsZWQgPSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCA9PT0gbW9kdWxlTWFwLmlzRW5hYmxlZChtb2R1bGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQpIHtcbiAgICAgICAgbW9kdWxlTWFwLmFkZE1vZHVsZShtb2R1bGUsIChtKSA9PiBtLm1vZHVsZUZhY3RvcnkobW9kdWxlQ29udGV4dCkpO1xuICAgICAgICBheGlzW21vZHVsZS5vcHRpb25zS2V5XSA9IG1vZHVsZU1hcC5nZXRNb2R1bGUobW9kdWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZU1hcC5yZW1vdmVNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgZGVsZXRlIGF4aXNbbW9kdWxlLm9wdGlvbnNLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycyhzb3VyY2UsIGxpc3RlbmVycykge1xuICAgIHNvdXJjZS5jbGVhckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgZm9yIChjb25zdCBbcHJvcGVydHksIGxpc3RlbmVyXSBvZiBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMpKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcikpIHtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIocHJvcGVydHksIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fQ2hhcnQuY2hhcnRzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRDb250YWluZXIodmFsdWUpO1xuICAgICAgX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcy5zZXQodmFsdWUsIHRoaXMpO1xuICAgIH0sXG4gICAgb2xkVmFsdWUodmFsdWUpIHtcbiAgICAgIF9DaGFydC5jaGFydHNJbnN0YW5jZXMuZGVsZXRlKHZhbHVlKTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJ3aWR0aCBvcHRpb25cIiwgeyBpbldpZHRoOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcImhlaWdodCBvcHRpb25cIiwgeyBpbkhlaWdodDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwibWluV2lkdGggb3B0aW9uXCIsIHsgaW5NaW5XaWR0aDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJtaW5XaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJtaW5IZWlnaHQgb3B0aW9uXCIsIHsgaW5NaW5IZWlnaHQ6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwibWluSGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJ0aXRsZVBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInNlcmllc0FyZWFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJzdWJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiZm9vdG5vdGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImtleWJvYXJkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wic3RhbmRhbG9uZVwiLCBcImludGVncmF0ZWRcIl0sIFwiYSBjaGFydCBtb2RlXCIpKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJtb2RlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgdGhpcy5vbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImF4ZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICB0aGlzLm9uU2VyaWVzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgMik7XG52YXIgQ2hhcnQgPSBfQ2hhcnQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvcXVhZHRyZWUudHNcbnZhciBRdWFkdHJlZU5lYXJlc3QgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5LCBtYXhkZXB0aCwgYm91bmRhcnkpIHtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUXVhZHRyZWVOb2RlTmVhcmVzdChjYXBhY2l0eSwgbWF4ZGVwdGgsIGJvdW5kYXJ5KTtcbiAgfVxuICBjbGVhcihib3VuZGFyeSkge1xuICAgIHRoaXMucm9vdC5jbGVhcihib3VuZGFyeSk7XG4gIH1cbiAgYWRkVmFsdWUoaGl0VGVzdGVyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGVsZW0gPSB7XG4gICAgICBoaXRUZXN0ZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpc3RhbmNlU3F1YXJlZDogKHgsIHkpID0+IHtcbiAgICAgICAgcmV0dXJuIGhpdFRlc3Rlci5kaXN0YW5jZVNxdWFyZWQoeCwgeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJvb3QuYWRkRWxlbShlbGVtKTtcbiAgfVxuICBmaW5kKHgsIHkpIHtcbiAgICBjb25zdCBhcmcgPSB7IGJlc3Q6IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IEluZmluaXR5IH0gfTtcbiAgICB0aGlzLnJvb3QuZmluZCh4LCB5LCBhcmcpO1xuICAgIHJldHVybiBhcmcuYmVzdDtcbiAgfVxufTtcbnZhciBRdWFkdHJlZVN1YmRpdmlzaW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobncsIG5lLCBzdywgc2UpIHtcbiAgICB0aGlzLm53ID0gbnc7XG4gICAgdGhpcy5uZSA9IG5lO1xuICAgIHRoaXMuc3cgPSBzdztcbiAgICB0aGlzLnNlID0gc2U7XG4gIH1cbiAgYWRkRWxlbShlbGVtKSB7XG4gICAgdGhpcy5udy5hZGRFbGVtKGVsZW0pO1xuICAgIHRoaXMubmUuYWRkRWxlbShlbGVtKTtcbiAgICB0aGlzLnN3LmFkZEVsZW0oZWxlbSk7XG4gICAgdGhpcy5zZS5hZGRFbGVtKGVsZW0pO1xuICB9XG4gIGZpbmQoeCwgeSwgYXJnKSB7XG4gICAgdGhpcy5udy5maW5kKHgsIHksIGFyZyk7XG4gICAgdGhpcy5uZS5maW5kKHgsIHksIGFyZyk7XG4gICAgdGhpcy5zdy5maW5kKHgsIHksIGFyZyk7XG4gICAgdGhpcy5zZS5maW5kKHgsIHksIGFyZyk7XG4gIH1cbn07XG52YXIgUXVhZHRyZWVOb2RlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYXBhY2l0eSwgbWF4ZGVwdGgsIGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMubWF4ZGVwdGggPSBtYXhkZXB0aDtcbiAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnkgPz8gQkJveC5OYU47XG4gICAgdGhpcy5lbGVtcyA9IFtdO1xuICAgIHRoaXMuc3ViZGl2aXNpb25zID0gdm9pZCAwO1xuICB9XG4gIGNsZWFyKGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5lbGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHZvaWQgMDtcbiAgfVxuICBhZGRFbGVtKGUpIHtcbiAgICBpZiAodGhpcy5hZGRDb25kaXRpb24oZSkpIHtcbiAgICAgIGlmICh0aGlzLnN1YmRpdmlzaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0aGlzLm1heGRlcHRoID09PSAwIHx8IHRoaXMuZWxlbXMubGVuZ3RoIDwgdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgIHRoaXMuZWxlbXMucHVzaChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN1YmRpdmlkZShlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdWJkaXZpc2lvbnMuYWRkRWxlbShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluZCh4LCB5LCBhcmcpIHtcbiAgICBpZiAodGhpcy5maW5kQ29uZGl0aW9uKHgsIHksIGFyZykpIHtcbiAgICAgIGlmICh0aGlzLnN1YmRpdmlzaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuZmluZEFjdGlvbih4LCB5LCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdWJkaXZpc2lvbnMuZmluZCh4LCB5LCBhcmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdWJkaXZpZGUobmV3RWxlbSkge1xuICAgIHRoaXMuc3ViZGl2aXNpb25zID0gdGhpcy5tYWtlU3ViZGl2aXNpb25zKCk7XG4gICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZWxlbXMpIHtcbiAgICAgIHRoaXMuc3ViZGl2aXNpb25zLmFkZEVsZW0oZSk7XG4gICAgfVxuICAgIHRoaXMuc3ViZGl2aXNpb25zLmFkZEVsZW0obmV3RWxlbSk7XG4gICAgdGhpcy5lbGVtcy5sZW5ndGggPSAwO1xuICB9XG4gIG1ha2VTdWJkaXZpc2lvbnMoKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmJvdW5kYXJ5O1xuICAgIGNvbnN0IHsgY2FwYWNpdHkgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVwdGggPSB0aGlzLm1heGRlcHRoIC0gMTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgY29uc3QgbndCb3VuZGFyeSA9IG5ldyBCQm94KHgsIHksIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgY29uc3QgbmVCb3VuZGFyeSA9IG5ldyBCQm94KHggKyBoYWxmV2lkdGgsIHksIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgY29uc3Qgc3dCb3VuZGFyeSA9IG5ldyBCQm94KHgsIHkgKyBoYWxmSGVpZ2h0LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIGNvbnN0IHNlQm91bmRhcnkgPSBuZXcgQkJveCh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICByZXR1cm4gbmV3IFF1YWR0cmVlU3ViZGl2aXNpb25zKFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIG53Qm91bmRhcnkpLFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIG5lQm91bmRhcnkpLFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIHN3Qm91bmRhcnkpLFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIHNlQm91bmRhcnkpXG4gICAgKTtcbiAgfVxufTtcbnZhciBRdWFkdHJlZU5vZGVOZWFyZXN0ID0gY2xhc3MgX1F1YWR0cmVlTm9kZU5lYXJlc3QgZXh0ZW5kcyBRdWFkdHJlZU5vZGUge1xuICBhZGRDb25kaXRpb24oZSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZS5oaXRUZXN0ZXIubWlkUG9pbnQ7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRhcnkuY29udGFpbnNQb2ludCh4LCB5KTtcbiAgfVxuICBmaW5kQ29uZGl0aW9uKHgsIHksIGFyZykge1xuICAgIGNvbnN0IHsgYmVzdCB9ID0gYXJnO1xuICAgIHJldHVybiBiZXN0LmRpc3RhbmNlU3F1YXJlZCAhPT0gMCAmJiB0aGlzLmJvdW5kYXJ5LmRpc3RhbmNlU3F1YXJlZCh4LCB5KSA8IGJlc3QuZGlzdGFuY2VTcXVhcmVkO1xuICB9XG4gIGZpbmRBY3Rpb24oeCwgeSwgYXJnKSB7XG4gICAgY29uc3Qgb3RoZXIgPSBuZWFyZXN0U3F1YXJlZCh4LCB5LCB0aGlzLmVsZW1zLCBhcmcuYmVzdC5kaXN0YW5jZVNxdWFyZWQpO1xuICAgIGlmIChvdGhlci5uZWFyZXN0ICE9PSB2b2lkIDAgJiYgb3RoZXIuZGlzdGFuY2VTcXVhcmVkIDwgYXJnLmJlc3QuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICBhcmcuYmVzdCA9IG90aGVyO1xuICAgIH1cbiAgfVxuICBjaGlsZChjYXBhY2l0eSwgZGVwdGgsIGJvdW5kYXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBfUXVhZHRyZWVOb2RlTmVhcmVzdChjYXBhY2l0eSwgZGVwdGgsIGJvdW5kYXJ5KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL21hcmtlci50c1xudmFyIE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuc2l6ZSA9IDEyO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgc2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNlbnRlciB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IEJCb3goeCAtIHNpemUgKiBjZW50ZXIueCwgeSAtIHNpemUgKiBjZW50ZXIueSwgc2l6ZSwgc2l6ZSk7XG4gIH1cbiAgY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICB9XG4gIGFwcGx5UGF0aChzLCBtb3Zlcykge1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gdGhpcztcbiAgICBsZXQgeyB4LCB5IH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnJlcGVhdCAhPSBudWxsKSB7XG4gICAgICB4ID0gMDtcbiAgICAgIHkgPSAwO1xuICAgIH1cbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB7IHg6IG14LCB5OiBteSwgdCB9IG9mIG1vdmVzKSB7XG4gICAgICB4ICs9IG14ICogcztcbiAgICAgIHkgKz0gbXkgKiBzO1xuICAgICAgaWYgKHQgPT09IFwibW92ZVwiKSB7XG4gICAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbiAgZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlcGVhdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgeCA9IHRoaXMudHJhbnNsYXRpb25YO1xuICAgIGxldCB5ID0gdGhpcy50cmFuc2xhdGlvblk7XG4gICAgZm9yIChjb25zdCB0cmFuc2xhdGlvbiBvZiB0aGlzLnJlcGVhdCkge1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54IC0geCwgdHJhbnNsYXRpb24ueSAtIHkpO1xuICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgICB4ID0gdHJhbnNsYXRpb24ueDtcbiAgICAgIHkgPSB0cmFuc2xhdGlvbi55O1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlcGVhdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGxldCB4ID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgbGV0IHkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zbGF0aW9uIG9mIHRoaXMucmVwZWF0KSB7XG4gICAgICBjdHgudHJhbnNsYXRlKHRyYW5zbGF0aW9uLnggLSB4LCB0cmFuc2xhdGlvbi55IC0geSk7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgeCA9IHRyYW5zbGF0aW9uLng7XG4gICAgICB5ID0gdHJhbnNsYXRpb24ueTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbk1hcmtlci5jZW50ZXIgPSB7IHg6IDAuNSwgeTogMC41IH07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgTWFya2VyLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIE1hcmtlci5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbih7IGNvbnZlcnRvcjogTWF0aC5hYnMgfSlcbl0sIE1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBNYXJrZXIucHJvdG90eXBlLCBcInJlcGVhdFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL2NpcmNsZS50c1xudmFyIENpcmNsZSA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHBhdGgsIHNpemUgfSA9IHRoaXM7XG4gICAgY29uc3QgciA9IHNpemUgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLmFyYyh4LCB5LCByLCAwLCBNYXRoLlBJICogMik7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbkNpcmNsZS5jbGFzc05hbWUgPSBcIkNpcmNsZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvY3Jvc3MudHNcbnZhciBfQ3Jvc3MgPSBjbGFzcyBfQ3Jvc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyA0LjI7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9Dcm9zcy5tb3Zlcyk7XG4gIH1cbn07XG5fQ3Jvc3MuY2xhc3NOYW1lID0gXCJDcm9zc1wiO1xuX0Nyb3NzLm1vdmVzID0gW1xuICB7IHg6IC0xLCB5OiAwLCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IC0xLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogMSB9LFxuICB7IHg6IDEsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAxIH0sXG4gIHsgeDogMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IC0xIH0sXG4gIHsgeDogLTEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogLTEgfVxuXTtcbnZhciBDcm9zcyA9IF9Dcm9zcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL2RpYW1vbmQudHNcbnZhciBfRGlhbW9uZCA9IGNsYXNzIF9EaWFtb25kIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gMjtcbiAgICBzdXBlci5hcHBseVBhdGgocywgX0RpYW1vbmQubW92ZXMpO1xuICB9XG59O1xuX0RpYW1vbmQuY2xhc3NOYW1lID0gXCJEaWFtb25kXCI7XG5fRGlhbW9uZC5tb3ZlcyA9IFtcbiAgeyB4OiAwLCB5OiAtMSwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAtMSB9XG5dO1xudmFyIERpYW1vbmQgPSBfRGlhbW9uZDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL2hlYXJ0LnRzXG52YXIgSGVhcnQgPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHJhZChkZWdyZWUyKSB7XG4gICAgcmV0dXJuIGRlZ3JlZTIgLyAxODAgKiBNYXRoLlBJO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyB4LCBwYXRoLCBzaXplLCByYWQgfSA9IHRoaXM7XG4gICAgY29uc3QgciA9IHNpemUgLyA0O1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKyByIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5hcmMoeCAtIHIsIHkgLSByLCByLCByYWQoMTMwKSwgcmFkKDMzMCkpO1xuICAgIHBhdGguYXJjKHggKyByLCB5IC0gciwgciwgcmFkKDIyMCksIHJhZCg1MCkpO1xuICAgIHBhdGgubGluZVRvKHgsIHkgKyByKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuSGVhcnQuY2xhc3NOYW1lID0gXCJIZWFydFwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvcGluLnRzXG52YXIgUGluID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSB9ID0gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zaXplO1xuICAgIGNvbnN0IGN4ID0gMC41O1xuICAgIGNvbnN0IGN5ID0gMTtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5tb3ZlVG8oeCArICgwLjE1NjI1IC0gY3gpICogcywgeSArICgwLjM0Mzc1IC0gY3kpICogcyk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjE1MTQ5MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzA3NzQxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC42OTIyNTkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC44NDM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMTUxNDkxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC44NDM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMzQzNzUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC44NDM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNDkzODI0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC43ODQ2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjYwMDE4MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNzE2NDYxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42OTUzOTMgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC42OTkwMDkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjcxOTc2OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNjgxMjcxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NDMxMDQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjY2Mzc4NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzY2MTA1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNjExODkzIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44MzQzNjcgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjU2MjIyOCAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODk5Njk5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41Mjg4OTYgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk4MDY0OCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjUyNDA3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTkyMzU4IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41MTI2NjMgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjQ4NzMzNyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3NTkyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTkyMzU4IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzExMDQgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk4MDY0OCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjQ4NzMzNyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3NTkyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTkyMzU4IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzExMDQgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk4MDY0OCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjQzNzc3MiAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODk5Njk5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zODgxMDcgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjgzNDM2NyAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzM2MjE1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NjYxMDUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC4zMTg3MjkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc0MzEwNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzAwOTkxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43MTk3NjkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjI4MzUzOSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjk1MzkzIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuMjE1Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42MDAxODEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjE1NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC40OTM4MjQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjE1NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4zNDM3NSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5QaW4uY2xhc3NOYW1lID0gXCJNYXBQaW5cIjtcblBpbi5jZW50ZXIgPSB7IHg6IDAuNSwgeTogMSB9O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvcGx1cy50c1xudmFyIF9QbHVzID0gY2xhc3MgX1BsdXMgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyAzO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfUGx1cy5tb3Zlcyk7XG4gIH1cbn07XG5fUGx1cy5jbGFzc05hbWUgPSBcIlBsdXNcIjtcbl9QbHVzLm1vdmVzID0gW1xuICB7IHg6IC0wLjUsIHk6IC0wLjUsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogMCwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogMSB9LFxuICB7IHg6IDEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAtMSB9LFxuICB7IHg6IC0xLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogLTEgfVxuXTtcbnZhciBQbHVzID0gX1BsdXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9zcXVhcmUudHNcbnZhciBTcXVhcmUgPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5IH0gPSB0aGlzO1xuICAgIGNvbnN0IGhzID0gdGhpcy5zaXplIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5tb3ZlVG8odGhpcy5hbGlnbih4IC0gaHMpLCB0aGlzLmFsaWduKHkgLSBocykpO1xuICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oeCArIGhzKSwgdGhpcy5hbGlnbih5IC0gaHMpKTtcbiAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKHggKyBocyksIHRoaXMuYWxpZ24oeSArIGhzKSk7XG4gICAgcGF0aC5saW5lVG8odGhpcy5hbGlnbih4IC0gaHMpLCB0aGlzLmFsaWduKHkgKyBocykpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5TcXVhcmUuY2xhc3NOYW1lID0gXCJTcXVhcmVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3N0YXIudHNcbnZhciBTdGFyID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgcGF0aCwgc2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCBzcGlrZXMgPSA1O1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gc2l6ZSAvIDI7XG4gICAgY29uc3Qgcm90YXRpb24gPSBNYXRoLlBJIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGlrZXMgKiAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGkgJSAyID09PSAwID8gc2l6ZSA6IGlubmVyUmFkaXVzO1xuICAgICAgY29uc3QgYW5nbGUyID0gaSAqIE1hdGguUEkgLyBzcGlrZXMgLSByb3RhdGlvbjtcbiAgICAgIGNvbnN0IHhDb29yZGluYXRlID0geCArIE1hdGguY29zKGFuZ2xlMikgKiByYWRpdXM7XG4gICAgICBjb25zdCB5Q29vcmRpbmF0ZSA9IHkgKyBNYXRoLnNpbihhbmdsZTIpICogcmFkaXVzO1xuICAgICAgcGF0aC5saW5lVG8oeENvb3JkaW5hdGUsIHlDb29yZGluYXRlKTtcbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblN0YXIuY2xhc3NOYW1lID0gXCJTdGFyXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci90cmlhbmdsZS50c1xudmFyIF9UcmlhbmdsZSA9IGNsYXNzIF9UcmlhbmdsZSBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAqIDEuMTtcbiAgICBzdXBlci5hcHBseVBhdGgocywgX1RyaWFuZ2xlLm1vdmVzKTtcbiAgfVxufTtcbl9UcmlhbmdsZS5jbGFzc05hbWUgPSBcIlRyaWFuZ2xlXCI7XG5fVHJpYW5nbGUubW92ZXMgPSBbXG4gIHsgeDogMCwgeTogLTAuNDgsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogMC41LCB5OiAwLjg3IH0sXG4gIHsgeDogLTEsIHk6IDAgfVxuXTtcbnZhciBUcmlhbmdsZSA9IF9UcmlhbmdsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3V0aWwudHNcbnZhciBNQVJLRVJfU0hBUEVTID0ge1xuICBjaXJjbGU6IENpcmNsZSxcbiAgY3Jvc3M6IENyb3NzLFxuICBkaWFtb25kOiBEaWFtb25kLFxuICBoZWFydDogSGVhcnQsXG4gIHBpbjogUGluLFxuICBwbHVzOiBQbHVzLFxuICBzcXVhcmU6IFNxdWFyZSxcbiAgc3RhcjogU3RhcixcbiAgdHJpYW5nbGU6IFRyaWFuZ2xlXG59O1xudmFyIE1BUktFUl9TVVBQT1JURURfU0hBUEVTID0gT2JqZWN0LmtleXMoTUFSS0VSX1NIQVBFUyk7XG5mdW5jdGlvbiBpc01hcmtlclNoYXBlKHNoYXBlKSB7XG4gIHJldHVybiB0eXBlb2Ygc2hhcGUgPT09IFwic3RyaW5nXCIgJiYgTUFSS0VSX1NVUFBPUlRFRF9TSEFQRVMuaW5jbHVkZXMoc2hhcGUpO1xufVxuZnVuY3Rpb24gZ2V0TWFya2VyKHNoYXBlID0gU3F1YXJlKSB7XG4gIGlmIChpc01hcmtlclNoYXBlKHNoYXBlKSkge1xuICAgIHJldHVybiBNQVJLRVJfU0hBUEVTW3NoYXBlXTtcbiAgfVxuICBpZiAodHlwZW9mIHNoYXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH1cbiAgcmV0dXJuIFNxdWFyZTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2RhdGFNb2RlbFNlcmllcy50c1xudmFyIERhdGFNb2RlbFNlcmllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNob3dGb2N1c0JveCA9IHRydWU7XG4gIH1cbiAgZ2V0U2NhbGVJbmZvcm1hdGlvbih7XG4gICAgeFNjYWxlLFxuICAgIHlTY2FsZVxuICB9KSB7XG4gICAgY29uc3QgaXNDb250aW51b3VzWCA9IENvbnRpbnVvdXNTY2FsZS5pcyh4U2NhbGUpO1xuICAgIGNvbnN0IGlzQ29udGludW91c1kgPSBDb250aW51b3VzU2NhbGUuaXMoeVNjYWxlKTtcbiAgICByZXR1cm4geyBpc0NvbnRpbnVvdXNYLCBpc0NvbnRpbnVvdXNZLCB4U2NhbGVUeXBlOiB4U2NhbGU/LnR5cGUsIHlTY2FsZVR5cGU6IHlTY2FsZT8udHlwZSB9O1xuICB9XG4gIGdldE1vZHVsZVByb3BlcnR5RGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5tYXBNb2R1bGVzKChtb2QyKSA9PiBtb2QyLmdldFByb3BlcnR5RGVmaW5pdGlvbnModGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSkpKS5mbGF0KCk7XG4gIH1cbiAgLy8gUmVxdWVzdCBkYXRhLCBidXQgd2l0aCBtZXNzYWdlIGRpc3BhdGNoaW5nIHRvIHNlcmllcy1vcHRpb25zIChtb2R1bGVzKS5cbiAgYXN5bmMgcmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwgb3B0cykge1xuICAgIG9wdHMucHJvcHMucHVzaCguLi50aGlzLmdldE1vZHVsZVByb3BlcnR5RGVmaW5pdGlvbnMoKSk7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IGRhdGFDb250cm9sbGVyLnJlcXVlc3QodGhpcy5pZCwgZGF0YSA/PyBbXSwgb3B0cyk7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSBkYXRhTW9kZWw7XG4gICAgdGhpcy5wcm9jZXNzZWREYXRhID0gcHJvY2Vzc2VkRGF0YTtcbiAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS1wcm9jZXNzZWRcIiwgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSk7XG4gICAgcmV0dXJuIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH07XG4gIH1cbiAgaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0cyA9IHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbjtcbiAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBvcmRlcmVkS2V5cywgdW5pcXVlS2V5cyB9ID0gdmFsaWRhdGlvblJlc3VsdHM7XG4gICAgcmV0dXJuIG9yZGVyZWRLZXlzICYmIHVuaXF1ZUtleXM7XG4gIH1cbiAgY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gIH1cbiAgcGlja0ZvY3VzKG9wdHMpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0Tm9kZURhdGEoKTtcbiAgICBpZiAobm9kZURhdGEgPT09IHZvaWQgMCB8fCBub2RlRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IGRhdHVtSW5kZXggPSB0aGlzLmNvbXB1dGVGb2N1c0RhdHVtSW5kZXgob3B0cywgbm9kZURhdGEpO1xuICAgIGlmIChkYXR1bUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHsgc2hvd0ZvY3VzQm94IH0gPSB0aGlzO1xuICAgIGNvbnN0IGRhdHVtID0gbm9kZURhdGFbZGF0dW1JbmRleF07XG4gICAgY29uc3QgZGVyaXZlZE9wdHMgPSB7IC4uLm9wdHMsIGRhdHVtSW5kZXggfTtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNvbXB1dGVGb2N1c0JvdW5kcyhkZXJpdmVkT3B0cyk7XG4gICAgaWYgKGJvdW5kcyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBib3VuZHMsIHNob3dGb2N1c0JveCwgZGF0dW0sIGRhdHVtSW5kZXggfTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUZvY3VzRGF0dW1JbmRleChvcHRzLCBub2RlRGF0YSkge1xuICAgIGNvbnN0IGlzRGF0dW1FbmFibGVkID0gKGRhdHVtSW5kZXgyKSA9PiB7XG4gICAgICBjb25zdCB7IG1pc3NpbmcgPSBmYWxzZSwgZW5hYmxlZCA9IHRydWUsIGZvY3VzYWJsZSA9IHRydWUgfSA9IG5vZGVEYXRhW2RhdHVtSW5kZXgyXTtcbiAgICAgIHJldHVybiAhbWlzc2luZyAmJiBlbmFibGVkICYmIGZvY3VzYWJsZTtcbiAgICB9O1xuICAgIGNvbnN0IHNlYXJjaEJhY2t3YXJkID0gKGRhdHVtSW5kZXgyKSA9PiB7XG4gICAgICB3aGlsZSAoZGF0dW1JbmRleDIgPj0gMCAmJiAhaXNEYXR1bUVuYWJsZWQoZGF0dW1JbmRleDIpKSB7XG4gICAgICAgIGRhdHVtSW5kZXgyLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDIgPT09IC0xID8gdm9pZCAwIDogZGF0dW1JbmRleDI7XG4gICAgfTtcbiAgICBjb25zdCBzZWFyY2hGb3J3YXJkID0gKGRhdHVtSW5kZXgyKSA9PiB7XG4gICAgICB3aGlsZSAoZGF0dW1JbmRleDIgPCBub2RlRGF0YS5sZW5ndGggJiYgIWlzRGF0dW1FbmFibGVkKGRhdHVtSW5kZXgyKSkge1xuICAgICAgICBkYXR1bUluZGV4MisrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdHVtSW5kZXgyID09PSBub2RlRGF0YS5sZW5ndGggPyB2b2lkIDAgOiBkYXR1bUluZGV4MjtcbiAgICB9O1xuICAgIGxldCBkYXR1bUluZGV4O1xuICAgIGNvbnN0IGNsYW1wZWRJbmRleCA9IGNsYW1wKDAsIG9wdHMuZGF0dW1JbmRleCwgbm9kZURhdGEubGVuZ3RoIC0gMSk7XG4gICAgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhIDwgMCkge1xuICAgICAgZGF0dW1JbmRleCA9IHNlYXJjaEJhY2t3YXJkKGNsYW1wZWRJbmRleCk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmRhdHVtSW5kZXhEZWx0YSA+IDApIHtcbiAgICAgIGRhdHVtSW5kZXggPSBzZWFyY2hGb3J3YXJkKGNsYW1wZWRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdHVtSW5kZXggPz8gKGRhdHVtSW5kZXggPSBzZWFyY2hGb3J3YXJkKGNsYW1wZWRJbmRleCkpO1xuICAgICAgZGF0dW1JbmRleCA/PyAoZGF0dW1JbmRleCA9IHNlYXJjaEJhY2t3YXJkKGNsYW1wZWRJbmRleCkpO1xuICAgIH1cbiAgICBpZiAoZGF0dW1JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAob3B0cy5kYXR1bUluZGV4RGVsdGEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRzLmRhdHVtSW5kZXggLSBvcHRzLmRhdHVtSW5kZXhEZWx0YTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRhdHVtSW5kZXg7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzUHJvcGVydGllcy50c1xudmFyIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbCA9IFwicmdiYSgyNTUsMjU1LDI1NSwgMC4zMylcIjtcbiAgICB0aGlzLnN0cm9rZSA9IGByZ2JhKDAsIDAsIDAsIDAuNClgO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNILCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xudmFyIFNlcmllc0hpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImRpbU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBUZXh0SGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yID0gXCJibGFja1wiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUZXh0SGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xudmFyIEhpZ2hsaWdodFByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlnaGxpZ2h0UHJvcGVydGllcy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBIaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaXRlbSA9IG5ldyBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB0aGlzLnNlcmllcyA9IG5ldyBTZXJpZXNIaWdobGlnaHRTdHlsZSgpO1xuICAgIHRoaXMudGV4dCA9IG5ldyBUZXh0SGlnaGxpZ2h0U3R5bGUoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJpdGVtXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInNlcmllc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xudmFyIFNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuc2hvd0luTGVnZW5kID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgIHRoaXMubm9kZUNsaWNrUmFuZ2UgPSBcImV4YWN0XCI7XG4gICAgdGhpcy5oaWdobGlnaHQgPSBuZXcgSGlnaGxpZ2h0UHJvcGVydGllcygpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3R5bGUgPSBuZXcgSGlnaGxpZ2h0U3R5bGUoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjdXJzb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSlcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vZGVDbGlja1JhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0U3R5bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vY2FydGVzaWFuU2VyaWVzLnRzXG52YXIgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMgPSB7XG4gIFtcInhcIiAvKiBYICovXTogW1wieEtleVwiXSxcbiAgW1wieVwiIC8qIFkgKi9dOiBbXCJ5S2V5XCJdXG59O1xudmFyIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyA9IHtcbiAgW1wieFwiIC8qIFggKi9dOiBbXCJ4TmFtZVwiXSxcbiAgW1wieVwiIC8qIFkgKi9dOiBbXCJ5TmFtZVwiXVxufTtcbnZhciBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIFNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMueEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnhLZXk7XG4gICAgdGhpcy55S2V5ID0gc2VyaWVzLnByb3BlcnRpZXMueUtleTtcbiAgfVxufTtcbnZhciBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpcyA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpc1wiLCAyKTtcbnZhciBDYXJ0ZXNpYW5TZXJpZXMgPSBjbGFzcyBleHRlbmRzIERhdGFNb2RlbFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXRoc1BlclNlcmllcyA9IFtcInBhdGhcIl0sXG4gICAgaGFzTWFya2VycyA9IGZhbHNlLFxuICAgIGhhc0hpZ2hsaWdodGVkTGFiZWxzID0gZmFsc2UsXG4gICAgcGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldCA9IFtdLFxuICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlLFxuICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uID0gdHJ1ZSxcbiAgICBhbmltYXRpb25BbHdheXNVcGRhdGVTZWxlY3Rpb25zID0gZmFsc2UsXG4gICAgYW5pbWF0aW9uUmVzZXRGbnMsXG4gICAgZGlyZWN0aW9uS2V5cyxcbiAgICBkaXJlY3Rpb25OYW1lcyxcbiAgICAuLi5vdGhlck9wdHNcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGRpcmVjdGlvbktleXMsXG4gICAgICBkaXJlY3Rpb25OYW1lcyxcbiAgICAgIGNhbkhhdmVBeGVzOiB0cnVlLFxuICAgICAgLi4ub3RoZXJPcHRzXG4gICAgfSk7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5kYXRhTm9kZUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1zZXJpZXMtZGF0YU5vZGVzYCxcbiAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJkYXRhXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5tYXJrZXJHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLW1hcmtlcnNgLFxuICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcIm1hcmtlclwiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLWxhYmVsc2AsXG4gICAgICAgIHpJbmRleDogOCAvKiBTRVJJRVNfTEFCRUxfWklOREVYICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwibGFiZWxzXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5sYWJlbEdyb3VwLCBUZXh0KTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmhpZ2hsaWdodE5vZGUsXG4gICAgICAoKSA9PiB0aGlzLm9wdHMuaGFzTWFya2VycyA/IHRoaXMubWFya2VyRmFjdG9yeSgpIDogdGhpcy5ub2RlRmFjdG9yeSgpXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmhpZ2hsaWdodExhYmVsLCBUZXh0KTtcbiAgICB0aGlzLmFubm90YXRpb25TZWxlY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLm1pblJlY3RzQ2FjaGUgPSB7XG4gICAgICBkaXJ0eU5vZGVEYXRhOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKCk7XG4gICAgaWYgKCFkaXJlY3Rpb25LZXlzIHx8ICFkaXJlY3Rpb25OYW1lcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGluaXRpYWxpc2Ugc2VyaWVzIHR5cGUgJHt0aGlzLnR5cGV9YCk7XG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgcGF0aHNQZXJTZXJpZXMsXG4gICAgICBoYXNNYXJrZXJzLFxuICAgICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHMsXG4gICAgICBwYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0LFxuICAgICAgZGlyZWN0aW9uS2V5cyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnMsXG4gICAgICBhbmltYXRpb25BbHdheXNVcGRhdGVTZWxlY3Rpb25zLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbixcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uXG4gICAgfTtcbiAgICB0aGlzLnBhdGhzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdGhzUGVyU2VyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGhpcy5wYXRoc1tpbmRleF0gPSBuZXcgUGF0aCh7IG5hbWU6IGAke3RoaXMuaWR9LSR7cGF0aHNQZXJTZXJpZXNbaW5kZXhdfWAgfSk7XG4gICAgICB0aGlzLnBhdGhzW2luZGV4XS56SW5kZXggPSA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi87XG4gICAgICB0aGlzLnBhdGhzW2luZGV4XS56SW5kZXhTdWJPcmRlciA9IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcInBhdGhzXCIsIGluZGV4KTtcbiAgICAgIHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKHRoaXMucGF0aHNbaW5kZXhdKTtcbiAgICB9XG4gICAgdGhpcy5kYXR1bVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmRhdGFOb2RlR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uXG4gICAgKTtcbiAgICB0aGlzLm1hcmtlclNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLm1hcmtlckdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5tYXJrZXJGYWN0b3J5KCksXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvblxuICAgICk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXG4gICAgICBcImVtcHR5XCIsXG4gICAgICB7XG4gICAgICAgIGVtcHR5OiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiLFxuICAgICAgICAgIGRpc2FibGU6IFwiZGlzYWJsZWRcIlxuICAgICAgICB9LFxuICAgICAgICByZWFkeToge1xuICAgICAgICAgIHVwZGF0ZURhdGE6IFwid2FpdGluZ1wiLFxuICAgICAgICAgIGNsZWFyOiBcImNsZWFyaW5nXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSksXG4gICAgICAgICAgaGlnaGxpZ2h0TWFya2VyczogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhkYXRhKSxcbiAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdGluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiLFxuICAgICAgICAgIGRpc2FibGU6IFwiZGlzYWJsZWRcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZDoge1xuICAgICAgICAgIHVwZGF0ZTogKGRhdGEpID0+IHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIlxuICAgICAgICB9LFxuICAgICAgICBjbGVhcmluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKCkgPT4gdGhpcy5jaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKClcbiAgICApO1xuICB9XG4gIGdldCBjb250ZXh0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHROb2RlRGF0YTtcbiAgfVxuICBnZXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Tm9kZURhdGE/Lm5vZGVEYXRhO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9uKHBoYXNlKSB7XG4gICAgaWYgKHBoYXNlID09PSBcImluaXRpYWxcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzZXRcIik7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJza2lwXCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwiZGlzYWJsZWRcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiZGlzYWJsZVwiKTtcbiAgICB9XG4gIH1cbiAgYWRkQ2hhcnRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihcbiAgICAgICAgXCJsZWdlbmQtaXRlbS1kb3VibGUtY2xpY2tcIixcbiAgICAgICAgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbURvdWJsZUNsaWNrKGV2ZW50KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fY29udGV4dE5vZGVEYXRhID0gdm9pZCAwO1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgX2NvbnRleHROb2RlRGF0YTogcHJldmlvdXNDb250ZXh0RGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpZXMgPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyPy5nZXRBY3RpdmVIaWdobGlnaHQoKT8uc2VyaWVzO1xuICAgIGNvbnN0IHNlcmllc0hpZ2hsaWdodGVkID0gc2VyaWVzID09PSB0aGlzO1xuICAgIGNvbnN0IHJlc2l6ZSA9IHRoaXMuY2hlY2tSZXNpemUoc2VyaWVzUmVjdCk7XG4gICAgY29uc3QgaGlnaGxpZ2h0SXRlbXMgPSBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbihzZXJpZXNIaWdobGlnaHRlZCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rpb25zKHZpc2libGUpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoaGlnaGxpZ2h0SXRlbXMsIHNlcmllc0hpZ2hsaWdodGVkLCB2aXNpYmxlKTtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0gdGhpcy5nZXRBbmltYXRpb25EYXRhKHNlcmllc1JlY3QsIHByZXZpb3VzQ29udGV4dERhdGEpO1xuICAgIGlmICghYW5pbWF0aW9uRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNpemVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZWxlY3Rpb25zKGFueVNlcmllc0l0ZW1FbmFibGVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFuaW1hdGlvblNraXBVcGRhdGUgPSAhdGhpcy5vcHRzLmFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnMgJiYgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBpZiAoIWFueVNlcmllc0l0ZW1FbmFibGVkICYmIGFuaW1hdGlvblNraXBVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5vZGVEYXRhUmVmcmVzaCAmJiAhdGhpcy5pc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9kZURhdGFSZWZyZXNoKSB7XG4gICAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWJ1ZyhgQ2FydGVzaWFuU2VyaWVzLnVwZGF0ZVNlbGVjdGlvbnMoKSAtIGNhbGxpbmcgY3JlYXRlTm9kZURhdGEoKSBmb3JgLCB0aGlzLmlkKTtcbiAgICAgIHRoaXMubWFya1F1YWR0cmVlRGlydHkoKTtcbiAgICAgIHRoaXMuX2NvbnRleHROb2RlRGF0YSA9IGF3YWl0IHRoaXMuY3JlYXRlTm9kZURhdGEoKTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvblZhbGlkID0gdGhpcy5pc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCk7XG4gICAgICBpZiAodGhpcy5fY29udGV4dE5vZGVEYXRhKSB7XG4gICAgICAgIChfYSA9IHRoaXMuX2NvbnRleHROb2RlRGF0YSkuYW5pbWF0aW9uVmFsaWQgPz8gKF9hLmFuaW1hdGlvblZhbGlkID0gYW5pbWF0aW9uVmFsaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5taW5SZWN0c0NhY2hlLmRpcnR5Tm9kZURhdGEgPSB0cnVlO1xuICAgICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgICBpZiAoZGF0YU1vZGVsICE9PSB2b2lkIDAgJiYgcHJvY2Vzc2VkRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLXVwZGF0ZVwiLCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy51cGRhdGVTZXJpZXNTZWxlY3Rpb25zKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlU2VyaWVzU2VsZWN0aW9ucyhzZXJpZXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb24sIHBhdGhzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbnRleHREYXRhID0gdGhpcy5fY29udGV4dE5vZGVEYXRhO1xuICAgIGlmICghY29udGV4dERhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbGFiZWxEYXRhLCBpdGVtSWQgfSA9IGNvbnRleHREYXRhO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlUGF0aHMoeyBzZXJpZXNIaWdobGlnaHRlZCwgaXRlbUlkLCBjb250ZXh0RGF0YSwgcGF0aHMgfSk7XG4gICAgdGhpcy5kYXR1bVNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlRGF0dW1TZWxlY3Rpb24oeyBub2RlRGF0YSwgZGF0dW1TZWxlY3Rpb24gfSk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlTGFiZWxTZWxlY3Rpb24oeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0pO1xuICAgIGlmICh0aGlzLm9wdHMuaGFzTWFya2Vycykge1xuICAgICAgdGhpcy5tYXJrZXJTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZU1hcmtlclNlbGVjdGlvbih7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSk7XG4gICAgfVxuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlLCBzdWJJbmRleCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4KTtcbiAgICBpZiAodHlwZSA9PT0gXCJwYXRoc1wiKSB7XG4gICAgICBjb25zdCBbc3VwZXJGbl0gPSByZXN1bHQ7XG4gICAgICBjb25zdCBwYXRoT2Zmc2V0ID0gdGhpcy5vcHRzLnBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXRbc3ViSW5kZXhdID8/IDA7XG4gICAgICByZXN1bHRbMF0gPSBpc0Z1bmN0aW9uKHN1cGVyRm4pID8gKCkgPT4gTnVtYmVyKHN1cGVyRm4oKSkgKyBwYXRoT2Zmc2V0IDogTnVtYmVyKHN1cGVyRm4pICsgcGF0aE9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyB1cGRhdGVOb2RlcyhoaWdobGlnaHRlZEl0ZW1zLCBzZXJpZXNIaWdobGlnaHRlZCwgYW55U2VyaWVzSXRlbUVuYWJsZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbixcbiAgICAgIG9wdHM6IHsgaGFzTWFya2VycywgaGFzSGlnaGxpZ2h0ZWRMYWJlbHMgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB2aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHRoaXMuX2NvbnRleHROb2RlRGF0YSAhPSBudWxsICYmIGFueVNlcmllc0l0ZW1FbmFibGVkO1xuICAgIHRoaXMucm9vdEdyb3VwLnZpc2libGUgPSBhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnZpc2libGUgPSAoYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlKSAmJiBzZXJpZXNIaWdobGlnaHRlZDtcbiAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XG4gICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTWFya2VyTm9kZXMoe1xuICAgICAgICBtYXJrZXJTZWxlY3Rpb246IGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgICAgaXNIaWdobGlnaHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiaGlnaGxpZ2h0TWFya2Vyc1wiLCBoaWdobGlnaHRTZWxlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZURhdHVtTm9kZXMoe1xuICAgICAgICBkYXR1bVNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgICBpc0hpZ2hsaWdodDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJoaWdobGlnaHRcIiwgaGlnaGxpZ2h0U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGhhc0hpZ2hsaWdodGVkTGFiZWxzKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUxhYmVsTm9kZXMoeyBsYWJlbFNlbGVjdGlvbjogaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YU5vZGVHcm91cCwgbWFya2VyR3JvdXAsIGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgbWFya2VyU2VsZWN0aW9uLCBwYXRocywgbGFiZWxHcm91cCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGl0ZW1JZCB9ID0gdGhpcy5jb250ZXh0Tm9kZURhdGEgPz8ge307XG4gICAgZGF0YU5vZGVHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICBkYXRhTm9kZUdyb3VwLnZpc2libGUgPSBhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGU7XG4gICAgbGFiZWxHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgbWFya2VyR3JvdXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICBtYXJrZXJHcm91cC56SW5kZXggPSBkYXRhTm9kZUdyb3VwLnpJbmRleCA+PSA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8gPyBkYXRhTm9kZUdyb3VwLnpJbmRleCA6IGRhdGFOb2RlR3JvdXAuekluZGV4ICsgMTtcbiAgICAgIG1hcmtlckdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICBpZiAobGFiZWxHcm91cCkge1xuICAgICAgbGFiZWxHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy51cGRhdGVQYXRoTm9kZXMoe1xuICAgICAgc2VyaWVzSGlnaGxpZ2h0ZWQsXG4gICAgICBpdGVtSWQsXG4gICAgICBwYXRocyxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlLFxuICAgICAgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0pO1xuICAgIGlmICghZGF0YU5vZGVHcm91cC52aXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlRGF0dW1Ob2Rlcyh7IGRhdHVtU2VsZWN0aW9uLCBoaWdobGlnaHRlZEl0ZW1zLCBpc0hpZ2hsaWdodDogZmFsc2UgfSk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVMYWJlbE5vZGVzKHsgbGFiZWxTZWxlY3Rpb24gfSk7XG4gICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTWFya2VyTm9kZXMoeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0TGFiZWxEYXRhKGxhYmVsRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgY29uc3QgbGFiZWxJdGVtcyA9IGxhYmVsRGF0YS5maWx0ZXIoXG4gICAgICAobGQpID0+IGxkLmRhdHVtID09PSBoaWdobGlnaHRlZEl0ZW0uZGF0dW0gJiYgbGQuaXRlbUlkID09PSBoaWdobGlnaHRlZEl0ZW0uaXRlbUlkXG4gICAgKTtcbiAgICByZXR1cm4gbGFiZWxJdGVtcy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiBsYWJlbEl0ZW1zO1xuICB9XG4gIGdldEhpZ2hsaWdodERhdGEoX25vZGVEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWRJdGVtID8gW2hpZ2hsaWdodGVkSXRlbV0gOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0Tm9kZURhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xuICAgIGNvbnN0IGl0ZW0gPSBzZXJpZXNIaWdobGlnaHRlZCAmJiBoaWdobGlnaHRlZERhdHVtPy5kYXR1bSA/IGhpZ2hsaWdodGVkRGF0dW0gOiB2b2lkIDA7XG4gICAgbGV0IGxhYmVsSXRlbXM7XG4gICAgbGV0IGhpZ2hsaWdodEl0ZW1zO1xuICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxhYmVsc0VuYWJsZWQgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCk7XG4gICAgICBjb25zdCB7IGxhYmVsRGF0YSwgbm9kZURhdGEgfSA9IGNvbnRleHROb2RlRGF0YTtcbiAgICAgIGhpZ2hsaWdodEl0ZW1zID0gdGhpcy5nZXRIaWdobGlnaHREYXRhKG5vZGVEYXRhLCBpdGVtKTtcbiAgICAgIGxhYmVsSXRlbXMgPSBsYWJlbHNFbmFibGVkID8gdGhpcy5nZXRIaWdobGlnaHRMYWJlbERhdGEobGFiZWxEYXRhLCBpdGVtKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkl0ZW0oe1xuICAgICAgaXRlbXM6IGhpZ2hsaWdodEl0ZW1zLFxuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uXG4gICAgfSk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uTGFiZWwoe1xuICAgICAgaXRlbXM6IGxhYmVsSXRlbXMsXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvblxuICAgIH0pO1xuICAgIHJldHVybiBoaWdobGlnaHRJdGVtcztcbiAgfVxuICBtYXJrUXVhZHRyZWVEaXJ0eSgpIHtcbiAgICB0aGlzLnF1YWR0cmVlID0gdm9pZCAwO1xuICB9XG4gICpkYXR1bU5vZGVzSXRlcigpIHtcbiAgICBmb3IgKGNvbnN0IHsgbm9kZSB9IG9mIHRoaXMuZGF0dW1TZWxlY3Rpb24pIHtcbiAgICAgIGlmIChub2RlLmRhdHVtLm1pc3NpbmcgPT09IHRydWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbiAgZ2V0UXVhZFRyZWUoKSB7XG4gICAgaWYgKHRoaXMucXVhZHRyZWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmN0eC5zY2VuZS5jYW52YXM7XG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gbmV3IEJCb3goMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLnF1YWR0cmVlID0gbmV3IFF1YWR0cmVlTmVhcmVzdCgxMDAsIDEwLCBjYW52YXNSZWN0KTtcbiAgICAgIHRoaXMuaW5pdFF1YWRUcmVlKHRoaXMucXVhZHRyZWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdWFkdHJlZTtcbiAgfVxuICBpbml0UXVhZFRyZWUoX3F1YWR0cmVlKSB7XG4gIH1cbiAgcGlja05vZGVFeGFjdFNoYXBlKHBvaW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGlja05vZGVFeGFjdFNoYXBlKHBvaW50KTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdHM6IHsgaGFzTWFya2VycyB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IHsgZGF0YU5vZGVHcm91cCwgbWFya2VyR3JvdXAgfSA9IHRoaXM7XG4gICAgbWF0Y2ggPSBkYXRhTm9kZUdyb3VwLnBpY2tOb2RlKHgsIHkpO1xuICAgIGlmICghbWF0Y2ggJiYgaGFzTWFya2Vycykge1xuICAgICAgbWF0Y2ggPSBtYXJrZXJHcm91cD8ucGlja05vZGUoeCwgeSk7XG4gICAgfVxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5kYXR1bS5taXNzaW5nICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4geyBkYXR1bTogbWF0Y2guZGF0dW0sIGRpc3RhbmNlOiAwIH07XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kMiBvZiB0aGlzLm1vZHVsZU1hcC5tb2R1bGVzKCkpIHtcbiAgICAgIGNvbnN0IHsgZGF0dW0gfSA9IG1vZDIucGlja05vZGVFeGFjdChwb2ludCkgPz8ge307XG4gICAgICBpZiAoZGF0dW0gPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoZGF0dW0/Lm1pc3NpbmcgPT09IHRydWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIHsgZGF0dW0sIGRpc3RhbmNlOiAwIH07XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCB7IGF4ZXMsIHJvb3RHcm91cCwgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dE5vZGVEYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3QgaGl0UG9pbnQgPSByb290R3JvdXAudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgbGV0IGNsb3Nlc3REYXR1bTtcbiAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIGNvbnRleHROb2RlRGF0YS5ub2RlRGF0YSkge1xuICAgICAgY29uc3QgeyBwb2ludDogeyB4OiBkYXR1bVggPSBOYU4sIHk6IGRhdHVtWSA9IE5hTiB9ID0ge30gfSA9IGRhdHVtO1xuICAgICAgaWYgKGlzTmFOKGRhdHVtWCkgfHwgaXNOYU4oZGF0dW1ZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzSW5SYW5nZSA9IHhBeGlzPy5pblJhbmdlKGRhdHVtWCkgJiYgeUF4aXM/LmluUmFuZ2UoZGF0dW1ZKTtcbiAgICAgIGlmICghaXNJblJhbmdlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzdGFuY2UzID0gTWF0aC5tYXgoKGhpdFBvaW50LnggLSBkYXR1bVgpICoqIDIgKyAoaGl0UG9pbnQueSAtIGRhdHVtWSkgKiogMiwgMCk7XG4gICAgICBpZiAoZGlzdGFuY2UzIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTM7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IGRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZDIgb2YgdGhpcy5tb2R1bGVNYXAubW9kdWxlcygpKSB7XG4gICAgICBjb25zdCBtb2RQaWNrID0gbW9kMi5waWNrTm9kZU5lYXJlc3QocG9pbnQpO1xuICAgICAgaWYgKG1vZFBpY2sgIT09IHZvaWQgMCAmJiBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gbW9kUGljay5kaXN0YW5jZVNxdWFyZWQ7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IG1vZFBpY2suZGF0dW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VzdERhdHVtKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZTMgPSBNYXRoLm1heChNYXRoLnNxcnQobWluRGlzdGFuY2UpIC0gKGNsb3Nlc3REYXR1bS5wb2ludD8uc2l6ZSA/PyAwKSwgMCk7XG4gICAgICByZXR1cm4geyBkYXR1bTogY2xvc2VzdERhdHVtLCBkaXN0YW5jZTogZGlzdGFuY2UzIH07XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCwgcmVxdWlyZUNhdGVnb3J5QXhpcykge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3QgeyBheGVzLCByb290R3JvdXAsIF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHROb2RlRGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpcyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghY29udGV4dE5vZGVEYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3QgZGlyZWN0aW9uczIgPSBbeEF4aXMsIHlBeGlzXS5maWx0ZXIoKGEpID0+IGEgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMpLm1hcCgoYSkgPT4gYS5kaXJlY3Rpb24pO1xuICAgIGlmIChyZXF1aXJlQ2F0ZWdvcnlBeGlzICYmIGRpcmVjdGlvbnMyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbWFqb3JEaXJlY3Rpb24gPSBcInhcIiAvKiBYICovXSA9IGRpcmVjdGlvbnMyO1xuICAgIGNvbnN0IGhpdFBvaW50ID0gcm9vdEdyb3VwLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGhpdFBvaW50Q29vcmRzID0gW2hpdFBvaW50LngsIGhpdFBvaW50LnldO1xuICAgIGlmIChtYWpvckRpcmVjdGlvbiAhPT0gXCJ4XCIgLyogWCAqLylcbiAgICAgIGhpdFBvaW50Q29vcmRzLnJldmVyc2UoKTtcbiAgICBjb25zdCBtaW5EaXN0YW5jZSA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIGxldCBjbG9zZXN0RGF0dW07XG4gICAgZm9yIChjb25zdCBkYXR1bSBvZiBjb250ZXh0Tm9kZURhdGEubm9kZURhdGEpIHtcbiAgICAgIGNvbnN0IHsgeDogZGF0dW1YID0gTmFOLCB5OiBkYXR1bVkgPSBOYU4gfSA9IGRhdHVtLnBvaW50ID8/IGRhdHVtLm1pZFBvaW50ID8/IHt9O1xuICAgICAgaWYgKGlzTmFOKGRhdHVtWCkgfHwgaXNOYU4oZGF0dW1ZKSB8fCBkYXR1bS5taXNzaW5nID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlzaWJsZSA9IFt4QXhpcz8uaW5SYW5nZShkYXR1bVgpLCB5QXhpcz8uaW5SYW5nZShkYXR1bVkpXTtcbiAgICAgIGlmIChtYWpvckRpcmVjdGlvbiAhPT0gXCJ4XCIgLyogWCAqLylcbiAgICAgICAgdmlzaWJsZS5yZXZlcnNlKCk7XG4gICAgICBpZiAoIXZpc2libGVbMF0gfHwgIXBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpcyAmJiAhdmlzaWJsZVsxXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdHVtUG9pbnQgPSBbZGF0dW1YLCBkYXR1bVldO1xuICAgICAgaWYgKG1ham9yRGlyZWN0aW9uICE9PSBcInhcIiAvKiBYICovKVxuICAgICAgICBkYXR1bVBvaW50LnJldmVyc2UoKTtcbiAgICAgIGxldCBuZXdNaW5EaXN0YW5jZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdHVtUG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguYWJzKGRhdHVtUG9pbnRbaV0gLSBoaXRQb2ludENvb3Jkc1tpXSk7XG4gICAgICAgIGlmIChkaXN0ID4gbWluRGlzdGFuY2VbaV0pIHtcbiAgICAgICAgICBuZXdNaW5EaXN0YW5jZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXN0IDwgbWluRGlzdGFuY2VbaV0pIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZVtpXSA9IGRpc3Q7XG4gICAgICAgICAgbWluRGlzdGFuY2UuZmlsbChJbmZpbml0eSwgaSArIDEsIG1pbkRpc3RhbmNlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdNaW5EaXN0YW5jZSkge1xuICAgICAgICBjbG9zZXN0RGF0dW0gPSBkYXR1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsb3Nlc3REYXR1bSkge1xuICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBNYXRoLm1heChcbiAgICAgICAgbWluRGlzdGFuY2VbMF0gKiogMiArIG1pbkRpc3RhbmNlWzFdICoqIDIgLSAoY2xvc2VzdERhdHVtLnBvaW50Py5zaXplID8/IDApLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBtb2QyIG9mIHRoaXMubW9kdWxlTWFwLm1vZHVsZXMoKSkge1xuICAgICAgICBjb25zdCBtb2RQaWNrID0gbW9kMi5waWNrTm9kZU1haW5BeGlzRmlyc3QocG9pbnQpO1xuICAgICAgICBpZiAobW9kUGljayAhPT0gdm9pZCAwICYmIG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkIDwgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgIGNsb3Nlc3REYXR1bSA9IG1vZFBpY2suZGF0dW07XG4gICAgICAgICAgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCA9IG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXR1bTogY2xvc2VzdERhdHVtLCBkaXN0YW5jZTogTWF0aC5zcXJ0KGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQpIH07XG4gICAgfVxuICB9XG4gIG9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMgfSA9IGV2ZW50O1xuICAgIGNvbnN0IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSA9IGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgbGVnZW5kSXRlbU5hbWUgPT09IGV2ZW50LmxlZ2VuZEl0ZW1OYW1lO1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQgfHwgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKTtcbiAgICB9XG4gIH1cbiAgb25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBudW1WaXNpYmxlSXRlbXMgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUgPSBsZWdlbmRJdGVtTmFtZSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1OYW1lID09PSBldmVudC5sZWdlbmRJdGVtTmFtZTtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkIHx8IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlbmFibGVkICYmIG51bVZpc2libGVJdGVtcyA9PT0gMSkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYW55IGFkamFjZW50IHR3byBub2Rlcy4gVGhlIGF4ZXMgYXJlIHRyZWF0ZWQgaW5kZXBlbmRlbnRseSwgc28gdGhpc1xuICAgKiBtYXkgbm90IHJlcHJlc2VudCB0aGUgc2FtZSB0d28gcG9pbnRzIGZvciBib3RoIGRpcmVjdGlvbnMuIFRoZSBkaW1lbnNpb25zIHJlcHJlc2VudCB0aGUgZ3JlYXRlc3QgZGlzdGFuY2VcbiAgICogYmV0d2VlbiBhbnkgdHdvIGFkamFjZW50IG5vZGVzLlxuICAgKi9cbiAgZ2V0TWluUmVjdHMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHsgZGlydHlOb2RlRGF0YSwgc2l6ZUNhY2hlLCBtaW5SZWN0LCBtaW5WaXNpYmxlUmVjdCB9ID0gdGhpcy5taW5SZWN0c0NhY2hlO1xuICAgIGNvbnN0IG5ld1NpemVDYWNoZSA9IEpTT04uc3RyaW5naWZ5KHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBjb25zdCBkaXJ0eVNpemUgPSBuZXdTaXplQ2FjaGUgIT09IHNpemVDYWNoZTtcbiAgICBpZiAoIWRpcnR5U2l6ZSAmJiAhZGlydHlOb2RlRGF0YSAmJiBtaW5SZWN0ICYmIG1pblZpc2libGVSZWN0KSB7XG4gICAgICByZXR1cm4geyBtaW5SZWN0LCBtaW5WaXNpYmxlUmVjdCB9O1xuICAgIH1cbiAgICBjb25zdCByZWN0cyA9IHRoaXMuY29tcHV0ZU1pblJlY3RzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubWluUmVjdHNDYWNoZSA9IHtcbiAgICAgIGRpcnR5Tm9kZURhdGE6IGZhbHNlLFxuICAgICAgc2l6ZUNhY2hlOiBuZXdTaXplQ2FjaGUsXG4gICAgICBtaW5SZWN0OiByZWN0cz8ubWluUmVjdCxcbiAgICAgIG1pblZpc2libGVSZWN0OiByZWN0cz8ubWluVmlzaWJsZVJlY3RcbiAgICB9O1xuICAgIHJldHVybiByZWN0cztcbiAgfVxuICBjb21wdXRlTWluUmVjdHMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gICAgaWYgKCFjb250ZXh0Py5ub2RlRGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBub2RlRGF0YSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBtaW5SZWN0WHMgPSBBcnJheShub2RlRGF0YS5sZW5ndGgpO1xuICAgIGNvbnN0IG1pblJlY3RZcyA9IEFycmF5KG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBbaSwgeyBtaWRQb2ludCB9XSBvZiBub2RlRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgIG1pblJlY3RYc1tpXSA9IG1pZFBvaW50Py54ID8/IDA7XG4gICAgICBtaW5SZWN0WXNbaV0gPSBtaWRQb2ludD8ueSA/PyAwO1xuICAgIH1cbiAgICBtaW5SZWN0WHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIG1pblJlY3RZcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgbGV0IHplcm9YLCB3aWR0aFgsIHplcm9ZLCBoZWlnaHRZO1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBub2RlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1pblJlY3RYc1tpXSA+PSAwKVxuICAgICAgICB6ZXJvWCA/PyAoemVyb1ggPSBpKTtcbiAgICAgIGlmIChtaW5SZWN0WHNbaV0gPiB3aWR0aClcbiAgICAgICAgd2lkdGhYID8/ICh3aWR0aFggPSBpKTtcbiAgICAgIGlmIChtaW5SZWN0WXNbaV0gPj0gMClcbiAgICAgICAgemVyb1kgPz8gKHplcm9ZID0gaSk7XG4gICAgICBpZiAobWluUmVjdFlzW2ldID4gaGVpZ2h0KVxuICAgICAgICBoZWlnaHRZID8/IChoZWlnaHRZID0gaSk7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBtaW5SZWN0WHNbaV0gLSBtaW5SZWN0WHNbaSAtIDFdKTtcbiAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgbWluUmVjdFlzW2ldIC0gbWluUmVjdFlzW2kgLSAxXSk7XG4gICAgfVxuICAgIHdpZHRoWCA/PyAod2lkdGhYID0gbm9kZURhdGEubGVuZ3RoKTtcbiAgICBoZWlnaHRZID8/IChoZWlnaHRZID0gbm9kZURhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBtaW5WaXNpYmxlUmVjdFhzID0gemVyb1ggIT0gbnVsbCAmJiB3aWR0aFggIT0gbnVsbCA/IG1pblJlY3RYcy5zbGljZSh6ZXJvWCwgd2lkdGhYKSA6IFtdO1xuICAgIGNvbnN0IG1pblZpc2libGVSZWN0WXMgPSB6ZXJvWSAhPSBudWxsICYmIGhlaWdodFkgIT0gbnVsbCA/IG1pblJlY3RZcy5zbGljZSh6ZXJvWSwgaGVpZ2h0WSkgOiBbXTtcbiAgICBsZXQgbWF4VmlzaWJsZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4VmlzaWJsZUhlaWdodCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBNYXRoLm1heChtaW5WaXNpYmxlUmVjdFhzLmxlbmd0aCwgbWluVmlzaWJsZVJlY3RZcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHgxID0gbWluVmlzaWJsZVJlY3RYc1tpXTtcbiAgICAgIGNvbnN0IHgyID0gbWluVmlzaWJsZVJlY3RYc1tpIC0gMV07XG4gICAgICBjb25zdCB5MSA9IG1pblZpc2libGVSZWN0WXNbaV07XG4gICAgICBjb25zdCB5MiA9IG1pblZpc2libGVSZWN0WXNbaSAtIDFdO1xuICAgICAgaWYgKHgxICE9IG51bGwgJiYgeDIgIT0gbnVsbCkge1xuICAgICAgICBtYXhWaXNpYmxlV2lkdGggPSBNYXRoLm1heChtYXhWaXNpYmxlV2lkdGgsIHgxIC0geDIpO1xuICAgICAgfVxuICAgICAgaWYgKHkxICE9IG51bGwgJiYgeTIgIT0gbnVsbCkge1xuICAgICAgICBtYXhWaXNpYmxlSGVpZ2h0ID0gTWF0aC5tYXgobWF4VmlzaWJsZUhlaWdodCwgeTEgLSB5Mik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pblJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICBjb25zdCBtaW5WaXNpYmxlUmVjdCA9IG5ldyBCQm94KDAsIDAsIG1heFZpc2libGVXaWR0aCwgbWF4VmlzaWJsZUhlaWdodCk7XG4gICAgcmV0dXJuIHsgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfTtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25JdGVtKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaXRlbXMsIGhpZ2hsaWdodFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCBub2RlRGF0YSA9IGl0ZW1zID8/IFtdO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBjb25zdCBtYXJrZXJTZWxlY3Rpb24gPSBoaWdobGlnaHRTZWxlY3Rpb247XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVNYXJrZXJTZWxlY3Rpb24oeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVEYXR1bVNlbGVjdGlvbih7XG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBkYXR1bVNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uTGFiZWwob3B0cykge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZUxhYmVsU2VsZWN0aW9uKHtcbiAgICAgIGxhYmVsRGF0YTogb3B0cy5pdGVtcyA/PyBbXSxcbiAgICAgIGxhYmVsU2VsZWN0aW9uOiBvcHRzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLmRhdHVtU2VsZWN0aW9uO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtTm9kZXMoX29wdHMpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLm1hcmtlclNlbGVjdGlvbjtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2Rlcyhfb3B0cykge1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICBvcHRzLnBhdGhzLmZvckVhY2goKHApID0+IHAudmlzaWJsZSA9IGZhbHNlKTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRoTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgcGF0aHMsIG9wYWNpdHksIHZpc2libGUgfSA9IG9wdHM7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBwYXRoLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgcGF0aC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gIH1cbiAgcmVzZXRQYXRoQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGRhdGEucGF0aHMuZm9yRWFjaCgocGF0aHMpID0+IHtcbiAgICAgICAgcmVzZXRNb3Rpb24oW3BhdGhzXSwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVzZXREYXR1bUFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBkYXR1bSB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAoZGF0dW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhLmRhdHVtU2VsZWN0aW9uXSwgZGF0dW0pO1xuICAgIH1cbiAgfVxuICByZXNldExhYmVsQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGEubGFiZWxTZWxlY3Rpb25dLCBsYWJlbCk7XG4gICAgfVxuICB9XG4gIHJlc2V0TWFya2VyQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAobWFya2VyICYmIHRoaXMub3B0cy5oYXNNYXJrZXJzKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YS5tYXJrZXJTZWxlY3Rpb25dLCBtYXJrZXIpO1xuICAgIH1cbiAgfVxuICByZXNldEFsbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGRhdGEpO1xuICAgIHRoaXMucmVzZXREYXR1bUFuaW1hdGlvbihkYXRhKTtcbiAgICB0aGlzLnJlc2V0TGFiZWxBbmltYXRpb24oZGF0YSk7XG4gICAgdGhpcy5yZXNldE1hcmtlckFuaW1hdGlvbihkYXRhKTtcbiAgICBpZiAoZGF0YS5jb250ZXh0RGF0YT8uYW5pbWF0aW9uVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGRhdHVtKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YV0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhkYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBtYXJrZXIpO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoZGF0YSkge1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0aW9uVHJhbnNpdGlvbkNsZWFyKCkge1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKTtcbiAgICBpZiAoIWFuaW1hdGlvbkRhdGEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiY2xlYXJcIiwgYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0LCBwcmV2aW91c0NvbnRleHREYXRhKSB7XG4gICAgY29uc3QgeyBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0RGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHREYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB7XG4gICAgICBkYXR1bVNlbGVjdGlvbjogdGhpcy5kYXR1bVNlbGVjdGlvbixcbiAgICAgIG1hcmtlclNlbGVjdGlvbjogdGhpcy5tYXJrZXJTZWxlY3Rpb24sXG4gICAgICBsYWJlbFNlbGVjdGlvbjogdGhpcy5sYWJlbFNlbGVjdGlvbixcbiAgICAgIGFubm90YXRpb25TZWxlY3Rpb25zOiBbLi4udGhpcy5hbm5vdGF0aW9uU2VsZWN0aW9uc10sXG4gICAgICBjb250ZXh0RGF0YSxcbiAgICAgIHByZXZpb3VzQ29udGV4dERhdGEsXG4gICAgICBwYXRoczogdGhpcy5wYXRocyxcbiAgICAgIHNlcmllc1JlY3RcbiAgICB9O1xuICAgIHJldHVybiBhbmltYXRpb25EYXRhO1xuICB9XG4gIGNhbGN1bGF0ZVNjYWxpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBkaXJlY3Rpb24gb2YgT2JqZWN0LnZhbHVlcyhDaGFydEF4aXNEaXJlY3Rpb24pKSB7XG4gICAgICBjb25zdCBheGlzID0gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gICAgICBpZiAoIWF4aXMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGF4aXMuc2NhbGUgaW5zdGFuY2VvZiBMb2dTY2FsZSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMsIGRvbWFpbiB9ID0gYXhpcy5zY2FsZTtcbiAgICAgICAgcmVzdWx0W2RpcmVjdGlvbl0gPSB7XG4gICAgICAgICAgdHlwZTogXCJsb2dcIixcbiAgICAgICAgICBjb252ZXJ0OiAoZCkgPT4gYXhpcy5zY2FsZS5jb252ZXJ0KGQpLFxuICAgICAgICAgIGRvbWFpbjogW2RvbWFpblswXSwgZG9tYWluWzFdXSxcbiAgICAgICAgICByYW5nZTogW3JhbmdlM1swXSwgcmFuZ2UzWzFdXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChheGlzLnNjYWxlIGluc3RhbmNlb2YgQ29udGludW91c1NjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gYXhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gYXhpcy5zY2FsZS5nZXREb21haW4oKTtcbiAgICAgICAgcmVzdWx0W2RpcmVjdGlvbl0gPSB7XG4gICAgICAgICAgdHlwZTogXCJjb250aW51b3VzXCIsXG4gICAgICAgICAgZG9tYWluOiBbZG9tYWluWzBdLCBkb21haW5bMV1dLFxuICAgICAgICAgIHJhbmdlOiBbcmFuZ2UzWzBdLCByYW5nZTNbMV1dXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGF4aXMuc2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyBkb21haW4gfSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHJlc3VsdFtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgcmFuZ2U6IGRvbWFpbi5tYXAoKGQpID0+IGF4aXMuc2NhbGUuY29udmVydChkKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2FydGVzaWFuQ2hhcnQudHNcbnZhciBkaXJlY3Rpb25zID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xudmFyIENhcnRlc2lhbkNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gICAgLyoqIEludGVncmF0ZWQgQ2hhcnRzIGZlYXR1cmUgc3RhdGUgLSBub3QgdXNlZCBpbiBTdGFuZGFsb25lIENoYXJ0cy4gKi9cbiAgICB0aGlzLnBhaXJlZCA9IHRydWU7XG4gICAgdGhpcy5maXJzdFNlcmllc1RyYW5zbGF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzID0gdm9pZCAwO1xuICAgIHRoaXMuX2xhc3RBeGlzQXJlYVdpZHRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbGFzdENsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0VmlzaWJpbGl0eSA9IHtcbiAgICAgIGNyb3NzTGluZXM6IHRydWUsXG4gICAgICBzZXJpZXM6IHRydWVcbiAgICB9O1xuICB9XG4gIG9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBzdXBlci5vbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyLnVwZGF0ZUF4ZXMobmV3VmFsdWUpO1xuICB9XG4gIGRlc3Ryb3lTZXJpZXMoc2VyaWVzKSB7XG4gICAgc3VwZXIuZGVzdHJveVNlcmllcyhzZXJpZXMpO1xuICAgIHRoaXMuZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiA9IHRydWU7XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcImNhcnRlc2lhblwiO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgY29uc3Qgc2hyaW5rUmVjdCA9IGF3YWl0IHN1cGVyLnBlcmZvcm1MYXlvdXQoKTtcbiAgICBjb25zdCB7IGZpcnN0U2VyaWVzVHJhbnNsYXRpb24sIHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uUmVjdCwgc2VyaWVzUmVjdCwgdmlzaWJpbGl0eSwgY2xpcFNlcmllcyB9ID0gdGhpcy51cGRhdGVBeGVzKHNocmlua1JlY3QpO1xuICAgIHRoaXMuc2VyaWVzUm9vdC52aXNpYmxlID0gdmlzaWJpbGl0eS5zZXJpZXM7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gc2VyaWVzUmVjdDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBhbmltYXRpb25SZWN0O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gc2VyaWVzUmVjdDtcbiAgICBpZiAoZmlyc3RTZXJpZXNUcmFuc2xhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IoeSk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcnN0U2VyaWVzVHJhbnNsYXRpb24gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gc2VyaWVzUm9vdDtcbiAgICAgIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgXCJzZXJpZXNSZWN0XCIsXG4gICAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICAgIFtzZXJpZXNSb290LCBoaWdobGlnaHRSb290LCBhbm5vdGF0aW9uUm9vdF0sXG4gICAgICAgIHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSxcbiAgICAgICAgeyB0cmFuc2xhdGlvblg6IE1hdGguZmxvb3IoeCksIHRyYW5zbGF0aW9uWTogTWF0aC5mbG9vcih5KSB9LFxuICAgICAgICB7IHBoYXNlOiBcInVwZGF0ZVwiIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmllc1BhZGRlZFJlY3QgPSBzZXJpZXNSZWN0LmNsb25lKCkuZ3Jvdyh0aGlzLnNlcmllc0FyZWEucGFkZGluZyk7XG4gICAgY29uc3QgY2xpcFJlY3QgPSB0aGlzLnNlcmllc0FyZWEuY2xpcCB8fCBjbGlwU2VyaWVzID8gc2VyaWVzUGFkZGVkUmVjdCA6IHZvaWQgMDtcbiAgICBzZXJpZXNSb290LnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShjbGlwUmVjdCk7XG4gICAgaGlnaGxpZ2h0Um9vdC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoY2xpcFJlY3QpO1xuICAgIGFubm90YXRpb25Sb290LnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShjbGlwUmVjdCk7XG4gICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaExheW91dENvbXBsZXRlKHtcbiAgICAgIHR5cGU6IFwibGF5b3V0LWNvbXBsZXRlXCIsXG4gICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5jdHguc2NlbmUud2lkdGgsIGhlaWdodDogdGhpcy5jdHguc2NlbmUuaGVpZ2h0IH0sXG4gICAgICBjbGlwU2VyaWVzLFxuICAgICAgc2VyaWVzOiB7XG4gICAgICAgIHJlY3Q6IHNlcmllc1JlY3QsXG4gICAgICAgIHBhZGRlZFJlY3Q6IHNlcmllc1BhZGRlZFJlY3QsXG4gICAgICAgIHZpc2libGU6IHZpc2liaWxpdHkuc2VyaWVzLFxuICAgICAgICBzaG91bGRGbGlwWFk6IHRoaXMuc2hvdWxkRmxpcFhZKClcbiAgICAgIH0sXG4gICAgICBheGVzOiB0aGlzLmF4ZXMubWFwKChheGlzKSA9PiBheGlzLmdldExheW91dFN0YXRlKCkpXG4gICAgfSk7XG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1hcE1vZHVsZXMoKG0pID0+IG0ucGVyZm9ybUNhcnRlc2lhbkxheW91dD8uKHsgc2VyaWVzUmVjdCB9KSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUHJvbWlzZXMpO1xuICAgIHJldHVybiBzaHJpbmtSZWN0O1xuICB9XG4gIHVwZGF0ZUF4ZXMoaW5wdXRTaHJpbmtSZWN0KSB7XG4gICAgY29uc3QgY3Jvc3NMaW5lSWRzID0gdGhpcy5heGVzLmZsYXRNYXAoKGF4aXMpID0+IGF4aXMuY3Jvc3NMaW5lcyA/PyBbXSkubWFwKChjcm9zc0xpbmUpID0+IGNyb3NzTGluZS5pZCk7XG4gICAgY29uc3QgYXhlc1ZhbGlkID0gdGhpcy5fbGFzdENyb3NzTGluZUlkcyAhPSBudWxsICYmIHRoaXMuX2xhc3RDcm9zc0xpbmVJZHMubGVuZ3RoID09PSBjcm9zc0xpbmVJZHMubGVuZ3RoICYmIHRoaXMuX2xhc3RDcm9zc0xpbmVJZHMuZXZlcnkoKGlkLCBpbmRleCkgPT4gY3Jvc3NMaW5lSWRzW2luZGV4XSA9PT0gaWQpO1xuICAgIGxldCBheGlzQXJlYVdpZHRocztcbiAgICBsZXQgY2xpcFNlcmllcztcbiAgICBsZXQgdmlzaWJpbGl0eTtcbiAgICBpZiAoYXhlc1ZhbGlkKSB7XG4gICAgICBheGlzQXJlYVdpZHRocyA9IG5ldyBNYXAodGhpcy5fbGFzdEF4aXNBcmVhV2lkdGhzLmVudHJpZXMoKSk7XG4gICAgICBjbGlwU2VyaWVzID0gdGhpcy5fbGFzdENsaXBTZXJpZXM7XG4gICAgICB2aXNpYmlsaXR5ID0geyAuLi50aGlzLl9sYXN0VmlzaWJpbGl0eSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzQXJlYVdpZHRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjbGlwU2VyaWVzID0gZmFsc2U7XG4gICAgICB2aXNpYmlsaXR5ID0geyBjcm9zc0xpbmVzOiB0cnVlLCBzZXJpZXM6IHRydWUgfTtcbiAgICAgIHRoaXMuX2xhc3RDcm9zc0xpbmVJZHMgPSBjcm9zc0xpbmVJZHM7XG4gICAgfVxuICAgIGNvbnN0IGxpdmVBeGlzV2lkdGhzID0gbmV3IFNldCh0aGlzLmF4ZXMubWFwKChhKSA9PiBhLnBvc2l0aW9uKSk7XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBheGlzQXJlYVdpZHRocy5rZXlzKCkpIHtcbiAgICAgIGlmICghbGl2ZUF4aXNXaWR0aHMuaGFzKHBvc2l0aW9uKSkge1xuICAgICAgICBheGlzQXJlYVdpZHRocy5kZWxldGUocG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFibGVPdXRwdXRzID0gKG90aGVyQXhpc1dpZHRocywgb3RoZXJDbGlwU2VyaWVzLCBvdGhlclZpc2liaWxpdHkpID0+IHtcbiAgICAgIGlmIChbLi4ub3RoZXJBeGlzV2lkdGhzLmtleXMoKV0uc29tZSgoaykgPT4gIWF4aXNBcmVhV2lkdGhzLmhhcyhrKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHZpc2liaWxpdHkuY3Jvc3NMaW5lcyAhPT0gb3RoZXJWaXNpYmlsaXR5LmNyb3NzTGluZXMgfHwgdmlzaWJpbGl0eS5zZXJpZXMgIT09IG90aGVyVmlzaWJpbGl0eS5zZXJpZXMgfHwgY2xpcFNlcmllcyAhPT0gb3RoZXJDbGlwU2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbLi4uYXhpc0FyZWFXaWR0aHMuZW50cmllcygpXS5ldmVyeSgoW3AsIHddKSA9PiB7XG4gICAgICAgIGNvbnN0IG90aGVyVyA9IG90aGVyQXhpc1dpZHRocy5nZXQocCk7XG4gICAgICAgIGlmICh3ICE9IG51bGwgfHwgb3RoZXJXICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdyA9PT0gb3RoZXJXO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjZWlsVmFsdWVzID0gKG1hcCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgTWF0aC5hYnModmFsdWUpID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCAwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUgIT0gbnVsbCA/IE1hdGguY2VpbCh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG4gICAgbGV0IGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBsYXN0UGFzc1Zpc2liaWxpdHkgPSB7fTtcbiAgICBsZXQgbGFzdFBhc3NDbGlwU2VyaWVzID0gZmFsc2U7XG4gICAgbGV0IHNlcmllc1JlY3QgPSB0aGlzLnNlcmllc1JlY3Q/LmNsb25lKCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgcHJpbWFyeVRpY2tDb3VudHMgPSB7fTtcbiAgICBkbyB7XG4gICAgICBheGlzQXJlYVdpZHRocyA9IG5ldyBNYXAobGFzdFBhc3NBeGlzQXJlYVdpZHRocy5lbnRyaWVzKCkpO1xuICAgICAgY2xpcFNlcmllcyA9IGxhc3RQYXNzQ2xpcFNlcmllcztcbiAgICAgIE9iamVjdC5hc3NpZ24odmlzaWJpbGl0eSwgbGFzdFBhc3NWaXNpYmlsaXR5KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudXBkYXRlQXhlc1Bhc3MoYXhpc0FyZWFXaWR0aHMsIGlucHV0U2hyaW5rUmVjdC5jbG9uZSgpLCBzZXJpZXNSZWN0KTtcbiAgICAgIGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMgPSBjZWlsVmFsdWVzKHJlc3VsdC5heGlzQXJlYVdpZHRocyk7XG4gICAgICBsYXN0UGFzc1Zpc2liaWxpdHkgPSByZXN1bHQudmlzaWJpbGl0eTtcbiAgICAgIGxhc3RQYXNzQ2xpcFNlcmllcyA9IHJlc3VsdC5jbGlwU2VyaWVzO1xuICAgICAgKHsgc2VyaWVzUmVjdCwgcHJpbWFyeVRpY2tDb3VudHMgfSA9IHJlc3VsdCk7XG4gICAgICBpZiAoY291bnQrKyA+IDEwKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFwidW5hYmxlIHRvIGZpbmQgc3RhYmxlIGF4aXMgbGF5b3V0LlwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXN0YWJsZU91dHB1dHMobGFzdFBhc3NBeGlzQXJlYVdpZHRocywgbGFzdFBhc3NDbGlwU2VyaWVzLCBsYXN0UGFzc1Zpc2liaWxpdHkpKTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy51cGRhdGUocHJpbWFyeVRpY2tDb3VudHNbYXhpcy5kaXJlY3Rpb25dKTtcbiAgICB9KTtcbiAgICBjb25zdCBjbGlwUmVjdFBhZGRpbmcgPSA1O1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLnNldENyb3NzTGluZXNWaXNpYmxlKHZpc2liaWxpdHkuY3Jvc3NMaW5lcyk7XG4gICAgICBpZiAoIXNlcmllc1JlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXhpcy5jbGlwR3JpZChcbiAgICAgICAgc2VyaWVzUmVjdC54LFxuICAgICAgICBzZXJpZXNSZWN0LnksXG4gICAgICAgIHNlcmllc1JlY3Qud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsXG4gICAgICAgIHNlcmllc1JlY3QuaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nXG4gICAgICApO1xuICAgICAgc3dpdGNoIChheGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhcbiAgICAgICAgICAgIGlucHV0U2hyaW5rUmVjdC54LFxuICAgICAgICAgICAgc2VyaWVzUmVjdC55LFxuICAgICAgICAgICAgaW5wdXRTaHJpbmtSZWN0LndpZHRoICsgY2xpcFJlY3RQYWRkaW5nLFxuICAgICAgICAgICAgc2VyaWVzUmVjdC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmdcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICBheGlzLmNsaXBUaWNrTGluZXMoXG4gICAgICAgICAgICBzZXJpZXNSZWN0LngsXG4gICAgICAgICAgICBpbnB1dFNocmlua1JlY3QueSxcbiAgICAgICAgICAgIHNlcmllc1JlY3Qud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsXG4gICAgICAgICAgICBpbnB1dFNocmlua1JlY3QuaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0QXhpc0FyZWFXaWR0aHMgPSBheGlzQXJlYVdpZHRocztcbiAgICB0aGlzLl9sYXN0VmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG4gICAgdGhpcy5fbGFzdENsaXBTZXJpZXMgPSBjbGlwU2VyaWVzO1xuICAgIHJldHVybiB7IHNlcmllc1JlY3QsIGFuaW1hdGlvblJlY3Q6IGlucHV0U2hyaW5rUmVjdCwgdmlzaWJpbGl0eSwgY2xpcFNlcmllcyB9O1xuICB9XG4gIHVwZGF0ZUF4ZXNQYXNzKGF4aXNBcmVhV2lkdGhzLCBib3VuZHMsIGxhc3RQYXNzU2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IGF4aXNXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGF4aXNHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHZpc2liaWxpdHkgPSB7XG4gICAgICBzZXJpZXM6IHRydWUsXG4gICAgICBjcm9zc0xpbmVzOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgY2xpcFNlcmllcyA9IGZhbHNlO1xuICAgIGNvbnN0IHByaW1hcnlUaWNrQ291bnRzID0ge307XG4gICAgY29uc3QgcGFkZGVkQm91bmRzID0gdGhpcy5hcHBseVNlcmllc1BhZGRpbmcoYm91bmRzKTtcbiAgICBjb25zdCBjcm9zc0xpbmVQYWRkaW5nID0gbGFzdFBhc3NTZXJpZXNSZWN0ID8gdGhpcy5idWlsZENyb3NzTGluZVBhZGRpbmcoYXhpc0FyZWFXaWR0aHMpIDoge307XG4gICAgY29uc3QgYXhpc0FyZWFCb3VuZCA9IHRoaXMuYnVpbGRBeGlzQm91bmQocGFkZGVkQm91bmRzLCBheGlzQXJlYVdpZHRocywgY3Jvc3NMaW5lUGFkZGluZywgdmlzaWJpbGl0eSk7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IHRoaXMuYnVpbGRTZXJpZXNSZWN0KGF4aXNBcmVhQm91bmQsIGF4aXNBcmVhV2lkdGhzKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9uID0gXCJsZWZ0XCIgfSA9IGF4aXM7XG4gICAgICBjb25zdCB7IGNsaXBTZXJpZXM6IG5ld0NsaXBTZXJpZXMsIGF4aXNUaGlja25lc3MgfSA9IHRoaXMuY2FsY3VsYXRlQXhpc0RpbWVuc2lvbnMoe1xuICAgICAgICBheGlzLFxuICAgICAgICBzZXJpZXNSZWN0LFxuICAgICAgICBwYWRkZWRCb3VuZHMsXG4gICAgICAgIHByaW1hcnlUaWNrQ291bnRzLFxuICAgICAgICBjbGlwU2VyaWVzXG4gICAgICB9KTtcbiAgICAgIGF4aXNXaWR0aHMuc2V0KGF4aXMuaWQsIGF4aXNUaGlja25lc3MpO1xuICAgICAgaWYgKCFheGlzR3JvdXBzLmhhcyhwb3NpdGlvbikpXG4gICAgICAgIGF4aXNHcm91cHMuc2V0KHBvc2l0aW9uLCBbXSk7XG4gICAgICBheGlzR3JvdXBzLmdldChwb3NpdGlvbik/LnB1c2goYXhpcyk7XG4gICAgICBjbGlwU2VyaWVzID0gY2xpcFNlcmllcyB8fCBuZXdDbGlwU2VyaWVzO1xuICAgIH1cbiAgICBjb25zdCBuZXdBeGlzQXJlYVdpZHRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXhpc09mZnNldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW3Bvc2l0aW9uLCBheGVzXSBvZiBheGlzR3JvdXBzLmVudHJpZXMoKSkge1xuICAgICAgbmV3QXhpc0FyZWFXaWR0aHMuc2V0KHBvc2l0aW9uLCB0aGlzLmNhbGN1bGF0ZUF4aXNBcmVhKGF4ZXMsIGF4aXNXaWR0aHMsIGF4aXNPZmZzZXRzKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3Bvc2l0aW9uLCBheGVzXSBvZiBheGlzR3JvdXBzLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5wb3NpdGlvbkF4ZXMoe1xuICAgICAgICBheGVzLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgYXhpc1dpZHRocyxcbiAgICAgICAgYXhpc09mZnNldHMsXG4gICAgICAgIGF4aXNBcmVhV2lkdGhzOiBuZXdBeGlzQXJlYVdpZHRocyxcbiAgICAgICAgYXhpc0JvdW5kOiBheGlzQXJlYUJvdW5kLFxuICAgICAgICBzZXJpZXNSZWN0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2xpcFNlcmllcywgc2VyaWVzUmVjdCwgYXhpc0FyZWFXaWR0aHM6IG5ld0F4aXNBcmVhV2lkdGhzLCB2aXNpYmlsaXR5LCBwcmltYXJ5VGlja0NvdW50cyB9O1xuICB9XG4gIGJ1aWxkQ3Jvc3NMaW5lUGFkZGluZyhheGlzQXJlYVNpemUpIHtcbiAgICBjb25zdCBjcm9zc0xpbmVQYWRkaW5nID0ge307XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMuY3Jvc3NMaW5lcz8uZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICAgIGNyb3NzTGluZS5jYWxjdWxhdGVQYWRkaW5nPy4oY3Jvc3NMaW5lUGFkZGluZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IFtzaWRlLCBwYWRkaW5nID0gMF0gb2YgT2JqZWN0LmVudHJpZXMoY3Jvc3NMaW5lUGFkZGluZykpIHtcbiAgICAgIGNyb3NzTGluZVBhZGRpbmdbc2lkZV0gPSBNYXRoLm1heChwYWRkaW5nIC0gKGF4aXNBcmVhU2l6ZS5nZXQoc2lkZSkgPz8gMCksIDApO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NMaW5lUGFkZGluZztcbiAgfVxuICBhcHBseVNlcmllc1BhZGRpbmcoYm91bmRzKSB7XG4gICAgY29uc3QgcGFkZGVkUmVjdCA9IGJvdW5kcy5jbG9uZSgpO1xuICAgIGNvbnN0IHJldmVyc2VkQXhlcyA9IHRoaXMuYXhlcy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICBkaXJlY3Rpb25zLmZvckVhY2goKGRpcikgPT4ge1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nW2Rpcl07XG4gICAgICBjb25zdCBheGlzID0gcmV2ZXJzZWRBeGVzLmZpbmQoKGEpID0+IGEucG9zaXRpb24gPT09IGRpcik7XG4gICAgICBpZiAoYXhpcykge1xuICAgICAgICBheGlzLnNlcmllc0FyZWFQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZGRlZFJlY3Quc2hyaW5rKHBhZGRpbmcsIGRpcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhZGRlZFJlY3Q7XG4gIH1cbiAgYnVpbGRBeGlzQm91bmQoYm91bmRzLCBheGlzQXJlYVdpZHRocywgY3Jvc3NMaW5lUGFkZGluZywgdmlzaWJpbGl0eSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGJvdW5kcy5jbG9uZSgpO1xuICAgIGNvbnN0IHsgdG9wID0gMCwgcmlnaHQgPSAwLCBib3R0b20gPSAwLCBsZWZ0ID0gMCB9ID0gY3Jvc3NMaW5lUGFkZGluZztcbiAgICBjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IGxlZnQgKyByaWdodDtcbiAgICBjb25zdCB2ZXJ0aWNhbFBhZGRpbmcgPSB0b3AgKyBib3R0b207XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IChheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcInJpZ2h0XCIpID8/IDApICsgaG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgY29uc3QgdG90YWxIZWlnaHQgPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwidG9wXCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcImJvdHRvbVwiKSA/PyAwKSArIHZlcnRpY2FsUGFkZGluZztcbiAgICBpZiAocmVzdWx0LndpZHRoIDw9IHRvdGFsV2lkdGggfHwgcmVzdWx0LmhlaWdodCA8PSB0b3RhbEhlaWdodCkge1xuICAgICAgdmlzaWJpbGl0eS5jcm9zc0xpbmVzID0gZmFsc2U7XG4gICAgICB2aXNpYmlsaXR5LnNlcmllcyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0LnggKz0gbGVmdDtcbiAgICByZXN1bHQueSArPSB0b3A7XG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6b250YWxQYWRkaW5nO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydGljYWxQYWRkaW5nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYnVpbGRTZXJpZXNSZWN0KGF4aXNCb3VuZCwgYXhpc0FyZWFXaWR0aHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBheGlzQm91bmQuY2xvbmUoKTtcbiAgICByZXN1bHQueCArPSBheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDA7XG4gICAgcmVzdWx0LnkgKz0gYXhpc0FyZWFXaWR0aHMuZ2V0KFwidG9wXCIpID8/IDA7XG4gICAgcmVzdWx0LndpZHRoIC09IChheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcInJpZ2h0XCIpID8/IDApO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gKGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJib3R0b21cIikgPz8gMCk7XG4gICAgcmVzdWx0LndpZHRoID0gTWF0aC5tYXgoMCwgcmVzdWx0LndpZHRoKTtcbiAgICByZXN1bHQuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcmVzdWx0LmhlaWdodCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjbGFtcFRvT3V0c2lkZVNlcmllc1JlY3Qoc2VyaWVzUmVjdCwgdmFsdWUsIGRpbWVuc2lvbiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBzZXJpZXNSZWN0O1xuICAgIGNvbnN0IGNsYW1wQm91bmRzID0gW3gsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodF07XG4gICAgY29uc3QgY29tcGFyZVRvID0gY2xhbXBCb3VuZHNbKGRpbWVuc2lvbiA9PT0gXCJ4XCIgPyAwIDogMSkgKyAoZGlyZWN0aW9uID09PSAxID8gMCA6IDIpXTtcbiAgICBjb25zdCBjbGFtcEZuID0gZGlyZWN0aW9uID09PSAxID8gTWF0aC5taW4gOiBNYXRoLm1heDtcbiAgICByZXR1cm4gY2xhbXBGbih2YWx1ZSwgY29tcGFyZVRvKTtcbiAgfVxuICBjYWxjdWxhdGVBeGlzRGltZW5zaW9ucyhvcHRzKSB7XG4gICAgY29uc3QgeyBheGlzLCBzZXJpZXNSZWN0LCBwYWRkZWRCb3VuZHMsIHByaW1hcnlUaWNrQ291bnRzIH0gPSBvcHRzO1xuICAgIGxldCB7IGNsaXBTZXJpZXMgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBwb3NpdGlvbiA9IFwibGVmdFwiLCBkaXJlY3Rpb24gfSA9IGF4aXM7XG4gICAgdGhpcy5zaXplQXhpcyhheGlzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbik7XG4gICAgbGV0IHByaW1hcnlUaWNrQ291bnQgPSBheGlzLm5pY2UgPyBwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dIDogdm9pZCAwO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi87XG4gICAgY29uc3QgcGFkZGVkQm91bmRzQ29lZmZpY2llbnQgPSAwLjM7XG4gICAgaWYgKGF4aXMudGhpY2tuZXNzKSB7XG4gICAgICBheGlzLm1heFRoaWNrbmVzcyA9IGF4aXMudGhpY2tuZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzLm1heFRoaWNrbmVzcyA9IChpc1ZlcnRpY2FsID8gcGFkZGVkQm91bmRzLndpZHRoIDogcGFkZGVkQm91bmRzLmhlaWdodCkgKiBwYWRkZWRCb3VuZHNDb2VmZmljaWVudDtcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0ID0gYXhpcy5jYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCk7XG4gICAgcHJpbWFyeVRpY2tDb3VudCA9IGxheW91dC5wcmltYXJ5VGlja0NvdW50O1xuICAgIHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gPz8gKHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gPSBwcmltYXJ5VGlja0NvdW50KTtcbiAgICBjbGlwU2VyaWVzIHx8IChjbGlwU2VyaWVzID0gYXhpcy5kYXRhRG9tYWluLmNsaXBwZWQgfHwgYXhpcy52aXNpYmxlUmFuZ2VbMF0gPiAwIHx8IGF4aXMudmlzaWJsZVJhbmdlWzFdIDwgMSk7XG4gICAgbGV0IGF4aXNUaGlja25lc3M7XG4gICAgaWYgKGF4aXMudGhpY2tuZXNzICE9IG51bGwgJiYgYXhpcy50aGlja25lc3MgPiAwKSB7XG4gICAgICBheGlzVGhpY2tuZXNzID0gYXhpcy50aGlja25lc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNUaGlja25lc3MgPSBpc1ZlcnRpY2FsID8gbGF5b3V0LmJib3gud2lkdGggOiBsYXlvdXQuYmJveC5oZWlnaHQ7XG4gICAgfVxuICAgIGF4aXNUaGlja25lc3MgPSBNYXRoLmNlaWwoYXhpc1RoaWNrbmVzcyk7XG4gICAgcmV0dXJuIHsgY2xpcFNlcmllcywgYXhpc1RoaWNrbmVzcywgcHJpbWFyeVRpY2tDb3VudCB9O1xuICB9XG4gIHNpemVBeGlzKGF4aXMsIHNlcmllc1JlY3QsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgaXNDYXRlZ29yeSA9IGF4aXMgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMgfHwgYXhpcyBpbnN0YW5jZW9mIEdyb3VwZWRDYXRlZ29yeUF4aXM7XG4gICAgY29uc3QgaXNMZWZ0UmlnaHQgPSBwb3NpdGlvbiA9PT0gXCJsZWZ0XCIgfHwgcG9zaXRpb24gPT09IFwicmlnaHRcIjtcbiAgICBsZXQgeyBtaW4sIG1heCB9ID0gdGhpcy5jdHguem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20oYXhpcy5pZCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzZXJpZXNSZWN0O1xuICAgIGNvbnN0IG1pblN0YXJ0ID0gMDtcbiAgICBjb25zdCBtYXhFbmQgPSBpc0xlZnRSaWdodCA/IGhlaWdodCA6IHdpZHRoO1xuICAgIGxldCBzdGFydCA9IG1pblN0YXJ0O1xuICAgIGxldCBlbmQgPSBtYXhFbmQ7XG4gICAgY29uc3QgeyB3aWR0aDogYXhpc1dpZHRoLCB1bml0LCBhbGlnbiB9ID0gYXhpcy5sYXlvdXRDb25zdHJhaW50cztcbiAgICBpZiAodW5pdCA9PT0gXCJweFwiKSB7XG4gICAgICBlbmQgPSBzdGFydCArIGF4aXNXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gZW5kICogYXhpc1dpZHRoIC8gMTAwO1xuICAgIH1cbiAgICBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgIHN0YXJ0ID0gbWF4RW5kIC0gKGVuZCAtIHN0YXJ0KTtcbiAgICAgIGVuZCA9IG1heEVuZDtcbiAgICB9XG4gICAgaWYgKGlzQ2F0ZWdvcnkgJiYgaXNMZWZ0UmlnaHQpIHtcbiAgICAgIFttaW4sIG1heF0gPSBbMSAtIG1heCwgMSAtIG1pbl07XG4gICAgfSBlbHNlIGlmIChpc0xlZnRSaWdodCkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gW2VuZCwgc3RhcnRdO1xuICAgIH1cbiAgICBheGlzLnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgIGF4aXMudmlzaWJsZVJhbmdlID0gW21pbiwgbWF4XTtcbiAgICBheGlzLmdyaWRMZW5ndGggPSBpc0xlZnRSaWdodCA/IHdpZHRoIDogaGVpZ2h0O1xuICB9XG4gIGNhbGN1bGF0ZUF4aXNBcmVhKGF4ZXMsIGF4aXNXaWR0aHMsIGF4aXNPZmZzZXRzKSB7XG4gICAgbGV0IHRvdGFsQXhpc1dpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIGF4aXNPZmZzZXRzLnNldChheGlzLmlkLCBjdXJyZW50T2Zmc2V0KTtcbiAgICAgIGNvbnN0IGF4aXNUaGlja25lc3MgPSBheGlzV2lkdGhzLmdldChheGlzLmlkKSA/PyAwO1xuICAgICAgdG90YWxBeGlzV2lkdGggPSBNYXRoLm1heCh0b3RhbEF4aXNXaWR0aCwgY3VycmVudE9mZnNldCArIGF4aXNUaGlja25lc3MpO1xuICAgICAgaWYgKGF4aXMubGF5b3V0Q29uc3RyYWludHMuc3RhY2tlZCkge1xuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGF4aXNUaGlja25lc3MgKyAxNTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQXhpc1dpZHRoO1xuICB9XG4gIHBvc2l0aW9uQXhlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBheGVzLCBheGlzQm91bmQsIGF4aXNXaWR0aHMsIGF4aXNPZmZzZXRzLCBheGlzQXJlYVdpZHRocywgc2VyaWVzUmVjdCwgcG9zaXRpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgYXhpc0FyZWFXaWR0aCA9IGF4aXNBcmVhV2lkdGhzLmdldChwb3NpdGlvbikgPz8gMDtcbiAgICBsZXQgbWFpbkRpbWVuc2lvbiA9IFwieFwiO1xuICAgIGxldCBtaW5vckRpbWVuc2lvbiA9IFwieVwiO1xuICAgIGxldCBkaXJlY3Rpb24gPSAxO1xuICAgIGxldCBheGlzQm91bmRNYWluT2Zmc2V0ID0gMDtcbiAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIgfHwgcG9zaXRpb24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIG1haW5EaW1lbnNpb24gPSBcInlcIjtcbiAgICAgIG1pbm9yRGltZW5zaW9uID0gXCJ4XCI7XG4gICAgICBheGlzQm91bmRNYWluT2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIGF4aXNCb3VuZE1haW5PZmZzZXQgKz0gYXhpc0JvdW5kW21haW5EaW1lbnNpb25dO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJyaWdodFwiIHx8IHBvc2l0aW9uID09PSBcImJvdHRvbVwiKSB7XG4gICAgICBkaXJlY3Rpb24gPSAtMTtcbiAgICAgIGF4aXNCb3VuZE1haW5PZmZzZXQgKz0gbWFpbkRpbWVuc2lvbiA9PT0gXCJ4XCIgPyBheGlzQm91bmQud2lkdGggOiBheGlzQm91bmQuaGVpZ2h0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgY29uc3QgbWlub3JPZmZzZXQgPSBheGlzQXJlYVdpZHRocy5nZXQobWlub3JEaW1lbnNpb24gPT09IFwieFwiID8gXCJsZWZ0XCIgOiBcInRvcFwiKSA/PyAwO1xuICAgICAgYXhpcy50cmFuc2xhdGlvblttaW5vckRpbWVuc2lvbl0gPSBheGlzQm91bmRbbWlub3JEaW1lbnNpb25dICsgbWlub3JPZmZzZXQ7XG4gICAgICBjb25zdCBheGlzVGhpY2tuZXNzID0gYXhpc1dpZHRocy5nZXQoYXhpcy5pZCkgPz8gMDtcbiAgICAgIGNvbnN0IGF4aXNPZmZzZXQgPSBheGlzT2Zmc2V0cy5nZXQoYXhpcy5pZCkgPz8gMDtcbiAgICAgIGF4aXMudHJhbnNsYXRpb25bbWFpbkRpbWVuc2lvbl0gPSB0aGlzLmNsYW1wVG9PdXRzaWRlU2VyaWVzUmVjdChcbiAgICAgICAgc2VyaWVzUmVjdCxcbiAgICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArIGRpcmVjdGlvbiAqIChheGlzT2Zmc2V0ICsgYXhpc1RoaWNrbmVzcyksXG4gICAgICAgIG1haW5EaW1lbnNpb24sXG4gICAgICAgIGRpcmVjdGlvblxuICAgICAgKTtcbiAgICAgIGF4aXMuZ3JpZFBhZGRpbmcgPSBheGlzQXJlYVdpZHRoIC0gYXhpc09mZnNldCAtIGF4aXNUaGlja25lc3M7XG4gICAgICBheGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIHNob3VsZEZsaXBYWSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc2VyaWVzLnNvbWUoKHNlcmllcykgPT4gIShzZXJpZXMgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5TZXJpZXMgJiYgc2VyaWVzLnNob3VsZEZsaXBYWSgpKSk7XG4gIH1cbn07XG5DYXJ0ZXNpYW5DaGFydC5jbGFzc05hbWUgPSBcIkNhcnRlc2lhbkNoYXJ0XCI7XG5DYXJ0ZXNpYW5DaGFydC50eXBlID0gXCJjYXJ0ZXNpYW5cIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRQcm94eS50c1xudmFyIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eSA9IGNsYXNzIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eSB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBmYWN0b3J5QXBpLCBsaWNlbnNlTWFuYWdlcikge1xuICAgIHRoaXMuZmFjdG9yeUFwaSA9IGZhY3RvcnlBcGk7XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlciA9IGxpY2Vuc2VNYW5hZ2VyO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICBjaGFydC5wdWJsaWNBcGkgPSB0aGlzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKHgpIHtcbiAgICBpZiAoeCBpbnN0YW5jZW9mIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh4LmNvbnN0cnVjdG9yPy5uYW1lID09PSBcIkFnQ2hhcnRJbnN0YW5jZVByb3h5XCIgJiYgeC5jaGFydCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHguY2hhcnQgIT0gbnVsbCAmJiB0aGlzLnZhbGlkYXRlSW1wbGVtZW50YXRpb24oeCk7XG4gIH1cbiAgc3RhdGljIHZhbGlkYXRlSW1wbGVtZW50YXRpb24oeCkge1xuICAgIGNvbnN0IGNoYXJ0UHJvcHMgPSBbXCJnZXRPcHRpb25zXCIsIFwiZGVzdHJveVwiXTtcbiAgICBjb25zdCBzaWduYXR1cmVQcm9wcyA9IE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA/PyB7fSk7XG4gICAgcmV0dXJuIGNoYXJ0UHJvcHMuZXZlcnkoKHByb3ApID0+IHNpZ25hdHVyZVByb3BzLmluY2x1ZGVzKHByb3ApKTtcbiAgfVxuICBhc3luYyB1cGRhdGUob3B0aW9ucykge1xuICAgIHRoaXMuZmFjdG9yeUFwaS5jcmVhdGVPclVwZGF0ZShvcHRpb25zLCB0aGlzKTtcbiAgICBhd2FpdCB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEZWx0YShkZWx0YU9wdGlvbnMpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkudXBkYXRlVXNlckRlbHRhKHRoaXMsIGRlbHRhT3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZGVlcENsb25lKHRoaXMuY2hhcnQuZ2V0T3B0aW9ucygpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIHdhaXRGb3JVcGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIGFzeW5jIGRvd25sb2FkKG9wdHMpIHtcbiAgICBjb25zdCBjbG9uZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJlc2l6ZWRDaGFydCh0aGlzLCBvcHRzKTtcbiAgICB0cnkge1xuICAgICAgY2xvbmUuY2hhcnQuZG93bmxvYWQob3B0cz8uZmlsZU5hbWUsIG9wdHM/LmZpbGVGb3JtYXQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbG9uZS5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEltYWdlRGF0YVVSTChvcHRzKSB7XG4gICAgY29uc3QgY2xvbmUgPSBhd2FpdCB0aGlzLnByZXBhcmVSZXNpemVkQ2hhcnQodGhpcywgb3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjbG9uZS5jaGFydC5nZXRDYW52YXNEYXRhVVJMKG9wdHM/LmZpbGVGb3JtYXQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbG9uZS5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmZhY3RvcnlBcGkuY2FyZXRha2VyLnNhdmUodGhpcy5jaGFydC5jdHguYW5ub3RhdGlvbk1hbmFnZXIpO1xuICB9XG4gIGFzeW5jIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpLmNhcmV0YWtlci5yZXN0b3JlKHN0YXRlLCB0aGlzLmNoYXJ0LmN0eC5hbm5vdGF0aW9uTWFuYWdlcik7XG4gICAgYXdhaXQgdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgcmVzZXRBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY2hhcnQucmVzZXRBbmltYXRpb25zKCk7XG4gIH1cbiAgc2tpcEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jaGFydC5za2lwQW5pbWF0aW9ucygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jaGFydC5wdWJsaWNBcGkgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVJlc2l6ZWRDaGFydChwcm94eSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFydCB9ID0gcHJveHk7XG4gICAgY29uc3Qgd2lkdGggPSBvcHRzLndpZHRoID8/IGNoYXJ0LndpZHRoID8/IGNoYXJ0LmN0eC5zY2VuZS5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gb3B0cy5oZWlnaHQgPz8gY2hhcnQuaGVpZ2h0ID8/IGNoYXJ0LmN0eC5zY2VuZS5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHN0YXRlID0gcHJveHkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc0VudGVycHJpc2UgPSBtb2R1bGVSZWdpc3RyeS5oYXNFbnRlcnByaXNlTW9kdWxlcygpO1xuICAgIGNvbnN0IG92ZXJyaWRlT3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IHByb2Nlc3NlZE9wdGlvbnMgPSBjaGFydC5jaGFydE9wdGlvbnMuZ2V0T3B0aW9ucygpO1xuICAgIGlmIChpc0VudGVycHJpc2UpIHtcbiAgICAgIG92ZXJyaWRlT3B0aW9ucy5hbmltYXRpb24gPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG4gICAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zKSkge1xuICAgICAgICBvdmVycmlkZU9wdGlvbnMudG9vbGJhciA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpY2Vuc2VNYW5hZ2VyPy5pc0Rpc3BsYXlXYXRlcm1hcmsoKSkge1xuICAgICAgICBvdmVycmlkZU9wdGlvbnMuZm9yZWdyb3VuZCA9IHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLmxpY2Vuc2VNYW5hZ2VyLmdldFdhdGVybWFya01lc3NhZ2UoKSxcbiAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgdXJsOiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpVNElpQm9aV2xuYUhROUlqUXdJaUIyYVdWM1FtOTRQU0l3SURBZ01qVTRJRFF3SWlCbWFXeHNQU0p1YjI1bElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnbzhjR0YwYUNCa1BTSk5NalV1TnpjNUlESTRMalkxTjBneE15NHpOVGxNTVRFdU1UY3pJRE0wTGpBeE1rZzFMalkzTWprM1RERTNMakU0TWlBM0xqQTFPVGs1U0RJeExqazFNMHd6TXk0ME5qSWdNelF1TURFeVNESTNMamsyTWt3eU5TNDNOellnTWpndU5qVTNTREkxTGpjM09WcE5NalF1TURZNElESTBMak01TjB3eE9TNDFPRGdnTVRNdU5ETTBUREUxTGpFd055QXlOQzR6T1RkSU1qUXVNRFk0V2swMk1pNHdPVElnTVRndU9ESXpTRFE1TGpneE4xWXlNeTR3T0RaSU5UWXVOemMxUXpVMkxqVTFOU0F5TlM0eU1qSWdOVFV1TnpVMUlESTJMamt5TnlBMU5DNHpOeklnTWpndU1qQXlRelV5TGprNE9TQXlPUzQwTnpZZ05URXVNVFkySURNd0xqRXhOU0EwT0M0NU1Ea2dNekF1TVRFMVF6UTNMall5TWlBek1DNHhNVFVnTkRZdU5EVWdNamt1T0RnMUlEUTFMak01TXlBeU9TNDBNak5ETkRRdU16VTRNeUF5T0M0NU56Z3hJRFF6TGpRek1qWWdNamd1TXpFek9DQTBNaTQyT0NBeU55NDBOelpETkRFdU9USTNJREkyTGpZek9TQTBNUzR6TkRRZ01qVXVOak14SURRd0xqa3pNU0F5TkM0ME5UTkROREF1TlRFNUlESXpMakkzTlNBME1DNHpNVEVnTWpFdU9UY2dOREF1TXpFeElESXdMalV6TjBNME1DNHpNVEVnTVRrdU1UQTFJRFF3TGpVeE5pQXhOeTQ0SURRd0xqa3pNU0F4Tmk0Mk1qRkROREV1TXpRMElERTFMalEwTXlBME1TNDVNamNnTVRRdU5ETTJJRFF5TGpZNElERXpMalU1T0VNME15NDBNemMySURFeUxqYzFOemNnTkRRdU16WTVOaUF4TWk0d09UTXlJRFExTGpReE1TQXhNUzQyTlRGRE5EWXVORGM0SURFeExqRTRPU0EwTnk0Mk5UWWdNVEF1T1RZZ05EZ3VPVFEySURFd0xqazJRelV4TGpZeE1pQXhNQzQ1TmlBMU15NDJNemNnTVRFdU5qQXlJRFUxTGpBeUlERXlMamc0TlV3MU9DNHpJRGt1TmpBME9UbEROVFV1T0RFM0lEY3VOalk1T1RrZ05USXVOamMySURZdU5qazVPVGtnTkRndU9EY3lJRFl1TmprNU9UbERORFl1TnpZZ05pNDJPVGs1T1NBME5DNDROVE1nTnk0d016UTVPU0EwTXk0eE5UUWdOeTQzTURBNU9VTTBNUzQwTlRVZ09DNHpOamM1T1NBek9TNDVPVGdnT1M0ek1ETTVPU0F6T0M0M09ETWdNVEF1TlRBMFF6TTNMalUyTnlBeE1TNDNNRGNnTXpZdU5qTTBJREV6TGpFMU9DQXpOUzQ1TnpjZ01UUXVPRFUzUXpNMUxqTXhPU0F4Tmk0MU5UWWdNelF1T1RrMElERTRMalExTVNBek5DNDVPVFFnTWpBdU5UUkRNelF1T1RrMElESXlMall6SURNMUxqTXlPU0F5TkM0ME9UUWdNelV1T1RrMUlESTJMakl3TlVNek5pNDJOaklnTWpjdU9URTJJRE0zTGpZd05TQXlPUzR6TnpRZ016Z3VPREUzSURNd0xqVTNOME0wTUM0d016SWdNekV1TnpnZ05ERXVORGcySURNeUxqY3hNeUEwTXk0eE9EZ2dNek11TXpnelF6UTBMamc0T0NBek5DNHdORGtnTkRZdU56Z3lJRE0wTGpNNE5DQTBPQzQ0TnpJZ016UXVNemcwUXpVd0xqazJNU0F6TkM0ek9EUWdOVEl1TnpVZ016UXVNRFE1SURVMExqTTVJRE16TGpNNE0wTTFOaTR3TXpFZ016SXVOekUySURVM0xqUXlOaUF6TVM0M09DQTFPQzQxTnprZ016QXVOVGMzUXpVNUxqY3pNeUF5T1M0ek56UWdOakF1TmpFNUlESTNMamt4TmlBMk1TNHlNemtnTWpZdU1qQTFRell4TGpnMklESTBMalE1TkNBMk1pNHhOeUF5TWk0Mk1EVWdOakl1TVRjZ01qQXVOVFJETmpJdU1UWTVOaUF4T1M0NU5qZzRJRFl5TGpFME5EVWdNVGt1TXprNElEWXlMakE1TlNBeE9DNDRNamxNTmpJdU1Ea3lJREU0TGpneU0xcE5NVFV4TGpneElERTJMams0TVVNeE5UTXVOREVnTVRRdU5qQTVJREUxTnk0ME1Ua2dNVFF1TXpVNElERTFPUzR3TWpJZ01UUXVNelU0VmpFNExqa3hRekUxTmk0NU5UY2dNVGd1T1RFZ01UVTBMams0TlNBeE9DNDVPVFlnTVRVekxqYzFOeUF4T1M0NE9USkRNVFV5TGpVeU9TQXlNQzQzT1RJZ01UVXhMamt4T1NBeU1TNDVPRElnTVRVeExqa3hPU0F5TXk0ME5qUldNek11T1RsSU1UUTJMamsyTkZZeE5DNHpOVGhJTVRVeExqY3pOa3d4TlRFdU9ERWdNVFl1T1RneFdrMHhORE11TURFeElERTBMak0yTVZZek5DNHdNekZJTVRNNExqSTBUREV6T0M0eE16RWdNekV1TURRMVF6RXpOeTQwTmpZZ016SXVNRGMySURFek5pNDFOVEVnTXpJdU9USXhPU0F4TXpVdU5EY3hJRE16TGpVd05FTXhNelF1TXpjMklETTBMakE1T1NBeE16TXVNRFk0SURNMExqTTVOaUF4TXpFdU5UTTJJRE0wTGpNNU5rTXhNekF1TWlBek5DNHpPVFlnTVRJNExqazJNeUF6TkM0eE5USWdNVEkzTGpneU1pQXpNeTQyTmpoRE1USTJMamNnTXpNdU1UazJOQ0F4TWpVdU5qZzVJRE15TGpRNU5TQXhNalF1T0RVMUlETXhMall3T1VNeE1qUXVNREU0SURNd0xqY3lNaUF4TWpNdU16VTBJREk1TGpZMk1pQXhNakl1T0RjeElESTRMalF5TWtNeE1qSXVNemcwSURJM0xqRTROU0F4TWpJdU1UUXlJREkxTGpneE1TQXhNakl1TVRReUlESTBMak13TkVNeE1qSXVNVFF5SURJeUxqYzVPQ0F4TWpJdU16ZzBJREl4TGpNM09DQXhNakl1T0RjeElESXdMakV4TmtNeE1qTXVNelUzSURFNExqZzFOQ0F4TWpRdU1ERTRJREUzTGpjM01pQXhNalF1T0RVMUlERTJMamczTTBNeE1qVXVOamc0SURFMUxqazNOalFnTVRJMkxqWTVPQ0F4TlM0eU5qTTJJREV5Tnk0NE1qSWdNVFF1TnpoRE1USTRMamsyTXlBeE5DNHlPREVnTVRNd0xqSXdNeUF4TkM0d016TWdNVE14TGpVek5pQXhOQzR3TXpORE1UTXpMakEwTXlBeE5DNHdNek1nTVRNMExqTXpJREUwTGpNeE9DQXhNelV1TXprM0lERTBMamc0T0VNeE16WXVORFl5SURFMUxqUTFPRGtnTVRNM0xqTTNOU0F4Tmk0eU56Z2dNVE00TGpBMU55QXhOeTR5TnpaV01UUXVNell4U0RFME15NHdNVEZhVFRFek1pNDJNekVnTXpBdU1UTXpRekV6TkM0eU5UWWdNekF1TVRNeklERXpOUzQxTmpjZ01qa3VOVGswSURFek5pNDFOalVnTWpndU5URXlRekV6Tnk0MU5qRWdNamN1TkRNZ01UTTRMakEySURJMUxqazVNU0F4TXpndU1EWWdNalF1TVRrMlF6RXpPQzR3TmlBeU1pNDBNREVnTVRNM0xqVTJNU0F5TUM0NU9TQXhNell1TlRZMUlERTVMamc1T1VNeE16VXVOVGNnTVRndU9EQTNJREV6TkM0eU5Ua2dNVGd1TWpVNElERXpNaTQyTXpFZ01UZ3VNalU0UXpFek1TNHdNRE1nTVRndU1qVTRJREV5T1M0M01qa2dNVGd1T0RBMElERXlPQzQzTXpRZ01Ua3VPRGs1UXpFeU55NDNNemdnTWpBdU9Ua3pJREV5Tnk0eU16a2dNakl1TkRNNElERXlOeTR5TXprZ01qUXVNak16UXpFeU55NHlNemtnTWpZdU1ESTRJREV5Tnk0M016VWdNamN1TkRNeklERXlPQzQzTXpRZ01qZ3VOVEUxUXpFeU9TNDNNamtnTWprdU5UazBJREV6TVM0d01qZ2dNekF1TVRNMklERXpNaTQyTXpFZ016QXVNVE0yVmpNd0xqRXpNMXBOT1RNdU5qazRJREkzTGpnM05rTTVNeTQxTnprMUlESTRMakF3TWpVZ09UTXVORFUyTkNBeU9DNHhNalEySURrekxqTXlPU0F5T0M0eU5ESkRPVEV1T1RRM0lESTVMalV4TmlBNU1DNHhNak1nTXpBdU1UVTFJRGczTGpnMk5pQXpNQzR4TlRWRE9EWXVOVGdnTXpBdU1UVTFJRGcxTGpRd09DQXlPUzQ1TWpZZ09EUXVNelVnTWprdU5EWTBRemd6TGpNeE5UVWdNamt1TURFNE9TQTRNaTR6T0RrNElESTRMak0xTkRZZ09ERXVOak0zSURJM0xqVXhOME00TUM0NE9EUWdNall1TmpjNUlEZ3dMak13TVNBeU5TNDJOeklnTnprdU9EZzVJREkwTGpRNU5FTTNPUzQwTnpZZ01qTXVNekUxSURjNUxqSTJPU0F5TWk0d01TQTNPUzR5TmprZ01qQXVOVGM0UXpjNUxqSTJPU0F4T1M0eE5EVWdOemt1TkRjeklERTNMamcwSURjNUxqZzRPU0F4Tmk0Mk5qSkRPREF1TXpBeElERTFMalE0TkNBNE1DNDRPRFFnTVRRdU5EYzJJRGd4TGpZek55QXhNeTQyTXpsRE9ESXVNemswT1NBeE1pNDNPVGczSURnekxqTXlOek1nTVRJdU1UTTBNaUE0TkM0ek5qa2dNVEV1TmpreVF6ZzFMalF6TmlBeE1TNHlNeUE0Tmk0Mk1UUWdNVEVnT0RjdU9UQXpJREV4UXprd0xqVTNJREV4SURreUxqVTVOU0F4TVM0Mk5ESWdPVE11T1RjM0lERXlMamt5Tmt3NU55NHlOVGdnT1M0Mk5EUTVPVU01TkM0M056UWdOeTQzTVRBNU9TQTVNUzQyTXpNZ05pNDNNems1T1NBNE55NDRNamtnTmk0M016azVPVU00TlM0M01UZ2dOaTQzTXprNU9TQTRNeTQ0TVRFZ055NHdOelE1T1NBNE1pNHhNVElnTnk0M05ERTVPVU00TUM0ME1UTWdPQzQwTURjNU9TQTNPQzQ1TlRZZ09TNHpORFE1T1NBM055NDNOQ0F4TUM0MU5EVkROell1TlRJMUlERXhMamMwTnlBM05TNDFPVElnTVRNdU1UazVJRGMwTGprek5DQXhOQzQ0T1RoRE56UXVNamMzSURFMkxqVTVOeUEzTXk0NU5URWdNVGd1TkRreElEY3pMamsxTVNBeU1DNDFPREZETnpNdU9UVXhJREl5TGpZM0lEYzBMakk0TmlBeU5DNDFNelFnTnpRdU9UVXpJREkyTGpJME5VTTNOUzQyTVRrZ01qY3VPVFUzSURjMkxqVTJNaUF5T1M0ME1UUWdOemN1TnpjMElETXdMall4TjBNM09DNDVPU0F6TVM0NE1pQTRNQzQwTkRRZ016SXVOelV6SURneUxqRTBOaUF6TXk0ME1qTkRPRE11T0RRMUlETTBMakE1SURnMUxqY3pPU0F6TkM0ME1qUWdPRGN1T0RJNUlETTBMalF5TkVNNE9TNDVNVGtnTXpRdU5ESTBJRGt4TGpjd09DQXpOQzR3T1NBNU15NHpORGdnTXpNdU5ESXpRemswTGpjeE9DQXpNaTQ0TmpVZ09UVXVPVEU0SURNeUxqRXlNU0E1Tmk0NU5EZ2dNekV1TVRreFF6azNMakUwT1NBek1TNHdNRGdnT1RjdU16UTRJRE13TGpneE5TQTVOeTQxTXpjZ016QXVOakpNT1RNdU56QXhJREkzTGpnNE5VdzVNeTQyT1RnZ01qY3VPRGMyV2sweE1UQXVPREF5SURFMExqQXhOVU14TURrdU1UazVJREUwTGpBeE5TQXhNRFl1T0RNMklERTBMalEzTVNBeE1EVXVOakV4SURFMkxqRTFPRXd4TURVdU5UTTNJRFl1TURFMU9UbElNVEF3TGpjMk5WWXpNeTQ1TXpsSU1UQTFMamN5VmpJeUxqWTBNVU14TURVdU56Y3hJREl4TGpRMk1EY2dNVEEyTGpJNE9DQXlNQzR6TkRnNElERXdOeTR4TlRjZ01Ua3VOVFE0T1VNeE1EZ3VNREkzSURFNExqYzBPVEVnTVRBNUxqRTNPQ0F4T0M0ek1qWTJJREV4TUM0ek5UZ2dNVGd1TXpjMFF6RXhNeTR6T1RjZ01UZ3VNemMwSURFeE5DNHlOamdnTWpFdU1UVTVJREV4TkM0eU5qZ2dNakl1TmpReFZqTXpMamt6T1VneE1Ua3VNakl6VmpJeExqQTFPVU14TVRrdU1qSXpJREl4TGpBMU9TQXhNVGt1TVRReUlERTBMakF4TlNBeE1UQXVPREF5SURFMExqQXhOVnBOTVRjekxqYzJNeUF4TkM0ek5UaElNVFk1TGprNU9WWTRMamN4TkRrNVNERTJOUzR3TkRoV01UUXVNelU0U0RFMk1TNHlPRFJXTVRndU9URTJTREUyTlM0d05EaFdNelF1TURBelNERTJPUzQ1T1RsV01UZ3VPVEUyU0RFM015NDNOak5XTVRRdU16VTRXazB4T1RBdU56ZzNJREkxTGpJMk1rTXhPVEF1TVRJNUlESTBMalV3TVRRZ01UZzVMak13TnlBeU15NDRPVGswSURFNE9DNHpPRFFnTWpNdU5UQXhRekU0Tnk0ME9EZ2dNak11TVRFM0lERTROaTR6TXpFZ01qSXVOek15SURFNE5DNDVORGdnTWpJdU16WTBRekU0TkM0eE5qVWdNakl1TVRRek9TQXhPRE11TXprZ01qRXVPRGszT0NBeE9ESXVOakl6SURJeExqWXlOa014T0RJdU1UWXpJREl4TGpRMk1qRWdNVGd4TGpjME1TQXlNUzR5TURZMklERTRNUzR6T0RNZ01qQXVPRGMxUXpFNE1TNHlNelVnTWpBdU56UXlNU0F4T0RFdU1URTRJREl3TGpVM09Ea2dNVGd4TGpBek9TQXlNQzR6T1RZMFF6RTRNQzQ1TmpFZ01qQXVNakUwSURFNE1DNDVNaklnTWpBdU1ERTJOaUF4T0RBdU9USTNJREU1TGpneE9FTXhPREF1T1RJM0lERTVMakkzTWlBeE9ERXVNVFUySURFNExqZzBOQ0F4T0RFdU5qSTFJREU0TGpVeFF6RTRNaTR4TWpFZ01UZ3VNVFUySURFNE1pNDROaklnTVRjdU9UYzJJREU0TXk0NE1qWWdNVGN1T1RjMlF6RTROQzQzT1NBeE55NDVOellnTVRnMUxqVTROeUF4T0M0eU1Ea2dNVGcyTGpFME9DQXhPQzQyTmpoRE1UZzJMamN3TmlBeE9TNHhNalFnTVRnM0xqQXdOeUF4T1M0M01qVWdNVGczTGpBM01pQXlNQzQxVERFNE55NHdPVFFnTWpBdU56Z3lTREU1TVM0Mk16Tk1NVGt4TGpZeE55QXlNQzQwTmtNeE9URXVOVEl4SURFNExqUTROU0F4T1RBdU56Y3hJREUyTGprZ01UZzVMak00TlNBeE5TNDNOVU14T0RndU1ERXlJREUwTGpZeE1pQXhPRFl1TVRnMUlERTBMakF6TXlBeE9ETXVPVFl5SURFMExqQXpNME14T0RJdU5EYzNJREUwTGpBek15QXhPREV1TVRReElERTBMakk0TnlBeE56a3VPVGswSURFMExqYzROa014TnpndU9ETXhJREUxTGpJNU1TQXhOemN1T1RJMklERTFMams1TlNBeE56Y3VNamsySURFMkxqZzRNa014TnpZdU5qY3pJREUzTGpjME5UVWdNVGMyTGpNek9DQXhPQzQzT0RRZ01UYzJMak0wTVNBeE9TNDRORGxETVRjMkxqTTBNU0F5TVM0eE5qY2dNVGMyTGpZNU9DQXlNaTR5TkRrZ01UYzNMak01T1NBeU15NHdOalJETVRjNExqQTJJREl6TGpnME16SWdNVGM0TGpnNU9DQXlOQzQwTlRNMElERTNPUzQ0TkRJZ01qUXVPRFEwUXpFNE1DNDNORFFnTWpVdU1qRTJJREU0TVM0NU1qZ2dNalV1TmpBM0lERTRNeTR6TmpFZ01qWkRNVGcwTGpnd05pQXlOaTQwTVNBeE9EVXVPRGN5SURJMkxqYzROU0F4T0RZdU5UTWdNamN1TVRJelF6RTROeTR4SURJM0xqUXhOQ0F4T0RjdU16YzVJREkzTGpnME5TQXhPRGN1TXpjNUlESTRMalEwTkVNeE9EY3VNemM1SURJNUxqQTBNaUF4T0RjdU1USXlJREk1TGpRMk55QXhPRFl1TlRrMUlESTVMamd6T1VNeE9EWXVNRFF6SURNd0xqSXlOaUF4T0RVdU1qTTNJRE13TGpReU5TQXhPRFF1TWpBeElETXdMalF5TlVNeE9ETXVNVFkySURNd0xqUXlOU0F4T0RJdU16azBJRE13TGpFM05DQXhPREV1TnpRNUlESTVMalkzTkVNeE9ERXVNVEV6SURJNUxqRTRNU0F4T0RBdU56Y3lJREk0TGpVNE9TQXhPREF1TnpFZ01qY3VPRFkwVERFNE1DNDJPRFVnTWpjdU5UZ3lTREUzTmk0d01UTk1NVGMyTGpBeU5TQXlOeTQ1TURGRE1UYzJMakEyTnlBeU9TNHdPVFUxSURFM05pNDBOeklnTXpBdU1qUTROeUF4TnpjdU1UZzRJRE14TGpJd05rTXhOemN1T1RBM0lETXlMakU0SURFM09DNDRPVE1nTXpJdU9UVTRJREU0TUM0eE1UZ2dNek11TlRFNVF6RTRNUzR6TXpZZ016UXVNRGMzSURFNE1pNDNNeklnTXpRdU16WXlJREU0TkM0eU5qWWdNelF1TXpZeVF6RTROUzQ0TURFZ016UXVNell5SURFNE55NHhNRGtnTXpRdU1UQTRJREU0T0M0eU16Z2dNek11TmpBNVF6RTRPUzR6TnpZZ016TXVNVEEwSURFNU1DNHlOeklnTXpJdU16azBJREU1TUM0NU1ERWdNekV1TkRrMFF6RTVNUzQxTXpRZ016QXVOVGt5SURFNU1TNDROVE1nTWprdU5UVTBJREU1TVM0NE5UTWdNamd1TkRBelF6RTVNUzQ0TWpnZ01qY3VNVEVnTVRreExqUTJOaUF5Tmk0d05UTWdNVGt3TGpjM055QXlOUzR5TmpKSU1Ua3dMamM0TjFvaUlHWnBiR3c5SWlNNVFqbENPVUlpTHo0S1BIQmhkR2dnWkQwaVRUSTBNUzQ1T0RJZ01qVXVOalU0TWxZeE55NDNNVEUzU0RJeU9DNDBOREZNTWpJd0xqUTVOQ0F5TlM0Mk5UZ3lTREkwTVM0NU9ESmFJaUJtYVd4c1BTSWpPVUk1UWpsQ0lpOCtDanh3WVhSb0lHUTlJazB5TlRjdU1qTTVJRFV1T1RVd09ERklNalF3TGpJMk5Vd3lNekl1TWpVMUlERXpMamc1TnpOSU1qVTNMakl6T1ZZMUxqazFNRGd4V2lJZ1ptbHNiRDBpSXpsQ09VSTVRaUl2UGdvOGNHRjBhQ0JrUFNKTk1qRXlMall4TVNBek15NDJNRFE0VERJeE5pNDJPQ0F5T1M0MU16WXhTREl6TUM0ME1USldNemN1TkRneU4wZ3lNVEl1TmpFeFZqTXpMall3TkRoYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlNVFV1TlRrNUlESXhMamM0TUROSU1qSTBMak0zTWt3eU16SXVNemd5SURFekxqZ3pNemRJTWpFMUxqVTVPVll5TVM0M09EQXpXaUlnWm1sc2JEMGlJemxDT1VJNVFpSXZQZ284Y0dGMGFDQmtQU0pOTWpBMklETXpMall3TkRkSU1qRXlMall4TVV3eU1qQXVORGswSURJMUxqWTFPREpJTWpBMlZqTXpMall3TkRkYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlOREF1TWpZMUlEVXVPVFV3T0RGTU1qTTJMakU1TnlBeE1DNHdNVGswU0RJeE1DNHlOVGxXTWk0d056STRPRWd5TkRBdU1qWTFWalV1T1RVd09ERmFJaUJtYVd4c1BTSWpPVUk1UWpsQ0lpOCtDand2YzNablBnbz1gLFxuICAgICAgICAgICAgd2lkdGg6IDE3MCxcbiAgICAgICAgICAgIGhlaWdodDogMjUsXG4gICAgICAgICAgICByaWdodDogMjUsXG4gICAgICAgICAgICBib3R0b206IDUwLFxuICAgICAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIHtcbiAgICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgb3ZlcnJpZGVPcHRpb25zLFxuICAgICAgcHJvY2Vzc2VkT3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgY2xvbmVQcm94eSA9IGF3YWl0IHRoaXMuZmFjdG9yeUFwaS5jcmVhdGVPclVwZGF0ZShvcHRpb25zKTtcbiAgICBhd2FpdCBjbG9uZVByb3h5LnNldFN0YXRlKHN0YXRlKTtcbiAgICBjbG9uZVByb3h5LmNoYXJ0LmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwiYWdDaGFydFYyXCIsIGNoYXJ0LmN0eC56b29tTWFuYWdlci5nZXRab29tKCkpO1xuICAgIGNoYXJ0LnNlcmllcy5mb3JFYWNoKChzZXJpZXMsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIXNlcmllcy52aXNpYmxlKSB7XG4gICAgICAgIGNsb25lUHJveHkuY2hhcnQuc2VyaWVzW2luZGV4XS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2hhcnQudXBkYXRlKDAgLyogRlVMTCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICBhd2FpdCBjbG9uZVByb3h5LndhaXRGb3JVcGRhdGUoKTtcbiAgICByZXR1cm4gY2xvbmVQcm94eTtcbiAgfVxufTtcbl9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG9sZFZhbHVlKGNoYXJ0KSB7XG4gICAgICBfQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuZGVsZXRlKGNoYXJ0KTtcbiAgICB9LFxuICAgIG5ld1ZhbHVlKGNoYXJ0KSB7XG4gICAgICBfQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuc2V0KGNoYXJ0LCB0aGlzKTtcbiAgICB9XG4gIH0pXG5dLCBfQWdDaGFydEluc3RhbmNlUHJveHkucHJvdG90eXBlLCBcImNoYXJ0XCIsIDIpO1xudmFyIEFnQ2hhcnRJbnN0YW5jZVByb3h5ID0gX0FnQ2hhcnRJbnN0YW5jZVByb3h5O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9saW5lYXJTY2FsZS50c1xudmFyIExpbmVhclNjYWxlID0gY2xhc3MgZXh0ZW5kcyBDb250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbMCwgMV0sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJudW1iZXJcIjtcbiAgfVxuICB0b0RvbWFpbihkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRpY2tDb3VudCA/PyBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIgfHwgY291bnQgPCAxIHx8ICF0aGlzLmRvbWFpbi5ldmVyeShpc0Zpbml0ZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmdldERvbWFpbigpO1xuICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICBjb25zdCBzdGVwID0gTWF0aC5hYnModGhpcy5pbnRlcnZhbCk7XG4gICAgICBpZiAoIWlzRGVuc2VJbnRlcnZhbCgoZDEgLSBkMCkgLyBzdGVwLCB0aGlzLmdldFBpeGVsUmFuZ2UoKSkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKGQwLCBkMSwgc3RlcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUaWNrcyhkMCwgZDEsIGNvdW50LCB0aGlzLm1pblRpY2tDb3VudCwgdGhpcy5tYXhUaWNrQ291bnQpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmljZSkge1xuICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluKCk7XG4gICAgfVxuICB9XG4gIGdldFRpY2tTdGVwKHN0YXJ0LCBzdG9wKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPz8gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIHRoaXMudGlja0NvdW50LCB0aGlzLm1pblRpY2tDb3VudCwgdGhpcy5tYXhUaWNrQ291bnQpO1xuICB9XG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoZSBkb21haW4gc28gdGhhdCBpdCBzdGFydHMgYW5kIGVuZHMgb24gbmljZSByb3VuZCB2YWx1ZXMuXG4gICAqL1xuICB1cGRhdGVOaWNlRG9tYWluKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aWNrQ291bnQ7XG4gICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgdGhpcy5uaWNlRG9tYWluID0gWy4uLnRoaXMuZG9tYWluXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFtzdGFydCwgc3RvcF0gPSB0aGlzLmRvbWFpbjtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgIFtzdGFydCwgc3RvcF0gPSBuaWNlVGlja3NEb21haW4oc3RhcnQsIHN0b3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3VuZFN0YXJ0ID0gc3RhcnQgPiBzdG9wID8gTWF0aC5jZWlsIDogTWF0aC5mbG9vcjtcbiAgICAgIGNvbnN0IHJvdW5kU3RvcCA9IHN0b3AgPCBzdGFydCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWw7XG4gICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEF0dGVtcHRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldjAgPSBzdGFydDtcbiAgICAgICAgY29uc3QgcHJldjEgPSBzdG9wO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRUaWNrU3RlcChzdGFydCwgc3RvcCk7XG4gICAgICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5kb21haW47XG4gICAgICAgIGlmIChzdGVwID49IDEpIHtcbiAgICAgICAgICBzdGFydCA9IHJvdW5kU3RhcnQoZDAgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgICAgc3RvcCA9IHJvdW5kU3RvcChkMSAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzID0gMSAvIHN0ZXA7XG4gICAgICAgICAgc3RhcnQgPSByb3VuZFN0YXJ0KGQwICogcykgLyBzO1xuICAgICAgICAgIHN0b3AgPSByb3VuZFN0b3AoZDEgKiBzKSAvIHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBwcmV2MCAmJiBzdG9wID09PSBwcmV2MSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubmljZURvbWFpbiA9IFtzdGFydCwgc3RvcF07XG4gIH1cbiAgdGlja0Zvcm1hdCh7IHRpY2tzOiBzcGVjaWZpZWRUaWNrcywgc3BlY2lmaWVyIH0pIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChzcGVjaWZpZWRUaWNrcyA/PyB0aGlzLnRpY2tzKCksIHNwZWNpZmllcik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2Vjb25kYXJ5QXhpc1RpY2tzLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVOaWNlU2Vjb25kYXJ5QXhpcyhkb21haW4sIHByaW1hcnlUaWNrQ291bnQsIHJldmVyc2UpIHtcbiAgbGV0IFtzdGFydCwgc3RvcF0gPSBmaW5kTWluTWF4KGRvbWFpbik7XG4gIHN0YXJ0ID0gY2FsY3VsYXRlTmljZVN0YXJ0KE1hdGguZmxvb3Ioc3RhcnQpLCBzdG9wLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgY29uc3Qgc3RlcCA9IGdldFRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwcmltYXJ5VGlja0NvdW50IC0gMTtcbiAgc3RvcCA9IHN0YXJ0ICsgc2VnbWVudHMgKiBzdGVwO1xuICBjb25zdCBkID0gcmV2ZXJzZSA/IFtzdG9wLCBzdGFydF0gOiBbc3RhcnQsIHN0b3BdO1xuICBjb25zdCB0aWNrcyA9IGdldFRpY2tzKHN0YXJ0LCBzdGVwLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgcmV0dXJuIHsgZG9tYWluOiBkLCB0aWNrcyB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTmljZVN0YXJ0KGEsIGIsIGNvdW50KSB7XG4gIGNvbnN0IHJhd1N0ZXAgPSBNYXRoLmFicyhiIC0gYSkgLyAoY291bnQgLSAxKTtcbiAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAocmF3U3RlcCkpO1xuICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnBvdygxMCwgb3JkZXIpO1xuICByZXR1cm4gTWF0aC5mbG9vcihhIC8gbWFnbml0dWRlKSAqIG1hZ25pdHVkZTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tzKHN0YXJ0LCBzdGVwLCBjb3VudCkge1xuICBjb25zdCBzdGVwUG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoc3RlcCkpO1xuICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IHN0ZXAgPiAwICYmIHN0ZXAgPCAxID8gTWF0aC5hYnMoc3RlcFBvd2VyKSA6IDA7XG4gIGNvbnN0IGYgPSBNYXRoLnBvdygxMCwgZnJhY3Rpb25EaWdpdHMpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBjb25zdCB0aWNrID0gc3RhcnQgKyBzdGVwICogaTtcbiAgICB0aWNrc1tpXSA9IE1hdGgucm91bmQodGljayAqIGYpIC8gZjtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiBnZXRUaWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBjb3VudCAtIDE7XG4gIGNvbnN0IHJhd1N0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIHNlZ21lbnRzO1xuICByZXR1cm4gY2FsY3VsYXRlTmV4dE5pY2VTdGVwKHJhd1N0ZXApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTmV4dE5pY2VTdGVwKHJhd1N0ZXApIHtcbiAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAocmF3U3RlcCkpO1xuICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnBvdygxMCwgb3JkZXIpO1xuICBjb25zdCBzdGVwID0gcmF3U3RlcCAvIG1hZ25pdHVkZSAqIDEwO1xuICBpZiAoc3RlcCA+IDAgJiYgc3RlcCA8PSAxKSB7XG4gICAgcmV0dXJuIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gMSAmJiBzdGVwIDw9IDIpIHtcbiAgICByZXR1cm4gMiAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gMSAmJiBzdGVwIDw9IDUpIHtcbiAgICByZXR1cm4gNSAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gNSAmJiBzdGVwIDw9IDEwKSB7XG4gICAgcmV0dXJuIDEwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxMCAmJiBzdGVwIDw9IDIwKSB7XG4gICAgcmV0dXJuIDIwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAyMCAmJiBzdGVwIDw9IDQwKSB7XG4gICAgcmV0dXJuIDQwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA0MCAmJiBzdGVwIDw9IDUwKSB7XG4gICAgcmV0dXJuIDUwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA1MCAmJiBzdGVwIDw9IDEwMCkge1xuICAgIHJldHVybiAxMDAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICByZXR1cm4gc3RlcDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9udW1iZXJBeGlzLnRzXG52YXIgTnVtYmVyQXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCwgc2NhbGUyID0gbmV3IExpbmVhclNjYWxlKCkpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgdGhpcy5taW4gPSBOYU47XG4gICAgdGhpcy5tYXggPSBOYU47XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGV4dGVudDogZXh0ZW50MiwgY2xpcHBlZCB9ID0gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCk7XG4gICAgcmV0dXJuIHsgZG9tYWluOiBleHRlbnQyLCBjbGlwcGVkIH07XG4gIH1cbiAgdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKHByaW1hcnlUaWNrQ291bnQpIHtcbiAgICBpZiAodGhpcy5kYXRhRG9tYWluID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGRhdGFEb21haW4gbm90IGNhbGN1bGF0ZWQsIGNhbm5vdCBwZXJmb3JtIHRpY2sgY2FsY3VsYXRpb24uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhRG9tYWluLmRvbWFpbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBkb21haW4sIHRpY2tzIH0gPSBjYWxjdWxhdGVOaWNlU2Vjb25kYXJ5QXhpcyhcbiAgICAgIHRoaXMuZGF0YURvbWFpbi5kb21haW4sXG4gICAgICBwcmltYXJ5VGlja0NvdW50ID8/IDAsXG4gICAgICB0aGlzLnJldmVyc2VcbiAgICApO1xuICAgIHRoaXMuc2NhbGUubmljZSA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGUuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuc2NhbGUudXBkYXRlKCk7XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG59O1xuTnVtYmVyQXhpcy5jbGFzc05hbWUgPSBcIk51bWJlckF4aXNcIjtcbk51bWJlckF4aXMudHlwZSA9IFwibnVtYmVyXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTiwgTEVTU19USEFOKFwibWF4XCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTnVtYmVyQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIEdSRUFURVJfVEhBTihcIm1pblwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIE51bWJlckF4aXMucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9sb2dBeGlzLnRzXG52YXIgTk9OX1pFUk9fTlVNQkVSID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT09IDAsIFwiYSBub24temVybyBudW1iZXJcIik7XG52YXIgTG9nQXhpcyA9IGNsYXNzIGV4dGVuZHMgTnVtYmVyQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IExvZ1NjYWxlKCkpO1xuICAgIHRoaXMubWluID0gTmFOO1xuICAgIHRoaXMubWF4ID0gTmFOO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBleHRlbnQ6IGV4dGVudDIsIGNsaXBwZWQgfSA9IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpO1xuICAgIGNvbnN0IGlzSW52ZXJ0ZWQgPSBleHRlbnQyWzBdID4gZXh0ZW50MlsxXTtcbiAgICBjb25zdCBjcm9zc2VzWmVybyA9IGV4dGVudDJbMF0gPCAwICYmIGV4dGVudDJbMV0gPiAwO1xuICAgIGNvbnN0IGhhc1plcm9FeHRlbnQgPSBleHRlbnQyWzBdID09PSAwICYmIGV4dGVudDJbMV0gPT09IDA7XG4gICAgY29uc3QgaW52YWxpZERvbWFpbiA9IGlzSW52ZXJ0ZWQgfHwgY3Jvc3Nlc1plcm8gfHwgaGFzWmVyb0V4dGVudDtcbiAgICBpZiAoaW52YWxpZERvbWFpbikge1xuICAgICAgaWYgKGNyb3NzZXNaZXJvKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICAgIGB0aGUgZGF0YSBkb21haW4gY3Jvc3NlcyB6ZXJvLCB0aGUgY2hhcnQgZGF0YSBjYW5ub3QgYmUgcmVuZGVyZWQuIFNlZSBsb2cgYXhpcyBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzWmVyb0V4dGVudCkge1xuICAgICAgICBMb2dnZXIud2FybihgdGhlIGRhdGEgZG9tYWluIGhhcyAwIGV4dGVudCwgbm8gZGF0YSBpcyByZW5kZXJlZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dGVudDJbMF0gPT09IDApIHtcbiAgICAgIGV4dGVudDJbMF0gPSAxO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MlsxXSA9PT0gMCkge1xuICAgICAgZXh0ZW50MlsxXSA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4geyBkb21haW46IGV4dGVudDIsIGNsaXBwZWQgfTtcbiAgfVxuICBzZXQgYmFzZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NhbGUuYmFzZSA9IHZhbHVlO1xuICB9XG4gIGdldCBiYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLmJhc2U7XG4gIH1cbn07XG5Mb2dBeGlzLmNsYXNzTmFtZSA9IFwiTG9nQXhpc1wiO1xuTG9nQXhpcy50eXBlID0gXCJsb2dcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBOT05fWkVST19OVU1CRVIsIExFU1NfVEhBTihcIm1heFwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIExvZ0F4aXMucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBOT05fWkVST19OVU1CRVIsIEdSRUFURVJfVEhBTihcIm1pblwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIExvZ0F4aXMucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy90aW1lQXhpcy50c1xudmFyIFRpbWVBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBuZXcgVGltZVNjYWxlKCkpO1xuICAgIHRoaXMubWluID0gdm9pZCAwO1xuICAgIHRoaXMubWF4ID0gdm9pZCAwO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGxldCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGxldCBjbGlwcGVkID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBtaW4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG1pbiA9IG5ldyBEYXRlKG1pbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWF4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBtYXggPSBuZXcgRGF0ZShtYXgpO1xuICAgIH1cbiAgICBpZiAoZC5sZW5ndGggPiAyKSB7XG4gICAgICBkID0gKGV4dGVudChkKSA/PyBbMCwgMWUzXSkubWFwKCh4KSA9PiBuZXcgRGF0ZSh4KSk7XG4gICAgfVxuICAgIGlmIChtaW4gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWluID4gZFswXSk7XG4gICAgICBkID0gW21pbiwgZFsxXV07XG4gICAgfVxuICAgIGlmIChtYXggaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWF4IDwgZFsxXSk7XG4gICAgICBkID0gW2RbMF0sIG1heF07XG4gICAgfVxuICAgIGlmIChkWzBdID4gZFsxXSkge1xuICAgICAgZCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4geyBkb21haW46IGQsIGNsaXBwZWQgfTtcbiAgfVxuICBvbkZvcm1hdENoYW5nZSh0aWNrcywgZnJhY3Rpb25EaWdpdHMsIGRvbWFpbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgc3VwZXIub25Gb3JtYXRDaGFuZ2UodGlja3MsIGZyYWN0aW9uRGlnaXRzLCBkb21haW4sIGZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSB0aGlzLnNjYWxlLnRpY2tGb3JtYXQoeyB0aWNrcywgZG9tYWluIH0pO1xuICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IHRoaXMuc2NhbGUudGlja0Zvcm1hdCh7IHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldDogMSB9KTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlUGFkZGluZygpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG59O1xuVGltZUF4aXMuY2xhc3NOYW1lID0gXCJUaW1lQXhpc1wiO1xuVGltZUF4aXMudHlwZSA9IFwidGltZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKERBVEVfT1JfREFURVRJTUVfTVMsIExFU1NfVEhBTihcIm1heFwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRpbWVBeGlzLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoREFURV9PUl9EQVRFVElNRV9NUywgR1JFQVRFUl9USEFOKFwibWluXCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVGltZUF4aXMucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9jb3JuZXIudHNcbnZhciBkcmF3Q29ybmVyID0gKHBhdGgsIHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9LCBjb3JuZXJSYWRpdXMsIG1vdmUpID0+IHtcbiAgaWYgKG1vdmUpIHtcbiAgICBwYXRoLm1vdmVUbyh4MCwgeTApO1xuICB9XG4gIGlmICh4MCAhPT0geDEgfHwgeTAgIT09IHkxKSB7XG4gICAgY29uc3QgcjAgPSBNYXRoLmF0YW4yKHkwIC0gY3ksIHgwIC0gY3gpO1xuICAgIGNvbnN0IHIxID0gTWF0aC5hdGFuMih5MSAtIGN5LCB4MSAtIGN4KTtcbiAgICBwYXRoLmFyYyhjeCwgY3ksIGNvcm5lclJhZGl1cywgcjAsIHIxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLmxpbmVUbyh4MCwgeTApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9yZWN0LnRzXG52YXIgZXBzaWxvbiA9IDFlLTY7XG52YXIgY29ybmVyRWRnZXMgPSAobGVhZGluZ0VkZ2UsIHRyYWlsaW5nRWRnZSwgbGVhZGluZ0luc2V0LCB0cmFpbGluZ0luc2V0LCBjb3JuZXJSYWRpdXMpID0+IHtcbiAgbGV0IGxlYWRpbmdDbGlwcGVkID0gZmFsc2U7XG4gIGxldCB0cmFpbGluZ0NsaXBwZWQgPSBmYWxzZTtcbiAgbGV0IGxlYWRpbmcwID0gdHJhaWxpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtIGxlYWRpbmdJbnNldCAqKiAyLCAwKSk7XG4gIGxldCBsZWFkaW5nMSA9IDA7XG4gIGxldCB0cmFpbGluZzAgPSAwO1xuICBsZXQgdHJhaWxpbmcxID0gbGVhZGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gdHJhaWxpbmdJbnNldCAqKiAyLCAwKSk7XG4gIGlmIChsZWFkaW5nMCA+IGxlYWRpbmdFZGdlKSB7XG4gICAgbGVhZGluZ0NsaXBwZWQgPSB0cnVlO1xuICAgIGxlYWRpbmcwID0gbGVhZGluZ0VkZ2U7XG4gICAgbGVhZGluZzEgPSBsZWFkaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSAodHJhaWxpbmdJbnNldCAtIGxlYWRpbmdFZGdlKSAqKiAyKSk7XG4gIH0gZWxzZSBpZiAobGVhZGluZzAgPCBlcHNpbG9uKSB7XG4gICAgbGVhZGluZzAgPSAwO1xuICB9XG4gIGlmICh0cmFpbGluZzEgPiB0cmFpbGluZ0VkZ2UpIHtcbiAgICB0cmFpbGluZ0NsaXBwZWQgPSB0cnVlO1xuICAgIHRyYWlsaW5nMCA9IHRyYWlsaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSAobGVhZGluZ0luc2V0IC0gdHJhaWxpbmdFZGdlKSAqKiAyKSk7XG4gICAgdHJhaWxpbmcxID0gdHJhaWxpbmdFZGdlO1xuICB9IGVsc2UgaWYgKHRyYWlsaW5nMSA8IGVwc2lsb24pIHtcbiAgICB0cmFpbGluZzEgPSAwO1xuICB9XG4gIHJldHVybiB7IGxlYWRpbmcwLCBsZWFkaW5nMSwgdHJhaWxpbmcwLCB0cmFpbGluZzEsIGxlYWRpbmdDbGlwcGVkLCB0cmFpbGluZ0NsaXBwZWQgfTtcbn07XG52YXIgaW5zZXRDb3JuZXJSYWRpdXNSZWN0ID0gKHBhdGgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGlpLCBjbGlwQkJveCkgPT4ge1xuICBsZXQge1xuICAgIHRvcExlZnQ6IHRvcExlZnRDb3JuZXJSYWRpdXMsXG4gICAgdG9wUmlnaHQ6IHRvcFJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21MZWZ0OiBib3R0b21MZWZ0Q29ybmVyUmFkaXVzXG4gIH0gPSBjb3JuZXJSYWRpaTtcbiAgY29uc3QgbWF4VmVydGljYWxDb3JuZXJSYWRpdXMgPSBNYXRoLm1heChcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzICsgYm90dG9tTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodENvcm5lclJhZGl1cyArIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXG4gICk7XG4gIGNvbnN0IG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgPSBNYXRoLm1heChcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzICsgdG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tTGVmdENvcm5lclJhZGl1cyArIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXG4gICk7XG4gIGlmIChtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyA8PSAwICYmIG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgPD0gMCkge1xuICAgIGlmIChjbGlwQkJveCA9PSBudWxsKSB7XG4gICAgICBwYXRoLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucmVjdChjbGlwQkJveC54LCBjbGlwQkJveC55LCBjbGlwQkJveC53aWR0aCwgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGNsaXBCQm94ID09IG51bGwgJiYgdG9wTGVmdENvcm5lclJhZGl1cyA9PT0gdG9wUmlnaHRDb3JuZXJSYWRpdXMgJiYgdG9wTGVmdENvcm5lclJhZGl1cyA9PT0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgJiYgdG9wTGVmdENvcm5lclJhZGl1cyA9PT0gYm90dG9tTGVmdENvcm5lclJhZGl1cykge1xuICAgIHBhdGgucm91bmRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHRvcExlZnRDb3JuZXJSYWRpdXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCArPSB3aWR0aDtcbiAgICB3aWR0aCA9IE1hdGguYWJzKHdpZHRoKTtcbiAgfVxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgKz0gaGVpZ2h0O1xuICAgIGhlaWdodCA9IE1hdGguYWJzKGhlaWdodCk7XG4gIH1cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApXG4gICAgcmV0dXJuO1xuICBpZiAoY2xpcEJCb3ggPT0gbnVsbCkge1xuICAgIGNsaXBCQm94ID0gbmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heCh4LCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKHggKyB3aWR0aCwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MCA9IE1hdGgubWF4KHksIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5taW4oeSArIGhlaWdodCwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY2xpcEJCb3ggPSBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICB9XG4gIGNvbnN0IGJvcmRlclNjYWxlID0gTWF0aC5tYXgobWF4VmVydGljYWxDb3JuZXJSYWRpdXMgLyBoZWlnaHQsIG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgLyB3aWR0aCwgMSk7XG4gIGlmIChib3JkZXJTY2FsZSA+IDEpIHtcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzIC89IGJvcmRlclNjYWxlO1xuICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzIC89IGJvcmRlclNjYWxlO1xuICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzIC89IGJvcmRlclNjYWxlO1xuICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gIH1cbiAgbGV0IGRyYXdUb3BMZWZ0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IGRyYXdUb3BSaWdodENvcm5lciA9IHRydWU7XG4gIGxldCBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSB0cnVlO1xuICBsZXQgZHJhd0JvdHRvbUxlZnRDb3JuZXIgPSB0cnVlO1xuICBsZXQgdG9wTGVmdENvcm5lcjtcbiAgbGV0IHRvcFJpZ2h0Q29ybmVyO1xuICBsZXQgYm90dG9tUmlnaHRDb3JuZXI7XG4gIGxldCBib3R0b21MZWZ0Q29ybmVyO1xuICBpZiAoZHJhd1RvcExlZnRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBNYXRoLm1heCh4ICsgdG9wTGVmdENvcm5lclJhZGl1cyAtIGNsaXBCQm94LngsIDApLFxuICAgICAgTWF0aC5tYXgoeSArIHRvcExlZnRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC55LCAwKSxcbiAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGlmIChub2Rlcy5sZWFkaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdCb3R0b21MZWZ0Q29ybmVyID0gZmFsc2U7XG4gICAgaWYgKG5vZGVzLnRyYWlsaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BSaWdodENvcm5lciA9IGZhbHNlO1xuICAgIGNvbnN0IHgwID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB5MCA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heChjbGlwQkJveC54ICsgbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IGN4ID0geCArIHRvcExlZnRDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgY3kgPSB5ICsgdG9wTGVmdENvcm5lclJhZGl1cztcbiAgICB0b3BMZWZ0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdUb3BSaWdodENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIE1hdGgubWF4KHkgKyB0b3BSaWdodENvcm5lclJhZGl1cyAtIGNsaXBCQm94LnksIDApLFxuICAgICAgTWF0aC5tYXgoY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gKHggKyB3aWR0aCAtIHRvcFJpZ2h0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICB0b3BSaWdodENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcExlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1pbihjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MCA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbihjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCBjeCA9IHggKyB3aWR0aCAtIHRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIHRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIHRvcFJpZ2h0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21SaWdodENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtICh4ICsgd2lkdGggLSBib3R0b21SaWdodENvcm5lclJhZGl1cyksIDApLFxuICAgICAgTWF0aC5tYXgoY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtICh5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbUxlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IGN4ID0geCArIHdpZHRoIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgY3kgPSB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgYm90dG9tUmlnaHRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBpZiAoZHJhd0JvdHRvbUxlZnRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBNYXRoLm1heChjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gKHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICBNYXRoLm1heCh4ICsgYm90dG9tTGVmdENvcm5lclJhZGl1cyAtIGNsaXBCQm94LngsIDApLFxuICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgaWYgKG5vZGVzLnRyYWlsaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BMZWZ0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heChjbGlwQkJveC54ICsgbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgY3ggPSB4ICsgYm90dG9tTGVmdENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGJvdHRvbUxlZnRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBsZXQgZGlkTW92ZSA9IGZhbHNlO1xuICBpZiAoZHJhd1RvcExlZnRDb3JuZXIgJiYgdG9wTGVmdENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCB0b3BMZWZ0Q29ybmVyLCB0b3BMZWZ0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3VG9wUmlnaHRDb3JuZXIgJiYgdG9wUmlnaHRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgdG9wUmlnaHRDb3JuZXIsIHRvcFJpZ2h0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3Qm90dG9tUmlnaHRDb3JuZXIgJiYgYm90dG9tUmlnaHRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgYm90dG9tUmlnaHRDb3JuZXIsIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3Qm90dG9tTGVmdENvcm5lciAmJiBib3R0b21MZWZ0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIGJvdHRvbUxlZnRDb3JuZXIsIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMsICFkaWRNb3ZlKTtcbiAgICBkaWRNb3ZlIHx8IChkaWRNb3ZlID0gdHJ1ZSk7XG4gIH1cbiAgcGF0aC5jbG9zZVBhdGgoKTtcbn07XG52YXIgUmVjdCA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ib3JkZXJQYXRoID0gbmV3IEV4dGVuZGVkUGF0aDJEKCk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAxMDtcbiAgICB0aGlzLmhlaWdodCA9IDEwO1xuICAgIHRoaXMudG9wTGVmdENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy50b3BSaWdodENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmNsaXBCQm94ID0gdm9pZCAwO1xuICAgIHRoaXMuY3Jpc3AgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggPSBTaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHRoaXMuZWZmZWN0aXZlU3Ryb2tlV2lkdGggPSBTaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHRoaXMuaGl0dGVzdGVyID0gc3VwZXIuaXNQb2ludEluUGF0aDtcbiAgICB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvciA9IHN1cGVyLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQ7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVjdGFuZ2xlJ3Mgd2lkdGggb3IgaGVpZ2h0IGlzIGxlc3MgdGhhbiBhIHBpeGVsXG4gICAgICogYW5kIGNyaXNwIG1vZGUgaXMgb24sIHRoZSByZWN0YW5nbGUgd2lsbCBzdGlsbCBmaXQgaW50byB0aGUgcGl4ZWwsXG4gICAgICogYnV0IHdpbGwgYmUgbGVzcyBvcGFxdWUgdG8gbWFrZSBhbiBlZmZlY3Qgb2YgaG9sZGluZyBsZXNzIHNwYWNlLlxuICAgICAqL1xuICAgIHRoaXMubWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKSB7XG4gICAgdGhpcy50b3BMZWZ0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICAgIHRoaXMudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gICAgdGhpcy5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICB0aGlzLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gIH1cbiAgaXNEaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCAhPT0gdGhpcy5zdHJva2VXaWR0aCB8fCBCb29sZWFuKHRoaXMucGF0aC5pc0RpcnR5KCkgfHwgdGhpcy5ib3JkZXJQYXRoLmlzRGlydHkoKSk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoLFxuICAgICAgYm9yZGVyUGF0aCxcbiAgICAgIGNyaXNwLFxuICAgICAgdG9wTGVmdENvcm5lclJhZGl1czogdG9wTGVmdCxcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiB0b3BSaWdodCxcbiAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBib3R0b21SaWdodCxcbiAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IGJvdHRvbUxlZnRcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgeyB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLCBzdHJva2VXaWR0aCwgY2xpcEJCb3ggfSA9IHRoaXM7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IHBpeGVsU2l6ZSA9IDEgLyBwaXhlbFJhdGlvO1xuICAgIGxldCBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSA9IDE7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBib3JkZXJQYXRoLmNsZWFyKHRydWUpO1xuICAgIGlmIChjcmlzcCkge1xuICAgICAgaWYgKHcgPD0gcGl4ZWxTaXplKSB7XG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ICo9IHcgLyBwaXhlbFNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaCA8PSBwaXhlbFNpemUpIHtcbiAgICAgICAgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgKj0gaCAvIHBpeGVsU2l6ZTtcbiAgICAgIH1cbiAgICAgIHcgPSB0aGlzLmFsaWduKHgsIHcpO1xuICAgICAgaCA9IHRoaXMuYWxpZ24oeSwgaCk7XG4gICAgICB4ID0gdGhpcy5hbGlnbih4KTtcbiAgICAgIHkgPSB0aGlzLmFsaWduKHkpO1xuICAgICAgY2xpcEJCb3ggPSBjbGlwQkJveCAhPSBudWxsID8gbmV3IEJCb3goXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueCksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueSksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueCwgY2xpcEJCb3gud2lkdGgpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LnksIGNsaXBCQm94LmhlaWdodClcbiAgICAgICkgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgaWYgKHcgPCBwaXhlbFNpemUpIHtcbiAgICAgICAgY29uc3QgbHggPSB4ICsgcGl4ZWxTaXplIC8gMjtcbiAgICAgICAgYm9yZGVyUGF0aC5tb3ZlVG8obHgsIHkpO1xuICAgICAgICBib3JkZXJQYXRoLmxpbmVUbyhseCwgeSArIGgpO1xuICAgICAgICBzdHJva2VXaWR0aCA9IHBpeGVsU2l6ZTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoaCA8IHBpeGVsU2l6ZSkge1xuICAgICAgICBjb25zdCBseSA9IHkgKyBwaXhlbFNpemUgLyAyO1xuICAgICAgICBib3JkZXJQYXRoLm1vdmVUbyh4LCBseSk7XG4gICAgICAgIGJvcmRlclBhdGgubGluZVRvKHggKyB3LCBseSk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gcGl4ZWxTaXplO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmIChzdHJva2VXaWR0aCA8IHcgJiYgc3Ryb2tlV2lkdGggPCBoKSB7XG4gICAgICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgeCArPSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgICAgIHkgKz0gaGFsZlN0cm9rZVdpZHRoO1xuICAgICAgICB3IC09IHN0cm9rZVdpZHRoO1xuICAgICAgICBoIC09IHN0cm9rZVdpZHRoO1xuICAgICAgICBjb25zdCBhZGp1c3RlZENsaXBCQm94ID0gY2xpcEJCb3g/LmNsb25lKCkuc2hyaW5rKGhhbGZTdHJva2VXaWR0aCk7XG4gICAgICAgIGNvbnN0IGNvcm5lclJhZGlpID0ge1xuICAgICAgICAgIHRvcExlZnQ6IHRvcExlZnQgPiAwID8gdG9wTGVmdCAtIHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgICB0b3BSaWdodDogdG9wUmlnaHQgPiAwID8gdG9wUmlnaHQgLSBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgYm90dG9tUmlnaHQ6IGJvdHRvbVJpZ2h0ID4gMCA/IGJvdHRvbVJpZ2h0IC0gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnQgPiAwID8gYm90dG9tTGVmdCAtIHN0cm9rZVdpZHRoIDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgICBpZiAodyA+IDAgJiYgaCA+IDAgJiYgKGFkanVzdGVkQ2xpcEJCb3ggPT0gbnVsbCB8fCBhZGp1c3RlZENsaXBCQm94Py53aWR0aCA+IDAgJiYgYWRqdXN0ZWRDbGlwQkJveD8uaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICBpbnNldENvcm5lclJhZGl1c1JlY3QocGF0aCwgeCwgeSwgdywgaCwgY29ybmVyUmFkaWksIGFkanVzdGVkQ2xpcEJCb3gpO1xuICAgICAgICAgIGluc2V0Q29ybmVyUmFkaXVzUmVjdChib3JkZXJQYXRoLCB4LCB5LCB3LCBoLCBjb3JuZXJSYWRpaSwgYWRqdXN0ZWRDbGlwQkJveCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB0aGlzLmJvcmRlckNsaXBQYXRoID8/IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoLmNsZWFyKHRydWUpO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIGJvcmRlclBhdGgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29ybmVyUmFkaWkgPSB7IHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCB9O1xuICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIGluc2V0Q29ybmVyUmFkaXVzUmVjdChwYXRoLCB4LCB5LCB3LCBoLCBjb3JuZXJSYWRpaSwgY2xpcEJCb3gpO1xuICAgIH1cbiAgICBpZiAoW3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdF0uZXZlcnkoKHIpID0+IHIgPT09IDApKSB7XG4gICAgICB0aGlzLmhpdHRlc3RlciA9IChoaXRYLCBoaXRZKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludChoaXRYLCBoaXRZKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpLmNvbnRhaW5zUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5kaXN0YW5jZVNxdWFyZWQgPSAoaGl0WCwgaGl0WSkgPT4gdGhpcy5nZXRCQm94KCkuZGlzdGFuY2VTcXVhcmVkKGhpdFgsIGhpdFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpdHRlc3RlciA9IHN1cGVyLmlzUG9pbnRJblBhdGg7XG4gICAgICB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvciA9IHN1cGVyLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuZWZmZWN0aXZlU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICB0aGlzLm1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGlwQkJveCB9ID0gdGhpcztcbiAgICByZXR1cm4gY2xpcEJCb3g/LmNsb25lKCkgPz8gbmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0dGVzdGVyKHgsIHkpO1xuICB9XG4gIGdldCBtaWRQb2ludCgpIHtcbiAgICByZXR1cm4geyB4OiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgeTogdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyIH07XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZUNhbGN1bGF0b3IoeCwgeSk7XG4gIH1cbiAgYXBwbHlGaWxsQWxwaGEoY3R4KSB7XG4gICAgY29uc3QgeyBmaWxsT3BhY2l0eSwgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHksIG9wYWNpdHkgfSA9IHRoaXM7XG4gICAgY3R4Lmdsb2JhbEFscGhhICo9IG9wYWNpdHkgKiBmaWxsT3BhY2l0eSAqIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5O1xuICB9XG4gIHJlbmRlclN0cm9rZShjdHgpIHtcbiAgICBjb25zdCB7IHN0cm9rZSwgZWZmZWN0aXZlU3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgaWYgKHN0cm9rZSAmJiBlZmZlY3RpdmVTdHJva2VXaWR0aCkge1xuICAgICAgY29uc3QgeyBnbG9iYWxBbHBoYSB9ID0gY3R4O1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBsaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICAgIGxpbmVDYXAsXG4gICAgICAgIGxpbmVKb2luLFxuICAgICAgICBib3JkZXJQYXRoLFxuICAgICAgICBib3JkZXJDbGlwUGF0aCxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHlcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKGJvcmRlckNsaXBQYXRoKSB7XG4gICAgICAgIGN0eC5jbGlwKGJvcmRlckNsaXBQYXRoLmdldFBhdGgyRCgpKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5ICogc3Ryb2tlT3BhY2l0eSAqIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGVmZmVjdGl2ZVN0cm9rZVdpZHRoO1xuICAgICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAobGluZUpvaW4pIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlKGJvcmRlclBhdGguZ2V0UGF0aDJEKCkpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgfVxuICB9XG59O1xuUmVjdC5jbGFzc05hbWUgPSBcIlJlY3RcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInRvcExlZnRDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwidG9wUmlnaHRDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiYm90dG9tTGVmdENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJjbGlwQkJveFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJjcmlzcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYmFja2dyb3VuZC9iYWNrZ3JvdW5kLnRzXG52YXIgQmFja2dyb3VuZCA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4LCB6SW5kZXggPSAwIC8qIFNFUklFU19CQUNLR1JPVU5EX1pJTkRFWCAqLywgbGF5ZXIgPSBmYWxzZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy56SW5kZXggPSB6SW5kZXg7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMucmVjdE5vZGUgPSBuZXcgUmVjdCgpO1xuICAgIHRoaXMudGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuZmlsbCA9IFwid2hpdGVcIjtcbiAgICB0aGlzLm5vZGUgPSBuZXcgR3JvdXAoeyBuYW1lOiBcImJhY2tncm91bmRcIiwgekluZGV4OiB0aGlzLnpJbmRleCwgbGF5ZXI6IHRoaXMubGF5ZXIgfSk7XG4gICAgdGhpcy5ub2RlLmFwcGVuZChbdGhpcy5yZWN0Tm9kZSwgdGhpcy50ZXh0Tm9kZV0pO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHguc2NlbmUuYXR0YWNoTm9kZSh0aGlzLm5vZGUpLFxuICAgICAgY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGUpID0+IHRoaXMub25MYXlvdXRDb21wbGV0ZShlKSlcbiAgICApO1xuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUoZSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZS5jaGFydDtcbiAgICB0aGlzLnJlY3ROb2RlLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5yZWN0Tm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIsIFwidmlzaWJsZVwiKVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJyZWN0Tm9kZVwiLCBcImZpbGxcIilcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcImltYWdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcInRleHROb2RlXCIpXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9iYWNrZ3JvdW5kL2JhY2tncm91bmRNb2R1bGUudHNcbnZhciBCYWNrZ3JvdW5kTW9kdWxlID0ge1xuICB0eXBlOiBcInJvb3RcIixcbiAgb3B0aW9uc0tleTogXCJiYWNrZ3JvdW5kXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQmFja2dyb3VuZChjdHgpXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zcHJpdGVSZW5kZXJlci50c1xudmFyIFNwcml0ZVJlbmRlcmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5vZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmIChjdHggPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFHIENoYXJ0cyAtIGludmFsaWQgMmQgY29udGV4dGApO1xuICAgIHRoaXMucmVuZGVyQ3R4ID0ge1xuICAgICAgY3R4LFxuICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogMSxcbiAgICAgIGZvcmNlUmVuZGVyOiB0cnVlLFxuICAgICAgcmVzaXplZDogZmFsc2UsXG4gICAgICBkZWJ1Z05vZGVzOiB7fVxuICAgIH07XG4gIH1cbiAgcmVzaXplKHsgc3ByaXRlUGl4ZWxSYXRpbywgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCB9KSB7XG4gICAgdGhpcy5vZmZzY3JlZW5DYW52YXMud2lkdGggPSBNYXRoLm1heChzcHJpdGVXaWR0aCwgMCkgKiBzcHJpdGVQaXhlbFJhdGlvO1xuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLmhlaWdodCA9IE1hdGgubWF4KHNwcml0ZUhlaWdodCwgMCkgKiBzcHJpdGVQaXhlbFJhdGlvO1xuICB9XG4gIHJlbmRlclNwcml0ZShub2Rlcywgb3B0cykge1xuICAgIG5vZGVzID0gdG9JdGVyYWJsZShub2Rlcyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyQ3R4LFxuICAgICAgcmVuZGVyQ3R4OiB7IGN0eCB9LFxuICAgICAgb2Zmc2NyZWVuQ2FudmFzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyID0gMSwgdHJhbnNsYXRlWCA9IDAsIHRyYW5zbGF0ZVkgPSAwIH0gPSBvcHRzID8/IHt9O1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgb2Zmc2NyZWVuQ2FudmFzLndpZHRoLCBvZmZzY3JlZW5DYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKHNjYWxlMiwgMCwgMCwgc2NhbGUyLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIG5vZGUucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybiBvZmZzY3JlZW5DYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwva2V5bmF2VXRpbC50c1xuZnVuY3Rpb24gYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBidXR0b24sIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgZGVzdHJveUZucy5wdXNoKCgpID0+IGJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSk7XG59XG5mdW5jdGlvbiBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGVsZW0sIG9uRXNjYXBlKSB7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgIG9uRXNjYXBlKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hlc0tleShldmVudCwga2V5LCAuLi5tb3Jla2V5cykge1xuICByZXR1cm4gIShldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiAoZXZlbnQua2V5ID09PSBrZXkgfHwgbW9yZWtleXMuc29tZSgoYWx0a2V5KSA9PiBldmVudC5rZXkgPT09IGFsdGtleSkpO1xufVxuZnVuY3Rpb24gbGlua1R3b0J1dHRvbnMoZGVzdHJveUZucywgc3JjLCBkc3QsIGtleSkge1xuICBpZiAoIWRzdClcbiAgICByZXR1cm47XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgc3JjLCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKG1hdGNoZXNLZXkoZXZlbnQsIGtleSkpIHtcbiAgICAgIGRzdC5mb2N1cygpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaW5rVGhyZWVCdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIG5leHQsIG5leHRLZXksIHByZXYsIHByZXZLZXkpIHtcbiAgbGlua1R3b0J1dHRvbnMoZGVzdHJveUZucywgY3VyciwgcHJldiwgcHJldktleSk7XG4gIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIG5leHQsIG5leHRLZXkpO1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAobWF0Y2hlc0tleShldmVudCwgbmV4dEtleSwgcHJldktleSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBQUkVWX05FWFRfS0VZUyA9IHtcbiAgaG9yaXpvbnRhbDogeyBuZXh0S2V5OiBcIkFycm93UmlnaHRcIiwgcHJldktleTogXCJBcnJvd0xlZnRcIiB9LFxuICB2ZXJ0aWNhbDogeyBuZXh0S2V5OiBcIkFycm93RG93blwiLCBwcmV2S2V5OiBcIkFycm93VXBcIiB9XG59O1xuZnVuY3Rpb24gaW5pdFRvb2xiYXJLZXlOYXYob3B0cykge1xuICBjb25zdCB7IG9yaWVudGF0aW9uLCB0b29sYmFyLCBidXR0b25zLCBvbkVzY2FwZSwgb25Gb2N1cywgb25CbHVyIH0gPSBvcHRzO1xuICBjb25zdCB7IG5leHRLZXksIHByZXZLZXkgfSA9IFBSRVZfTkVYVF9LRVlTW29yaWVudGF0aW9uXTtcbiAgY29uc3QgYXJpYUhpZGRlbiA9IGJ1dHRvbnMubGVuZ3RoID09PSAwO1xuICB0b29sYmFyLnJvbGUgPSBcInRvb2xiYXJcIjtcbiAgdG9vbGJhci5hcmlhT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgdG9vbGJhci5hcmlhSGlkZGVuID0gYXJpYUhpZGRlbi50b1N0cmluZygpO1xuICBjb25zdCBzZXRUYWJJbmRpY2VzID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiBcInRhYkluZGV4XCIgaW4gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBidXR0b25zLmZvckVhY2goKGIpID0+IGIudGFiSW5kZXggPSAtMSk7XG4gICAgICBldmVudC50YXJnZXQudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZGVzdHJveUZucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gYnV0dG9uc1tpIC0gMV07XG4gICAgY29uc3QgY3VyciA9IGJ1dHRvbnNbaV07XG4gICAgY29uc3QgbmV4dCA9IGJ1dHRvbnNbaSArIDFdO1xuICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJmb2N1c1wiLCBzZXRUYWJJbmRpY2VzKTtcbiAgICBpZiAob25Gb2N1cylcbiAgICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJmb2N1c1wiLCBvbkZvY3VzKTtcbiAgICBpZiAob25CbHVyKVxuICAgICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImJsdXJcIiwgb25CbHVyKTtcbiAgICBpZiAob25Fc2NhcGUpXG4gICAgICBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIG9uRXNjYXBlKTtcbiAgICBsaW5rVGhyZWVCdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIHByZXYsIHByZXZLZXksIG5leHQsIG5leHRLZXkpO1xuICAgIGN1cnIudGFiSW5kZXggPSBpID09PSAwID8gMCA6IC0xO1xuICB9XG4gIHJldHVybiBkZXN0cm95Rm5zO1xufVxuZnVuY3Rpb24gaW5pdE1lbnVLZXlOYXYob3B0cykge1xuICBjb25zdCB7IG9yaWVudGF0aW9uLCBtZW51LCBidXR0b25zLCBvbkVzY2FwZSB9ID0gb3B0cztcbiAgY29uc3QgeyBuZXh0S2V5LCBwcmV2S2V5IH0gPSBQUkVWX05FWFRfS0VZU1tvcmllbnRhdGlvbl07XG4gIG1lbnUucm9sZSA9IFwibWVudVwiO1xuICBtZW51LmFyaWFPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICBjb25zdCBkZXN0cm95Rm5zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXYgPSBidXR0b25zWyhidXR0b25zLmxlbmd0aCArIGkgLSAxKSAlIGJ1dHRvbnMubGVuZ3RoXTtcbiAgICBjb25zdCBjdXJyID0gYnV0dG9uc1tpXTtcbiAgICBjb25zdCBuZXh0ID0gYnV0dG9uc1soYnV0dG9ucy5sZW5ndGggKyBpICsgMSkgJSBidXR0b25zLmxlbmd0aF07XG4gICAgaWYgKG9uRXNjYXBlKVxuICAgICAgYWRkRXNjYXBlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBvbkVzY2FwZSk7XG4gICAgbGlua1RocmVlQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBwcmV2LCBwcmV2S2V5LCBuZXh0LCBuZXh0S2V5KTtcbiAgICBjdXJyLnRhYkluZGV4ID0gLTE7XG4gIH1cbiAgbWVudS50YWJJbmRleCA9IC0xO1xuICBpZiAob25Fc2NhcGUpXG4gICAgYWRkRXNjYXBlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBtZW51LCBvbkVzY2FwZSk7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgbWVudSwgXCJrZXlkb3duXCIsIChldikgPT4ge1xuICAgIGlmIChldi50YXJnZXQgPT09IG1lbnUgJiYgKGV2LmtleSA9PT0gbmV4dEtleSB8fCBldi5rZXkgPT09IHByZXZLZXkpKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYnV0dG9uc1swXT8uZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVzdHJveUZucztcbn1cbmZ1bmN0aW9uIG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcihlbGVtZW50Miwgb25jbGljaykge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQyLmFyaWFEaXNhYmxlZCA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbmNsaWNrKGV2ZW50KTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZ3JpZExheW91dC50c1xuZnVuY3Rpb24gZ3JpZExheW91dCh7XG4gIG9yaWVudGF0aW9uLFxuICBiYm94ZXMsXG4gIG1heEhlaWdodCxcbiAgbWF4V2lkdGgsXG4gIGl0ZW1QYWRkaW5nWSA9IDAsXG4gIGl0ZW1QYWRkaW5nWCA9IDAsXG4gIGZvcmNlUmVzdWx0ID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgY29uc3QgcHJpbWFyeSA9IHtcbiAgICBtYXg6IGhvcml6b250YWwgPyBtYXhXaWR0aCA6IG1heEhlaWdodCxcbiAgICBmbjogaG9yaXpvbnRhbCA/IChiKSA9PiBiLndpZHRoIDogKGIpID0+IGIuaGVpZ2h0LFxuICAgIHBhZGRpbmc6IGhvcml6b250YWwgPyBpdGVtUGFkZGluZ1ggOiBpdGVtUGFkZGluZ1lcbiAgfTtcbiAgY29uc3Qgc2Vjb25kYXJ5ID0ge1xuICAgIG1heDogaG9yaXpvbnRhbCA/IG1heEhlaWdodCA6IG1heFdpZHRoLFxuICAgIGZuOiBob3Jpem9udGFsID8gKGIpID0+IGIuaGVpZ2h0IDogKGIpID0+IGIud2lkdGgsXG4gICAgcGFkZGluZzogaG9yaXpvbnRhbCA/IGl0ZW1QYWRkaW5nWSA6IGl0ZW1QYWRkaW5nWFxuICB9O1xuICBsZXQgcHJvY2Vzc2VkQkJveENvdW50ID0gMDtcbiAgY29uc3QgcmF3UGFnZXMgPSBbXTtcbiAgd2hpbGUgKHByb2Nlc3NlZEJCb3hDb3VudCA8IGJib3hlcy5sZW5ndGgpIHtcbiAgICBjb25zdCB1bnByb2Nlc3NlZEJCb3hlcyA9IGJib3hlcy5zbGljZShwcm9jZXNzZWRCQm94Q291bnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NCQm94ZXModW5wcm9jZXNzZWRCQm94ZXMsIHByb2Nlc3NlZEJCb3hDb3VudCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzc2VkQkJveENvdW50ICs9IHJlc3VsdC5wcm9jZXNzZWRCQm94Q291bnQ7XG4gICAgcmF3UGFnZXMucHVzaChyZXN1bHQucGFnZUluZGljZXMpO1xuICB9XG4gIHJldHVybiBidWlsZFBhZ2VzKHJhd1BhZ2VzLCBvcmllbnRhdGlvbiwgYmJveGVzLCBpdGVtUGFkZGluZ1ksIGl0ZW1QYWRkaW5nWCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQkJveGVzKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcbiAgY29uc3QgbWluR3Vlc3MgPSAxO1xuICBsZXQgc3RhcnRpbmdHdWVzcyA9IGVzdGltYXRlU3RhcnRpbmdHdWVzcyhiYm94ZXMsIHByaW1hcnkpO1xuICBpZiAoc3RhcnRpbmdHdWVzcyA8IG1pbkd1ZXNzKSB7XG4gICAgaWYgKCFmb3JjZVJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFydGluZ0d1ZXNzID0gbWluR3Vlc3M7XG4gIH1cbiAgbGV0IGd1ZXNzID0gc3RhcnRpbmdHdWVzcztcbiAgd2hpbGUgKGd1ZXNzID49IG1pbkd1ZXNzKSB7XG4gICAgY29uc3QgcGFnZUluZGljZXMgPSBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIGd1ZXNzLCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KTtcbiAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCAmJiBndWVzcyA8PSBtaW5HdWVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCkge1xuICAgICAgZ3Vlc3MtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZ2VJbmRpY2VzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAocGFnZUluZGljZXMgPD0gbWluR3Vlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ3Vlc3MgPSBwYWdlSW5kaWNlcyA8IGd1ZXNzICYmIHBhZ2VJbmRpY2VzID4gbWluR3Vlc3MgPyBwYWdlSW5kaWNlcyA6IGd1ZXNzO1xuICAgICAgZ3Vlc3MtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzZWRCQm94Q291bnQgPSBwYWdlSW5kaWNlcy5sZW5ndGggKiBwYWdlSW5kaWNlc1swXS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgcHJvY2Vzc2VkQkJveENvdW50LCBwYWdlSW5kaWNlcyB9O1xuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnlDb3VudCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHN1bVNlY29uZGFyeSA9IDA7XG4gIGxldCBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gMDtcbiAgbGV0IGN1cnJlbnRQcmltYXJ5SW5kaWNlcyA9IFtdO1xuICBjb25zdCBtYXhQcmltYXJ5VmFsdWVzID0gW107XG4gIGZvciAobGV0IGJib3hJbmRleCA9IDA7IGJib3hJbmRleCA8IGJib3hlcy5sZW5ndGg7IGJib3hJbmRleCsrKSB7XG4gICAgY29uc3QgcHJpbWFyeVZhbHVlSWR4ID0gKGJib3hJbmRleCArIHByaW1hcnlDb3VudCkgJSBwcmltYXJ5Q291bnQ7XG4gICAgaWYgKHByaW1hcnlWYWx1ZUlkeCA9PT0gMCkge1xuICAgICAgc3VtU2Vjb25kYXJ5ICs9IGN1cnJlbnRNYXhTZWNvbmRhcnk7XG4gICAgICBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gMDtcbiAgICAgIGlmIChjdXJyZW50UHJpbWFyeUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50UHJpbWFyeUluZGljZXMpO1xuICAgICAgfVxuICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XG4gICAgfVxuICAgIGNvbnN0IHByaW1hcnlWYWx1ZSA9IHByaW1hcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgcHJpbWFyeS5wYWRkaW5nO1xuICAgIG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA9IE1hdGgubWF4KG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA/PyAwLCBwcmltYXJ5VmFsdWUpO1xuICAgIGN1cnJlbnRNYXhTZWNvbmRhcnkgPSBNYXRoLm1heChjdXJyZW50TWF4U2Vjb25kYXJ5LCBzZWNvbmRhcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgc2Vjb25kYXJ5LnBhZGRpbmcpO1xuICAgIGNvbnN0IGN1cnJlbnRTZWNvbmRhcnlEaW1lbnNpb24gPSBzdW1TZWNvbmRhcnkgKyBjdXJyZW50TWF4U2Vjb25kYXJ5O1xuICAgIGNvbnN0IHJldHVyblJlc3VsdCA9ICFmb3JjZVJlc3VsdCB8fCByZXN1bHQubGVuZ3RoID4gMDtcbiAgICBpZiAoY3VycmVudFNlY29uZGFyeURpbWVuc2lvbiA+IHNlY29uZGFyeS5tYXggJiYgcmV0dXJuUmVzdWx0KSB7XG4gICAgICBjdXJyZW50UHJpbWFyeUluZGljZXMgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBzdW1QcmltYXJ5ID0gbWF4UHJpbWFyeVZhbHVlcy5yZWR1Y2UoKHN1bTIsIG5leHQpID0+IHN1bTIgKyBuZXh0LCAwKTtcbiAgICBpZiAoc3VtUHJpbWFyeSA+IHByaW1hcnkubWF4ICYmICFmb3JjZVJlc3VsdCkge1xuICAgICAgaWYgKG1heFByaW1hcnlWYWx1ZXMubGVuZ3RoIDwgcHJpbWFyeUNvdW50KSB7XG4gICAgICAgIHJldHVybiBtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFByaW1hcnlJbmRpY2VzLnB1c2goYmJveEluZGV4ICsgaW5kZXhPZmZzZXQpO1xuICB9XG4gIGlmIChjdXJyZW50UHJpbWFyeUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQcmltYXJ5SW5kaWNlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gYnVpbGRQYWdlcyhyYXdQYWdlcywgb3JpZW50YXRpb24sIGJib3hlcywgaXRlbVBhZGRpbmdZLCBpdGVtUGFkZGluZ1gpIHtcbiAgbGV0IG1heFBhZ2VXaWR0aCA9IDA7XG4gIGxldCBtYXhQYWdlSGVpZ2h0ID0gMDtcbiAgY29uc3QgcGFnZXMgPSByYXdQYWdlcy5tYXAoKGluZGljZXMpID0+IHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBpbmRpY2VzID0gdHJhbnNwb3NlKGluZGljZXMpO1xuICAgIH1cbiAgICBsZXQgZW5kSW5kZXggPSAwO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBpbmRpY2VzLm1hcCgoY29sSW5kaWNlcykgPT4ge1xuICAgICAgY29uc3QgY29sQkJveGVzID0gY29sSW5kaWNlcy5tYXAoKGJib3hJbmRleCkgPT4ge1xuICAgICAgICBlbmRJbmRleCA9IE1hdGgubWF4KGJib3hJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICByZXR1cm4gYmJveGVzW2Jib3hJbmRleF07XG4gICAgICB9KTtcbiAgICAgIGxldCBjb2x1bW5IZWlnaHQgPSAwO1xuICAgICAgbGV0IGNvbHVtbldpZHRoID0gMDtcbiAgICAgIGNvbEJCb3hlcy5mb3JFYWNoKChiYm94KSA9PiB7XG4gICAgICAgIGNvbHVtbkhlaWdodCArPSBiYm94LmhlaWdodCArIGl0ZW1QYWRkaW5nWTtcbiAgICAgICAgY29sdW1uV2lkdGggPSBNYXRoLm1heChjb2x1bW5XaWR0aCwgYmJveC53aWR0aCArIGl0ZW1QYWRkaW5nWCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGljZXM6IGNvbEluZGljZXMsXG4gICAgICAgIGJib3hlczogY29sQkJveGVzLFxuICAgICAgICBjb2x1bW5IZWlnaHQ6IE1hdGguY2VpbChjb2x1bW5IZWlnaHQpLFxuICAgICAgICBjb2x1bW5XaWR0aDogTWF0aC5jZWlsKGNvbHVtbldpZHRoKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgcGFnZVdpZHRoID0gMDtcbiAgICBsZXQgcGFnZUhlaWdodCA9IDA7XG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgIHBhZ2VXaWR0aCArPSBjb2x1bW4uY29sdW1uV2lkdGg7XG4gICAgICBwYWdlSGVpZ2h0ID0gTWF0aC5tYXgocGFnZUhlaWdodCwgY29sdW1uLmNvbHVtbkhlaWdodCk7XG4gICAgfSk7XG4gICAgbWF4UGFnZVdpZHRoID0gTWF0aC5tYXgocGFnZVdpZHRoLCBtYXhQYWdlV2lkdGgpO1xuICAgIG1heFBhZ2VIZWlnaHQgPSBNYXRoLm1heChwYWdlSGVpZ2h0LCBtYXhQYWdlSGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1ucyxcbiAgICAgIHN0YXJ0SW5kZXg6IGluZGljZXNbMF1bMF0sXG4gICAgICBlbmRJbmRleCxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHsgcGFnZXMsIG1heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodCB9O1xufVxuZnVuY3Rpb24gdHJhbnNwb3NlKGRhdGEpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgXyBvZiBkYXRhWzBdKSB7XG4gICAgcmVzdWx0LnB1c2goW10pO1xuICB9XG4gIGRhdGEuZm9yRWFjaCgoaW5uZXJEYXRhLCBkYXRhSWR4KSA9PiB7XG4gICAgaW5uZXJEYXRhLmZvckVhY2goKGl0ZW0sIGl0ZW1JZHgpID0+IHtcbiAgICAgIHJlc3VsdFtpdGVtSWR4XVtkYXRhSWR4XSA9IGl0ZW07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXN0aW1hdGVTdGFydGluZ0d1ZXNzKGJib3hlcywgcHJpbWFyeSkge1xuICBjb25zdCBuID0gYmJveGVzLmxlbmd0aDtcbiAgbGV0IHByaW1hcnlTdW0gPSAwO1xuICBmb3IgKGxldCBiYm94SW5kZXggPSAwOyBiYm94SW5kZXggPCBuOyBiYm94SW5kZXgrKykge1xuICAgIHByaW1hcnlTdW0gKz0gcHJpbWFyeS5mbihiYm94ZXNbYmJveEluZGV4XSkgKyBwcmltYXJ5LnBhZGRpbmc7XG4gICAgaWYgKHByaW1hcnlTdW0gPiBwcmltYXJ5Lm1heCkge1xuICAgICAgY29uc3QgcmF0aW8yID0gbiAvIGJib3hJbmRleDtcbiAgICAgIGlmIChyYXRpbzIgPCAyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobiAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3hJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2ltYWdlLnRzXG52YXIgSW1hZ2UgPSBjbGFzcyBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VJbWFnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2VJbWFnZSA9IHNvdXJjZUltYWdlO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgfVxuICB1cGRhdGVCaXRtYXAobmV3Qml0bWFwLCBiaXRtYXBQaXhlbFJhdGlvLCB4LCB5KSB7XG4gICAgdGhpcy5zb3VyY2VJbWFnZSA9IG5ld0JpdG1hcDtcbiAgICB0aGlzLndpZHRoID0gbmV3Qml0bWFwLndpZHRoIC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLmhlaWdodCA9IG5ld0JpdG1hcC5oZWlnaHQgLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMueCA9IHggLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMueSA9IHkgLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIDMgLyogTUFKT1IgKi8pO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkKys7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltYWdlID0gdGhpcy5zb3VyY2VJbWFnZTtcbiAgICBpZiAoIWltYWdlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmRNYXJrZXJMYWJlbC50c1xudmFyIExlZ2VuZE1hcmtlckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBHcm91cCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgbmFtZTogXCJtYXJrZXJMYWJlbEdyb3VwXCIgfSk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogXCJsZWdlbmQtbWFya2VyTGFiZWwtc3ltYm9sc1wiXG4gICAgfSk7XG4gICAgdGhpcy5iaXRtYXAgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLmJpdG1hcERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucGFnZUluZGV4ID0gTmFOO1xuICAgIHRoaXMuX21hcmtlcnMgPSBbXTtcbiAgICB0aGlzLl9saW5lcyA9IFtdO1xuICAgIGNvbnN0IHsgbWFya2VycywgbGFiZWwsIGxpbmVzIH0gPSB0aGlzO1xuICAgIGxhYmVsLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgbGFiZWwuZm9udFNpemUgPSAxMjtcbiAgICBsYWJlbC5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgbGFiZWwuZmlsbCA9IFwiYmxhY2tcIjtcbiAgICBsYWJlbC55ID0gMTtcbiAgICB0aGlzLnVwZGF0ZVN5bWJvbHMobWFya2VycywgbGluZXMpO1xuICAgIHRoaXMuYXBwZW5kKGFyZ3NJdGVyYWJsZSh0aGlzLnN5bWJvbHNHcm91cCwgbGFiZWwpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnByb3h5QnV0dG9uPy5yZW1vdmUoKTtcbiAgfVxuICBnZXQgbWFya2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya2VycztcbiAgfVxuICBnZXQgbGluZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVzO1xuICB9XG4gIHVwZGF0ZVN5bWJvbHMobWFya2VycywgbGluZXMpIHtcbiAgICBpZiAoYXJyYXlzRXF1YWwodGhpcy5fbWFya2VycywgbWFya2VycykgJiYgYXJyYXlzRXF1YWwodGhpcy5fbGluZXMsIGxpbmVzKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJpdG1hcERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLl9saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMuc3ltYm9sc0dyb3VwLmNsZWFyKCk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAuYXBwZW5kKFt0aGlzLmJpdG1hcCwgLi4ubWFya2VycywgLi4ubGluZXNdKTtcbiAgfVxuICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMucmVmcmVzaFZpc2liaWxpdGllcygpO1xuICB9XG4gIHJlZnJlc2hWaXNpYmlsaXRpZXMoKSB7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuZW5hYmxlZCA/IDEgOiAwLjU7XG4gICAgdGhpcy5sYWJlbC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMuYml0bWFwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMuc2V0Qml0bWFwVmlzaWJpbGl0eSghdGhpcy5lbmFibGVkKTtcbiAgfVxuICBzZXRCaXRtYXBWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICBjb25zdCB7IGxpbmVzLCBtYXJrZXJzIH0gPSB0aGlzO1xuICAgIFtsaW5lcywgbWFya2Vyc10uZm9yRWFjaCgoc2hhcGVzKSA9PiBzaGFwZXMuZm9yRWFjaCgoc2hhcGUpID0+IHNoYXBlLnZpc2libGUgPSAhdmlzaWJsZSkpO1xuICAgIHRoaXMuYml0bWFwLnZpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIC8vIFRoZSBCQm94IG9mIHRoaXMuYml0bWFwIGlzIGBzcHJpdGVQYWRkaW5nYCBwaXhlbHMgYmlnZ2VyIGluIGVhY2ggZGlyZWN0aW9uIHRoYW4gQkJveCBvZiB0aGUgbWFya2VycyBhbmQgbGluZXMuXG4gIC8vIFRoaXMgcGFkZGluZyBhbGxvd3MgdGhlIFNwcml0ZVJlbmRlcmVyIHRvIGRyYXcgYW50aWFsaWFzaW5nIHBpeGVscyB0aGF0IGNhbiBleHRlbmQgYmV5b25kIHRoZSBzaGFwZXMnIGJvdW5kcy5cbiAgdXBkYXRlKHNwcml0ZVJlbmRlcmVyLCB7IHNwcml0ZUFBUGFkZGluZywgc3ByaXRlUGl4ZWxSYXRpbzogc2NhbGUyIH0sIGRpbWVuc2lvblByb3BzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJzLCBsaW5lcyB9ID0gdGhpcztcbiAgICBsZXQgc3ByaXRlWCA9IDA7XG4gICAgbGV0IHNwcml0ZVkgPSAwO1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChtYXJrZXJzLmxlbmd0aCwgbGluZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCB7IGxlbmd0aDogbGVuZ3RoMiwgc3BhY2luZyB9ID0gZGltZW5zaW9uUHJvcHNbaV0gPz8gMDtcbiAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlcnNbaV07XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBjb25zdCBzaXplID0gbWFya2VyPy5zaXplID8/IDA7XG4gICAgICBsZXQgbGluZVRvcCA9IEluZmluaXR5O1xuICAgICAgbGV0IG1hcmtlclRvcCA9IEluZmluaXR5O1xuICAgICAgbGV0IG1hcmtlckxlZnQgPSBJbmZpbml0eTtcbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gbWFya2VyLmNvbnN0cnVjdG9yLmNlbnRlcjtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gKHNpemUgKyBtYXJrZXIuc3Ryb2tlV2lkdGgpIC8gMjtcbiAgICAgICAgbWFya2VyLnggPSAoY2VudGVyLnggLSAwLjUpICogc2l6ZSArIGxlbmd0aDIgLyAyICsgc2hpZnQ7XG4gICAgICAgIG1hcmtlci55ID0gKGNlbnRlci55IC0gMC41KSAqIHNpemU7XG4gICAgICAgIG1hcmtlclRvcCA9IG1hcmtlci55IC0gcmFkaXVzO1xuICAgICAgICBtYXJrZXJMZWZ0ID0gbWFya2VyLnggLSByYWRpdXM7XG4gICAgICB9XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICBsaW5lLngxID0gc2hpZnQ7XG4gICAgICAgIGxpbmUueDIgPSBzaGlmdCArIGxlbmd0aDI7XG4gICAgICAgIGxpbmUueTEgPSAwO1xuICAgICAgICBsaW5lLnkyID0gMDtcbiAgICAgICAgbGluZS5tYXJrRGlydHlUcmFuc2Zvcm0oKTtcbiAgICAgICAgbGluZVRvcCA9IC1saW5lLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIHNoaWZ0ICs9IHNwYWNpbmcgKyBNYXRoLm1heChsZW5ndGgyLCBzaXplKTtcbiAgICAgIHNwcml0ZVggPSBNYXRoLm1pbihzcHJpdGVYLCBsaW5lLngxLCBsaW5lLngyLCBtYXJrZXJMZWZ0KTtcbiAgICAgIHNwcml0ZVkgPSBNYXRoLm1pbihzcHJpdGVZLCBsaW5lVG9wLCBtYXJrZXJUb3ApO1xuICAgIH1cbiAgICBjb25zdCBsYXN0U3ltYm9sUHJvcHMgPSBkaW1lbnNpb25Qcm9wcy5hdCgtMSk7XG4gICAgY29uc3QgbGFzdExpbmUgPSB0aGlzLmxpbmVzLmF0KC0xKTtcbiAgICBjb25zdCBsYXN0TWFya2VyID0gdGhpcy5tYXJrZXJzLmF0KC0xKTtcbiAgICBjb25zdCBsaW5lRW5kID0gbGFzdExpbmUgPyBsYXN0TGluZS54MiA6IC1JbmZpbml0eTtcbiAgICBjb25zdCBtYXJrZXJFbmQgPSAobGFzdE1hcmtlcj8ueCA/PyAwKSArIChsYXN0TWFya2VyPy5zaXplID8/IDApIC8gMjtcbiAgICB0aGlzLmxhYmVsLnggPSBNYXRoLm1heChsaW5lRW5kLCBtYXJrZXJFbmQpICsgKGxhc3RTeW1ib2xQcm9wcz8uc3BhY2luZyA/PyAwKTtcbiAgICBpZiAodGhpcy5iaXRtYXBEaXJ0eSkge1xuICAgICAgdGhpcy5zZXRCaXRtYXBWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVggPSAoc3ByaXRlQUFQYWRkaW5nICsgc3ByaXRlWCkgKiBzY2FsZTI7XG4gICAgICBjb25zdCB0cmFuc2xhdGVZID0gKHNwcml0ZUFBUGFkZGluZyAtIHNwcml0ZVkpICogc2NhbGUyO1xuICAgICAgY29uc3Qgc3ByaXRlID0gc3ByaXRlUmVuZGVyZXIucmVuZGVyU3ByaXRlKHRoaXMuc3ltYm9sc0dyb3VwLCB7XG4gICAgICAgIHNjYWxlOiBzY2FsZTIsXG4gICAgICAgIHRyYW5zbGF0ZVg6IE1hdGguZmxvb3IodHJhbnNsYXRlWCksXG4gICAgICAgIHRyYW5zbGF0ZVk6IE1hdGguZmxvb3IodHJhbnNsYXRlWSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaXRtYXAudXBkYXRlQml0bWFwKHNwcml0ZSwgc2NhbGUyLCBNYXRoLmNlaWwoLXRyYW5zbGF0ZVgpLCBNYXRoLmNlaWwoLXRyYW5zbGF0ZVkpKTtcbiAgICAgIHRoaXMuYml0bWFwRGlydHkgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVmcmVzaFZpc2liaWxpdGllcygpO1xuICAgIH1cbiAgICBpZiAoZGltZW5zaW9uUHJvcHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy5zeW1ib2xzR3JvdXAuZ2V0QkJveCgpO1xuICAgIGNvbnN0IGNsaXBwZWRXaWR0aCA9IE1hdGgubWF4KGxhc3RNYXJrZXI/LnNpemUgPz8gMCwgbGFzdFN5bWJvbFByb3BzPy5sZW5ndGggPz8gMCk7XG4gICAgY29uc3QgY2xpcFJlY3QgPSBuZXcgQkJveChiYm94LnggKyBjbGlwcGVkV2lkdGggLyAyLCBiYm94LnksIGNsaXBwZWRXaWR0aCwgYmJveC5oZWlnaHQpO1xuICAgIHRoaXMuc3ltYm9sc0dyb3VwLnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShjbGlwUmVjdCk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgbGluZXMsIG1hcmtlcnMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIEdyb3VwLmNvbXB1dGVCQm94KGFycmF5c0l0ZXJhYmxlKFtsYWJlbF0sIGxpbmVzLCBtYXJrZXJzKSwgeyBza2lwSW52aXNpYmxlOiBmYWxzZSB9KTtcbiAgfVxufTtcbkxlZ2VuZE1hcmtlckxhYmVsLmNsYXNzTmFtZSA9IFwiTWFya2VyTGFiZWxcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIsIFwiZmlsbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9wYWdpbmF0aW9uL3BhZ2luYXRpb24udHNcbnZhciBQYWdpbmF0aW9uTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yID0gXCJibGFja1wiO1xuICAgIHRoaXMuZm9udFN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbnZhciBQYWdpbmF0aW9uTWFya2VyU3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLmZpbGwgPSB2b2lkIDA7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cm9rZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG52YXIgUGFnaW5hdGlvbk1hcmtlciA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2hhcGUgPSBUcmlhbmdsZTtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLnBhZGRpbmcgPSA4O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50Lm1hcmtlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLnBhcmVudC5vbk1hcmtlclNoYXBlQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbnZhciBQYWdpbmF0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0VXBkYXRlQ2FsbGJhY2ssIHBhZ2VVcGRhdGVDYWxsYmFjaywgcmVnaW9uTWFuYWdlciwgY3Vyc29yTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrID0gY2hhcnRVcGRhdGVDYWxsYmFjaztcbiAgICB0aGlzLnBhZ2VVcGRhdGVDYWxsYmFjayA9IHBhZ2VVcGRhdGVDYWxsYmFjaztcbiAgICB0aGlzLnJlZ2lvbk1hbmFnZXIgPSByZWdpb25NYW5hZ2VyO1xuICAgIHRoaXMuY3Vyc29yTWFuYWdlciA9IGN1cnNvck1hbmFnZXI7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubWFya2VyID0gbmV3IFBhZ2luYXRpb25NYXJrZXIodGhpcyk7XG4gICAgdGhpcy5hY3RpdmVTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmluYWN0aXZlU3R5bGUgPSBuZXcgUGFnaW5hdGlvbk1hcmtlclN0eWxlKCk7XG4gICAgdGhpcy5oaWdobGlnaHRTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IFBhZ2luYXRpb25MYWJlbCgpO1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInBhZ2luYXRpb25cIiB9KTtcbiAgICB0aGlzLmxhYmVsTm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy50b3RhbFBhZ2VzID0gMDtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIHRoaXMubmV4dEJ1dHRvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBcInZlcnRpY2FsXCI7XG4gICAgdGhpcy5fbmV4dEJ1dHRvbiA9IG5ldyBUcmlhbmdsZSgpO1xuICAgIHRoaXMuX3ByZXZpb3VzQnV0dG9uID0gbmV3IFRyaWFuZ2xlKCk7XG4gICAgdGhpcy5sYWJlbE5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBmb250RmFtaWx5OiBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIixcbiAgICAgIHk6IDFcbiAgICB9KTtcbiAgICB0aGlzLmdyb3VwLmFwcGVuZChbdGhpcy5uZXh0QnV0dG9uLCB0aGlzLnByZXZpb3VzQnV0dG9uLCB0aGlzLmxhYmVsTm9kZV0pO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJwYWdpbmF0aW9uXCIsIHRoaXMuZ3JvdXApO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uUGFnaW5hdGlvbkNsaWNrKGV2ZW50KSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25QYWdpbmF0aW9uTW91c2VNb3ZlKGV2ZW50KSlcbiAgICApO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIHNldCBlbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGU7XG4gIH1cbiAgc2V0IG9yaWVudGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSB2YWx1ZTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24ucm90YXRpb24gPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIHRoaXMubmV4dEJ1dHRvbi5yb3RhdGlvbiA9IE1hdGguUEkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uLnJvdGF0aW9uID0gTWF0aC5QSTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgfVxuICBzZXQgbmV4dEJ1dHRvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9uZXh0QnV0dG9uICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVDaGlsZCh0aGlzLl9uZXh0QnV0dG9uKTtcbiAgICAgIHRoaXMuX25leHRCdXR0b24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZ3JvdXAuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXQgbmV4dEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dEJ1dHRvbjtcbiAgfVxuICBzZXQgcHJldmlvdXNCdXR0b24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fcHJldmlvdXNCdXR0b24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUNoaWxkKHRoaXMuX3ByZXZpb3VzQnV0dG9uKTtcbiAgICAgIHRoaXMuX3ByZXZpb3VzQnV0dG9uID0gdmFsdWU7XG4gICAgICB0aGlzLmdyb3VwLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByZXZpb3VzQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0J1dHRvbjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XG4gICAgdGhpcy5lbmFibGVPckRpc2FibGVCdXR0b25zKCk7XG4gIH1cbiAgdXBkYXRlUG9zaXRpb25zKCkge1xuICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpO1xuICB9XG4gIHVwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBzaXplOiBtYXJrZXJTaXplLCBwYWRkaW5nOiBtYXJrZXJQYWRkaW5nIH0gPSB0aGlzLm1hcmtlcjtcbiAgICB0aGlzLm5leHRCdXR0b24uc2l6ZSA9IG1hcmtlclNpemU7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbi5zaXplID0gbWFya2VyU2l6ZTtcbiAgICB0aGlzLmxhYmVsTm9kZS54ID0gbWFya2VyU2l6ZSAvIDIgKyBtYXJrZXJQYWRkaW5nO1xuICB9XG4gIHVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBsYWJlbEJCb3ggPSB0aGlzLmxhYmVsTm9kZS5nZXRCQm94KCk7XG4gICAgdGhpcy5uZXh0QnV0dG9uLnRyYW5zbGF0aW9uWCA9IGxhYmVsQkJveC54ICsgbGFiZWxCQm94LndpZHRoICsgdGhpcy5tYXJrZXIuc2l6ZSAvIDIgKyB0aGlzLm1hcmtlci5wYWRkaW5nO1xuICB9XG4gIHVwZGF0ZUxhYmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRQYWdlLFxuICAgICAgdG90YWxQYWdlczogcGFnZXMsXG4gICAgICBsYWJlbE5vZGUsXG4gICAgICBsYWJlbDogeyBjb2xvciwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGFiZWxOb2RlLnRleHQgPSBgJHtjdXJyZW50UGFnZSArIDF9IC8gJHtwYWdlc31gO1xuICAgIGxhYmVsTm9kZS5maWxsID0gY29sb3I7XG4gICAgbGFiZWxOb2RlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICBsYWJlbE5vZGUuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgbGFiZWxOb2RlLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgbGFiZWxOb2RlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICB9XG4gIHVwZGF0ZU1hcmtlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dEJ1dHRvbixcbiAgICAgIHByZXZpb3VzQnV0dG9uLFxuICAgICAgbmV4dEJ1dHRvbkRpc2FibGVkLFxuICAgICAgcHJldmlvdXNCdXR0b25EaXNhYmxlZCxcbiAgICAgIGFjdGl2ZVN0eWxlLFxuICAgICAgaW5hY3RpdmVTdHlsZSxcbiAgICAgIGhpZ2hsaWdodFN0eWxlLFxuICAgICAgaGlnaGxpZ2h0QWN0aXZlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYnV0dG9uU3R5bGUgPSAoYnV0dG9uLCBkaXNhYmxlZCkgPT4ge1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBpbmFjdGl2ZVN0eWxlO1xuICAgICAgfSBlbHNlIGlmIChidXR0b24gPT09IGhpZ2hsaWdodEFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0U3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aXZlU3R5bGU7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcihuZXh0QnV0dG9uLCBidXR0b25TdHlsZShcIm5leHRcIiwgbmV4dEJ1dHRvbkRpc2FibGVkKSk7XG4gICAgdGhpcy51cGRhdGVNYXJrZXIocHJldmlvdXNCdXR0b24sIGJ1dHRvblN0eWxlKFwicHJldmlvdXNcIiwgcHJldmlvdXNCdXR0b25EaXNhYmxlZCkpO1xuICB9XG4gIHVwZGF0ZU1hcmtlcihtYXJrZXIsIHN0eWxlKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSB0aGlzLm1hcmtlcjtcbiAgICBtYXJrZXIuc2l6ZSA9IHNpemU7XG4gICAgbWFya2VyLmZpbGwgPSBzdHlsZS5maWxsO1xuICAgIG1hcmtlci5maWxsT3BhY2l0eSA9IHN0eWxlLmZpbGxPcGFjaXR5ID8/IDE7XG4gICAgbWFya2VyLnN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICBtYXJrZXIuc3Ryb2tlV2lkdGggPSBzdHlsZS5zdHJva2VXaWR0aDtcbiAgICBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA9IHN0eWxlLnN0cm9rZU9wYWNpdHk7XG4gIH1cbiAgZW5hYmxlT3JEaXNhYmxlQnV0dG9ucygpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRQYWdlLCB0b3RhbFBhZ2VzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHplcm9QYWdlc1RvRGlzcGxheSA9IHRvdGFsUGFnZXMgPT09IDA7XG4gICAgY29uc3Qgb25MYXN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSB0b3RhbFBhZ2VzIC0gMTtcbiAgICBjb25zdCBvbkZpcnN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSAwO1xuICAgIHRoaXMubmV4dEJ1dHRvbkRpc2FibGVkID0gb25MYXN0UGFnZSB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXk7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkID0gb25GaXJzdFBhZ2UgfHwgemVyb1BhZ2VzVG9EaXNwbGF5O1xuICB9XG4gIG5leHRCdXR0b25Db250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICByZXR1cm4gIXRoaXMubmV4dEJ1dHRvbkRpc2FibGVkICYmIHRoaXMubmV4dEJ1dHRvbi5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpO1xuICB9XG4gIHByZXZpb3VzQnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgcmV0dXJuICF0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgJiYgdGhpcy5wcmV2aW91c0J1dHRvbi5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpO1xuICB9XG4gIGNsaWNrTmV4dCgpIHtcbiAgICB0aGlzLmluY3JlbWVudFBhZ2UoKTtcbiAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgfVxuICBjbGlja1ByZXZpb3VzKCkge1xuICAgIHRoaXMuZGVjcmVtZW50UGFnZSgpO1xuICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xuICB9XG4gIHNldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHBhZ2VOdW1iZXIgPSBjbGFtcCgwLCBwYWdlTnVtYmVyLCB0aGlzLnRvdGFsUGFnZXMgLSAxKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGFnZSAhPT0gcGFnZU51bWJlcikge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2VOdW1iZXI7XG4gICAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgb25QYWdpbmF0aW9uQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRoaXMubmV4dEJ1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY2xpY2tOZXh0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzQnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jbGlja1ByZXZpb3VzKCk7XG4gICAgfVxuICB9XG4gIG9uUGFnaW5hdGlvbk1vdXNlTW92ZShldmVudCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgaWYgKHRoaXMubmV4dEJ1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgICAgdGhpcy5oaWdobGlnaHRBY3RpdmUgPSBcIm5leHRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXNCdXR0b25Db250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsIFwicG9pbnRlclwiKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gXCJwcmV2aW91c1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICAgICAgdGhpcy5oaWdobGlnaHRBY3RpdmUgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTWFya2VycygpO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVDYWxsYmFjayg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gIH1cbiAgb25QYWdpbmF0aW9uQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnBhZ2VVcGRhdGVDYWxsYmFjayh0aGlzLmN1cnJlbnRQYWdlKTtcbiAgfVxuICBpbmNyZW1lbnRQYWdlKCkge1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBNYXRoLm1pbih0aGlzLmN1cnJlbnRQYWdlICsgMSwgdGhpcy50b3RhbFBhZ2VzIC0gMSk7XG4gIH1cbiAgZGVjcmVtZW50UGFnZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gTWF0aC5tYXgodGhpcy5jdXJyZW50UGFnZSAtIDEsIDApO1xuICB9XG4gIG9uTWFya2VyU2hhcGVDaGFuZ2UoKSB7XG4gICAgY29uc3QgTWFya2VyMiA9IGdldE1hcmtlcih0aGlzLm1hcmtlci5zaGFwZSB8fCBUcmlhbmdsZSk7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbiA9IG5ldyBNYXJrZXIyKCk7XG4gICAgdGhpcy5uZXh0QnV0dG9uID0gbmV3IE1hcmtlcjIoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucygpO1xuICAgIHRoaXMudXBkYXRlTWFya2VycygpO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVDYWxsYmFjayg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gIH1cbiAgYXR0YWNoUGFnaW5hdGlvbihub2RlKSB7XG4gICAgbm9kZS5hcHBlbmQodGhpcy5ncm91cCk7XG4gIH1cbiAgZ2V0QkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cC5nZXRCQm94KHRydWUpO1xuICB9XG4gIGNvbXB1dGVDU1NCb3VuZHMoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX3ByZXZpb3VzQnV0dG9uLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5fbmV4dEJ1dHRvbi5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgcmV0dXJuIHsgcHJldiwgbmV4dCB9O1xuICB9XG59O1xuUGFnaW5hdGlvbi5jbGFzc05hbWUgPSBcIlBhZ2luYXRpb25cIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImFjdGl2ZVN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwiaW5hY3RpdmVTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImhpZ2hsaWdodFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xlZ2VuZC50c1xudmFyIExlZ2VuZExhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tYXhMZW5ndGggPSB2b2lkIDA7XG4gICAgdGhpcy5jb2xvciA9IFwiYmxhY2tcIjtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEyO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwibWF4TGVuZ3RoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG52YXIgTGVnZW5kTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaXplID0gMTU7XG4gICAgdGhpcy5wYWRkaW5nID0gODtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC5wYXJlbnQ/Lm9uTWFya2VyU2hhcGVDaGFuZ2UoKSlcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIExlZ2VuZExpbmUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaW5lLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwgMik7XG52YXIgTGVnZW5kSXRlbSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGFkZGluZ1ggPSAxNjtcbiAgICB0aGlzLnBhZGRpbmdZID0gODtcbiAgICB0aGlzLnNob3dTZXJpZXNTdHJva2UgPSBmYWxzZTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBMZWdlbmRNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExlZ2VuZExhYmVsKCk7XG4gICAgdGhpcy5saW5lID0gbmV3IExlZ2VuZExpbmUoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJwYWRkaW5nWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcInBhZGRpbmdZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcInNob3dTZXJpZXNTdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcImxpbmVcIiwgMik7XG52YXIgTGVnZW5kTGlzdGVuZXJzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExpc3RlbmVycy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUNsaWNrXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExpc3RlbmVycy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbURvdWJsZUNsaWNrXCIsIDIpO1xudmFyIElEX0xFR0VORF9WSVNJQklMSVRZID0gXCJsZWdlbmQtdmlzaWJpbGl0eVwiO1xudmFyIElEX0xFR0VORF9PVEhFUl9TRVJJRVMgPSBcImxlZ2VuZC1vdGhlci1zZXJpZXNcIjtcbnZhciBMZWdlbmQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwibGVnZW5kXCIsIGxheWVyOiB0cnVlLCB6SW5kZXg6IDEzIC8qIExFR0VORF9aSU5ERVggKi8gfSk7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuZ3JvdXAsXG4gICAgICBMZWdlbmRNYXJrZXJMYWJlbFxuICAgICk7XG4gICAgdGhpcy5zcHJpdGVSZW5kZXJlciA9IG5ldyBTcHJpdGVSZW5kZXJlcigpO1xuICAgIHRoaXMub2xkU2l6ZSA9IFswLCAwXTtcbiAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgdGhpcy5tYXhQYWdlU2l6ZSA9IFswLCAwXTtcbiAgICAvKiogSXRlbSBpbmRleCB0byB0cmFjayBvbiByZS1wYWdpbmF0aW9uLCBzbyBjdXJyZW50IHBhZ2UgdXBkYXRlcyBhcHByb3ByaWF0ZWx5LiAqL1xuICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSAwO1xuICAgIHRoaXMudHJ1bmNhdGVkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB0aGlzLnRvZ2dsZVNlcmllcyA9IHRydWU7XG4gICAgdGhpcy5pdGVtID0gbmV3IExlZ2VuZEl0ZW0oKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMZWdlbmRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucG9zaXRpb24gPSBcImJvdHRvbVwiO1xuICAgIHRoaXMuc3BhY2luZyA9IDIwO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuc2l6ZSA9IFswLCAwXTtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLml0ZW0ubWFya2VyLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5wYWdpbmF0aW9uID0gbmV3IFBhZ2luYXRpb24oXG4gICAgICAodHlwZSkgPT4gY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKHR5cGUpLFxuICAgICAgKHBhZ2UpID0+IHRoaXMudXBkYXRlUGFnZU51bWJlcihwYWdlKSxcbiAgICAgIGN0eC5yZWdpb25NYW5hZ2VyLFxuICAgICAgY3R4LmN1cnNvck1hbmFnZXJcbiAgICApO1xuICAgIHRoaXMucGFnaW5hdGlvbi5hdHRhY2hQYWdpbmF0aW9uKHRoaXMuZ3JvdXApO1xuICAgIGN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LnJlZ2lzdGVyRGVmYXVsdEFjdGlvbih7XG4gICAgICBpZDogSURfTEVHRU5EX1ZJU0lCSUxJVFksXG4gICAgICB0eXBlOiBcImxlZ2VuZFwiLFxuICAgICAgbGFiZWw6IFwiY29udGV4dE1lbnVUb2dnbGVTZXJpZXNWaXNpYmlsaXR5XCIsXG4gICAgICBhY3Rpb246IChwYXJhbXMpID0+IHRoaXMuY29udGV4dFRvZ2dsZVZpc2liaWxpdHkocGFyYW1zKVxuICAgIH0pO1xuICAgIGN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LnJlZ2lzdGVyRGVmYXVsdEFjdGlvbih7XG4gICAgICBpZDogSURfTEVHRU5EX09USEVSX1NFUklFUyxcbiAgICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgICBsYWJlbDogXCJjb250ZXh0TWVudVRvZ2dsZU90aGVyU2VyaWVzXCIsXG4gICAgICBhY3Rpb246IChwYXJhbXMpID0+IHRoaXMuY29udGV4dFRvZ2dsZU90aGVyU2VyaWVzKHBhcmFtcylcbiAgICB9KTtcbiAgICBjb25zdCB7IERlZmF1bHQ6IERlZmF1bHQyLCBBbmltYXRpb246IEFuaW1hdGlvbjIsIENvbnRleHRNZW51IH0gPSBJbnRlcmFjdGlvblN0YXRlO1xuICAgIGNvbnN0IGFuaW1hdGlvblN0YXRlID0gRGVmYXVsdDIgfCBBbmltYXRpb24yO1xuICAgIGNvbnN0IGNvbnRleHRNZW51U3RhdGUgPSBEZWZhdWx0MiB8IEFuaW1hdGlvbjIgfCBDb250ZXh0TWVudTtcbiAgICBjb25zdCByZWdpb24gPSBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJsZWdlbmRcIiwgdGhpcy5ncm91cCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCAoZSkgPT4gdGhpcy5jaGVja0NvbnRleHRDbGljayhlKSwgY29udGV4dE1lbnVTdGF0ZSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4gdGhpcy5jaGVja0xlZ2VuZENsaWNrKGUpLCBhbmltYXRpb25TdGF0ZSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoZSkgPT4gdGhpcy5jaGVja0xlZ2VuZERvdWJsZUNsaWNrKGUpLCBhbmltYXRpb25TdGF0ZSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZSkgPT4gdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU1vdmUoZSksIGFuaW1hdGlvblN0YXRlKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMuaGFuZGxlTGVnZW5kTW91c2VFeGl0KCksIGFuaW1hdGlvblN0YXRlKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImVudGVyXCIsIChlKSA9PiB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlRW50ZXIoZSksIGFuaW1hdGlvblN0YXRlKSxcbiAgICAgIGN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwic3RhcnQtbGF5b3V0XCIsIChlKSA9PiB0aGlzLnBvc2l0aW9uTGVnZW5kKGUpKSxcbiAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgKCkgPT4gdGhpcy5vbkxvY2FsZUNoYW5nZWQoKSksXG4gICAgICAoKSA9PiB0aGlzLmdyb3VwLnBhcmVudD8ucmVtb3ZlQ2hpbGQodGhpcy5ncm91cClcbiAgICApO1xuICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJ0b29sYmFyXCIsXG4gICAgICBpZDogYCR7dGhpcy5pZH0tdG9vbGJhcmAsXG4gICAgICBjbGFzc0xpc3Q6IFtcImFnLWNoYXJ0cy1wcm94eS1sZWdlbmQtdG9vbGJhclwiXSxcbiAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRcIiB9LFxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgIGFyaWFIaWRkZW46IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5Q29udGFpbmVyKHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGlkOiBgJHt0aGlzLmlkfS1wYWdpbmF0aW9uYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LWxlZ2VuZC1wYWdpbmF0aW9uXCJdLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2luYXRpb25cIiB9LFxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgIGFyaWFIaWRkZW46IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGAke3RoaXMuaWR9LXRvb2xiYXJgKTtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYCR7dGhpcy5pZH0tcGFnaW5hdGlvbmApO1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5kZXN0cm95KCk7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFyKCk7XG4gIH1cbiAgaW5pdExlZ2VuZEl0ZW1Ub29sYmFyKCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgXywgaSkgPT4ge1xuICAgICAgbWFya2VyTGFiZWwucHJveHlCdXR0b24gPz8gKG1hcmtlckxhYmVsLnByb3h5QnV0dG9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgaWQ6IGBhZy1jaGFydHMtbGVnZW5kLWl0ZW0tJHtpfWAsXG4gICAgICAgIHRleHRDb250ZW50OiB0aGlzLmdldEl0ZW1BcmlhVGV4dChpKSxcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TGVnZW5kVG9vbGJhcixcbiAgICAgICAgZm9jdXNhYmxlOiBtYXJrZXJMYWJlbCxcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGRhdHVtIGZyb20gdGhlIG5vZGUgcmF0aGVyIHRoYW4gZnJvbSB0aGUgbWV0aG9kIHBhcmFtZXRlci5cbiAgICAgICAgLy8gVGhlIG1ldGhvZCBwYXJhbWV0ZXIgYGRhdHVtYCBnZXRzIGRlc3Ryb3llZCB3aGVuIHRoZSBkYXRhIGlzIHJlZnJlc2hlZFxuICAgICAgICAvLyB1c2luZyBTZXJpZXMuZ2V0TGVnZW5kRGF0YSgpLiBCdXQgdGhlIHNjZW5lIG5vZGUgd2lsbCBzdGF5IHRoZSBzYW1lLlxuICAgICAgICBvbmNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kb0NsaWNrKG1hcmtlckxhYmVsLmRhdHVtKTtcbiAgICAgICAgICBtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMuZ2V0SXRlbUFyaWFUZXh0KGksICFtYXJrZXJMYWJlbC5kYXR1bS5lbmFibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25ibHVyOiAoKSA9PiB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlRXhpdCgpLFxuICAgICAgICBvbmZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYm91bmRzID0gbWFya2VyTGFiZWw/LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgICAgICBjb25zdCBldmVudCA9IG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudCh0aGlzLmN0eC5mb2N1c0luZGljYXRvciwgeyBib3VuZHMsIHNob3dGb2N1c0JveDogdHJ1ZSB9KTtcbiAgICAgICAgICB0aGlzLmRvSG92ZXIoZXZlbnQsIG1hcmtlckxhYmVsLmRhdHVtKTtcbiAgICAgICAgICB0aGlzLnBhZ2luYXRpb24uc2V0UGFnZShtYXJrZXJMYWJlbC5wYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuaXRlbVNlbGVjdGlvbi5ub2RlcygpLm1hcCgobWFya2VyTGFiZWwpID0+IG1hcmtlckxhYmVsLnByb3h5QnV0dG9uKS5maWx0ZXIoKGJ1dHRvbikgPT4gISFidXR0b24pO1xuICAgIGluaXRUb29sYmFyS2V5TmF2KHtcbiAgICAgIG9yaWVudGF0aW9uOiB0aGlzLmdldE9yaWVudGF0aW9uKCksXG4gICAgICBidXR0b25zLFxuICAgICAgdG9vbGJhcjogdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXJcbiAgICB9KTtcbiAgfVxuICBvbk1hcmtlclNoYXBlQ2hhbmdlKCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5jbGVhcigpO1xuICAgIHRoaXMuZ3JvdXAubWFya0RpcnR5KHRoaXMuZ3JvdXAsIDIgLyogTUlOT1IgKi8pO1xuICB9XG4gIGdldE9yaWVudGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIHVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmVuYWJsZWQgJiYgdGhpcy52aXNpYmxlICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwO1xuICB9XG4gIGF0dGFjaExlZ2VuZChzY2VuZSkge1xuICAgIHNjZW5lLmFwcGVuZENoaWxkKHRoaXMuZ3JvdXApO1xuICB9XG4gIGdldEl0ZW1MYWJlbChkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gdGhpcy5pdGVtLmxhYmVsO1xuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB7XG4gICAgICAgIGl0ZW1JZDogZGF0dW0uaXRlbUlkLFxuICAgICAgICB2YWx1ZTogZGF0dW0ubGFiZWwudGV4dCxcbiAgICAgICAgc2VyaWVzSWQ6IGRhdHVtLnNlcmllc0lkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdHVtLmxhYmVsLnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgaXMgZ2l2ZW4gdGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgbGVnZW5kLCB3aGljaCBvbmx5IHNlcnZlcyBhcyBhIGhpbnQuXG4gICAqIFRoZSB2ZXJ0aWNhbGx5IG9yaWVudGVkIGxlZ2VuZCB3aWxsIHRha2UgYXMgbXVjaCBob3Jpem9udGFsIHNwYWNlIGFzIG5lZWRlZCwgYnV0IHdpbGxcbiAgICogcmVzcGVjdCB0aGUgaGVpZ2h0IGNvbnN0cmFpbnRzLCBhbmQgdGhlIGhvcml6b250YWwgbGVnZW5kIHdpbGwgdGFrZSBhcyBtdWNoIHZlcnRpY2FsXG4gICAqIHNwYWNlIGFzIG5lZWRlZCBpbiBhbiBhdHRlbXB0IG5vdCB0byBleGNlZWQgdGhlIGdpdmVuIHdpZHRoLlxuICAgKiBBZnRlciB0aGUgbGF5b3V0IGlzIGRvbmUsIHRoZSB7QGxpbmsgc2l6ZX0gd2lsbCBjb250YWluIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbGVnZW5kLlxuICAgKiBJZiB0aGUgYWN0dWFsIHNpemUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBhY3R1YWwgc2l6ZSwgdGhlIGxlZ2VuZCB3aWxsIGZpcmVcbiAgICogdGhlICdsYXlvdXRDaGFuZ2UnIGV2ZW50IHRvIGNvbW11bmljYXRlIHRoYXQgYW5vdGhlciBsYXlvdXQgaXMgbmVlZGVkLCBhbmQgdGhlIGFib3ZlXG4gICAqIHByb2Nlc3Mgc2hvdWxkIGJlIHJlcGVhdGVkLlxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodFxuICAgKi9cbiAgY2FsY0xheW91dCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFkZGluZ1gsXG4gICAgICBwYWRkaW5nWSxcbiAgICAgIGxhYmVsLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICBsYWJlbDogeyBtYXhMZW5ndGggPSBJbmZpbml0eSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9XG4gICAgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBkYXRhID0gWy4uLnRoaXMuZGF0YV07XG4gICAgaWYgKHRoaXMucmV2ZXJzZU9yZGVyKSB7XG4gICAgICBkYXRhLnJldmVyc2UoKTtcbiAgICB9XG4gICAgY29uc3QgcHJveHlUb29sYmFyTmVlZHNVcGRhdGUgPSB0aGlzLml0ZW1TZWxlY3Rpb24ubm9kZXMoKS5sZW5ndGggPT09IDA7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLnVwZGF0ZShkYXRhKTtcbiAgICBpZiAocHJveHlUb29sYmFyTmVlZHNVcGRhdGUpIHtcbiAgICAgIHRoaXMuaW5pdExlZ2VuZEl0ZW1Ub29sYmFyKCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3hlcyA9IFtdO1xuICAgIGNvbnN0IGZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKGxhYmVsKTtcbiAgICBjb25zdCBpdGVtTWF4V2lkdGhQZXJjZW50YWdlID0gMC44O1xuICAgIGNvbnN0IG1heEl0ZW1XaWR0aCA9IG1heFdpZHRoID8/IHdpZHRoICogaXRlbU1heFdpZHRoUGVyY2VudGFnZTtcbiAgICBjb25zdCBzcHJpdGVEaW1zID0gdGhpcy5jYWxjdWxhdGVTcHJpdGVEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zcHJpdGVSZW5kZXJlci5yZXNpemUoc3ByaXRlRGltcyk7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBkYXR1bSkgPT4ge1xuICAgICAgbWFya2VyTGFiZWwuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgbWFya2VyTGFiZWwuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICBtYXJrZXJMYWJlbC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgbWFya2VyTGFiZWwuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICBjb25zdCBwYWRkZWRTeW1ib2xXaWR0aCA9IHRoaXMudXBkYXRlTWFya2VyTGFiZWwobWFya2VyTGFiZWwsIGRhdHVtLCBzcHJpdGVEaW1zKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0dW0uaXRlbUlkID8/IGRhdHVtLmlkO1xuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pO1xuICAgICAgY29uc3QgdGV4dCA9IChsYWJlbFRleHQgPz8gXCI8dW5rbm93bj5cIikucmVwbGFjZSgvXFxyP1xcbi9nLCBcIiBcIik7XG4gICAgICBtYXJrZXJMYWJlbC50ZXh0ID0gdGhpcy50cnVuY2F0ZSh0ZXh0LCBtYXhMZW5ndGgsIG1heEl0ZW1XaWR0aCwgcGFkZGVkU3ltYm9sV2lkdGgsIGZvbnQsIGlkKTtcbiAgICAgIGJib3hlcy5wdXNoKG1hcmtlckxhYmVsLmdldEJCb3goKSk7XG4gICAgfSk7XG4gICAgd2lkdGggPSBNYXRoLm1heCgxLCB3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgaGVpZ2h0KTtcbiAgICBpZiAoIWlzRmluaXRlKHdpZHRoKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLm9sZFNpemU7XG4gICAgc2l6ZVswXSA9IHdpZHRoO1xuICAgIHNpemVbMV0gPSBoZWlnaHQ7XG4gICAgaWYgKHNpemVbMF0gIT09IG9sZFNpemVbMF0gfHwgc2l6ZVsxXSAhPT0gb2xkU2l6ZVsxXSkge1xuICAgICAgb2xkU2l6ZVswXSA9IHNpemVbMF07XG4gICAgICBvbGRTaXplWzFdID0gc2l6ZVsxXTtcbiAgICB9XG4gICAgY29uc3QgeyBwYWdlcywgbWF4UGFnZUhlaWdodCwgbWF4UGFnZVdpZHRoIH0gPSB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBvbGRQYWdlcyA9IHRoaXMucGFnZXM7XG4gICAgdGhpcy5wYWdlcyA9IHBhZ2VzO1xuICAgIHRoaXMubWF4UGFnZVNpemUgPSBbbWF4UGFnZVdpZHRoIC0gcGFkZGluZ1gsIG1heFBhZ2VIZWlnaHQgLSBwYWRkaW5nWV07XG4gICAgY29uc3QgcGFnZU51bWJlciA9IHRoaXMucGFnaW5hdGlvbi5jdXJyZW50UGFnZTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1twYWdlTnVtYmVyXTtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPCAxIHx8ICFwYWdlKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB7IG9sZFBhZ2VzIH07XG4gICAgfVxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMocGFnZU51bWJlcik7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICByZXR1cm4geyBvbGRQYWdlcyB9O1xuICB9XG4gIGNhbGNTeW1ib2xzRW5hYmxlZChzeW1ib2wpIHtcbiAgICBjb25zdCB7IHNob3dTZXJpZXNTdHJva2UsIG1hcmtlciB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IG1hcmtlckVuYWJsZWQgPSAhIW1hcmtlci5lbmFibGVkIHx8ICFzaG93U2VyaWVzU3Ryb2tlIHx8IChzeW1ib2wubWFya2VyLmVuYWJsZWQgPz8gdHJ1ZSk7XG4gICAgY29uc3QgbGluZUVuYWJsZWQgPSAhIShzeW1ib2wubGluZSAmJiBzaG93U2VyaWVzU3Ryb2tlKTtcbiAgICByZXR1cm4geyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCB9O1xuICB9XG4gIGNhbGNTeW1ib2xzTGVuZ3RocyhzeW1ib2wpIHtcbiAgICBjb25zdCB7IG1hcmtlciwgbGluZSB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IHsgbWFya2VyRW5hYmxlZCwgbGluZUVuYWJsZWQgfSA9IHRoaXMuY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCk7XG4gICAgY29uc3QgeyBzdHJva2VXaWR0aDogbWFya2VyU3Ryb2tlV2lkdGggfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGVzKHN5bWJvbCk7XG4gICAgY29uc3QgeyBzdHJva2VXaWR0aDogbGluZVN0cm9rZVdpZHRoIH0gPSBsaW5lRW5hYmxlZCA/IHRoaXMuZ2V0TGluZVN0eWxlcyhzeW1ib2wpIDogeyBzdHJva2VXaWR0aDogMCB9O1xuICAgIGNvbnN0IG1hcmtlckxlbmd0aCA9IG1hcmtlckVuYWJsZWQgPyBtYXJrZXIuc2l6ZSA6IDA7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVFbmFibGVkID8gbGluZS5sZW5ndGggPz8gMjUgOiAwO1xuICAgIHJldHVybiB7IG1hcmtlckxlbmd0aCwgbWFya2VyU3Ryb2tlV2lkdGgsIGxpbmVMZW5ndGgsIGxpbmVTdHJva2VXaWR0aCB9O1xuICB9XG4gIGNhbGN1bGF0ZVNwcml0ZURpbWVuc2lvbnMoKSB7XG4gICAgbGV0IHNwcml0ZUFBUGFkZGluZyA9IDA7XG4gICAgbGV0IHNwcml0ZVdpZHRoID0gMDtcbiAgICBsZXQgc3ByaXRlSGVpZ2h0ID0gMDtcbiAgICBsZXQgbWFya2VyV2lkdGggPSAwO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChfLCBkYXR1bSkgPT4ge1xuICAgICAgZGF0dW0uc3ltYm9scy5mb3JFYWNoKChzeW1ib2wpID0+IHtcbiAgICAgICAgY29uc3QgeyBtYXJrZXJMZW5ndGgsIG1hcmtlclN0cm9rZVdpZHRoLCBsaW5lTGVuZ3RoLCBsaW5lU3Ryb2tlV2lkdGggfSA9IHRoaXMuY2FsY1N5bWJvbHNMZW5ndGhzKHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IG1hcmtlclRvdGFsTGVuZ3RoID0gbWFya2VyTGVuZ3RoICsgbWFya2VyU3Ryb2tlV2lkdGg7XG4gICAgICAgIG1hcmtlcldpZHRoID0gTWF0aC5tYXgobWFya2VyV2lkdGgsIGxpbmVMZW5ndGgsIG1hcmtlckxlbmd0aCk7XG4gICAgICAgIHNwcml0ZVdpZHRoID0gTWF0aC5tYXgoc3ByaXRlV2lkdGgsIGxpbmVMZW5ndGgsIG1hcmtlclRvdGFsTGVuZ3RoKTtcbiAgICAgICAgc3ByaXRlSGVpZ2h0ID0gTWF0aC5tYXgoc3ByaXRlSGVpZ2h0LCBsaW5lU3Ryb2tlV2lkdGgsIG1hcmtlclRvdGFsTGVuZ3RoKTtcbiAgICAgICAgc3ByaXRlQUFQYWRkaW5nID0gTWF0aC5tYXgoc3ByaXRlQUFQYWRkaW5nLCBtYXJrZXJTdHJva2VXaWR0aCArIDAuNSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzcHJpdGVXaWR0aCArPSBzcHJpdGVBQVBhZGRpbmcgKiAyO1xuICAgIHNwcml0ZUhlaWdodCArPSBzcHJpdGVBQVBhZGRpbmcgKiAyO1xuICAgIGNvbnN0IHNwcml0ZVBpeGVsUmF0aW8gPSBnZXRXaW5kb3coKS5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHJldHVybiB7IHNwcml0ZVBpeGVsUmF0aW8sIHNwcml0ZUFBUGFkZGluZywgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCwgbWFya2VyV2lkdGggfTtcbiAgfVxuICB1cGRhdGVNYXJrZXJMYWJlbChtYXJrZXJMYWJlbCwgZGF0dW0sIHNwcml0ZURpbXMpIHtcbiAgICBjb25zdCB7IG1hcmtlcjogaXRlbU1hcmtlciwgcGFkZGluZ1ggfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCB7IG1hcmtlcldpZHRoIH0gPSBzcHJpdGVEaW1zO1xuICAgIGNvbnN0IGRpbWVuc2lvblByb3BzID0gW107XG4gICAgbGV0IHBhZGRlZFN5bWJvbFdpZHRoID0gcGFkZGluZ1g7XG4gICAgaWYgKG1hcmtlckxhYmVsLm1hcmtlcnMubGVuZ3RoICE9PSBkYXR1bS5zeW1ib2xzLmxlbmd0aCAmJiBtYXJrZXJMYWJlbC5saW5lcy5sZW5ndGggIT09IGRhdHVtLnN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtYXJrZXJzID0gW107XG4gICAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgICAgZGF0dW0uc3ltYm9scy5mb3JFYWNoKChzeW1ib2wpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaGFwZTogbWFya2VyU2hhcGUgPSBzeW1ib2wubWFya2VyLnNoYXBlIH0gPSBpdGVtTWFya2VyO1xuICAgICAgICBjb25zdCBNYXJrZXJDdHIgPSBnZXRNYXJrZXIobWFya2VyU2hhcGUpO1xuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKCkpO1xuICAgICAgICBtYXJrZXJzLnB1c2gobmV3IE1hcmtlckN0cigpKTtcbiAgICAgIH0pO1xuICAgICAgbWFya2VyTGFiZWwudXBkYXRlU3ltYm9scyhtYXJrZXJzLCBsaW5lcyk7XG4gICAgfVxuICAgIGRhdHVtLnN5bWJvbHMuZm9yRWFjaCgoc3ltYm9sLCBpKSA9PiB7XG4gICAgICBjb25zdCBzcGFjaW5nID0gc3ltYm9sLm1hcmtlci5wYWRkaW5nID8/IGl0ZW1NYXJrZXIucGFkZGluZztcbiAgICAgIGNvbnN0IHsgbWFya2VyRW5hYmxlZCwgbGluZUVuYWJsZWQgfSA9IHRoaXMuY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCk7XG4gICAgICBtYXJrZXJMYWJlbC5tYXJrZXJzW2ldLnNpemUgPSBtYXJrZXJFbmFibGVkIHx8ICFsaW5lRW5hYmxlZCA/IGl0ZW1NYXJrZXIuc2l6ZSA6IDA7XG4gICAgICBkaW1lbnNpb25Qcm9wcy5wdXNoKHsgbGVuZ3RoOiBtYXJrZXJXaWR0aCwgc3BhY2luZyB9KTtcbiAgICAgIGlmIChtYXJrZXJFbmFibGVkIHx8IGxpbmVFbmFibGVkKSB7XG4gICAgICAgIHBhZGRlZFN5bWJvbFdpZHRoICs9IHNwYWNpbmcgKyBtYXJrZXJXaWR0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlckxhYmVsLm1hcmtlcnNbaV07XG4gICAgICBjb25zdCBsaW5lID0gbWFya2VyTGFiZWwubGluZXNbaV07XG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGgsIGZpbGwsIHN0cm9rZSwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHkgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGVzKHN5bWJvbCk7XG4gICAgICAgIG1hcmtlci5maWxsID0gZmlsbDtcbiAgICAgICAgbWFya2VyLnN0cm9rZSA9IHN0cm9rZTtcbiAgICAgICAgbWFya2VyLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIG1hcmtlci5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5O1xuICAgICAgICBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICB9XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICBjb25zdCBsaW5lU3R5bGVzID0gdGhpcy5nZXRMaW5lU3R5bGVzKHN5bWJvbCk7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gbGluZVN0eWxlcy5zdHJva2U7XG4gICAgICAgIGxpbmUuc3Ryb2tlT3BhY2l0eSA9IGxpbmVTdHlsZXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGxpbmVTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGxpbmUubGluZURhc2ggPSBsaW5lU3R5bGVzLmxpbmVEYXNoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1hcmtlckxhYmVsLnVwZGF0ZSh0aGlzLnNwcml0ZVJlbmRlcmVyLCBzcHJpdGVEaW1zLCBkaW1lbnNpb25Qcm9wcyk7XG4gICAgcmV0dXJuIHBhZGRlZFN5bWJvbFdpZHRoO1xuICB9XG4gIHRydW5jYXRlKHRleHQsIG1heENoYXJMZW5ndGgsIG1heEl0ZW1XaWR0aCwgcGFkZGVkTWFya2VyV2lkdGgsIGZvbnQsIGlkKSB7XG4gICAgbGV0IGFkZEVsbGlwc2lzID0gZmFsc2U7XG4gICAgaWYgKHRleHQubGVuZ3RoID4gbWF4Q2hhckxlbmd0aCkge1xuICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIG1heENoYXJMZW5ndGgpO1xuICAgICAgYWRkRWxsaXBzaXMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBtZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250IH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFRleHRXcmFwcGVyLnRydW5jYXRlTGluZSh0ZXh0LCBtZWFzdXJlciwgbWF4SXRlbVdpZHRoIC0gcGFkZGVkTWFya2VyV2lkdGgsIGFkZEVsbGlwc2lzKTtcbiAgICBpZiAocmVzdWx0LmVuZHNXaXRoKFRleHRVdGlscy5FbGxpcHNpc0NoYXIpKSB7XG4gICAgICB0aGlzLnRydW5jYXRlZEl0ZW1zLmFkZChpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJ1bmNhdGVkSXRlbXMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB1cGRhdGVQYWdpbmF0aW9uKGJib3hlcywgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IHRyYWNraW5nSW5kZXggPSBNYXRoLm1pbih0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4LCBiYm94ZXMubGVuZ3RoKTtcbiAgICB0aGlzLnBhZ2luYXRpb24ub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25ZID0gMDtcbiAgICBjb25zdCB7IHBhZ2VzLCBtYXhQYWdlSGVpZ2h0LCBtYXhQYWdlV2lkdGgsIHBhZ2luYXRpb25CQm94LCBwYWdpbmF0aW9uVmVydGljYWwgfSA9IHRoaXMuY2FsY3VsYXRlUGFnaW5hdGlvbihcbiAgICAgIGJib3hlcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgKTtcbiAgICBjb25zdCBuZXdDdXJyZW50UGFnZSA9IHBhZ2VzLmZpbmRJbmRleCgocCkgPT4gcC5lbmRJbmRleCA+PSB0cmFja2luZ0luZGV4KTtcbiAgICB0aGlzLnBhZ2luYXRpb24uY3VycmVudFBhZ2UgPSBjbGFtcCgwLCBuZXdDdXJyZW50UGFnZSwgcGFnZXMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgeyBwYWRkaW5nWDogaXRlbVBhZGRpbmdYLCBwYWRkaW5nWTogaXRlbVBhZGRpbmdZIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmcgPSA4O1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1zV2lkdGggPSBtYXhQYWdlV2lkdGggLSBpdGVtUGFkZGluZ1g7XG4gICAgY29uc3QgbGVnZW5kSXRlbXNIZWlnaHQgPSBtYXhQYWdlSGVpZ2h0IC0gaXRlbVBhZGRpbmdZO1xuICAgIGxldCBwYWdpbmF0aW9uWCA9IDA7XG4gICAgbGV0IHBhZ2luYXRpb25ZID0gLXBhZ2luYXRpb25CQm94LnkgLSB0aGlzLml0ZW0ubWFya2VyLnNpemUgLyAyO1xuICAgIGlmIChwYWdpbmF0aW9uVmVydGljYWwpIHtcbiAgICAgIHBhZ2luYXRpb25ZICs9IGxlZ2VuZEl0ZW1zSGVpZ2h0ICsgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRpb25YICs9IC1wYWdpbmF0aW9uQkJveC54ICsgbGVnZW5kSXRlbXNXaWR0aCArIHBhZ2luYXRpb25Db21wb25lbnRQYWRkaW5nO1xuICAgICAgcGFnaW5hdGlvblkgKz0gKGxlZ2VuZEl0ZW1zSGVpZ2h0IC0gcGFnaW5hdGlvbkJCb3guaGVpZ2h0KSAvIDI7XG4gICAgfVxuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblggPSBwYWdpbmF0aW9uWDtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25ZID0gcGFnaW5hdGlvblk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGVNYXJrZXJzKCk7XG4gICAgbGV0IHBhZ2VJbmRleCA9IDA7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBfLCBub2RlSW5kZXgpID0+IHtcbiAgICAgIGlmIChub2RlSW5kZXggPiAocGFnZXNbcGFnZUluZGV4XT8uZW5kSW5kZXggPz8gSW5maW5pdHkpKSB7XG4gICAgICAgIHBhZ2VJbmRleCsrO1xuICAgICAgfVxuICAgICAgbWFya2VyTGFiZWwucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXhQYWdlSGVpZ2h0LFxuICAgICAgbWF4UGFnZVdpZHRoLFxuICAgICAgcGFnZXNcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUl0ZW1Qcm94eUJ1dHRvbnMoKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsKSA9PiB7XG4gICAgICBjb25zdCBiYm94ID0gbWFya2VyTGFiZWwuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpPy5jbG9uZSgpO1xuICAgICAgYmJveC50cmFuc2xhdGUodGhpcy5ncm91cC50cmFuc2xhdGlvblgsIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25ZKTtcbiAgICAgIHNldEVsZW1lbnRCQm94KG1hcmtlckxhYmVsLnByb3h5QnV0dG9uLCBiYm94KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYWdpbmF0aW9uUHJveHlCdXR0b25zKG9sZFBhZ2VzKSB7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24uc3R5bGUuZGlzcGxheSA9IHRoaXMucGFnaW5hdGlvbi52aXNpYmxlID8gXCJhYnNvbHV0ZVwiIDogXCJub25lXCI7XG4gICAgY29uc3Qgb2xkTmVlZHNCdXR0b25zID0gKG9sZFBhZ2VzPy5sZW5ndGggPz8gdGhpcy5wYWdlcy5sZW5ndGgpID4gMTtcbiAgICBjb25zdCBuZXdOZWVkc0J1dHRvbnMgPSB0aGlzLnBhZ2VzLmxlbmd0aCA+IDE7XG4gICAgaWYgKG9sZE5lZWRzQnV0dG9ucyAhPT0gbmV3TmVlZHNCdXR0b25zKSB7XG4gICAgICBpZiAobmV3TmVlZHNCdXR0b25zKSB7XG4gICAgICAgIHRoaXMucHJveHlQcmV2QnV0dG9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1wcmV2LXBhZ2VgLFxuICAgICAgICAgIHRleHRDb250ZW50OiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2VQcmV2aW91c1wiIH0sXG4gICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbixcbiAgICAgICAgICBmb2N1c2FibGU6IHRoaXMucGFnaW5hdGlvbi5wcmV2aW91c0J1dHRvbixcbiAgICAgICAgICBvbmNsaWNrOiAoKSA9PiB0aGlzLnBhZ2luYXRpb24uY2xpY2tQcmV2aW91cygpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3h5TmV4dEJ1dHRvbiA/PyAodGhpcy5wcm94eU5leHRCdXR0b24gPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgaWQ6IGAke3RoaXMuaWR9LW5leHQtcGFnZWAsXG4gICAgICAgICAgdGV4dENvbnRlbnQ6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kUGFnZU5leHRcIiB9LFxuICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgIHBhcmVudDogdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24sXG4gICAgICAgICAgZm9jdXNhYmxlOiB0aGlzLnBhZ2luYXRpb24ubmV4dEJ1dHRvbixcbiAgICAgICAgICBvbmNsaWNrOiAoKSA9PiB0aGlzLnBhZ2luYXRpb24uY2xpY2tOZXh0KClcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm94eU5leHRCdXR0b24/LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnByb3h5UHJldkJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgICAgIFt0aGlzLnByb3h5TmV4dEJ1dHRvbiwgdGhpcy5wcm94eVByZXZCdXR0b25dID0gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBwcmV2LCBuZXh0IH0gPSB0aGlzLnBhZ2luYXRpb24uY29tcHV0ZUNTU0JvdW5kcygpO1xuICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlQcmV2QnV0dG9uLCBwcmV2KTtcbiAgICBzZXRFbGVtZW50QkJveCh0aGlzLnByb3h5TmV4dEJ1dHRvbiwgbmV4dCk7XG4gIH1cbiAgY2FsY3VsYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7IHBhZGRpbmdYOiBpdGVtUGFkZGluZ1gsIHBhZGRpbmdZOiBpdGVtUGFkZGluZ1kgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcbiAgICBjb25zdCBwYWdpbmF0aW9uVmVydGljYWwgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIl0uaW5jbHVkZXModGhpcy5wb3NpdGlvbik7XG4gICAgbGV0IHBhZ2luYXRpb25CQm94ID0gdGhpcy5wYWdpbmF0aW9uLmdldEJCb3goKTtcbiAgICBsZXQgbGFzdFBhc3NQYWdpbmF0aW9uQkJveCA9IG5ldyBCQm94KDAsIDAsIDAsIDApO1xuICAgIGxldCBwYWdlcyA9IFtdO1xuICAgIGxldCBtYXhQYWdlV2lkdGggPSAwO1xuICAgIGxldCBtYXhQYWdlSGVpZ2h0ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHN0YWJsZU91dHB1dCA9IChiYm94KSA9PiB7XG4gICAgICByZXR1cm4gYmJveC53aWR0aCA9PT0gcGFnaW5hdGlvbkJCb3gud2lkdGggJiYgYmJveC5oZWlnaHQgPT09IHBhZ2luYXRpb25CQm94LmhlaWdodDtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlUmVzdWx0ID0gdGhpcy5tYXhXaWR0aCAhPT0gdm9pZCAwICYmIHRoaXMubWF4SGVpZ2h0ICE9PSB2b2lkIDA7XG4gICAgZG8ge1xuICAgICAgaWYgKGNvdW50KysgPiAxMCkge1xuICAgICAgICBMb2dnZXIud2FybihcInVuYWJsZSB0byBmaW5kIHN0YWJsZSBsZWdlbmQgbGF5b3V0LlwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwYWdpbmF0aW9uQkJveCA9IGxhc3RQYXNzUGFnaW5hdGlvbkJCb3g7XG4gICAgICBjb25zdCBtYXhXaWR0aCA9IHdpZHRoIC0gKHBhZ2luYXRpb25WZXJ0aWNhbCA/IDAgOiBwYWdpbmF0aW9uQkJveC53aWR0aCk7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSBoZWlnaHQgLSAocGFnaW5hdGlvblZlcnRpY2FsID8gcGFnaW5hdGlvbkJCb3guaGVpZ2h0IDogMCk7XG4gICAgICBjb25zdCBsYXlvdXQgPSBncmlkTGF5b3V0KHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGJib3hlcyxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgaXRlbVBhZGRpbmdZLFxuICAgICAgICBpdGVtUGFkZGluZ1gsXG4gICAgICAgIGZvcmNlUmVzdWx0XG4gICAgICB9KTtcbiAgICAgIHBhZ2VzID0gbGF5b3V0Py5wYWdlcyA/PyBbXTtcbiAgICAgIG1heFBhZ2VXaWR0aCA9IGxheW91dD8ubWF4UGFnZVdpZHRoID8/IDA7XG4gICAgICBtYXhQYWdlSGVpZ2h0ID0gbGF5b3V0Py5tYXhQYWdlSGVpZ2h0ID8/IDA7XG4gICAgICBjb25zdCB0b3RhbFBhZ2VzID0gcGFnZXMubGVuZ3RoO1xuICAgICAgdGhpcy5wYWdpbmF0aW9uLnZpc2libGUgPSB0b3RhbFBhZ2VzID4gMTtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi50b3RhbFBhZ2VzID0gdG90YWxQYWdlcztcbiAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIGxhc3RQYXNzUGFnaW5hdGlvbkJCb3ggPSB0aGlzLnBhZ2luYXRpb24uZ2V0QkJveCgpO1xuICAgICAgaWYgKCF0aGlzLnBhZ2luYXRpb24udmlzaWJsZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICghc3RhYmxlT3V0cHV0KGxhc3RQYXNzUGFnaW5hdGlvbkJCb3gpKTtcbiAgICByZXR1cm4geyBtYXhQYWdlV2lkdGgsIG1heFBhZ2VIZWlnaHQsIHBhZ2VzLCBwYWdpbmF0aW9uQkJveCwgcGFnaW5hdGlvblZlcnRpY2FsIH07XG4gIH1cbiAgdXBkYXRlUG9zaXRpb25zKHBhZ2VOdW1iZXIgPSAwKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXRlbTogeyBwYWRkaW5nWSB9LFxuICAgICAgaXRlbVNlbGVjdGlvbixcbiAgICAgIHBhZ2VzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHBhZ2VzLmxlbmd0aCA8IDEgfHwgIXBhZ2VzW3BhZ2VOdW1iZXJdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29sdW1ucywgc3RhcnRJbmRleDogdmlzaWJsZVN0YXJ0LCBlbmRJbmRleDogdmlzaWJsZUVuZCB9ID0gcGFnZXNbcGFnZU51bWJlcl07XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBjb25zdCBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuICAgIGNvbnN0IHJvd0NvdW50ID0gY29sdW1uc1swXS5pbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5nZXRPcmllbnRhdGlvbigpID09PSBcImhvcml6b250YWxcIjtcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gY29sdW1uc1swXS5iYm94ZXNbMF0uaGVpZ2h0ICsgcGFkZGluZ1k7XG4gICAgY29uc3Qgcm93U3VtQ29sdW1uV2lkdGhzID0gW107XG4gICAgaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgXywgaSkgPT4ge1xuICAgICAgaWYgKGkgPCB2aXNpYmxlU3RhcnQgfHwgaSA+IHZpc2libGVFbmQpIHtcbiAgICAgICAgbWFya2VyTGFiZWwudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlSW5kZXggPSBpIC0gdmlzaWJsZVN0YXJ0O1xuICAgICAgbGV0IGNvbHVtbkluZGV4O1xuICAgICAgbGV0IHJvd0luZGV4O1xuICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgY29sdW1uSW5kZXggPSBwYWdlSW5kZXggJSBjb2x1bW5Db3VudDtcbiAgICAgICAgcm93SW5kZXggPSBNYXRoLmZsb29yKHBhZ2VJbmRleCAvIGNvbHVtbkNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbkluZGV4ID0gTWF0aC5mbG9vcihwYWdlSW5kZXggLyByb3dDb3VudCk7XG4gICAgICAgIHJvd0luZGV4ID0gcGFnZUluZGV4ICUgcm93Q291bnQ7XG4gICAgICB9XG4gICAgICBtYXJrZXJMYWJlbC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbY29sdW1uSW5kZXhdO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeSA9IE1hdGguZmxvb3IoaXRlbUhlaWdodCAqIHJvd0luZGV4KTtcbiAgICAgIHggPSBNYXRoLmZsb29yKHJvd1N1bUNvbHVtbldpZHRoc1tyb3dJbmRleF0gPz8gMCk7XG4gICAgICByb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID0gKHJvd1N1bUNvbHVtbldpZHRoc1tyb3dJbmRleF0gPz8gMCkgKyBjb2x1bW4uY29sdW1uV2lkdGg7XG4gICAgICBtYXJrZXJMYWJlbC50cmFuc2xhdGlvblggPSB4O1xuICAgICAgbWFya2VyTGFiZWwudHJhbnNsYXRpb25ZID0geTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYWdlTnVtYmVyKHBhZ2VOdW1iZXIpIHtcbiAgICBjb25zdCB7IHBhZ2VzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHBhZ2VzW3BhZ2VOdW1iZXJdO1xuICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gMDtcbiAgICB9IGVsc2UgaWYgKHBhZ2VOdW1iZXIgPT09IHBhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSBlbmRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5kZXggKyBlbmRJbmRleCkgLyAyKTtcbiAgICB9XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGVNYXJrZXJzKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMocGFnZU51bWJlcik7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbDogeyBjb2xvciB9XG4gICAgfSA9IHRoaXMuaXRlbTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIGRhdHVtKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5zZXRFbmFibGVkKGRhdHVtLmVuYWJsZWQpO1xuICAgICAgbWFya2VyTGFiZWwuY29sb3IgPSBjb2xvcjtcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHRNZW51KCk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dE1lbnUoKSB7XG4gICAgY29uc3QgeyB0b2dnbGVTZXJpZXMgfSA9IHRoaXM7XG4gICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5zZXRBY3Rpb25WaXNpYmxpdHkoSURfTEVHRU5EX1ZJU0lCSUxJVFksIHRvZ2dsZVNlcmllcyk7XG4gICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5zZXRBY3Rpb25WaXNpYmxpdHkoSURfTEVHRU5EX09USEVSX1NFUklFUywgdG9nZ2xlU2VyaWVzKTtcbiAgfVxuICBnZXRMaW5lU3R5bGVzKGRhdHVtKSB7XG4gICAgY29uc3QgeyBzdHJva2UsIHN0cm9rZU9wYWNpdHkgPSAxLCBzdHJva2VXaWR0aCwgbGluZURhc2ggfSA9IGRhdHVtLmxpbmUgPz8ge307XG4gICAgY29uc3QgZGVmYXVsdExpbmVTdHJva2VXaWR0aCA9IE1hdGgubWluKDIsIHN0cm9rZVdpZHRoID8/IDEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuaXRlbS5saW5lLnN0cm9rZVdpZHRoID8/IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lRGFzaFxuICAgIH07XG4gIH1cbiAgZ2V0TWFya2VyU3R5bGVzKGRhdHVtKSB7XG4gICAgY29uc3QgeyBmaWxsLCBzdHJva2UsIHN0cm9rZU9wYWNpdHkgPSAxLCBmaWxsT3BhY2l0eSA9IDEsIHN0cm9rZVdpZHRoIH0gPSBkYXR1bS5tYXJrZXI7XG4gICAgY29uc3QgZGVmYXVsdExpbmVTdHJva2VXaWR0aCA9IE1hdGgubWluKDIsIHN0cm9rZVdpZHRoID8/IDEpO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuaXRlbS5tYXJrZXIuc3Ryb2tlV2lkdGggPz8gZGVmYXVsdExpbmVTdHJva2VXaWR0aFxuICAgIH07XG4gIH1cbiAgZ2V0RGF0dW1Gb3JQb2ludCh4LCB5KSB7XG4gICAgY29uc3QgdmlzaWJsZUNoaWxkQkJveGVzID0gW107XG4gICAgY29uc3QgY2xvc2VzdExlZnRUb3AgPSB7IGRpc3Q6IEluZmluaXR5LCBkYXR1bTogdm9pZCAwIH07XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWNoaWxkLnZpc2libGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBMZWdlbmRNYXJrZXJMYWJlbCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgY2hpbGRCQm94ID0gY2hpbGQuZ2V0QkJveCgpLmNsb25lKCk7XG4gICAgICBjaGlsZEJCb3guZ3Jvdyh0aGlzLml0ZW0ucGFkZGluZ1ggLyAyLCBcImhvcml6b250YWxcIik7XG4gICAgICBjaGlsZEJCb3guZ3Jvdyh0aGlzLml0ZW0ucGFkZGluZ1kgLyAyLCBcInZlcnRpY2FsXCIpO1xuICAgICAgaWYgKGNoaWxkQkJveC5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5kYXR1bTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc3RYID0geCAtIGNoaWxkQkJveC54IC0gdGhpcy5pdGVtLnBhZGRpbmdYIC8gMjtcbiAgICAgIGNvbnN0IGRpc3RZID0geSAtIGNoaWxkQkJveC55IC0gdGhpcy5pdGVtLnBhZGRpbmdZIC8gMjtcbiAgICAgIGNvbnN0IGRpc3QgPSBkaXN0WCAqKiAyICsgZGlzdFkgKiogMjtcbiAgICAgIGNvbnN0IHRvVGhlTGVmdFRvcCA9IGRpc3RYID49IDAgJiYgZGlzdFkgPj0gMDtcbiAgICAgIGlmICh0b1RoZUxlZnRUb3AgJiYgZGlzdCA8IGNsb3Nlc3RMZWZ0VG9wLmRpc3QpIHtcbiAgICAgICAgY2xvc2VzdExlZnRUb3AuZGlzdCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RMZWZ0VG9wLmRhdHVtID0gY2hpbGQuZGF0dW07XG4gICAgICB9XG4gICAgICB2aXNpYmxlQ2hpbGRCQm94ZXMucHVzaChjaGlsZEJCb3gpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlQkJveCA9IEJCb3gubWVyZ2UodmlzaWJsZUNoaWxkQkJveGVzKTtcbiAgICBpZiAoIXBhZ2VCQm94LmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RMZWZ0VG9wLmRhdHVtO1xuICB9XG4gIGNvbXB1dGVQYWdlZEJCb3goKSB7XG4gICAgbGV0IGFjdHVhbEJCb3ggPSB0aGlzLmdyb3VwLmdldEJCb3goKTtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIGFjdHVhbEJCb3g7XG4gICAgfVxuICAgIGNvbnN0IFttYXhQYWdlV2lkdGgsIG1heFBhZ2VIZWlnaHRdID0gdGhpcy5tYXhQYWdlU2l6ZTtcbiAgICBhY3R1YWxCQm94ID0gYWN0dWFsQkJveC5jbG9uZSgpO1xuICAgIGFjdHVhbEJCb3guaGVpZ2h0ID0gTWF0aC5tYXgobWF4UGFnZUhlaWdodCwgYWN0dWFsQkJveC5oZWlnaHQpO1xuICAgIGFjdHVhbEJCb3gud2lkdGggPSBNYXRoLm1heChtYXhQYWdlV2lkdGgsIGFjdHVhbEJCb3gud2lkdGgpO1xuICAgIHJldHVybiBhY3R1YWxCQm94O1xuICB9XG4gIGNvbnRleHRUb2dnbGVWaXNpYmlsaXR5KHBhcmFtcykge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5kYXRhLmZpbmQoKHYpID0+IHYuaXRlbUlkID09PSBwYXJhbXMuaXRlbUlkKTtcbiAgICB0aGlzLmRvQ2xpY2soZGF0dW0pO1xuICB9XG4gIGNvbnRleHRUb2dnbGVPdGhlclNlcmllcyhwYXJhbXMpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZGF0YS5maW5kKCh2KSA9PiB2Lml0ZW1JZCA9PT0gcGFyYW1zLml0ZW1JZCk7XG4gICAgdGhpcy5kb0RvdWJsZUNsaWNrKGRhdHVtKTtcbiAgfVxuICBjaGVja0NvbnRleHRDbGljayhldmVudCkge1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgaWYgKHRoaXMucHJldmVudEhpZGluZ0FsbCAmJiB0aGlzLmNvbnRleHRNZW51RGF0dW0/LmVuYWJsZWQgJiYgdGhpcy5nZXRWaXNpYmxlSXRlbUNvdW50KCkgPD0gMSkge1xuICAgICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNhYmxlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5lbmFibGVBY3Rpb24oSURfTEVHRU5EX1ZJU0lCSUxJVFkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LmRpc3BhdGNoQ29udGV4dChcImxlZ2VuZFwiLCBldmVudCwgeyBsZWdlbmRJdGVtIH0pO1xuICB9XG4gIGNoZWNrTGVnZW5kQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZ2V0RGF0dW1Gb3JQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICBpZiAodGhpcy5kb0NsaWNrKGRhdHVtKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0VmlzaWJsZUl0ZW1Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguY2hhcnRTZXJ2aWNlLnNlcmllcy5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEoXCJjYXRlZ29yeVwiKSkuZmlsdGVyKChkKSA9PiBkLmVuYWJsZWQpLmxlbmd0aDtcbiAgfVxuICBkb0NsaWNrKGRhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdGVuZXJzOiB7IGxlZ2VuZEl0ZW1DbGljayB9LFxuICAgICAgY3R4OiB7IGNoYXJ0U2VydmljZSwgaGlnaGxpZ2h0TWFuYWdlciB9LFxuICAgICAgcHJldmVudEhpZGluZ0FsbCxcbiAgICAgIHRvZ2dsZVNlcmllc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGF0dW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgaXRlbUlkLCBlbmFibGVkIH0gPSBkYXR1bTtcbiAgICBjb25zdCBzZXJpZXMgPSBjaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGlkKTtcbiAgICBpZiAoIXNlcmllcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbmV3RW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgaWYgKHRvZ2dsZVNlcmllcykge1xuICAgICAgbmV3RW5hYmxlZCA9ICFlbmFibGVkO1xuICAgICAgaWYgKHByZXZlbnRIaWRpbmdBbGwgJiYgIW5ld0VuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgbnVtVmlzaWJsZUl0ZW1zID0gdGhpcy5nZXRWaXNpYmxlSXRlbUNvdW50KCk7XG4gICAgICAgIGlmIChudW1WaXNpYmxlSXRlbXMgPCAyKSB7XG4gICAgICAgICAgbmV3RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXR1cyA9IG5ld0VuYWJsZWQgPyBcImFyaWFBbm5vdW5jZVZpc2libGVcIiA6IFwiYXJpYUFubm91bmNlSGlkZGVuXCI7XG4gICAgICB0aGlzLmN0eC5hcmlhQW5ub3VuY2VtZW50U2VydmljZS5hbm5vdW5jZVZhbHVlKHN0YXR1cyk7XG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5sZWdlbmRJdGVtQ2xpY2soc2VyaWVzLCBpdGVtSWQsIG5ld0VuYWJsZWQsIGRhdHVtLmxlZ2VuZEl0ZW1OYW1lKTtcbiAgICB9XG4gICAgaWYgKG5ld0VuYWJsZWQpIHtcbiAgICAgIGhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIHtcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGRhdHVtOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgICB9XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoMiAvKiBQUk9DRVNTX0RBVEEgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUgfSk7XG4gICAgbGVnZW5kSXRlbUNsaWNrPy4oeyB0eXBlOiBcImNsaWNrXCIsIGVuYWJsZWQ6IG5ld0VuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzSWQ6IHNlcmllcy5pZCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjaGVja0xlZ2VuZERvdWJsZUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgaWYgKHRoaXMuZG9Eb3VibGVDbGljayhkYXR1bSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGRvRG91YmxlQ2xpY2soZGF0dW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBsaXN0ZW5lcnM6IHsgbGVnZW5kSXRlbURvdWJsZUNsaWNrIH0sXG4gICAgICBjdHg6IHsgY2hhcnRTZXJ2aWNlIH0sXG4gICAgICB0b2dnbGVTZXJpZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoY2hhcnRTZXJ2aWNlLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZGF0dW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgaXRlbUlkLCBzZXJpZXNJZCB9ID0gZGF0dW07XG4gICAgY29uc3Qgc2VyaWVzID0gY2hhcnRTZXJ2aWNlLnNlcmllcy5maW5kKChzKSA9PiBzLmlkID09PSBpZCk7XG4gICAgaWYgKCFzZXJpZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRvZ2dsZVNlcmllcykge1xuICAgICAgY29uc3QgbGVnZW5kRGF0YSA9IGNoYXJ0U2VydmljZS5zZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRMZWdlbmREYXRhKFwiY2F0ZWdvcnlcIikpO1xuICAgICAgY29uc3QgbnVtVmlzaWJsZUl0ZW1zID0gbGVnZW5kRGF0YS5maWx0ZXIoKGQpID0+IGQuZW5hYmxlZCkubGVuZ3RoO1xuICAgICAgY29uc3QgY2xpY2tlZEl0ZW0gPSBsZWdlbmREYXRhLmZpbmQoKGQpID0+IGQuaXRlbUlkID09PSBpdGVtSWQgJiYgZC5zZXJpZXNJZCA9PT0gc2VyaWVzSWQpO1xuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIubGVnZW5kSXRlbURvdWJsZUNsaWNrKFxuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgY2xpY2tlZEl0ZW0/LmVuYWJsZWQgPz8gZmFsc2UsXG4gICAgICAgIG51bVZpc2libGVJdGVtcyxcbiAgICAgICAgY2xpY2tlZEl0ZW0/LmxlZ2VuZEl0ZW1OYW1lXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgyIC8qIFBST0NFU1NfREFUQSAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICBsZWdlbmRJdGVtRG91YmxlQ2xpY2s/Lih7IHR5cGU6IFwiZGJsY2xpY2tcIiwgZW5hYmxlZDogdHJ1ZSwgaXRlbUlkLCBzZXJpZXNJZDogc2VyaWVzLmlkIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGhhbmRsZUxlZ2VuZE1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZ2V0RGF0dW1Gb3JQb2ludChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB0aGlzLmRvSG92ZXIoZXZlbnQsIGRhdHVtKTtcbiAgfVxuICBkb0hvdmVyKGV2ZW50LCBkYXR1bSkge1xuICAgIGNvbnN0IHsgdG9nZ2xlU2VyaWVzLCBsaXN0ZW5lcnMgfSA9IHRoaXM7XG4gICAgaWYgKGV2ZW50ID09PSB2b2lkIDAgfHwgZGF0dW0gPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXJpZXMgPSBkYXR1bSA/IHRoaXMuY3R4LmNoYXJ0U2VydmljZS5zZXJpZXMuZmluZCgocykgPT4gcy5pZCA9PT0gZGF0dW0/LmlkKSA6IHZvaWQgMDtcbiAgICBpZiAoZGF0dW0gJiYgdGhpcy50cnVuY2F0ZWRJdGVtcy5oYXMoZGF0dW0uaXRlbUlkID8/IGRhdHVtLmlkKSkge1xuICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZVRvb2x0aXAoXG4gICAgICAgIHRoaXMuaWQsXG4gICAgICAgIHsgb2Zmc2V0WCwgb2Zmc2V0WSwgbGFzdFBvaW50ZXJFdmVudDogZXZlbnQsIHNob3dBcnJvdzogZmFsc2UgfSxcbiAgICAgICAgdG9Ub29sdGlwSHRtbCh7IGNvbnRlbnQ6IHRoaXMuZ2V0SXRlbUxhYmVsKGRhdHVtKSB9KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB9XG4gICAgaWYgKHRvZ2dsZVNlcmllcyB8fCBsaXN0ZW5lcnMubGVnZW5kSXRlbUNsaWNrICE9IG51bGwgfHwgbGlzdGVuZXJzLmxlZ2VuZEl0ZW1Eb3VibGVDbGljayAhPSBudWxsKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkLCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGlmIChkYXR1bT8uZW5hYmxlZCAmJiBzZXJpZXMpIHtcbiAgICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0KHtcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBpdGVtSWQ6IGRhdHVtPy5pdGVtSWQsXG4gICAgICAgIGRhdHVtOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCgpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVMZWdlbmRNb3VzZUV4aXQoKSB7XG4gICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCgpO1xuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodChkYXR1bSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlID09PSAxNiAvKiBEZWZhdWx0ICovKSB7XG4gICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCBkYXR1bSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gMSAvKiBBbmltYXRpb24gKi8pIHtcbiAgICAgIHRoaXMucGVuZGluZ0hpZ2hsaWdodERhdHVtID0gZGF0dW07XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLm9uQmF0Y2hTdG9wKCgpID0+IHtcbiAgICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgdGhpcy5wZW5kaW5nSGlnaGxpZ2h0RGF0dW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUxlZ2VuZE1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbmFibGVkLFxuICAgICAgdG9nZ2xlU2VyaWVzLFxuICAgICAgbGlzdGVuZXJzOiB7IGxlZ2VuZEl0ZW1DbGljazogY2xpY2tMaXN0ZW5lciwgbGVnZW5kSXRlbURvdWJsZUNsaWNrOiBkYmxjbGlja0xpc3RlbmVyIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZ2V0RGF0dW1Gb3JQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICBpZiAoZW5hYmxlZCAmJiBkYXR1bSAhPT0gdm9pZCAwICYmICh0b2dnbGVTZXJpZXMgfHwgY2xpY2tMaXN0ZW5lciAhPSBudWxsIHx8IGRibGNsaWNrTGlzdGVuZXIgIT0gbnVsbCkpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gIH1cbiAgb25Mb2NhbGVDaGFuZ2VkKCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKCh7IHByb3h5QnV0dG9uIH0sIF8sIGkpID0+IHtcbiAgICAgIGlmIChwcm94eUJ1dHRvbiAhPSBudWxsKSB7XG4gICAgICAgIHByb3h5QnV0dG9uLnRleHRDb250ZW50ID0gdGhpcy5nZXRJdGVtQXJpYVRleHQoaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0SXRlbUFyaWFUZXh0KG5vZGVJbmRleCwgZW5hYmxlZCkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5kYXRhW25vZGVJbmRleF07XG4gICAgY29uc3QgbGFiZWwgPSBkYXR1bSAmJiB0aGlzLmdldEl0ZW1MYWJlbChkYXR1bSk7XG4gICAgZW5hYmxlZCA/PyAoZW5hYmxlZCA9IGRhdHVtLmVuYWJsZWQpO1xuICAgIGNvbnN0IGxtID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlcjtcbiAgICBpZiAobm9kZUluZGV4ID49IDAgJiYgbGFiZWwpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbm9kZUluZGV4ICsgMTtcbiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBhcnQxID0gbG0udChcImFyaWFMYWJlbExlZ2VuZEl0ZW1cIiwgeyBsYWJlbCwgaW5kZXgsIGNvdW50IH0pO1xuICAgICAgY29uc3QgcGFydDIgPSBsbS50KGVuYWJsZWQgPyBcImFyaWFBbm5vdW5jZVZpc2libGVcIiA6IFwiYXJpYUFubm91bmNlSGlkZGVuXCIpO1xuICAgICAgcmV0dXJuIFtwYXJ0MSwgcGFydDJdLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBsbS50KFwiYXJpYUxhYmVsTGVnZW5kSXRlbVVua25vd25cIik7XG4gIH1cbiAgcG9zaXRpb25MZWdlbmQoY3R4KSB7XG4gICAgY29uc3QgeyBzaHJpbmtSZWN0IH0gPSBjdHg7XG4gICAgY29uc3QgbmV3U2hyaW5rUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgLi4uY3R4LCBzaHJpbmtSZWN0OiBuZXdTaHJpbmtSZWN0IH07XG4gICAgfVxuICAgIGNvbnN0IFtsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0XSA9IHRoaXMuY2FsY3VsYXRlTGVnZW5kRGltZW5zaW9ucyhzaHJpbmtSZWN0KTtcbiAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSAwO1xuICAgIGNvbnN0IHsgb2xkUGFnZXMgfSA9IHRoaXMuY2FsY0xheW91dChsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0KTtcbiAgICBjb25zdCBsZWdlbmRCQm94ID0gdGhpcy5jb21wdXRlUGFnZWRCQm94KCk7XG4gICAgY29uc3QgY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uID0gKCkgPT4ge1xuICAgICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIHJldHVybiBzaHJpbmtSZWN0LmhlaWdodCAtIGxlZ2VuZEJCb3guaGVpZ2h0O1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc2hyaW5rUmVjdC53aWR0aCAtIGxlZ2VuZEJCb3gud2lkdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICBjb25zdCBsZWdlbmRQYWRkaW5nID0gdGhpcy5zcGFjaW5nO1xuICAgICAgbGV0IHRyYW5zbGF0aW9uWDtcbiAgICAgIGxldCB0cmFuc2xhdGlvblk7XG4gICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgdHJhbnNsYXRpb25YID0gKHNocmlua1JlY3Qud2lkdGggLSBsZWdlbmRCQm94LndpZHRoKSAvIDI7XG4gICAgICAgICAgdHJhbnNsYXRpb25ZID0gY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uKCk7XG4gICAgICAgICAgbmV3U2hyaW5rUmVjdC5zaHJpbmsobGVnZW5kQkJveC5oZWlnaHQgKyBsZWdlbmRQYWRkaW5nLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdHJhbnNsYXRpb25YID0gY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uKCk7XG4gICAgICAgICAgdHJhbnNsYXRpb25ZID0gKHNocmlua1JlY3QuaGVpZ2h0IC0gbGVnZW5kQkJveC5oZWlnaHQpIC8gMjtcbiAgICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhsZWdlbmRCQm94LndpZHRoICsgbGVnZW5kUGFkZGluZywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IoLWxlZ2VuZEJCb3gueCArIHNocmlua1JlY3QueCArIHRyYW5zbGF0aW9uWCk7XG4gICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IoLWxlZ2VuZEJCb3gueSArIHNocmlua1JlY3QueSArIHRyYW5zbGF0aW9uWSk7XG4gICAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhci5hcmlhT3JpZW50YXRpb24gPSB0aGlzLmdldE9yaWVudGF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVJdGVtUHJveHlCdXR0b25zKCk7XG4gICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uUHJveHlCdXR0b25zKG9sZFBhZ2VzKTtcbiAgICByZXR1cm4geyAuLi5jdHgsIHNocmlua1JlY3Q6IG5ld1Nocmlua1JlY3QgfTtcbiAgfVxuICBjYWxjdWxhdGVMZWdlbmREaW1lbnNpb25zKHNocmlua1JlY3QpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNocmlua1JlY3Q7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBjb25zdCBtYXhDb2VmZmljaWVudCA9IDAuNTtcbiAgICBjb25zdCBtaW5IZWlnaHRDb2VmZmljaWVudCA9IDAuMjtcbiAgICBjb25zdCBtaW5XaWR0aENvZWZmaWNpZW50ID0gMC4yNTtcbiAgICBsZXQgbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgY29uc3QgaGVpZ2h0Q29lZmZpY2llbnQgPSBhc3BlY3RSYXRpbyA8IDEgPyBNYXRoLm1pbihtYXhDb2VmZmljaWVudCwgbWluSGVpZ2h0Q29lZmZpY2llbnQgKiAoMSAvIGFzcGVjdFJhdGlvKSkgOiBtaW5IZWlnaHRDb2VmZmljaWVudDtcbiAgICAgICAgbGVnZW5kV2lkdGggPSB0aGlzLm1heFdpZHRoID8gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgd2lkdGgpIDogd2lkdGg7XG4gICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodCkgOiBNYXRoLnJvdW5kKGhlaWdodCAqIGhlaWdodENvZWZmaWNpZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zdCB3aWR0aENvZWZmaWNpZW50ID0gYXNwZWN0UmF0aW8gPiAxID8gTWF0aC5taW4obWF4Q29lZmZpY2llbnQsIG1pbldpZHRoQ29lZmZpY2llbnQgKiBhc3BlY3RSYXRpbykgOiBtaW5XaWR0aENvZWZmaWNpZW50O1xuICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMubWF4V2lkdGggPyBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCB3aWR0aCkgOiBNYXRoLnJvdW5kKHdpZHRoICogd2lkdGhDb2VmZmljaWVudCk7XG4gICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodCkgOiBoZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBbbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodF07XG4gIH1cbn07XG5MZWdlbmQuY2xhc3NOYW1lID0gXCJMZWdlbmRcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInRvZ2dsZVNlcmllc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicGFnaW5hdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwiaXRlbVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwibGlzdGVuZXJzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0LnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpKSxcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSU9OKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInJldmVyc2VPcmRlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSwgXCJhbiBvcmllbnRhdGlvblwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicHJldmVudEhpZGluZ0FsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kTW9kdWxlLnRzXG52YXIgQ29tbXVuaXR5TGVnZW5kTW9kdWxlID0ge1xuICB0eXBlOiBcImxlZ2VuZFwiLFxuICBvcHRpb25zS2V5OiBcImxlZ2VuZFwiLFxuICBpZGVudGlmaWVyOiBcImNhdGVnb3J5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBMZWdlbmQoY3R4KSxcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xvY2FsZS9sb2NhbGUudHNcbnZhciBMb2NhbGUgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5sb2NhbGVUZXh0ID0gdm9pZCAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5jdHgubG9jYWxlTWFuYWdlci5zZXRMb2NhbGVUZXh0KHRhcmdldC5sb2NhbGVUZXh0KTtcbiAgfSksXG4gIFZhbGlkYXRlKFBMQUlOX09CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTG9jYWxlLnByb3RvdHlwZSwgXCJsb2NhbGVUZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5jdHgubG9jYWxlTWFuYWdlci5zZXRMb2NhbGVUZXh0Rm9ybWF0dGVyKHRhcmdldC5nZXRMb2NhbGVUZXh0KTtcbiAgfSksXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMb2NhbGUucHJvdG90eXBlLCBcImdldExvY2FsZVRleHRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xvY2FsZS9sb2NhbGVNb2R1bGUudHNcbnZhciBMb2NhbGVNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcImxvY2FsZVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IExvY2FsZShjdHgpXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3Ivc2hhcGVzL3JhbmdlSGFuZGxlLnRzXG52YXIgUmFuZ2VIYW5kbGUgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuekluZGV4ID0gMztcbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDg7XG4gICAgdGhpcy5oZWlnaHQgPSAxNjtcbiAgICB0aGlzLmdyaXBMaW5lR2FwID0gMjtcbiAgICB0aGlzLmdyaXBMaW5lTGVuZ3RoID0gODtcbiAgfVxuICBzZXRDZW50ZXIoeCwgeSkge1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB0aGlzLmNlbnRlclggPSB4O1xuICAgIHRoaXMuY2VudGVyWSA9IHk7XG4gIH1cbiAgc3RhdGljIGFsaWduKG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW4sIG1heCkge1xuICAgIGNvbnN0IGhhbmRsZVBpeGVsQWxpZ24gPSBtaW5IYW5kbGUuc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IG1pbkhhbmRsZVggPSBtaW5IYW5kbGUuYWxpZ24oeCArIHdpZHRoICogbWluKSArIGhhbmRsZVBpeGVsQWxpZ247XG4gICAgY29uc3QgbWF4SGFuZGxlWCA9IG1pbkhhbmRsZVggKyBtaW5IYW5kbGUuYWxpZ24oeCArIHdpZHRoICogbWluLCB3aWR0aCAqIChtYXggLSBtaW4pKSAtIDIgKiBoYW5kbGVQaXhlbEFsaWduO1xuICAgIGNvbnN0IGhhbmRsZVkgPSBtaW5IYW5kbGUuYWxpZ24oeSArIGhlaWdodCAvIDIpICsgaGFuZGxlUGl4ZWxBbGlnbjtcbiAgICBtaW5IYW5kbGUuc2V0Q2VudGVyKG1pbkhhbmRsZVgsIGhhbmRsZVkpO1xuICAgIG1heEhhbmRsZS5zZXRDZW50ZXIobWF4SGFuZGxlWCwgaGFuZGxlWSk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBjZW50ZXJYIC0gd2lkdGggLyAyO1xuICAgIGNvbnN0IHkgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4gbmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgcmV0dXJuIGJib3guY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgcGF0aCwgc3Ryb2tlV2lkdGgsIGdyaXBMaW5lR2FwLCBncmlwTGluZUxlbmd0aCB9ID0gdGhpcztcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcz8ucGl4ZWxSYXRpbyA/PyAxO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSBNYXRoLmZsb29yKHRoaXMud2lkdGggLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0IC8gMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBwYXRoLm1vdmVUbyhjZW50ZXJYIC0gaGFsZldpZHRoLCBjZW50ZXJZIC0gaGFsZkhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCArIGhhbGZXaWR0aCwgY2VudGVyWSAtIGhhbGZIZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggKyBoYWxmV2lkdGgsIGNlbnRlclkgKyBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYIC0gaGFsZldpZHRoLCBjZW50ZXJZICsgaGFsZkhlaWdodCk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICBjb25zdCBkeCA9IE1hdGguZmxvb3IoKGdyaXBMaW5lR2FwICsgc3Ryb2tlV2lkdGgpIC8gMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBjb25zdCBkeSA9IE1hdGguZmxvb3IoZ3JpcExpbmVMZW5ndGggLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIHBhdGgubW92ZVRvKGNlbnRlclggLSBkeCwgY2VudGVyWSAtIGR5KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYIC0gZHgsIGNlbnRlclkgKyBkeSk7XG4gICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIGR4LCBjZW50ZXJZIC0gZHkpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggKyBkeCwgY2VudGVyWSArIGR5KTtcbiAgfVxufTtcblJhbmdlSGFuZGxlLmNsYXNzTmFtZSA9IFwiUmFuZ2VIYW5kbGVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCB0eXBlOiBcInBhdGhcIiB9KVxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiZ3JpcExpbmVHYXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJncmlwTGluZUxlbmd0aFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL3NoYXBlcy9yYW5nZU1hc2sudHNcbnZhciBSYW5nZU1hc2sgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuekluZGV4ID0gMjtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMubWluID0gMDtcbiAgICB0aGlzLm1heCA9IDE7XG4gIH1cbiAgbGF5b3V0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICB1cGRhdGUobWluLCBtYXgpIHtcbiAgICB0aGlzLm1pbiA9IGlzTmFOKG1pbikgPyB0aGlzLm1pbiA6IG1pbjtcbiAgICB0aGlzLm1heCA9IGlzTmFOKG1heCkgPyB0aGlzLm1heCA6IG1heDtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBjb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IG1pblggPSB4ICsgd2lkdGggKiBtaW47XG4gICAgY29uc3QgbWF4WCA9IHggKyB3aWR0aCAqIG1heDtcbiAgICByZXR1cm4gbmV3IEJCb3gobWluWCwgeSwgbWF4WCAtIG1pblgsIGhlaWdodCk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbiwgbWF4LCBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICBjb25zdCBwaXhlbEFsaWduID0gc3Ryb2tlV2lkdGggLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBjb25zdCBheCA9IHRoaXMuYWxpZ24oeCkgKyBwaXhlbEFsaWduO1xuICAgIGNvbnN0IGF5ID0gdGhpcy5hbGlnbih5KSArIHBpeGVsQWxpZ247XG4gICAgY29uc3QgYXh3ID0gYXggKyB0aGlzLmFsaWduKHgsIHdpZHRoKSAtIDIgKiBwaXhlbEFsaWduO1xuICAgIGNvbnN0IGF5aCA9IGF5ICsgdGhpcy5hbGlnbih5LCBoZWlnaHQpIC0gMiAqIHBpeGVsQWxpZ247XG4gICAgcGF0aC5tb3ZlVG8oYXgsIGF5KTtcbiAgICBwYXRoLmxpbmVUbyhheHcsIGF5KTtcbiAgICBwYXRoLmxpbmVUbyhheHcsIGF5aCk7XG4gICAgcGF0aC5saW5lVG8oYXgsIGF5aCk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICBjb25zdCBtaW5YID0gdGhpcy5hbGlnbih4ICsgd2lkdGggKiBtaW4pICsgcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBtYXhYID0gbWluWCArIHRoaXMuYWxpZ24oeCArIHdpZHRoICogbWluLCB3aWR0aCAqIChtYXggLSBtaW4pKSAtIDIgKiBwaXhlbEFsaWduO1xuICAgIHBhdGgubW92ZVRvKG1pblgsIGF5KTtcbiAgICBwYXRoLmxpbmVUbyhtaW5YLCBheWgpO1xuICAgIHBhdGgubGluZVRvKG1heFgsIGF5aCk7XG4gICAgcGF0aC5saW5lVG8obWF4WCwgYXkpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5SYW5nZU1hc2suY2xhc3NOYW1lID0gXCJSYW5nZU1hc2tcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL3NoYXBlcy9yYW5nZVNlbGVjdG9yLnRzXG52YXIgUmFuZ2VTZWxlY3RvciA9IGNsYXNzIGV4dGVuZHMgR3JvdXAge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgIHN1cGVyKHsgbmFtZTogXCJyYW5nZVNlbGVjdG9yR3JvdXBcIiwgbGF5ZXI6IHRydWUsIHpJbmRleDogMTQgLyogTkFWSUdBVE9SX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMubE9mZnNldCA9IDA7XG4gICAgdGhpcy5yT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmlzQ29udGFpbmVyTm9kZSA9IHRydWU7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IEdyb3VwKHsgbmFtZTogXCJuYXZpZ2F0b3ItYmFja2dyb3VuZFwiIH0pO1xuICAgIHRoaXMuYmFja2dyb3VuZC56SW5kZXggPSAxO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kKTtcbiAgICB0aGlzLmFwcGVuZChjaGlsZHJlbik7XG4gIH1cbiAgbGF5b3V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGxPZmZzZXQsIHJPZmZzZXQpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubE9mZnNldCA9IGxPZmZzZXQ7XG4gICAgdGhpcy5yT2Zmc2V0ID0gck9mZnNldDtcbiAgICB0aGlzLmJhY2tncm91bmQudHJhbnNsYXRpb25YID0geDtcbiAgICB0aGlzLmJhY2tncm91bmQudHJhbnNsYXRpb25ZID0geTtcbiAgfVxuICB1cGRhdGVCYWNrZ3JvdW5kKG9sZEdyb3VwLCBuZXdHcm91cCkge1xuICAgIGlmIChvbGRHcm91cCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmQucmVtb3ZlQ2hpbGQob2xkR3JvdXApO1xuICAgIH1cbiAgICBpZiAobmV3R3JvdXAgIT0gbnVsbCkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKG5ld0dyb3VwKTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsT2Zmc2V0LCByT2Zmc2V0IH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gbE9mZnNldCwgeSwgd2lkdGggKyAobE9mZnNldCArIHJPZmZzZXQpLCBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3IvbmF2aWdhdG9yLnRzXG52YXIgTmF2aWdhdG9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMubWluaUNoYXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMubWFzayA9IG5ldyBSYW5nZU1hc2soKTtcbiAgICB0aGlzLm1pbkhhbmRsZSA9IG5ldyBSYW5nZUhhbmRsZSgpO1xuICAgIHRoaXMubWF4SGFuZGxlID0gbmV3IFJhbmdlSGFuZGxlKCk7XG4gICAgdGhpcy5tYXNrVmlzaWJsZVJhbmdlID0ge1xuICAgICAgaWQ6IFwibmF2aWdhdG9yLW1hc2stdmlzaWJsZS1yYW5nZVwiLFxuICAgICAgZ2V0QkJveDogKCkgPT4gdGhpcy5tYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCksXG4gICAgICBjb21wdXRlVHJhbnNmb3JtZWRCQm94OiAoKSA9PiB0aGlzLm1hc2suY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKVxuICAgIH07XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLnNwYWNpbmcgPSAxMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5yYW5nZVNlbGVjdG9yID0gbmV3IFJhbmdlU2VsZWN0b3IoW3RoaXMubWFzaywgdGhpcy5taW5IYW5kbGUsIHRoaXMubWF4SGFuZGxlXSk7XG4gICAgdGhpcy5fbWluID0gMDtcbiAgICB0aGlzLl9tYXggPSAxO1xuICAgIHRoaXMubWluUmFuZ2UgPSAxZS0zO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcIm5hdmlnYXRvclwiLCB0aGlzLnJhbmdlU2VsZWN0b3IpO1xuICAgIGNvbnN0IGRyYWdTdGF0ZXMgPSAxNiAvKiBEZWZhdWx0ICovIHwgMSAvKiBBbmltYXRpb24gKi8gfCA4IC8qIFpvb21EcmFnICovO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LnNjZW5lLmF0dGFjaE5vZGUodGhpcy5yYW5nZVNlbGVjdG9yKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnLXN0YXJ0XCIsIChldmVudCkgPT4gdGhpcy5vbkRyYWdTdGFydChldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZ1wiLCAoZXZlbnQpID0+IHRoaXMub25EcmFnKGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnLWVuZFwiLCAoKSA9PiB0aGlzLm9uRHJhZ0VuZCgpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsIChldmVudCkgPT4gdGhpcy5vbkxlYXZlKGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgKCkgPT4gdGhpcy51cGRhdGVab29tKCkpLFxuICAgICAgY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKGV2ZW50KSA9PiB0aGlzLm9uWm9vbUNoYW5nZShldmVudCkpXG4gICAgKTtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhciA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5Q29udGFpbmVyKHtcbiAgICAgIHR5cGU6IFwidG9vbGJhclwiLFxuICAgICAgaWQ6IGBuYXZpZ2F0b3ItdG9vbGJhcmAsXG4gICAgICBjbGFzc0xpc3Q6IFtcImFnLWNoYXJ0cy1wcm94eS1uYXZpZ2F0b3ItdG9vbGJhclwiXSxcbiAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvclwiIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50cyA9IFtcbiAgICAgIHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgIHR5cGU6IFwic2xpZGVyXCIsXG4gICAgICAgIGlkOiBcImFnLWNoYXJ0cy1uYXZpZ2F0b3ItbWluXCIsXG4gICAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxOYXZpZ2F0b3JNaW5pbXVtXCIgfSxcbiAgICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgICAgZm9jdXNhYmxlOiB0aGlzLm1pbkhhbmRsZSxcbiAgICAgICAgb25jaGFuZ2U6IChldikgPT4gdGhpcy5vbk1pblNsaWRlckNoYW5nZShldilcbiAgICAgIH0pLFxuICAgICAgdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgaWQ6IFwiYWctY2hhcnRzLW5hdmlnYXRvci1wYW5cIixcbiAgICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvclJhbmdlXCIgfSxcbiAgICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgICAgZm9jdXNhYmxlOiB0aGlzLm1hc2tWaXNpYmxlUmFuZ2UsXG4gICAgICAgIG9uY2hhbmdlOiAoZXYpID0+IHRoaXMub25QYW5TbGlkZXJDaGFuZ2UoZXYpXG4gICAgICB9KSxcbiAgICAgIHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgIHR5cGU6IFwic2xpZGVyXCIsXG4gICAgICAgIGlkOiBcImFnLWNoYXJ0cy1uYXZpZ2F0b3ItbWF4XCIsXG4gICAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxOYXZpZ2F0b3JNYXhpbXVtXCIgfSxcbiAgICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgICAgZm9jdXNhYmxlOiB0aGlzLm1heEhhbmRsZSxcbiAgICAgICAgb25jaGFuZ2U6IChldikgPT4gdGhpcy5vbk1heFNsaWRlckNoYW5nZShldilcbiAgICAgIH0pXG4gICAgXTtcbiAgICBpbml0VG9vbGJhcktleU5hdih7XG4gICAgICBvcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgdG9vbGJhcjogdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsXG4gICAgICBidXR0b25zOiB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNcbiAgICB9KTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCgoKSA9PiB7XG4gICAgICB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhci5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVCYWNrZ3JvdW5kKG9sZEdyb3VwLCBuZXdHcm91cCkge1xuICAgIHRoaXMucmFuZ2VTZWxlY3Rvcj8udXBkYXRlQmFja2dyb3VuZChvbGRHcm91cCwgbmV3R3JvdXApO1xuICB9XG4gIHVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMucmFuZ2VTZWxlY3RvciA9PSBudWxsIHx8IGVuYWJsZWQgPT09IHRoaXMucmFuZ2VTZWxlY3Rvci52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmFuZ2VTZWxlY3Rvci52aXNpYmxlID0gZW5hYmxlZDtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhci5hcmlhSGlkZGVuID0gKCFlbmFibGVkKS50b1N0cmluZygpO1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcIm5hdmlnYXRvclwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBjb25zdCB7IHNocmlua1JlY3QgfSA9IGN0eDtcbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICBjb25zdCBuYXZpZ2F0b3JUb3RhbEhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5zcGFjaW5nO1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsobmF2aWdhdG9yVG90YWxIZWlnaHQsIFwiYm90dG9tXCIpO1xuICAgICAgdGhpcy55ID0gc2hyaW5rUmVjdC55ICsgc2hyaW5rUmVjdC5oZWlnaHQgKyB0aGlzLnNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmN0eCwgc2hyaW5rUmVjdCB9O1xuICB9XG4gIGFzeW5jIHBlcmZvcm1DYXJ0ZXNpYW5MYXlvdXQob3B0cykge1xuICAgIGNvbnN0IHsgeCwgd2lkdGggfSA9IG9wdHMuc2VyaWVzUmVjdDtcbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICBjb25zdCB7IHksIGhlaWdodCB9ID0gdGhpcztcbiAgICAgIHRoaXMubGF5b3V0Tm9kZXMoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBzZXRFbGVtZW50QkJveCh0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhciwgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB9XG4gIG9uSG92ZXIoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG1hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgaWYgKG1pbkhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpIHx8IG1heEhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihcIm5hdmlnYXRvclwiLCBcImV3LXJlc2l6ZVwiKTtcbiAgICB9IGVsc2UgaWYgKG1hc2suY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihcIm5hdmlnYXRvclwiLCBcImdyYWJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIpO1xuICAgIH1cbiAgfVxuICBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGUsIHgsIHdpZHRoLCBfbWluOiBtaW4gfSA9IHRoaXM7XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAobWluSGFuZGxlLnpJbmRleCA8IG1heEhhbmRsZS56SW5kZXgpIHtcbiAgICAgIGlmIChtYXhIYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gXCJtYXhcIjtcbiAgICAgIH0gZWxzZSBpZiAobWluSGFuZGxlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWluXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW5IYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWluXCI7XG4gICAgfSBlbHNlIGlmIChtYXhIYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWF4XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgbWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcInBhblwiO1xuICAgICAgdGhpcy5wYW5TdGFydCA9IChvZmZzZXRYIC0geCkgLyB3aWR0aCAtIG1pbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuZmlyZVpvb21QYW5TdGFydEV2ZW50KFwibmF2aWdhdG9yXCIpO1xuICAgIH1cbiAgfVxuICBvbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkcmFnZ2luZywgbWluUmFuZ2UsIHBhblN0YXJ0LCB4LCB3aWR0aCB9ID0gdGhpcztcbiAgICBsZXQgeyBfbWluOiBtaW4sIF9tYXg6IG1heCB9ID0gdGhpcztcbiAgICBjb25zdCB7IG9mZnNldFggfSA9IGV2ZW50O1xuICAgIGNvbnN0IHJhdGlvMiA9IChvZmZzZXRYIC0geCkgLyB3aWR0aDtcbiAgICBpZiAoZHJhZ2dpbmcgPT09IFwibWluXCIpIHtcbiAgICAgIG1pbiA9IGNsYW1wKDAsIHJhdGlvMiwgbWF4IC0gbWluUmFuZ2UpO1xuICAgIH0gZWxzZSBpZiAoZHJhZ2dpbmcgPT09IFwibWF4XCIpIHtcbiAgICAgIG1heCA9IGNsYW1wKG1pbiArIG1pblJhbmdlLCByYXRpbzIsIDEpO1xuICAgIH0gZWxzZSBpZiAoZHJhZ2dpbmcgPT09IFwicGFuXCIgJiYgcGFuU3RhcnQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3BhbiA9IG1heCAtIG1pbjtcbiAgICAgIG1pbiA9IGNsYW1wKDAsIHJhdGlvMiAtIHBhblN0YXJ0LCAxIC0gc3Bhbik7XG4gICAgICBtYXggPSBtaW4gKyBzcGFuO1xuICAgIH1cbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICB9XG4gIG9uRHJhZ0VuZCgpIHtcbiAgICB0aGlzLmRyYWdnaW5nID0gdm9pZCAwO1xuICB9XG4gIG9uTGVhdmUoX2V2ZW50KSB7XG4gICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IoXCJuYXZpZ2F0b3JcIik7XG4gIH1cbiAgb25ab29tQ2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3QgeyB4IH0gPSBldmVudDtcbiAgICBpZiAoIXgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fbWluID0geC5taW47XG4gICAgdGhpcy5fbWF4ID0geC5tYXg7XG4gICAgdGhpcy51cGRhdGVOb2Rlcyh4Lm1pbiwgeC5tYXgpO1xuICAgIHRoaXMuc2V0UGFuU2xpZGVyVmFsdWUoeC5taW4sIHgubWF4KTtcbiAgICB0aGlzLnNldFNsaWRlclJhdGlvKHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1swXSwgeC5taW4pO1xuICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzJdLCB4Lm1heCk7XG4gIH1cbiAgb25QYW5TbGlkZXJDaGFuZ2UoX2V2ZW50KSB7XG4gICAgY29uc3QgcmF0aW8yID0gdGhpcy5nZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMV0pO1xuICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9tYXggLSB0aGlzLl9taW47XG4gICAgdGhpcy5fbWluID0gY2xhbXAoMCwgcmF0aW8yLCAxIC0gc3Bhbik7XG4gICAgdGhpcy5fbWF4ID0gdGhpcy5fbWluICsgc3BhbjtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBvbk1pblNsaWRlckNoYW5nZShfZXZlbnQpIHtcbiAgICBjb25zdCBzbGlkZXIgPSB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMF07XG4gICAgdGhpcy5fbWluID0gdGhpcy5zZXRTbGlkZXJSYXRpb0NsYW1wZWQoc2xpZGVyLCAwLCB0aGlzLl9tYXggLSB0aGlzLm1pblJhbmdlKTtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBvbk1heFNsaWRlckNoYW5nZShfZXZlbnQpIHtcbiAgICBjb25zdCBzbGlkZXIgPSB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMl07XG4gICAgdGhpcy5fbWF4ID0gdGhpcy5zZXRTbGlkZXJSYXRpb0NsYW1wZWQoc2xpZGVyLCB0aGlzLl9taW4gKyB0aGlzLm1pblJhbmdlLCAxKTtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBzZXRQYW5TbGlkZXJWYWx1ZShtaW4sIG1heCkge1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1sxXS52YWx1ZSA9IGAke01hdGgucm91bmQobWluICogMTAwKX1gO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1sxXS5hcmlhVmFsdWVUZXh0ID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYVZhbHVlUGFuUmFuZ2VcIiwgeyBtaW4sIG1heCB9KTtcbiAgfVxuICBzZXRTbGlkZXJSYXRpb0NsYW1wZWQoc2xpZGVyLCBjbGFtcE1pbiwgY2xhbXBNYXgpIHtcbiAgICBjb25zdCByYXRpbzIgPSB0aGlzLmdldFNsaWRlclJhdGlvKHNsaWRlcik7XG4gICAgY29uc3QgY2xhbXBlZFJhdGlvID0gY2xhbXAoY2xhbXBNaW4sIHJhdGlvMiwgY2xhbXBNYXgpO1xuICAgIGlmIChjbGFtcGVkUmF0aW8gIT09IHJhdGlvMikge1xuICAgICAgdGhpcy5zZXRTbGlkZXJSYXRpbyhzbGlkZXIsIGNsYW1wZWRSYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcGVkUmF0aW87XG4gIH1cbiAgc2V0U2xpZGVyUmF0aW8oc2xpZGVyLCByYXRpbzIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE1hdGgucm91bmQocmF0aW8yICogMTAwKTtcbiAgICBzbGlkZXIudmFsdWUgPSBgJHt2YWx1ZX1gO1xuICAgIHNsaWRlci5hcmlhVmFsdWVUZXh0ID0gZm9ybWF0UGVyY2VudGFnZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0U2xpZGVyUmF0aW8oc2xpZGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc2xpZGVyLnZhbHVlKSAvIDEwMDtcbiAgfVxuICBsYXlvdXROb2Rlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeyByYW5nZVNlbGVjdG9yLCBtYXNrLCBtaW5IYW5kbGUsIG1heEhhbmRsZSwgX21pbjogbWluLCBfbWF4OiBtYXggfSA9IHRoaXM7XG4gICAgcmFuZ2VTZWxlY3Rvci5sYXlvdXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluSGFuZGxlLndpZHRoIC8gMiwgbWF4SGFuZGxlLndpZHRoIC8gMik7XG4gICAgbWFzay5sYXlvdXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgUmFuZ2VIYW5kbGUuYWxpZ24obWluSGFuZGxlLCBtYXhIYW5kbGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbiwgbWF4KTtcbiAgICBpZiAobWluICsgKG1heCAtIG1pbikgLyAyIDwgMC41KSB7XG4gICAgICBtaW5IYW5kbGUuekluZGV4ID0gMztcbiAgICAgIG1heEhhbmRsZS56SW5kZXggPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5IYW5kbGUuekluZGV4ID0gNDtcbiAgICAgIG1heEhhbmRsZS56SW5kZXggPSAzO1xuICAgIH1cbiAgICBbbWluSGFuZGxlLCB0aGlzLm1hc2tWaXNpYmxlUmFuZ2UsIG1heEhhbmRsZV0uZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGJib3ggPSBub2RlLmdldEJCb3goKTtcbiAgICAgIGNvbnN0IHRib3ggPSB7IHg6IGJib3gueCAtIHgsIHk6IGJib3gueSAtIHksIGhlaWdodDogYmJveC5oZWlnaHQsIHdpZHRoOiBiYm94LndpZHRoIH07XG4gICAgICBzZXRFbGVtZW50QkJveCh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbaW5kZXhdLCB0Ym94KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVOb2RlcyhtaW4sIG1heCkge1xuICAgIHRoaXMubWFzay51cGRhdGUobWluLCBtYXgpO1xuICB9XG4gIHVwZGF0ZVpvb20oKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBfbWluOiBtaW4sIF9tYXg6IG1heCB9ID0gdGhpcztcbiAgICBpZiAobWluID09IG51bGwgfHwgbWF4ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgd2Fybk9uQ29uZmxpY3QgPSAoc3RhdGVJZCkgPT4ge1xuICAgICAgaWYgKHRoaXMubWluID09IG51bGwgJiYgdGhpcy5tYXggPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICBgQ291bGQgbm90IGFwcGx5IFtuYXZpZ2F0b3IubWluXSBvciBbbmF2aWdhdG9yLm1heF0gYXMgWyR7c3RhdGVJZH1dIGhhcyBtb2RpZmllZCB0aGUgaW5pdGlhbCB6b29tIHN0YXRlLmBcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcIm5hdmlnYXRvclwiLCB7IHg6IHsgbWluLCBtYXggfSB9LCBmYWxzZSwgd2Fybk9uQ29uZmxpY3QpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcIm1pbmlDaGFydFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkpXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShtaW4pIHtcbiAgICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICAgIH1cbiAgfSksXG4gIFZhbGlkYXRlKEFORChSQVRJTywgTEVTU19USEFOKFwibWF4XCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUobWF4KSB7XG4gICAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgICB9XG4gIH0pLFxuICBWYWxpZGF0ZShBTkQoUkFUSU8sIEdSRUFURVJfVEhBTihcIm1pblwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3IvbmF2aWdhdG9yTW9kdWxlLnRzXG52YXIgTmF2aWdhdG9yTW9kdWxlID0ge1xuICB0eXBlOiBcInJvb3RcIixcbiAgb3B0aW9uc0tleTogXCJuYXZpZ2F0b3JcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IE5hdmlnYXRvcihjdHgpLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgbmF2aWdhdG9yOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGhlaWdodDogMzAsXG4gICAgICBtYXNrOiB7XG4gICAgICAgIGZpbGw6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2U6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMlxuICAgICAgfSxcbiAgICAgIG1pbkhhbmRsZToge1xuICAgICAgICBmaWxsOiBcIiNmMmYyZjJcIixcbiAgICAgICAgc3Ryb2tlOiBcIiM5OTk5OTlcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHdpZHRoOiA5LFxuICAgICAgICBoZWlnaHQ6IDE2LFxuICAgICAgICBncmlwTGluZUdhcDogMSxcbiAgICAgICAgZ3JpcExpbmVMZW5ndGg6IDhcbiAgICAgIH0sXG4gICAgICBtYXhIYW5kbGU6IHtcbiAgICAgICAgZmlsbDogXCIjZjJmMmYyXCIsXG4gICAgICAgIHN0cm9rZTogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICB3aWR0aDogOSxcbiAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgZ3JpcExpbmVHYXA6IDEsXG4gICAgICAgIGdyaXBMaW5lTGVuZ3RoOiA4XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvdGhlbWUudHNcbmZ1bmN0aW9uIHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5KHsgdGFrZUNvbG9ycyB9KSB7XG4gIGNvbnN0IHtcbiAgICBmaWxsczogW2ZpbGxdLFxuICAgIHN0cm9rZXM6IFtzdHJva2VdXG4gIH0gPSB0YWtlQ29sb3JzKDEpO1xuICByZXR1cm4geyBmaWxsLCBzdHJva2UgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcykge1xuICByZXR1cm4geyBtYXJrZXI6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5KHBhcmFtcykgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2NvbnN0YW50cy50c1xudmFyIEZPTlRfU0laRSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZPTlRfU0laRTIpID0+IHtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiU01BTExcIl0gPSAxMl0gPSBcIlNNQUxMXCI7XG4gIEZPTlRfU0laRTJbRk9OVF9TSVpFMltcIk1FRElVTVwiXSA9IDEzXSA9IFwiTUVESVVNXCI7XG4gIEZPTlRfU0laRTJbRk9OVF9TSVpFMltcIkxBUkdFXCJdID0gMTddID0gXCJMQVJHRVwiO1xuICByZXR1cm4gRk9OVF9TSVpFMjtcbn0pKEZPTlRfU0laRSB8fCB7fSk7XG52YXIgRk9OVF9XRUlHSFQyID0gLyogQF9fUFVSRV9fICovICgoRk9OVF9XRUlHSFQzKSA9PiB7XG4gIEZPTlRfV0VJR0hUM1tcIk5PUk1BTFwiXSA9IFwibm9ybWFsXCI7XG4gIEZPTlRfV0VJR0hUM1tcIkJPTERcIl0gPSBcImJvbGRcIjtcbiAgRk9OVF9XRUlHSFQzW1wiQk9MREVSXCJdID0gXCJib2xkZXJcIjtcbiAgRk9OVF9XRUlHSFQzW1wiTElHSFRFUlwiXSA9IFwibGlnaHRlclwiO1xuICByZXR1cm4gRk9OVF9XRUlHSFQzO1xufSkoRk9OVF9XRUlHSFQyIHx8IHt9KTtcbnZhciBQT1NJVElPTjIgPSAvKiBAX19QVVJFX18gKi8gKChQT1NJVElPTjMpID0+IHtcbiAgUE9TSVRJT04zW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgUE9TSVRJT04zW1wiUklHSFRcIl0gPSBcInJpZ2h0XCI7XG4gIFBPU0lUSU9OM1tcIkJPVFRPTVwiXSA9IFwiYm90dG9tXCI7XG4gIFBPU0lUSU9OM1tcIkxFRlRcIl0gPSBcImxlZnRcIjtcbiAgcmV0dXJuIFBPU0lUSU9OMztcbn0pKFBPU0lUSU9OMiB8fCB7fSk7XG52YXIgQ0FSVEVTSUFOX0FYSVNfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKENBUlRFU0lBTl9BWElTX1RZUEUyKSA9PiB7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiQ0FURUdPUllcIl0gPSBcImNhdGVnb3J5XCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiT1JESU5BTF9USU1FXCJdID0gXCJvcmRpbmFsLXRpbWVcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJOVU1CRVJcIl0gPSBcIm51bWJlclwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIlRJTUVcIl0gPSBcInRpbWVcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJMT0dcIl0gPSBcImxvZ1wiO1xuICByZXR1cm4gQ0FSVEVTSUFOX0FYSVNfVFlQRTI7XG59KShDQVJURVNJQU5fQVhJU19UWVBFIHx8IHt9KTtcbnZhciBQT0xBUl9BWElTX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChQT0xBUl9BWElTX1RZUEUyKSA9PiB7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJBTkdMRV9DQVRFR09SWVwiXSA9IFwiYW5nbGUtY2F0ZWdvcnlcIjtcbiAgUE9MQVJfQVhJU19UWVBFMltcIkFOR0xFX05VTUJFUlwiXSA9IFwiYW5nbGUtbnVtYmVyXCI7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJSQURJVVNfQ0FURUdPUllcIl0gPSBcInJhZGl1cy1jYXRlZ29yeVwiO1xuICBQT0xBUl9BWElTX1RZUEUyW1wiUkFESVVTX05VTUJFUlwiXSA9IFwicmFkaXVzLW51bWJlclwiO1xuICByZXR1cm4gUE9MQVJfQVhJU19UWVBFMjtcbn0pKFBPTEFSX0FYSVNfVFlQRSB8fCB7fSk7XG52YXIgUE9MQVJfQVhJU19TSEFQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFBPTEFSX0FYSVNfU0hBUEUyKSA9PiB7XG4gIFBPTEFSX0FYSVNfU0hBUEUyW1wiQ0lSQ0xFXCJdID0gXCJjaXJjbGVcIjtcbiAgUE9MQVJfQVhJU19TSEFQRTJbXCJQT0xZR09OXCJdID0gXCJwb2x5Z29uXCI7XG4gIHJldHVybiBQT0xBUl9BWElTX1NIQVBFMjtcbn0pKFBPTEFSX0FYSVNfU0hBUEUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvc3ltYm9scy50c1xudmFyIElTX0RBUktfVEhFTUUgPSBTeW1ib2woXCJpcy1kYXJrLXRoZW1lXCIpO1xudmFyIERFRkFVTFRfRk9OVF9GQU1JTFkgPSBTeW1ib2woXCJkZWZhdWx0LWZvbnRcIik7XG52YXIgREVGQVVMVF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtaW52ZXJ0ZWQtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWluc2lkZS1zZXJpZXMtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1tdXRlZC1sYWJlbC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9BWElTX0dSSURfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1heGlzLWdyaWQtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtYXhpcy1saW5lLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtY3Jvc3MtbGluZXMtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWJhY2tncm91bmQtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfU0hBRE9XX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtc2hhZG93LWNvbG91clwiKTtcbnZhciBERUZBVUxUX0NPTE9VUlMgPSBTeW1ib2woXCJkZWZhdWx0LWNvbG91cnNcIik7XG52YXIgREVGQVVMVF9QQURESU5HID0gU3ltYm9sKFwiZGVmYXVsdC1wYWRkaW5nXCIpO1xudmFyIERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUgPSBTeW1ib2woXCJkZWZhdWx0LWNhcHRpb24tbGF5b3V0LXN0eWxlXCIpO1xudmFyIERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQgPSBTeW1ib2woXCJkZWZhdWx0LWNhcHRpb24tYWxpZ25tZW50XCIpO1xudmFyIFBBTEVUVEVfVVBfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS11cC1zdHJva2VcIik7XG52YXIgUEFMRVRURV9ET1dOX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtZG93bi1zdHJva2VcIik7XG52YXIgUEFMRVRURV9VUF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS11cC1maWxsXCIpO1xudmFyIFBBTEVUVEVfRE9XTl9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1kb3duLWZpbGxcIik7XG52YXIgUEFMRVRURV9ORVVUUkFMX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtbmV1dHJhbC1zdHJva2VcIik7XG52YXIgUEFMRVRURV9ORVVUUkFMX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLW5ldXRyYWwtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0FMVF9VUF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWFsdC11cC1zdHJva2VcIik7XG52YXIgUEFMRVRURV9BTFRfRE9XTl9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWFsdC1kb3duLXN0cm9rZVwiKTtcbnZhciBQQUxFVFRFX0FMVF9VUF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtdXAtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0FMVF9ET1dOX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLWFsdC1kb3duLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1ncmF5LWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWdyYXktc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSA9IFN5bWJvbChcImRlZmF1bHQtcG9sYXItc2VyaWVzLXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFID0gU3ltYm9sKFxuICBcImRlZmF1bHQtZGl2ZXJnaW5nLXNlcmllcy1jb2xvdXItcmFuZ2VcIlxuKTtcbnZhciBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyA9IFN5bWJvbChcImRlZmF1bHQtaGllcmFyY2h5LWZpbGxzXCIpO1xudmFyIERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMgPSBTeW1ib2woXCJkZWZhdWx0LWhpZXJhcmNoeS1zdHJva2VzXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1zdHJva2VcIik7XG52YXIgREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LXRleHQtYW5ub3RhdGlvbi1jb2xvclwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLWJhY2tncm91bmQtZmlsbFwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24taGFuZGxlLWZpbGxcIik7XG52YXIgREVGQVVMVF9URVhUQk9YX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtZmlsbFwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfU1RST0tFID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0Ym94LXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtY29sb3JcIik7XG52YXIgREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OID0gU3ltYm9sKFwiZGVmYXVsdC10b29sYmFyLXBvc2l0aW9uXCIpO1xudmFyIERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCA9IFN5bWJvbChcImRlZmF1bHQtZ3JpZGxpbmUtZW5hYmxlZFwiKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL3BhdGhNb3Rpb24udHNcbmZ1bmN0aW9uIHBhdGhNb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHBhdGhzLCBmbnMpIHtcbiAgY29uc3QgeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0gPSBmbnM7XG4gIGNvbnN0IGFuaW1hdGUgPSAocGhhc2UsIHBhdGgsIHVwZGF0ZUZuKSA9PiB7XG4gICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfV8ke3BhdGguaWR9XyR7cGhhc2V9YCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDEsXG4gICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgY29sbGFwc2FibGU6IGZhbHNlLFxuICAgICAgb25VcGRhdGUocmF0aW8yLCBwcmVJbml0KSB7XG4gICAgICAgIGlmIChwcmVJbml0ICYmIHBoYXNlICE9PSBcInJlbW92ZWRcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBhdGgucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdXBkYXRlRm4ocmF0aW8yLCBwYXRoKTtcbiAgICAgICAgcGF0aC5jaGVja1BhdGhEaXJ0eSgpO1xuICAgICAgfSxcbiAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgaWYgKHBoYXNlICE9PSBcImFkZGVkXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXRoLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICAgIHVwZGF0ZUZuKDEsIHBhdGgpO1xuICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICB9LFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdXG4gICAgfSk7XG4gIH07XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmICghYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgYW5pbWF0ZShcInJlbW92ZWRcIiwgcGF0aCwgcmVtb3ZlUGhhc2VGbik7XG4gICAgICBhbmltYXRlKFwidXBkYXRlZFwiLCBwYXRoLCB1cGRhdGVQaGFzZUZuKTtcbiAgICB9XG4gICAgYW5pbWF0ZShcImFkZGVkXCIsIHBhdGgsIGFkZFBoYXNlRm4pO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2FuaXRpemUudHNcbnZhciBlbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHNhbml0aXplSHRtbCh0ZXh0KSB7XG4gIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodGV4dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGVsZW1lbnQgPz8gKGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgZWxlbWVudC50ZXh0Q29udGVudCA9IFN0cmluZyh0ZXh0KTtcbiAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzTGFiZWxVdGlsLnRzXG5mdW5jdGlvbiBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5sYWJlbFNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIHN1YklkLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbGFiZWxTZWxlY3Rpb25zLFxuICAgIHsgb3BhY2l0eTogMCB9LFxuICAgIHsgb3BhY2l0eTogMSB9LFxuICAgIHsgcGhhc2U6IFwidHJhaWxpbmdcIiB9XG4gICk7XG59XG5mdW5jdGlvbiBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubGFiZWxTZWxlY3Rpb25zKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICBpZCxcbiAgICBzdWJJZCxcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIGxhYmVsU2VsZWN0aW9ucyxcbiAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICB7IHBoYXNlOiBcInJlbW92ZVwiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc2V0TGFiZWxGbihfbm9kZSkge1xuICByZXR1cm4geyBvcGFjaXR5OiAxIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvY2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMudHNcbnZhciBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2RpcnR5ID0gMyAvKiBNQUpPUiAqLztcbiAgfVxuICBtYXJrRGlydHkoX3NvdXJjZSwgdHlwZSA9IDEgLyogVFJJVklBTCAqLykge1xuICAgIGlmICh0aGlzLl9kaXJ0eSA8IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RpcnR5ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgbWFya0NsZWFuKF9vcHRzKSB7XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHkgPiAwIC8qIE5PTkUgKi87XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2Ryb3BTaGFkb3cudHNcbnZhciBEcm9wU2hhZG93ID0gY2xhc3MgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIjtcbiAgICB0aGlzLnhPZmZzZXQgPSAwO1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gICAgdGhpcy5ibHVyID0gNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJ4T2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcInlPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiYmx1clwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc01hcmtlci50c1xudmFyIE1BUktFUl9TSEFQRSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUpID0+IGlzTWFya2VyU2hhcGUodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIE9iamVjdC5jcmVhdGUodmFsdWUucHJvdG90eXBlKSBpbnN0YW5jZW9mIE1hcmtlcixcbiAgYGEgbWFya2VyIHNoYXBlIGtleXdvcmQgc3VjaCBhcyAnY2lyY2xlJywgJ2RpYW1vbmQnIG9yICdzcXVhcmUnIG9yIGFuIG9iamVjdCBleHRlbmRpbmcgdGhlIE1hcmtlciBjbGFzc2Bcbik7XG52YXIgU2VyaWVzTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNoYXBlID0gQ2lyY2xlO1xuICAgIHRoaXMuc2l6ZSA9IDY7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgfVxuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9ID0gdGhpcztcbiAgICByZXR1cm4geyBzaXplLCBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfTtcbiAgfVxuICBnZXREaWFtZXRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFSS0VSX1NIQVBFKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1Rvb2x0aXAudHNcbnZhciBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgU2VyaWVzVG9vbHRpcCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRvb2x0aXBQb3NpdGlvbigpO1xuICAgIHRoaXMucmFuZ2UgPSB2b2lkIDA7XG4gIH1cbiAgdG9Ub29sdGlwSHRtbChkZWZhdWx0cywgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB0b1Rvb2x0aXBIdG1sKHRoaXMucmVuZGVyZXIocGFyYW1zKSwgZGVmYXVsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9Ub29sdGlwSHRtbChkZWZhdWx0cyk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInNob3dBcnJvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcImludGVyYWN0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaW50ZXJwb2xhdGlvblByb3BlcnRpZXMudHNcbnZhciBJTlRFUlBPTEFUSU9OX1RZUEUgPSBVTklPTihbXCJsaW5lYXJcIiwgXCJzbW9vdGhcIiwgXCJzdGVwXCJdLCBcImEgbGluZSBzdHlsZVwiKTtcbnZhciBJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT04gPSBVTklPTihbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG52YXIgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImxpbmVhclwiO1xuICAgIHRoaXMudGVuc2lvbiA9IDE7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiZW5kXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUlBPTEFUSU9OX1RZUEUpXG5dLCBJbnRlcnBvbGF0aW9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMucHJvdG90eXBlLCBcInRlbnNpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT04pXG5dLCBJbnRlcnBvbGF0aW9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBBcmVhU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54TmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGwgPSBcIiNjMTYwNjhcIjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IFwiIzg3NDM0OVwiO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBuZXcgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgU2VyaWVzTWFya2VyKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgdGhpcy5jb25uZWN0TWlzc2luZ0RhdGEgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9ybWFsaXplZFRvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImludGVycG9sYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb25uZWN0TWlzc2luZ0RhdGFcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvYmV6aWVyLnRzXG5mdW5jdGlvbiBldmFsdWF0ZUJlemllcihwMCwgcDEsIHAyLCBwMywgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqKiAzICogcDAgKyAzICogKDEgLSB0KSAqKiAyICogdCAqIHAxICsgMyAqICgxIC0gdCkgKyB0ICoqIDIgKiBwMiArIHQgKiogMyAqIHAzO1xufVxuZnVuY3Rpb24gc29sdmVCZXppZXIocDAsIHAxLCBwMiwgcDMsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA8PSBNYXRoLm1pbihwMCwgcDMpKSB7XG4gICAgcmV0dXJuIHAwIDwgcDMgPyAwIDogMTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA+PSBNYXRoLm1heChwMCwgcDMpKSB7XG4gICAgcmV0dXJuIHAwIDwgcDMgPyAxIDogMDtcbiAgfVxuICBsZXQgdDAgPSAwO1xuICBsZXQgdDEgPSAxO1xuICBsZXQgdCA9IE5hTjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICB0ID0gKHQwICsgdDEpIC8gMjtcbiAgICBjb25zdCBjdXJ2ZVZhbHVlID0gKDEgLSB0KSAqKiAzICogcDAgKyAzICogKDEgLSB0KSAqKiAyICogdCAqIHAxICsgMyAqICgxIC0gdCkgKiB0ICoqIDIgKiBwMiArIHQgKiogMyAqIHAzO1xuICAgIGlmIChjdXJ2ZVZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIHQwID0gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgPSB0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHNwbGl0QmV6aWVyKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCB0KSB7XG4gIGNvbnN0IHgwMSA9ICgxIC0gdCkgKiBwMHggKyB0ICogcDF4O1xuICBjb25zdCB5MDEgPSAoMSAtIHQpICogcDB5ICsgdCAqIHAxeTtcbiAgY29uc3QgeDEyID0gKDEgLSB0KSAqIHAxeCArIHQgKiBwMng7XG4gIGNvbnN0IHkxMiA9ICgxIC0gdCkgKiBwMXkgKyB0ICogcDJ5O1xuICBjb25zdCB4MjMgPSAoMSAtIHQpICogcDJ4ICsgdCAqIHAzeDtcbiAgY29uc3QgeTIzID0gKDEgLSB0KSAqIHAyeSArIHQgKiBwM3k7XG4gIGNvbnN0IHgwMTIgPSAoMSAtIHQpICogeDAxICsgdCAqIHgxMjtcbiAgY29uc3QgeTAxMiA9ICgxIC0gdCkgKiB5MDEgKyB0ICogeTEyO1xuICBjb25zdCB4MTIzID0gKDEgLSB0KSAqIHgxMiArIHQgKiB4MjM7XG4gIGNvbnN0IHkxMjMgPSAoMSAtIHQpICogeTEyICsgdCAqIHkyMztcbiAgY29uc3QgeDAxMjMgPSAoMSAtIHQpICogeDAxMiArIHQgKiB4MTIzO1xuICBjb25zdCB5MDEyMyA9ICgxIC0gdCkgKiB5MDEyICsgdCAqIHkxMjM7XG4gIHJldHVybiBbXG4gICAgW1xuICAgICAgeyB4OiBwMHgsIHk6IHAweSB9LFxuICAgICAgeyB4OiB4MDEsIHk6IHkwMSB9LFxuICAgICAgeyB4OiB4MDEyLCB5OiB5MDEyIH0sXG4gICAgICB7IHg6IHgwMTIzLCB5OiB5MDEyMyB9XG4gICAgXSxcbiAgICBbXG4gICAgICB7IHg6IHgwMTIzLCB5OiB5MDEyMyB9LFxuICAgICAgeyB4OiB4MTIzLCB5OiB5MTIzIH0sXG4gICAgICB7IHg6IHgyMywgeTogeTIzIH0sXG4gICAgICB7IHg6IHAzeCwgeTogcDN5IH1cbiAgICBdXG4gIF07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZUludGVycG9sYXRpb24udHNcbmZ1bmN0aW9uIHNwYW5SYW5nZShzcGFuKSB7XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHg6IHNwYW4ueDAsIHk6IHNwYW4ueTAgfSxcbiAgICAgICAgeyB4OiBzcGFuLngxLCB5OiBzcGFuLnkxIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHg6IHNwYW4uY3AweCwgeTogc3Bhbi5jcDB5IH0sXG4gICAgICAgIHsgeDogc3Bhbi5jcDN4LCB5OiBzcGFuLmNwM3kgfVxuICAgICAgXTtcbiAgfVxufVxuZnVuY3Rpb24gcmV2ZXJzZVNwYW4oc3Bhbikge1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiBzcGFuLngxLFxuICAgICAgICB5MDogc3Bhbi55MSxcbiAgICAgICAgeDE6IHNwYW4ueDAsXG4gICAgICAgIHkxOiBzcGFuLnkwXG4gICAgICB9O1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICBjcDB4OiBzcGFuLmNwM3gsXG4gICAgICAgIGNwMHk6IHNwYW4uY3AzeSxcbiAgICAgICAgY3AxeDogc3Bhbi5jcDJ4LFxuICAgICAgICBjcDF5OiBzcGFuLmNwMnksXG4gICAgICAgIGNwMng6IHNwYW4uY3AxeCxcbiAgICAgICAgY3AyeTogc3Bhbi5jcDF5LFxuICAgICAgICBjcDN4OiBzcGFuLmNwMHgsXG4gICAgICAgIGNwM3k6IHNwYW4uY3AweVxuICAgICAgfTtcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdGVwXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiBzcGFuLngxLFxuICAgICAgICB5MDogc3Bhbi55MSxcbiAgICAgICAgeDE6IHNwYW4ueDAsXG4gICAgICAgIHkxOiBzcGFuLnkwLFxuICAgICAgICBzdGVwWDogc3Bhbi5zdGVwWFxuICAgICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY29sbGFwc2VTcGFuVG9Qb2ludChzcGFuLCBwb2ludCkge1xuICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiB4LFxuICAgICAgICB5MDogeSxcbiAgICAgICAgeDE6IHgsXG4gICAgICAgIHkxOiB5XG4gICAgICB9O1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0ZXBcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IHgsXG4gICAgICAgIHkwOiB5LFxuICAgICAgICB4MTogeCxcbiAgICAgICAgeTE6IHksXG4gICAgICAgIHN0ZXBYOiB4XG4gICAgICB9O1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICBjcDB4OiB4LFxuICAgICAgICBjcDB5OiB5LFxuICAgICAgICBjcDF4OiB4LFxuICAgICAgICBjcDF5OiB5LFxuICAgICAgICBjcDJ4OiB4LFxuICAgICAgICBjcDJ5OiB5LFxuICAgICAgICBjcDN4OiB4LFxuICAgICAgICBjcDN5OiB5XG4gICAgICB9O1xuICB9XG59XG5mdW5jdGlvbiByZXNjYWxlU3BhbihzcGFuLCBuZXh0U3RhcnQsIG5leHRFbmQpIHtcbiAgY29uc3QgW3ByZXZTdGFydCwgcHJldkVuZF0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHdpZHRoU2NhbGUgPSBwcmV2RW5kLnggIT09IHByZXZTdGFydC54ID8gKG5leHRFbmQueCAtIG5leHRTdGFydC54KSAvIChwcmV2RW5kLnggLSBwcmV2U3RhcnQueCkgOiAwO1xuICBjb25zdCBoZWlnaHRTY2FsZSA9IHByZXZFbmQueSAhPT0gcHJldlN0YXJ0LnkgPyAobmV4dEVuZC55IC0gbmV4dFN0YXJ0LnkpIC8gKHByZXZFbmQueSAtIHByZXZTdGFydC55KSA6IDA7XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IG5leHRTdGFydC54LFxuICAgICAgICB5MDogbmV4dFN0YXJ0LnksXG4gICAgICAgIHgxOiBuZXh0RW5kLngsXG4gICAgICAgIHkxOiBuZXh0RW5kLnlcbiAgICAgIH07XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIGNwMHg6IG5leHRTdGFydC54LFxuICAgICAgICBjcDB5OiBuZXh0U3RhcnQueSxcbiAgICAgICAgY3AxeDogbmV4dEVuZC54IC0gKHNwYW4uY3AyeCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGUsXG4gICAgICAgIGNwMXk6IG5leHRFbmQueSAtIChzcGFuLmNwMnkgLSBwcmV2U3RhcnQueSkgKiBoZWlnaHRTY2FsZSxcbiAgICAgICAgY3AyeDogbmV4dEVuZC54IC0gKHNwYW4uY3AxeCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGUsXG4gICAgICAgIGNwMnk6IG5leHRFbmQueSAtIChzcGFuLmNwMXkgLSBwcmV2U3RhcnQueSkgKiBoZWlnaHRTY2FsZSxcbiAgICAgICAgY3AzeDogbmV4dEVuZC54LFxuICAgICAgICBjcDN5OiBuZXh0RW5kLnlcbiAgICAgIH07XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RlcFwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogbmV4dFN0YXJ0LngsXG4gICAgICAgIHkwOiBuZXh0U3RhcnQueSxcbiAgICAgICAgeDE6IG5leHRFbmQueCxcbiAgICAgICAgeTE6IG5leHRFbmQueSxcbiAgICAgICAgc3RlcFg6IG5leHRFbmQueCAtIChzcGFuLnN0ZXBYIC0gcHJldlN0YXJ0LngpICogd2lkdGhTY2FsZVxuICAgICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TW92ZVRvKHNwYW4sIG1vdmVUbykge1xuICByZXR1cm4gc3Bhbi5tb3ZlVG8gIT09IG1vdmVUbyA/IHsgLi4uc3BhbiwgbW92ZVRvIH0gOiBzcGFuO1xufVxuZnVuY3Rpb24gc3BsaXRTcGFuQXRYKHNwYW4sIHgpIHtcbiAgY29uc3QgW3N0YXJ0LCBlbmRdID0gc3BhblJhbmdlKHNwYW4pO1xuICBsZXQgeDA7XG4gIGxldCB5MDtcbiAgbGV0IHgxO1xuICBsZXQgeTE7XG4gIGlmIChzdGFydC54IDwgZW5kLngpIHtcbiAgICB4MCA9IHN0YXJ0Lng7XG4gICAgeTAgPSBzdGFydC55O1xuICAgIHgxID0gZW5kLng7XG4gICAgeTEgPSBlbmQueTtcbiAgfSBlbHNlIHtcbiAgICB4MCA9IGVuZC54O1xuICAgIHkwID0gZW5kLnk7XG4gICAgeDEgPSBzdGFydC54O1xuICAgIHkxID0gc3RhcnQueTtcbiAgfVxuICBpZiAoeCA8IHgwKSB7XG4gICAgcmV0dXJuIFtyZXNjYWxlU3BhbihzcGFuLCBzdGFydCwgc3RhcnQpLCBzZXRNb3ZlVG8oc3BhbiwgZmFsc2UpXTtcbiAgfSBlbHNlIGlmICh4ID4geDEpIHtcbiAgICByZXR1cm4gW3NwYW4sIHNldE1vdmVUbyhyZXNjYWxlU3BhbihzcGFuLCBlbmQsIGVuZCksIGZhbHNlKV07XG4gIH1cbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6IHtcbiAgICAgIGNvbnN0IG1pZFkgPSB5MCA9PT0geTEgPyB5MCA6ICh5MSAtIHkwKSAvICh4MSAtIHgwKSAqICh4IC0geDApICsgeTA7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbzogc3Bhbi5tb3ZlVG8sIHgwLCB5MCwgeDE6IHgsIHkxOiBtaWRZIH0sXG4gICAgICAgIHsgdHlwZTogXCJsaW5lYXJcIiwgbW92ZVRvOiBmYWxzZSwgeDA6IHgsIHkwOiBtaWRZLCB4MSwgeTEgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIGlmICh4IDwgc3Bhbi5zdGVwWCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbzogc3Bhbi5tb3ZlVG8sIHgwLCB5MCwgeDE6IHgsIHkxOiB5MCwgc3RlcFg6IHggfSxcbiAgICAgICAgICB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG86IGZhbHNlLCB4MDogeCwgeTAsIHgxLCB5MSwgc3RlcFg6IHNwYW4uc3RlcFggfVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG86IHNwYW4ubW92ZVRvLCB4MCwgeTAsIHgxOiB4LCB5MSwgc3RlcFg6IHNwYW4uc3RlcFggfSxcbiAgICAgICAgICB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG86IGZhbHNlLCB4MDogeCwgeTA6IHkxLCB4MSwgeTEsIHN0ZXBYOiB4IH1cbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICBjYXNlIFwiY3ViaWNcIjoge1xuICAgICAgY29uc3QgdCA9IHNvbHZlQmV6aWVyKHNwYW4uY3AweCwgc3Bhbi5jcDF4LCBzcGFuLmNwMngsIHNwYW4uY3AzeCwgeCk7XG4gICAgICBjb25zdCBbYSwgYl0gPSBzcGxpdEJlemllcihcbiAgICAgICAgc3Bhbi5jcDB4LFxuICAgICAgICBzcGFuLmNwMHksXG4gICAgICAgIHNwYW4uY3AxeCxcbiAgICAgICAgc3Bhbi5jcDF5LFxuICAgICAgICBzcGFuLmNwMngsXG4gICAgICAgIHNwYW4uY3AyeSxcbiAgICAgICAgc3Bhbi5jcDN4LFxuICAgICAgICBzcGFuLmNwM3ksXG4gICAgICAgIHRcbiAgICAgICk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgICAgY3AweDogYVswXS54LFxuICAgICAgICAgIGNwMHk6IGFbMF0ueSxcbiAgICAgICAgICBjcDF4OiBhWzFdLngsXG4gICAgICAgICAgY3AxeTogYVsxXS55LFxuICAgICAgICAgIGNwMng6IGFbMl0ueCxcbiAgICAgICAgICBjcDJ5OiBhWzJdLnksXG4gICAgICAgICAgY3AzeDogYVszXS54LFxuICAgICAgICAgIGNwM3k6IGFbM10ueVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICAgIG1vdmVUbzogZmFsc2UsXG4gICAgICAgICAgY3AweDogYlswXS54LFxuICAgICAgICAgIGNwMHk6IGJbMF0ueSxcbiAgICAgICAgICBjcDF4OiBiWzFdLngsXG4gICAgICAgICAgY3AxeTogYlsxXS55LFxuICAgICAgICAgIGNwMng6IGJbMl0ueCxcbiAgICAgICAgICBjcDJ5OiBiWzJdLnksXG4gICAgICAgICAgY3AzeDogYlszXS54LFxuICAgICAgICAgIGNwM3k6IGJbM10ueVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xpcFNwYW5YKHNwYW4sIHgwLCB4MSkge1xuICBjb25zdCB7IG1vdmVUbyB9ID0gc3BhbjtcbiAgY29uc3QgW3N0YXJ0LCBlbmRdID0gc3BhblJhbmdlKHNwYW4pO1xuICBsZXQgc3BhblgwO1xuICBsZXQgc3BhblkwO1xuICBsZXQgc3BhblgxO1xuICBsZXQgc3BhblkxO1xuICBpZiAoc3RhcnQueCA8IGVuZC54KSB7XG4gICAgc3BhblgwID0gc3RhcnQueDtcbiAgICBzcGFuWTAgPSBzdGFydC55O1xuICAgIHNwYW5YMSA9IGVuZC54O1xuICAgIHNwYW5ZMSA9IGVuZC55O1xuICB9IGVsc2Uge1xuICAgIHNwYW5YMCA9IGVuZC54O1xuICAgIHNwYW5ZMCA9IGVuZC55O1xuICAgIHNwYW5YMSA9IHN0YXJ0Lng7XG4gICAgc3BhblkxID0gc3RhcnQueTtcbiAgfVxuICBpZiAoeDEgPCBzcGFuWDApIHtcbiAgICByZXR1cm4gcmVzY2FsZVNwYW4oc3Bhbiwgc3RhcnQsIHN0YXJ0KTtcbiAgfSBlbHNlIGlmICh4MCA+IHNwYW5YMSkge1xuICAgIHJldHVybiByZXNjYWxlU3BhbihzcGFuLCBlbmQsIGVuZCk7XG4gIH1cbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6IHtcbiAgICAgIGNvbnN0IG0gPSBzcGFuWTAgPT09IHNwYW5ZMSA/IHZvaWQgMCA6IChzcGFuWTEgLSBzcGFuWTApIC8gKHNwYW5YMSAtIHNwYW5YMCk7XG4gICAgICBjb25zdCB5MCA9IG0gPT0gbnVsbCA/IHNwYW5ZMCA6IG0gKiAoeDAgLSBzcGFuWDApICsgc3BhblkwO1xuICAgICAgY29uc3QgeTEgPSBtID09IG51bGwgPyBzcGFuWTAgOiBtICogKHgxIC0gc3BhblgwKSArIHNwYW5ZMDtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEgfTtcbiAgICB9XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIGlmICh4MSA8PSBzcGFuLnN0ZXBYKSB7XG4gICAgICAgIGNvbnN0IHkgPSBzcGFuLnkwO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTA6IHksIHgxLCB5MTogeSwgc3RlcFg6IHgxIH07XG4gICAgICB9IGVsc2UgaWYgKHgwID49IHNwYW4uc3RlcFgpIHtcbiAgICAgICAgY29uc3QgeSA9IHNwYW4ueTE7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MDogeSwgeDEsIHkxOiB5LCBzdGVwWDogeDAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgeTAsIHkxLCBzdGVwWCB9ID0gc3BhbjtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYIH07XG4gICAgICB9XG4gICAgY2FzZSBcImN1YmljXCI6IHtcbiAgICAgIGNvbnN0IHQwID0gc29sdmVCZXppZXIoc3Bhbi5jcDB4LCBzcGFuLmNwMXgsIHNwYW4uY3AyeCwgc3Bhbi5jcDN4LCB4MCk7XG4gICAgICBsZXQgW191bnVzZWQsIGJlemllcl0gPSBzcGxpdEJlemllcihcbiAgICAgICAgc3Bhbi5jcDB4LFxuICAgICAgICBzcGFuLmNwMHksXG4gICAgICAgIHNwYW4uY3AxeCxcbiAgICAgICAgc3Bhbi5jcDF5LFxuICAgICAgICBzcGFuLmNwMngsXG4gICAgICAgIHNwYW4uY3AyeSxcbiAgICAgICAgc3Bhbi5jcDN4LFxuICAgICAgICBzcGFuLmNwM3ksXG4gICAgICAgIHQwXG4gICAgICApO1xuICAgICAgY29uc3QgdDEgPSBzb2x2ZUJlemllcihiZXppZXJbMF0ueCwgYmV6aWVyWzFdLngsIGJlemllclsyXS54LCBiZXppZXJbM10ueCwgeDEpO1xuICAgICAgW2JlemllciwgX3VudXNlZF0gPSBzcGxpdEJlemllcihcbiAgICAgICAgYmV6aWVyWzBdLngsXG4gICAgICAgIGJlemllclswXS55LFxuICAgICAgICBiZXppZXJbMV0ueCxcbiAgICAgICAgYmV6aWVyWzFdLnksXG4gICAgICAgIGJlemllclsyXS54LFxuICAgICAgICBiZXppZXJbMl0ueSxcbiAgICAgICAgYmV6aWVyWzNdLngsXG4gICAgICAgIGJlemllclszXS55LFxuICAgICAgICB0MVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgbW92ZVRvLFxuICAgICAgICBjcDB4OiBiZXppZXJbMF0ueCxcbiAgICAgICAgY3AweTogYmV6aWVyWzBdLnksXG4gICAgICAgIGNwMXg6IGJlemllclsxXS54LFxuICAgICAgICBjcDF5OiBiZXppZXJbMV0ueSxcbiAgICAgICAgY3AyeDogYmV6aWVyWzJdLngsXG4gICAgICAgIGNwMnk6IGJlemllclsyXS55LFxuICAgICAgICBjcDN4OiBiZXppZXJbM10ueCxcbiAgICAgICAgY3AzeTogYmV6aWVyWzNdLnlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVNwYW5zKGEsIGIsIHJhdGlvMikge1xuICBpZiAoYS50eXBlID09PSBcImN1YmljXCIgJiYgYi50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgbW92ZVRvOiBhLm1vdmVUbyxcbiAgICAgIGNwMHg6IChiLmNwMHggLSBhLmNwMHgpICogcmF0aW8yICsgYS5jcDB4LFxuICAgICAgY3AweTogKGIuY3AweSAtIGEuY3AweSkgKiByYXRpbzIgKyBhLmNwMHksXG4gICAgICBjcDF4OiAoYi5jcDF4IC0gYS5jcDF4KSAqIHJhdGlvMiArIGEuY3AxeCxcbiAgICAgIGNwMXk6IChiLmNwMXkgLSBhLmNwMXkpICogcmF0aW8yICsgYS5jcDF5LFxuICAgICAgY3AyeDogKGIuY3AyeCAtIGEuY3AyeCkgKiByYXRpbzIgKyBhLmNwMngsXG4gICAgICBjcDJ5OiAoYi5jcDJ5IC0gYS5jcDJ5KSAqIHJhdGlvMiArIGEuY3AyeSxcbiAgICAgIGNwM3g6IChiLmNwM3ggLSBhLmNwM3gpICogcmF0aW8yICsgYS5jcDN4LFxuICAgICAgY3AzeTogKGIuY3AzeSAtIGEuY3AzeSkgKiByYXRpbzIgKyBhLmNwM3lcbiAgICB9O1xuICB9IGVsc2UgaWYgKGEudHlwZSA9PT0gXCJzdGVwXCIgJiYgYi50eXBlID09PSBcInN0ZXBcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0ZXBcIixcbiAgICAgIG1vdmVUbzogYS5tb3ZlVG8sXG4gICAgICB4MDogKGIueDAgLSBhLngwKSAqIHJhdGlvMiArIGEueDAsXG4gICAgICB5MDogKGIueTAgLSBhLnkwKSAqIHJhdGlvMiArIGEueTAsXG4gICAgICB4MTogKGIueDEgLSBhLngxKSAqIHJhdGlvMiArIGEueDEsXG4gICAgICB5MTogKGIueTEgLSBhLnkxKSAqIHJhdGlvMiArIGEueTEsXG4gICAgICBzdGVwWDogKGIuc3RlcFggLSBhLnN0ZXBYKSAqIHJhdGlvMiArIGEuc3RlcFhcbiAgICB9O1xuICB9XG4gIGNvbnN0IFthU3RhcnQsIGFFbmRdID0gc3BhblJhbmdlKGEpO1xuICBjb25zdCBbYlN0YXJ0LCBiRW5kXSA9IHNwYW5SYW5nZShiKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgIG1vdmVUbzogYS5tb3ZlVG8sXG4gICAgeDA6IChiU3RhcnQueCAtIGFTdGFydC54KSAqIHJhdGlvMiArIGFTdGFydC54LFxuICAgIHkwOiAoYlN0YXJ0LnkgLSBhU3RhcnQueSkgKiByYXRpbzIgKyBhU3RhcnQueSxcbiAgICB4MTogKGJFbmQueCAtIGFFbmQueCkgKiByYXRpbzIgKyBhRW5kLngsXG4gICAgeTE6IChiRW5kLnkgLSBhRW5kLnkpICogcmF0aW8yICsgYUVuZC55XG4gIH07XG59XG5mdW5jdGlvbiBwbG90U3BhbihwYXRoLCBzcGFuLCBtb3ZlVG8gPSBzcGFuLm1vdmVUbyA/IDEgLyogTW92ZVRvICovIDogMCAvKiBOb25lICovKSB7XG4gIGNvbnN0IFtzdGFydF0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIHN3aXRjaCAobW92ZVRvKSB7XG4gICAgY2FzZSAxIC8qIE1vdmVUbyAqLzpcbiAgICAgIHBhdGgubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyIC8qIExpbmVUbyAqLzpcbiAgICAgIHBhdGgubGluZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICBwYXRoLmxpbmVUbyhzcGFuLngxLCBzcGFuLnkxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcGF0aC5jdWJpY0N1cnZlVG8oc3Bhbi5jcDF4LCBzcGFuLmNwMXksIHNwYW4uY3AyeCwgc3Bhbi5jcDJ5LCBzcGFuLmNwM3gsIHNwYW4uY3AzeSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcGF0aC5saW5lVG8oc3Bhbi5zdGVwWCwgc3Bhbi55MCk7XG4gICAgICBwYXRoLmxpbmVUbyhzcGFuLnN0ZXBYLCBzcGFuLnkxKTtcbiAgICAgIHBhdGgubGluZVRvKHNwYW4ueDEsIHNwYW4ueTEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVhclBvaW50cyhwb2ludHMpIHtcbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgeDAgPSBOYU47XG4gIGxldCB5MCA9IE5hTjtcbiAgZm9yIChjb25zdCB7IHg6IHgxLCB5OiB5MSB9IG9mIHBvaW50cykge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgY29uc3QgbW92ZVRvID0gaSA9PT0gMTtcbiAgICAgIHNwYW5zLnB1c2goeyB0eXBlOiBcImxpbmVhclwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxIH0pO1xuICAgIH1cbiAgICBpICs9IDE7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cbnZhciBsaW5lU3RlcHMgPSB7XG4gIHN0YXJ0OiAwLFxuICBtaWRkbGU6IDAuNSxcbiAgZW5kOiAxXG59O1xuZnVuY3Rpb24gc3RlcFBvaW50cyhwb2ludHMsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IHNwYW5zID0gW107XG4gIGxldCBpID0gMDtcbiAgbGV0IHgwID0gTmFOO1xuICBsZXQgeTAgPSBOYU47XG4gIGNvbnN0IHAwID0gdHlwZW9mIHBvc2l0aW9uID09PSBcIm51bWJlclwiID8gcG9zaXRpb24gOiBsaW5lU3RlcHNbcG9zaXRpb25dO1xuICBmb3IgKGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gb2YgcG9pbnRzKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBjb25zdCBtb3ZlVG8gPSBpID09PSAxO1xuICAgICAgY29uc3Qgc3RlcFggPSB4MCArICh4MSAtIHgwKSAqIHAwO1xuICAgICAgc3BhbnMucHVzaCh7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCB9KTtcbiAgICB9XG4gICAgaSArPSAxO1xuICAgIHgwID0geDE7XG4gICAgeTAgPSB5MTtcbiAgfVxuICByZXR1cm4gc3BhbnM7XG59XG52YXIgZmxhdG5lc3NSYXRpbyA9IDAuMDU7XG5mdW5jdGlvbiBzbW9vdGhQb2ludHMoaVBvaW50cywgdGVuc2lvbikge1xuICBjb25zdCBwb2ludHMgPSBBcnJheS5pc0FycmF5KGlQb2ludHMpID8gaVBvaW50cyA6IEFycmF5LmZyb20oaVBvaW50cyk7XG4gIGlmIChwb2ludHMubGVuZ3RoIDw9IDEpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBncmFkaWVudHMgPSBwb2ludHMubWFwKChjLCBpKSA9PiB7XG4gICAgY29uc3QgcCA9IGkgPT09IDAgPyBjIDogcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBuID0gaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDEgPyBjIDogcG9pbnRzW2kgKyAxXTtcbiAgICBjb25zdCBpc1Rlcm1pbmFsUG9pbnQgPSBpID09PSAwIHx8IGkgPT09IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGlmIChNYXRoLnNpZ24ocC55IC0gYy55KSA9PT0gTWF0aC5zaWduKG4ueSAtIGMueSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoIWlzVGVybWluYWxQb2ludCkge1xuICAgICAgY29uc3QgcmFuZ2UzID0gTWF0aC5hYnMocC55IC0gbi55KTtcbiAgICAgIGNvbnN0IHByZXZSYXRpbyA9IE1hdGguYWJzKGMueSAtIHAueSkgLyByYW5nZTM7XG4gICAgICBjb25zdCBuZXh0UmF0aW8gPSBNYXRoLmFicyhjLnkgLSBuLnkpIC8gcmFuZ2UzO1xuICAgICAgaWYgKHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IDEgLSBwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbyB8fCBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbyB8fCAxIC0gbmV4dFJhdGlvIDw9IGZsYXRuZXNzUmF0aW8pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAobi55IC0gcC55KSAvIChuLnggLSBwLngpO1xuICB9KTtcbiAgaWYgKGdyYWRpZW50c1sxXSA9PT0gMCkge1xuICAgIGdyYWRpZW50c1swXSAqPSAyO1xuICB9XG4gIGlmIChncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDJdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzW2dyYWRpZW50cy5sZW5ndGggLSAxXSAqPSAyO1xuICB9XG4gIGNvbnN0IHNwYW5zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcHJldiA9IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgcHJldk0gPSBncmFkaWVudHNbaSAtIDFdO1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tpXTtcbiAgICBjb25zdCBjdXJNID0gZ3JhZGllbnRzW2ldO1xuICAgIGNvbnN0IGR4ID0gY3VyLnggLSBwcmV2Lng7XG4gICAgY29uc3QgZHkgPSBjdXIueSAtIHByZXYueTtcbiAgICBsZXQgZGNwMXggPSBkeCAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AxeSA9IGR4ICogcHJldk0gKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMnggPSBkeCAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeSA9IGR4ICogY3VyTSAqIHRlbnNpb24gLyAzO1xuICAgIGlmIChjdXJNID09PSAwICYmIE1hdGguYWJzKGRjcDF5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMXggKj0gTWF0aC5hYnMoZHkgLyBkY3AxeSk7XG4gICAgICBkY3AxeSA9IE1hdGguc2lnbihkY3AxeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIGlmIChwcmV2TSA9PT0gMCAmJiBNYXRoLmFicyhkY3AyeSkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGRjcDJ4ICo9IE1hdGguYWJzKGR5IC8gZGNwMnkpO1xuICAgICAgZGNwMnkgPSBNYXRoLnNpZ24oZGNwMnkpICogTWF0aC5hYnMoZHkpO1xuICAgIH1cbiAgICBzcGFucy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgIG1vdmVUbzogaSA9PT0gMSxcbiAgICAgIGNwMHg6IHByZXYueCxcbiAgICAgIGNwMHk6IHByZXYueSxcbiAgICAgIGNwMXg6IHByZXYueCArIGRjcDF4LFxuICAgICAgY3AxeTogcHJldi55ICsgZGNwMXksXG4gICAgICBjcDJ4OiBjdXIueCAtIGRjcDJ4LFxuICAgICAgY3AyeTogY3VyLnkgLSBkY3AyeSxcbiAgICAgIGNwM3g6IGN1ci54LFxuICAgICAgY3AzeTogY3VyLnlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3BhbnM7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbWFya2VyVXRpbC50c1xuZnVuY3Rpb24gbWFya2VyRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgYW5pbWF0aW9uTWFuYWdlciwgc3RhdHVzLCAuLi5tYXJrZXJTZWxlY3Rpb25zKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHsgcGhhc2U6IHN0YXR1cyA/IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXSA6IFwidHJhaWxpbmdcIiB9O1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIFwibWFya2Vyc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zLCB7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0sIHBhcmFtcyk7XG4gIG1hcmtlclNlbGVjdGlvbnMuZm9yRWFjaCgocykgPT4gcy5jbGVhbnVwKCkpO1xufVxuZnVuY3Rpb24gbWFya2VyU2NhbGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLm1hcmtlclNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIFwibWFya2Vyc1wiLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbWFya2VyU2VsZWN0aW9ucyxcbiAgICB7IHNjYWxpbmdYOiAwLCBzY2FsaW5nWTogMCB9LFxuICAgIHsgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH0sXG4gICAgeyBwaGFzZTogXCJpbml0aWFsXCIgfVxuICApO1xuICBtYXJrZXJTZWxlY3Rpb25zLmZvckVhY2goKHMpID0+IHMuY2xlYW51cCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih7IGlkLCBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBhbmltYXRpb25NYW5hZ2VyLCAuLi5tYXJrZXJTZWxlY3Rpb25zKSB7XG4gIGNvbnN0IHNlcmllc1dpZHRoID0gbm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdFdpZHRoO1xuICBjb25zdCBmcm9tRm4gPSAoXywgZGF0dW0pID0+IHtcbiAgICBjb25zdCB4ID0gZGF0dW0ubWlkUG9pbnQ/LnggPz8gc2VyaWVzV2lkdGg7XG4gICAgbGV0IGRlbGF5ID0gY2xhbXAoMCwgaW52ZXJzZUVhc2VPdXQoeCAvIHNlcmllc1dpZHRoKSwgMSk7XG4gICAgaWYgKGlzTmFOKGRlbGF5KSkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4geyBzY2FsaW5nWDogMCwgc2NhbGluZ1k6IDAsIGRlbGF5LCBkdXJhdGlvbjogUVVJQ0tfVFJBTlNJVElPTiwgcGhhc2U6IFwiaW5pdGlhbFwiIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoKSA9PiB7XG4gICAgcmV0dXJuIHsgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH07XG4gIH07XG4gIGZyb21Ub01vdGlvbihpZCwgXCJtYXJrZXJzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHsgZnJvbUZuLCB0b0ZuIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRNYXJrZXJGbihfbm9kZSkge1xuICByZXR1cm4geyBvcGFjaXR5OiAxLCBzY2FsaW5nWDogMSwgc2NhbGluZ1k6IDEgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0TWFya2VyUG9zaXRpb25Gbihfbm9kZSwgZGF0dW0pIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnBvaW50Py54ID8/IE5hTixcbiAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnBvaW50Py55ID8/IE5hTlxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZU1hcmtlckFuaW1hdGlvbihwYWlyTWFwLCBwYXJlbnRTdGF0dXMpIHtcbiAgY29uc3QgcmVhZEZpcnN0UGFpciA9ICh4VmFsdWUsIHR5cGUpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYWlyTWFwW3R5cGVdW3hWYWx1ZV07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbDtcbiAgfTtcbiAgY29uc3QgbWFya2VyU3RhdHVzID0gKGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeyB4VmFsdWUgfSA9IGRhdHVtO1xuICAgIGlmIChwYWlyTWFwLm1vdmVkW3hWYWx1ZV0pIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiByZWFkRmlyc3RQYWlyKHhWYWx1ZSwgXCJtb3ZlZFwiKSwgc3RhdHVzOiBcInVwZGF0ZWRcIiB9O1xuICAgIH0gZWxzZSBpZiAocGFpck1hcC5yZW1vdmVkW3hWYWx1ZV0pIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiByZWFkRmlyc3RQYWlyKHhWYWx1ZSwgXCJyZW1vdmVkXCIpLCBzdGF0dXM6IFwicmVtb3ZlZFwiIH07XG4gICAgfSBlbHNlIGlmIChwYWlyTWFwLmFkZGVkW3hWYWx1ZV0pIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiByZWFkRmlyc3RQYWlyKHhWYWx1ZSwgXCJhZGRlZFwiKSwgc3RhdHVzOiBcImFkZGVkXCIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInVua25vd25cIiB9O1xuICB9O1xuICBjb25zdCBmcm9tRm4gPSAobWFya2VyLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBwb2ludCB9ID0gbWFya2VyU3RhdHVzKGRhdHVtKTtcbiAgICBpZiAoc3RhdHVzID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAgfTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHRyYW5zbGF0aW9uWDogcG9pbnQ/LmZyb20/LnggPz8gbWFya2VyLnRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogcG9pbnQ/LmZyb20/LnkgPz8gbWFya2VyLnRyYW5zbGF0aW9uWSxcbiAgICAgIG9wYWNpdHk6IG1hcmtlci5vcGFjaXR5LFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgIH07XG4gICAgaWYgKHBhcmVudFN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNsYXRpb25YOiBwb2ludD8udG8/LngsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogcG9pbnQ/LnRvPy55LFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcImFkZGVkXCJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIGRlZmF1bHRzLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoX21hcmtlciwgZGF0dW0pID0+IHtcbiAgICBjb25zdCB7IHN0YXR1cywgcG9pbnQgfSA9IG1hcmtlclN0YXR1cyhkYXR1bSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm4geyBvcGFjaXR5OiAwIH07XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnBvaW50LngsXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnBvaW50LnksXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgIH07XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgcGFyZW50U3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogcG9pbnQ/LnRvPy54LFxuICAgICAgICB0cmFuc2xhdGlvblk6IHBvaW50Py50bz8ueSxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbXCJyZW1vdmVkXCJdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH07XG4gIHJldHVybiB7IGZyb21GbiwgdG9GbiB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHNlcmllcywgeyBkYXR1bUluZGV4IH0pIHtcbiAgY29uc3Qgbm9kZURhdGEgPSBzZXJpZXMuZ2V0Tm9kZURhdGEoKTtcbiAgaWYgKG5vZGVEYXRhID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgZGF0dW0gPSBub2RlRGF0YVtkYXR1bUluZGV4XTtcbiAgaWYgKGRhdHVtID09PSB2b2lkIDAgfHwgZGF0dW0ucG9pbnQgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBzaXplID0gc2VyaWVzLmdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKS5zaXplO1xuICBjb25zdCByYWRpdXMgPSBzaXplIC8gMjtcbiAgY29uc3QgeyB4LCB5IH0gPSBzZXJpZXMuY29udGVudEdyb3VwLmludmVyc2VUcmFuc2Zvcm1Qb2ludChkYXR1bS5wb2ludC54IC0gcmFkaXVzLCBkYXR1bS5wb2ludC55IC0gcmFkaXVzKTtcbiAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHNpemUsIHNpemUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVQbG90dGVyLnRzXG5mdW5jdGlvbiBwbG90TGluZWFyUG9pbnRzKHBhdGgsIHBvaW50cywgY29udGludWVQYXRoKSB7XG4gIGxldCBkaWRNb3ZlID0gY29udGludWVQYXRoO1xuICBmb3IgKGNvbnN0IHsgeCwgeSB9IG9mIHBvaW50cykge1xuICAgIGlmIChkaWRNb3ZlKSB7XG4gICAgICBwYXRoLmxpbmVUbyh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5tb3ZlVG8oeCwgeSk7XG4gICAgICBkaWRNb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbnZhciBmbGF0bmVzc1JhdGlvMiA9IDAuMDU7XG5mdW5jdGlvbiBwbG90U21vb3RoUG9pbnRzKHBhdGgsIGlQb2ludHMsIHRlbnNpb24sIGNvbnRpbnVlUGF0aCkge1xuICBjb25zdCBwb2ludHMgPSBBcnJheS5pc0FycmF5KGlQb2ludHMpID8gaVBvaW50cyA6IEFycmF5LmZyb20oaVBvaW50cyk7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgaWYgKGNvbnRpbnVlUGF0aCkge1xuICAgIHBhdGgubGluZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgfVxuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3JhZGllbnRzID0gcG9pbnRzLm1hcCgoYywgaSkgPT4ge1xuICAgIGNvbnN0IHAgPSBpID09PSAwID8gYyA6IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgbiA9IGkgPT09IHBvaW50cy5sZW5ndGggLSAxID8gYyA6IHBvaW50c1tpICsgMV07XG4gICAgY29uc3QgaXNUZXJtaW5hbFBvaW50ID0gaSA9PT0gMCB8fCBpID09PSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoTWF0aC5zaWduKHAueSAtIGMueSkgPT09IE1hdGguc2lnbihuLnkgLSBjLnkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCFpc1Rlcm1pbmFsUG9pbnQpIHtcbiAgICAgIGNvbnN0IHJhbmdlMyA9IE1hdGguYWJzKHAueSAtIG4ueSk7XG4gICAgICBjb25zdCBwcmV2UmF0aW8gPSBNYXRoLmFicyhjLnkgLSBwLnkpIC8gcmFuZ2UzO1xuICAgICAgY29uc3QgbmV4dFJhdGlvID0gTWF0aC5hYnMoYy55IC0gbi55KSAvIHJhbmdlMztcbiAgICAgIGlmIChwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIgfHwgMSAtIHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvMiB8fCBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIgfHwgMSAtIG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvMikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChuLnkgLSBwLnkpIC8gKG4ueCAtIHAueCk7XG4gIH0pO1xuICBpZiAoZ3JhZGllbnRzWzFdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzWzBdICo9IDI7XG4gIH1cbiAgaWYgKGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMl0gPT09IDApIHtcbiAgICBncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDFdICo9IDI7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmV2ID0gcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBwcmV2TSA9IGdyYWRpZW50c1tpIC0gMV07XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IGN1ck0gPSBncmFkaWVudHNbaV07XG4gICAgY29uc3QgZHggPSBjdXIueCAtIHByZXYueDtcbiAgICBjb25zdCBkeSA9IGN1ci55IC0gcHJldi55O1xuICAgIGxldCBkY3AxeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDF5ID0gZHggKiBwcmV2TSAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ5ID0gZHggKiBjdXJNICogdGVuc2lvbiAvIDM7XG4gICAgaWYgKGN1ck0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMXkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AxeCAqPSBNYXRoLmFicyhkeSAvIGRjcDF5KTtcbiAgICAgIGRjcDF5ID0gTWF0aC5zaWduKGRjcDF5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgaWYgKHByZXZNID09PSAwICYmIE1hdGguYWJzKGRjcDJ5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMnggKj0gTWF0aC5hYnMoZHkgLyBkY3AyeSk7XG4gICAgICBkY3AyeSA9IE1hdGguc2lnbihkY3AyeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKHByZXYueCArIGRjcDF4LCBwcmV2LnkgKyBkY3AxeSwgY3VyLnggLSBkY3AyeCwgY3VyLnkgLSBkY3AyeSwgY3VyLngsIGN1ci55KTtcbiAgfVxufVxuZnVuY3Rpb24gcGxvdFN0ZXBQb2ludHMocGF0aCwgcG9pbnRzLCBhbGlnbiwgY29udGludWVQYXRoKSB7XG4gIGxldCBsYXN0UG9pbnQ7XG4gIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgaWYgKGxhc3RQb2ludCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb25hbEFsaWduID0gbGFzdFBvaW50LnggPCBwb2ludC54ID8gYWxpZ24gOiAxIC0gYWxpZ247XG4gICAgICBjb25zdCB4ID0gKHBvaW50LnggLSBsYXN0UG9pbnQueCkgKiBkaXJlY3Rpb25hbEFsaWduICsgbGFzdFBvaW50Lng7XG4gICAgICBwYXRoLmxpbmVUbyh4LCBsYXN0UG9pbnQ/LnkgPz8gcG9pbnQueSk7XG4gICAgICBwYXRoLmxpbmVUbyh4LCBwb2ludC55KTtcbiAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0gZWxzZSBpZiAoY29udGludWVQYXRoKSB7XG4gICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxuICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vcGF0aFV0aWwudHNcbmZ1bmN0aW9uIG1pbk1heChub2RlRGF0YSkge1xuICByZXR1cm4gbm9kZURhdGEucmVkdWNlKFxuICAgICh7IG1pbiwgbWF4IH0sIG5vZGUpID0+IHtcbiAgICAgIGlmIChtaW4gPT0gbnVsbCB8fCBtaW4ucG9pbnQueCA+IG5vZGUucG9pbnQueCkge1xuICAgICAgICBtaW4gPSBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKG1heCA9PSBudWxsIHx8IG1heC5wb2ludC54IDwgbm9kZS5wb2ludC54KSB7XG4gICAgICAgIG1heCA9IG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbk9uTGluZShhLCBiLCB0YXJnZXRYKSB7XG4gIGNvbnN0IG0gPSAoYi55IC0gYS55KSAvIChiLnggLSBhLngpO1xuICBjb25zdCB5ID0gKHRhcmdldFggLSBhLngpICogbSArIGEueTtcbiAgcmV0dXJuIHsgeDogdGFyZ2V0WCwgeSB9O1xufVxuZnVuY3Rpb24gYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0cywgcHJvY2Vzcywgc2tpcCwgcHJvY2Vzc0ZuKSB7XG4gIGxldCBwcmV2TWFya2VySWR4ID0gLTEsIG5leHRNYXJrZXJJZHggPSAwO1xuICBjb25zdCB0b1Byb2Nlc3MgPSBbXTtcbiAgd2hpbGUgKG5leHRNYXJrZXJJZHggPCByZXN1bHRzLmxlbmd0aCkge1xuICAgIGlmIChyZXN1bHRzW25leHRNYXJrZXJJZHhdLmNoYW5nZSA9PT0gcHJvY2Vzcykge1xuICAgICAgdG9Qcm9jZXNzLnB1c2gocmVzdWx0c1tuZXh0TWFya2VySWR4XSk7XG4gICAgICBuZXh0TWFya2VySWR4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdHNbbmV4dE1hcmtlcklkeF0uY2hhbmdlID09PSBza2lwKSB7XG4gICAgICBuZXh0TWFya2VySWR4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgICBwcm9jZXNzRm4odG9Qcm9jZXNzLCBwcmV2TWFya2VySWR4LCBuZXh0TWFya2VySWR4KTtcbiAgICAgIHRvUHJvY2Vzcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBwcmV2TWFya2VySWR4ID0gbmV4dE1hcmtlcklkeDtcbiAgICBuZXh0TWFya2VySWR4Kys7XG4gIH1cbiAgaWYgKHRvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgcHJvY2Vzc0ZuKHRvUHJvY2VzcywgcHJldk1hcmtlcklkeCwgbmV4dE1hcmtlcklkeCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIHNwbGl0TW9kZSkge1xuICBiYWNrZmlsbFBhdGhQb2ludChyZXN1bHQsIFwib3V0XCIsIFwiaW5cIiwgKHRvUHJvY2Vzcywgc0lkeCwgZUlkeCkgPT4ge1xuICAgIGlmIChzSWR4ID09PSAtMSAmJiByZXN1bHRbZUlkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gcmVzdWx0W2VJZHhdLmZyb20pO1xuICAgIH0gZWxzZSBpZiAoZUlkeCA9PT0gcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc0lkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gcmVzdWx0W3NJZHhdLmZyb20pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSBcImludGVyc2VjdFwiICYmIHJlc3VsdFtzSWR4XT8uZnJvbSAmJiByZXN1bHRbZUlkeF0/LmZyb20pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gaW50ZXJzZWN0aW9uT25MaW5lKHJlc3VsdFtzSWR4XS5mcm9tLCByZXN1bHRbZUlkeF0uZnJvbSwgZC5mcm9tLngpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQudG8gPSBkLmZyb20pO1xuICAgIH1cbiAgfSk7XG4gIGJhY2tmaWxsUGF0aFBvaW50KHJlc3VsdCwgXCJpblwiLCBcIm91dFwiLCAodG9Qcm9jZXNzLCBzSWR4LCBlSWR4KSA9PiB7XG4gICAgaWYgKHNJZHggPT09IC0xICYmIHJlc3VsdFtlSWR4XSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IHJlc3VsdFtlSWR4XS50byk7XG4gICAgfSBlbHNlIGlmIChlSWR4ID09PSByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzSWR4XSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IHJlc3VsdFtzSWR4XS50byk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IFwiaW50ZXJzZWN0XCIgJiYgcmVzdWx0W3NJZHhdPy50byAmJiByZXN1bHRbZUlkeF0/LnRvKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC5mcm9tID0gaW50ZXJzZWN0aW9uT25MaW5lKHJlc3VsdFtzSWR4XS50bywgcmVzdWx0W2VJZHhdLnRvLCBkLnRvLngpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IGQudG8pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQb2ludChmcm9tMiwgdG8sIHJhdGlvMikge1xuICBjb25zdCB4MSA9IGlzTmFOKGZyb20yLngpID8gdG8ueCA6IGZyb20yLng7XG4gIGNvbnN0IHkxID0gaXNOYU4oZnJvbTIueSkgPyB0by55IDogZnJvbTIueTtcbiAgY29uc3QgeGQgPSB0by54IC0gZnJvbTIueDtcbiAgY29uc3QgeWQgPSB0by55IC0gZnJvbTIueTtcbiAgY29uc3QgeHIgPSBpc05hTih4ZCkgPyAwIDogeGQgKiByYXRpbzI7XG4gIGNvbnN0IHlyID0gaXNOYU4oeWQpID8gMCA6IHlkICogcmF0aW8yO1xuICByZXR1cm4ge1xuICAgIHg6IHgxICsgeHIsXG4gICAgeTogeTEgKyB5clxuICB9O1xufVxudmFyIGxpbmVTdGVwczIgPSB7XG4gIHN0YXJ0OiAwLFxuICBtaWRkbGU6IDAuNSxcbiAgZW5kOiAxXG59O1xuZnVuY3Rpb24gcGxvdFBhdGgocG9pbnRzLCBwYXRoLCBpbnRlcnBvbGF0aW9uLCBjb250aW51ZVBhdGggPSBmYWxzZSkge1xuICBjb25zdCB7IHBhdGg6IGxpbmVQYXRoIH0gPSBwYXRoO1xuICBpZiAoaW50ZXJwb2xhdGlvbj8udHlwZSA9PT0gXCJzbW9vdGhcIikge1xuICAgIHBsb3RTbW9vdGhQb2ludHMobGluZVBhdGgsIHBvaW50cywgaW50ZXJwb2xhdGlvbi50ZW5zaW9uID8/IDEsIGNvbnRpbnVlUGF0aCk7XG4gIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbj8udHlwZSA9PT0gXCJzdGVwXCIpIHtcbiAgICBwbG90U3RlcFBvaW50cyhsaW5lUGF0aCwgcG9pbnRzLCBsaW5lU3RlcHMyW2ludGVycG9sYXRpb24ucG9zaXRpb24gPz8gXCJlbmRcIl0sIGNvbnRpbnVlUGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcGxvdExpbmVhclBvaW50cyhsaW5lUGF0aCwgcG9pbnRzLCBjb250aW51ZVBhdGgpO1xuICB9XG59XG5mdW5jdGlvbiBzcGxpdFBhaXJEYXRhKHBhaXJEYXRhLCByYXRpb3MpIHtcbiAgbGV0IHByZXZpb3VzVG87XG4gIGxldCBwb2ludHMgPSB2b2lkIDA7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBjb25zdCBmbHVzaEN1cnJlbnQgPSAoKSA9PiB7XG4gICAgaWYgKHBvaW50cyAhPSBudWxsKSB7XG4gICAgICBvdXQucHVzaChwb2ludHMpO1xuICAgICAgcG9pbnRzID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCBkYXRhIG9mIHBhaXJEYXRhKSB7XG4gICAgY29uc3QgeyBmcm9tOiBmcm9tMiwgdG8gfSA9IGRhdGE7XG4gICAgY29uc3QgcmF0aW8yID0gcmF0aW9zW2RhdGEuY2hhbmdlXTtcbiAgICBpZiAocmF0aW8yID09IG51bGwgfHwgZnJvbTIgPT0gbnVsbCB8fCB0byA9PSBudWxsKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcG9pbnQgPSBjYWxjdWxhdGVQb2ludChmcm9tMiwgdG8sIHJhdGlvMik7XG4gICAgaWYgKGRhdGEubW92ZVRvID09PSBmYWxzZSkge1xuICAgICAgcG9pbnRzID8/IChwb2ludHMgPSBbXSk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLm1vdmVUbyA9PT0gdHJ1ZSB8fCAhcHJldmlvdXNUbykge1xuICAgICAgZmx1c2hDdXJyZW50KCk7XG4gICAgICBwb2ludHMgPSBbcG9pbnRdO1xuICAgIH0gZWxzZSBpZiAocHJldmlvdXNUbykge1xuICAgICAgY29uc3QgbW92ZVRvUmF0aW8gPSBkYXRhLm1vdmVUbyA9PT0gXCJpblwiID8gcmF0aW8yIDogMSAtIHJhdGlvMjtcbiAgICAgIGNvbnN0IHsgeDogbWlkUG9pbnRYLCB5OiBtaWRQb2ludFkgfSA9IGNhbGN1bGF0ZVBvaW50KHByZXZpb3VzVG8sIHBvaW50LCBtb3ZlVG9SYXRpbyk7XG4gICAgICBwb2ludHMgPz8gKHBvaW50cyA9IFtdKTtcbiAgICAgIHBvaW50cy5wdXNoKHsgeDogbWlkUG9pbnRYLCB5OiBtaWRQb2ludFkgfSk7XG4gICAgICBmbHVzaEN1cnJlbnQoKTtcbiAgICAgIHBvaW50cyA9IFtwb2ludF07XG4gICAgfVxuICAgIHByZXZpb3VzVG8gPSBwb2ludDtcbiAgfVxuICBmbHVzaEN1cnJlbnQoKTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHJlbmRlclBhcnRpYWxQYXRoKHBhaXJEYXRhLCByYXRpb3MsIHBhdGgsIGludGVycG9sYXRpb24pIHtcbiAgc3BsaXRQYWlyRGF0YShwYWlyRGF0YSwgcmF0aW9zKS5mb3JFYWNoKChwb2ludHMpID0+IHtcbiAgICBwbG90UGF0aChwb2ludHMsIHBhdGgsIGludGVycG9sYXRpb24pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhdGhTd2lwZUluQW5pbWF0aW9uKHsgaWQsIHZpc2libGUsIG5vZGVEYXRhRGVwZW5kZW5jaWVzIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKSB7XG4gIGNvbnN0IHsgc2VyaWVzUmVjdFdpZHRoOiB3aWR0aCwgc2VyaWVzUmVjdEhlaWdodDogaGVpZ2h0IH0gPSBub2RlRGF0YURlcGVuZGVuY2llcztcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIFwicGF0aF9wcm9wZXJ0aWVzXCIsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBwYXRocyxcbiAgICB7IGNsaXBYOiAwIH0sXG4gICAgeyBjbGlwWDogd2lkdGggfSxcbiAgICB7XG4gICAgICBwaGFzZTogXCJpbml0aWFsXCIsXG4gICAgICBzdGFydDogeyBjbGlwTW9kZTogXCJub3JtYWxcIiwgY2xpcFk6IGhlaWdodCwgdmlzaWJsZSB9LFxuICAgICAgZmluaXNoOiB7IGNsaXBNb2RlOiB2b2lkIDAsIHZpc2libGUgfVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhdGhGYWRlSW5BbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgcGhhc2UgPSBcImFkZFwiLCAuLi5zZWxlY3Rpb24pIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKGlkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uLCB7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0sIHsgcGhhc2UgfSk7XG59XG5mdW5jdGlvbiBwYXRoRmFkZU91dEFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5zZWxlY3Rpb24pIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKGlkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uLCB7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0sIHsgcGhhc2U6IFwicmVtb3ZlXCIgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJlc2V0UGF0aEZuKG9wdHMpIHtcbiAgcmV0dXJuIChfbm9kZSkgPT4ge1xuICAgIHJldHVybiB7IHZpc2libGU6IG9wdHMuZ2V0VmlzaWJsZSgpLCBvcGFjaXR5OiBvcHRzLmdldE9wYWNpdHkoKSwgY2xpcFNjYWxpbmdYOiAxLCBjbGlwTW9kZTogdm9pZCAwIH07XG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDbGlwUGF0aCh7IG5vZGVEYXRhRGVwZW5kZW5jaWVzIH0sIHBhdGgpIHtcbiAgY29uc3QgdG9GaW5pdGUgPSAodmFsdWUpID0+IGlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogMDtcbiAgcGF0aC5jbGlwWCA9IHRvRmluaXRlKG5vZGVEYXRhRGVwZW5kZW5jaWVzLnNlcmllc1JlY3RXaWR0aCk7XG4gIHBhdGguY2xpcFkgPSB0b0Zpbml0ZShub2RlRGF0YURlcGVuZGVuY2llcy5zZXJpZXNSZWN0SGVpZ2h0KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9zY2FsaW5nLnRzXG5mdW5jdGlvbiBpc0NvbnRpbnVvdXNTY2FsaW5nKHNjYWxpbmcpIHtcbiAgcmV0dXJuIHNjYWxpbmcudHlwZSA9PT0gXCJjb250aW51b3VzXCIgfHwgc2NhbGluZy50eXBlID09PSBcImxvZ1wiO1xufVxuZnVuY3Rpb24gaXNDYXRlZ29yeVNjYWxpbmcoc2NhbGluZykge1xuICByZXR1cm4gc2NhbGluZy50eXBlID09PSBcImNhdGVnb3J5XCI7XG59XG5mdW5jdGlvbiBhcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLmRvbWFpbi5sZW5ndGggPT09IGIuZG9tYWluLmxlbmd0aCAmJiBhLnJhbmdlLmxlbmd0aCA9PT0gYi5yYW5nZS5sZW5ndGggJiYgYS5kb21haW4uZXZlcnkoKHZhbCwgaW5kZXgpID0+IHZhbCA9PT0gYi5kb21haW5baW5kZXhdKSAmJiBhLnJhbmdlLmV2ZXJ5KCh2YWwsIGluZGV4KSA9PiB2YWwgPT09IGIucmFuZ2VbaW5kZXhdKTtcbn1cbmZ1bmN0aW9uIGFyZVNjYWxpbmdFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSB2b2lkIDAgfHwgYiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGEgIT09IHZvaWQgMCB8fCBiICE9PSB2b2lkIDA7XG4gIH1cbiAgaWYgKGlzQ29udGludW91c1NjYWxpbmcoYSkgJiYgaXNDb250aW51b3VzU2NhbGluZyhiKSkge1xuICAgIHJldHVybiBhLnR5cGUgPT09IGIudHlwZSAmJiBhcmVFcXVhbChhLCBiKTtcbiAgfVxuICBpZiAoaXNDYXRlZ29yeVNjYWxpbmcoYSkgJiYgaXNDYXRlZ29yeVNjYWxpbmcoYikpIHtcbiAgICByZXR1cm4gYXJlRXF1YWwoYSwgYik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTY2FsZVZhbGlkKHNjYWxlMikge1xuICBpZiAoc2NhbGUyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXNjYWxlMi5yYW5nZS5ldmVyeSgodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChzY2FsZTIudHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgcmV0dXJuIHNjYWxlMi5kb21haW4uZXZlcnkoKHYpID0+IHYgIT0gbnVsbCk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlMi5kb21haW4uZXZlcnkoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSB8fCB2IGluc3RhbmNlb2YgRGF0ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVV0aWwudHNcbmZ1bmN0aW9uKiBwYXRoUmFuZ2VzKHBvaW50cykge1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IDA7XG4gIGZvciAoY29uc3QgeyBwb2ludCB9IG9mIHBvaW50cykge1xuICAgIGlmIChwb2ludC5tb3ZlVG8pIHtcbiAgICAgIGNvbnN0IHJhbmdlMyA9IHN0YXJ0ID49IDAgPyB7IHN0YXJ0LCBlbmQgfSA6IHZvaWQgMDtcbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICBpZiAocmFuZ2UzICE9PSB2b2lkIDApIHtcbiAgICAgICAgeWllbGQgcmFuZ2UzO1xuICAgICAgfVxuICAgIH1cbiAgICBlbmQgKz0gMTtcbiAgfVxuICBpZiAoc3RhcnQgIT09IC0xKSB7XG4gICAgeWllbGQgeyBzdGFydCwgZW5kIH07XG4gIH1cbn1cbmZ1bmN0aW9uKiBwYXRoUmFuZ2VQb2ludHMocG9pbnRzLCB7IHN0YXJ0LCBlbmQgfSkge1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgIHlpZWxkIHBvaW50c1tpXS5wb2ludDtcbiAgfVxufVxuZnVuY3Rpb24qIHBhdGhSYW5nZVBvaW50c1JldmVyc2UocG9pbnRzLCB7IHN0YXJ0LCBlbmQgfSkge1xuICBmb3IgKGxldCBpID0gZW5kIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAxKSB7XG4gICAgeWllbGQgcG9pbnRzW2ldLnBvaW50O1xuICB9XG59XG5mdW5jdGlvbiBpbnRlZ3JhdGVkQ2F0ZWdvcnlNYXRjaChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKFwiaWRcIiBpbiBhICYmIFwiaWRcIiBpbiBiKSB7XG4gICAgcmV0dXJuIGEuaWQgPT09IGIuaWQ7XG4gIH1cbiAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gc2NhbGUodmFsLCBzY2FsaW5nKSB7XG4gIGlmICghc2NhbGluZylcbiAgICByZXR1cm4gTmFOO1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHZhbCA9IHZhbC5nZXRUaW1lKCk7XG4gIH1cbiAgaWYgKHNjYWxpbmcudHlwZSA9PT0gXCJjb250aW51b3VzXCIgJiYgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvbnN0IGRvbWFpblJhdGlvID0gKHZhbCAtIHNjYWxpbmcuZG9tYWluWzBdKSAvIChzY2FsaW5nLmRvbWFpblsxXSAtIHNjYWxpbmcuZG9tYWluWzBdKTtcbiAgICByZXR1cm4gZG9tYWluUmF0aW8gKiAoc2NhbGluZy5yYW5nZVsxXSAtIHNjYWxpbmcucmFuZ2VbMF0pICsgc2NhbGluZy5yYW5nZVswXTtcbiAgfVxuICBpZiAoc2NhbGluZy50eXBlID09PSBcImxvZ1wiICYmIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gc2NhbGluZy5jb252ZXJ0KHZhbCk7XG4gIH1cbiAgY29uc3QgbWF0Y2hpbmdJbmRleCA9IHNjYWxpbmcuZG9tYWluLmZpbmRJbmRleCgoZCkgPT4gZCA9PT0gdmFsKTtcbiAgaWYgKG1hdGNoaW5nSW5kZXggPj0gMCkge1xuICAgIHJldHVybiBzY2FsaW5nLnJhbmdlW21hdGNoaW5nSW5kZXhdO1xuICB9XG4gIGNvbnN0IG1hdGNoaW5nSW50ZWdyYXRlZEluZGV4ID0gc2NhbGluZy5kb21haW4uZmluZEluZGV4KChkKSA9PiBpbnRlZ3JhdGVkQ2F0ZWdvcnlNYXRjaCh2YWwsIGQpKTtcbiAgaWYgKG1hdGNoaW5nSW50ZWdyYXRlZEluZGV4ID49IDApIHtcbiAgICByZXR1cm4gc2NhbGluZy5yYW5nZVttYXRjaGluZ0ludGVncmF0ZWRJbmRleF07XG4gIH1cbiAgcmV0dXJuIE5hTjtcbn1cbmZ1bmN0aW9uIHNjYWxlc0NoYW5nZWQobmV3RGF0YSwgb2xkRGF0YSkge1xuICByZXR1cm4gIWFyZVNjYWxpbmdFcXVhbChuZXdEYXRhLnNjYWxlcy54LCBvbGREYXRhLnNjYWxlcy54KSB8fCAhYXJlU2NhbGluZ0VxdWFsKG5ld0RhdGEuc2NhbGVzLnksIG9sZERhdGEuc2NhbGVzLnkpO1xufVxuZnVuY3Rpb24gY2xvc2VNYXRjaChhLCBiKSB7XG4gIGNvbnN0IGFuID0gTnVtYmVyKGEpO1xuICBjb25zdCBibiA9IE51bWJlcihiKTtcbiAgaWYgKCFpc05hTihhbikgJiYgIWlzTmFOKGJuKSkge1xuICAgIHJldHVybiBNYXRoLmFicyhibiAtIGFuKSA8IDAuMjU7XG4gIH1cbiAgcmV0dXJuIGEgPT09IGI7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNb3ZlVG8oZnJvbTIgPSBmYWxzZSwgdG8gPSBmYWxzZSkge1xuICBpZiAoZnJvbTIgPT09IHRvKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZnJvbTIpO1xuICB9XG4gIHJldHVybiBmcm9tMiA/IFwiaW5cIiA6IFwib3V0XCI7XG59XG5mdW5jdGlvbiBwYWlyQ29udGludW91c0RhdGEobmV3RGF0YSwgb2xkRGF0YSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFja2ZpbGxTcGxpdE1vZGUgPSBcImludGVyc2VjdFwiIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgcmVzdWx0TWFwID0ge1xuICAgIGFkZGVkOiB7fSxcbiAgICBtb3ZlZDoge30sXG4gICAgcmVtb3ZlZDoge31cbiAgfTtcbiAgY29uc3QgcGFpclVwID0gKGZyb20yLCB0bywgeFZhbHVlLCBjaGFuZ2UgPSBcIm1vdmVcIikgPT4ge1xuICAgIGlmIChmcm9tMiAmJiAoaXNOYU4oZnJvbTIucG9pbnQueCkgfHwgaXNOYU4oZnJvbTIucG9pbnQueSkpKSB7XG4gICAgICBmcm9tMiA9IHRvO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRQb2ludCA9IHtcbiAgICAgIGZyb206IGZyb20yPy5wb2ludCxcbiAgICAgIHRvOiB0bz8ucG9pbnQsXG4gICAgICBtb3ZlVG86IGNhbGN1bGF0ZU1vdmVUbyhmcm9tMj8ucG9pbnQubW92ZVRvLCB0bz8ucG9pbnQubW92ZVRvKSxcbiAgICAgIGNoYW5nZVxuICAgIH07XG4gICAgaWYgKGNoYW5nZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgIHJlc3VsdE1hcC5tb3ZlZFt4VmFsdWVdID0gcmVzdWx0UG9pbnQ7XG4gICAgICBvbGRJZHgrKztcbiAgICAgIG5ld0lkeCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlID09PSBcImluXCIpIHtcbiAgICAgIHJlc3VsdE1hcC5hZGRlZFt4VmFsdWVdID0gcmVzdWx0UG9pbnQ7XG4gICAgICBuZXdJZHgrKztcbiAgICB9IGVsc2UgaWYgKGNoYW5nZSA9PT0gXCJvdXRcIikge1xuICAgICAgcmVzdWx0TWFwLnJlbW92ZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xuICAgICAgb2xkSWR4Kys7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHJlc3VsdFBvaW50KTtcbiAgfTtcbiAgY29uc3QgeyBtaW46IG1pbkZyb21Ob2RlLCBtYXg6IG1heEZyb21Ob2RlIH0gPSBtaW5NYXgob2xkRGF0YS5ub2RlRGF0YSk7XG4gIGNvbnN0IHsgbWluOiBtaW5Ub05vZGUsIG1heDogbWF4VG9Ob2RlIH0gPSBtaW5NYXgobmV3RGF0YS5ub2RlRGF0YSk7XG4gIGxldCBvbGRJZHggPSAwO1xuICBsZXQgbmV3SWR4ID0gMDtcbiAgd2hpbGUgKG9sZElkeCA8IG9sZERhdGEubm9kZURhdGEubGVuZ3RoIHx8IG5ld0lkeCA8IG5ld0RhdGEubm9kZURhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgZnJvbTIgPSBvbGREYXRhLm5vZGVEYXRhW29sZElkeF07XG4gICAgY29uc3QgdG8gPSBuZXdEYXRhLm5vZGVEYXRhW25ld0lkeF07XG4gICAgY29uc3QgZnJvbVNoaWZ0ZWQgPSBmcm9tMiA/IHNjYWxlKGZyb20yLnhWYWx1ZSA/PyBOYU4sIG5ld0RhdGEuc2NhbGVzLngpIDogdm9pZCAwO1xuICAgIGNvbnN0IHRvVW5zaGlmdGVkID0gdG8gPyBzY2FsZSh0by54VmFsdWUgPz8gTmFOLCBvbGREYXRhLnNjYWxlcy54KSA6IHZvaWQgMDtcbiAgICBjb25zdCBOQSA9IHZvaWQgMDtcbiAgICBpZiAoZnJvbVNoaWZ0ZWQgIT0gbnVsbCAmJiBjbG9zZU1hdGNoKGZyb21TaGlmdGVkLCB0bz8ucG9pbnQueCkpIHtcbiAgICAgIHBhaXJVcChmcm9tMiwgdG8sIHRvLnhWYWx1ZSwgXCJtb3ZlXCIpO1xuICAgIH0gZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgIT0gbnVsbCAmJiBmcm9tU2hpZnRlZCA8IChtaW5Ub05vZGU/LnBvaW50LnggPz8gLUluZmluaXR5KSkge1xuICAgICAgcGFpclVwKGZyb20yLCBOQSwgZnJvbTIueFZhbHVlLCBcIm91dFwiKTtcbiAgICB9IGVsc2UgaWYgKGZyb21TaGlmdGVkICE9IG51bGwgJiYgZnJvbVNoaWZ0ZWQgPiAobWF4VG9Ob2RlPy5wb2ludC54ID8/IEluZmluaXR5KSkge1xuICAgICAgcGFpclVwKGZyb20yLCBOQSwgZnJvbTIueFZhbHVlLCBcIm91dFwiKTtcbiAgICB9IGVsc2UgaWYgKHRvVW5zaGlmdGVkICE9IG51bGwgJiYgdG9VbnNoaWZ0ZWQgPCAobWluRnJvbU5vZGU/LnBvaW50LnggPz8gLUluZmluaXR5KSkge1xuICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCBcImluXCIpO1xuICAgIH0gZWxzZSBpZiAodG9VbnNoaWZ0ZWQgIT0gbnVsbCAmJiB0b1Vuc2hpZnRlZCA+IChtYXhGcm9tTm9kZT8ucG9pbnQueCA/PyBJbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2UgaWYgKGZyb21TaGlmdGVkICE9IG51bGwgJiYgZnJvbVNoaWZ0ZWQgPCB0bz8ucG9pbnQueCkge1xuICAgICAgcGFpclVwKGZyb20yLCBOQSwgZnJvbTIueFZhbHVlLCBcIm91dFwiKTtcbiAgICB9IGVsc2UgaWYgKHRvVW5zaGlmdGVkICE9IG51bGwgJiYgdG9VbnNoaWZ0ZWQgPCBmcm9tMj8ucG9pbnQueCkge1xuICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCBcImluXCIpO1xuICAgIH0gZWxzZSBpZiAoZnJvbTIpIHtcbiAgICAgIHBhaXJVcChmcm9tMiwgTkEsIGZyb20yLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmICh0bykge1xuICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCBcImluXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcHJvY2VzcyBwb2ludHNcIik7XG4gICAgfVxuICB9XG4gIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIGJhY2tmaWxsU3BsaXRNb2RlKTtcbiAgcmV0dXJuIHsgcmVzdWx0LCByZXN1bHRNYXAgfTtcbn1cbmZ1bmN0aW9uIHBhaXJDYXRlZ29yeURhdGEobmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJhY2tmaWxsU3BsaXRNb2RlID0gXCJpbnRlcnNlY3RcIiwgbXVsdGlEYXR1bSA9IGZhbHNlIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgcmVzdWx0TWFwU2luZ2xlID0ge1xuICAgIGFkZGVkOiB7fSxcbiAgICBtb3ZlZDoge30sXG4gICAgcmVtb3ZlZDoge31cbiAgfTtcbiAgY29uc3QgcmVzdWx0TWFwTXVsdGkgPSB7XG4gICAgYWRkZWQ6IHt9LFxuICAgIG1vdmVkOiB7fSxcbiAgICByZW1vdmVkOiB7fVxuICB9O1xuICBjb25zdCBwb2ludFJlc3VsdE1hcHBpbmcgPSB7XG4gICAgaW46IFwiYWRkZWRcIixcbiAgICBtb3ZlOiBcIm1vdmVkXCIsXG4gICAgb3V0OiBcInJlbW92ZWRcIlxuICB9O1xuICBsZXQgcHJldmlvdXNSZXN1bHRQb2ludCA9IHZvaWQgMDtcbiAgbGV0IHByZXZpb3VzWFZhbHVlID0gdm9pZCAwO1xuICBjb25zdCBhZGRUb1Jlc3VsdE1hcCA9ICh4VmFsdWUsIG5ld1BvaW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHR5cGUgPSBwb2ludFJlc3VsdE1hcHBpbmdbbmV3UG9pbnQuY2hhbmdlXTtcbiAgICBpZiAobXVsdGlEYXR1bSkge1xuICAgICAgKF9hID0gcmVzdWx0TWFwTXVsdGlbdHlwZV0pW3hWYWx1ZV0gPz8gKF9hW3hWYWx1ZV0gPSBbXSk7XG4gICAgICByZXN1bHRNYXBNdWx0aVt0eXBlXVt4VmFsdWVdLnB1c2gobmV3UG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRNYXBTaW5nbGVbdHlwZV1beFZhbHVlXSA9IG5ld1BvaW50O1xuICAgIH1cbiAgICBwcmV2aW91c1Jlc3VsdFBvaW50ID0gbmV3UG9pbnQ7XG4gICAgcHJldmlvdXNYVmFsdWUgPSB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZSh4VmFsdWUpO1xuICB9O1xuICBsZXQgb2xkSW5kZXggPSAwO1xuICBsZXQgbmV3SW5kZXggPSAwO1xuICBsZXQgaXNYVW5vcmRlcmVkID0gZmFsc2U7XG4gIHdoaWxlIChvbGRJbmRleCA8IG9sZERhdGEubm9kZURhdGEubGVuZ3RoIHx8IG5ld0luZGV4IDwgbmV3RGF0YS5ub2RlRGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBvbGREYXRhLm5vZGVEYXRhW29sZEluZGV4XTtcbiAgICBjb25zdCBhZnRlciA9IG5ld0RhdGEubm9kZURhdGFbbmV3SW5kZXhdO1xuICAgIGNvbnN0IGJYVmFsdWUgPSB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShiZWZvcmU/LnhWYWx1ZSk7XG4gICAgY29uc3QgYVhWYWx1ZSA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGFmdGVyPy54VmFsdWUpO1xuICAgIGxldCByZXN1bHRQb2ludDtcbiAgICBpZiAoYlhWYWx1ZSA9PT0gYVhWYWx1ZSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIGNoYW5nZTogXCJtb3ZlXCIsXG4gICAgICAgIG1vdmVUbzogY2FsY3VsYXRlTW92ZVRvKGJlZm9yZS5wb2ludC5tb3ZlVG8gPz8gZmFsc2UsIGFmdGVyLnBvaW50Lm1vdmVUbyksXG4gICAgICAgIGZyb206IGJlZm9yZS5wb2ludCxcbiAgICAgICAgdG86IGFmdGVyLnBvaW50XG4gICAgICB9O1xuICAgICAgYWRkVG9SZXN1bHRNYXAoYmVmb3JlPy54VmFsdWUsIHJlc3VsdFBvaW50KTtcbiAgICAgIG9sZEluZGV4Kys7XG4gICAgICBuZXdJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoZGlmZjI/LnJlbW92ZWQuaGFzKFN0cmluZyhiWFZhbHVlKSkpIHtcbiAgICAgIHJlc3VsdFBvaW50ID0ge1xuICAgICAgICBjaGFuZ2U6IFwib3V0XCIsXG4gICAgICAgIG1vdmVUbzogYmVmb3JlLnBvaW50Lm1vdmVUbyA/PyBmYWxzZSxcbiAgICAgICAgZnJvbTogYmVmb3JlLnBvaW50XG4gICAgICB9O1xuICAgICAgYWRkVG9SZXN1bHRNYXAoYmVmb3JlPy54VmFsdWUsIHJlc3VsdFBvaW50KTtcbiAgICAgIG9sZEluZGV4Kys7XG4gICAgfSBlbHNlIGlmIChkaWZmMj8uYWRkZWQuaGFzKFN0cmluZyhhWFZhbHVlKSkpIHtcbiAgICAgIHJlc3VsdFBvaW50ID0ge1xuICAgICAgICBjaGFuZ2U6IFwiaW5cIixcbiAgICAgICAgbW92ZVRvOiBhZnRlci5wb2ludC5tb3ZlVG8gPz8gZmFsc2UsXG4gICAgICAgIHRvOiBhZnRlci5wb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGFmdGVyPy54VmFsdWUsIHJlc3VsdFBvaW50KTtcbiAgICAgIG5ld0luZGV4Kys7XG4gICAgfSBlbHNlIGlmIChtdWx0aURhdHVtICYmIHByZXZpb3VzUmVzdWx0UG9pbnQgJiYgcHJldmlvdXNYVmFsdWUgPT09IGJYVmFsdWUpIHtcbiAgICAgIHJlc3VsdFBvaW50ID0ge1xuICAgICAgICAuLi5wcmV2aW91c1Jlc3VsdFBvaW50XG4gICAgICB9O1xuICAgICAgYWRkVG9SZXN1bHRNYXAoYmVmb3JlPy54VmFsdWUsIHJlc3VsdFBvaW50KTtcbiAgICAgIG9sZEluZGV4Kys7XG4gICAgfSBlbHNlIGlmIChtdWx0aURhdHVtICYmIHByZXZpb3VzUmVzdWx0UG9pbnQgJiYgcHJldmlvdXNYVmFsdWUgPT09IGFYVmFsdWUpIHtcbiAgICAgIHJlc3VsdFBvaW50ID0ge1xuICAgICAgICAuLi5wcmV2aW91c1Jlc3VsdFBvaW50XG4gICAgICB9O1xuICAgICAgYWRkVG9SZXN1bHRNYXAoYWZ0ZXI/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgbmV3SW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaXNYVW5vcmRlcmVkID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChyZXN1bHRQb2ludCk7XG4gIH1cbiAgbGV0IHByZXZpb3VzWCA9IC1JbmZpbml0eTtcbiAgaXNYVW5vcmRlcmVkIHx8IChpc1hVbm9yZGVyZWQgPSByZXN1bHQuc29tZSgocGF0aFBvaW50KSA9PiB7XG4gICAgY29uc3QgeyBjaGFuZ2U6IG1hcmtlciwgdG86IHsgeCA9IC1JbmZpbml0eSB9ID0ge30gfSA9IHBhdGhQb2ludDtcbiAgICBpZiAobWFya2VyID09PSBcIm91dFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHVub3JkZXJlZCA9IHggPCBwcmV2aW91c1g7XG4gICAgcHJldmlvdXNYID0geDtcbiAgICByZXR1cm4gdW5vcmRlcmVkO1xuICB9KSk7XG4gIGlmIChpc1hVbm9yZGVyZWQpIHtcbiAgICByZXR1cm4geyByZXN1bHQ6IHZvaWQgMCwgcmVzdWx0TWFwOiB2b2lkIDAgfTtcbiAgfVxuICBiYWNrZmlsbFBhdGhQb2ludERhdGEocmVzdWx0LCBiYWNrZmlsbFNwbGl0TW9kZSk7XG4gIHJldHVybiB7IHJlc3VsdCwgcmVzdWx0TWFwOiBtdWx0aURhdHVtID8gcmVzdWx0TWFwTXVsdGkgOiByZXN1bHRNYXBTaW5nbGUgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVBhdGhTdGF0dXMobmV3RGF0YSwgb2xkRGF0YSwgcGFpckRhdGEpIHtcbiAgbGV0IHN0YXR1cyA9IFwidXBkYXRlZFwiO1xuICBjb25zdCB2aXNpYmxlID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YS52aXNpYmxlO1xuICB9O1xuICBpZiAoIXZpc2libGUob2xkRGF0YSkgJiYgdmlzaWJsZShuZXdEYXRhKSkge1xuICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgfSBlbHNlIGlmICh2aXNpYmxlKG9sZERhdGEpICYmICF2aXNpYmxlKG5ld0RhdGEpKSB7XG4gICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWlyRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhaXJEYXRhW2ldLmNoYW5nZSAhPT0gXCJtb3ZlXCIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKHBhaXJEYXRhW2ldLmZyb20/LnggIT09IHBhaXJEYXRhW2ldLnRvPy54KVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChwYWlyRGF0YVtpXS5mcm9tPy55ICE9PSBwYWlyRGF0YVtpXS50bz8ueSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoaSA9PT0gcGFpckRhdGEubGVuZ3RoIC0gMSlcbiAgICAgICAgcmV0dXJuIFwibm8tb3BcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXR1cztcbn1cbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uKHN0YXR1cywgdmlzaWJsZVRvZ2dsZU1vZGUpIHtcbiAgY29uc3QgcGhhc2UgPSB2aXNpYmxlVG9nZ2xlTW9kZSA9PT0gXCJub25lXCIgPyBcInVwZGF0ZWRcIiA6IHN0YXR1cztcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGZyb21GbjogKF9wYXRoKSA9PiB7XG4gICAgICBsZXQgbWl4aW47XG4gICAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgICBtaXhpbiA9IHsgZmluaXNoOiB7IHZpc2libGU6IGZhbHNlIH0gfTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgbWl4aW4gPSB7IHN0YXJ0OiB7IHZpc2libGU6IHRydWUgfSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWl4aW4gPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3BoYXNlXSwgLi4ubWl4aW4gfTtcbiAgICB9LFxuICAgIHRvRm46IChfcGF0aCkgPT4ge1xuICAgICAgcmV0dXJuIHsgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdIH07XG4gICAgfVxuICB9O1xuICBpZiAodmlzaWJsZVRvZ2dsZU1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21GbjogKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHN0YXR1cyA9PT0gXCJhZGRlZFwiID8gMCA6IHBhdGgub3BhY2l0eTtcbiAgICAgICAgcmV0dXJuIHsgb3BhY2l0eSwgLi4ucmVzdWx0LmZyb21GbihwYXRoKSB9O1xuICAgICAgfSxcbiAgICAgIHRvRm46IChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBzdGF0dXMgPT09IFwicmVtb3ZlZFwiID8gMCA6IDE7XG4gICAgICAgIHJldHVybiB7IG9wYWNpdHksIC4uLnJlc3VsdC50b0ZuKHBhdGgpIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhLCB2aXNpYmxlVG9nZ2xlTW9kZSwgaW50ZXJwb2xhdGlvbiwgcmVuZGVyKSB7XG4gIGNvbnN0IHN0YXR1cyA9IGRldGVybWluZVBhdGhTdGF0dXMobmV3RGF0YSwgb2xkRGF0YSwgcGFpckRhdGEpO1xuICBjb25zdCByZW1vdmVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4ge1xuICAgIHJlbmRlcihwYWlyRGF0YSwgeyBtb3ZlOiAwLCBvdXQ6IHJhdGlvMiB9LCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHtcbiAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogcmF0aW8yIH0sIHBhdGgsIGludGVycG9sYXRpb24pO1xuICB9O1xuICBjb25zdCBhZGRQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4ge1xuICAgIHJlbmRlcihwYWlyRGF0YSwgeyBtb3ZlOiAxLCBpbjogcmF0aW8yIH0sIHBhdGgsIGludGVycG9sYXRpb24pO1xuICB9O1xuICBjb25zdCBwYXRoUHJvcGVydGllcyA9IHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uKHN0YXR1cywgdmlzaWJsZVRvZ2dsZU1vZGUpO1xuICByZXR1cm4geyBzdGF0dXMsIHBhdGg6IHsgYWRkUGhhc2VGbiwgdXBkYXRlUGhhc2VGbiwgcmVtb3ZlUGhhc2VGbiB9LCBwYXRoUHJvcGVydGllcyB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyLCBpbnRlcnBvbGF0aW9uKSB7XG4gIGNvbnN0IGlzQ2F0ZWdvcnlCYXNlZCA9IG5ld0RhdGEuc2NhbGVzLng/LnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgY29uc3Qgd2FzQ2F0ZWdvcnlCYXNlZCA9IG9sZERhdGEuc2NhbGVzLng/LnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgaWYgKGlzQ2F0ZWdvcnlCYXNlZCAhPT0gd2FzQ2F0ZWdvcnlCYXNlZCB8fCAhaXNTY2FsZVZhbGlkKG5ld0RhdGEuc2NhbGVzLngpIHx8ICFpc1NjYWxlVmFsaWQob2xkRGF0YS5zY2FsZXMueCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyByZXN1bHQ6IHBhaXJEYXRhLCByZXN1bHRNYXA6IHBhaXJNYXAgfSA9IGlzQ2F0ZWdvcnlCYXNlZCA/IHBhaXJDYXRlZ29yeURhdGEobmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIpIDogcGFpckNvbnRpbnVvdXNEYXRhKG5ld0RhdGEsIG9sZERhdGEpO1xuICBsZXQgc3RhdHVzID0gXCJ1cGRhdGVkXCI7XG4gIGlmIChvbGREYXRhLnZpc2libGUgJiYgIW5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICB9IGVsc2UgaWYgKCFvbGREYXRhLnZpc2libGUgJiYgbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICB9XG4gIGlmIChwYWlyRGF0YSA9PT0gdm9pZCAwIHx8IHBhaXJNYXAgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYXNNb3Rpb24gPSAoZGlmZjI/LmNoYW5nZWQgPz8gdHJ1ZSkgfHwgc2NhbGVzQ2hhbmdlZChuZXdEYXRhLCBvbGREYXRhKSB8fCBzdGF0dXMgIT09IFwidXBkYXRlZFwiO1xuICBjb25zdCBwYXRoRm5zID0gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhLCBcImZhZGVcIiwgaW50ZXJwb2xhdGlvbiwgcmVuZGVyUGFydGlhbFBhdGgpO1xuICBjb25zdCBtYXJrZXIgPSBwcmVwYXJlTWFya2VyQW5pbWF0aW9uKHBhaXJNYXAsIHN0YXR1cyk7XG4gIHJldHVybiB7IC4uLnBhdGhGbnMsIG1hcmtlciwgaGFzTW90aW9uIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZUludGVycG9sYXRpb25VdGlsLnRzXG5mdW5jdGlvbiBjbG9zZUNtcChhLCBiLCBkZWx0YTMgPSAxZS02KSB7XG4gIGlmIChhID09PSBiIHx8IDEgLSBNYXRoLm1pbihhLCBiKSAvIE1hdGgubWF4KGEsIGIpIDwgZGVsdGEzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb3NlTWF0Y2gyKGEsIGIsIGRlbHRhMykge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGFuID0gTnVtYmVyKGEpO1xuICBjb25zdCBibiA9IE51bWJlcihiKTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShhbikgJiYgTnVtYmVyLmlzRmluaXRlKGJuKSAmJiBjbG9zZUNtcChhbiwgYm4sIGRlbHRhMykgPT09IDA7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGFucyhzcGFuRGF0YSwgeyB4OiB4U2NhbGUsIHk6IHlTY2FsZSB9KSB7XG4gIGxldCByYW5nZVNwYW5EYXRhO1xuICBjb25zdCBpbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zID0gW107XG4gIGxldCBzaGlmdGVkWFN0YXJ0ID0gSW5maW5pdHk7XG4gIGxldCBzaGlmdGVkWEVuZCA9IC1JbmZpbml0eTtcbiAgZm9yIChjb25zdCBzcGFuRGF0dW0gb2Ygc3BhbkRhdGEpIHtcbiAgICBjb25zdCB4MCA9IHNjYWxlKHNwYW5EYXR1bS54VmFsdWUwLCB4U2NhbGUpO1xuICAgIGNvbnN0IHkwID0gc2NhbGUoc3BhbkRhdHVtLnlWYWx1ZTAsIHlTY2FsZSk7XG4gICAgY29uc3QgeDEgPSBzY2FsZShzcGFuRGF0dW0ueFZhbHVlMSwgeFNjYWxlKTtcbiAgICBjb25zdCB5MSA9IHNjYWxlKHNwYW5EYXR1bS55VmFsdWUxLCB5U2NhbGUpO1xuICAgIGNvbnN0IHN0YXJ0SXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUoeDApO1xuICAgIGNvbnN0IGVuZElzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHgxKTtcbiAgICBpZiAoc3RhcnRJc0Zpbml0ZSAmJiBlbmRJc0Zpbml0ZSAmJiByYW5nZVNwYW5EYXRhID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVuc2hpZnRlZCA9IHNwYW5EYXR1bS5zcGFuO1xuICAgICAgY29uc3Qgc2hpZnRlZCA9IHJlc2NhbGVTcGFuKHVuc2hpZnRlZCwgeyB4OiB4MCwgeTogeTAgfSwgeyB4OiB4MSwgeTogeTEgfSk7XG4gICAgICBjb25zdCBzcGFuVHJhbnNmb3JtID0geyB1bnNoaWZ0ZWQsIHNoaWZ0ZWQgfTtcbiAgICAgIHNoaWZ0ZWRYU3RhcnQgPSBNYXRoLm1pbihzaGlmdGVkWFN0YXJ0LCB4MCk7XG4gICAgICBzaGlmdGVkWEVuZCA9IE1hdGgubWF4KHNoaWZ0ZWRYRW5kLCB4MSk7XG4gICAgICBpbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zLnB1c2goc3BhblRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmIChzdGFydElzRmluaXRlICYmICFlbmRJc0Zpbml0ZSAmJiByYW5nZVNwYW5EYXRhID09IG51bGwpIHtcbiAgICAgIHJhbmdlU3BhbkRhdGEgPSBbc3BhbkRhdHVtXTtcbiAgICB9IGVsc2UgaWYgKCFzdGFydElzRmluaXRlICYmICFlbmRJc0Zpbml0ZSAmJiByYW5nZVNwYW5EYXRhICE9IG51bGwpIHtcbiAgICAgIGlmIChyYW5nZVNwYW5EYXRhICE9IG51bGwpIHtcbiAgICAgICAgcmFuZ2VTcGFuRGF0YS5wdXNoKHNwYW5EYXR1bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc3RhcnRJc0Zpbml0ZSAmJiBlbmRJc0Zpbml0ZSAmJiByYW5nZVNwYW5EYXRhICE9IG51bGwpIHtcbiAgICAgIHJhbmdlU3BhbkRhdGEucHVzaChzcGFuRGF0dW0pO1xuICAgICAgY29uc3Qgc3RhcnRTcGFuRGF0dW0gPSByYW5nZVNwYW5EYXRhLmF0KDApO1xuICAgICAgY29uc3QgZW5kU3BhbkRhdHVtID0gcmFuZ2VTcGFuRGF0YS5hdCgtMSk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1TdGFydCA9IHtcbiAgICAgICAgeDogc2NhbGUoc3RhcnRTcGFuRGF0dW0ueFZhbHVlMCwgeFNjYWxlKSxcbiAgICAgICAgeTogc2NhbGUoc3RhcnRTcGFuRGF0dW0ueVZhbHVlMCwgeVNjYWxlKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybUVuZCA9IHtcbiAgICAgICAgeDogc2NhbGUoZW5kU3BhbkRhdHVtLnhWYWx1ZTEsIHhTY2FsZSksXG4gICAgICAgIHk6IHNjYWxlKGVuZFNwYW5EYXR1bS55VmFsdWUxLCB5U2NhbGUpXG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RlcCA9ICh0cmFuc2Zvcm1FbmQueCAtIHRyYW5zZm9ybVN0YXJ0LngpIC8gKHJhbmdlU3BhbkRhdGEubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlU3BhbkRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgeyBzcGFuOiBpbnRlcnBvbGF0aW5nVW5zaGlmdGVkLCB5VmFsdWUwLCB5VmFsdWUxIH0gPSByYW5nZVNwYW5EYXRhW2ldO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW5nU2hpZnRlZCA9IHJlc2NhbGVTcGFuKFxuICAgICAgICAgIGludGVycG9sYXRpbmdVbnNoaWZ0ZWQsXG4gICAgICAgICAgeyB4OiB0cmFuc2Zvcm1TdGFydC54ICsgc3RlcCAqIChpICsgMCksIHk6IHNjYWxlKHlWYWx1ZTAsIHlTY2FsZSkgfSxcbiAgICAgICAgICB7IHg6IHRyYW5zZm9ybVN0YXJ0LnggKyBzdGVwICogKGkgKyAxKSwgeTogc2NhbGUoeVZhbHVlMSwgeVNjYWxlKSB9XG4gICAgICAgICk7XG4gICAgICAgIGludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMucHVzaCh7IHVuc2hpZnRlZDogaW50ZXJwb2xhdGluZ1Vuc2hpZnRlZCwgc2hpZnRlZDogaW50ZXJwb2xhdGluZ1NoaWZ0ZWQgfSk7XG4gICAgICB9XG4gICAgICBzaGlmdGVkWFN0YXJ0ID0gTWF0aC5taW4oc2hpZnRlZFhTdGFydCwgdHJhbnNmb3JtU3RhcnQueCk7XG4gICAgICBzaGlmdGVkWEVuZCA9IE1hdGgubWF4KHNoaWZ0ZWRYRW5kLCB0cmFuc2Zvcm1FbmQueCk7XG4gICAgICByYW5nZVNwYW5EYXRhID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0SXNGaW5pdGUgJiYgZW5kSXNGaW5pdGUgJiYgcmFuZ2VTcGFuRGF0YSA9PSBudWxsKSB7XG4gICAgICBjb25zdCB1bnNoaWZ0ZWQgPSBzcGFuRGF0dW0uc3BhbjtcbiAgICAgIGNvbnN0IHNoaWZ0ZWQgPSByZXNjYWxlU3Bhbih1bnNoaWZ0ZWQsIHsgeDogeDEsIHk6IHkwIH0sIHsgeDogeDEsIHk6IHkxIH0pO1xuICAgICAgaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucy5wdXNoKHsgdW5zaGlmdGVkLCBzaGlmdGVkIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZVNwYW5EYXRhID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAocmFuZ2VTcGFuRGF0YSAhPSBudWxsKSB7XG4gICAgY29uc3Qgc3RhcnRTcGFuRGF0dW0gPSByYW5nZVNwYW5EYXRhLmF0KDApO1xuICAgIGNvbnN0IHggPSBzY2FsZShzdGFydFNwYW5EYXR1bS54VmFsdWUwLCB4U2NhbGUpO1xuICAgIGZvciAoY29uc3QgeyBzcGFuOiBpbnRlcnBvbGF0aW5nVW5zaGlmdGVkLCB5VmFsdWUwLCB5VmFsdWUxIH0gb2YgcmFuZ2VTcGFuRGF0YSkge1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGluZ1NoaWZ0ZWQgPSByZXNjYWxlU3BhbihcbiAgICAgICAgaW50ZXJwb2xhdGluZ1Vuc2hpZnRlZCxcbiAgICAgICAgeyB4LCB5OiBzY2FsZSh5VmFsdWUwLCB5U2NhbGUpIH0sXG4gICAgICAgIHsgeCwgeTogc2NhbGUoeVZhbHVlMSwgeVNjYWxlKSB9XG4gICAgICApO1xuICAgICAgaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucy5wdXNoKHsgdW5zaGlmdGVkOiBpbnRlcnBvbGF0aW5nVW5zaGlmdGVkLCBzaGlmdGVkOiBpbnRlcnBvbGF0aW5nU2hpZnRlZCB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hpZnRlZFhSYW5nZSA9IFtzaGlmdGVkWFN0YXJ0LCBzaGlmdGVkWEVuZF07XG4gIHJldHVybiB7IGludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMsIHNoaWZ0ZWRYUmFuZ2UgfTtcbn1cbmZ1bmN0aW9uIHBhaXJVcFNwYW5zKG5ld0RhdGEsIG9sZERhdGEsIHNwbGl0TW9kZSkge1xuICBjb25zdCBvbGRTcGFucyA9IHRyYW5zZm9ybVNwYW5zKG9sZERhdGEuZGF0YSwgbmV3RGF0YS5zY2FsZXMpO1xuICBjb25zdCBuZXdTcGFucyA9IHRyYW5zZm9ybVNwYW5zKG5ld0RhdGEuZGF0YSwgb2xkRGF0YS5zY2FsZXMpO1xuICBjb25zdCBbb2xkUmFuZ2VTdGFydE5ld1NjYWxlLCBvbGRSYW5nZUVuZE5ld1NjYWxlXSA9IG9sZFNwYW5zLnNoaWZ0ZWRYUmFuZ2U7XG4gIGNvbnN0IFtuZXdSYW5nZVN0YXJ0T2xkU2NhbGUsIG5ld1JhbmdlRW5kT2xkU2NhbGVdID0gbmV3U3BhbnMuc2hpZnRlZFhSYW5nZTtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICBjb25zdCBtb3ZlZCA9IFtdO1xuICBmb3IgKGNvbnN0IG9sZFNwYW5EYXR1bSBvZiBvbGRTcGFucy5pbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zKSB7XG4gICAgY29uc3Qgb2xkU3Bhbk9sZFNjYWxlID0gb2xkU3BhbkRhdHVtLnVuc2hpZnRlZDtcbiAgICBjb25zdCBvbGRTcGFuTmV3U2NhbGUgPSBvbGRTcGFuRGF0dW0uc2hpZnRlZDtcbiAgICBjb25zdCBbeyB4OiBmcm9tU3RhcnRPbGRTY2FsZSwgeTogZnJvbVN0YXJ0T2xkU2NhbGVZIH0sIHsgeDogZnJvbUVuZE9sZFNjYWxlLCB5OiBmcm9tRW5kT2xkU2NhbGVZIH1dID0gc3BhblJhbmdlKG9sZFNwYW5PbGRTY2FsZSk7XG4gICAgbGV0IGhhc0NvcnJlc3BvbmRpbmdTcGFuID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBuZXdTcGFuRGF0dW0gb2YgbmV3U3BhbnMuaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucykge1xuICAgICAgY29uc3QgbmV3U3Bhbk9sZFNjYWxlID0gbmV3U3BhbkRhdHVtLnNoaWZ0ZWQ7XG4gICAgICBjb25zdCBuZXdTcGFuTmV3U2NhbGUgPSBuZXdTcGFuRGF0dW0udW5zaGlmdGVkO1xuICAgICAgY29uc3QgW3sgeDogdG9TdGFydE9sZFNjYWxlIH0sIHsgeDogdG9FbmRPbGRTY2FsZSB9XSA9IHNwYW5SYW5nZShuZXdTcGFuT2xkU2NhbGUpO1xuICAgICAgaWYgKGNsb3NlQ21wKGZyb21TdGFydE9sZFNjYWxlLCB0b0VuZE9sZFNjYWxlKSAhPT0gLTEgfHwgY2xvc2VDbXAoZnJvbUVuZE9sZFNjYWxlLCB0b1N0YXJ0T2xkU2NhbGUpICE9PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNsb3NlTWF0Y2gyKGZyb21TdGFydE9sZFNjYWxlLCB0b1N0YXJ0T2xkU2NhbGUpICYmIGNsb3NlTWF0Y2gyKGZyb21FbmRPbGRTY2FsZSwgdG9FbmRPbGRTY2FsZSkpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLCB0bzogb2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgICAgICBtb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLCB0bzogbmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgfSBlbHNlIGlmIChmcm9tU3RhcnRPbGRTY2FsZSA8PSB0b1N0YXJ0T2xkU2NhbGUgJiYgZnJvbUVuZE9sZFNjYWxlID49IHRvRW5kT2xkU2NhbGUpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLCB0bzogb2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgICAgICBtb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLCB0bzogb2xkU3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgW3sgeDogZnJvbVN0YXJ0TmV3U2NhbGUgfSwgeyB4OiBmcm9tRW5kTmV3U2NhbGUgfV0gPSBzcGFuUmFuZ2Uob2xkU3Bhbk5ld1NjYWxlKTtcbiAgICAgICAgY29uc3QgW3sgeDogdG9TdGFydE5ld1NjYWxlIH0sIHsgeDogdG9FbmROZXdTY2FsZSB9XSA9IHNwYW5SYW5nZShuZXdTcGFuTmV3U2NhbGUpO1xuICAgICAgICBjb25zdCB4UmFuZ2VTdGFydE9sZFNjYWxlID0gTWF0aC5tYXgoZnJvbVN0YXJ0T2xkU2NhbGUsIHRvU3RhcnRPbGRTY2FsZSk7XG4gICAgICAgIGNvbnN0IHhSYW5nZUVuZE9sZFNjYWxlID0gTWF0aC5taW4oZnJvbUVuZE9sZFNjYWxlLCB0b0VuZE9sZFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSA9IGNsaXBTcGFuWChvbGRTcGFuT2xkU2NhbGUsIHhSYW5nZVN0YXJ0T2xkU2NhbGUsIHhSYW5nZUVuZE9sZFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2xpcHBlZE5ld1NwYW5PbGRTY2FsZSA9IGNsaXBTcGFuWChuZXdTcGFuT2xkU2NhbGUsIHhSYW5nZVN0YXJ0T2xkU2NhbGUsIHhSYW5nZUVuZE9sZFNjYWxlKTtcbiAgICAgICAgY29uc3QgeFJhbmdlU3RhcnROZXdTY2FsZSA9IE1hdGgubWF4KGZyb21TdGFydE5ld1NjYWxlLCB0b1N0YXJ0TmV3U2NhbGUpO1xuICAgICAgICBjb25zdCB4UmFuZ2VFbmROZXdTY2FsZSA9IE1hdGgubWluKGZyb21FbmROZXdTY2FsZSwgdG9FbmROZXdTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgPSBjbGlwU3BhblgobmV3U3Bhbk5ld1NjYWxlLCB4UmFuZ2VTdGFydE5ld1NjYWxlLCB4UmFuZ2VFbmROZXdTY2FsZSk7XG4gICAgICAgIHJlbW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk9sZFNjYWxlIH0pO1xuICAgICAgICBtb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE5ld1NwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICB9XG4gICAgICBoYXNDb3JyZXNwb25kaW5nU3BhbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChoYXNDb3JyZXNwb25kaW5nU3BhbilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChjbG9zZUNtcChmcm9tRW5kT2xkU2NhbGUsIG5ld1JhbmdlU3RhcnRPbGRTY2FsZSkgIT09IDEpIHtcbiAgICAgIHJlbW92ZWQucHVzaCh7XG4gICAgICAgIGZyb206IG9sZFNwYW5PbGRTY2FsZSxcbiAgICAgICAgdG86IHJlc2NhbGVTcGFuKFxuICAgICAgICAgIG9sZFNwYW5PbGRTY2FsZSxcbiAgICAgICAgICB7IHg6IG5ld1JhbmdlU3RhcnRPbGRTY2FsZSwgeTogZnJvbVN0YXJ0T2xkU2NhbGVZIH0sXG4gICAgICAgICAgeyB4OiBuZXdSYW5nZVN0YXJ0T2xkU2NhbGUsIHk6IGZyb21FbmRPbGRTY2FsZVkgfVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb3NlQ21wKGZyb21TdGFydE9sZFNjYWxlLCBuZXdSYW5nZUVuZE9sZFNjYWxlKSAhPT0gLTEpIHtcbiAgICAgIHJlbW92ZWQucHVzaCh7XG4gICAgICAgIGZyb206IG9sZFNwYW5PbGRTY2FsZSxcbiAgICAgICAgdG86IHJlc2NhbGVTcGFuKFxuICAgICAgICAgIG9sZFNwYW5PbGRTY2FsZSxcbiAgICAgICAgICB7IHg6IG5ld1JhbmdlRW5kT2xkU2NhbGUsIHk6IGZyb21TdGFydE9sZFNjYWxlWSB9LFxuICAgICAgICAgIHsgeDogbmV3UmFuZ2VFbmRPbGRTY2FsZSwgeTogZnJvbUVuZE9sZFNjYWxlWSB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSAwIC8qIFplcm8gKi8pIHtcbiAgICAgIGNvbnN0IHkgPSBzY2FsZSgwLCBvbGREYXRhLnNjYWxlcy55KTtcbiAgICAgIHJlbW92ZWQucHVzaCh7XG4gICAgICAgIGZyb206IG9sZFNwYW5PbGRTY2FsZSxcbiAgICAgICAgdG86IHJlc2NhbGVTcGFuKG9sZFNwYW5PbGRTY2FsZSwgeyB4OiBmcm9tU3RhcnRPbGRTY2FsZSwgeSB9LCB7IHg6IGZyb21FbmRPbGRTY2FsZSwgeSB9KVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IDEgLyogRGl2aWRlICovKSB7XG4gICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gc3BsaXRTcGFuQXRYKG9sZFNwYW5PbGRTY2FsZSwgKGZyb21TdGFydE9sZFNjYWxlICsgZnJvbUVuZE9sZFNjYWxlKSAvIDIpO1xuICAgICAgcmVtb3ZlZC5wdXNoKFxuICAgICAgICB7IGZyb206IGxlZnQsIHRvOiBjb2xsYXBzZVNwYW5Ub1BvaW50KGxlZnQsIHsgeDogZnJvbVN0YXJ0T2xkU2NhbGUsIHk6IGZyb21TdGFydE9sZFNjYWxlWSB9KSB9LFxuICAgICAgICB7IGZyb206IHJpZ2h0LCB0bzogY29sbGFwc2VTcGFuVG9Qb2ludChyaWdodCwgeyB4OiBmcm9tRW5kT2xkU2NhbGUsIHk6IGZyb21FbmRPbGRTY2FsZVkgfSkgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgZm9yIChjb25zdCBuZXdTcGFuRGF0dW0gb2YgbmV3RGF0YS5kYXRhKSB7XG4gICAgY29uc3QgbmV3U3Bhbk5ld1NjYWxlID0gbmV3U3BhbkRhdHVtLnNwYW47XG4gICAgY29uc3QgW3sgeDogdG9TdGFydE5ld1NjYWxlLCB5OiB0b1N0YXJ0TmV3U2NhbGVZIH0sIHsgeDogdG9FbmROZXdTY2FsZSwgeTogdG9FbmROZXdTY2FsZVkgfV0gPSBzcGFuUmFuZ2UobmV3U3Bhbk5ld1NjYWxlKTtcbiAgICBsZXQgaGFzQ29ycmVzcG9uZGluZ1NwYW4gPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG9sZFNwYW5EYXR1bSBvZiBvbGRTcGFucy5pbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zKSB7XG4gICAgICBjb25zdCBvbGRTcGFuTmV3U2NhbGUgPSBvbGRTcGFuRGF0dW0uc2hpZnRlZDtcbiAgICAgIGNvbnN0IFt7IHg6IGZyb21TdGFydE5ld1NjYWxlIH0sIHsgeDogZnJvbUVuZE5ld1NjYWxlIH1dID0gc3BhblJhbmdlKG9sZFNwYW5OZXdTY2FsZSk7XG4gICAgICBpZiAoY2xvc2VDbXAoZnJvbVN0YXJ0TmV3U2NhbGUsIHRvRW5kTmV3U2NhbGUpICE9PSAtMSB8fCBjbG9zZUNtcChmcm9tRW5kTmV3U2NhbGUsIHRvU3RhcnROZXdTY2FsZSkgIT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VNYXRjaDIoZnJvbVN0YXJ0TmV3U2NhbGUsIHRvU3RhcnROZXdTY2FsZSkgJiYgY2xvc2VNYXRjaDIoZnJvbUVuZE5ld1NjYWxlLCB0b0VuZE5ld1NjYWxlKSkge1xuICAgICAgICBhZGRlZC5wdXNoKHsgZnJvbTogbmV3U3Bhbk5ld1NjYWxlLCB0bzogbmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgfSBlbHNlIGlmIChmcm9tU3RhcnROZXdTY2FsZSA8PSB0b1N0YXJ0TmV3U2NhbGUgJiYgZnJvbUVuZE5ld1NjYWxlID49IHRvRW5kTmV3U2NhbGUpIHtcbiAgICAgICAgY29uc3QgY2xpcHBlZE9sZFNwYW5OZXdTY2FsZSA9IGNsaXBTcGFuWChvbGRTcGFuTmV3U2NhbGUsIHRvU3RhcnROZXdTY2FsZSwgdG9FbmROZXdTY2FsZSk7XG4gICAgICAgIGFkZGVkLnB1c2goeyBmcm9tOiBjbGlwcGVkT2xkU3Bhbk5ld1NjYWxlLCB0bzogbmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkZWQucHVzaCh7IGZyb206IG5ld1NwYW5OZXdTY2FsZSwgdG86IG5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICAgIH1cbiAgICAgIGhhc0NvcnJlc3BvbmRpbmdTcGFuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0NvcnJlc3BvbmRpbmdTcGFuKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGNsb3NlQ21wKHRvRW5kTmV3U2NhbGUsIG9sZFJhbmdlU3RhcnROZXdTY2FsZSkgIT09IDEpIHtcbiAgICAgIGFkZGVkLnB1c2goe1xuICAgICAgICBmcm9tOiByZXNjYWxlU3BhbihcbiAgICAgICAgICBuZXdTcGFuTmV3U2NhbGUsXG4gICAgICAgICAgeyB4OiBvbGRSYW5nZVN0YXJ0TmV3U2NhbGUsIHk6IHRvU3RhcnROZXdTY2FsZVkgfSxcbiAgICAgICAgICB7IHg6IG9sZFJhbmdlU3RhcnROZXdTY2FsZSwgeTogdG9FbmROZXdTY2FsZVkgfVxuICAgICAgICApLFxuICAgICAgICB0bzogbmV3U3Bhbk5ld1NjYWxlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb3NlQ21wKHRvU3RhcnROZXdTY2FsZSwgb2xkUmFuZ2VFbmROZXdTY2FsZSkgIT09IC0xKSB7XG4gICAgICBhZGRlZC5wdXNoKHtcbiAgICAgICAgZnJvbTogcmVzY2FsZVNwYW4oXG4gICAgICAgICAgbmV3U3Bhbk5ld1NjYWxlLFxuICAgICAgICAgIHsgeDogb2xkUmFuZ2VFbmROZXdTY2FsZSwgeTogdG9TdGFydE5ld1NjYWxlWSB9LFxuICAgICAgICAgIHsgeDogb2xkUmFuZ2VFbmROZXdTY2FsZSwgeTogdG9FbmROZXdTY2FsZVkgfVxuICAgICAgICApLFxuICAgICAgICB0bzogbmV3U3Bhbk5ld1NjYWxlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gMCAvKiBaZXJvICovKSB7XG4gICAgICBjb25zdCB5ID0gc2NhbGUoMCwgbmV3RGF0YS5zY2FsZXMueSk7XG4gICAgICBhZGRlZC5wdXNoKHtcbiAgICAgICAgZnJvbTogcmVzY2FsZVNwYW4obmV3U3Bhbk5ld1NjYWxlLCB7IHg6IHRvU3RhcnROZXdTY2FsZSwgeSB9LCB7IHg6IHRvRW5kTmV3U2NhbGUsIHkgfSksXG4gICAgICAgIHRvOiBuZXdTcGFuTmV3U2NhbGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSAxIC8qIERpdmlkZSAqLykge1xuICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHNwbGl0U3BhbkF0WChuZXdTcGFuTmV3U2NhbGUsICh0b1N0YXJ0TmV3U2NhbGUgKyB0b0VuZE5ld1NjYWxlKSAvIDIpO1xuICAgICAgYWRkZWQucHVzaChcbiAgICAgICAgeyBmcm9tOiBjb2xsYXBzZVNwYW5Ub1BvaW50KGxlZnQsIHsgeDogdG9TdGFydE5ld1NjYWxlLCB5OiB0b1N0YXJ0TmV3U2NhbGVZIH0pLCB0bzogbmV3U3Bhbk5ld1NjYWxlIH0sXG4gICAgICAgIHsgZnJvbTogY29sbGFwc2VTcGFuVG9Qb2ludChyaWdodCwgeyB4OiB0b0VuZE5ld1NjYWxlLCB5OiB0b0VuZE5ld1NjYWxlWSB9KSwgdG86IG5ld1NwYW5OZXdTY2FsZSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBhZGRlZCwgbW92ZWQsIHJlbW92ZWQgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhVXRpbC50c1xudmFyIEFyZWFTZXJpZXNUYWcgPSAvKiBAX19QVVJFX18gKi8gKChBcmVhU2VyaWVzVGFnMikgPT4ge1xuICBBcmVhU2VyaWVzVGFnMltBcmVhU2VyaWVzVGFnMltcIkZpbGxcIl0gPSAwXSA9IFwiRmlsbFwiO1xuICBBcmVhU2VyaWVzVGFnMltBcmVhU2VyaWVzVGFnMltcIlN0cm9rZVwiXSA9IDFdID0gXCJTdHJva2VcIjtcbiAgQXJlYVNlcmllc1RhZzJbQXJlYVNlcmllc1RhZzJbXCJNYXJrZXJcIl0gPSAyXSA9IFwiTWFya2VyXCI7XG4gIEFyZWFTZXJpZXNUYWcyW0FyZWFTZXJpZXNUYWcyW1wiTGFiZWxcIl0gPSAzXSA9IFwiTGFiZWxcIjtcbiAgcmV0dXJuIEFyZWFTZXJpZXNUYWcyO1xufSkoQXJlYVNlcmllc1RhZyB8fCB7fSk7XG5mdW5jdGlvbiBwbG90U3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucywgcGhhbnRvbVNwYW5zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBzcGFuID0gc3BhbnNbaV07XG4gICAgY29uc3QgcGhhbnRvbVNwYW4gPSBwaGFudG9tU3BhbnNbaV07XG4gICAgcGxvdFNwYW4ocGF0aC5wYXRoLCBpbnRlcnBvbGF0ZVNwYW5zKHNwYW4uZnJvbSwgc3Bhbi50bywgcmF0aW8yKSwgMSAvKiBNb3ZlVG8gKi8pO1xuICAgIHBsb3RTcGFuKHBhdGgucGF0aCwgcmV2ZXJzZVNwYW4oaW50ZXJwb2xhdGVTcGFucyhwaGFudG9tU3Bhbi5mcm9tLCBwaGFudG9tU3Bhbi50bywgcmF0aW8yKSksIDIgLyogTGluZVRvICovKTtcbiAgICBwYXRoLnBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbkZucyhzdGF0dXMsIHNwYW5zLCBwaGFudG9tU3BhbnMsIHZpc2libGVUb2dnbGVNb2RlKSB7XG4gIGNvbnN0IHJlbW92ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90U3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5yZW1vdmVkLCBwaGFudG9tU3BhbnMucmVtb3ZlZCk7XG4gIGNvbnN0IHVwZGF0ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90U3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5tb3ZlZCwgcGhhbnRvbVNwYW5zLm1vdmVkKTtcbiAgY29uc3QgYWRkUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLmFkZGVkLCBwaGFudG9tU3BhbnMuYWRkZWQpO1xuICBjb25zdCBwYXRoUHJvcGVydGllcyA9IHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uKHN0YXR1cywgdmlzaWJsZVRvZ2dsZU1vZGUpO1xuICByZXR1cm4geyBzdGF0dXMsIHBhdGg6IHsgYWRkUGhhc2VGbiwgdXBkYXRlUGhhc2VGbiwgcmVtb3ZlUGhhc2VGbiB9LCBwYXRoUHJvcGVydGllcyB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyKSB7XG4gIGNvbnN0IGlzQ2F0ZWdvcnlCYXNlZCA9IG5ld0RhdGEuc2NhbGVzLng/LnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgY29uc3Qgd2FzQ2F0ZWdvcnlCYXNlZCA9IG9sZERhdGEuc2NhbGVzLng/LnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgaWYgKGlzQ2F0ZWdvcnlCYXNlZCAhPT0gd2FzQ2F0ZWdvcnlCYXNlZCB8fCAhaXNTY2FsZVZhbGlkKG5ld0RhdGEuc2NhbGVzLngpIHx8ICFpc1NjYWxlVmFsaWQob2xkRGF0YS5zY2FsZXMueCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXR1cyA9IFwidXBkYXRlZFwiO1xuICBpZiAob2xkRGF0YS52aXNpYmxlICYmICFuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIGlmICghb2xkRGF0YS52aXNpYmxlICYmIG5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgfVxuICBjb25zdCBzcGFucyA9IHBhaXJVcFNwYW5zKFxuICAgIHsgc2NhbGVzOiBuZXdEYXRhLnNjYWxlcywgZGF0YTogbmV3RGF0YS5maWxsRGF0YS5zcGFucywgdmlzaWJsZTogbmV3RGF0YS52aXNpYmxlIH0sXG4gICAgeyBzY2FsZXM6IG9sZERhdGEuc2NhbGVzLCBkYXRhOiBvbGREYXRhLmZpbGxEYXRhLnNwYW5zLCB2aXNpYmxlOiBvbGREYXRhLnZpc2libGUgfSxcbiAgICAwIC8qIFplcm8gKi9cbiAgKTtcbiAgY29uc3QgcGhhbnRvbVNwYW5zID0gcGFpclVwU3BhbnMoXG4gICAgeyBzY2FsZXM6IG5ld0RhdGEuc2NhbGVzLCBkYXRhOiBuZXdEYXRhLmZpbGxEYXRhLnBoYW50b21TcGFucywgdmlzaWJsZTogbmV3RGF0YS52aXNpYmxlIH0sXG4gICAgeyBzY2FsZXM6IG9sZERhdGEuc2NhbGVzLCBkYXRhOiBvbGREYXRhLmZpbGxEYXRhLnBoYW50b21TcGFucywgdmlzaWJsZTogb2xkRGF0YS52aXNpYmxlIH0sXG4gICAgMCAvKiBaZXJvICovXG4gICk7XG4gIGNvbnN0IHByZXBhcmVNYXJrZXJQYWlycyA9ICgpID0+IHtcbiAgICBpZiAoaXNDYXRlZ29yeUJhc2VkKSB7XG4gICAgICByZXR1cm4gcGFpckNhdGVnb3J5RGF0YShuZXdEYXRhLCBvbGREYXRhLCBkaWZmMiwgeyBiYWNrZmlsbFNwbGl0TW9kZTogXCJzdGF0aWNcIiwgbXVsdGlEYXR1bTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhLCB7IGJhY2tmaWxsU3BsaXRNb2RlOiBcInN0YXRpY1wiIH0pO1xuICB9O1xuICBjb25zdCB7IHJlc3VsdE1hcDogbWFya2VyUGFpck1hcCB9ID0gcHJlcGFyZU1hcmtlclBhaXJzKCk7XG4gIGlmIChtYXJrZXJQYWlyTWFwID09PSB2b2lkIDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBzdGFja1Zpc2libGUgPSB0cnVlO1xuICBjb25zdCBmYWRlTW9kZSA9IHN0YWNrVmlzaWJsZSA/IFwibm9uZVwiIDogXCJmYWRlXCI7XG4gIGNvbnN0IGZpbGwgPSBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb25GbnMoc3RhdHVzLCBzcGFucywgcGhhbnRvbVNwYW5zLCBmYWRlTW9kZSk7XG4gIGNvbnN0IG1hcmtlciA9IHByZXBhcmVNYXJrZXJBbmltYXRpb24obWFya2VyUGFpck1hcCwgc3RhdHVzKTtcbiAgcmV0dXJuIHsgc3RhdHVzLCBmaWxsLCBtYXJrZXIgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhU2VyaWVzLnRzXG52YXIgQXJlYVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtcImZpbGxcIiwgXCJzdHJva2VcIl0sXG4gICAgICBwYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0OiBbMCwgMWUzXSxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBwaWNrTW9kZXM6IFsxIC8qIE5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIHBhdGg6IGJ1aWxkUmVzZXRQYXRoRm4oeyBnZXRWaXNpYmxlOiAoKSA9PiB0aGlzLnZpc2libGUsIGdldE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0T3BhY2l0eSgpIH0pLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxuICAgICAgICBtYXJrZXI6IChub2RlLCBkYXR1bSkgPT4gKHsgLi4ucmVzZXRNYXJrZXJGbihub2RlKSwgLi4ucmVzZXRNYXJrZXJQb3NpdGlvbkZuKG5vZGUsIGRhdHVtKSB9KVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBBcmVhU2VyaWVzUHJvcGVydGllcygpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQsIHN0YWNrQ291bnQgPSAxIH0gPSB7fSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGNvbm5lY3RNaXNzaW5nRGF0YSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IGlzQ29udGludW91c1gsIHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGN1cnJlbnRJZHMgPSB7XG4gICAgICB2YWx1ZTogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVgLFxuICAgICAgdmFsdWVzOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgLFxuICAgICAgc3RhY2s6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlLXN0YWNrYCxcbiAgICAgIG1hcmtlcjogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzLW1hcmtlcmBcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAoaXNEZWZpbmVkKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKE9iamVjdC52YWx1ZXMoY3VycmVudElkcyksIG5vcm1hbGl6ZWRUbywgXCJyYW5nZVwiKSk7XG4gICAgfVxuICAgIGlmICghaXNDb250aW51b3VzWCAmJiBhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uID0geyBpbnZhbGlkVmFsdWU6IG51bGwgfTtcbiAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmIHN0YWNrQ291bnQgPiAxKSB7XG4gICAgICBjb21tb24uaW52YWxpZFZhbHVlID0gMDtcbiAgICB9XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICBjb21tb24uZm9yY2VWYWx1ZSA9IDA7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAga2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4VmFsdWVcIiB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlUmF3YCwgLi4uY29tbW9uIH0pLFxuICAgICAgICAuLi5ncm91cFN0YWNrVmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGB5VmFsdWVTdGFja2AsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIGdyb3VwSWQ6IGN1cnJlbnRJZHMuc3RhY2tcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgeVZhbHVlYCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgZ3JvdXBJZDogY3VycmVudElkcy52YWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ3aW5kb3dcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZUVuZGAsXG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICBncm91cElkOiBjdXJyZW50SWRzLnZhbHVlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlQ3VtdWxhdGl2ZWAsXG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICBncm91cElkOiBjdXJyZW50SWRzLm1hcmtlclxuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdLFxuICAgICAgZ3JvdXBCeUtleXM6IHRydWUsXG4gICAgICBncm91cEJ5RGF0YTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3Qga2V5RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3Qga2V5cyA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHhWYWx1ZWAsIFwia2V5XCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlFeHRlbnQgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWVFbmRgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIGlmIChrZXlEZWY/LmRlZi50eXBlID09PSBcImtleVwiICYmIGtleURlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoa2V5cyksIHhBeGlzKTtcbiAgICB9IGVsc2UgaWYgKHlBeGlzIGluc3RhbmNlb2YgTG9nQXhpcyB8fCB5QXhpcyBpbnN0YW5jZW9mIFRpbWVBeGlzKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RXh0ZW50LCB5QXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpeGVkWUV4dGVudCA9IFt5RXh0ZW50WzBdID4gMCA/IDAgOiB5RXh0ZW50WzBdLCB5RXh0ZW50WzFdIDwgMCA/IDAgOiB5RXh0ZW50WzFdXTtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGZpeGVkWUV4dGVudCwgeUF4aXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGRhdGEsIHByb2Nlc3NlZERhdGE6IHsgZGF0YTogZ3JvdXBlZERhdGEgfSA9IHt9LCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXhBeGlzIHx8ICF5QXhpcyB8fCAhZGF0YSB8fCAhZGF0YU1vZGVsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHlLZXksXG4gICAgICB4S2V5LFxuICAgICAgbWFya2VyLFxuICAgICAgbGFiZWwsXG4gICAgICBmaWxsOiBzZXJpZXNGaWxsLFxuICAgICAgc3Ryb2tlOiBzZXJpZXNTdHJva2UsXG4gICAgICBjb25uZWN0TWlzc2luZ0RhdGFcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHhTY2FsZSB9ID0geEF4aXM7XG4gICAgY29uc3QgeyBzY2FsZTogeVNjYWxlIH0gPSB5QXhpcztcbiAgICBjb25zdCB7IGlzQ29udGludW91c1kgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgZGVmcyA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNCeUlkcyh0aGlzLCBbYHlWYWx1ZUVuZGAsIGB5VmFsdWVSYXdgLCBgeVZhbHVlQ3VtdWxhdGl2ZWBdKTtcbiAgICBjb25zdCB5VmFsdWVTdGFja0luZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIFwieVZhbHVlU3RhY2tcIik7XG4gICAgY29uc3QgY3JlYXRlTWFya2VyQ29vcmRpbmF0ZSA9ICh4RGF0dW0sIHlFbmQsIHJhd1lEYXR1bSkgPT4ge1xuICAgICAgbGV0IGN1cnJZO1xuICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLnByb3BlcnRpZXMubm9ybWFsaXplZFRvKSA/IGlzQ29udGludW91c1kgJiYgaXNDb250aW51b3VzKHJhd1lEYXR1bSkgOiAhaXNOYU4ocmF3WURhdHVtKSkge1xuICAgICAgICBjdXJyWSA9IHlFbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldCxcbiAgICAgICAgeTogeVNjYWxlLmNvbnZlcnQoY3VyclkpLFxuICAgICAgICBzaXplOiBtYXJrZXIuc2l6ZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGl0ZW1JZCA9IHlLZXk7XG4gICAgY29uc3QgbGFiZWxEYXRhID0gW107XG4gICAgY29uc3QgbWFya2VyRGF0YSA9IFtdO1xuICAgIGNvbnN0IHsgdmlzaWJsZVNhbWVTdGFja0NvdW50IH0gPSB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIuZ2V0VmlzaWJsZVBlZXJHcm91cEluZGV4KHRoaXMpO1xuICAgIGxldCBkYXR1bUlkeCA9IC0xO1xuICAgIGdyb3VwZWREYXRhPy5mb3JFYWNoKChkYXR1bUdyb3VwKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleXMsXG4gICAgICAgIGtleXM6IFt4RGF0dW1dLFxuICAgICAgICBkYXR1bTogZGF0dW1BcnJheSxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXNBcnJheVxuICAgICAgfSA9IGRhdHVtR3JvdXA7XG4gICAgICB2YWx1ZXNBcnJheS5mb3JFYWNoKCh2YWx1ZXMsIHZhbHVlSWR4KSA9PiB7XG4gICAgICAgIGRhdHVtSWR4Kys7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdHVtID0gZGF0dW1BcnJheVt2YWx1ZUlkeF07XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMyID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmc1ZhbHVlcyhkZWZzLCB7IGtleXMsIHZhbHVlcyB9KTtcbiAgICAgICAgY29uc3QgeyB5VmFsdWVSYXc6IHlEYXR1bSwgeVZhbHVlQ3VtdWxhdGl2ZSwgeVZhbHVlRW5kIH0gPSBkYXRhVmFsdWVzMjtcbiAgICAgICAgY29uc3QgdmFsaWRQb2ludCA9IE51bWJlci5pc0Zpbml0ZSh5RGF0dW0pO1xuICAgICAgICBjb25zdCBwb2ludCA9IGNyZWF0ZU1hcmtlckNvb3JkaW5hdGUoeERhdHVtLCAreVZhbHVlQ3VtdWxhdGl2ZSwgeURhdHVtKTtcbiAgICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbWFya2VyKSB7XG4gICAgICAgICAgbWFya2VyRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBkYXR1bUlkeCxcbiAgICAgICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgICAgIGl0ZW1JZCxcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bSxcbiAgICAgICAgICAgIG1pZFBvaW50OiB7IHg6IHBvaW50LngsIHk6IHBvaW50LnkgfSxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogeVZhbHVlRW5kLFxuICAgICAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICBmaWxsOiBtYXJrZXIuZmlsbCA/PyBzZXJpZXNGaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHNlcmllc1N0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGggPz8gdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbGFiZWwpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YWx1ZTogeURhdHVtLFxuICAgICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICAgIHhOYW1lOiB0aGlzLnByb3BlcnRpZXMueE5hbWUsXG4gICAgICAgICAgICAgIHlOYW1lOiB0aGlzLnByb3BlcnRpZXMueU5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSA/IHZhbHVlLnRvRml4ZWQoMikgOiBTdHJpbmcodmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsYWJlbERhdGEucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogZGF0dW1JZHgsXG4gICAgICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbFRleHQgPyB7XG4gICAgICAgICAgICAgIHRleHQ6IGxhYmVsVGV4dCxcbiAgICAgICAgICAgICAgZm9udFN0eWxlOiBsYWJlbC5mb250U3R5bGUsXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiBsYWJlbC5mb250U2l6ZSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yXG4gICAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgaW50ZXJwb2xhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGludGVycG9sYXRlUG9pbnRzID0gKHBvaW50cykgPT4ge1xuICAgICAgbGV0IHNwYW5zO1xuICAgICAgY29uc3QgcG9pbnRzSXRlciA9IHBvaW50cy5tYXAoKHBvaW50KSA9PiBwb2ludC5wb2ludCk7XG4gICAgICBzd2l0Y2ggKGludGVycG9sYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICAgICAgc3BhbnMgPSBsaW5lYXJQb2ludHMocG9pbnRzSXRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzbW9vdGhcIjpcbiAgICAgICAgICBzcGFucyA9IHNtb290aFBvaW50cyhwb2ludHNJdGVyLCBpbnRlcnBvbGF0aW9uLnRlbnNpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgICAgIHNwYW5zID0gc3RlcFBvaW50cyhwb2ludHNJdGVyLCBpbnRlcnBvbGF0aW9uLnBvc2l0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGFucy5tYXAoKHNwYW4sIGkpID0+ICh7XG4gICAgICAgIHNwYW4sXG4gICAgICAgIHhWYWx1ZTA6IHBvaW50c1tpXS54RGF0dW0sXG4gICAgICAgIHlWYWx1ZTA6IHBvaW50c1tpXS55RGF0dW0sXG4gICAgICAgIHhWYWx1ZTE6IHBvaW50c1tpICsgMV0ueERhdHVtLFxuICAgICAgICB5VmFsdWUxOiBwb2ludHNbaSArIDFdLnlEYXR1bVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgc3BhbnNGb3JQb2ludHMgPSAocG9pbnRzKSA9PiB7XG4gICAgICByZXR1cm4gcG9pbnRzLmZsYXRNYXAoKHApID0+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocCkgPyBpbnRlcnBvbGF0ZVBvaW50cyhwKSA6IG5ldyBBcnJheShwLnNraXApLmZpbGwobnVsbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBncm91cGVkRGF0YT8uZmxhdE1hcCgoZGF0dW1Hcm91cCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlzOiBbeERhdHVtXSxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXNBcnJheVxuICAgICAgfSA9IGRhdHVtR3JvdXA7XG4gICAgICByZXR1cm4gdmFsdWVzQXJyYXkubWFwKCh2YWx1ZXMpID0+ICh7IHhEYXR1bSwgdmFsdWVzIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBjcmVhdGVQb2ludCA9ICh4RGF0dW0sIHlEYXR1bSkgPT4gKHtcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIHg6IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0LFxuICAgICAgICB5OiB5U2NhbGUuY29udmVydCh5RGF0dW0pXG4gICAgICB9LFxuICAgICAgeERhdHVtLFxuICAgICAgeURhdHVtXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0U2VyaWVzU3BhbnMgPSAoaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgaWYgKGRhdGFWYWx1ZXMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhVmFsdWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHsgeERhdHVtLCB2YWx1ZXMgfSA9IGRhdGFWYWx1ZXNbaV07XG4gICAgICAgIGNvbnN0IHlWYWx1ZVN0YWNrID0gdmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBjb25zdCB5RGF0dW0gPSB5VmFsdWVTdGFja1tpbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bUlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHlEYXR1bSk7XG4gICAgICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgIXlEYXR1bUlzRmluaXRlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsYXN0WVZhbHVlU3RhY2sgPSBkYXRhVmFsdWVzW2kgLSAxXT8udmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBjb25zdCBuZXh0WVZhbHVlU3RhY2sgPSBkYXRhVmFsdWVzW2kgKyAxXT8udmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBsZXQgeVZhbHVlRW5kQmFja3dhcmRzID0gMDtcbiAgICAgICAgbGV0IHlWYWx1ZUVuZEZvcndhcmRzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaW5kZXg7IGogKz0gMSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0geVZhbHVlU3RhY2tbal07XG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RXYXNGaW5pdGUgPSBsYXN0WVZhbHVlU3RhY2sgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUobGFzdFlWYWx1ZVN0YWNrW2pdKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRXYXNGaW5pdGUgPSBuZXh0WVZhbHVlU3RhY2sgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUobmV4dFlWYWx1ZVN0YWNrW2pdKTtcbiAgICAgICAgICAgIGlmIChsYXN0V2FzRmluaXRlKSB7XG4gICAgICAgICAgICAgIHlWYWx1ZUVuZEJhY2t3YXJkcyArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0V2FzRmluaXRlKSB7XG4gICAgICAgICAgICAgIHlWYWx1ZUVuZEZvcndhcmRzICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnRzID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFjb25uZWN0TWlzc2luZ0RhdGEgJiYgKHlWYWx1ZUVuZEJhY2t3YXJkcyAhPT0geVZhbHVlRW5kRm9yd2FyZHMgfHwgIXlEYXR1bUlzRmluaXRlKSkge1xuICAgICAgICAgIGlmICgheURhdHVtSXNGaW5pdGUgJiYgQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSAmJiBjdXJyZW50UG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9IHsgc2tpcDogMSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludEJhY2t3YXJkcyA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kQmFja3dhcmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50Rm9yd2FyZHMgPSBjcmVhdGVQb2ludCh4RGF0dW0sIHlWYWx1ZUVuZEZvcndhcmRzKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChwb2ludEJhY2t3YXJkcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnNraXAgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHlEYXR1bUlzRmluaXRlID8gW3BvaW50Rm9yd2FyZHNdIDogeyBza2lwOiAwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB5VmFsdWVFbmQgPSBNYXRoLm1heCh5VmFsdWVFbmRCYWNrd2FyZHMsIHlWYWx1ZUVuZEZvcndhcmRzKTtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5za2lwICs9IDE7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BvaW50XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhbnNGb3JQb2ludHMocG9pbnRzKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0luZGV4ID8/IDA7XG4gICAgY29uc3QgZ2V0QXhpc1NwYW5zID0gKCkgPT4ge1xuICAgICAgaWYgKGRhdGFWYWx1ZXMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgeVZhbHVlWmVyb1BvaW50cyA9IGRhdGFWYWx1ZXMubWFwKCh7IHhEYXR1bSwgdmFsdWVzIH0pID0+IHtcbiAgICAgICAgY29uc3QgeVZhbHVlU3RhY2sgPSB2YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bSA9IHlWYWx1ZVN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmICFOdW1iZXIuaXNGaW5pdGUoeURhdHVtKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBjcmVhdGVQb2ludCh4RGF0dW0sIDApO1xuICAgICAgfSkuZmlsdGVyKCh4KSA9PiB4ICE9IG51bGwpO1xuICAgICAgcmV0dXJuIGludGVycG9sYXRlUG9pbnRzKHlWYWx1ZVplcm9Qb2ludHMpO1xuICAgIH07XG4gICAgY29uc3QgY3VycmVudFNlcmllc1NwYW5zID0gZ2V0U2VyaWVzU3BhbnMoc3RhY2tJbmRleCk7XG4gICAgY29uc3QgcGhhbnRvbVNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLm1hcCgoKSA9PiBudWxsKTtcbiAgICBmb3IgKGxldCBqID0gc3RhY2tJbmRleCAtIDE7IGogPj0gLTE7IGogLT0gMSkge1xuICAgICAgbGV0IHNwYW5zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaGFudG9tU3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHBoYW50b21TcGFuc1tpXSAhPSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzcGFucyA/PyAoc3BhbnMgPSBqICE9PSAtMSA/IGdldFNlcmllc1NwYW5zKGopIDogZ2V0QXhpc1NwYW5zKCkpO1xuICAgICAgICBwaGFudG9tU3BhbnNbaV0gPSBzcGFuc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsbFNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLm1hcCgoc3BhbiwgaW5kZXgpID0+IHNwYW4gPz8gcGhhbnRvbVNwYW5zW2luZGV4XSk7XG4gICAgY29uc3Qgc3Ryb2tlU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMuZmlsdGVyKChzcGFuKSA9PiBzcGFuICE9IG51bGwpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpdGVtSWQsXG4gICAgICBmaWxsRGF0YTogeyBpdGVtSWQsIHNwYW5zOiBmaWxsU3BhbnMsIHBoYW50b21TcGFucyB9LFxuICAgICAgc3Ryb2tlRGF0YTogeyBpdGVtSWQsIHNwYW5zOiBzdHJva2VTcGFucyB9LFxuICAgICAgbGFiZWxEYXRhLFxuICAgICAgbm9kZURhdGE6IG1hcmtlckRhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgc3RhY2tWaXNpYmxlOiB2aXNpYmxlU2FtZVN0YWNrQ291bnQgPiAwXG4gICAgfTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRoTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgb3BhY2l0eSwgdmlzaWJsZSwgYW5pbWF0aW9uRW5hYmxlZCB9ID0gb3B0cztcbiAgICBjb25zdCBbZmlsbCwgc3Ryb2tlXSA9IG9wdHMucGF0aHM7XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCk7XG4gICAgc3Ryb2tlLnNldFByb3BlcnRpZXMoe1xuICAgICAgdGFnOiAxIC8qIFN0cm9rZSAqLyxcbiAgICAgIGZpbGw6IHZvaWQgMCxcbiAgICAgIGxpbmVKb2luOiBzdHJva2UubGluZUNhcCA9IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqLyxcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldCxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlXG4gICAgfSk7XG4gICAgZmlsbC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRhZzogMCAvKiBGaWxsICovLFxuICAgICAgc3Ryb2tlOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovLFxuICAgICAgZmlsbDogdGhpcy5wcm9wZXJ0aWVzLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXQsXG4gICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGZpbGxTaGFkb3c6IHRoaXMucHJvcGVydGllcy5zaGFkb3csXG4gICAgICBvcGFjaXR5LFxuICAgICAgdmlzaWJsZTogdmlzaWJsZSB8fCBhbmltYXRpb25FbmFibGVkLFxuICAgICAgc3Ryb2tlV2lkdGhcbiAgICB9KTtcbiAgICB1cGRhdGVDbGlwUGF0aCh0aGlzLCBzdHJva2UpO1xuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIGZpbGwpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhvcHRzLnBhdGhzLCBvcHRzLmNvbnRleHREYXRhKTtcbiAgfVxuICB1cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgdGhpcy51cGRhdGVGaWxsUGF0aChwYXRocywgY29udGV4dERhdGEpO1xuICAgIHRoaXMudXBkYXRlU3Ryb2tlUGF0aChwYXRocywgY29udGV4dERhdGEpO1xuICB9XG4gIHVwZGF0ZUZpbGxQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgc3BhbnMsIHBoYW50b21TcGFucyB9ID0gY29udGV4dERhdGEuZmlsbERhdGE7XG4gICAgY29uc3QgW2ZpbGxdID0gcGF0aHM7XG4gICAgY29uc3QgeyBwYXRoIH0gPSBmaWxsO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgeyBzcGFuIH0gPSBzcGFuc1tpXTtcbiAgICAgIGNvbnN0IHBoYW50b21TcGFuID0gcGhhbnRvbVNwYW5zW2ldLnNwYW47XG4gICAgICBwbG90U3BhbihwYXRoLCBzcGFuLCAxIC8qIE1vdmVUbyAqLyk7XG4gICAgICBwbG90U3BhbihwYXRoLCByZXZlcnNlU3BhbihwaGFudG9tU3BhbiksIDIgLyogTGluZVRvICovKTtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGZpbGwuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICB1cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgc3BhbnMgfSA9IGNvbnRleHREYXRhLnN0cm9rZURhdGE7XG4gICAgY29uc3QgWywgc3Ryb2tlXSA9IHBhdGhzO1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gc3Ryb2tlO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgZm9yIChjb25zdCB7IHNwYW4gfSBvZiBzcGFucykge1xuICAgICAgcGxvdFNwYW4ocGF0aCwgc3Bhbik7XG4gICAgfVxuICAgIHN0cm9rZS5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgPyBub2RlRGF0YSA6IFtdKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIG1hcmtlciwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIGhpZ2hsaWdodFN0eWxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VPcGFjaXR5XG4gICAgfSk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXkgfSwgYmFzZVN0eWxlKTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMubWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUobGFiZWxEYXRhLCAodGV4dCkgPT4ge1xuICAgICAgdGV4dC50YWcgPSAzIC8qIExhYmVsICovO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgeyBlbmFibGVkOiBsYWJlbEVuYWJsZWQsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGNvbG9yIH0gPSB0aGlzLnByb3BlcnRpZXMubGFiZWw7XG4gICAgbGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgeCwgeSwgbGFiZWwgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsICYmIGxhYmVsRW5hYmxlZCAmJiB0aGlzLnZpc2libGUpIHtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBsYWJlbC50ZXh0QWxpZ247XG4gICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0LnggPSB4O1xuICAgICAgICB0ZXh0LnkgPSB5IC0gMTA7XG4gICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0LnZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIGF4ZXMsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHhOYW1lLCB5TmFtZSwgdG9vbHRpcCwgbWFya2VyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyB5S2V5LCB4VmFsdWUsIHlWYWx1ZSwgZGF0dW0sIGl0ZW1JZCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICEoeEF4aXMgJiYgeUF4aXMgJiYgaXNGaW5pdGVOdW1iZXIoeVZhbHVlKSkgfHwgIWRhdGFNb2RlbCkge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeFN0cmluZyA9IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSk7XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwoeU5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoeFN0cmluZyArIFwiOiBcIiArIHlTdHJpbmcpO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoeyBmaWxsOiB0aGlzLnByb3BlcnRpZXMuZmlsbCB9LCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xuICAgICAgc3Ryb2tlOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoXG4gICAgICBtYXJrZXIsXG4gICAgICB7IGRhdHVtOiBub2RlRGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiBmYWxzZSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAgeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB4S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgc2VyaWVzSWRcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXRoaXMucHJvcGVydGllcy5zaG93SW5MZWdlbmQgfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHlLZXksXG4gICAgICB5TmFtZSxcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2UsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbWFya2VyLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB1c2VBcmVhRmlsbCA9ICFtYXJrZXIuZW5hYmxlZCB8fCBtYXJrZXIuZmlsbCA9PT0gdm9pZCAwO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGUsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxlZ2VuZEl0ZW1OYW1lID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZTogbWFya2VyLnNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiB1c2VBcmVhRmlsbCA/IGZpbGwgOiBtYXJrZXIuZmlsbCxcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHVzZUFyZWFGaWxsID8gZmlsbE9wYWNpdHkgOiBtYXJrZXIuZmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSA/PyBzdHJva2UsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IG1hcmtlci5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgZW5hYmxlZDogbWFya2VyLmVuYWJsZWQgfHwgc3Ryb2tlV2lkdGggPD0gMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgbGluZURhc2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHBhdGhTd2lwZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKTtcbiAgICByZXNldE1vdGlvbihbbWFya2VyU2VsZWN0aW9uXSwgcmVzZXRNYXJrZXJQb3NpdGlvbkZuKTtcbiAgICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHN1cGVyLmFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgY29udGV4dERhdGEsIHBhdGhzLCBwcmV2aW91c0NvbnRleHREYXRhIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IFtmaWxsLCBzdHJva2VdID0gcGF0aHM7XG4gICAgaWYgKGZpbGwgPT0gbnVsbCAmJiBzdHJva2UgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJlc2V0TWFya2VyQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIHRoaXMucmVzZXRMYWJlbEFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0UGF0aEFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0cm9rZVBhdGgocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXAgPSAoKSA9PiB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH07XG4gICAgaWYgKGNvbnRleHREYXRhID09IG51bGwgfHwgcHJldmlvdXNDb250ZXh0RGF0YSA9PSBudWxsKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZGVkXCIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiZmlsbF9wYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRcIiwgZmlsbCk7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic3Ryb2tlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFwidHJhaWxpbmdcIiwgc3Ryb2tlKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uKGNvbnRleHREYXRhLCBwcmV2aW91c0NvbnRleHREYXRhLCB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmYpO1xuICAgIGlmIChmbnMgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZm5zLnN0YXR1cyA9PT0gXCJuby1vcFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCB2b2lkIDAsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiZmlsbF9wYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgW2ZpbGxdLCBmbnMuZmlsbC5wYXRoUHJvcGVydGllcyk7XG4gICAgcGF0aE1vdGlvbih0aGlzLmlkLCBcImZpbGxfcGF0aF91cGRhdGVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW2ZpbGxdLCBmbnMuZmlsbC5wYXRoKTtcbiAgICB0aGlzLnVwZGF0ZVN0cm9rZVBhdGgocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic3Ryb2tlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFwidHJhaWxpbmdcIiwgc3Ryb2tlKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSB9ID0gZGF0dW07XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwgeyBkYXR1bSwgeEtleSwgeUtleSwgaGlnaGxpZ2h0ZWQ6IHRydWUgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuQXJlYVNlcmllcy5jbGFzc05hbWUgPSBcIkFyZWFTZXJpZXNcIjtcbkFyZWFTZXJpZXMudHlwZSA9IFwiYXJlYVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFTZXJpZXNNb2R1bGUudHNcbnZhciBBcmVhU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiYXJlYVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQXJlYVNlcmllcyhjdHgpLFxuICBzdGFja2FibGU6IHRydWUsXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIG5vZGVDbGlja1JhbmdlOiBcIm5lYXJlc3RcIixcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgICAgeE9mZnNldDogMyxcbiAgICAgICAgeU9mZnNldDogMyxcbiAgICAgICAgYmx1cjogNVxuICAgICAgfSxcbiAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHVzZXJzIHNob3VsZG4ndCBzcGVjaWZ5IGFsbCBvcHRpb25zLCBidXQgd2UgaGF2ZSB0byBmb3IgdGhlbWluZyB0byB3b3JrXG4gICAgICAgIHRlbnNpb246IDEsXG4gICAgICAgIHBvc2l0aW9uOiBcImVuZFwiXG4gICAgICB9LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc2l6ZTogNyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcyk7XG4gICAgcmV0dXJuIHsgZmlsbDogbWFya2VyLmZpbGwsIHN0cm9rZTogbWFya2VyLnN0cm9rZSwgbWFya2VyIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vcXVhZHRyZWVVdGlsLnRzXG5mdW5jdGlvbiogY2hpbGRyZW5JdGVyKHBhcmVudCkge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgcGFyZW50LmNoaWxkcmVuKSB7XG4gICAgeWllbGQgbm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIGhpdFRlc3RlcnMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIGhpdFRlc3RlcnMpIHtcbiAgICBjb25zdCBkYXR1bSA9IG5vZGUuZGF0dW07XG4gICAgaWYgKGRhdHVtID09PSB2b2lkIDApIHtcbiAgICAgIExvZ2dlci5lcnJvcihcInVuZGVmaW5lZCBkYXR1bVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVhZHRyZWUuYWRkVmFsdWUobm9kZSwgZGF0dW0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluZFF1YWR0cmVlTWF0Y2goc2VyaWVzLCBwb2ludCkge1xuICBjb25zdCB7IHgsIHkgfSA9IHNlcmllcy5jb250ZW50R3JvdXAudHJhbnNmb3JtUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gIGNvbnN0IHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQzIH0gPSBzZXJpZXMuZ2V0UXVhZFRyZWUoKS5maW5kKHgsIHkpO1xuICBpZiAobmVhcmVzdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgZGF0dW06IG5lYXJlc3QudmFsdWUsIGRpc3RhbmNlOiBNYXRoLnNxcnQoZGlzdGFuY2VTcXVhcmVkMykgfTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2Fic3RyYWN0QmFyU2VyaWVzLnRzXG52YXIgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IFwidmVydGljYWxcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERJUkVDVElPTilcbl0sIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIDIpO1xudmFyIEFic3RyYWN0QmFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBiYXJzIHdpdGhpbiBlYWNoIGdyb3VwLlxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXBTY2FsZSA9IG5ldyBCYW5kU2NhbGUoKTtcbiAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0gdm9pZCAwO1xuICAgIHRoaXMubGFyZ2VzdERhdGFJbnRlcnZhbCA9IHZvaWQgMDtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAwLjMsIG91dGVyOiAwLjE1IH07XG4gIH1cbiAgc2hvdWxkRmxpcFhZKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZlcnRpY2FsKCk7XG4gIH1cbiAgaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICB9XG4gIGdldEJhckRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRGbGlwWFkoKSA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICB9XG4gIGdldENhdGVnb3J5RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNob3VsZEZsaXBYWSgpID8gXCJ5XCIgLyogWSAqLyA6IFwieFwiIC8qIFggKi87XG4gIH1cbiAgZ2V0VmFsdWVBeGlzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0QmFyRGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICB9XG4gIGdldENhdGVnb3J5QXhpcygpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICB9XG4gIHVwZGF0ZUdyb3VwU2NhbGUoeEF4aXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cFNjYWxlLFxuICAgICAgc21hbGxlc3REYXRhSW50ZXJ2YWwsXG4gICAgICBjdHg6IHsgc2VyaWVzU3RhdGVNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4QmFuZFdpZHRoID0gQ29udGludW91c1NjYWxlLmlzKHhTY2FsZSkgPyB4U2NhbGUuY2FsY0JhbmR3aWR0aChzbWFsbGVzdERhdGFJbnRlcnZhbCkgOiB4U2NhbGUuYmFuZHdpZHRoO1xuICAgIGNvbnN0IGRvbWFpbiA9IFtdO1xuICAgIGNvbnN0IHsgaW5kZXg6IGdyb3VwSW5kZXgsIHZpc2libGVHcm91cENvdW50IH0gPSBzZXJpZXNTdGF0ZU1hbmFnZXIuZ2V0VmlzaWJsZVBlZXJHcm91cEluZGV4KHRoaXMpO1xuICAgIGZvciAobGV0IGdyb3VwSWR4ID0gMDsgZ3JvdXBJZHggPCB2aXNpYmxlR3JvdXBDb3VudDsgZ3JvdXBJZHgrKykge1xuICAgICAgZG9tYWluLnB1c2goU3RyaW5nKGdyb3VwSWR4KSk7XG4gICAgfVxuICAgIGdyb3VwU2NhbGUuZG9tYWluID0gZG9tYWluO1xuICAgIGdyb3VwU2NhbGUucmFuZ2UgPSBbMCwgeEJhbmRXaWR0aCA/PyAwXTtcbiAgICBpZiAoeEF4aXMgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMpIHtcbiAgICAgIGdyb3VwU2NhbGUucGFkZGluZ0lubmVyID0geEF4aXMuZ3JvdXBQYWRkaW5nSW5uZXI7XG4gICAgfSBlbHNlIGlmICh4QXhpcyBpbnN0YW5jZW9mIEdyb3VwZWRDYXRlZ29yeUF4aXMpIHtcbiAgICAgIGdyb3VwU2NhbGUucGFkZGluZyA9IDAuMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBTY2FsZS5wYWRkaW5nID0gMDtcbiAgICB9XG4gICAgZ3JvdXBTY2FsZS5yb3VuZCA9IGdyb3VwU2NhbGUucGFkZGluZyAhPT0gMDtcbiAgICBjb25zdCBiYXJXaWR0aCA9IGdyb3VwU2NhbGUuYmFuZHdpZHRoID49IDEgPyAoXG4gICAgICAvLyBQaXhlbC1yb3VuZGVkIHZhbHVlIGZvciBsb3ctdm9sdW1lIGJhciBjaGFydHMuXG4gICAgICBncm91cFNjYWxlLmJhbmR3aWR0aFxuICAgICkgOiAoXG4gICAgICAvLyBIYW5kbGUgaGlnaC12b2x1bWUgYmFyIGNoYXJ0cyBncmFjZWZ1bGx5LlxuICAgICAgZ3JvdXBTY2FsZS5yYXdCYW5kd2lkdGhcbiAgICApO1xuICAgIHJldHVybiB7IGJhcldpZHRoLCBncm91cEluZGV4IH07XG4gIH1cbiAgcmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBpZiAodGhpcy5nZXRCYXJEaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgICByZXR1cm4gXCJ5XCIgLyogWSAqLztcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInhcIiAvKiBYICovO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xuICB9XG4gIGluaXRRdWFkVHJlZShxdWFkdHJlZSkge1xuICAgIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlKHF1YWR0cmVlLCB0aGlzLmRhdHVtTm9kZXNJdGVyKCkpO1xuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIGZpbmRRdWFkdHJlZU1hdGNoKHRoaXMsIHBvaW50KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgQmFyU2VyaWVzTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBsYWNlbWVudCA9IFwiaW5zaWRlXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQTEFDRU1FTlQpXG5dLCBCYXJTZXJpZXNMYWJlbC5wcm90b3R5cGUsIFwicGxhY2VtZW50XCIsIDIpO1xudmFyIEJhclNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsID0gXCIjYzE2MDY4XCI7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2UgPSBcIiM4NzQzNDlcIjtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuY3Jpc3AgPSB2b2lkIDA7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQmFyU2VyaWVzTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3RhY2tHcm91cFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9ybWFsaXplZFRvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjcmlzcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyVXRpbC50c1xuZnVuY3Rpb24gdXBkYXRlUmVjdChyZWN0LCBjb25maWcpIHtcbiAgcmVjdC5jcmlzcCA9IGNvbmZpZy5jcmlzcCA/PyB0cnVlO1xuICByZWN0LmZpbGwgPSBjb25maWcuZmlsbDtcbiAgcmVjdC5zdHJva2UgPSBjb25maWcuc3Ryb2tlO1xuICByZWN0LnN0cm9rZVdpZHRoID0gY29uZmlnLnN0cm9rZVdpZHRoO1xuICByZWN0LmZpbGxPcGFjaXR5ID0gY29uZmlnLmZpbGxPcGFjaXR5O1xuICByZWN0LnN0cm9rZU9wYWNpdHkgPSBjb25maWcuc3Ryb2tlT3BhY2l0eTtcbiAgcmVjdC5saW5lRGFzaCA9IGNvbmZpZy5saW5lRGFzaDtcbiAgcmVjdC5saW5lRGFzaE9mZnNldCA9IGNvbmZpZy5saW5lRGFzaE9mZnNldDtcbiAgcmVjdC5maWxsU2hhZG93ID0gY29uZmlnLmZpbGxTaGFkb3c7XG4gIHJlY3QudG9wTGVmdENvcm5lclJhZGl1cyA9IGNvbmZpZy50b3BMZWZ0Q29ybmVyUmFkaXVzICE9PSBmYWxzZSA/IGNvbmZpZy5jb3JuZXJSYWRpdXMgPz8gMCA6IDA7XG4gIHJlY3QudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSBjb25maWcudG9wUmlnaHRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGNvbmZpZy5ib3R0b21SaWdodENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBjb25maWcuYm90dG9tTGVmdENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LnZpc2libGUgPSBjb25maWcudmlzaWJsZSA/PyB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UmVjdENvbmZpZyh7XG4gIGRhdHVtLFxuICBpc0hpZ2hsaWdodGVkLFxuICBzdHlsZSxcbiAgaGlnaGxpZ2h0U3R5bGUsXG4gIGl0ZW1TdHlsZXIsXG4gIHNlcmllc0lkLFxuICBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9LFxuICAuLi5vcHRzXG59KSB7XG4gIGNvbnN0IHtcbiAgICBmaWxsLFxuICAgIGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgIGNvcm5lclJhZGl1cyA9IDBcbiAgfSA9IG1lcmdlRGVmYXVsdHMoaXNIaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZSwgc3R5bGUpO1xuICBsZXQgZm9ybWF0O1xuICBpZiAoaXRlbVN0eWxlcikge1xuICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICBkYXR1bTogZGF0dW0uZGF0dW0sXG4gICAgICB4S2V5OiBkYXR1bS54S2V5LFxuICAgICAgZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgIGhpZ2hsaWdodGVkOiBpc0hpZ2hsaWdodGVkLFxuICAgICAgc2VyaWVzSWQsXG4gICAgICAuLi5vcHRzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaWxsOiBmb3JtYXQ/LmZpbGwgPz8gZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2U6IGZvcm1hdD8uc3Ryb2tlID8/IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogZm9ybWF0Py5zdHJva2VXaWR0aCA/PyBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5OiBmb3JtYXQ/LnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldDogZm9ybWF0Py5saW5lRGFzaE9mZnNldCA/PyBsaW5lRGFzaE9mZnNldCxcbiAgICBjb3JuZXJSYWRpdXM6IGZvcm1hdD8uY29ybmVyUmFkaXVzID8/IGNvcm5lclJhZGl1cyxcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiBzdHlsZS50b3BMZWZ0Q29ybmVyUmFkaXVzLFxuICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiBzdHlsZS50b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogc3R5bGUuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogc3R5bGUuYm90dG9tTGVmdENvcm5lclJhZGl1cyxcbiAgICBmaWxsU2hhZG93OiBzdHlsZS5maWxsU2hhZG93XG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0NyaXNwKHNjYWxlMiwgdmlzaWJsZVJhbmdlLCBzbWFsbGVzdERhdGFJbnRlcnZhbCwgbGFyZ2VzdERhdGFJbnRlcnZhbCkge1xuICBpZiAodmlzaWJsZVJhbmdlICE9IG51bGwpIHtcbiAgICBjb25zdCBbdmlzaWJsZU1pbiwgdmlzaWJsZU1heF0gPSB2aXNpYmxlUmFuZ2U7XG4gICAgY29uc3QgaXNab29tZWQgPSB2aXNpYmxlTWluICE9PSAwIHx8IHZpc2libGVNYXggIT09IDE7XG4gICAgaWYgKGlzWm9vbWVkKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgIGNvbnN0IHNwYWNpbmcgPSBzY2FsZTIuY2FsY0JhbmR3aWR0aChsYXJnZXN0RGF0YUludGVydmFsKSAtIHNjYWxlMi5jYWxjQmFuZHdpZHRoKHNtYWxsZXN0RGF0YUludGVydmFsKTtcbiAgICBpZiAoc3BhY2luZyA+IDAgJiYgc3BhY2luZyA8IDEpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgaXNEYXR1bU5lZ2F0aXZlID0gKGRhdHVtKSA9PiB7XG4gIHJldHVybiBpc05lZ2F0aXZlKGRhdHVtLnlWYWx1ZSA/PyAwKTtcbn07XG5mdW5jdGlvbiBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKGlzVmVydGljYWwsIGF4ZXMsIG1vZGUpIHtcbiAgY29uc3QgeyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9ID0gZ2V0U3RhcnRpbmdWYWx1ZXMoaXNWZXJ0aWNhbCwgYXhlcyk7XG4gIGNvbnN0IGNhbGN1bGF0ZSA9IChkYXR1bSwgcHJldkRhdHVtKSA9PiB7XG4gICAgbGV0IHggPSBpc1ZlcnRpY2FsID8gZGF0dW0ueCA6IHN0YXJ0aW5nWDtcbiAgICBsZXQgeSA9IGlzVmVydGljYWwgPyBzdGFydGluZ1kgOiBkYXR1bS55O1xuICAgIGxldCB3aWR0aCA9IGlzVmVydGljYWwgPyBkYXR1bS53aWR0aCA6IDA7XG4gICAgbGV0IGhlaWdodCA9IGlzVmVydGljYWwgPyAwIDogZGF0dW0uaGVpZ2h0O1xuICAgIGNvbnN0IHsgb3BhY2l0eSB9ID0gZGF0dW07XG4gICAgaWYgKHByZXZEYXR1bSAmJiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpKSB7XG4gICAgICAoeyB4LCB5IH0gPSBwcmV2RGF0dW0pO1xuICAgICAgd2lkdGggPSBpc1ZlcnRpY2FsID8gcHJldkRhdHVtLndpZHRoIDogMDtcbiAgICAgIGhlaWdodCA9IGlzVmVydGljYWwgPyAwIDogcHJldkRhdHVtLmhlaWdodDtcbiAgICAgIGlmIChpc1ZlcnRpY2FsICYmICFpc0RhdHVtTmVnYXRpdmUocHJldkRhdHVtKSkge1xuICAgICAgICB5ICs9IHByZXZEYXR1bS5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZlcnRpY2FsICYmIGlzRGF0dW1OZWdhdGl2ZShwcmV2RGF0dW0pKSB7XG4gICAgICAgIHggKz0gcHJldkRhdHVtLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2xpcEJCb3g7XG4gICAgaWYgKGRhdHVtLmNsaXBCQm94ID09IG51bGwpIHtcbiAgICAgIGNsaXBCQm94ID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAoaXNEYXR1bU5lZ2F0aXZlKGRhdHVtKSkge1xuICAgICAgY2xpcEJCb3ggPSBpc1ZlcnRpY2FsID8gbmV3IEJCb3goeCwgeSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodCkgOiBuZXcgQkJveCh4IC0gd2lkdGgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGlwQkJveCwgb3BhY2l0eSB9O1xuICB9O1xuICByZXR1cm4geyBpc1ZlcnRpY2FsLCBjYWxjdWxhdGUsIG1vZGUgfTtcbn1cbmZ1bmN0aW9uIG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbihpc1ZlcnRpY2FsLCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgaXNWZXJ0aWNhbCxcbiAgICBjYWxjdWxhdGU6IChkYXR1bSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNWZXJ0aWNhbCA/IGRhdHVtLnggOiBkYXR1bS54ICsgZGF0dW0ud2lkdGggLyAyLFxuICAgICAgICB5OiBpc1ZlcnRpY2FsID8gZGF0dW0ueSArIGRhdHVtLmhlaWdodCAvIDIgOiBkYXR1bS55LFxuICAgICAgICB3aWR0aDogaXNWZXJ0aWNhbCA/IGRhdHVtLndpZHRoIDogMCxcbiAgICAgICAgaGVpZ2h0OiBpc1ZlcnRpY2FsID8gMCA6IGRhdHVtLmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IGRhdHVtLmNsaXBCQm94LFxuICAgICAgICBvcGFjaXR5OiBkYXR1bS5vcGFjaXR5XG4gICAgICB9O1xuICAgIH0sXG4gICAgbW9kZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhpbml0UG9zKSB7XG4gIGNvbnN0IGlzUmVtb3ZlZCA9IChkYXR1bSkgPT4gZGF0dW0gPT0gbnVsbCB8fCBpc05hTihkYXR1bS54KSB8fCBpc05hTihkYXR1bS55KTtcbiAgY29uc3QgZnJvbUZuID0gKHJlY3QsIGRhdHVtLCBzdGF0dXMpID0+IHtcbiAgICBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIiAmJiBpc1JlbW92ZWQoZGF0dW0pKSB7XG4gICAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJ1cGRhdGVkXCIgJiYgaXNSZW1vdmVkKHJlY3QucHJldmlvdXNEYXR1bSkpIHtcbiAgICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgICB9XG4gICAgbGV0IHNvdXJjZTtcbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgJiYgcmVjdC5wcmV2aW91c0RhdHVtID09IG51bGwgJiYgaW5pdFBvcy5tb2RlID09PSBcImZhZGVcIikge1xuICAgICAgc291cmNlID0geyAuLi5yZXNldEJhclNlbGVjdGlvbnNGbihyZWN0LCBkYXR1bSksIG9wYWNpdHk6IDAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIgfHwgc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIHNvdXJjZSA9IGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSB7XG4gICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgeTogcmVjdC55LFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IHJlY3QuY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IHJlY3Qub3BhY2l0eVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGhhc2UgPSBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c107XG4gICAgcmV0dXJuIHsgLi4uc291cmNlLCBwaGFzZSB9O1xuICB9O1xuICBjb25zdCB0b0ZuID0gKHJlY3QsIGRhdHVtLCBzdGF0dXMpID0+IHtcbiAgICBsZXQgc291cmNlO1xuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiICYmIHJlY3QuZGF0dW0gPT0gbnVsbCAmJiBpbml0UG9zLm1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgICBzb3VyY2UgPSB7IC4uLnJlc2V0QmFyU2VsZWN0aW9uc0ZuKHJlY3QsIGRhdHVtKSwgb3BhY2l0eTogMCB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiB8fCBpc1JlbW92ZWQoZGF0dW0pKSB7XG4gICAgICBzb3VyY2UgPSBpbml0UG9zLmNhbGN1bGF0ZShkYXR1bSwgcmVjdC5wcmV2aW91c0RhdHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0ge1xuICAgICAgICB4OiBkYXR1bS54LFxuICAgICAgICB5OiBkYXR1bS55LFxuICAgICAgICB3aWR0aDogZGF0dW0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0dW0uaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogZGF0dW0uY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IGRhdHVtLm9wYWNpdHlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG4gIHJldHVybiB7IHRvRm4sIGZyb21GbiB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRpbmdWYWx1ZXMoaXNWZXJ0aWNhbCwgYXhlcykge1xuICBjb25zdCBheGlzID0gYXhlc1tpc1ZlcnRpY2FsID8gXCJ5XCIgLyogWSAqLyA6IFwieFwiIC8qIFggKi9dO1xuICBsZXQgc3RhcnRpbmdYID0gSW5maW5pdHk7XG4gIGxldCBzdGFydGluZ1kgPSAwO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm4geyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9O1xuICB9XG4gIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgc3RhcnRpbmdZID0gYXhpcy5zY2FsZS5jb252ZXJ0KENvbnRpbnVvdXNTY2FsZS5pcyhheGlzLnNjYWxlKSA/IDAgOiBNYXRoLm1heCguLi5heGlzLnJhbmdlKSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRpbmdYID0gYXhpcy5zY2FsZS5jb252ZXJ0KENvbnRpbnVvdXNTY2FsZS5pcyhheGlzLnNjYWxlKSA/IDAgOiBNYXRoLm1pbiguLi5heGlzLnJhbmdlKSk7XG4gIH1cbiAgcmV0dXJuIHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QmFyU2VsZWN0aW9uc0ZuKF9ub2RlLCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGNsaXBCQm94LCBvcGFjaXR5IH0pIHtcbiAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2xpcEJCb3gsIG9wYWNpdHkgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCYXJGb2N1c0JvdW5kcyhkYXR1bSwgYmFyR3JvdXAsIHNlcmllc1JlY3QpIHtcbiAgaWYgKGRhdHVtID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBkYXR1bTtcbiAgcmV0dXJuIGJhckdyb3VwLmludmVyc2VUcmFuc2Zvcm1CQm94KG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKS5jbGlwKHNlcmllc1JlY3QpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xhYmVsVXRpbC50c1xuZnVuY3Rpb24gdXBkYXRlTGFiZWxOb2RlKHRleHROb2RlLCBsYWJlbCwgbGFiZWxEYXR1bSkge1xuICBpZiAobGFiZWwuZW5hYmxlZCAmJiBsYWJlbERhdHVtKSB7XG4gICAgY29uc3QgeyB4LCB5LCB0ZXh0LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSB9ID0gbGFiZWxEYXR1bTtcbiAgICBjb25zdCB7IGNvbG9yOiBmaWxsLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5IH0gPSBsYWJlbDtcbiAgICB0ZXh0Tm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRleHQsXG4gICAgICBmaWxsLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udEZhbWlseSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIHRleHRCYXNlbGluZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRleHROb2RlLnZpc2libGUgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0TGFiZWxQbGFjZW1lbnQoe1xuICBpc1Bvc2l0aXZlLFxuICBpc1ZlcnRpY2FsLFxuICBwbGFjZW1lbnQsXG4gIHBhZGRpbmcgPSAwLFxuICByZWN0XG59KSB7XG4gIGxldCB4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XG4gIGxldCB5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xuICBsZXQgdGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgbGV0IHRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgY2FzZSBcInN0YXJ0XCI6IHtcbiAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHkgPSBpc1Bvc2l0aXZlID8gcmVjdC55ICsgcmVjdC5oZWlnaHQgKyBwYWRkaW5nIDogcmVjdC55IC0gcGFkZGluZztcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gaXNQb3NpdGl2ZSA/IFwidG9wXCIgOiBcImJvdHRvbVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGlzUG9zaXRpdmUgPyByZWN0LnggLSBwYWRkaW5nIDogcmVjdC54ICsgcmVjdC53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIHRleHRBbGlnbiA9IGlzUG9zaXRpdmUgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJvdXRzaWRlXCI6XG4gICAgY2FzZSBcImVuZFwiOiB7XG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICB5ID0gaXNQb3NpdGl2ZSA/IHJlY3QueSAtIHBhZGRpbmcgOiByZWN0LnkgKyByZWN0LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIHRleHRCYXNlbGluZSA9IGlzUG9zaXRpdmUgPyBcImJvdHRvbVwiIDogXCJ0b3BcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBpc1Bvc2l0aXZlID8gcmVjdC54ICsgcmVjdC53aWR0aCArIHBhZGRpbmcgOiByZWN0LnggLSBwYWRkaW5nO1xuICAgICAgICB0ZXh0QWxpZ24gPSBpc1Bvc2l0aXZlID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB4LCB5LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllcy50c1xudmFyIEJhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RCYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFszIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNIaWdobGlnaHRlZExhYmVsczogdHJ1ZSxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9uczogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIGRhdHVtOiByZXNldEJhclNlbGVjdGlvbnNGbixcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBCYXJTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gIH1cbiAgY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMueUZpbHRlcktleSAhPSBudWxsICYmICh0aGlzLnNlcmllc0dyb3VwaW5nID09IG51bGwgfHwgdGhpcy5zZXJpZXNHcm91cGluZy5zdGFja0luZGV4ID09PSAwKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhdGhpcy5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQgfSA9IHt9LCBkYXRhID0gW10gfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB5RmlsdGVyS2V5LCBub3JtYWxpemVkVG8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5nZXRWYWx1ZUF4aXMoKT8uc2NhbGU7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBzdGFja0dyb3VwTmFtZSA9IGBiYXItc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYDtcbiAgICBjb25zdCBzdGFja0dyb3VwVHJhaWxpbmdOYW1lID0gYCR7c3RhY2tHcm91cE5hbWV9LXRyYWlsaW5nYDtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgbm9ybWFsaXNlR3JvdXBUbyhbc3RhY2tHcm91cE5hbWUsIHN0YWNrR3JvdXBUcmFpbGluZ05hbWVdLCBNYXRoLmFicyhub3JtYWxpemVkVG8pLCBcInJhbmdlXCIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgfVxuICAgIGNvbnN0IHZpc2libGVQcm9wcyA9IHRoaXMudmlzaWJsZSA/IHt9IDogeyBmb3JjZVZhbHVlOiAwIH07XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieFZhbHVlXCIgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZS1yYXdgLCBpbnZhbGlkVmFsdWU6IG51bGwsIC4uLnZpc2libGVQcm9wcyB9KSxcbiAgICAgICAgLi4udGhpcy5jcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSA/IFtcbiAgICAgICAgICB2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHtcbiAgICAgICAgICAgIGlkOiBgeUZpbHRlclZhbHVlYCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIC4uLnZpc2libGVQcm9wc1xuICAgICAgICAgIH0pXG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZS1lbmRgLFxuICAgICAgICAgICAgcmFuZ2VJZDogYHlWYWx1ZS1yYW5nZWAsXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWU6IG51bGwsXG4gICAgICAgICAgICBtaXNzaW5nVmFsdWU6IDAsXG4gICAgICAgICAgICBncm91cElkOiBzdGFja0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHNlcGFyYXRlTmVnYXRpdmU6IHRydWUsXG4gICAgICAgICAgICAuLi52aXNpYmxlUHJvcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ0cmFpbGluZ1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlLXN0YXJ0YCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIG1pc3NpbmdWYWx1ZTogMCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IHN0YWNrR3JvdXBUcmFpbGluZ05hbWUsXG4gICAgICAgICAgICBzZXBhcmF0ZU5lZ2F0aXZlOiB0cnVlLFxuICAgICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmlzQ29udGludW91c1ggPyBbU01BTExFU1RfS0VZX0lOVEVSVkFMLCBMQVJHRVNUX0tFWV9JTlRFUlZBTF0gOiBbXSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXSxcbiAgICAgIGdyb3VwQnlLZXlzOiB0cnVlLFxuICAgICAgZ3JvdXBCeURhdGE6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCA9IHByb2Nlc3NlZERhdGEucmVkdWNlZD8uc21hbGxlc3RLZXlJbnRlcnZhbDtcbiAgICB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwgPSBwcm9jZXNzZWREYXRhLnJlZHVjZWQ/Lmxhcmdlc3RLZXlJbnRlcnZhbDtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgc21hbGxlc3REYXRhSW50ZXJ2YWwgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBjYXRlZ29yeUF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xuICAgIGNvbnN0IHZhbHVlQXhpcyA9IHRoaXMuZ2V0VmFsdWVBeGlzKCk7XG4gICAgY29uc3Qga2V5RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3Qga2V5cyA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHhWYWx1ZWAsIFwia2V5XCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGxldCB5RXh0ZW50ID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlLWVuZGAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeUZpbHRlckV4dGVudCA9IHRoaXMuY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkgPyBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5RmlsdGVyVmFsdWVgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGlmICh5RmlsdGVyRXh0ZW50ICE9IG51bGwpIHtcbiAgICAgIHlFeHRlbnQgPSBbTWF0aC5taW4oeUV4dGVudFswXSwgeUZpbHRlckV4dGVudFswXSksIE1hdGgubWF4KHlFeHRlbnRbMV0sIHlGaWx0ZXJFeHRlbnRbMV0pXTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpKSB7XG4gICAgICBpZiAoa2V5RGVmPy5kZWYudHlwZSA9PT0gXCJrZXlcIiAmJiBrZXlEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NhbGVQYWRkaW5nID0gaXNGaW5pdGVOdW1iZXIoc21hbGxlc3REYXRhSW50ZXJ2YWwpID8gc21hbGxlc3REYXRhSW50ZXJ2YWwgKiAwLjUgOiAwO1xuICAgICAgY29uc3Qga2V5c0V4dGVudCA9IGV4dGVudChrZXlzKSA/PyBbTmFOLCBOYU5dO1xuICAgICAgY29uc3QgZDAgPSBrZXlzRXh0ZW50WzBdICsgLXNjYWxlUGFkZGluZztcbiAgICAgIGNvbnN0IGQxID0ga2V5c0V4dGVudFsxXSArIHNjYWxlUGFkZGluZztcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KFtkMCwgZDFdLCBjYXRlZ29yeUF4aXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRWYWx1ZUF4aXMoKSBpbnN0YW5jZW9mIExvZ0F4aXMpIHtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlFeHRlbnQsIHZhbHVlQXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpeGVkWUV4dGVudCA9IFtNYXRoLm1pbigwLCB5RXh0ZW50WzBdKSwgTWF0aC5tYXgoMCwgeUV4dGVudFsxXSldO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50LCB2YWx1ZUF4aXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICF4QXhpcyB8fCAheUF4aXMgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIGNvcm5lclJhZGl1cywgbGVnZW5kSXRlbU5hbWUsIGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeVJldmVyc2VkID0geUF4aXMuaXNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IHsgYmFyV2lkdGgsIGdyb3VwSW5kZXggfSA9IHRoaXMudXBkYXRlR3JvdXBTY2FsZSh4QXhpcyk7XG4gICAgY29uc3QgYmFyT2Zmc2V0ID0gQ29udGludW91c1NjYWxlLmlzKHhTY2FsZSkgPyBiYXJXaWR0aCAqIC0wLjUgOiAwO1xuICAgIGNvbnN0IHhJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeVJhd0luZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtcmF3YCk7XG4gICAgY29uc3QgeUZpbHRlckluZGV4ID0gdGhpcy5jcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgeVN0YXJ0SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1zdGFydGApO1xuICAgIGNvbnN0IHlFbmRJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlLWVuZGApO1xuICAgIGNvbnN0IHlSYW5nZUluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtcmFuZ2VgKTtcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3Qgbm9kZURhdHVtID0gKHtcbiAgICAgIGRhdHVtLFxuICAgICAgdmFsdWVJbmRleCxcbiAgICAgIHhWYWx1ZSxcbiAgICAgIHlWYWx1ZSxcbiAgICAgIGN1bXVsYXRpdmVWYWx1ZSxcbiAgICAgIHBoYW50b20sXG4gICAgICBjdXJyWSxcbiAgICAgIHByZXZZLFxuICAgICAgaXNQb3NpdGl2ZSxcbiAgICAgIHlSYW5nZSxcbiAgICAgIGxhYmVsVGV4dCxcbiAgICAgIGNyb3NzU2NhbGUgPSAxXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhWYWx1ZSk7XG4gICAgICBjb25zdCBpc1Vwd2FyZCA9IGlzUG9zaXRpdmUgIT09IHlSZXZlcnNlZDtcbiAgICAgIGNvbnN0IGJhclggPSB4ICsgZ3JvdXBTY2FsZS5jb252ZXJ0KFN0cmluZyhncm91cEluZGV4KSkgKyBiYXJPZmZzZXQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoY3VyclkpO1xuICAgICAgY29uc3QgYm90dG9tWSA9IHlTY2FsZS5jb252ZXJ0KHByZXZZKTtcbiAgICAgIGNvbnN0IGJhckFsb25nWCA9IHRoaXMuZ2V0QmFyRGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi87XG4gICAgICBjb25zdCBiYm94SGVpZ2h0ID0geVNjYWxlLmNvbnZlcnQoeVJhbmdlKTtcbiAgICAgIGNvbnN0IGJib3hCb3R0b20gPSB5U2NhbGUuY29udmVydCgwKTtcbiAgICAgIGNvbnN0IHhPZmZzZXQgPSBiYXJXaWR0aCAqIDAuNSAqICgxIC0gY3Jvc3NTY2FsZSk7XG4gICAgICBjb25zdCByZWN0ID0ge1xuICAgICAgICB4OiBiYXJBbG9uZ1ggPyBNYXRoLm1pbih5LCBib3R0b21ZKSA6IGJhclggKyB4T2Zmc2V0LFxuICAgICAgICB5OiBiYXJBbG9uZ1ggPyBiYXJYICsgeE9mZnNldCA6IE1hdGgubWluKHksIGJvdHRvbVkpLFxuICAgICAgICB3aWR0aDogYmFyQWxvbmdYID8gTWF0aC5hYnMoYm90dG9tWSAtIHkpIDogYmFyV2lkdGggKiBjcm9zc1NjYWxlLFxuICAgICAgICBoZWlnaHQ6IGJhckFsb25nWCA/IGJhcldpZHRoICogY3Jvc3NTY2FsZSA6IE1hdGguYWJzKGJvdHRvbVkgLSB5KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsaXBCQm94ID0gbmV3IEJCb3gocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGJhclJlY3QgPSB7XG4gICAgICAgIHg6IGJhckFsb25nWCA/IE1hdGgubWluKGJib3hCb3R0b20sIGJib3hIZWlnaHQpIDogYmFyWCArIHhPZmZzZXQsXG4gICAgICAgIHk6IGJhckFsb25nWCA/IGJhclggKyB4T2Zmc2V0IDogTWF0aC5taW4oYmJveEJvdHRvbSwgYmJveEhlaWdodCksXG4gICAgICAgIHdpZHRoOiBiYXJBbG9uZ1ggPyBNYXRoLmFicyhiYm94Qm90dG9tIC0gYmJveEhlaWdodCkgOiBiYXJXaWR0aCAqIGNyb3NzU2NhbGUsXG4gICAgICAgIGhlaWdodDogYmFyQWxvbmdYID8gYmFyV2lkdGggKiBjcm9zc1NjYWxlIDogTWF0aC5hYnMoYmJveEJvdHRvbSAtIGJib3hIZWlnaHQpXG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250U3R5bGU6IGxhYmVsRm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0OiBsYWJlbEZvbnRXZWlnaHQsXG4gICAgICAgIGZvbnRTaXplOiBsYWJlbEZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiBsYWJlbEZvbnRGYW1pbHksXG4gICAgICAgIGNvbG9yOiBsYWJlbENvbG9yLFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0gPSBsYWJlbDtcbiAgICAgIGNvbnN0IGxlbmd0aFJhdGlvTXVsdGlwbGllciA9IHRoaXMuc2hvdWxkRmxpcFhZKCkgPyByZWN0LmhlaWdodCA6IHJlY3Qud2lkdGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGl0ZW1JZDogcGhhbnRvbSA/IGNyZWF0ZURhdHVtSWQoeUtleSwgcGhhbnRvbSkgOiB5S2V5LFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgdmFsdWVJbmRleCxcbiAgICAgICAgY3VtdWxhdGl2ZVZhbHVlLFxuICAgICAgICBwaGFudG9tLFxuICAgICAgICB4VmFsdWUsXG4gICAgICAgIHlWYWx1ZSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgY2FwRGVmYXVsdHM6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpb011bHRpcGxpZXIsXG4gICAgICAgICAgbGVuZ3RoTWF4OiBsZW5ndGhSYXRpb011bHRpcGxpZXJcbiAgICAgICAgfSxcbiAgICAgICAgeDogYmFyUmVjdC54LFxuICAgICAgICB5OiBiYXJSZWN0LnksXG4gICAgICAgIHdpZHRoOiBiYXJSZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGJhclJlY3QuaGVpZ2h0LFxuICAgICAgICBtaWRQb2ludDogeyB4OiByZWN0LnggKyByZWN0LndpZHRoIC8gMiwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyIH0sXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgdG9wTGVmdENvcm5lclJhZGl1czogYmFyQWxvbmdYICE9PSBpc1Vwd2FyZCxcbiAgICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXM6IGlzVXB3YXJkLFxuICAgICAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogYmFyQWxvbmdYID09PSBpc1Vwd2FyZCxcbiAgICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogIWlzVXB3YXJkLFxuICAgICAgICBjbGlwQkJveCxcbiAgICAgICAgbGFiZWw6IGxhYmVsVGV4dCAhPSBudWxsID8ge1xuICAgICAgICAgIHRleHQ6IGxhYmVsVGV4dCxcbiAgICAgICAgICBmaWxsOiBsYWJlbENvbG9yLFxuICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWxGb250U3R5bGUsXG4gICAgICAgICAgZm9udFdlaWdodDogbGFiZWxGb250V2VpZ2h0LFxuICAgICAgICAgIGZvbnRTaXplOiBsYWJlbEZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsRm9udEZhbWlseSxcbiAgICAgICAgICAuLi5hZGp1c3RMYWJlbFBsYWNlbWVudCh7XG4gICAgICAgICAgICBpc1Bvc2l0aXZlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogIWJhckFsb25nWCxcbiAgICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICAgIHJlY3RcbiAgICAgICAgICB9KVxuICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICBtaXNzaW5nOiB5VmFsdWUgPT0gbnVsbCxcbiAgICAgICAgZm9jdXNhYmxlOiAhcGhhbnRvbVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHsgZ3JvdXBTY2FsZSwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBbXTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuICAgIHByb2Nlc3NlZERhdGE/LmRhdGEuZm9yRWFjaCgoeyBrZXlzLCBkYXR1bTogc2VyaWVzRGF0dW0sIHZhbHVlcywgYWdnVmFsdWVzIH0pID0+IHtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgdmFsdWVJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB4VmFsdWUgPSBrZXlzW3hJbmRleF07XG4gICAgICAgIGNvbnN0IHlSYXdWYWx1ZSA9IHZhbHVlW3lSYXdJbmRleF07XG4gICAgICAgIGNvbnN0IHlTdGFydCA9IE51bWJlcih2YWx1ZVt5U3RhcnRJbmRleF0pO1xuICAgICAgICBjb25zdCB5RmlsdGVyVmFsdWUgPSB5RmlsdGVySW5kZXggIT0gbnVsbCA/IE51bWJlcih2YWx1ZVt5RmlsdGVySW5kZXhdKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgeUVuZCA9IE51bWJlcih2YWx1ZVt5RW5kSW5kZXhdKTtcbiAgICAgICAgY29uc3QgaXNQb3NpdGl2ZSA9IHlSYXdWYWx1ZSA+PSAwICYmICFPYmplY3QuaXMoeVJhd1ZhbHVlLCAtMCk7XG4gICAgICAgIGNvbnN0IHlSYW5nZSA9IGFnZ1ZhbHVlcz8uW3lSYW5nZUluZGV4XVtpc1Bvc2l0aXZlID8gMSA6IDBdID8/IDA7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHlFbmQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHlGaWx0ZXJWYWx1ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUoeUZpbHRlclZhbHVlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHlSYXdWYWx1ZSAhPSBudWxsID8gdGhpcy5nZXRMYWJlbFRleHQoXG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bVt2YWx1ZUluZGV4XSxcbiAgICAgICAgICAgIHZhbHVlOiB5RmlsdGVyVmFsdWUgPz8geVJhd1ZhbHVlLFxuICAgICAgICAgICAgeEtleSxcbiAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICB4TmFtZSxcbiAgICAgICAgICAgIHlOYW1lLFxuICAgICAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICh2KSA9PiBpc0Zpbml0ZU51bWJlcih2KSA/IHYudG9GaXhlZCgyKSA6IFN0cmluZyh2KVxuICAgICAgICApIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBpbnNldCA9IHlGaWx0ZXJWYWx1ZSAhPSBudWxsICYmIHlGaWx0ZXJWYWx1ZSA+IHlSYXdWYWx1ZTtcbiAgICAgICAgY29uc3Qgbm9kZURhdGEgPSBub2RlRGF0dW0oe1xuICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bVt2YWx1ZUluZGV4XSxcbiAgICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICB5VmFsdWU6IHlGaWx0ZXJWYWx1ZSA/PyB5UmF3VmFsdWUsXG4gICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RmlsdGVyVmFsdWUgPz8geUVuZCxcbiAgICAgICAgICBwaGFudG9tOiBmYWxzZSxcbiAgICAgICAgICBjdXJyWTogeUZpbHRlclZhbHVlICE9IG51bGwgPyB5U3RhcnQgKyB5RmlsdGVyVmFsdWUgOiB5RW5kLFxuICAgICAgICAgIHByZXZZOiB5U3RhcnQsXG4gICAgICAgICAgaXNQb3NpdGl2ZSxcbiAgICAgICAgICB5UmFuZ2U6IE1hdGgubWF4KHlTdGFydCArICh5RmlsdGVyVmFsdWUgPz8gLUluZmluaXR5KSwgeVJhbmdlKSxcbiAgICAgICAgICBsYWJlbFRleHQsXG4gICAgICAgICAgY3Jvc3NTY2FsZTogaW5zZXQgPyAwLjYgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZURhdGEpO1xuICAgICAgICBsYWJlbHMucHVzaChub2RlRGF0YSk7XG4gICAgICAgIGlmICh5RmlsdGVyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHBoYW50b21Ob2RlRGF0YSA9IG5vZGVEYXR1bSh7XG4gICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW1bdmFsdWVJbmRleF0sXG4gICAgICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgICAgeVZhbHVlOiB5RmlsdGVyVmFsdWUsXG4gICAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIHBoYW50b206IHRydWUsXG4gICAgICAgICAgICBjdXJyWTogeUVuZCxcbiAgICAgICAgICAgIHByZXZZOiB5U3RhcnQsXG4gICAgICAgICAgICBpc1Bvc2l0aXZlLFxuICAgICAgICAgICAgeVJhbmdlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiB2b2lkIDAsXG4gICAgICAgICAgICBjcm9zc1NjYWxlOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwaGFudG9tTm9kZXMucHVzaChwaGFudG9tTm9kZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGE6IHBoYW50b21Ob2Rlcy5sZW5ndGggPiAwID8gWy4uLnBoYW50b21Ob2RlcywgLi4ubm9kZXNdIDogbm9kZXMsXG4gICAgICBsYWJlbERhdGE6IGxhYmVscyxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUgfHwgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH07XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0KCk7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0RGF0YShub2RlRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0SXRlbSA9IG5vZGVEYXRhLmZpbmQoXG4gICAgICAobm9kZURhdHVtKSA9PiBub2RlRGF0dW0uZGF0dW0gPT09IGhpZ2hsaWdodGVkSXRlbS5kYXR1bSAmJiAhbm9kZURhdHVtLnBoYW50b21cbiAgICApO1xuICAgIHJldHVybiBoaWdobGlnaHRJdGVtICE9IG51bGwgPyBbaGlnaGxpZ2h0SXRlbV0gOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLmRhdHVtU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIG9wdHMubm9kZURhdGEsXG4gICAgICB2b2lkIDAsXG4gICAgICAoZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoZGF0dW0ueFZhbHVlLCBkYXR1bS52YWx1ZUluZGV4LCBkYXR1bS5waGFudG9tKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1Ob2RlcyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHlLZXksXG4gICAgICBzdGFja0dyb3VwLFxuICAgICAgZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGl0ZW1TdHlsZXIsXG4gICAgICBzaGFkb3csXG4gICAgICBoaWdobGlnaHRTdHlsZTogeyBpdGVtOiBpdGVtSGlnaGxpZ2h0U3R5bGUgfVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgY3Jpc3AgPSB0aGlzLnByb3BlcnRpZXMuY3Jpc3AgPz8gY2hlY2tDcmlzcCh4QXhpcz8uc2NhbGUsIHhBeGlzPy52aXNpYmxlUmFuZ2UsIHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwsIHRoaXMubGFyZ2VzdERhdGFJbnRlcnZhbCk7XG4gICAgY29uc3QgY2F0ZWdvcnlBbG9uZ1ggPSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi87XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlLFxuICAgICAgbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGZpbGxTaGFkb3c6IHNoYWRvdyxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMFxuICAgIH07XG4gICAgY29uc3QgcmVjdFBhcmFtcyA9IHtcbiAgICAgIGRhdHVtOiB2b2lkIDAsXG4gICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICBpc0hpZ2hsaWdodGVkOiBvcHRzLmlzSGlnaGxpZ2h0LFxuICAgICAgaGlnaGxpZ2h0U3R5bGU6IGl0ZW1IaWdobGlnaHRTdHlsZSxcbiAgICAgIHlLZXksXG4gICAgICBzdHlsZSxcbiAgICAgIGl0ZW1TdHlsZXIsXG4gICAgICBzdGFja0dyb3VwXG4gICAgfTtcbiAgICBvcHRzLmRhdHVtU2VsZWN0aW9uLmVhY2goKHJlY3QsIGRhdHVtKSA9PiB7XG4gICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5ICogKGRhdHVtLnBoYW50b20gPyAwLjIgOiAxKTtcbiAgICAgIHN0eWxlLnN0cm9rZU9wYWNpdHkgPSBzdHJva2VPcGFjaXR5ICogKGRhdHVtLnBoYW50b20gPyAwLjIgOiAxKTtcbiAgICAgIHN0eWxlLmNvcm5lclJhZGl1cyA9IGRhdHVtLmNvcm5lclJhZGl1cztcbiAgICAgIHN0eWxlLnRvcExlZnRDb3JuZXJSYWRpdXMgPSBkYXR1bS50b3BMZWZ0Q29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSBkYXR1bS50b3BSaWdodENvcm5lclJhZGl1cztcbiAgICAgIHN0eWxlLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gZGF0dW0uYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gZGF0dW0uYm90dG9tTGVmdENvcm5lclJhZGl1cztcbiAgICAgIGNvbnN0IHZpc2libGUgPSBjYXRlZ29yeUFsb25nWCA/IChkYXR1bS5jbGlwQkJveD8ud2lkdGggPz8gZGF0dW0ud2lkdGgpID4gMCA6IChkYXR1bS5jbGlwQkJveD8uaGVpZ2h0ID8/IGRhdHVtLmhlaWdodCkgPiAwO1xuICAgICAgcmVjdFBhcmFtcy5kYXR1bSA9IGRhdHVtO1xuICAgICAgY29uc3QgY29uZmlnID0gZ2V0UmVjdENvbmZpZyhyZWN0UGFyYW1zKTtcbiAgICAgIGNvbmZpZy5jcmlzcCA9IGNyaXNwO1xuICAgICAgY29uZmlnLnZpc2libGUgPSB2aXNpYmxlO1xuICAgICAgdXBkYXRlUmVjdChyZWN0LCBjb25maWcpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpID8gb3B0cy5sYWJlbERhdGEgOiBbXTtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoZGF0YSwgKHRleHQpID0+IHtcbiAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHROb2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdXBkYXRlTGFiZWxOb2RlKHRleHROb2RlLCB0aGlzLnByb3BlcnRpZXMubGFiZWwsIGRhdHVtLmxhYmVsKTtcbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBwcm9jZXNzZWREYXRhLFxuICAgICAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0VmFsdWVBeGlzKCk7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCB0b29sdGlwLCBpdGVtU3R5bGVyLCBzdGFja0dyb3VwLCBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgeFZhbHVlLCB5VmFsdWUsIGRhdHVtLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4U3RyaW5nID0geEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKTtcbiAgICBjb25zdCB5U3RyaW5nID0geUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh5TmFtZSk7XG4gICAgY29uc3QgY29udGVudCA9IHNhbml0aXplSHRtbCh4U3RyaW5nICsgXCI6IFwiICsgeVN0cmluZyk7XG4gICAgbGV0IGZvcm1hdDtcbiAgICBpZiAoaXRlbVN0eWxlcikge1xuICAgICAgZm9ybWF0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGl0ZW1TdHlsZXIsIHtcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICBzdGFja0dyb3VwLFxuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSxcbiAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxuICAgICAgICBjb3JuZXJSYWRpdXM6IHRoaXMucHJvcGVydGllcy5jb3JuZXJSYWRpdXMsXG4gICAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoID8/IFtdLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBmb3JtYXQ/LmZpbGwgPz8gZmlsbDtcbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAgeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBzdGFja0dyb3VwLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lLFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyBzaG93SW5MZWdlbmQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAobGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiIHx8ICF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhc2hvd0luTGVnZW5kKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBsZWdlbmRJdGVtTmFtZSwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7IHRleHQ6IGxlZ2VuZEl0ZW1OYW1lID8/IHlOYW1lID8/IHlLZXkgfSxcbiAgICAgICAgc3ltYm9sczogW3sgbWFya2VyOiB7IGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH0gfV0sXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMgfSkge1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbih0aGlzLmlzVmVydGljYWwoKSwgdGhpcy5heGVzLCBcIm5vcm1hbFwiKSk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwibm9kZXNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgW2RhdHVtU2VsZWN0aW9uXSwgZm5zKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgY29uc3QgeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zLCBwcmV2aW91c0NvbnRleHREYXRhIH0gPSBkYXRhO1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZjtcbiAgICBjb25zdCBtb2RlID0gcHJldmlvdXNDb250ZXh0RGF0YSA9PSBudWxsID8gXCJmYWRlXCIgOiBcIm5vcm1hbFwiO1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbih0aGlzLmlzVmVydGljYWwoKSwgdGhpcy5heGVzLCBtb2RlKSk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbZGF0dW1TZWxlY3Rpb25dLFxuICAgICAgZm5zLFxuICAgICAgKF8sIGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLnhWYWx1ZSwgZGF0dW0udmFsdWVJbmRleCwgZGF0dW0ucGhhbnRvbSksXG4gICAgICBkYXRhRGlmZlxuICAgICk7XG4gICAgY29uc3QgaGFzTW90aW9uID0gZGF0YURpZmY/LmNoYW5nZWQgPz8gdHJ1ZTtcbiAgICBpZiAoaGFzTW90aW9uKSB7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgICB9XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyh7IGRhdHVtSW5kZXgsIHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IGRhdHVtQm94ID0gdGhpcy5jb250ZXh0Tm9kZURhdGE/Lm5vZGVEYXRhW2RhdHVtSW5kZXhdLmNsaXBCQm94O1xuICAgIHJldHVybiBjb21wdXRlQmFyRm9jdXNCb3VuZHMoZGF0dW1Cb3gsIHRoaXMuY29udGVudEdyb3VwLCBzZXJpZXNSZWN0KTtcbiAgfVxufTtcbkJhclNlcmllcy5jbGFzc05hbWUgPSBcIkJhclNlcmllc1wiO1xuQmFyU2VyaWVzLnR5cGUgPSBcImJhclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllc01vZHVsZS50c1xudmFyIEJhclNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImJhclwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQmFyU2VyaWVzKGN0eCksXG4gIHN0YWNrYWJsZTogdHJ1ZSxcbiAgZ3JvdXBhYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH1cbiAgXSxcbiAgc3dhcERlZmF1bHRBeGVzQ29uZGl0aW9uOiAoc2VyaWVzKSA9PiBzZXJpZXM/LmRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIsXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgICAgICAgcGxhY2VtZW50OiBcImluc2lkZVwiXG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgICB4T2Zmc2V0OiAzLFxuICAgICAgICB5T2Zmc2V0OiAzLFxuICAgICAgICBibHVyOiA1XG4gICAgICB9LFxuICAgICAgZXJyb3JCYXI6IHtcbiAgICAgICAgY2FwOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW86IDAuM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2NvbG9yU2NhbGUudHNcbnZhciBjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSA9ICh2KSA9PiB7XG4gIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbVN0cmluZyh2KTtcbiAgY29uc3QgW2wsIGMsIGhdID0gQ29sb3IuUkdCdG9PS0xDSChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgcmV0dXJuIHsgbCwgYywgaCwgYTogY29sb3IuYSB9O1xufTtcbnZhciBkZWx0YSA9IDFlLTY7XG52YXIgaXNBY2hyb21hdGljID0gKHgpID0+IHguYyA8IGRlbHRhIHx8IHgubCA8IGRlbHRhIHx8IHgubCA+IDEgLSBkZWx0YTtcbnZhciBpbnRlcnBvbGF0ZU9rbGNoID0gKHgsIHksIGQpID0+IHtcbiAgZCA9IGNsYW1wKDAsIGQsIDEpO1xuICBsZXQgaDtcbiAgaWYgKGlzQWNocm9tYXRpYyh4KSkge1xuICAgIGggPSB5Lmg7XG4gIH0gZWxzZSBpZiAoaXNBY2hyb21hdGljKHkpKSB7XG4gICAgaCA9IHguaDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB4SCA9IHguaDtcbiAgICBsZXQgeUggPSB5Lmg7XG4gICAgY29uc3QgZGVsdGFIID0geS5oIC0geC5oO1xuICAgIGlmIChkZWx0YUggPiAxODApIHtcbiAgICAgIHlIIC09IDM2MDtcbiAgICB9IGVsc2UgaWYgKGRlbHRhSCA8IC0xODApIHtcbiAgICAgIHlIICs9IDM2MDtcbiAgICB9XG4gICAgaCA9IHhIICogKDEgLSBkKSArIHlIICogZDtcbiAgfVxuICBjb25zdCBjID0geC5jICogKDEgLSBkKSArIHkuYyAqIGQ7XG4gIGNvbnN0IGwgPSB4LmwgKiAoMSAtIGQpICsgeS5sICogZDtcbiAgY29uc3QgYSA9IHguYSAqICgxIC0gZCkgKyB5LmEgKiBkO1xuICByZXR1cm4gQ29sb3IuZnJvbU9LTENIKGwsIGMsIGgsIGEpO1xufTtcbnZhciBDb2xvclNjYWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnR5cGUgPSBcImNvbG9yXCI7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLmRvbWFpbiA9IFswLCAxXTtcbiAgICB0aGlzLnJhbmdlID0gW1wicmVkXCIsIFwiYmx1ZVwiXTtcbiAgICB0aGlzLnBhcnNlZFJhbmdlID0gdGhpcy5yYW5nZS5tYXAoY29udmVydENvbG9yU3RyaW5nVG9Pa2xjaGEpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IGRvbWFpbiwgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBpZiAoZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcImBjb2xvckRvbWFpbmAgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXMuXCIpO1xuICAgICAgaWYgKGRvbWFpbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tYWluLnB1c2goMCwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGRvbWFpbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZG9tYWluLnB1c2goZG9tYWluWzBdICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZG9tYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gZG9tYWluW2kgLSAxXTtcbiAgICAgIGNvbnN0IGIgPSBkb21haW5baV07XG4gICAgICBpZiAoYSA+PSBiKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcImBjb2xvckRvbWFpbmAgdmFsdWVzIHNob3VsZCBiZSBzdXBwbGllZCBpbiBhc2NlbmRpbmcgb3JkZXIuXCIpO1xuICAgICAgICBkb21haW4uc29ydCgoYTIsIGIyKSA9PiBhMiAtIGIyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTMubGVuZ3RoIDwgZG9tYWluLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IHJhbmdlMy5sZW5ndGg7IGkgPCBkb21haW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmFuZ2UzLnB1c2gocmFuZ2UzLmxlbmd0aCA+IDAgPyByYW5nZTNbMF0gOiBcImJsYWNrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBhcnNlZFJhbmdlID0gdGhpcy5yYW5nZS5tYXAoY29udmVydENvbG9yU3RyaW5nVG9Pa2xjaGEpO1xuICB9XG4gIGNvbnZlcnQoeCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IHsgZG9tYWluLCByYW5nZTogcmFuZ2UzLCBwYXJzZWRSYW5nZSB9ID0gdGhpcztcbiAgICBjb25zdCBkMCA9IGRvbWFpblswXTtcbiAgICBjb25zdCBkMSA9IGRvbWFpbi5hdCgtMSk7XG4gICAgY29uc3QgcjAgPSByYW5nZTNbMF07XG4gICAgY29uc3QgcjEgPSByYW5nZTNbcmFuZ2UzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh4IDw9IGQwKSB7XG4gICAgICByZXR1cm4gcjA7XG4gICAgfVxuICAgIGlmICh4ID49IGQxKSB7XG4gICAgICByZXR1cm4gcjE7XG4gICAgfVxuICAgIGxldCBpbmRleDtcbiAgICBsZXQgcTtcbiAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgdCA9ICh4IC0gZDApIC8gKGQxIC0gZDApO1xuICAgICAgY29uc3Qgc3RlcCA9IDEgLyAocmFuZ2UzLmxlbmd0aCAtIDEpO1xuICAgICAgaW5kZXggPSByYW5nZTMubGVuZ3RoIDw9IDIgPyAwIDogTWF0aC5taW4oTWF0aC5mbG9vcih0ICogKHJhbmdlMy5sZW5ndGggLSAxKSksIHJhbmdlMy5sZW5ndGggLSAyKTtcbiAgICAgIHEgPSAodCAtIGluZGV4ICogc3RlcCkgLyBzdGVwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBkb21haW4ubGVuZ3RoIC0gMjsgaW5kZXgrKykge1xuICAgICAgICBpZiAoeCA8IGRvbWFpbltpbmRleCArIDFdKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGEgPSBkb21haW5baW5kZXhdO1xuICAgICAgY29uc3QgYiA9IGRvbWFpbltpbmRleCArIDFdO1xuICAgICAgcSA9ICh4IC0gYSkgLyAoYiAtIGEpO1xuICAgIH1cbiAgICBjb25zdCBjMCA9IHBhcnNlZFJhbmdlW2luZGV4XTtcbiAgICBjb25zdCBjMSA9IHBhcnNlZFJhbmdlW2luZGV4ICsgMV07XG4gICAgcmV0dXJuIGludGVycG9sYXRlT2tsY2goYzAsIGMxLCBxKS50b1JnYmFTdHJpbmcoKTtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5pbnZhbGlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiRXhwZWN0ZWQgdXBkYXRlIHRvIG5vdCBpbnZhbGlkYXRlIHNjYWxlXCIpO1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgQ29sb3JTY2FsZS5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBDb2xvclNjYWxlLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9idWJibGVTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgQnViYmxlU2VyaWVzTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNNYXJrZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWF4U2l6ZSA9IDMwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEJ1YmJsZVNlcmllc01hcmtlci5wcm90b3R5cGUsIFwibWF4U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEJ1YmJsZVNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xudmFyIEJ1YmJsZVNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcInRvcFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTEFCRUxfUExBQ0VNRU5UKVxuXSwgQnViYmxlU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbnZhciBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yUmFuZ2UgPSBbXCIjZmZmZjAwXCIsIFwiIzAwZmYwMFwiLCBcIiMwMDAwZmZcIl07XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBCdWJibGVTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgLy8gTm8gdmFsaWRhdGlvbi4gTm90IGEgcGFydCBvZiB0aGUgb3B0aW9ucyBjb250cmFjdC5cbiAgICB0aGlzLm1hcmtlciA9IG5ldyBCdWJibGVTZXJpZXNNYXJrZXIoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JEb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2hhcGVcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaXplXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5tYXhTaXplXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5kb21haW5cIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxPcGFjaXR5XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlV2lkdGhcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VPcGFjaXR5XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5pdGVtU3R5bGVyXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYnViYmxlU2VyaWVzLnRzXG52YXIgQnViYmxlU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLnNpemVLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zaXplS2V5O1xuICB9XG59O1xudmFyIEJ1YmJsZVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbXG4gICAgICAgIDIgLyogTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1QgKi8sXG4gICAgICAgIDMgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtdLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXG4gICAgICAgIG1hcmtlcjogcmVzZXRNYXJrZXJGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gQnViYmxlU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5zaXplU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLmNvbG9yU2NhbGUgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgY29sb3JTY2FsZVR5cGUgPSB0aGlzLmNvbG9yU2NhbGUudHlwZTtcbiAgICBjb25zdCBzaXplU2NhbGVUeXBlID0gdGhpcy5zaXplU2NhbGUudHlwZTtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgY29sb3JLZXksIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAga2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4S2V5LXJhd1wiIH0pLFxuICAgICAgICBrZXlQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBcInlLZXktcmF3XCIgfSksXG4gICAgICAgIC4uLmxhYmVsS2V5ID8gW2tleVByb3BlcnR5KGxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGxhYmVsS2V5LXJhd2AgfSldIDogW10sXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogYHhWYWx1ZWAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZWAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoc2l6ZUtleSwgc2l6ZVNjYWxlVHlwZSwgeyBpZDogYHNpemVWYWx1ZWAgfSksXG4gICAgICAgIC4uLmNvbG9yS2V5ID8gW3ZhbHVlUHJvcGVydHkoY29sb3JLZXksIGNvbG9yU2NhbGVUeXBlLCB7IGlkOiBgY29sb3JWYWx1ZWAgfSldIDogW10sXG4gICAgICAgIC4uLmxhYmVsS2V5ID8gW3ZhbHVlUHJvcGVydHkobGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgbGFiZWxWYWx1ZWAgfSldIDogW11cbiAgICAgIF1cbiAgICB9KTtcbiAgICBjb25zdCBzaXplS2V5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzaXplVmFsdWVgKTtcbiAgICBjb25zdCBwcm9jZXNzZWRTaXplID0gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW3NpemVLZXlJZHhdID8/IFtdO1xuICAgIHRoaXMuc2l6ZVNjYWxlLmRvbWFpbiA9IG1hcmtlci5kb21haW4gPyBtYXJrZXIuZG9tYWluIDogcHJvY2Vzc2VkU2l6ZTtcbiAgICBpZiAoY29sb3JLZXkpIHtcbiAgICAgIGNvbnN0IGNvbG9yS2V5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCk7XG4gICAgICB0aGlzLmNvbG9yU2NhbGUuZG9tYWluID0gY29sb3JEb21haW4gPz8gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW2NvbG9yS2V5SWR4XSA/PyBbXTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5yYW5nZSA9IGNvbG9yUmFuZ2U7XG4gICAgICB0aGlzLmNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGlkID0gZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovID8gYHhWYWx1ZWAgOiBgeVZhbHVlYDtcbiAgICBjb25zdCBkYXRhRGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBpZCk7XG4gICAgY29uc3QgZG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBpZCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBpZiAoZGF0YURlZj8uZGVmLnR5cGUgPT09IFwidmFsdWVcIiAmJiBkYXRhRGVmPy5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSwgYXhpcyk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBheGVzLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGNvbG9yU2NhbGUsIHNpemVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCB4TmFtZSwgeU5hbWUsIHNpemVOYW1lLCBsYWJlbE5hbWUsIGxhYmVsLCBjb2xvcktleSwgbWFya2VyLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbWFya2VyU2hhcGUgPSBnZXRNYXJrZXIobWFya2VyLnNoYXBlKTtcbiAgICBjb25zdCB7IHBsYWNlbWVudCB9ID0gbGFiZWw7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIShkYXRhTW9kZWwgJiYgcHJvY2Vzc2VkRGF0YSAmJiB2aXNpYmxlICYmIHhBeGlzICYmIHlBeGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeURhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZWApO1xuICAgIGNvbnN0IHNpemVEYXRhSWR4ID0gc2l6ZUtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2l6ZVZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCBjb2xvckRhdGFJZHggPSBjb2xvcktleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgbGFiZWxEYXRhSWR4ID0gbGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxhYmVsVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgeU9mZnNldCA9ICh5U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIHNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xuICAgIGNvbnN0IGZvbnQgPSBsYWJlbC5nZXRGb250KCk7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgZm9yIChjb25zdCB7IHZhbHVlcywgZGF0dW0gfSBvZiBwcm9jZXNzZWREYXRhLmRhdGEgPz8gW10pIHtcbiAgICAgIGNvbnN0IHhEYXR1bSA9IHZhbHVlc1t4RGF0YUlkeF07XG4gICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeURhdGFJZHhdO1xuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSkgKyB5T2Zmc2V0O1xuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQobGFiZWwsIHtcbiAgICAgICAgdmFsdWU6IGxhYmVsS2V5ID8gdmFsdWVzW2xhYmVsRGF0YUlkeF0gOiB5RGF0dW0sXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICBzaXplS2V5LFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBzaXplTmFtZSxcbiAgICAgICAgbGFiZWxOYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNpemUgPSB0ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQoU3RyaW5nKGxhYmVsVGV4dCkpO1xuICAgICAgY29uc3QgbWFya2VyU2l6ZSA9IHNpemVLZXkgPyBzaXplU2NhbGUuY29udmVydCh2YWx1ZXNbc2l6ZURhdGFJZHhdKSA6IG1hcmtlci5zaXplO1xuICAgICAgY29uc3QgZmlsbCA9IGNvbG9yS2V5ID8gY29sb3JTY2FsZS5jb252ZXJ0KHZhbHVlc1tjb2xvckRhdGFJZHhdKSA6IHZvaWQgMDtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgc2l6ZVZhbHVlOiB2YWx1ZXNbc2l6ZURhdGFJZHhdLFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBtYXJrZXJTaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGFiZWxUZXh0LCAuLi5zaXplIH0sXG4gICAgICAgIG1hcmtlcjogbWFya2VyU2hhcGUsXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5sYWJlbERhdGEgPz8gW107XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgPyBub2RlRGF0YSA6IFtdO1xuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgZGF0YSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIChkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChbZGF0dW0ueFZhbHVlLCBkYXR1bS55VmFsdWUsIGRhdHVtLmxhYmVsLnRleHRdKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSwgbWFya2VyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzaXplLCBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICBoaWdobGlnaHRlZCAmJiB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSxcbiAgICAgIG1hcmtlci5nZXRTdHlsZSgpXG4gICAgKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9O1xuICAgIHRoaXMuc2l6ZVNjYWxlLnJhbmdlID0gW21hcmtlci5zaXplLCBtYXJrZXIubWF4U2l6ZV07XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5IH0sIGJhc2VTdHlsZSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHBsYWNlZExhYmVscyA9IHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkID8gdGhpcy5jaGFydD8ucGxhY2VMYWJlbHMoKS5nZXQodGhpcykgPz8gW10gOiBbXTtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBwbGFjZWRMYWJlbHMubWFwKCh2KSA9PiAoe1xuICAgICAgICAuLi52LmRhdHVtLFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIHg6IHYueCxcbiAgICAgICAgICB5OiB2LnksXG4gICAgICAgICAgc2l6ZTogdi5kYXR1bS5wb2ludC5zaXplXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIHRleHQudGV4dCA9IGRhdHVtLmxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICAgIHRleHQueCA9IGRhdHVtLnBvaW50Py54ID8/IDA7XG4gICAgICB0ZXh0LnkgPSBkYXR1bS5wb2ludD8ueSA/PyAwO1xuICAgICAgdGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgICAgdGV4dC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgICAgdGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIHhOYW1lLCB5TmFtZSwgc2l6ZU5hbWUsIGxhYmVsTmFtZSwgbWFya2VyLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnByb3BlcnRpZXMudGl0bGUgPz8geU5hbWU7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIHsgZmlsbDogbm9kZURhdHVtLmZpbGwsIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKG1hcmtlci5zdHJva2VXaWR0aCkgfSxcbiAgICAgIG1hcmtlci5nZXRTdHlsZSgpXG4gICAgKTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yID0gXCJncmF5XCIgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoXG4gICAgICBtYXJrZXIsXG4gICAgICB7IGRhdHVtOiBub2RlRGF0dW0sIGhpZ2hsaWdodGVkOiBmYWxzZSwgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0dW0sXG4gICAgICB4VmFsdWUsXG4gICAgICB5VmFsdWUsXG4gICAgICBzaXplVmFsdWUsXG4gICAgICBsYWJlbDogeyB0ZXh0OiBsYWJlbFRleHQgfSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeFN0cmluZyA9IHNhbml0aXplSHRtbCh4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpKTtcbiAgICBjb25zdCB5U3RyaW5nID0gc2FuaXRpemVIdG1sKHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSkpO1xuICAgIGxldCBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKHhOYW1lID8/IHhLZXkpfTwvYj46ICR7eFN0cmluZ308YnI+PGI+JHtzYW5pdGl6ZUh0bWwoeU5hbWUgPz8geUtleSl9PC9iPjogJHt5U3RyaW5nfWA7XG4gICAgaWYgKHNpemVLZXkpIHtcbiAgICAgIGNvbnRlbnQgKz0gYDxicj48Yj4ke3Nhbml0aXplSHRtbChzaXplTmFtZSA/PyBzaXplS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChTdHJpbmcoc2l6ZVZhbHVlKSl9YDtcbiAgICB9XG4gICAgaWYgKGxhYmVsS2V5KSB7XG4gICAgICBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKGxhYmVsTmFtZSA/PyBsYWJlbEtleSl9PC9iPjogJHtzYW5pdGl6ZUh0bWwobGFiZWxUZXh0KX08YnI+YCArIGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgc2l6ZUtleSxcbiAgICAgICAgc2l6ZU5hbWUsXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICBsYWJlbE5hbWUsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHlLZXksIHlOYW1lLCB0aXRsZSwgbWFya2VyLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzaGFwZSwgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IG1hcmtlcjtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHRpdGxlID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBzdHJva2VPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/PyAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24gfSkge1xuICAgIG1hcmtlclNjYWxlSW5BbmltYXRpb24odGhpcywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7XG4gICAgICBkYXR1bSxcbiAgICAgIHhLZXksXG4gICAgICB5S2V5LFxuICAgICAgc2l6ZUtleSxcbiAgICAgIGxhYmVsS2V5LFxuICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuQnViYmxlU2VyaWVzLmNsYXNzTmFtZSA9IFwiQnViYmxlU2VyaWVzXCI7XG5CdWJibGVTZXJpZXMudHlwZSA9IFwiYnViYmxlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYnViYmxlU2VyaWVzTW9kdWxlLnRzXG52YXIgQnViYmxlU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiYnViYmxlXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBCdWJibGVTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcIm5lYXJlc3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgIHNpemU6IDcsXG4gICAgICBtYXhTaXplOiAzMCxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2hpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYXJlYVBsb3QgPSBmYWxzZTtcbiAgICB0aGlzLmFnZ3JlZ2F0aW9uID0gXCJzdW1cIjtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYXJlYVBsb3RcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYmluc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImNvdW50XCIsIFwic3VtXCIsIFwibWVhblwiXSwgXCJhIGhpc3RvZ3JhbSBhZ2dyZWdhdGlvblwiKSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFnZ3JlZ2F0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJiaW5Db3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXMudHNcbnZhciBkZWZhdWx0QmluQ291bnQgPSAxMDtcbnZhciBIaXN0b2dyYW1TZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogWzMgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgZGF0dW06IHJlc2V0QmFyU2VsZWN0aW9uc0ZuLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLmNhbGN1bGF0ZWRCaW5zID0gW107XG4gIH1cbiAgLy8gRHVyaW5nIHByb2Nlc3NEYXRhIHBoYXNlLCB1c2VkIHRvIHVuaWZ5IGRpZmZlcmVudCB3YXlzIG9mIHRoZSB1c2VyIHNwZWNpZnlpbmdcbiAgLy8gdGhlIGJpbnMuIFJldHVybnMgYmlucyBpbiBmb3JtYXRbW21pbjEsIG1heDFdLCBbbWluMiwgbWF4Ml0sIC4uLiBdLlxuICBkZXJpdmVCaW5zKHhEb21haW4pIHtcbiAgICBjb25zdCBiaW5TdGFydHMgPSBjcmVhdGVUaWNrcyh4RG9tYWluWzBdLCB4RG9tYWluWzFdLCBkZWZhdWx0QmluQ291bnQpO1xuICAgIGNvbnN0IGJpblNpemUgPSB0aWNrU3RlcCh4RG9tYWluWzBdLCB4RG9tYWluWzFdLCBkZWZhdWx0QmluQ291bnQpO1xuICAgIGNvbnN0IFtmaXJzdEJpbkVuZF0gPSBiaW5TdGFydHM7XG4gICAgY29uc3QgZXhwYW5kU3RhcnRUb0JpbiA9IChuKSA9PiBbbiwgbiArIGJpblNpemVdO1xuICAgIHJldHVybiBbW2ZpcnN0QmluRW5kIC0gYmluU2l6ZSwgZmlyc3RCaW5FbmRdLCAuLi5iaW5TdGFydHMubWFwKGV4cGFuZFN0YXJ0VG9CaW4pXTtcbiAgfVxuICBjYWxjdWxhdGVOaWNlQmlucyhkb21haW4sIGJpbkNvdW50KSB7XG4gICAgY29uc3Qgc3RhcnRHdWVzcyA9IE1hdGguZmxvb3IoZG9tYWluWzBdKTtcbiAgICBjb25zdCBzdG9wID0gZG9tYWluWzFdO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gYmluQ291bnQgfHwgMTtcbiAgICBjb25zdCB7IHN0YXJ0LCBiaW5TaXplIH0gPSB0aGlzLmNhbGN1bGF0ZU5pY2VTdGFydChzdGFydEd1ZXNzLCBzdG9wLCBzZWdtZW50cyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QmlucyhzdGFydCwgc3RvcCwgYmluU2l6ZSwgc2VnbWVudHMpO1xuICB9XG4gIGdldEJpbnMoc3RhcnQsIHN0b3AsIHN0ZXAsIGNvdW50KSB7XG4gICAgY29uc3QgYmlucyA9IFtdO1xuICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuY2FsY3VsYXRlUHJlY2lzaW9uKHN0ZXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYSA9IE1hdGgucm91bmQoKHN0YXJ0ICsgaSAqIHN0ZXApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgIGxldCBiID0gTWF0aC5yb3VuZCgoc3RhcnQgKyAoaSArIDEpICogc3RlcCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgaWYgKGkgPT09IGNvdW50IC0gMSkge1xuICAgICAgICBiID0gTWF0aC5tYXgoYiwgc3RvcCk7XG4gICAgICB9XG4gICAgICBiaW5zW2ldID0gW2EsIGJdO1xuICAgIH1cbiAgICByZXR1cm4gYmlucztcbiAgfVxuICBjYWxjdWxhdGVQcmVjaXNpb24oc3RlcCkge1xuICAgIGxldCBwcmVjaXNpb24gPSAxMDtcbiAgICBpZiAoaXNGaW5pdGUoc3RlcCkgJiYgc3RlcCA+IDApIHtcbiAgICAgIHdoaWxlIChzdGVwIDwgMSkge1xuICAgICAgICBwcmVjaXNpb24gKj0gMTA7XG4gICAgICAgIHN0ZXAgKj0gMTA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVjaXNpb247XG4gIH1cbiAgY2FsY3VsYXRlTmljZVN0YXJ0KGEsIGIsIHNlZ21lbnRzKSB7XG4gICAgY29uc3QgYmluU2l6ZSA9IE1hdGguYWJzKGIgLSBhKSAvIHNlZ21lbnRzO1xuICAgIGNvbnN0IG9yZGVyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGJpblNpemUpKTtcbiAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnBvdygxMCwgb3JkZXIpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihhIC8gbWFnbml0dWRlKSAqIG1hZ25pdHVkZTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQsXG4gICAgICBiaW5TaXplXG4gICAgfTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICB0aGlzLnByb2Nlc3NlZERhdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGFyZWFQbG90LCBhZ2dyZWdhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHlTY2FsZSwgeFNjYWxlIH0pO1xuICAgIGNvbnN0IHByb3BzID0gW2tleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUpLCBTT1JUX0RPTUFJTl9HUk9VUFNdO1xuICAgIGlmICh5S2V5KSB7XG4gICAgICBsZXQgYWdnUHJvcCA9IGdyb3VwQ291bnQoXCJncm91cEFnZ1wiKTtcbiAgICAgIGlmIChhZ2dyZWdhdGlvbiA9PT0gXCJjb3VudFwiKSB7XG4gICAgICB9IGVsc2UgaWYgKGFnZ3JlZ2F0aW9uID09PSBcInN1bVwiKSB7XG4gICAgICAgIGFnZ1Byb3AgPSBncm91cFN1bShcImdyb3VwQWdnXCIpO1xuICAgICAgfSBlbHNlIGlmIChhZ2dyZWdhdGlvbiA9PT0gXCJtZWFuXCIpIHtcbiAgICAgICAgYWdnUHJvcCA9IGdyb3VwQXZlcmFnZShcImdyb3VwQWdnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZWFQbG90KSB7XG4gICAgICAgIGFnZ1Byb3AgPSBhcmVhKFwiZ3JvdXBBZ2dcIiwgYWdnUHJvcCk7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpbnZhbGlkVmFsdWU6IHZvaWQgMCB9KSwgYWdnUHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhZ2dQcm9wID0gZ3JvdXBDb3VudChcImdyb3VwQWdnXCIpO1xuICAgICAgaWYgKGFyZWFQbG90KSB7XG4gICAgICAgIGFnZ1Byb3AgPSBhcmVhKFwiZ3JvdXBBZ2dcIiwgYWdnUHJvcCk7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKGFnZ1Byb3ApO1xuICAgIH1cbiAgICBjb25zdCBncm91cEJ5Rm4gPSAoZGF0YVNldCkgPT4ge1xuICAgICAgY29uc3QgeEV4dGVudCA9IGZpeE51bWVyaWNFeHRlbnQoZGF0YVNldC5kb21haW4ua2V5c1swXSk7XG4gICAgICBpZiAoeEV4dGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGF0YVNldC5kb21haW4uZ3JvdXBzID0gW107XG4gICAgICAgIHJldHVybiAoKSA9PiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpbnMgPSBpc051bWJlcih0aGlzLnByb3BlcnRpZXMuYmluQ291bnQpID8gdGhpcy5jYWxjdWxhdGVOaWNlQmlucyh4RXh0ZW50LCB0aGlzLnByb3BlcnRpZXMuYmluQ291bnQpIDogdGhpcy5wcm9wZXJ0aWVzLmJpbnMgPz8gdGhpcy5kZXJpdmVCaW5zKHhFeHRlbnQpO1xuICAgICAgY29uc3QgYmluQ291bnQgPSBiaW5zLmxlbmd0aDtcbiAgICAgIHRoaXMuY2FsY3VsYXRlZEJpbnMgPSBbLi4uYmluc107XG4gICAgICByZXR1cm4gKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgeFZhbHVlID0gaXRlbS5rZXlzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbkNvdW50OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0QmluID0gYmluc1tpXTtcbiAgICAgICAgICBpZiAoeFZhbHVlID49IG5leHRCaW5bMF0gJiYgeFZhbHVlIDwgbmV4dEJpblsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRCaW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSBiaW5Db3VudCAtIDEgJiYgeFZhbHVlIDw9IG5leHRCaW5bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0QmluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuICAgIH07XG4gICAgaWYgKCF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpICYmIHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgcHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCB0aGlzLmRhdGEsIHsgcHJvcHMsIGdyb3VwQnlGbiB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCAhdGhpcy5jYWxjdWxhdGVkQmlucy5sZW5ndGgpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeURvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYGdyb3VwQWdnYCwgXCJhZ2dyZWdhdGVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeERvbWFpbk1pbiA9IHRoaXMuY2FsY3VsYXRlZEJpbnM/LlswXVswXTtcbiAgICBjb25zdCB4RG9tYWluTWF4ID0gdGhpcy5jYWxjdWxhdGVkQmlucz8uWyh0aGlzLmNhbGN1bGF0ZWRCaW5zPy5sZW5ndGggPz8gMCkgLSAxXVsxXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChbeERvbWFpbk1pbiwgeERvbWFpbk1heF0pO1xuICAgIH1cbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RG9tYWluKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBheGVzLFxuICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICgheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2NhbGU6IHhTY2FsZSB9ID0geEF4aXM7XG4gICAgY29uc3QgeyBzY2FsZTogeVNjYWxlIH0gPSB5QXhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgY29ybmVyUmFkaXVzIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3Qge1xuICAgICAgZm9ybWF0dGVyOiBsYWJlbEZvcm1hdHRlciA9IChwYXJhbXMpID0+IFN0cmluZyhwYXJhbXMudmFsdWUpLFxuICAgICAgZm9udFN0eWxlOiBsYWJlbEZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsRm9udFdlaWdodCxcbiAgICAgIGZvbnRTaXplOiBsYWJlbEZvbnRTaXplLFxuICAgICAgZm9udEZhbWlseTogbGFiZWxGb250RmFtaWx5LFxuICAgICAgY29sb3I6IGxhYmVsQ29sb3JcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGl0ZW1JZDogdGhpcy5wcm9wZXJ0aWVzLnlLZXkgPz8gdGhpcy5pZCxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICBhbmltYXRpb25WYWxpZDogdHJ1ZSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgIXByb2Nlc3NlZERhdGEgfHwgcHJvY2Vzc2VkRGF0YS50eXBlICE9PSBcImdyb3VwZWRcIilcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZ2dWYWx1ZXM6IFtbbmVnYXRpdmVBZ2csIHBvc2l0aXZlQWdnXV0gPSBbWzAsIDBdXSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGRhdHVtOiB7IGxlbmd0aDogZnJlcXVlbmN5IH0sXG4gICAgICAgIGtleXM6IGRvbWFpbixcbiAgICAgICAga2V5czogW3hEb21haW5NaW4sIHhEb21haW5NYXhdXG4gICAgICB9ID0gZ3JvdXA7XG4gICAgICBjb25zdCB4TWluUHggPSB4U2NhbGUuY29udmVydCh4RG9tYWluTWluKTtcbiAgICAgIGNvbnN0IHhNYXhQeCA9IHhTY2FsZS5jb252ZXJ0KHhEb21haW5NYXgpO1xuICAgICAgY29uc3QgdG90YWwgPSBuZWdhdGl2ZUFnZyArIHBvc2l0aXZlQWdnO1xuICAgICAgY29uc3QgeVplcm9QeCA9IHlTY2FsZS5jb252ZXJ0KDApO1xuICAgICAgY29uc3QgeU1heFB4ID0geVNjYWxlLmNvbnZlcnQodG90YWwpO1xuICAgICAgY29uc3QgdyA9IE1hdGguYWJzKHhNYXhQeCAtIHhNaW5QeCk7XG4gICAgICBjb25zdCBoID0gTWF0aC5hYnMoeU1heFB4IC0geVplcm9QeCk7XG4gICAgICBjb25zdCB4ID0gTWF0aC5taW4oeE1pblB4LCB4TWF4UHgpO1xuICAgICAgY29uc3QgeSA9IE1hdGgubWluKHlaZXJvUHgsIHlNYXhQeCk7XG4gICAgICBsZXQgc2VsZWN0aW9uRGF0dW1MYWJlbCA9IHZvaWQgMDtcbiAgICAgIGlmICh0b3RhbCAhPT0gMCkge1xuICAgICAgICBzZWxlY3Rpb25EYXR1bUxhYmVsID0ge1xuICAgICAgICAgIHRleHQ6IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbEZvcm1hdHRlciwge1xuICAgICAgICAgICAgdmFsdWU6IHRvdGFsLFxuICAgICAgICAgICAgZGF0dW0sXG4gICAgICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgeE5hbWUsXG4gICAgICAgICAgICB5TmFtZVxuICAgICAgICAgIH0pID8/IFN0cmluZyh0b3RhbCksXG4gICAgICAgICAgZm9udFN0eWxlOiBsYWJlbEZvbnRTdHlsZSxcbiAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbEZvbnRXZWlnaHQsXG4gICAgICAgICAgZm9udFNpemU6IGxhYmVsRm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogbGFiZWxGb250RmFtaWx5LFxuICAgICAgICAgIGZpbGw6IGxhYmVsQ29sb3IsXG4gICAgICAgICAgeDogeCArIHcgLyAyLFxuICAgICAgICAgIHk6IHkgKyBoIC8gMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZU1pZFBvaW50ID0ge1xuICAgICAgICB4OiB4ICsgdyAvIDIsXG4gICAgICAgIHk6IHkgKyBoIC8gMlxuICAgICAgfTtcbiAgICAgIGNvbnN0IHlBeGlzUmV2ZXJzZWQgPSB5QXhpcy5pc1JldmVyc2VkKCk7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgLy8gcmVxdWlyZWQgYnkgU2VyaWVzTm9kZURhdHVtLCBidXQgbWlnaHQgbm90IG1ha2Ugc2Vuc2UgaGVyZVxuICAgICAgICAvLyBzaW5jZSBlYWNoIHNlbGVjdGlvbiBpcyBhbiBhZ2dyZWdhdGlvbiBvZiBtdWx0aXBsZSBkYXRhLlxuICAgICAgICBhZ2dyZWdhdGVkVmFsdWU6IHRvdGFsLFxuICAgICAgICBmcmVxdWVuY3ksXG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeFZhbHVlOiB4TWluUHgsXG4gICAgICAgIHlWYWx1ZTogeU1heFB4LFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICBtaWRQb2ludDogbm9kZU1pZFBvaW50LFxuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgdG9wTGVmdENvcm5lclJhZGl1czogIXlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiAheUF4aXNSZXZlcnNlZCxcbiAgICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IHlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IHlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBsYWJlbDogc2VsZWN0aW9uRGF0dW1MYWJlbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbm9kZURhdGEuc29ydCgoYSwgYikgPT4gYS54IC0gYi54KTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3QoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bVNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgZGF0dW1TZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgcmV0dXJuIGRhdHVtU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgKHJlY3QpID0+IHtcbiAgICAgICAgcmVjdC50YWcgPSAwIC8qIEJpbiAqLztcbiAgICAgICAgcmVjdC5jcmlzcCA9IHRydWU7XG4gICAgICB9LFxuICAgICAgKGRhdHVtKSA9PiBkYXR1bS5kb21haW4uam9pbihcIl9cIilcbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgaXNIaWdobGlnaHQ6IGlzRGF0dW1IaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7XG4gICAgICBmaWxsT3BhY2l0eTogc2VyaWVzRmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgIHNoYWRvdyxcbiAgICAgIGhpZ2hsaWdodFN0eWxlOiB7XG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBmaWxsOiBoaWdobGlnaHRlZEZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IGhpZ2hsaWdodEZpbGxPcGFjaXR5ID0gc2VyaWVzRmlsbE9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiBoaWdobGlnaHRlZFN0cm9rZSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIG9wdHMuZGF0dW1TZWxlY3Rpb24uZWFjaCgocmVjdCwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgdG9wTGVmdENvcm5lclJhZGl1cyxcbiAgICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzXG4gICAgICB9ID0gZGF0dW07XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGlzRGF0dW1IaWdobGlnaHRlZCAmJiBoaWdobGlnaHRlZERhdHVtU3Ryb2tlV2lkdGggIT09IHZvaWQgMCA/IGhpZ2hsaWdodGVkRGF0dW1TdHJva2VXaWR0aCA6IGRhdHVtLnN0cm9rZVdpZHRoO1xuICAgICAgY29uc3QgZmlsbE9wYWNpdHkgPSBpc0RhdHVtSGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRGaWxsT3BhY2l0eSA6IHNlcmllc0ZpbGxPcGFjaXR5O1xuICAgICAgcmVjdC5maWxsID0gKGlzRGF0dW1IaWdobGlnaHRlZCA/IGhpZ2hsaWdodGVkRmlsbCA6IHZvaWQgMCkgPz8gZGF0dW0uZmlsbDtcbiAgICAgIHJlY3Quc3Ryb2tlID0gKGlzRGF0dW1IaWdobGlnaHRlZCA/IGhpZ2hsaWdodGVkU3Ryb2tlIDogdm9pZCAwKSA/PyBkYXR1bS5zdHJva2U7XG4gICAgICByZWN0LmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHk7XG4gICAgICByZWN0LnN0cm9rZU9wYWNpdHkgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgcmVjdC5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgcmVjdC5saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgcmVjdC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgcmVjdC50b3BMZWZ0Q29ybmVyUmFkaXVzID0gdG9wTGVmdENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gdG9wUmlnaHRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC5maWxsU2hhZG93ID0gc2hhZG93O1xuICAgICAgcmVjdC56SW5kZXggPSBpc0RhdHVtSGlnaGxpZ2h0ZWQgPyBTZXJpZXMuaGlnaGxpZ2h0ZWRaSW5kZXggOiBpbmRleDtcbiAgICAgIHJlY3QudmlzaWJsZSA9IGRhdHVtLmhlaWdodCA+IDA7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWxEYXRhLCBsYWJlbFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICByZXR1cm4gbGFiZWxTZWxlY3Rpb24udXBkYXRlKGxhYmVsRGF0YSwgKHRleHQpID0+IHtcbiAgICAgIHRleHQudGFnID0gMSAvKiBMYWJlbCAqLztcbiAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCBsYWJlbEVuYWJsZWQgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCk7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5sYWJlbDtcbiAgICAgIGlmIChsYWJlbCAmJiBsYWJlbEVuYWJsZWQpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgICAgdGV4dC54ID0gbGFiZWwueDtcbiAgICAgICAgdGV4dC55ID0gbGFiZWwueTtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC5maWxsID0gbGFiZWwuZmlsbDtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXRRdWFkVHJlZShxdWFkdHJlZSkge1xuICAgIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlKHF1YWR0cmVlLCBjaGlsZHJlbkl0ZXIodGhpcy5jb250ZW50R3JvdXAuY2hpbGRyZW5bMF0pKTtcbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIHJldHVybiBmaW5kUXVhZHRyZWVNYXRjaCh0aGlzLCBwb2ludCk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBmaWxsOiBjb2xvciwgYWdncmVnYXRpb24sIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7XG4gICAgICBhZ2dyZWdhdGVkVmFsdWUsXG4gICAgICBmcmVxdWVuY3ksXG4gICAgICBkb21haW46IFtyYW5nZU1pbiwgcmFuZ2VNYXhdLFxuICAgICAgaXRlbUlkXG4gICAgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB0aXRsZSA9IGAke3Nhbml0aXplSHRtbCh4TmFtZSA/PyB4S2V5KX06ICR7eEF4aXMuZm9ybWF0RGF0dW0ocmFuZ2VNaW4pfSAtICR7eEF4aXMuZm9ybWF0RGF0dW0ocmFuZ2VNYXgpfWA7XG4gICAgbGV0IGNvbnRlbnQgPSB5S2V5ID8gYDxiPiR7c2FuaXRpemVIdG1sKHlOYW1lID8/IHlLZXkpfSAoJHthZ2dyZWdhdGlvbn0pPC9iPjogJHt5QXhpcy5mb3JtYXREYXR1bShhZ2dyZWdhdGVkVmFsdWUpfTxicj5gIDogXCJcIjtcbiAgICBjb250ZW50ICs9IGA8Yj5GcmVxdWVuY3k8L2I+OiAke2ZyZXF1ZW5jeX1gO1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgdGl0bGUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgY29udGVudFxuICAgIH07XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChkZWZhdWx0cywge1xuICAgICAgZGF0dW06IHtcbiAgICAgICAgZGF0YTogbm9kZURhdHVtLmRhdHVtLFxuICAgICAgICBhZ2dyZWdhdGVkVmFsdWU6IG5vZGVEYXR1bS5hZ2dyZWdhdGVkVmFsdWUsXG4gICAgICAgIGRvbWFpbjogbm9kZURhdHVtLmRvbWFpbixcbiAgICAgICAgZnJlcXVlbmN5OiBub2RlRGF0dW0uZnJlcXVlbmN5XG4gICAgICB9LFxuICAgICAgaXRlbUlkLFxuICAgICAgeEtleSxcbiAgICAgIHhOYW1lLFxuICAgICAgeUtleSxcbiAgICAgIHlOYW1lLFxuICAgICAgY29sb3IsXG4gICAgICB0aXRsZSxcbiAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgfSk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5TmFtZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHhLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHlOYW1lID8/IHhLZXkgPz8gXCJGcmVxdWVuY3lcIlxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIGZpbGw6IGZpbGwgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uIH0pIHtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odHJ1ZSwgdGhpcy5heGVzLCBcIm5vcm1hbFwiKSk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiZGF0dW1zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIFtkYXR1bVNlbGVjdGlvbl0sIGZucyk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIGNvbnN0IGRhdGFEaWZmID0gdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmO1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbih0cnVlLCB0aGlzLmF4ZXMsIFwibm9ybWFsXCIpKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJkYXR1bXNcIixcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbZGF0YS5kYXR1bVNlbGVjdGlvbl0sXG4gICAgICBmbnMsXG4gICAgICAoXywgZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoZGF0dW0uZG9tYWluKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBkYXRhLmxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKHsgZGF0dW1JbmRleCwgc2VyaWVzUmVjdCB9KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVCYXJGb2N1c0JvdW5kcyh0aGlzLmNvbnRleHROb2RlRGF0YT8ubm9kZURhdGFbZGF0dW1JbmRleF0sIHRoaXMuY29udGVudEdyb3VwLCBzZXJpZXNSZWN0KTtcbiAgfVxufTtcbkhpc3RvZ3JhbVNlcmllcy5jbGFzc05hbWUgPSBcIkhpc3RvZ3JhbVNlcmllc1wiO1xuSGlzdG9ncmFtU2VyaWVzLnR5cGUgPSBcImhpc3RvZ3JhbVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2hpc3RvZ3JhbVNlcmllc01vZHVsZS50c1xudmFyIEhpc3RvZ3JhbVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImhpc3RvZ3JhbVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgSGlzdG9ncmFtU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICAgIGJsdXI6IDVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiAoeyB0YWtlQ29sb3JzIH0pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBmaWxsczogW2ZpbGxdLFxuICAgICAgc3Ryb2tlczogW3N0cm9rZV1cbiAgICB9ID0gdGFrZUNvbG9ycygxKTtcbiAgICByZXR1cm4geyBmaWxsLCBzdHJva2UgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lU2VyaWVzUHJvcGVydGllcy50c1xudmFyIExpbmVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnN0cm9rZSA9IFwiIzg3NDM0OVwiO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBuZXcgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMoKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICB0aGlzLmNvbm5lY3RNaXNzaW5nRGF0YSA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdGFja0dyb3VwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9ybWFsaXplZFRvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbnRlcnBvbGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb25uZWN0TWlzc2luZ0RhdGFcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVNlcmllcy50c1xudmFyIExpbmVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVCAqLyxcbiAgICAgICAgMyAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBwYXRoOiBidWlsZFJlc2V0UGF0aEZuKHsgZ2V0VmlzaWJsZTogKCkgPT4gdGhpcy52aXNpYmxlLCBnZXRPcGFjaXR5OiAoKSA9PiB0aGlzLmdldE9wYWNpdHkoKSB9KSxcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcbiAgICAgICAgbWFya2VyOiAobm9kZSwgZGF0dW0pID0+ICh7IC4uLnJlc2V0TWFya2VyRm4obm9kZSksIC4uLnJlc2V0TWFya2VyUG9zaXRpb25Gbihub2RlLCBkYXR1bSkgfSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgTGluZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEsIHZpc2libGUsIHNlcmllc0dyb3VwaW5nOiB7IGdyb3VwSW5kZXggPSB0aGlzLmlkLCBzdGFja0NvdW50ID0gMSB9ID0ge30gfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBjb25uZWN0TWlzc2luZ0RhdGEsIG5vcm1hbGl6ZWRUbyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb21tb24gPSB7IGludmFsaWRWYWx1ZTogbnVsbCB9O1xuICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIGNvbW1vbi5pbnZhbGlkVmFsdWUgPSAwO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNvbW1vbi5mb3JjZVZhbHVlID0gMDtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcbiAgICBpZiAoIWlzQ29udGludW91c1gpIHtcbiAgICAgIHByb3BzLnB1c2goa2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4S2V5XCIgfSkpO1xuICAgIH1cbiAgICBwcm9wcy5wdXNoKFxuICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhWYWx1ZVwiIH0pLFxuICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7XG4gICAgICAgIGlkOiBgeVZhbHVlUmF3YCxcbiAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICBpbnZhbGlkVmFsdWU6IHZvaWQgMFxuICAgICAgfSlcbiAgICApO1xuICAgIGlmIChzdGFja0NvdW50ID4gMSkge1xuICAgICAgY29uc3QgaWRzID0gW1xuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgLFxuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtdHJhaWxpbmdgLFxuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtbWFya2VyYFxuICAgICAgXTtcbiAgICAgIHByb3BzLnB1c2goXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93XCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWVFbmRgLFxuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgZ3JvdXBJZDogaWRzWzBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93LXRyYWlsaW5nXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWVTdGFydGAsXG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICBncm91cElkOiBpZHNbMV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZUN1bXVsYXRpdmVgLFxuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgZ3JvdXBJZDogaWRzWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWZpbmVkKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgICAgcHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKFtpZHNbMF0sIGlkc1sxXSwgaWRzWzJdXSwgbm9ybWFsaXplZFRvLCBcInJhbmdlXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIHByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbihpc0NvbnRpbnVvdXNYID8gW1wieFZhbHVlXCJdIDogdm9pZCAwKSk7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICAgIHByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7IHByb3BzIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBheGVzIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCB4RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgY29uc3QgZG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICAgIGlmICh4RGVmPy5kZWYudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIHhEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgICB9XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSwgeEF4aXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gdGhpcy5zZXJpZXNHcm91cGluZz8uc3RhY2tDb3VudCA/PyAxO1xuICAgICAgY29uc3QgZG9tYWluID0gc3RhY2tDb3VudCA+IDEgPyBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWVFbmRgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpIDogZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlUmF3YCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGRvbWFpbiwgeUF4aXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIG1hcmtlciwgbGFiZWwsIGNvbm5lY3RNaXNzaW5nRGF0YSwgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBzdGFja2VkID0gKHRoaXMuc2VyaWVzR3JvdXBpbmc/LnN0YWNrQ291bnQgPz8gMSkgPiAxO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgeU9mZnNldCA9ICh5U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIGNvbnN0IHNpemUgPSBtYXJrZXIuZW5hYmxlZCA/IG1hcmtlci5zaXplIDogMDtcbiAgICBjb25zdCB4SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVSYXdgKTtcbiAgICBjb25zdCB5Q3VtdWxhdGl2ZUlkeCA9IHN0YWNrZWQgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZUN1bXVsYXRpdmVgKSA6IHlJZHg7XG4gICAgY29uc3QgeUVuZElkeCA9IHN0YWNrZWQgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZUVuZGApIDogdm9pZCAwO1xuICAgIGxldCBtb3ZlVG8gPSB0cnVlO1xuICAgIHByb2Nlc3NlZERhdGEuZGF0YT8uZm9yRWFjaCgoeyBkYXR1bSwgdmFsdWVzIH0pID0+IHtcbiAgICAgIGNvbnN0IHhEYXR1bSA9IHZhbHVlc1t4SWR4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHZhbHVlc1t5SWR4XTtcbiAgICAgIGNvbnN0IHlDdW11bGF0aXZlRGF0dW0gPSB2YWx1ZXNbeUN1bXVsYXRpdmVJZHhdO1xuICAgICAgY29uc3QgeUVuZERhdHVtID0geUVuZElkeCAhPSBudWxsID8gdmFsdWVzW3lFbmRJZHhdIDogdm9pZCAwO1xuICAgICAgaWYgKHlEYXR1bSA9PSBudWxsKSB7XG4gICAgICAgIG1vdmVUbyB8fCAobW92ZVRvID0gIWNvbm5lY3RNaXNzaW5nRGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldDtcbiAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICBtb3ZlVG8gfHwgKG1vdmVUbyA9ICFjb25uZWN0TWlzc2luZ0RhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoeUN1bXVsYXRpdmVEYXR1bSkgKyB5T2Zmc2V0O1xuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoXG4gICAgICAgIGxhYmVsLFxuICAgICAgICB7IHZhbHVlOiB5RGF0dW0sIGRhdHVtLCB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGxlZ2VuZEl0ZW1OYW1lIH0sXG4gICAgICAgICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpID8gdmFsdWUudG9GaXhlZCgyKSA6IFN0cmluZyh2YWx1ZSlcbiAgICAgICk7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgbW92ZVRvLCBzaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RW5kRGF0dW0sXG4gICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgY2FwRGVmYXVsdHM6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpb011bHRpcGxpZXI6IHRoaXMucHJvcGVydGllcy5tYXJrZXIuZ2V0RGlhbWV0ZXIoKSxcbiAgICAgICAgICBsZW5ndGhNYXg6IEluZmluaXR5XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiBsYWJlbFRleHQgPyB7XG4gICAgICAgICAgdGV4dDogbGFiZWxUZXh0LFxuICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJib3R0b21cIixcbiAgICAgICAgICBmaWxsOiBsYWJlbC5jb2xvclxuICAgICAgICB9IDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIG1vdmVUbyA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRoTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhzOiBbbGluZU5vZGVdLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGUsXG4gICAgICBhbmltYXRpb25FbmFibGVkXG4gICAgfSA9IG9wdHM7XG4gICAgbGluZU5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICBmaWxsOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0XG4gICAgfSk7XG4gICAgaWYgKCFhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBsaW5lTm9kZS52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gICAgdXBkYXRlQ2xpcFBhdGgodGhpcywgbGluZU5vZGUpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgbGV0IHsgbm9kZURhdGEgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgeyBzaGFwZSwgZW5hYmxlZCB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBub2RlRGF0YSA9IHNoYXBlICYmIGVuYWJsZWQgPyBub2RlRGF0YSA6IFtdO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoZGF0dW0ueFZhbHVlKSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBtYXJrZXIsIGhpZ2hsaWdodFN0eWxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5XG4gICAgfSk7XG4gICAgY29uc3QgYXBwbHlUcmFuc2xhdGlvbiA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXkgfSwgYmFzZVN0eWxlLCB7IGFwcGx5VHJhbnNsYXRpb24gfSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgbWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMuaXNMYWJlbEVuYWJsZWQoKSA/IG9wdHMubGFiZWxEYXRhIDogW10pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHBvaW50LCBsYWJlbCB9ID0gZGF0dW07XG4gICAgICBpZiAoZGF0dW0gJiYgbGFiZWwgJiYgZW5hYmxlZCkge1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IGxhYmVsLnRleHRBbGlnbjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBsYWJlbC50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICAgIHRleHQueCA9IHBvaW50Lng7XG4gICAgICAgIHRleHQueSA9IHBvaW50LnkgLSAxMDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIHN0cm9rZVdpZHRoLCBtYXJrZXIsIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdHVtLCB4VmFsdWUsIHlWYWx1ZSwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeFN0cmluZyA9IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSk7XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwodGhpcy5wcm9wZXJ0aWVzLnRpdGxlID8/IHlOYW1lKTtcbiAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyBcIjogXCIgKyB5U3RyaW5nKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogbWFya2VyLnN0cm9rZSB9LCBtYXJrZXIuZ2V0U3R5bGUoKSwgeyBzdHJva2VXaWR0aCB9KTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogZmFsc2UgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgaWYgKCEodGhpcy5kYXRhPy5sZW5ndGggJiYgdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSAmJiBsZWdlbmRUeXBlID09PSBcImNhdGVnb3J5XCIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGgsIGxpbmVEYXNoLCB0aXRsZSwgbWFya2VyLCB2aXNpYmxlLCBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbG9yMCA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWUsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxlZ2VuZEl0ZW1OYW1lID8/IHRpdGxlID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZTogbWFya2VyLnNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiBtYXJrZXIuZmlsbCA/PyBjb2xvcjAsXG4gICAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSA/PyBzdHJva2UgPz8gY29sb3IwLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogbWFya2VyLmZpbGxPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IG1hcmtlci5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCA/PyAwLFxuICAgICAgICAgICAgICBlbmFibGVkOiBtYXJrZXIuZW5hYmxlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPz8gY29sb3IwLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgbGluZURhc2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhvcHRzLnBhdGhzLCBvcHRzLmNvbnRleHREYXRhKTtcbiAgfVxuICB1cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgY29uc3QgeyBpbnRlcnBvbGF0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBub2RlRGF0YSB9ID0gY29udGV4dERhdGE7XG4gICAgY29uc3QgW2xpbmVOb2RlXSA9IHBhdGhzO1xuICAgIGxpbmVOb2RlLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgZm9yIChjb25zdCByYW5nZTMgb2YgcGF0aFJhbmdlcyhub2RlRGF0YSkpIHtcbiAgICAgIHBsb3RQYXRoKHBhdGhSYW5nZVBvaW50cyhub2RlRGF0YSwgcmFuZ2UzKSwgbGluZU5vZGUsIGludGVycG9sYXRpb24pO1xuICAgIH1cbiAgICBsaW5lTm9kZS5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zLCBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHBhdGhTd2lwZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKTtcbiAgICByZXNldE1vdGlvbihbbWFya2VyU2VsZWN0aW9uXSwgcmVzZXRNYXJrZXJQb3NpdGlvbkZuKTtcbiAgICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHN1cGVyLmFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbjogbWFya2VyU2VsZWN0aW9ucyxcbiAgICAgIGxhYmVsU2VsZWN0aW9uOiBsYWJlbFNlbGVjdGlvbnMsXG4gICAgICBhbm5vdGF0aW9uU2VsZWN0aW9ucyxcbiAgICAgIGNvbnRleHREYXRhLFxuICAgICAgcGF0aHMsXG4gICAgICBwcmV2aW91c0NvbnRleHREYXRhXG4gICAgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgW3BhdGhdID0gcGF0aHM7XG4gICAgdGhpcy5yZXNldE1hcmtlckFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICB0aGlzLnJlc2V0TGFiZWxBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFBhdGhBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIH07XG4gICAgY29uc3Qgc2tpcCA9ICgpID0+IHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBpZiAoY29udGV4dERhdGEgPT0gbnVsbCB8fCBwcmV2aW91c0NvbnRleHREYXRhID09IG51bGwpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkZWRcIiwgbWFya2VyU2VsZWN0aW9ucyk7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwicGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkXCIsIHBhdGgpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24oXG4gICAgICBjb250ZXh0RGF0YSxcbiAgICAgIHByZXZpb3VzQ29udGV4dERhdGEsXG4gICAgICB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmYsXG4gICAgICB0aGlzLnByb3BlcnRpZXMuaW50ZXJwb2xhdGlvblxuICAgICk7XG4gICAgaWYgKGZucyA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmbnMuc3RhdHVzID09PSBcIm5vLW9wXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIHZvaWQgMCwgbWFya2VyU2VsZWN0aW9ucyk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwicGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtwYXRoXSwgZm5zLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBwYXRoTW90aW9uKHRoaXMuaWQsIFwicGF0aF91cGRhdGVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3BhdGhdLCBmbnMucGF0aCk7XG4gICAgaWYgKGZucy5oYXNNb3Rpb24pIHtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9ucyk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgICB9XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIGdldEJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHsgaW5uZXI6IDEsIG91dGVyOiAwLjEgfTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKCk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pIHtcbiAgICBjb25zdCB7IHhLZXksIHlLZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7IGRhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogdHJ1ZSB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5MaW5lU2VyaWVzLmNsYXNzTmFtZSA9IFwiTGluZVNlcmllc1wiO1xuTGluZVNlcmllcy50eXBlID0gXCJsaW5lXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVNlcmllc01vZHVsZS50c1xudmFyIExpbmVTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJsaW5lXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBMaW5lU2VyaWVzKGN0eCksXG4gIHN0YWNrYWJsZTogdHJ1ZSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcIm5lYXJlc3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgdG9vbHRpcDogeyBwb3NpdGlvbjogeyB0eXBlOiBcIm5vZGVcIiB9IH0sXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB1c2VycyBzaG91bGRuJ3Qgc3BlY2lmeSBhbGwgb3B0aW9ucywgYnV0IHdlIGhhdmUgdG8gZm9yIHRoZW1pbmcgdG8gd29ya1xuICAgICAgICB0ZW5zaW9uOiAxLFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIlxuICAgICAgfSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc2l6ZTogNyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBlcnJvckJhcjoge1xuICAgICAgICBjYXA6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpbzogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSBtYXJrZXJQYWxldHRlRmFjdG9yeShwYXJhbXMpO1xuICAgIHJldHVybiB7IHN0cm9rZTogbWFya2VyLmZpbGwsIG1hcmtlciB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgU2NhdHRlclNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcInRvcFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTEFCRUxfUExBQ0VNRU5UKVxuXSwgU2NhdHRlclNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgMik7XG52YXIgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3JSYW5nZSA9IFtcIiNmZmZmMDBcIiwgXCIjMDBmZjAwXCIsIFwiIzAwMDBmZlwiXTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IFNjYXR0ZXJTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgLy8gTm8gdmFsaWRhdGlvbi4gTm90IGEgcGFydCBvZiB0aGUgb3B0aW9ucyBjb250cmFjdC5cbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yRG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yUmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2hhcGVcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2l6ZVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsT3BhY2l0eVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVdpZHRoXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZU9wYWNpdHlcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5pdGVtU3R5bGVyXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhdHRlclNlcmllcy50c1xudmFyIFNjYXR0ZXJTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIE5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUICovLFxuICAgICAgICAzIC8qIE5FQVJFU1RfTk9ERSAqLyxcbiAgICAgICAgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICAgXSxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXSxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBtYXJrZXI6IHJlc2V0TWFya2VyRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLmNvbG9yU2NhbGUgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgY29sb3JTY2FsZVR5cGUgPSB0aGlzLmNvbG9yU2NhbGUudHlwZTtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5LCBjb2xvcktleSwgY29sb3JEb21haW4sIGNvbG9yUmFuZ2UgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCB0aGlzLmRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieEtleS1yYXdcIiB9KSxcbiAgICAgICAga2V5UHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogXCJ5S2V5LXJhd1wiIH0pLFxuICAgICAgICAuLi5sYWJlbEtleSA/IFtrZXlQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbEtleS1yYXdgIH0pXSA6IFtdLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IGB4VmFsdWVgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVgIH0pLFxuICAgICAgICAuLi5jb2xvcktleSA/IFt2YWx1ZVByb3BlcnR5KGNvbG9yS2V5LCBjb2xvclNjYWxlVHlwZSwgeyBpZDogYGNvbG9yVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICAuLi5sYWJlbEtleSA/IFt2YWx1ZVByb3BlcnR5KGxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGxhYmVsVmFsdWVgIH0pXSA6IFtdXG4gICAgICBdXG4gICAgfSk7XG4gICAgaWYgKGNvbG9yS2V5KSB7XG4gICAgICBjb25zdCBjb2xvcktleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLmRvbWFpbiA9IGNvbG9yRG9tYWluID8/IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tjb2xvcktleUlkeF0gPz8gW107XG4gICAgICB0aGlzLmNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBpZCA9IGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IGB4VmFsdWVgIDogYHlWYWx1ZWA7XG4gICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRhdGFEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgZGF0YURlZj8uZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gZG9tYWluO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGRvbWFpbiksIGF4aXMpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBjb2xvclNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIGNvbG9yS2V5LCB4TmFtZSwgeU5hbWUsIGxhYmVsTmFtZSwgbWFya2VyLCBsYWJlbCwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgcGxhY2VtZW50IH0gPSBsYWJlbDtcbiAgICBjb25zdCBtYXJrZXJTaGFwZSA9IGdldE1hcmtlcihtYXJrZXIuc2hhcGUpO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCEoZGF0YU1vZGVsICYmIHByb2Nlc3NlZERhdGEgJiYgdmlzaWJsZSAmJiB4QXhpcyAmJiB5QXhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeERhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IHlEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVgKTtcbiAgICBjb25zdCBjb2xvckRhdGFJZHggPSBjb2xvcktleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgbGFiZWxEYXRhSWR4ID0gbGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxhYmVsVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgeU9mZnNldCA9ICh5U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIGNvbnN0IGZvbnQgPSBsYWJlbC5nZXRGb250KCk7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgZm9yIChjb25zdCB7IHZhbHVlcywgZGF0dW0gfSBvZiBwcm9jZXNzZWREYXRhLmRhdGEgPz8gW10pIHtcbiAgICAgIGNvbnN0IHhEYXR1bSA9IHZhbHVlc1t4RGF0YUlkeF07XG4gICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeURhdGFJZHhdO1xuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSkgKyB5T2Zmc2V0O1xuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQobGFiZWwsIHtcbiAgICAgICAgdmFsdWU6IGxhYmVsS2V5ID8gdmFsdWVzW2xhYmVsRGF0YUlkeF0gOiB5RGF0dW0sXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBsYWJlbE5hbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dChsYWJlbFRleHQpO1xuICAgICAgY29uc3QgZmlsbCA9IGNvbG9yS2V5ID8gY29sb3JTY2FsZS5jb252ZXJ0KHZhbHVlc1tjb2xvckRhdGFJZHhdKSA6IHZvaWQgMDtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgY2FwRGVmYXVsdHM6IHsgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyOiBtYXJrZXIuZ2V0RGlhbWV0ZXIoKSwgbGVuZ3RoTWF4OiBJbmZpbml0eSB9LFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBtYXJrZXIuc2l6ZSB9LFxuICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXG4gICAgICAgIGZpbGwsXG4gICAgICAgIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCwgLi4uc2l6ZSB9LFxuICAgICAgICBtYXJrZXI6IG1hcmtlclNoYXBlLFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHROb2RlRGF0YT8ubGFiZWxEYXRhID8/IFtdO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgPyBub2RlRGF0YSA6IFtdKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5LCBtYXJrZXIsIGhpZ2hsaWdodFN0eWxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXksIGxhYmVsS2V5IH0sIGJhc2VTdHlsZSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgbWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgcGxhY2VkTGFiZWxzID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpID8gdGhpcy5jaGFydD8ucGxhY2VMYWJlbHMoKS5nZXQodGhpcykgPz8gW10gOiBbXTtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBwbGFjZWRMYWJlbHMubWFwKCh7IGRhdHVtLCB4LCB5IH0pID0+ICh7XG4gICAgICAgIC4uLmRhdHVtLFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBkYXR1bS5wb2ludC5zaXplIH0sXG4gICAgICAgIHBsYWNlbWVudDogXCJ0b3BcIlxuICAgICAgfSkpLFxuICAgICAgKHRleHQpID0+IHtcbiAgICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIHRleHQudGV4dCA9IGRhdHVtLmxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICAgIHRleHQueCA9IGRhdHVtLnBvaW50Py54ID8/IDA7XG4gICAgICB0ZXh0LnkgPSBkYXR1bS5wb2ludD8ueSA/PyAwO1xuICAgICAgdGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgICAgdGV4dC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgICAgdGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIHhOYW1lLCB5TmFtZSwgbGFiZWxOYW1lLCB0aXRsZSA9IHlOYW1lLCBtYXJrZXIsIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdHVtLCB4VmFsdWUsIHlWYWx1ZSwgbGFiZWwsIGl0ZW1JZCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICB7IGZpbGw6IG5vZGVEYXR1bS5maWxsLCBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChtYXJrZXIuc3Ryb2tlV2lkdGgpIH0sXG4gICAgICBtYXJrZXIuZ2V0U3R5bGUoKVxuICAgICk7XG4gICAgY29uc3QgeyBmaWxsOiBjb2xvciA9IFwiZ3JheVwiIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCBoaWdobGlnaHRlZDogZmFsc2UsIHhLZXksIHlLZXksIGxhYmVsS2V5IH0sXG4gICAgICBiYXNlU3R5bGVcbiAgICApO1xuICAgIGNvbnN0IHhTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHNhbml0aXplSHRtbCh5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpKTtcbiAgICBsZXQgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbCh4TmFtZSA/PyB4S2V5KX08L2I+OiAke3hTdHJpbmd9PGJyPjxiPiR7c2FuaXRpemVIdG1sKHlOYW1lID8/IHlLZXkpfTwvYj46ICR7eVN0cmluZ31gO1xuICAgIGlmIChsYWJlbEtleSkge1xuICAgICAgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbChsYWJlbE5hbWUgPz8gbGFiZWxLZXkpfTwvYj46ICR7c2FuaXRpemVIdG1sKGxhYmVsLnRleHQpfTxicj5gICsgY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgbGFiZWxOYW1lLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgdGl0bGUsIG1hcmtlciwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IG1hcmtlcjtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHRpdGxlID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZTogbWFya2VyLnNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiBtYXJrZXIuZmlsbCA/PyBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggPz8gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMgfSA9IGRhdGE7XG4gICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbih0aGlzLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHsgZGF0dW0sIHhLZXksIHlLZXksIGxhYmVsS2V5LCBoaWdobGlnaHRlZDogdHJ1ZSB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5TY2F0dGVyU2VyaWVzLmNsYXNzTmFtZSA9IFwiU2NhdHRlclNlcmllc1wiO1xuU2NhdHRlclNlcmllcy50eXBlID0gXCJzY2F0dGVyXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhdHRlclNlcmllc01vZHVsZS50c1xudmFyIFNjYXR0ZXJTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJzY2F0dGVyXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBTY2F0dGVyU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICBzaXplOiA3LFxuICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgZXJyb3JCYXI6IHtcbiAgICAgICAgY2FwOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW86IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zZWN0b3JCb3gudHNcbnZhciBTZWN0b3JCb3ggPSBjbGFzcyBfU2VjdG9yQm94IHtcbiAgY29uc3RydWN0b3Ioc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykge1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgdGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cztcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgX1NlY3RvckJveChzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKTtcbiAgfVxuICBbaW50ZXJwb2xhdGVdKG90aGVyLCBkKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VjdG9yQm94KFxuICAgICAgdGhpcy5zdGFydEFuZ2xlICogKDEgLSBkKSArIG90aGVyLnN0YXJ0QW5nbGUgKiBkLFxuICAgICAgdGhpcy5lbmRBbmdsZSAqICgxIC0gZCkgKyBvdGhlci5lbmRBbmdsZSAqIGQsXG4gICAgICB0aGlzLmlubmVyUmFkaXVzICogKDEgLSBkKSArIG90aGVyLmlubmVyUmFkaXVzICogZCxcbiAgICAgIHRoaXMub3V0ZXJSYWRpdXMgKiAoMSAtIGQpICsgb3RoZXIub3V0ZXJSYWRpdXMgKiBkXG4gICAgKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9zZWN0b3IudHNcbmZ1bmN0aW9uIHNlY3RvckJveCh7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSkge1xuICBsZXQgeDAgPSBJbmZpbml0eTtcbiAgbGV0IHkwID0gSW5maW5pdHk7XG4gIGxldCB4MSA9IC1JbmZpbml0eTtcbiAgbGV0IHkxID0gLUluZmluaXR5O1xuICBjb25zdCBhZGRQb2ludCA9ICh4LCB5KSA9PiB7XG4gICAgeDAgPSBNYXRoLm1pbih4LCB4MCk7XG4gICAgeTAgPSBNYXRoLm1pbih5LCB5MCk7XG4gICAgeDEgPSBNYXRoLm1heCh4LCB4MSk7XG4gICAgeTEgPSBNYXRoLm1heCh5LCB5MSk7XG4gIH07XG4gIGFkZFBvaW50KGlubmVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIGlubmVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICBhZGRQb2ludChpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICBhZGRQb2ludChvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcbiAgYWRkUG9pbnQob3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIG91dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcygwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludChvdXRlclJhZGl1cywgMCk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJICogMC41LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgwLCBvdXRlclJhZGl1cyk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgtb3V0ZXJSYWRpdXMsIDApO1xuICB9XG4gIGlmIChpc0JldHdlZW5BbmdsZXMoTWF0aC5QSSAqIDEuNSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgYWRkUG9pbnQoMCwgLW91dGVyUmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbmV3IEJCb3goeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3IpIHtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gc2VjdG9yO1xuICBpZiAoc2VjdG9yLnN0YXJ0QW5nbGUgPT09IHNlY3Rvci5lbmRBbmdsZSB8fCByYWRpdXMgPCBNYXRoLm1pbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHx8IHJhZGl1cyA+IE1hdGgubWF4KGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMTgwKHNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgY29uc3QgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZTE4MChzZWN0b3IuZW5kQW5nbGUpO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHksIHgpO1xuICByZXR1cm4gc3RhcnRBbmdsZSA8IGVuZEFuZ2xlID8gYW5nbGUyIDw9IGVuZEFuZ2xlICYmIGFuZ2xlMiA+PSBzdGFydEFuZ2xlIDogYW5nbGUyIDw9IGVuZEFuZ2xlICYmIGFuZ2xlMiA+PSAtTWF0aC5QSSB8fCBhbmdsZTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZTIgPD0gTWF0aC5QSTtcbn1cbmZ1bmN0aW9uIGxpbmVDb2xsaWRlc1NlY3RvcihsaW5lLCBzZWN0b3IpIHtcbiAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0b3I7XG4gIGNvbnN0IG91dGVyU3RhcnQgPSB7IHg6IG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkgfTtcbiAgY29uc3Qgb3V0ZXJFbmQgPSB7IHg6IG91dGVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBvdXRlclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xuICBjb25zdCBpbm5lclN0YXJ0ID0gaW5uZXJSYWRpdXMgPT09IDAgPyB7IHg6IDAsIHk6IDAgfSA6IHsgeDogaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSB9O1xuICBjb25zdCBpbm5lckVuZCA9IGlubmVyUmFkaXVzID09PSAwID8geyB4OiAwLCB5OiAwIH0gOiB7IHg6IGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xuICByZXR1cm4gc2VnbWVudEludGVyc2VjdGlvbihcbiAgICBsaW5lLnN0YXJ0LngsXG4gICAgbGluZS5zdGFydC55LFxuICAgIGxpbmUuZW5kLngsXG4gICAgbGluZS5lbmQueSxcbiAgICBvdXRlclN0YXJ0LngsXG4gICAgb3V0ZXJTdGFydC55LFxuICAgIGlubmVyU3RhcnQueCxcbiAgICBpbm5lclN0YXJ0LnlcbiAgKSB8fCBzZWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIGxpbmUuc3RhcnQueCxcbiAgICBsaW5lLnN0YXJ0LnksXG4gICAgbGluZS5lbmQueCxcbiAgICBsaW5lLmVuZC55LFxuICAgIG91dGVyRW5kLngsXG4gICAgb3V0ZXJFbmQueSxcbiAgICBpbm5lckVuZC54LFxuICAgIGlubmVyRW5kLnlcbiAgKSB8fCBhcmNJbnRlcnNlY3Rpb25zKFxuICAgIDAsXG4gICAgMCxcbiAgICBvdXRlclJhZGl1cyxcbiAgICBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlLFxuICAgIHRydWUsXG4gICAgbGluZS5zdGFydC54LFxuICAgIGxpbmUuc3RhcnQueSxcbiAgICBsaW5lLmVuZC54LFxuICAgIGxpbmUuZW5kLnlcbiAgKTtcbn1cbmZ1bmN0aW9uIGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSB7XG4gIGNvbnN0IHRvcExlZnQgPSB7IHg6IGJveC54LCB5OiBib3gueSB9O1xuICBjb25zdCB0b3BSaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH07XG4gIGNvbnN0IGJvdHRvbUxlZnQgPSB7IHg6IGJveC54LCB5OiBib3gueSArIGJveC5oZWlnaHQgfTtcbiAgY29uc3QgYm90dG9tUmlnaHQgPSB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSArIGJveC5oZWlnaHQgfTtcbiAgcmV0dXJuIGxpbmVDb2xsaWRlc1NlY3Rvcih7IHN0YXJ0OiB0b3BMZWZ0LCBlbmQ6IHRvcFJpZ2h0IH0sIHNlY3RvcikgfHwgbGluZUNvbGxpZGVzU2VjdG9yKHsgc3RhcnQ6IGJvdHRvbUxlZnQsIGVuZDogYm90dG9tUmlnaHQgfSwgc2VjdG9yKTtcbn1cbmZ1bmN0aW9uIHJhZGlpU2NhbGluZ0ZhY3RvcihyLCBzd2VlcCwgYSwgYikge1xuICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKVxuICAgIHJldHVybiAwO1xuICBjb25zdCBmczEgPSBNYXRoLmFzaW4oTWF0aC5hYnMoMSAqIGEpIC8gKHIgKyAxICogYSkpICsgTWF0aC5hc2luKE1hdGguYWJzKDEgKiBiKSAvIChyICsgMSAqIGIpKSAtIHN3ZWVwO1xuICBpZiAoZnMxIDwgMClcbiAgICByZXR1cm4gMTtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgY29uc3QgcyA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgIGNvbnN0IGZzID0gTWF0aC5hc2luKE1hdGguYWJzKHMgKiBhKSAvIChyICsgcyAqIGEpKSArIE1hdGguYXNpbihNYXRoLmFicyhzICogYikgLyAociArIHMgKiBiKSkgLSBzd2VlcDtcbiAgICBpZiAoZnMgPCAwKSB7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbnZhciBkZWx0YTIgPSAxZS02O1xuZnVuY3Rpb24gY2xvY2t3aXNlQW5nbGUoYW5nbGUyLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSkge1xuICBpZiAoYW5nbGVCZXR3ZWVuKGFuZ2xlMiwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpIDwgZGVsdGEyKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlVG9TdGFydEFuZ2xlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub3JtYWxpemVBbmdsZTM2MChhbmdsZTIgLSByZWxhdGl2ZVRvU3RhcnRBbmdsZSkgKyByZWxhdGl2ZVRvU3RhcnRBbmdsZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvY2t3aXNlQW5nbGVzKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSA9IDApIHtcbiAgY29uc3QgZnVsbFBpZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPj0gMiAqIE1hdGguUEk7XG4gIGNvbnN0IHN3ZWVwQW5nbGUgPSBmdWxsUGllID8gMiAqIE1hdGguUEkgOiBub3JtYWxpemVBbmdsZTM2MChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICBzdGFydEFuZ2xlID0gY2xvY2t3aXNlQW5nbGUoc3RhcnRBbmdsZSwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpO1xuICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlO1xuICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9O1xufVxuZnVuY3Rpb24gYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsaXBBbmdsZSkge1xuICBjb25zdCBzaW5BID0gTWF0aC5zaW4oY2xpcEFuZ2xlKTtcbiAgY29uc3QgY29zQSA9IE1hdGguY29zKGNsaXBBbmdsZSk7XG4gIGNvbnN0IGMgPSBjeCAqKiAyICsgY3kgKiogMiAtIHIgKiogMjtcbiAgbGV0IHAweCA9IE5hTjtcbiAgbGV0IHAweSA9IE5hTjtcbiAgbGV0IHAxeCA9IE5hTjtcbiAgbGV0IHAxeSA9IE5hTjtcbiAgaWYgKGNvc0EgPiAwLjUpIHtcbiAgICBjb25zdCB0YW5BID0gc2luQSAvIGNvc0E7XG4gICAgY29uc3QgYSA9IDEgKyB0YW5BICoqIDI7XG4gICAgY29uc3QgYiA9IC0yICogKGN4ICsgY3kgKiB0YW5BKTtcbiAgICBjb25zdCBkID0gYiAqKiAyIC0gNCAqIGEgKiBjO1xuICAgIGlmIChkIDwgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4MCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHgxID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvICgyICogYSk7XG4gICAgcDB4ID0geDA7XG4gICAgcDB5ID0geDAgKiB0YW5BO1xuICAgIHAxeCA9IHgxO1xuICAgIHAxeSA9IHgxICogdGFuQTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb3RBID0gY29zQSAvIHNpbkE7XG4gICAgY29uc3QgYSA9IDEgKyBjb3RBICoqIDI7XG4gICAgY29uc3QgYiA9IC0yICogKGN5ICsgY3ggKiBjb3RBKTtcbiAgICBjb25zdCBkID0gYiAqKiAyIC0gNCAqIGEgKiBjO1xuICAgIGlmIChkIDwgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5MCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHkxID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvICgyICogYSk7XG4gICAgcDB4ID0geTAgKiBjb3RBO1xuICAgIHAweSA9IHkwO1xuICAgIHAxeCA9IHkxICogY290QTtcbiAgICBwMXkgPSB5MTtcbiAgfVxuICBjb25zdCBub3JtYWxpc2VkWCA9IGNvc0E7XG4gIGNvbnN0IG5vcm1hbGlzZWRZID0gc2luQTtcbiAgY29uc3QgcDBEb3ROb3JtYWxpemVkID0gcDB4ICogbm9ybWFsaXNlZFggKyBwMHkgKiBub3JtYWxpc2VkWTtcbiAgY29uc3QgcDFEb3ROb3JtYWxpemVkID0gcDF4ICogbm9ybWFsaXNlZFggKyBwMXkgKiBub3JtYWxpc2VkWTtcbiAgY29uc3QgYTAgPSBwMERvdE5vcm1hbGl6ZWQgPiAwID8gY2xvY2t3aXNlQW5nbGUoTWF0aC5hdGFuMihwMHkgLSBjeSwgcDB4IC0gY3gpLCBzdGFydEFuZ2xlKSA6IE5hTjtcbiAgY29uc3QgYTEgPSBwMURvdE5vcm1hbGl6ZWQgPiAwID8gY2xvY2t3aXNlQW5nbGUoTWF0aC5hdGFuMihwMXkgLSBjeSwgcDF4IC0gY3gpLCBzdGFydEFuZ2xlKSA6IE5hTjtcbiAgaWYgKGEwID49IHN0YXJ0QW5nbGUgJiYgYTAgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTA7XG4gIH0gZWxzZSBpZiAoYTEgPj0gc3RhcnRBbmdsZSAmJiBhMSA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMTtcbiAgfVxufVxuZnVuY3Rpb24gYXJjQ2lyY2xlSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2lyY2xlUikge1xuICBjb25zdCBkID0gTWF0aC5oeXBvdChjeCwgY3kpO1xuICBjb25zdCBkMSA9IChkICoqIDIgLSByICoqIDIgKyBjaXJjbGVSICoqIDIpIC8gKDIgKiBkKTtcbiAgY29uc3QgZDIgPSBkIC0gZDE7XG4gIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihjeSwgY3gpO1xuICBjb25zdCBkZWx0YVRoZXRhID0gTWF0aC5hY29zKC1kMiAvIHIpO1xuICBjb25zdCBhMCA9IGNsb2Nrd2lzZUFuZ2xlKHRoZXRhICsgZGVsdGFUaGV0YSwgc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGExID0gY2xvY2t3aXNlQW5nbGUodGhldGEgLSBkZWx0YVRoZXRhLCBzdGFydEFuZ2xlKTtcbiAgaWYgKGEwID49IHN0YXJ0QW5nbGUgJiYgYTAgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTA7XG4gIH0gZWxzZSBpZiAoYTEgPj0gc3RhcnRBbmdsZSAmJiBhMSA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9zZWN0b3IudHNcbnZhciBBcmMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGN4LCBjeSwgciwgYTAsIGExKSB7XG4gICAgdGhpcy5jeCA9IGN4O1xuICAgIHRoaXMuY3kgPSBjeTtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuYTAgPSBhMDtcbiAgICB0aGlzLmExID0gYTE7XG4gICAgaWYgKHRoaXMuYTAgPj0gdGhpcy5hMSkge1xuICAgICAgdGhpcy5hMCA9IE5hTjtcbiAgICAgIHRoaXMuYTEgPSBOYU47XG4gICAgfVxuICB9XG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh0aGlzLmEwKSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5hMSk7XG4gIH1cbiAgcG9pbnRBdChhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMuY3ggKyB0aGlzLnIgKiBNYXRoLmNvcyhhKSxcbiAgICAgIHk6IHRoaXMuY3kgKyB0aGlzLnIgKiBNYXRoLnNpbihhKVxuICAgIH07XG4gIH1cbiAgY2xpcFN0YXJ0KGEpIHtcbiAgICBpZiAoYSA9PSBudWxsIHx8ICF0aGlzLmlzVmFsaWQoKSB8fCBhIDwgdGhpcy5hMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmEwID0gYTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGEpIHx8IHRoaXMuYTAgPj0gdGhpcy5hMSkge1xuICAgICAgdGhpcy5hMCA9IE5hTjtcbiAgICAgIHRoaXMuYTEgPSBOYU47XG4gICAgfVxuICB9XG4gIGNsaXBFbmQoYSkge1xuICAgIGlmIChhID09IG51bGwgfHwgIXRoaXMuaXNWYWxpZCgpIHx8IGEgPiB0aGlzLmExKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYTEgPSBhO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYSkgfHwgdGhpcy5hMCA+PSB0aGlzLmExKSB7XG4gICAgICB0aGlzLmEwID0gTmFOO1xuICAgICAgdGhpcy5hMSA9IE5hTjtcbiAgICB9XG4gIH1cbn07XG52YXIgU2VjdG9yID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IDEwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSAyMDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMjtcbiAgICB0aGlzLmNsaXBTZWN0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25jZW50cmljRWRnZUluc2V0ID0gMDtcbiAgICB0aGlzLnJhZGlhbEVkZ2VJbnNldCA9IDA7XG4gICAgdGhpcy5zdGFydE91dGVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmVuZE91dGVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuZW5kSW5uZXJDb3JuZXJSYWRpdXMgPSAwO1xuICB9XG4gIHNldCBpbnNldCh2YWx1ZSkge1xuICAgIHRoaXMuY29uY2VudHJpY0VkZ2VJbnNldCA9IHZhbHVlO1xuICAgIHRoaXMucmFkaWFsRWRnZUluc2V0ID0gdmFsdWU7XG4gIH1cbiAgc2V0IGNvcm5lclJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMuc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICAgIHRoaXMuZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgICB0aGlzLnN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgICB0aGlzLmVuZElubmVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIHNlY3RvckJveCh0aGlzKS50cmFuc2xhdGUodGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclkpO1xuICB9XG4gIG5vcm1hbGl6ZWRSYWRpaSgpIHtcbiAgICBjb25zdCB7IGNvbmNlbnRyaWNFZGdlSW5zZXQgfSA9IHRoaXM7XG4gICAgbGV0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzO1xuICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgPiAwID8gaW5uZXJSYWRpdXMgKyBjb25jZW50cmljRWRnZUluc2V0IDogMDtcbiAgICBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzIC0gY29uY2VudHJpY0VkZ2VJbnNldCwgMCk7XG4gICAgcmV0dXJuIHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gIH1cbiAgbm9ybWFsaXplZENsaXBTZWN0b3IoKSB7XG4gICAgY29uc3QgeyBjbGlwU2VjdG9yIH0gPSB0aGlzO1xuICAgIGlmIChjbGlwU2VjdG9yID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gY2xvY2t3aXNlQW5nbGVzKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcEFuZ2xlcyA9IGNsb2Nrd2lzZUFuZ2xlcyhjbGlwU2VjdG9yLnN0YXJ0QW5nbGUsIGNsaXBTZWN0b3IuZW5kQW5nbGUsIHN0YXJ0QW5nbGUpO1xuICAgIHJldHVybiBuZXcgU2VjdG9yQm94KFxuICAgICAgTWF0aC5tYXgoc3RhcnRBbmdsZSwgY2xpcEFuZ2xlcy5zdGFydEFuZ2xlKSxcbiAgICAgIE1hdGgubWluKGVuZEFuZ2xlLCBjbGlwQW5nbGVzLmVuZEFuZ2xlKSxcbiAgICAgIE1hdGgubWF4KGlubmVyUmFkaXVzLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKSxcbiAgICAgIE1hdGgubWluKG91dGVyUmFkaXVzLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKVxuICAgICk7XG4gIH1cbiAgZ2V0QW5nbGVPZmZzZXQocmFkaXVzKSB7XG4gICAgcmV0dXJuIHJhZGl1cyA+IDAgPyB0aGlzLnJhZGlhbEVkZ2VJbnNldCAvIHJhZGl1cyA6IDA7XG4gIH1cbiAgYXJjKHIsIGFuZ2xlU3dlZXAsIGEwLCBhMSwgb3V0ZXJBcmMsIGlubmVyQXJjLCBzdGFydCwgaW5uZXIpIHtcbiAgICBpZiAociA8PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlcyh0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUpO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLm5vcm1hbGl6ZWRSYWRpaSgpO1xuICAgIGNvbnN0IGNsaXBTZWN0b3IgPSB0aGlzLm5vcm1hbGl6ZWRDbGlwU2VjdG9yKCk7XG4gICAgaWYgKGlubmVyICYmIGlubmVyUmFkaXVzIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaW5uZXJBbmdsZU9mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQW5nbGVPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KG91dGVyUmFkaXVzKTtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IGlubmVyID8gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lclJhZGl1cyArIHIpIDogdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlclJhZGl1cyAtIHIpO1xuICAgIGNvbnN0IGFuZ2xlMiA9IHN0YXJ0ID8gc3RhcnRBbmdsZSArIGFuZ2xlT2Zmc2V0ICsgYW5nbGVTd2VlcCA6IGVuZEFuZ2xlIC0gYW5nbGVPZmZzZXQgLSBhbmdsZVN3ZWVwO1xuICAgIGNvbnN0IHJhZGl1cyA9IGlubmVyID8gaW5uZXJSYWRpdXMgKyByIDogb3V0ZXJSYWRpdXMgLSByO1xuICAgIGNvbnN0IGN4ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUyKTtcbiAgICBjb25zdCBjeSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlMik7XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZGVsdGEzID0gMWUtNjtcbiAgICAgIGlmICghc3RhcnQgJiYgIShhbmdsZTIgPj0gc3RhcnRBbmdsZSAtIGRlbHRhMyAmJiBhbmdsZTIgPD0gY2xpcFNlY3Rvci5lbmRBbmdsZSAtIGRlbHRhMykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChzdGFydCAmJiAhKGFuZ2xlMiA+PSBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUgKyBkZWx0YTMgJiYgYW5nbGUyIDw9IGVuZEFuZ2xlIC0gZGVsdGEzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGlubmVyICYmICEocmFkaXVzID49IGNsaXBTZWN0b3IuaW5uZXJSYWRpdXMgLSBkZWx0YTMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIWlubmVyICYmICEocmFkaXVzIDw9IGNsaXBTZWN0b3Iub3V0ZXJSYWRpdXMgKyBkZWx0YTMpKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFyYyA9IG5ldyBBcmMoY3gsIGN5LCByLCBhMCwgYTEpO1xuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lcikge1xuICAgICAgICBhcmMuY2xpcFN0YXJ0KFxuICAgICAgICAgIGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5lbmRBbmdsZSAtIGlubmVyQW5nbGVPZmZzZXQpXG4gICAgICAgICk7XG4gICAgICAgIGFyYy5jbGlwRW5kKFxuICAgICAgICAgIGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5zdGFydEFuZ2xlICsgaW5uZXJBbmdsZU9mZnNldClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyYy5jbGlwU3RhcnQoXG4gICAgICAgICAgYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUgKyBvdXRlckFuZ2xlT2Zmc2V0KVxuICAgICAgICApO1xuICAgICAgICBhcmMuY2xpcEVuZChhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3IuZW5kQW5nbGUgLSBvdXRlckFuZ2xlT2Zmc2V0KSk7XG4gICAgICB9XG4gICAgICBsZXQgY2lyY2xlQ2xpcFN0YXJ0O1xuICAgICAgbGV0IGNpcmNsZUNsaXBFbmQ7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgY2lyY2xlQ2xpcFN0YXJ0ID0gYXJjQ2lyY2xlSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3IuaW5uZXJSYWRpdXMpO1xuICAgICAgICBjaXJjbGVDbGlwRW5kID0gYXJjQ2lyY2xlSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3Iub3V0ZXJSYWRpdXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2lyY2xlQ2xpcFN0YXJ0ID0gYXJjQ2lyY2xlSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3Iub3V0ZXJSYWRpdXMpO1xuICAgICAgICBjaXJjbGVDbGlwRW5kID0gYXJjQ2lyY2xlSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3IuaW5uZXJSYWRpdXMpO1xuICAgICAgfVxuICAgICAgYXJjLmNsaXBTdGFydChjaXJjbGVDbGlwU3RhcnQpO1xuICAgICAgYXJjLmNsaXBFbmQoY2lyY2xlQ2xpcEVuZCk7XG4gICAgICBpZiAoY2lyY2xlQ2xpcFN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IGFyYy5wb2ludEF0KGNpcmNsZUNsaXBTdGFydCk7XG4gICAgICAgIGNvbnN0IHRoZXRhMiA9IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIoeTIsIHgyKSwgc3RhcnRBbmdsZSk7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIGlubmVyQXJjPy5jbGlwU3RhcnQodGhldGEyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRlckFyYy5jbGlwRW5kKHRoZXRhMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaXJjbGVDbGlwRW5kICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IGFyYy5wb2ludEF0KGNpcmNsZUNsaXBFbmQpO1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBjbG9ja3dpc2VBbmdsZShNYXRoLmF0YW4yKHkyLCB4MiksIHN0YXJ0QW5nbGUpO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBvdXRlckFyYy5jbGlwU3RhcnQodGhldGEyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbm5lckFyYz8uY2xpcEVuZCh0aGV0YTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdCgoYXJjLmEwICsgYXJjLmExKSAvIDIpO1xuICAgICAgaWYgKCFpc1BvaW50SW5TZWN0b3IoeDIsIHkyLCBjbGlwU2VjdG9yKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IGFyYy5wb2ludEF0KHN0YXJ0ID09PSBpbm5lciA/IGFyYy5hMCA6IGFyYy5hMSk7XG4gICAgY29uc3QgdGhldGEgPSBjbG9ja3dpc2VBbmdsZShNYXRoLmF0YW4yKHksIHgpLCBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCByYWRpYWxBcmMgPSBpbm5lciA/IGlubmVyQXJjIDogb3V0ZXJBcmM7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICByYWRpYWxBcmM/LmNsaXBTdGFydCh0aGV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZGlhbEFyYz8uY2xpcEVuZCh0aGV0YSk7XG4gICAgfVxuICAgIHJldHVybiBhcmM7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBkZWx0YTMgPSAxZS02O1xuICAgIGNvbnN0IHsgcGF0aCwgY2VudGVyWCwgY2VudGVyWSwgY29uY2VudHJpY0VkZ2VJbnNldCwgcmFkaWFsRWRnZUluc2V0IH0gPSB0aGlzO1xuICAgIGxldCB7IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsIGVuZE91dGVyQ29ybmVyUmFkaXVzLCBzdGFydElubmVyQ29ybmVyUmFkaXVzLCBlbmRJbm5lckNvcm5lclJhZGl1cyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBjbG9ja3dpc2VBbmdsZXModGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlKTtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5ub3JtYWxpemVkUmFkaWkoKTtcbiAgICBjb25zdCBjbGlwU2VjdG9yID0gdGhpcy5ub3JtYWxpemVkQ2xpcFNlY3RvcigpO1xuICAgIGNvbnN0IHN3ZWVwQW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgY29uc3QgZnVsbFBpZSA9IHN3ZWVwQW5nbGUgPj0gMiAqIE1hdGguUEkgLSBkZWx0YTM7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGlmIChpbm5lclJhZGl1cyA9PT0gMCAmJiBvdXRlclJhZGl1cyA9PT0gMCB8fCBpbm5lclJhZGl1cyA+IG91dGVyUmFkaXVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICgoY2xpcFNlY3Rvcj8uc3RhcnRBbmdsZSA/PyBzdGFydEFuZ2xlKSA9PT0gKGNsaXBTZWN0b3I/LmVuZEFuZ2xlID8/IGVuZEFuZ2xlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZnVsbFBpZSAmJiB0aGlzLmNsaXBTZWN0b3IgPT0gbnVsbCAmJiBzdGFydE91dGVyQ29ybmVyUmFkaXVzID09PSAwICYmIGVuZE91dGVyQ29ybmVyUmFkaXVzID09PSAwICYmIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgPT09IDAgJiYgZW5kSW5uZXJDb3JuZXJSYWRpdXMgPT09IDApIHtcbiAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBjZW50ZXJZICsgb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSk7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgaWYgKGlubmVyUmFkaXVzID4gY29uY2VudHJpY0VkZ2VJbnNldCkge1xuICAgICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIGNlbnRlclkgKyBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSk7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jbGlwU2VjdG9yID09IG51bGwgJiYgTWF0aC5hYnMoaW5uZXJSYWRpdXMgLSBvdXRlclJhZGl1cykgPCAxZS02KSB7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGZhbHNlKTtcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbm5lckFuZ2xlT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lclJhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBbmdsZU9mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQW5nbGVFeGNlZWRlZCA9IHN3ZWVwQW5nbGUgPCAyICogb3V0ZXJBbmdsZU9mZnNldDtcbiAgICBpZiAob3V0ZXJBbmdsZUV4Y2VlZGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGhhc0lubmVyU3dlZXAgPSAoY2xpcFNlY3Rvcj8uaW5uZXJSYWRpdXMgPz8gaW5uZXJSYWRpdXMpID4gY29uY2VudHJpY0VkZ2VJbnNldDtcbiAgICBjb25zdCBpbm5lckFuZ2xlRXhjZWVkZWQgPSBpbm5lclJhZGl1cyA8IGNvbmNlbnRyaWNFZGdlSW5zZXQgfHwgc3dlZXBBbmdsZSA8IDIgKiBpbm5lckFuZ2xlT2Zmc2V0O1xuICAgIGNvbnN0IHJhZGlhbExlbmd0aCA9IG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXM7XG4gICAgY29uc3QgbWF4UmFkaWFsTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGNvbnN0IGluaXRpYWxTY2FsaW5nRmFjdG9yID0gbWF4UmFkaWFsTGVuZ3RoID4gMCA/IE1hdGgubWluKHJhZGlhbExlbmd0aCAvIG1heFJhZGlhbExlbmd0aCwgMSkgOiAxO1xuICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRJbm5lckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBjb25zdCBvdXRlclNjYWxpbmdGYWN0b3IgPSByYWRpaVNjYWxpbmdGYWN0b3IoXG4gICAgICBvdXRlclJhZGl1cyxcbiAgICAgIHN3ZWVwQW5nbGUgLSAyICogb3V0ZXJBbmdsZU9mZnNldCxcbiAgICAgIC1zdGFydE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgLWVuZE91dGVyQ29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICo9IG91dGVyU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRPdXRlckNvcm5lclJhZGl1cyAqPSBvdXRlclNjYWxpbmdGYWN0b3I7XG4gICAgaWYgKCFpbm5lckFuZ2xlRXhjZWVkZWQgJiYgaGFzSW5uZXJTd2VlcCkge1xuICAgICAgY29uc3QgaW5uZXJTY2FsaW5nRmFjdG9yID0gcmFkaWlTY2FsaW5nRmFjdG9yKFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgc3dlZXBBbmdsZSAtIDIgKiBpbm5lckFuZ2xlT2Zmc2V0LFxuICAgICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgICBlbmRJbm5lckNvcm5lclJhZGl1c1xuICAgICAgKTtcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5uZXJTY2FsaW5nRmFjdG9yO1xuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5uZXJTY2FsaW5nRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB9XG4gICAgY29uc3QgbWF4Q29tYmluZWRSYWRpYWxMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKyBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKyBlbmRJbm5lckNvcm5lclJhZGl1c1xuICAgICk7XG4gICAgY29uc3QgZWRnZXNTY2FsaW5nRmFjdG9yID0gbWF4Q29tYmluZWRSYWRpYWxMZW5ndGggPiAwID8gTWF0aC5taW4ocmFkaWFsTGVuZ3RoIC8gbWF4Q29tYmluZWRSYWRpYWxMZW5ndGgsIDEpIDogMTtcbiAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRPdXRlckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIGxldCBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IDA7XG4gICAgbGV0IGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IDA7XG4gICAgY29uc3Qgc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID0gc3RhcnRPdXRlckNvcm5lclJhZGl1cyAvIChvdXRlclJhZGl1cyAtIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPSBlbmRPdXRlckNvcm5lclJhZGl1cyAvIChvdXRlclJhZGl1cyAtIGVuZE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICBpZiAoc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID49IDAgJiYgc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwIDwgMSAtIGRlbHRhMykge1xuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBzd2VlcEFuZ2xlIC8gMjtcbiAgICAgIGNvbnN0IG1heFN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAvICgxIC8gTWF0aC5zaW4oc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXApICsgMSk7XG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzID0gTWF0aC5taW4obWF4U3RhcnRPdXRlckNvcm5lclJhZGl1cywgc3RhcnRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgfVxuICAgIGlmIChlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID49IDAgJiYgZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA8IDEgLSBkZWx0YTMpIHtcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gc3dlZXBBbmdsZSAvIDI7XG4gICAgICBjb25zdCBtYXhFbmRPdXRlckNvcm5lclJhZGl1cyA9IG91dGVyUmFkaXVzIC8gKDEgLyBNYXRoLnNpbihlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXApICsgMSk7XG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyA9IE1hdGgubWluKG1heEVuZE91dGVyQ29ybmVyUmFkaXVzLCBlbmRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAvIChpbm5lclJhZGl1cyArIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMpXG4gICAgKTtcbiAgICBjb25zdCBlbmRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oZW5kSW5uZXJDb3JuZXJSYWRpdXMgLyAoaW5uZXJSYWRpdXMgKyBlbmRJbm5lckNvcm5lclJhZGl1cykpO1xuICAgIGNvbnN0IG91dGVyQXJjUmFkaXVzID0gY2xpcFNlY3Rvcj8ub3V0ZXJSYWRpdXMgPz8gb3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJBcmNSYWRpdXNPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KG91dGVyQXJjUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFyYyA9IG5ldyBBcmMoXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG91dGVyQXJjUmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSArIG91dGVyQXJjUmFkaXVzT2Zmc2V0LFxuICAgICAgZW5kQW5nbGUgLSBvdXRlckFyY1JhZGl1c09mZnNldFxuICAgICk7XG4gICAgY29uc3QgaW5uZXJBcmNSYWRpdXMgPSBjbGlwU2VjdG9yPy5pbm5lclJhZGl1cyA/PyBpbm5lclJhZGl1cztcbiAgICBjb25zdCBpbm5lckFyY1JhZGl1c09mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJBcmNSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyQXJjID0gaGFzSW5uZXJTd2VlcCA/IG5ldyBBcmMoMCwgMCwgaW5uZXJBcmNSYWRpdXMsIHN0YXJ0QW5nbGUgKyBpbm5lckFyY1JhZGl1c09mZnNldCwgZW5kQW5nbGUgLSBpbm5lckFyY1JhZGl1c09mZnNldCkgOiB2b2lkIDA7XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgb3V0ZXJBcmMuY2xpcFN0YXJ0KGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSk7XG4gICAgICBvdXRlckFyYy5jbGlwRW5kKGNsaXBTZWN0b3IuZW5kQW5nbGUpO1xuICAgICAgaW5uZXJBcmM/LmNsaXBTdGFydChjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpO1xuICAgICAgaW5uZXJBcmM/LmNsaXBFbmQoY2xpcFNlY3Rvci5lbmRBbmdsZSk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0T3V0ZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIHN0YXJ0QW5nbGUgLSBNYXRoLlBJICogMC41LFxuICAgICAgc3RhcnRBbmdsZSArIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIHRydWUsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgZW5kT3V0ZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgZW5kQW5nbGUgLSBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBlbmRBbmdsZSArIE1hdGguUEkgKiAwLjUsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgZW5kSW5uZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgZW5kQW5nbGUgKyBNYXRoLlBJICogMC41LFxuICAgICAgZW5kQW5nbGUgKyBNYXRoLlBJIC0gZW5kSW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIGZhbHNlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3Qgc3RhcnRJbm5lckFyYyA9IHRoaXMuYXJjKFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgc3RhcnRBbmdsZSArIE1hdGguUEkgKyBzdGFydElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIHN0YXJ0QW5nbGUgKyBNYXRoLlBJICogMS41LFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIHRydWUsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoaW5uZXJBbmdsZUV4Y2VlZGVkKSB7XG4gICAgICBjb25zdCB4ID0gc3dlZXBBbmdsZSA8IE1hdGguUEkgKiAwLjUgPyByYWRpYWxFZGdlSW5zZXQgKiAoMSArIE1hdGguY29zKHN3ZWVwQW5nbGUpKSAvIE1hdGguc2luKHN3ZWVwQW5nbGUpIDogTmFOO1xuICAgICAgbGV0IHI7XG4gICAgICBpZiAoeCA+IDAgJiYgeCA8IG91dGVyUmFkaXVzKSB7XG4gICAgICAgIHIgPSBNYXRoLm1heChNYXRoLmh5cG90KHJhZGlhbEVkZ2VJbnNldCwgeCksIGlubmVyUmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSByYWRpYWxFZGdlSW5zZXQ7XG4gICAgICB9XG4gICAgICByID0gTWF0aC5tYXgociwgaW5uZXJSYWRpdXMpO1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZSAqIDAuNTtcbiAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyByICogTWF0aC5jb3MobWlkQW5nbGUpLCBjZW50ZXJZICsgciAqIE1hdGguc2luKG1pZEFuZ2xlKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydElubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUgfHwgaW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlIC8gMjtcbiAgICAgIGNvbnN0IGN4ID0gaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhtaWRBbmdsZSk7XG4gICAgICBjb25zdCBjeSA9IGlubmVyUmFkaXVzICogTWF0aC5zaW4obWlkQW5nbGUpO1xuICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3kpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRPdXRlckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBzdGFydE91dGVyQXJjO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgfVxuICAgIGlmIChvdXRlckFyYy5pc1ZhbGlkKCkpIHtcbiAgICAgIGNvbnN0IHsgciwgYTAsIGExIH0gPSBvdXRlckFyYztcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIHIsIGEwLCBhMSk7XG4gICAgfVxuICAgIGlmIChlbmRPdXRlckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBlbmRPdXRlckFyYztcbiAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgIH1cbiAgICBpZiAoIWlubmVyQW5nbGVFeGNlZWRlZCkge1xuICAgICAgaWYgKGVuZElubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gZW5kSW5uZXJBcmM7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyByLCBhMCwgYTEgfSA9IGlubmVyQXJjO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByLCBhMSwgYTAsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0SW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBzdGFydElubmVyQXJjO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLmNsaXBTZWN0b3IgPz8gdGhpcztcbiAgICByZXR1cm4gaXNQb2ludEluU2VjdG9yKHBvaW50LnggLSB0aGlzLmNlbnRlclgsIHBvaW50LnkgLSB0aGlzLmNlbnRlclksIHtcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1pbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpLFxuICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cylcbiAgICB9KTtcbiAgfVxufTtcblNlY3Rvci5jbGFzc05hbWUgPSBcIlNlY3RvclwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNlbnRlcllcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2xpcFNlY3RvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNvbmNlbnRyaWNFZGdlSW5zZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJyYWRpYWxFZGdlSW5zZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydE91dGVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiZW5kT3V0ZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydElubmVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiZW5kSW5uZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9kZWZhdWx0Q29sb3JzLnRzXG52YXIgREVGQVVMVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIE9SQU5HRTogXCIjZmZhMDNhXCIsXG4gIEdSRUVOOiBcIiM0NTlkNTVcIixcbiAgQ1lBTjogXCIjMzRiZmUxXCIsXG4gIFlFTExPVzogXCIjZTFjYzAwXCIsXG4gIFZJT0xFVDogXCIjOTY2OWNiXCIsXG4gIEdSQVk6IFwiI2I1YjViNVwiLFxuICBNQUdFTlRBOiBcIiNiZDVhYTdcIixcbiAgQlJPV046IFwiIzhhNjIyNFwiLFxuICBSRUQ6IFwiI2VmNTQ1MlwiXG59O1xudmFyIERFRkFVTFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMmI1Yzk1XCIsXG4gIE9SQU5HRTogXCIjY2M2ZjEwXCIsXG4gIEdSRUVOOiBcIiMxZTY1MmVcIixcbiAgQ1lBTjogXCIjMTg4NTllXCIsXG4gIFlFTExPVzogXCIjYTY5NDAwXCIsXG4gIFZJT0xFVDogXCIjNjAzYzg4XCIsXG4gIEdSQVk6IFwiIzU3NTc1N1wiLFxuICBNQUdFTlRBOiBcIiM3ZDJmNmRcIixcbiAgQlJPV046IFwiIzRmMzUwOFwiLFxuICBSRUQ6IFwiI2E4MjUyOVwiXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgRG9udXRUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQ2FwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBEb251dFRpdGxlLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgMik7XG52YXIgRG9udXRJbm5lckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zcGFjaW5nID0gMjtcbiAgfVxuICBzZXQocHJvcGVydGllcywgX3Jlc2V0KSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldChwcm9wZXJ0aWVzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIERvbnV0SW5uZXJMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0SW5uZXJMYWJlbC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbnZhciBEb251dElubmVyQ2lyY2xlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgRG9udXRJbm5lckNpcmNsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRJbm5lckNpcmNsZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG52YXIgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm9mZnNldCA9IDM7XG4gICAgdGhpcy5taW5BbmdsZSA9IDA7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gNDtcbiAgICB0aGlzLm1heENvbGxpc2lvbk9mZnNldCA9IDUwO1xuICAgIHRoaXMuYXZvaWRDb2xsaXNpb25zID0gdHJ1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtYXhDb2xsaXNpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcImF2b2lkQ29sbGlzaW9uc1wiLCAyKTtcbnZhciBEb251dFNlcmllc1NlY3RvckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgdGhpcy5wb3NpdGlvblJhdGlvID0gMC41O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uUmF0aW9cIiwgMik7XG52YXIgRG9udXRTZXJpZXNDYWxsb3V0TGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGVuZ3RoID0gMTA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImNvbG9yc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xudmFyIERvbnV0U2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxscyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9GSUxMUyk7XG4gICAgdGhpcy5zdHJva2VzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c09mZnNldCA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c1JhdGlvID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnNlY3RvclNwYWNpbmcgPSAwO1xuICAgIHRoaXMuaW5uZXJMYWJlbHMgPSBuZXcgUHJvcGVydGllc0FycmF5KERvbnV0SW5uZXJMYWJlbCk7XG4gICAgdGhpcy50aXRsZSA9IG5ldyBEb251dFRpdGxlKCk7XG4gICAgdGhpcy5pbm5lckNpcmNsZSA9IG5ldyBEb251dElubmVyQ2lyY2xlKCk7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsID0gbmV3IERvbnV0U2VyaWVzQ2FsbG91dExhYmVsKCk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbCA9IG5ldyBEb251dFNlcmllc1NlY3RvckxhYmVsKCk7XG4gICAgdGhpcy5jYWxsb3V0TGluZSA9IG5ldyBEb251dFNlcmllc0NhbGxvdXRMaW5lKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxuICBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IHN1cGVySXNWYWxpZCA9IHN1cGVyLmlzVmFsaWQoKTtcbiAgICBpZiAodGhpcy5pbm5lclJhZGl1c1JhdGlvID09IG51bGwgJiYgdGhpcy5pbm5lclJhZGl1c09mZnNldCA9PSBudWxsKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIFwiRWl0aGVyIGFuIFtpbm5lclJhZGl1c1JhdGlvXSBvciBhbiBbaW5uZXJSYWRpdXNPZmZzZXRdIG11c3QgYmUgc2V0IHRvIHJlbmRlciBhIGRvbnV0IHNlcmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVySXNWYWxpZDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlRmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c0tleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNYXhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1LZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzUmF0aW9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1JhdGlvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVF9BUlJBWSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJMYWJlbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lckNpcmNsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVV0aWwudHNcbmZ1bmN0aW9uIHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoaW5pdGlhbExvYWQsIHJvdGF0aW9uRGVncmVlcywgc2NhbGVGbiwgb2xkU2NhbGVGbikge1xuICBjb25zdCBzY2FsZTIgPSBbc2NhbGVGbi5jb252ZXJ0KDApLCBzY2FsZUZuLmNvbnZlcnQoMSldO1xuICBjb25zdCBvbGRTY2FsZSA9IFtvbGRTY2FsZUZuLmNvbnZlcnQoMCksIG9sZFNjYWxlRm4uY29udmVydCgxKV07XG4gIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5QSSAvIC0yICsgdG9SYWRpYW5zKHJvdGF0aW9uRGVncmVlcyk7XG4gIGNvbnN0IHBoYXNlID0gaW5pdGlhbExvYWQgPyBcImluaXRpYWxcIiA6IFwidXBkYXRlXCI7XG4gIGNvbnN0IHNjYWxlVG9OZXdSYWRpdXMgPSAoeyByYWRpdXMgfSkgPT4ge1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzOiBzY2FsZTJbMF0sIG91dGVyUmFkaXVzOiBzY2FsZTJbMF0gKyAoc2NhbGUyWzFdIC0gc2NhbGUyWzBdKSAqIHJhZGl1cyB9O1xuICB9O1xuICBjb25zdCBzY2FsZVRvT2xkUmFkaXVzID0gKHsgcmFkaXVzIH0pID0+IHtcbiAgICByZXR1cm4geyBpbm5lclJhZGl1czogb2xkU2NhbGVbMF0sIG91dGVyUmFkaXVzOiBvbGRTY2FsZVswXSArIChvbGRTY2FsZVsxXSAtIG9sZFNjYWxlWzBdKSAqIHJhZGl1cyB9O1xuICB9O1xuICBjb25zdCBmcm9tRm4gPSAoc2VjdCwgZGF0dW0sIHN0YXR1cywgeyBwcmV2RnJvbVByb3BzIH0pID0+IHtcbiAgICBsZXQgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0O1xuICAgIGxldCB7IGZpbGwsIHN0cm9rZSB9ID0gZGF0dW0uc2VjdG9yRm9ybWF0O1xuICAgIGlmIChzdGF0dXMgPT09IFwidW5rbm93blwiIHx8IHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmICFwcmV2RnJvbVByb3BzKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgICBlbmRBbmdsZSA9IHJvdGF0aW9uO1xuICAgICAgaW5uZXJSYWRpdXMgPSBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXM7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiBwcmV2RnJvbVByb3BzKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcHJldkZyb21Qcm9wcy5lbmRBbmdsZSA/PyByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcHJldkZyb21Qcm9wcy5lbmRBbmdsZSA/PyByb3RhdGlvbjtcbiAgICAgIGlubmVyUmFkaXVzID0gcHJldkZyb21Qcm9wcy5pbm5lclJhZGl1cyA/PyBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcHJldkZyb21Qcm9wcy5vdXRlclJhZGl1cyA/PyBkYXR1bS5vdXRlclJhZGl1cztcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmICFpbml0aWFsTG9hZCkge1xuICAgICAgY29uc3QgcmFkaWkgPSBzY2FsZVRvT2xkUmFkaXVzKGRhdHVtKTtcbiAgICAgIGlubmVyUmFkaXVzID0gcmFkaWkuaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IHJhZGlpLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIikge1xuICAgICAgZmlsbCA9IHNlY3QuZmlsbCA/PyBmaWxsO1xuICAgICAgc3Ryb2tlID0gc2VjdC5zdHJva2UgPz8gc3Ryb2tlO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBmaWxsLCBzdHJva2UsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoX3NlY3QsIGRhdHVtLCBzdGF0dXMsIHsgcHJldkxpdmUgfSkgPT4ge1xuICAgIGxldCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHsgc3Ryb2tlLCBmaWxsIH0gPSBkYXR1bS5zZWN0b3JGb3JtYXQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgcHJldkxpdmUpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSBwcmV2TGl2ZS5kYXR1bT8uZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IHByZXZMaXZlLmRhdHVtPy5lbmRBbmdsZTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgIXByZXZMaXZlKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgICBlbmRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgY29uc3QgcmFkaWkgPSBzY2FsZVRvTmV3UmFkaXVzKGRhdHVtKTtcbiAgICAgIGlubmVyUmFkaXVzID0gcmFkaWkuaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IHJhZGlpLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBzdHJva2UsIGZpbGwgfTtcbiAgfTtcbiAgY29uc3QgaW5uZXJDaXJjbGVGcm9tRm4gPSAobm9kZSwgXykgPT4ge1xuICAgIHJldHVybiB7IHNpemU6IG5vZGUucHJldmlvdXNEYXR1bT8ucmFkaXVzID8/IG5vZGUuc2l6ZSA/PyAwLCBwaGFzZSB9O1xuICB9O1xuICBjb25zdCBpbm5lckNpcmNsZVRvRm4gPSAoXywgZGF0dW0pID0+IHtcbiAgICByZXR1cm4geyBzaXplOiBkYXR1bS5yYWRpdXMgPz8gMCB9O1xuICB9O1xuICByZXR1cm4geyBub2RlczogeyB0b0ZuLCBmcm9tRm4gfSwgaW5uZXJDaXJjbGU6IHsgZnJvbUZuOiBpbm5lckNpcmNsZUZyb21GbiwgdG9GbjogaW5uZXJDaXJjbGVUb0ZuIH0gfTtcbn1cbmZ1bmN0aW9uIHJlc2V0UGllU2VsZWN0aW9uc0ZuKF9ub2RlLCBkYXR1bSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0QW5nbGU6IGRhdHVtLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGRhdHVtLmVuZEFuZ2xlLFxuICAgIGlubmVyUmFkaXVzOiBkYXR1bS5pbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1czogZGF0dW0ub3V0ZXJSYWRpdXMsXG4gICAgZmlsbDogZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgc3Ryb2tlOiBkYXR1bS5zZWN0b3JGb3JtYXQuc3Ryb2tlXG4gIH07XG59XG5mdW5jdGlvbiBwaWNrQnlNYXRjaGluZ0FuZ2xlKHNlcmllcywgcG9pbnQpIHtcbiAgY29uc3QgZHkgPSBwb2ludC55IC0gc2VyaWVzLmNlbnRlclk7XG4gIGNvbnN0IGR4ID0gcG9pbnQueCAtIHNlcmllcy5jZW50ZXJYO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gIGNvbnN0IHNlY3RvcnMgPSBzZXJpZXMuZ2V0SXRlbU5vZGVzKCk7XG4gIGZvciAoY29uc3Qgc2VjdG9yIG9mIHNlY3RvcnMpIHtcbiAgICBpZiAoc2VjdG9yLmRhdHVtLm1pc3NpbmcgPT09IHRydWUpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNCZXR3ZWVuQW5nbGVzKGFuZ2xlMiwgc2VjdG9yLnN0YXJ0QW5nbGUsIHNlY3Rvci5lbmRBbmdsZSkpIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBsZXQgZGlzdGFuY2UzID0gMDtcbiAgICAgIGlmIChyYWRpdXMgPCBzZWN0b3IuaW5uZXJSYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UzID0gc2VjdG9yLmlubmVyUmFkaXVzIC0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmIChyYWRpdXMgPiBzZWN0b3Iub3V0ZXJSYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UzID0gcmFkaXVzIC0gc2VjdG9yLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0dW06IHNlY3Rvci5kYXR1bSwgZGlzdGFuY2U6IGRpc3RhbmNlMyB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcG9sYXJTZXJpZXMudHNcbnZhciBQb2xhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgRGF0YU1vZGVsU2VyaWVzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVzZUxhYmVsTGF5ZXIgPSBmYWxzZSxcbiAgICBwaWNrTW9kZXMgPSBbMyAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgIGNhbkhhdmVBeGVzID0gZmFsc2UsXG4gICAgYW5pbWF0aW9uUmVzZXRGbnMsXG4gICAgLi4ub3B0c1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIHVzZUxhYmVsTGF5ZXIsXG4gICAgICBwaWNrTW9kZXMsXG4gICAgICBjb250ZW50R3JvdXBWaXJ0dWFsOiBmYWxzZSxcbiAgICAgIGRpcmVjdGlvbktleXM6IHtcbiAgICAgICAgW1wieFwiIC8qIFggKi9dOiBbXCJhbmdsZUtleVwiXSxcbiAgICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXCJyYWRpdXNLZXlcIl1cbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb25OYW1lczoge1xuICAgICAgICBbXCJ4XCIgLyogWCAqL106IFtcImFuZ2xlTmFtZVwiXSxcbiAgICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXCJyYWRpdXNOYW1lXCJdXG4gICAgICB9LFxuICAgICAgY2FuSGF2ZUF4ZXNcbiAgICB9KTtcbiAgICB0aGlzLml0ZW1Hcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLm5vZGVEYXRhID0gW107XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaXRlbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5sYWJlbEdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5sYWJlbEZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwsXG4gICAgICAoKSA9PiB0aGlzLmxhYmVsRmFjdG9yeSgpXG4gICAgKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIHRoZSBwb2xhciBzZXJpZXMgKGZvciBleGFtcGxlLCB0aGUgY2VudGVyIG9mIGEgcGllKS5cbiAgICAgKiBJZiB0aGUgcG9sYXIgY2hhcnQgaGFzIG11bHRpcGxlIHNlcmllcywgYWxsIG9mIHRoZW0gd2lsbCBoYXZlIHRoZWlyXG4gICAgICogY2VudGVyIHNldCB0byB0aGUgc2FtZSB2YWx1ZSBhcyBhIHJlc3VsdCBvZiB0aGUgcG9sYXIgY2hhcnQgbGF5b3V0LlxuICAgICAqIFRoZSBjZW50ZXIgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3NlZCB0byBiZSBzZXQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHJhZGl1cyB0aGUgc2VyaWVzIGNhbiB1c2UuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBzZXQgYXV0b21hdGljYWxseSBhcyBhIHJlc3VsdCBvZiB0aGUgcG9sYXIgY2hhcnQgbGF5b3V0XG4gICAgICogYW5kIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzZXQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgIHRoaXMuaXRlbUdyb3VwLnpJbmRleFN1Yk9yZGVyID0gWygpID0+IHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIsIDFdO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPSBhbmltYXRpb25SZXNldEZucztcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcbiAgICAgIFwiZW1wdHlcIixcbiAgICAgIHtcbiAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdGluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgZ2V0SXRlbU5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1Hcm91cC5jaGlsZHJlbjtcbiAgfVxuICBnZXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlRGF0YTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9XG4gIH1cbiAgbGFiZWxGYWN0b3J5KCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBnZXRJbm5lclJhZGl1cygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc2V0QWxsQW5pbWF0aW9uKCkge1xuICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmxhYmVsU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChfZGF0YSkge1xuICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKF9kYXRhKSB7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKF9kYXRhKSB7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJjbGVhclwiLCB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKSk7XG4gIH1cbiAgZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0KSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzUmVjdCB9O1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldE5vZGVEYXRhKCk/LltvcHRzLmRhdHVtSW5kZXhdO1xuICAgIGlmIChkYXR1bSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtU2VsZWN0aW9uLnNlbGVjdCgobm9kZSkgPT4gbm9kZSBpbnN0YW5jZW9mIFBhdGggJiYgbm9kZS5kYXR1bSA9PT0gZGF0dW0pWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXMudHNcbnZhciBEb251dFNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5hbmdsZUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5O1xuICAgIHRoaXMucmFkaXVzS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMucmFkaXVzS2V5O1xuICAgIHRoaXMuY2FsbG91dExhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5O1xuICAgIHRoaXMuc2VjdG9yTGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleTtcbiAgfVxufTtcbnZhciBEb251dFNlcmllcyA9IGNsYXNzIGV4dGVuZHMgUG9sYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFszIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICB1c2VMYWJlbExheWVyOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHsgaXRlbTogcmVzZXRQaWVTZWxlY3Rpb25zRm4sIGxhYmVsOiByZXNldExhYmVsRm4gfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBEb251dFNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5waGFudG9tR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoKSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMucGhhbnRvbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcInBpZUNhbGxvdXRMYWJlbHNcIiB9KSk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKFxuICAgICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCxcbiAgICAgIEdyb3VwXG4gICAgKTtcbiAgICAvLyBUaGUgZ3JvdXAgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBiYWNrZ3JvdW5kIGdyYXBoaWNzLlxuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwID0gdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1iYWNrZ3JvdW5kYCxcbiAgICAgICAgbGF5ZXI6IHRydWUsXG4gICAgICAgIHpJbmRleDogMCAvKiBTRVJJRVNfQkFDS0dST1VORF9aSU5ERVggKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICAvLyBBRy02MTkzIElmIHRoZSBzdW0gb2YgYWxsIGRhdHVtcyBpcyAwLCB0aGVuIHdlJ2xsIGRyYXcgMSBvciAyIHJpbmdzIHRvIHJlcHJlc2VudCB0aGUgZW1wdHkgc2VyaWVzLlxuICAgIHRoaXMuemVyb3N1bVJpbmdzR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS16ZXJvc3VtUmluZ3NgIH0pKTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBDaXJjbGUoKSk7XG4gICAgdGhpcy56ZXJvc3VtSW5uZXJSaW5nID0gdGhpcy56ZXJvc3VtUmluZ3NHcm91cC5hcHBlbmRDaGlsZChuZXcgQ2lyY2xlKCkpO1xuICAgIHRoaXMuaW5uZXJMYWJlbHNHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwiaW5uZXJMYWJlbHNcIiB9KSk7XG4gICAgdGhpcy5pbm5lckNpcmNsZUdyb3VwID0gdGhpcy5iYWNrZ3JvdW5kR3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0taW5uZXJDaXJjbGVgIH0pKTtcbiAgICB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmlubmVyTGFiZWxzR3JvdXAsIFRleHQpO1xuICAgIHRoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5pbm5lckNpcmNsZUdyb3VwLFxuICAgICAgQ2lyY2xlXG4gICAgKTtcbiAgICAvLyBXaGVuIGEgdXNlciB0b2dnbGVzIGEgc2VyaWVzIGl0ZW0gKGUuZy4gZnJvbSB0aGUgbGVnZW5kKSwgaXRzIGJvb2xlYW4gc3RhdGUgaXMgcmVjb3JkZWQgaGVyZS5cbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkID0gW107XG4gICAgdGhpcy5zdXJyb3VuZGluZ1JhZGl1cyA9IHZvaWQgMDtcbiAgICB0aGlzLk5vZGVFdmVudCA9IERvbnV0U2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuYW5nbGVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5hbmdsZVNjYWxlLnJhbmdlID0gWy1NYXRoLlBJLCBNYXRoLlBJXS5tYXAoKGFuZ2xlMikgPT4gYW5nbGUyICsgTWF0aC5QSSAvIDIpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwLm9wYWNpdHkgPSAwLjI7XG4gICAgdGhpcy5waGFudG9tR3JvdXAuekluZGV4U3ViT3JkZXIgPSBbKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciwgMF07XG4gIH1cbiAgZ2V0IGNhbGxvdXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5waGFudG9tTm9kZURhdGEgPz8gdGhpcy5ub2RlRGF0YTtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXI/LmFkZExpc3RlbmVyKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSlcbiAgICApO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiBzdXBlci52aXNpYmxlICYmICh0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLnNvbWUoKHZpc2libGUpID0+IHZpc2libGUpKTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFNlY3RvcigpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZVNjYWxlLmRvbWFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmFkaXVzU2NhbGUuZG9tYWluO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgYW5nbGVGaWx0ZXJLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCBleHRyYUtleVByb3BzID0gW107XG4gICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsS2V5YCB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1c1NjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBjb25zdCBhbmdsZVNjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBpZiAocmFkaXVzS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIHJhbmdlZFZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCB7XG4gICAgICAgICAgaWQ6IFwicmFkaXVzVmFsdWVcIixcbiAgICAgICAgICBtaW46IHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCxcbiAgICAgICAgICBtYXg6IHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXhcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCByYWRpdXNTY2FsZVR5cGUsIHsgaWQ6IGByYWRpdXNSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwicmFkaXVzVmFsdWVcIiwgWzAsIDFdLCAxLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXgpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1WYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoYW5nbGVGaWx0ZXJLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYGFuZ2xlRmlsdGVyVmFsdWVgLFxuICAgICAgICAgIG9ubHlQb3NpdGl2ZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZUZpbHRlclJhd2AgfSksXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZUZpbHRlclZhbHVlXCIsIFswLCAxXSwgMCwgMClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YSAmJiBleHRyYUtleVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICBkYXRhID0gZGF0YS5tYXAoKGQsIGlkeCkgPT4gdmlzaWJsZSAmJiBzZXJpZXNJdGVtRW5hYmxlZFtpZHhdID8gZCA6IHsgLi4uZCwgW2FuZ2xlS2V5XTogMCB9KTtcbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIC4uLmV4dHJhS2V5UHJvcHMsXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVWYWx1ZWAsIG9ubHlQb3NpdGl2ZTogdHJ1ZSB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVJhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZVZhbHVlXCIsIFswLCAxXSwgMCwgMCksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlRGVmIG9mIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGVmcz8udmFsdWVzID8/IFtdKSB7XG4gICAgICBjb25zdCB7IGlkLCBtaXNzaW5nLCBwcm9wZXJ0eSB9ID0gdmFsdWVEZWY7XG4gICAgICBjb25zdCBtaXNzQ291bnQgPSBnZXRNaXNzQ291bnQodGhpcywgbWlzc2luZyk7XG4gICAgICBpZiAoaWQgIT09IFwiYW5nbGVSYXdcIiAmJiBtaXNzQ291bnQgPiAwKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgbm8gdmFsdWUgd2FzIGZvdW5kIGZvciB0aGUga2V5ICcke1N0cmluZyhwcm9wZXJ0eSl9JyBvbiAke21pc3NDb3VudH0gZGF0YSBlbGVtZW50JHttaXNzQ291bnQgPiAxID8gXCJzXCIgOiBcIlwifWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBhc3luYyBtYXliZVJlZnJlc2hOb2RlRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZURhdGEgPSBbXSwgcGhhbnRvbU5vZGVEYXRhIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCkgPz8ge307XG4gICAgdGhpcy5ub2RlRGF0YSA9IG5vZGVEYXRhO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gcGhhbnRvbU5vZGVEYXRhO1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gIH1cbiAgZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKSB7XG4gICAgY29uc3QgYW5nbGVJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlVmFsdWVgKTtcbiAgICBjb25zdCBhbmdsZVJhd0lkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVSYXdgKTtcbiAgICBjb25zdCBhbmdsZUZpbHRlcklkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c1Jhd0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1Jhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNhbGxvdXRMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNlY3RvckxhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH07XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYW5nbGVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uLCBpbm5lclJhZGl1c1JhdGlvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4geyBpdGVtSWQ6IHNlcmllc0lkLCBub2RlRGF0YTogW10sIGxhYmVsRGF0YTogW10gfTtcbiAgICB9XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS50eXBlICE9PSBcInVuZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB1c2VGaWx0ZXJBbmdsZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmIHByb2Nlc3NlZERhdGEuZGF0YS5zb21lKCh7IHZhbHVlcyB9KSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSA+IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgfSk7XG4gICAgbGV0IGN1cnJlbnRTdGFydCA9IDA7XG4gICAgbGV0IHN1bTIgPSAwO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcGhhbnRvbU5vZGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCA/IFtdIDogdm9pZCAwO1xuICAgIHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKChncm91cCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gZ3JvdXA7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB1c2VGaWx0ZXJBbmdsZXMgPyB2YWx1ZXNbYW5nbGVGaWx0ZXJJZHhdIDogdmFsdWVzW2FuZ2xlSWR4XTtcbiAgICAgIGNvbnN0IGNyb3NzRmlsdGVyU2NhbGUgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmICF1c2VGaWx0ZXJBbmdsZXMgPyBNYXRoLnNxcnQodmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSAvIHZhbHVlc1thbmdsZVJhd0lkeF0pIDogMTtcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjdXJyZW50U3RhcnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzdW0yICs9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIGNvbnN0IGVuZEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY29uc3Qgc3BhbiA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzcGFuIC8gMjtcbiAgICAgIGNvbnN0IGFuZ2xlVmFsdWUgPSB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgICAgY29uc3QgcmFkaXVzUmF3ID0gcmFkaXVzSWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzSWR4XSA/PyAxIDogMTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1JhdyAqIGNyb3NzRmlsdGVyU2NhbGU7XG4gICAgICBjb25zdCByYWRpdXNWYWx1ZSA9IHJhZGl1c1Jhd0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c1Jhd0lkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBsZWdlbmRJdGVtVmFsdWUgPSBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBub2RlTGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgc3BhbixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBtaWRDb3M6IE1hdGguY29zKG1pZEFuZ2xlKSxcbiAgICAgICAgbWlkU2luOiBNYXRoLnNpbihtaWRBbmdsZSksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICByYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KHJhZGl1cyksIDApLFxuICAgICAgICBzZWN0b3JGb3JtYXQsXG4gICAgICAgIHJhZGl1c1ZhbHVlLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWUsXG4gICAgICAgIGVuYWJsZWQ6IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICAgIC4uLm5vZGVMYWJlbHNcbiAgICAgIH07XG4gICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKHBoYW50b21Ob2RlcyAhPSBudWxsKSB7XG4gICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDEpLCAwKSxcbiAgICAgICAgICBmb2N1c2FibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMDtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcudmlzaWJsZSA9IHN1bTIgPT09IDAgJiYgaW5uZXJSYWRpdXNSYXRpbyAhPSBudWxsICYmIGlubmVyUmFkaXVzUmF0aW8gIT09IDEgJiYgaW5uZXJSYWRpdXNSYXRpbyA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogc2VyaWVzSWQsXG4gICAgICBub2RlRGF0YTogbm9kZXMsXG4gICAgICBsYWJlbERhdGE6IG5vZGVzLFxuICAgICAgcGhhbnRvbU5vZGVEYXRhOiBwaGFudG9tTm9kZXNcbiAgICB9O1xuICB9XG4gIGdldExhYmVscyhkYXR1bSwgbWlkQW5nbGUsIHNwYW4sIHNraXBEaXNhYmxlZCwgY2FsbG91dExhYmVsVmFsdWUsIHNlY3RvckxhYmVsVmFsdWUsIGxlZ2VuZEl0ZW1WYWx1ZSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBzZWN0b3JMYWJlbCwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgY2FsbG91dExhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5IDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBzZWN0b3JMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5IDogdm9pZCAwO1xuICAgIGlmICghY2FsbG91dExhYmVsS2V5ICYmICFzZWN0b3JMYWJlbEtleSAmJiAhbGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgc3BhbiA+IHRvUmFkaWFucyhjYWxsb3V0TGFiZWwubWluQW5nbGUpKSB7XG4gICAgICByZXN1bHQuY2FsbG91dExhYmVsID0ge1xuICAgICAgICAuLi50aGlzLmdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChjYWxsb3V0TGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogY2FsbG91dExhYmVsVmFsdWVcbiAgICAgICAgfSksXG4gICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgIGNvbGxpc2lvblRleHRBbGlnbjogdm9pZCAwLFxuICAgICAgICBjb2xsaXNpb25PZmZzZXRZOiAwLFxuICAgICAgICBib3g6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXN1bHQuc2VjdG9yTGFiZWwgPSB7XG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KHNlY3RvckxhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IHNlY3RvckxhYmVsVmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5ICE9IG51bGwgJiYgbGVnZW5kSXRlbVZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5sZWdlbmRJdGVtID0geyBrZXk6IGxlZ2VuZEl0ZW1LZXksIHRleHQ6IGxlZ2VuZEl0ZW1WYWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpIHtcbiAgICBjb25zdCBxdWFkcmFudFRleHRPcHRzID0gW1xuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJib3R0b21cIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwibGVmdFwiLCB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiaGFuZ2luZ1wiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJyaWdodFwiLCB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIgfVxuICAgIF07XG4gICAgY29uc3QgbWlkQW5nbGUxODAgPSBub3JtYWxpemVBbmdsZTE4MChtaWRBbmdsZSk7XG4gICAgY29uc3QgcXVhZHJhbnRTdGFydCA9IC0wLjc1ICogTWF0aC5QSTtcbiAgICBjb25zdCBxdWFkcmFudE9mZnNldCA9IG1pZEFuZ2xlMTgwIC0gcXVhZHJhbnRTdGFydDtcbiAgICBjb25zdCBxdWFkcmFudCA9IE1hdGguZmxvb3IocXVhZHJhbnRPZmZzZXQgLyAoTWF0aC5QSSAvIDIpKTtcbiAgICBjb25zdCBxdWFkcmFudEluZGV4ID0gbW9kKHF1YWRyYW50LCBxdWFkcmFudFRleHRPcHRzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHF1YWRyYW50VGV4dE9wdHNbcXVhZHJhbnRJbmRleF07XG4gIH1cbiAgZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBmb3JtYXRJbmRleCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrQ2FjaGUgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSwgZmlsbHMsIHN0cm9rZXMsIGl0ZW1TdHlsZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBkZWZhdWx0U3Ryb2tlID0gc3Ryb2tlc1tmb3JtYXRJbmRleCAlIHN0cm9rZXMubGVuZ3RoXTtcbiAgICBjb25zdCB7IGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGNvcm5lclJhZGl1cyB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAge1xuICAgICAgICBmaWxsOiBmaWxscy5sZW5ndGggPiAwID8gZmlsbHNbZm9ybWF0SW5kZXggJSBmaWxscy5sZW5ndGhdIDogdm9pZCAwLFxuICAgICAgICBzdHJva2U6IGRlZmF1bHRTdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpXG4gICAgICB9LFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzXG4gICAgKTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmIChpdGVtU3R5bGVyKSB7XG4gICAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgYW5nbGVLZXksXG4gICAgICAgIHJhZGl1c0tleSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgICAgbGVnZW5kSXRlbUtleSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICBoaWdobGlnaHRlZCxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogZm9ybWF0Py5zdHJva2UgPz8gc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGZvcm1hdD8uc3Ryb2tlV2lkdGggPz8gc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5OiBmb3JtYXQ/LnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBmb3JtYXQ/LmxpbmVEYXNoID8/IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGZvcm1hdD8ubGluZURhc2hPZmZzZXQgPz8gbGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXM6IGZvcm1hdD8uY29ybmVyUmFkaXVzID8/IGNvcm5lclJhZGl1c1xuICAgIH07XG4gIH1cbiAgZ2V0SW5uZXJSYWRpdXMoKSB7XG4gICAgY29uc3QgeyByYWRpdXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1c1JhdGlvID0gMSwgaW5uZXJSYWRpdXNPZmZzZXQgPSAwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgKiBpbm5lclJhZGl1c1JhdGlvICsgaW5uZXJSYWRpdXNPZmZzZXQ7XG4gICAgaWYgKGlubmVyUmFkaXVzID09PSByYWRpdXMgfHwgaW5uZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGlubmVyUmFkaXVzO1xuICB9XG4gIGdldE91dGVyUmFkaXVzKCkge1xuICAgIGNvbnN0IHsgb3V0ZXJSYWRpdXNSYXRpbywgb3V0ZXJSYWRpdXNPZmZzZXQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yYWRpdXMgKiBvdXRlclJhZGl1c1JhdGlvICsgb3V0ZXJSYWRpdXNPZmZzZXQsIDApO1xuICB9XG4gIHVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSkge1xuICAgIGNvbnN0IG5ld1JhbmdlID0gW3RoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgdGhpcy5nZXRPdXRlclJhZGl1cygpXTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IHNldFJhZGlpID0gKGQpID0+ICh7XG4gICAgICAuLi5kLFxuICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KGQucmFkaXVzKSwgMClcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoc2V0UmFkaWkpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdGhpcy5waGFudG9tTm9kZURhdGE/Lm1hcChzZXRSYWRpaSk7XG4gIH1cbiAgZ2V0VGl0bGVUcmFuc2xhdGlvblkoKSB7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlWzFdKTtcbiAgICBpZiAob3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNwYWNpbmcgPz8gMDtcbiAgICBjb25zdCB0aXRsZU9mZnNldCA9IDIgKyBzcGFjaW5nO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5tYXgoMCwgLW91dGVyUmFkaXVzKTtcbiAgICByZXR1cm4gLW91dGVyUmFkaXVzIC0gdGl0bGVPZmZzZXQgLSBkeTtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMgPSB7XG4gICAgICBzZXJpZXNSZWN0V2lkdGg6IHNlcmllc1JlY3Q/LndpZHRoLFxuICAgICAgc2VyaWVzUmVjdEhlaWdodDogc2VyaWVzUmVjdD8uaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCByZXNpemUgPSBqc29uRGlmZih0aGlzLm5vZGVEYXRhRGVwZW5kZW5jaWVzLCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcykgIT0gbnVsbDtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB9XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIGNvbnN0IHRpdGxlQm94ID0gdGl0bGUubm9kZS5nZXRCQm94KCk7XG4gICAgICB0aXRsZS5ub2RlLnZpc2libGUgPSB0aXRsZS5lbmFibGVkICYmIGlzRmluaXRlKGR5KSAmJiAhdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKHRpdGxlQm94LCAwLCBkeSk7XG4gICAgICB0aXRsZS5ub2RlLnRyYW5zbGF0aW9uWSA9IGlzRmluaXRlKGR5KSA/IGR5IDogMDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaXJjbGUgb2YgW3RoaXMuemVyb3N1bUlubmVyUmluZywgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nXSkge1xuICAgICAgY2lyY2xlLmZpbGxPcGFjaXR5ID0gMDtcbiAgICAgIGNpcmNsZS5zdHJva2UgPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLmNvbG9yO1xuICAgICAgY2lyY2xlLnN0cm9rZVdpZHRoID0gMTtcbiAgICAgIGNpcmNsZS5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVOb2RlTWlkUG9pbnQoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpO1xuICB9XG4gIHVwZGF0ZVRpdGxlTm9kZXMoKSB7XG4gICAgY29uc3QgeyBvbGRUaXRsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKG9sZFRpdGxlICE9PSB0aXRsZSkge1xuICAgICAgaWYgKG9sZFRpdGxlKSB7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8ucmVtb3ZlQ2hpbGQob2xkVGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgdGl0bGUubm9kZS50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LmFwcGVuZENoaWxkKHRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbGRUaXRsZSA9IHRpdGxlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOb2RlTWlkUG9pbnQoKSB7XG4gICAgY29uc3Qgc2V0TWlkUG9pbnQgPSAoZCkgPT4ge1xuICAgICAgY29uc3QgcmFkaXVzID0gZC5pbm5lclJhZGl1cyArIChkLm91dGVyUmFkaXVzIC0gZC5pbm5lclJhZGl1cykgLyAyO1xuICAgICAgZC5taWRQb2ludCA9IHtcbiAgICAgICAgeDogZC5taWRDb3MgKiBNYXRoLm1heCgwLCByYWRpdXMpLFxuICAgICAgICB5OiBkLm1pZFNpbiAqIE1hdGgubWF4KDAsIHJhZGl1cylcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vZGVEYXRhLmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhPy5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZWxlY3Rpb25zKCkge1xuICAgIGF3YWl0IHRoaXMudXBkYXRlR3JvdXBTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUlubmVyQ2lyY2xlU2VsZWN0aW9uKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlR3JvdXBTZWxlY3Rpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXRlbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgIHBoYW50b21TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGxhYmVsU2VsZWN0aW9uLFxuICAgICAgaW5uZXJMYWJlbHNTZWxlY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBoaWdobGlnaHRlZE5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoKGRhdHVtKSA9PiAoe1xuICAgICAgLi4uZGF0dW0sXG4gICAgICAvLyBBbGxvdyBtdXRhYmxlIHNlY3RvckZvcm1hdCwgc28gZm9ybWF0dGVkIHNlY3RvciBzdHlsZXMgY2FuIGJlIHVwZGF0ZWQgYW5kIHZhcmllZFxuICAgICAgLy8gYmV0d2VlbiBub3JtYWwgYW5kIGhpZ2hsaWdodGVkIGNhc2VzLlxuICAgICAgc2VjdG9yRm9ybWF0OiB7IC4uLmRhdHVtLnNlY3RvckZvcm1hdCB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IChzZWxlY3Rpb24sIG5vZGVEYXRhKSA9PiB7XG4gICAgICBzZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSk7XG4gICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlKGl0ZW1TZWxlY3Rpb24sIHRoaXMubm9kZURhdGEpO1xuICAgIHVwZGF0ZShoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICAgIHVwZGF0ZShwaGFudG9tU2VsZWN0aW9uLCB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyBbXSk7XG4gICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLmNhbGxvdXROb2RlRGF0YSwgKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgIGxpbmUudGFnID0gMCAvKiBDYWxsb3V0ICovO1xuICAgICAgbGluZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICAgIHRleHQudGFnID0gMSAvKiBMYWJlbCAqLztcbiAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH0pO1xuICAgIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLm5vZGVEYXRhKTtcbiAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbi51cGRhdGUoaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gICAgaW5uZXJMYWJlbHNTZWxlY3Rpb24udXBkYXRlKHRoaXMucHJvcGVydGllcy5pbm5lckxhYmVscywgKG5vZGUpID0+IHtcbiAgICAgIG5vZGUucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVJbm5lckNpcmNsZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IGlubmVyQ2lyY2xlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgbGV0IHJhZGl1cyA9IDA7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLmdldElubmVyUmFkaXVzKCk7XG4gICAgaWYgKGlubmVyUmFkaXVzID4gMCkge1xuICAgICAgY29uc3QgY2lyY2xlUmFkaXVzID0gTWF0aC5taW4oaW5uZXJSYWRpdXMsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSk7XG4gICAgICBjb25zdCBhbnRpQWxpYXNpbmdQYWRkaW5nID0gMTtcbiAgICAgIHJhZGl1cyA9IE1hdGguY2VpbChjaXJjbGVSYWRpdXMgKiAyICsgYW50aUFsaWFzaW5nUGFkZGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdHVtcyA9IGlubmVyQ2lyY2xlID8gW3sgcmFkaXVzIH1dIDogW107XG4gICAgdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbi51cGRhdGUoZGF0dW1zKTtcbiAgfVxuICBhc3luYyB1cGRhdGVOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuaW5kZXhPZih0cnVlKSA+PSAwO1xuICAgIHRoaXMucm9vdEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbC52aXNpYmxlID0gaXNWaXNpYmxlICYmIGhpZ2hsaWdodGVkRGF0dW0/LnNlcmllcyA9PT0gdGhpcztcbiAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50R3JvdXAub3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb24uZWFjaCgobm9kZSwgeyByYWRpdXMgfSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgZmlsbDogdGhpcy5wcm9wZXJ0aWVzLmlubmVyQ2lyY2xlPy5maWxsLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuaW5uZXJDaXJjbGU/LmZpbGxPcGFjaXR5LFxuICAgICAgICBzaXplOiByYWRpdXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRpc2FibGVkID0gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JGbiA9IChzZWN0b3IsIGRhdHVtLCBfaW5kZXgsIGlzRGF0dW1IaWdobGlnaHRlZCkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0uZGF0dW0sIGRhdHVtLml0ZW1JZCwgaXNEYXR1bUhpZ2hsaWdodGVkKTtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5maWxsID0gZm9ybWF0LmZpbGw7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIGlmIChhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3Iuc3RhcnRBbmdsZSA9IGRhdHVtLnN0YXJ0QW5nbGU7XG4gICAgICAgIHNlY3Rvci5lbmRBbmdsZSA9IGRhdHVtLmVuZEFuZ2xlO1xuICAgICAgICBzZWN0b3IuaW5uZXJSYWRpdXMgPSBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgICAgc2VjdG9yLm91dGVyUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNEYXR1bUhpZ2hsaWdodGVkIHx8IGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5maWxsID0gZm9ybWF0LmZpbGw7XG4gICAgICAgIHNlY3Rvci5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgfVxuICAgICAgc2VjdG9yLnN0cm9rZVdpZHRoID0gZm9ybWF0LnN0cm9rZVdpZHRoO1xuICAgICAgc2VjdG9yLmZpbGxPcGFjaXR5ID0gZm9ybWF0LmZpbGxPcGFjaXR5O1xuICAgICAgc2VjdG9yLnN0cm9rZU9wYWNpdHkgPSBmb3JtYXQuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5saW5lRGFzaCA9IGZvcm1hdC5saW5lRGFzaDtcbiAgICAgIHNlY3Rvci5saW5lRGFzaE9mZnNldCA9IGZvcm1hdC5saW5lRGFzaE9mZnNldDtcbiAgICAgIHNlY3Rvci5jb3JuZXJSYWRpdXMgPSBmb3JtYXQuY29ybmVyUmFkaXVzO1xuICAgICAgc2VjdG9yLmZpbGxTaGFkb3cgPSB0aGlzLnByb3BlcnRpZXMuc2hhZG93O1xuICAgICAgY29uc3QgaW5zZXQgPSBNYXRoLm1heChcbiAgICAgICAgKHRoaXMucHJvcGVydGllcy5zZWN0b3JTcGFjaW5nICsgKGZvcm1hdC5zdHJva2UgIT0gbnVsbCA/IGZvcm1hdC5zdHJva2VXaWR0aCA6IDApKSAvIDIsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBzZWN0b3IuaW5zZXQgPSBpbnNldDtcbiAgICAgIHNlY3Rvci5saW5lSm9pbiA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JTcGFjaW5nID49IDAgfHwgaW5zZXQgPiAwID8gXCJtaXRlclwiIDogXCJyb3VuZFwiO1xuICAgIH07XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdHVtLml0ZW1JZCA9PT0gaGlnaGxpZ2h0ZWREYXR1bT8uaXRlbUlkKSB7XG4gICAgICAgIG5vZGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGluZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KTtcbiAgICB0aGlzLnVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUlubmVyTGFiZWxOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlWmVyb3N1bVJpbmdzKCk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgY2FsbG91dFN0cm9rZVdpZHRoID0gY2FsbG91dExpbmUuc3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgY2FsbG91dENvbG9ycyA9IGNhbGxvdXRMaW5lLmNvbG9ycyA/PyB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCB9ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbDtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygwIC8qIENhbGxvdXQgKi8pLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkYXR1bSA9IGxpbmUuZGF0dW07XG4gICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbDogbGFiZWwsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGlmIChsYWJlbD8udGV4dCAmJiAhbGFiZWwuaGlkZGVuICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSBjYWxsb3V0U3Ryb2tlV2lkdGg7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gY2FsbG91dENvbG9yc1tpbmRleCAlIGNhbGxvdXRDb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgbGluZS5maWxsID0gdm9pZCAwO1xuICAgICAgICBjb25zdCB4MSA9IGRhdHVtLm1pZENvcyAqIG91dGVyUmFkaXVzO1xuICAgICAgICBjb25zdCB5MSA9IGRhdHVtLm1pZFNpbiAqIG91dGVyUmFkaXVzO1xuICAgICAgICBsZXQgeDIgPSBkYXR1bS5taWRDb3MgKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgbGV0IHkyID0gZGF0dW0ubWlkU2luICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGlzTW92ZWQgPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMDtcbiAgICAgICAgaWYgKGlzTW92ZWQgJiYgbGFiZWwuYm94ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBib3ggPSBsYWJlbC5ib3g7XG4gICAgICAgICAgbGV0IGN4ID0geDI7XG4gICAgICAgICAgbGV0IGN5ID0geTI7XG4gICAgICAgICAgaWYgKHgyIDwgYm94LngpIHtcbiAgICAgICAgICAgIGN4ID0gYm94Lng7XG4gICAgICAgICAgfSBlbHNlIGlmICh4MiA+IGJveC54ICsgYm94LndpZHRoKSB7XG4gICAgICAgICAgICBjeCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeTIgPCBib3gueSkge1xuICAgICAgICAgICAgY3kgPSBib3gueTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkyID4gYm94LnkgKyBib3guaGVpZ2h0KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZHggPSBjeCAtIHgyO1xuICAgICAgICAgIGNvbnN0IGR5ID0gY3kgLSB5MjtcbiAgICAgICAgICBjb25zdCBsZW5ndGgyID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG4gICAgICAgICAgY29uc3QgcGFkZGVkTGVuZ3RoID0gbGVuZ3RoMiAtIG9mZnNldDQ7XG4gICAgICAgICAgaWYgKHBhZGRlZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHgyID0geDIgKyBkeCAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgICB5MiA9IHkyICsgZHkgKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lLngxID0geDE7XG4gICAgICAgIGxpbmUueTEgPSB5MTtcbiAgICAgICAgbGluZS54MiA9IHgyO1xuICAgICAgICBsaW5lLnkyID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRMYWJlbE92ZXJmbG93KHRleHQsIGJveCwgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHNlcmllc0xlZnQgPSBzZXJpZXNSZWN0LnggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzUmlnaHQgPSBzZXJpZXNSZWN0LnggKyBzZXJpZXNSZWN0LndpZHRoIC0gdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1RvcCA9IHNlcmllc1JlY3QueSAtIHRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBzZXJpZXNCb3R0b20gPSBzZXJpZXNSZWN0LnkgKyBzZXJpZXNSZWN0LmhlaWdodCAtIHRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBlcnJQeCA9IDE7XG4gICAgbGV0IHZpc2libGVUZXh0UGFydCA9IDE7XG4gICAgaWYgKGJveC54ICsgZXJyUHggPCBzZXJpZXNMZWZ0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoYm94LnggKyBib3gud2lkdGggLSBzZXJpZXNMZWZ0KSAvIGJveC53aWR0aDtcbiAgICB9IGVsc2UgaWYgKGJveC54ICsgYm94LndpZHRoIC0gZXJyUHggPiBzZXJpZXNSaWdodCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKHNlcmllc1JpZ2h0IC0gYm94LngpIC8gYm94LndpZHRoO1xuICAgIH1cbiAgICBjb25zdCBoYXNWZXJ0aWNhbE92ZXJmbG93ID0gYm94LnkgKyBlcnJQeCA8IHNlcmllc1RvcCB8fCBib3gueSArIGJveC5oZWlnaHQgLSBlcnJQeCA+IHNlcmllc0JvdHRvbTtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdmlzaWJsZVRleHRQYXJ0ID09PSAxID8gdGV4dC5sZW5ndGggOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoICogdmlzaWJsZVRleHRQYXJ0KSAtIDE7XG4gICAgY29uc3QgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyA9IHRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gpO1xuICAgIHJldHVybiB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfTtcbiAgfVxuICBiYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCwgZHggPSAwLCBkeSA9IDApIHtcbiAgICBjb25zdCB7IHN1cnJvdW5kaW5nUmFkaXVzIH0gPSB0aGlzO1xuICAgIGlmIChzdXJyb3VuZGluZ1JhZGl1cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICB7IHg6IGJveC54ICsgZHgsIHk6IGJveC55ICsgZHkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGggKyBkeCwgeTogYm94LnkgKyBkeSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCArIGR4LCB5OiBib3gueSArIGJveC5oZWlnaHQgKyBkeSB9LFxuICAgICAgeyB4OiBib3gueCArIGR4LCB5OiBib3gueSArIGJveC5oZWlnaHQgKyBkeSB9XG4gICAgXTtcbiAgICBjb25zdCBzdXIyID0gc3Vycm91bmRpbmdSYWRpdXMgKiogMjtcbiAgICByZXR1cm4gY29ybmVycy5zb21lKChjb3JuZXIpID0+IGNvcm5lci54ICoqIDIgKyBjb3JuZXIueSAqKiAyID4gc3VyMik7XG4gIH1cbiAgY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIHJldHVybiAhbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDA7XG4gICAgfTtcbiAgICBjb25zdCBmdWxsRGF0YSA9IHRoaXMuY2FsbG91dE5vZGVEYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdWxsRGF0YS5maWx0ZXIoKHQpID0+ICFzaG91bGRTa2lwKHQpKTtcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IHZvaWQgMDtcbiAgICAgIGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSAwO1xuICAgIH0pO1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZnRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPCAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCByaWdodExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA+PSAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCB0b3BMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPCAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGJvdHRvbUxhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA+PSAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGdldFRleHRCQm94ID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gQkJveC56ZXJvLmNsb25lKCk7XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExpbmUubGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduO1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgcmV0dXJuIFRleHQuY29tcHV0ZUJCb3gobGFiZWwudGV4dCwgeCwgeSwge1xuICAgICAgICBmb250OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZE5laWdoYm91cllDb2xsaXNpb24gPSAobGFiZWwsIG5leHQsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgYm94ID0gZ2V0VGV4dEJCb3gobGFiZWwpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3Qgb3RoZXIgPSBnZXRUZXh0QkJveChuZXh0KS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVzT3JCZWhpbmQgPSBib3gueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiBib3gueCArIGJveC53aWR0aCA+IG90aGVyLnggJiYgKGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCA+IG90aGVyLnkpO1xuICAgICAgaWYgKGNvbGxpZGVzT3JCZWhpbmQpIHtcbiAgICAgICAgY29uc3QgZHkgPSBkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSAtIG90aGVyLnkgLSBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgLSBvdGhlci55O1xuICAgICAgICBuZXh0LmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gZHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFlDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbWlkTGFiZWwgPSBsYWJlbHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhLm1pZFNpbikgLSBNYXRoLmFicyhiLm1pZFNpbikpWzBdO1xuICAgICAgY29uc3QgbWlkSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtaWRMYWJlbCk7XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tdG9wXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4ICsgMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tYm90dG9tXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRYQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgPSBkYXRhLnNvbWUoKGRhdHVtKSA9PiBkYXR1bS5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMCk7XG4gICAgICBjb25zdCBib3hlcyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiBnZXRUZXh0QkJveChsYWJlbCkpO1xuICAgICAgY29uc3QgcGFkZGVkQm94ZXMgPSBib3hlcy5tYXAoKGJveCkgPT4gYm94LmNsb25lKCkuZ3JvdyhtaW5TcGFjaW5nIC8gMikpO1xuICAgICAgbGV0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQm94ZXMubGVuZ3RoICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYOyBpKyspIHtcbiAgICAgICAgY29uc3QgYm94ID0gcGFkZGVkQm94ZXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxhYmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFkZGVkQm94ZXNbal07XG4gICAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3gob3RoZXIpKSB7XG4gICAgICAgICAgICBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VjdG9ycyA9IGZ1bGxEYXRhLm1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVTZWN0b3JzID0gYm94ZXMuc29tZSgoYm94KSA9PiB7XG4gICAgICAgIHJldHVybiBzZWN0b3JzLnNvbWUoKHNlY3RvcikgPT4gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlZICYmICFsYWJlbHNDb2xsaWRlU2VjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYWJlbHMuZmlsdGVyKChkKSA9PiBkLmNhbGxvdXRMYWJlbC50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkLmNhbGxvdXRMYWJlbDtcbiAgICAgICAgaWYgKGQubWlkQ29zIDwgMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChkLm1pZENvcyA+IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGF2b2lkWUNvbGxpc2lvbnMobGVmdExhYmVscyk7XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhyaWdodExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyh0b3BMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnMoYm90dG9tTGFiZWxzKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBjb2xvciB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IHRlbXBUZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMSAvKiBMYWJlbCAqLykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSB9ID0gdGV4dDtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydChkYXR1bS5yYWRpdXMpO1xuICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCByYWRpdXMpO1xuICAgICAgaWYgKCFsYWJlbD8udGV4dCB8fCBvdXRlclJhZGl1cyA9PT0gMCB8fCBsYWJlbC5oaWRkZW4pIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gb3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCBhbGlnbiA9IHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICAgIHRlbXBUZXh0Tm9kZS50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRlbXBUZXh0Tm9kZS54ID0geDtcbiAgICAgIHRlbXBUZXh0Tm9kZS55ID0geTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGVtcFRleHROb2RlLnNldEFsaWduKGFsaWduKTtcbiAgICAgIGNvbnN0IGJveCA9IHRlbXBUZXh0Tm9kZS5nZXRCQm94KCk7XG4gICAgICBsZXQgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xuICAgICAgaWYgKGNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3cobGFiZWwudGV4dCwgYm94LCBzZXJpZXNSZWN0KTtcbiAgICAgICAgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA9PT0gdGV4dExlbmd0aCA/IGxhYmVsLnRleHQgOiBgJHtsYWJlbC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0TGVuZ3RoKX1cXHUyMDI2YDtcbiAgICAgICAgdmlzaWJsZSA9ICFoYXNWZXJ0aWNhbE92ZXJmbG93O1xuICAgICAgfVxuICAgICAgdGV4dC50ZXh0ID0gZGlzcGxheVRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0LnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbXB1dGVMYWJlbHNCQm94KG9wdGlvbnMsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtYXhDb2xsaXNpb25PZmZzZXQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShmYWxzZSk7XG4gICAgdGhpcy5jb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpO1xuICAgIGNvbnN0IHRleHRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgIGxldCB0aXRsZUJveDtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKHRpdGxlPy50ZXh0ICYmIHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICB0ZXh0LnRleHQgPSB0aXRsZS50ZXh0O1xuICAgICAgICB0ZXh0LnggPSAwO1xuICAgICAgICB0ZXh0LnkgPSBkeTtcbiAgICAgICAgdGV4dC5zZXRGb250KHRpdGxlKTtcbiAgICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVCb3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgdGV4dEJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxvdXROb2RlRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAoIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgbGFiZWwuYm94ID0gYm94O1xuICAgICAgaWYgKE1hdGguYWJzKGxhYmVsLmNvbGxpc2lvbk9mZnNldFkpID4gbWF4Q29sbGlzaW9uT2Zmc2V0KSB7XG4gICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgICAgIGNvbnN0IHRpdGxlQ2xlYW5BcmVhID0gbmV3IEJCb3goXG4gICAgICAgICAgdGl0bGVCb3gueCAtIG1pblNwYWNpbmcsXG4gICAgICAgICAgc2VyaWVzVG9wLFxuICAgICAgICAgIHRpdGxlQm94LndpZHRoICsgMiAqIG1pblNwYWNpbmcsXG4gICAgICAgICAgdGl0bGVCb3gueSArIHRpdGxlQm94LmhlaWdodCArIG1pblNwYWNpbmcgLSBzZXJpZXNUb3BcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3godGl0bGVDbGVhbkFyZWEpKSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhpZGVXaGVuTmVjZXNzYXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KFxuICAgICAgICAgIGxhYmVsLnRleHQsXG4gICAgICAgICAgYm94LFxuICAgICAgICAgIHNlcmllc1JlY3RcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNUb29TaG9ydCA9IGxhYmVsLnRleHQubGVuZ3RoID4gMiAmJiB0ZXh0TGVuZ3RoIDwgMjtcbiAgICAgICAgaWYgKGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfHwgaXNUb29TaG9ydCB8fCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93KSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGV4dEJveGVzLnB1c2goYm94KTtcbiAgICB9KTtcbiAgICBpZiAodGV4dEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKHRleHRCb3hlcyk7XG4gIH1cbiAgdXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCB7IGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIHBvc2l0aW9uT2Zmc2V0LCBwb3NpdGlvblJhdGlvLCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckxhYmVsID0gKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICBsZXQgaXNUZXh0VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHNlY3RvckxhYmVsICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gaW5uZXJSYWRpdXMgKiAoMSAtIHBvc2l0aW9uUmF0aW8pICsgb3V0ZXJSYWRpdXMgKiBwb3NpdGlvblJhdGlvICsgcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0LnRleHQgPSBzZWN0b3JMYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0LnggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgICAgdGV4dC55ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXM7XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICBjb25zdCBiYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICAgICAgW2Jib3gueCwgYmJveC55XSxcbiAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55XSxcbiAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55ICsgYmJveC5oZWlnaHRdLFxuICAgICAgICAgIFtiYm94LngsIGJib3gueSArIGJib3guaGVpZ2h0XVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBkYXR1bTtcbiAgICAgICAgY29uc3Qgc2VjdG9yQm91bmRzID0geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICAgIGlmIChjb3JuZXJzLmV2ZXJ5KChbeCwgeV0pID0+IGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3JCb3VuZHMpKSkge1xuICAgICAgICAgIGlzVGV4dFZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0LnZpc2libGUgPSBpc1RleHRWaXNpYmxlO1xuICAgIH07XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICB9XG4gIHVwZGF0ZUlubmVyTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB0ZXh0QkJveGVzID0gW107XG4gICAgY29uc3QgbWFyZ2lucyA9IFtdO1xuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IGRhdHVtO1xuICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIHRleHQudGV4dCA9IGRhdHVtLnRleHQ7XG4gICAgICB0ZXh0LnggPSAwO1xuICAgICAgdGV4dC55ID0gMDtcbiAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICAgIHRleHRCQm94ZXMucHVzaCh0ZXh0LmdldEJCb3goKSk7XG4gICAgICBtYXJnaW5zLnB1c2goZGF0dW0uc3BhY2luZyk7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0TWFyZ2luVG9wID0gKGluZGV4KSA9PiBpbmRleCA9PT0gMCA/IDAgOiBtYXJnaW5zW2luZGV4XTtcbiAgICBjb25zdCBnZXRNYXJnaW5Cb3R0b20gPSAoaW5kZXgpID0+IGluZGV4ID09PSBtYXJnaW5zLmxlbmd0aCAtIDEgPyAwIDogbWFyZ2luc1tpbmRleF07XG4gICAgY29uc3QgdG90YWxIZWlnaHQgPSB0ZXh0QkJveGVzLnJlZHVjZSgoc3VtMiwgYmJveCwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHN1bTIgKyBiYm94LmhlaWdodCArIGdldE1hcmdpblRvcChpKSArIGdldE1hcmdpbkJvdHRvbShpKTtcbiAgICB9LCAwKTtcbiAgICBjb25zdCB0b3RhbFdpZHRoID0gTWF0aC5tYXgoLi4udGV4dEJCb3hlcy5tYXAoKGJib3gpID0+IGJib3gud2lkdGgpKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICBjb25zdCBsYWJlbFJhZGl1cyA9IE1hdGguc3FydChNYXRoLnBvdyh0b3RhbFdpZHRoIC8gMiwgMikgKyBNYXRoLnBvdyh0b3RhbEhlaWdodCAvIDIsIDIpKTtcbiAgICBjb25zdCBsYWJlbHNWaXNpYmxlID0gbGFiZWxSYWRpdXMgPD0gKGlubmVyUmFkaXVzID4gMCA/IGlubmVyUmFkaXVzIDogdGhpcy5nZXRPdXRlclJhZGl1cygpKTtcbiAgICBjb25zdCB0ZXh0Qm90dG9tcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBwcmV2ID0gLXRvdGFsSGVpZ2h0IC8gMjsgaSA8IHRleHRCQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJib3ggPSB0ZXh0QkJveGVzW2ldO1xuICAgICAgY29uc3QgYm90dG9tID0gYmJveC5oZWlnaHQgKyBwcmV2ICsgZ2V0TWFyZ2luVG9wKGkpO1xuICAgICAgdGV4dEJvdHRvbXMucHVzaChib3R0b20pO1xuICAgICAgcHJldiA9IGJvdHRvbSArIGdldE1hcmdpbkJvdHRvbShpKTtcbiAgICB9XG4gICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbi5lYWNoKCh0ZXh0LCBfZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB0ZXh0LnkgPSB0ZXh0Qm90dG9tc1tpbmRleF07XG4gICAgICB0ZXh0LnZpc2libGUgPSBsYWJlbHNWaXNpYmxlO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVplcm9zdW1SaW5ncygpIHtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc2l6ZSA9IHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgdGhpcy56ZXJvc3VtSW5uZXJSaW5nLnNpemUgPSB0aGlzLmdldElubmVyUmFkaXVzKCkgKiAyO1xuICB9XG4gIGdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgY2FsbG91dExhYmVsLCBsZWdlbmRJdGVtIH0gPSBub2RlRGF0dW07XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVnZW5kSXRlbS50ZXh0O1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjYWxsb3V0TGFiZWwudGV4dDtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBzZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc2VjdG9yTGFiZWwudGV4dDtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gcGlja0J5TWF0Y2hpbmdBbmdsZSh0aGlzLCBwb2ludCk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgZmlsbDogY29sb3IgfSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwodGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy50ZXh0KTtcbiAgICBjb25zdCBjb250ZW50ID0gaXNGaW5pdGVOdW1iZXIoYW5nbGVWYWx1ZSkgPyB0b0ZpeGVkKGFuZ2xlVmFsdWUpIDogU3RyaW5nKGFuZ2xlVmFsdWUpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSk7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSA/PyBsYWJlbFRleHQsXG4gICAgICAgIGNvbnRlbnQ6IHRpdGxlICYmIGxhYmVsVGV4dCA/IGAke2xhYmVsVGV4dH06ICR7Y29udGVudH1gIDogY29udGVudCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHZpc2libGUsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YT8uZGF0YS5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWxlZ2VuZEl0ZW1LZXkgJiYgKCFjYWxsb3V0TGFiZWxLZXkgfHwgY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSkgJiYgKCFzZWN0b3JMYWJlbEtleSB8fCBzZWN0b3JMYWJlbEtleSA9PT0gYW5nbGVLZXkpKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsSWR4LCBzZWN0b3JMYWJlbElkeCwgbGVnZW5kSXRlbUlkeCB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHRpdGxlVGV4dCA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc2hvd0luTGVnZW5kICYmIHRoaXMucHJvcGVydGllcy50aXRsZS50ZXh0O1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29uc3QgbGFiZWxQYXJ0cyA9IFtdO1xuICAgICAgaWYgKHRpdGxlVGV4dCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2godGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxhYmVscy5sZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5sZWdlbmRJdGVtLnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxQYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBsZWdlbmREYXRhLnB1c2goe1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFBhcnRzLmpvaW4oXCIgLSBcIilcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBmaWxsOiBzZWN0b3JGb3JtYXQuZmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzZWN0b3JGb3JtYXQuc3Ryb2tlLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWU6IGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCA/IGRhdHVtW2xlZ2VuZEl0ZW1LZXldIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZERhdGE7XG4gIH1cbiAgb25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBsZWdlbmRJdGVtTmFtZSB9ID0gZXZlbnQ7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgfSBlbHNlIGlmIChsZWdlbmRJdGVtTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCkge1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaXRlbUlkXSA9IGVuYWJsZWQ7XG4gICAgaWYgKHRoaXMubm9kZURhdGFbaXRlbUlkXSkge1xuICAgICAgdGhpcy5ub2RlRGF0YVtpdGVtSWRdLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gIH1cbiAgdG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhsZWdlbmRJdGVtTmFtZSwgZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgfHwgIXRoaXMuZGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZ2VuZEl0ZW1JZHggPSB0aGlzLmRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCk7XG4gICAgdGhpcy5wcm9jZXNzZWREYXRhPy5kYXRhLmZvckVhY2goKHsgdmFsdWVzIH0sIGRhdHVtSXRlbUlkKSA9PiB7XG4gICAgICBpZiAodmFsdWVzW2xlZ2VuZEl0ZW1JZHhdID09PSBsZWdlbmRJdGVtTmFtZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oZGF0dW1JdGVtSWQsIGVuYWJsZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgdHJ1ZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHRoaXMucmFkaXVzU2NhbGUsXG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW3RoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24sIHRoaXMucGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSlcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImlubmVyXCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeSgpIHtcbiAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbiwgcHJvY2Vzc2VkRGF0YSwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoZGF0YURpZmY/Lm1vdmVkLnNpemUgPz8gMCkgPT09IDA7XG4gICAgY29uc3QgaGFzS2V5cyA9IChwcm9jZXNzZWREYXRhPy5kZWZzLmtleXMubGVuZ3RoID8/IDApID4gMDtcbiAgICBjb25zdCBoYXNVbmlxdWVLZXlzID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyA/PyB0cnVlO1xuICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJpbm5lclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIGBpbm5lckNpcmNsZWAsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uXSwgZm5zLmlubmVyQ2lyY2xlKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImlubmVyXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtsZWdlbmRJdGVtS2V5XTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2NhbGxvdXRMYWJlbEtleV07XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW3NlY3RvckxhYmVsS2V5XTtcbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1JZChkYXR1bSkge1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IGRhdHVtO1xuICAgIGNvbnN0IGRhdHVtSWQgPSB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShkYXR1bS5kYXR1bSk7XG4gICAgcmV0dXJuIGRhdHVtSWQgIT0gbnVsbCA/IFN0cmluZyhkYXR1bUlkKSA6IGAke2luZGV4fWA7XG4gIH1cbiAgb25EYXRhQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IGRhdGE/Lm1hcCgoXywgaW5kZXgpID0+IHNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSA/PyB0cnVlKSA/PyBbXTtcbiAgfVxufTtcbkRvbnV0U2VyaWVzLmNsYXNzTmFtZSA9IFwiRG9udXRTZXJpZXNcIjtcbkRvbnV0U2VyaWVzLnR5cGUgPSBcImRvbnV0XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFRoZW1lLnRzXG52YXIgZG9udXRUaGVtZSA9IHtcbiAgc2VyaWVzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gICAgICBzcGFjaW5nOiA1XG4gICAgfSxcbiAgICBjYWxsb3V0TGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgb2Zmc2V0OiAzLFxuICAgICAgbWluQW5nbGU6IDBcbiAgICB9LFxuICAgIHNlY3RvckxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gICAgICBwb3NpdGlvbk9mZnNldDogMCxcbiAgICAgIHBvc2l0aW9uUmF0aW86IDAuNVxuICAgIH0sXG4gICAgY2FsbG91dExpbmU6IHtcbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0sXG4gICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICBzdHJva2VXaWR0aDogMCxcbiAgICBsaW5lRGFzaDogWzBdLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNlY3RvclNwYWNpbmc6IDEsXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICB4T2Zmc2V0OiAzLFxuICAgICAgeU9mZnNldDogMyxcbiAgICAgIGJsdXI6IDVcbiAgICB9LFxuICAgIGlubmVyTGFiZWxzOiB7XG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgc3BhY2luZzogMlxuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVRoZW1lLnRzXG52YXIgcGllVGhlbWUgPSB7XG4gIHNlcmllczoge1xuICAgIHRpdGxlOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTQsXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLFxuICAgICAgc3BhY2luZzogNVxuICAgIH0sXG4gICAgY2FsbG91dExhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgIG9mZnNldDogMyxcbiAgICAgIG1pbkFuZ2xlOiAwXG4gICAgfSxcbiAgICBzZWN0b3JMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxuICAgICAgcG9zaXRpb25PZmZzZXQ6IDAsXG4gICAgICBwb3NpdGlvblJhdGlvOiAwLjVcbiAgICB9LFxuICAgIGNhbGxvdXRMaW5lOiB7XG4gICAgICBsZW5ndGg6IDEwLFxuICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICB9LFxuICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgbGluZURhc2g6IFswXSxcbiAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzZWN0b3JTcGFjaW5nOiAxLFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgeE9mZnNldDogMyxcbiAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICBibHVyOiA1XG4gICAgfVxuICB9XG59O1xudmFyIHBpZVBhbGV0dGVGYWN0b3J5ID0gKHsgdGFrZUNvbG9ycywgY29sb3JzQ291bnQgfSkgPT4ge1xuICBjb25zdCB7IGZpbGxzLCBzdHJva2VzIH0gPSB0YWtlQ29sb3JzKGNvbG9yc0NvdW50KTtcbiAgcmV0dXJuIHsgZmlsbHMsIHN0cm9rZXMsIGNhbGxvdXRMaW5lOiB7IGNvbG9yczogc3Ryb2tlcyB9IH07XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXNNb2R1bGUudHNcbnZhciBEb251dFNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sXG4gIGlkZW50aWZpZXI6IFwiZG9udXRcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IERvbnV0U2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIHRoZW1lVGVtcGxhdGU6IGRvbnV0VGhlbWUsXG4gIHBhbGV0dGVGYWN0b3J5OiBwaWVQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBQaWVUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQ2FwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBQaWVUaXRsZS5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xudmFyIFBpZVNlcmllc0NhbGxvdXRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMub2Zmc2V0ID0gMztcbiAgICB0aGlzLm1pbkFuZ2xlID0gMDtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSA0O1xuICAgIHRoaXMubWF4Q29sbGlzaW9uT2Zmc2V0ID0gNTA7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pbkFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtYXhDb2xsaXNpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJhdm9pZENvbGxpc2lvbnNcIiwgMik7XG52YXIgUGllU2VyaWVzU2VjdG9yTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uUmF0aW8gPSAwLjU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBQaWVTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblJhdGlvXCIsIDIpO1xudmFyIFBpZVNlcmllc0NhbGxvdXRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImNvbG9yc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG52YXIgUGllU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxscyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9GSUxMUyk7XG4gICAgdGhpcy5zdHJva2VzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c09mZnNldCA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c1JhdGlvID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnNlY3RvclNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgUGllVGl0bGUoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWwgPSBuZXcgUGllU2VyaWVzQ2FsbG91dExhYmVsKCk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbCA9IG5ldyBQaWVTZXJpZXNTZWN0b3JMYWJlbCgpO1xuICAgIHRoaXMuY2FsbG91dExpbmUgPSBuZXcgUGllU2VyaWVzQ2FsbG91dExpbmUoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c0tleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNYXhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1JhdGlvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JTcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllcy50c1xudmFyIFBpZVNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5hbmdsZUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5O1xuICAgIHRoaXMucmFkaXVzS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMucmFkaXVzS2V5O1xuICAgIHRoaXMuY2FsbG91dExhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5O1xuICAgIHRoaXMuc2VjdG9yTGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleTtcbiAgfVxufTtcbnZhciBQaWVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFBvbGFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMyAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7IGl0ZW06IHJlc2V0UGllU2VsZWN0aW9uc0ZuLCBsYWJlbDogcmVzZXRMYWJlbEZuIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgUGllU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5waGFudG9tR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwicGllQ2FsbG91dExhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oXG4gICAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwLFxuICAgICAgR3JvdXBcbiAgICApO1xuICAgIC8vIFRoZSBncm91cCBub2RlIHRoYXQgY29udGFpbnMgdGhlIGJhY2tncm91bmQgZ3JhcGhpY3MuXG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWJhY2tncm91bmRgLFxuICAgICAgICBsYXllcjogdHJ1ZSxcbiAgICAgICAgekluZGV4OiAwIC8qIFNFUklFU19CQUNLR1JPVU5EX1pJTkRFWCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIC8vIEFHLTYxOTMgSWYgdGhlIHN1bSBvZiBhbGwgZGF0dW1zIGlzIDAsIHRoZW4gd2UnbGwgZHJhdyAxIG9yIDIgcmluZ3MgdG8gcmVwcmVzZW50IHRoZSBlbXB0eSBzZXJpZXMuXG4gICAgdGhpcy56ZXJvc3VtUmluZ3NHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXplcm9zdW1SaW5nc2AgfSkpO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IENpcmNsZSgpKTtcbiAgICAvLyBXaGVuIGEgdXNlciB0b2dnbGVzIGEgc2VyaWVzIGl0ZW0gKGUuZy4gZnJvbSB0aGUgbGVnZW5kKSwgaXRzIGJvb2xlYW4gc3RhdGUgaXMgcmVjb3JkZWQgaGVyZS5cbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkID0gW107XG4gICAgdGhpcy5zdXJyb3VuZGluZ1JhZGl1cyA9IHZvaWQgMDtcbiAgICB0aGlzLk5vZGVFdmVudCA9IFBpZVNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmFuZ2xlU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluID0gWzAsIDFdO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5yYW5nZSA9IFstTWF0aC5QSSwgTWF0aC5QSV0ubWFwKChhbmdsZTIpID0+IGFuZ2xlMiArIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cC5vcGFjaXR5ID0gMC4yO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwLnpJbmRleFN1Yk9yZGVyID0gWygpID0+IHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIsIDBdO1xuICB9XG4gIGdldCBjYWxsb3V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IHRoaXMubm9kZURhdGE7XG4gIH1cbiAgYWRkQ2hhcnRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyPy5hZGRMaXN0ZW5lcihcImxlZ2VuZC1pdGVtLWNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1DbGljayhldmVudCkpXG4gICAgKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudmlzaWJsZSAmJiAodGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5sZW5ndGggPT09IDAgfHwgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5zb21lKCh2aXNpYmxlKSA9PiB2aXNpYmxlKSk7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgY29uc3Qgc2VjdG9yID0gbmV3IFNlY3RvcigpO1xuICAgIHNlY3Rvci5taXRlckxpbWl0ID0gMWU5O1xuICAgIHJldHVybiBzZWN0b3I7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yYWRpdXNTY2FsZS5kb21haW47XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IGRhdGEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBzZXJpZXNJdGVtRW5hYmxlZCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBhbmdsZUZpbHRlcktleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5UHJvcHMgPSBbXTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1LZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxLZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxLZXlgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGNvbnN0IGFuZ2xlU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGlmIChyYWRpdXNLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgcmFuZ2VkVmFsdWVQcm9wZXJ0eShyYWRpdXNLZXksIHtcbiAgICAgICAgICBpZDogXCJyYWRpdXNWYWx1ZVwiLFxuICAgICAgICAgIG1pbjogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLFxuICAgICAgICAgIG1heDogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01heFxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShyYWRpdXNLZXksIHJhZGl1c1NjYWxlVHlwZSwgeyBpZDogYHJhZGl1c1Jhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJyYWRpdXNWYWx1ZVwiLCBbMCwgMV0sIDEsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01heClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbVZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUZpbHRlcktleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgYW5nbGVGaWx0ZXJWYWx1ZWAsXG4gICAgICAgICAgb25seVBvc2l0aXZlOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlRmlsdGVyUmF3YCB9KSxcbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlRmlsdGVyVmFsdWVcIiwgWzAsIDFdLCAwLCAwKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzICYmIGV4dHJhS2V5UHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIGRhdGEgPSBkYXRhLm1hcCgoZCwgaWR4KSA9PiB2aXNpYmxlICYmIHNlcmllc0l0ZW1FbmFibGVkW2lkeF0gPyBkIDogeyAuLi5kLCBbYW5nbGVLZXldOiAwIH0pO1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAgLi4uZXh0cmFLZXlQcm9wcyxcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVZhbHVlYCwgb25seVBvc2l0aXZlOiB0cnVlIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlVmFsdWVcIiwgWzAsIDFdLCAwLCAwKSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdGhpcy5wcm9jZXNzZWREYXRhPy5kZWZzPy52YWx1ZXMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHsgaWQsIG1pc3NpbmcsIHByb3BlcnR5IH0gPSB2YWx1ZURlZjtcbiAgICAgIGNvbnN0IG1pc3NDb3VudCA9IGdldE1pc3NDb3VudCh0aGlzLCBtaXNzaW5nKTtcbiAgICAgIGlmIChpZCAhPT0gXCJhbmdsZVJhd1wiICYmIG1pc3NDb3VudCA+IDApIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBubyB2YWx1ZSB3YXMgZm91bmQgZm9yIHRoZSBrZXkgJyR7U3RyaW5nKHByb3BlcnR5KX0nIG9uICR7bWlzc0NvdW50fSBkYXRhIGVsZW1lbnQke21pc3NDb3VudCA+IDEgPyBcInNcIiA6IFwiXCJ9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGFzeW5jIG1heWJlUmVmcmVzaE5vZGVEYXRhKCkge1xuICAgIGlmICghdGhpcy5ub2RlRGF0YVJlZnJlc2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBub2RlRGF0YSA9IFtdLCBwaGFudG9tTm9kZURhdGEgfSA9IGF3YWl0IHRoaXMuY3JlYXRlTm9kZURhdGEoKSA/PyB7fTtcbiAgICB0aGlzLm5vZGVEYXRhID0gbm9kZURhdGE7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSBwaGFudG9tTm9kZURhdGE7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgfVxuICBnZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpIHtcbiAgICBjb25zdCBhbmdsZUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVWYWx1ZWApO1xuICAgIGNvbnN0IGFuZ2xlUmF3SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVJhd2ApO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVySWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhbmdsZUZpbHRlclJhd0lkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclJhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1ZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzUmF3SWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgcmFkaXVzUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FsbG91dExhYmVsSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY2FsbG91dExhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZWN0b3JMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2VjdG9yTGFiZWxWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1JZHggPSB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBhbmdsZVNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLnR5cGUgIT09IFwidW5ncm91cGVkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgYW5nbGVJZHgsXG4gICAgICBhbmdsZVJhd0lkeCxcbiAgICAgIGFuZ2xlRmlsdGVySWR4LFxuICAgICAgYW5nbGVGaWx0ZXJSYXdJZHgsXG4gICAgICByYWRpdXNJZHgsXG4gICAgICByYWRpdXNSYXdJZHgsXG4gICAgICBjYWxsb3V0TGFiZWxJZHgsXG4gICAgICBzZWN0b3JMYWJlbElkeCxcbiAgICAgIGxlZ2VuZEl0ZW1JZHhcbiAgICB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHVzZUZpbHRlckFuZ2xlcyA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgJiYgcHJvY2Vzc2VkRGF0YS5kYXRhLnNvbWUoKHsgdmFsdWVzIH0pID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZXNbYW5nbGVGaWx0ZXJSYXdJZHhdID4gdmFsdWVzW2FuZ2xlUmF3SWR4XTtcbiAgICB9KTtcbiAgICBsZXQgY3VycmVudFN0YXJ0ID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsID8gW10gOiB2b2lkIDA7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhLmZvckVhY2goKGdyb3VwLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBncm91cDtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHVzZUZpbHRlckFuZ2xlcyA/IHZhbHVlc1thbmdsZUZpbHRlcklkeF0gOiB2YWx1ZXNbYW5nbGVJZHhdO1xuICAgICAgY29uc3QgY3Jvc3NGaWx0ZXJTY2FsZSA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgJiYgIXVzZUZpbHRlckFuZ2xlcyA/IE1hdGguc3FydCh2YWx1ZXNbYW5nbGVGaWx0ZXJSYXdJZHhdIC8gdmFsdWVzW2FuZ2xlUmF3SWR4XSkgOiAxO1xuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGN1cnJlbnRTdGFydCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIHN1bTIgKz0gY3VycmVudFZhbHVlO1xuICAgICAgY29uc3QgZW5kQW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjb25zdCBzcGFuID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHNwYW4gLyAyO1xuICAgICAgY29uc3QgYW5nbGVWYWx1ZSA9IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgICBjb25zdCByYWRpdXNSYXcgPSByYWRpdXNJZHggIT0gbnVsbCA/IHZhbHVlc1tyYWRpdXNJZHhdID8/IDEgOiAxO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzUmF3ICogY3Jvc3NGaWx0ZXJTY2FsZTtcbiAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gcmFkaXVzUmF3SWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzUmF3SWR4XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1WYWx1ZSA9IGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vZGVMYWJlbHMgPSB0aGlzLmdldExhYmVscyhcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBzcGFuLFxuICAgICAgICB0cnVlLFxuICAgICAgICBjYWxsb3V0TGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tjYWxsb3V0TGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBzZWN0b3JMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW3NlY3RvckxhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlXG4gICAgICApO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYW5nbGVWYWx1ZSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIG1pZENvczogTWF0aC5jb3MobWlkQW5nbGUpLFxuICAgICAgICBtaWRTaW46IE1hdGguc2luKG1pZEFuZ2xlKSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQocmFkaXVzKSwgMCksXG4gICAgICAgIHNlY3RvckZvcm1hdCxcbiAgICAgICAgcmFkaXVzVmFsdWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZSxcbiAgICAgICAgZW5hYmxlZDogdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0sXG4gICAgICAgIC4uLm5vZGVMYWJlbHNcbiAgICAgIH07XG4gICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKHBoYW50b21Ob2RlcyAhPSBudWxsKSB7XG4gICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDEpLCAwKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcudmlzaWJsZSA9IHN1bTIgPT09IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogc2VyaWVzSWQsXG4gICAgICBub2RlRGF0YTogbm9kZXMsXG4gICAgICBsYWJlbERhdGE6IG5vZGVzLFxuICAgICAgcGhhbnRvbU5vZGVEYXRhOiBwaGFudG9tTm9kZXNcbiAgICB9O1xuICB9XG4gIGdldExhYmVscyhkYXR1bSwgbWlkQW5nbGUsIHNwYW4sIHNraXBEaXNhYmxlZCwgY2FsbG91dExhYmVsVmFsdWUsIHNlY3RvckxhYmVsVmFsdWUsIGxlZ2VuZEl0ZW1WYWx1ZSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBzZWN0b3JMYWJlbCwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgY2FsbG91dExhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5IDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBzZWN0b3JMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5IDogdm9pZCAwO1xuICAgIGlmICghY2FsbG91dExhYmVsS2V5ICYmICFzZWN0b3JMYWJlbEtleSAmJiAhbGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgc3BhbiA+IHRvUmFkaWFucyhjYWxsb3V0TGFiZWwubWluQW5nbGUpKSB7XG4gICAgICByZXN1bHQuY2FsbG91dExhYmVsID0ge1xuICAgICAgICAuLi50aGlzLmdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChjYWxsb3V0TGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogY2FsbG91dExhYmVsVmFsdWVcbiAgICAgICAgfSksXG4gICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgIGNvbGxpc2lvblRleHRBbGlnbjogdm9pZCAwLFxuICAgICAgICBjb2xsaXNpb25PZmZzZXRZOiAwLFxuICAgICAgICBib3g6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXN1bHQuc2VjdG9yTGFiZWwgPSB7XG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KHNlY3RvckxhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IHNlY3RvckxhYmVsVmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5ICE9IG51bGwgJiYgbGVnZW5kSXRlbVZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5sZWdlbmRJdGVtID0geyBrZXk6IGxlZ2VuZEl0ZW1LZXksIHRleHQ6IGxlZ2VuZEl0ZW1WYWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpIHtcbiAgICBjb25zdCBxdWFkcmFudFRleHRPcHRzID0gW1xuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJib3R0b21cIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwibGVmdFwiLCB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiaGFuZ2luZ1wiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJyaWdodFwiLCB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIgfVxuICAgIF07XG4gICAgY29uc3QgbWlkQW5nbGUxODAgPSBub3JtYWxpemVBbmdsZTE4MChtaWRBbmdsZSk7XG4gICAgY29uc3QgcXVhZHJhbnRTdGFydCA9IC0wLjc1ICogTWF0aC5QSTtcbiAgICBjb25zdCBxdWFkcmFudE9mZnNldCA9IG1pZEFuZ2xlMTgwIC0gcXVhZHJhbnRTdGFydDtcbiAgICBjb25zdCBxdWFkcmFudCA9IE1hdGguZmxvb3IocXVhZHJhbnRPZmZzZXQgLyAoTWF0aC5QSSAvIDIpKTtcbiAgICBjb25zdCBxdWFkcmFudEluZGV4ID0gbW9kKHF1YWRyYW50LCBxdWFkcmFudFRleHRPcHRzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHF1YWRyYW50VGV4dE9wdHNbcXVhZHJhbnRJbmRleF07XG4gIH1cbiAgZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBmb3JtYXRJbmRleCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrQ2FjaGUgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSwgZmlsbHMsIHN0cm9rZXMsIGl0ZW1TdHlsZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBkZWZhdWx0U3Ryb2tlID0gc3Ryb2tlc1tmb3JtYXRJbmRleCAlIHN0cm9rZXMubGVuZ3RoXTtcbiAgICBjb25zdCB7IGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGNvcm5lclJhZGl1cyB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAge1xuICAgICAgICBmaWxsOiBmaWxscy5sZW5ndGggPiAwID8gZmlsbHNbZm9ybWF0SW5kZXggJSBmaWxscy5sZW5ndGhdIDogdm9pZCAwLFxuICAgICAgICBzdHJva2U6IGRlZmF1bHRTdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpXG4gICAgICB9LFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzXG4gICAgKTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmIChpdGVtU3R5bGVyKSB7XG4gICAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgYW5nbGVLZXksXG4gICAgICAgIHJhZGl1c0tleSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgICAgbGVnZW5kSXRlbUtleSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICBoaWdobGlnaHRlZCxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogZm9ybWF0Py5zdHJva2UgPz8gc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGZvcm1hdD8uc3Ryb2tlV2lkdGggPz8gc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5OiBmb3JtYXQ/LnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBmb3JtYXQ/LmxpbmVEYXNoID8/IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGZvcm1hdD8ubGluZURhc2hPZmZzZXQgPz8gbGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXM6IGZvcm1hdD8uY29ybmVyUmFkaXVzID8/IGNvcm5lclJhZGl1c1xuICAgIH07XG4gIH1cbiAgZ2V0T3V0ZXJSYWRpdXMoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmFkaXVzICogdGhpcy5wcm9wZXJ0aWVzLm91dGVyUmFkaXVzUmF0aW8gKyB0aGlzLnByb3BlcnRpZXMub3V0ZXJSYWRpdXNPZmZzZXQsIDApO1xuICB9XG4gIHVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSkge1xuICAgIGNvbnN0IG5ld1JhbmdlID0gWzAsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKV07XG4gICAgdGhpcy5yYWRpdXNTY2FsZS5yYW5nZSA9IG5ld1JhbmdlO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IG5ld1JhbmdlO1xuICAgIH1cbiAgICBjb25zdCBzZXRSYWRpaSA9IChkKSA9PiAoe1xuICAgICAgLi4uZCxcbiAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChkLnJhZGl1cyksIDApXG4gICAgfSk7XG4gICAgdGhpcy5ub2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKHNldFJhZGlpKTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHRoaXMucGhhbnRvbU5vZGVEYXRhPy5tYXAoc2V0UmFkaWkpO1xuICB9XG4gIGdldFRpdGxlVHJhbnNsYXRpb25ZKCkge1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5yYWRpdXNTY2FsZS5yYW5nZVsxXSk7XG4gICAgaWYgKG91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy5zcGFjaW5nID8/IDA7XG4gICAgY29uc3QgdGl0bGVPZmZzZXQgPSAyICsgc3BhY2luZztcbiAgICBjb25zdCBkeSA9IE1hdGgubWF4KDAsIC1vdXRlclJhZGl1cyk7XG4gICAgcmV0dXJuIC1vdXRlclJhZGl1cyAtIHRpdGxlT2Zmc2V0IC0gZHk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzID0ge1xuICAgICAgc2VyaWVzUmVjdFdpZHRoOiBzZXJpZXNSZWN0Py53aWR0aCxcbiAgICAgIHNlcmllc1JlY3RIZWlnaHQ6IHNlcmllc1JlY3Q/LmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcmVzaXplID0ganNvbkRpZmYodGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcywgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMpICE9IG51bGw7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdOb2RlRGF0YURlcGVuZGVuY2llcztcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlVGl0bGVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICBjb25zdCB0aXRsZUJveCA9IHRpdGxlLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgdGl0bGUubm9kZS52aXNpYmxlID0gdGl0bGUuZW5hYmxlZCAmJiBpc0Zpbml0ZShkeSkgJiYgIXRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyh0aXRsZUJveCwgMCwgZHkpO1xuICAgICAgdGl0bGUubm9kZS50cmFuc2xhdGlvblkgPSBpc0Zpbml0ZShkeSkgPyBkeSA6IDA7XG4gICAgfVxuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5maWxsT3BhY2l0eSA9IDA7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnN0cm9rZSA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwuY29sb3I7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy51cGRhdGVOb2RlTWlkUG9pbnQoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpO1xuICB9XG4gIHVwZGF0ZVRpdGxlTm9kZXMoKSB7XG4gICAgY29uc3QgeyBvbGRUaXRsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKG9sZFRpdGxlICE9PSB0aXRsZSkge1xuICAgICAgaWYgKG9sZFRpdGxlKSB7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8ucmVtb3ZlQ2hpbGQob2xkVGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgdGl0bGUubm9kZS50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LmFwcGVuZENoaWxkKHRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbGRUaXRsZSA9IHRpdGxlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOb2RlTWlkUG9pbnQoKSB7XG4gICAgY29uc3Qgc2V0TWlkUG9pbnQgPSAoZCkgPT4ge1xuICAgICAgY29uc3QgcmFkaXVzID0gZC5pbm5lclJhZGl1cyArIChkLm91dGVyUmFkaXVzIC0gZC5pbm5lclJhZGl1cykgLyAyO1xuICAgICAgZC5taWRQb2ludCA9IHtcbiAgICAgICAgeDogZC5taWRDb3MgKiBNYXRoLm1heCgwLCByYWRpdXMpLFxuICAgICAgICB5OiBkLm1pZFNpbiAqIE1hdGgubWF4KDAsIHJhZGl1cylcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vZGVEYXRhLmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhPy5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZWxlY3Rpb25zKCkge1xuICAgIGF3YWl0IHRoaXMudXBkYXRlR3JvdXBTZWxlY3Rpb24oKTtcbiAgfVxuICBhc3luYyB1cGRhdGVHcm91cFNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgcGhhbnRvbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxuICAgICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBoaWdobGlnaHRlZE5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoKGRhdHVtKSA9PiAoe1xuICAgICAgLi4uZGF0dW0sXG4gICAgICAvLyBBbGxvdyBtdXRhYmxlIHNlY3RvckZvcm1hdCwgc28gZm9ybWF0dGVkIHNlY3RvciBzdHlsZXMgY2FuIGJlIHVwZGF0ZWQgYW5kIHZhcmllZFxuICAgICAgLy8gYmV0d2VlbiBub3JtYWwgYW5kIGhpZ2hsaWdodGVkIGNhc2VzLlxuICAgICAgc2VjdG9yRm9ybWF0OiB7IC4uLmRhdHVtLnNlY3RvckZvcm1hdCB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IChzZWxlY3Rpb24sIG5vZGVEYXRhKSA9PiB7XG4gICAgICBzZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSk7XG4gICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlKGl0ZW1TZWxlY3Rpb24sIHRoaXMubm9kZURhdGEpO1xuICAgIHVwZGF0ZShoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICAgIHVwZGF0ZShwaGFudG9tU2VsZWN0aW9uLCB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyBbXSk7XG4gICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLmNhbGxvdXROb2RlRGF0YSwgKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgIGxpbmUudGFnID0gMCAvKiBDYWxsb3V0ICovO1xuICAgICAgbGluZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICAgIHRleHQudGFnID0gMSAvKiBMYWJlbCAqLztcbiAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH0pO1xuICAgIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLm5vZGVEYXRhKTtcbiAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbi51cGRhdGUoaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTm9kZXMoc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0dW0gPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmluZGV4T2YodHJ1ZSkgPj0gMDtcbiAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwudmlzaWJsZSA9IGlzVmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgfVxuICAgIHRoaXMuY29udGVudEdyb3VwLm9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICBjb25zdCBhbmltYXRpb25EaXNhYmxlZCA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yRm4gPSAoc2VjdG9yLCBkYXR1bSwgX2luZGV4LCBpc0RhdHVtSGlnaGxpZ2h0ZWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLmRhdHVtLCBkYXR1bS5pdGVtSWQsIGlzRGF0dW1IaWdobGlnaHRlZCk7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICBpZiAoYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLnN0YXJ0QW5nbGUgPSBkYXR1bS5zdGFydEFuZ2xlO1xuICAgICAgICBzZWN0b3IuZW5kQW5nbGUgPSBkYXR1bS5lbmRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmlubmVyUmFkaXVzID0gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICAgIHNlY3Rvci5vdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGF0dW1IaWdobGlnaHRlZCB8fCBhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3IuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgICBzZWN0b3Iuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIH1cbiAgICAgIHNlY3Rvci5zdHJva2VXaWR0aCA9IGZvcm1hdC5zdHJva2VXaWR0aDtcbiAgICAgIHNlY3Rvci5maWxsT3BhY2l0eSA9IGZvcm1hdC5maWxsT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5zdHJva2VPcGFjaXR5ID0gZm9ybWF0LnN0cm9rZU9wYWNpdHk7XG4gICAgICBzZWN0b3IubGluZURhc2ggPSBmb3JtYXQubGluZURhc2g7XG4gICAgICBzZWN0b3IubGluZURhc2hPZmZzZXQgPSBmb3JtYXQubGluZURhc2hPZmZzZXQ7XG4gICAgICBzZWN0b3IuY29ybmVyUmFkaXVzID0gZm9ybWF0LmNvcm5lclJhZGl1cztcbiAgICAgIHNlY3Rvci5maWxsU2hhZG93ID0gdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdztcbiAgICAgIGNvbnN0IGluc2V0ID0gTWF0aC5tYXgoXG4gICAgICAgICh0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyArIChmb3JtYXQuc3Ryb2tlICE9IG51bGwgPyBmb3JtYXQuc3Ryb2tlV2lkdGggOiAwKSkgLyAyLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgc2VjdG9yLmluc2V0ID0gaW5zZXQ7XG4gICAgICBzZWN0b3IubGluZUpvaW4gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyA+PSAwIHx8IGluc2V0ID4gMCA/IFwibWl0ZXJcIiA6IFwicm91bmRcIjtcbiAgICB9O1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgdHJ1ZSk7XG4gICAgICBpZiAoZGF0dW0uaXRlbUlkID09PSBoaWdobGlnaHRlZERhdHVtPy5pdGVtSWQpIHtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpO1xuICAgIHRoaXMudXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlWmVyb3N1bVJpbmdzKCk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgY2FsbG91dFN0cm9rZVdpZHRoID0gY2FsbG91dExpbmUuc3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgY2FsbG91dENvbG9ycyA9IGNhbGxvdXRMaW5lLmNvbG9ycyA/PyB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCB9ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbDtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygwIC8qIENhbGxvdXQgKi8pLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkYXR1bSA9IGxpbmUuZGF0dW07XG4gICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbDogbGFiZWwsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGlmIChsYWJlbD8udGV4dCAmJiAhbGFiZWwuaGlkZGVuICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSBjYWxsb3V0U3Ryb2tlV2lkdGg7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gY2FsbG91dENvbG9yc1tpbmRleCAlIGNhbGxvdXRDb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgbGluZS5maWxsID0gdm9pZCAwO1xuICAgICAgICBjb25zdCB4MSA9IGRhdHVtLm1pZENvcyAqIG91dGVyUmFkaXVzO1xuICAgICAgICBjb25zdCB5MSA9IGRhdHVtLm1pZFNpbiAqIG91dGVyUmFkaXVzO1xuICAgICAgICBsZXQgeDIgPSBkYXR1bS5taWRDb3MgKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgbGV0IHkyID0gZGF0dW0ubWlkU2luICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGlzTW92ZWQgPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMDtcbiAgICAgICAgaWYgKGlzTW92ZWQgJiYgbGFiZWwuYm94ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBib3ggPSBsYWJlbC5ib3g7XG4gICAgICAgICAgbGV0IGN4ID0geDI7XG4gICAgICAgICAgbGV0IGN5ID0geTI7XG4gICAgICAgICAgaWYgKHgyIDwgYm94LngpIHtcbiAgICAgICAgICAgIGN4ID0gYm94Lng7XG4gICAgICAgICAgfSBlbHNlIGlmICh4MiA+IGJveC54ICsgYm94LndpZHRoKSB7XG4gICAgICAgICAgICBjeCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeTIgPCBib3gueSkge1xuICAgICAgICAgICAgY3kgPSBib3gueTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkyID4gYm94LnkgKyBib3guaGVpZ2h0KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZHggPSBjeCAtIHgyO1xuICAgICAgICAgIGNvbnN0IGR5ID0gY3kgLSB5MjtcbiAgICAgICAgICBjb25zdCBsZW5ndGgyID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG4gICAgICAgICAgY29uc3QgcGFkZGVkTGVuZ3RoID0gbGVuZ3RoMiAtIG9mZnNldDQ7XG4gICAgICAgICAgaWYgKHBhZGRlZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHgyID0geDIgKyBkeCAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgICB5MiA9IHkyICsgZHkgKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lLngxID0geDE7XG4gICAgICAgIGxpbmUueTEgPSB5MTtcbiAgICAgICAgbGluZS54MiA9IHgyO1xuICAgICAgICBsaW5lLnkyID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRMYWJlbE92ZXJmbG93KHRleHQsIGJveCwgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHNlcmllc0xlZnQgPSBzZXJpZXNSZWN0LnggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzUmlnaHQgPSBzZXJpZXNSZWN0LnggKyBzZXJpZXNSZWN0LndpZHRoIC0gdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1RvcCA9IHNlcmllc1JlY3QueSAtIHRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBzZXJpZXNCb3R0b20gPSBzZXJpZXNSZWN0LnkgKyBzZXJpZXNSZWN0LmhlaWdodCAtIHRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBlcnJQeCA9IDE7XG4gICAgbGV0IHZpc2libGVUZXh0UGFydCA9IDE7XG4gICAgaWYgKGJveC54ICsgZXJyUHggPCBzZXJpZXNMZWZ0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoYm94LnggKyBib3gud2lkdGggLSBzZXJpZXNMZWZ0KSAvIGJveC53aWR0aDtcbiAgICB9IGVsc2UgaWYgKGJveC54ICsgYm94LndpZHRoIC0gZXJyUHggPiBzZXJpZXNSaWdodCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKHNlcmllc1JpZ2h0IC0gYm94LngpIC8gYm94LndpZHRoO1xuICAgIH1cbiAgICBjb25zdCBoYXNWZXJ0aWNhbE92ZXJmbG93ID0gYm94LnkgKyBlcnJQeCA8IHNlcmllc1RvcCB8fCBib3gueSArIGJveC5oZWlnaHQgLSBlcnJQeCA+IHNlcmllc0JvdHRvbTtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdmlzaWJsZVRleHRQYXJ0ID09PSAxID8gdGV4dC5sZW5ndGggOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoICogdmlzaWJsZVRleHRQYXJ0KSAtIDE7XG4gICAgY29uc3QgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyA9IHRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gpO1xuICAgIHJldHVybiB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfTtcbiAgfVxuICBiYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCwgZHggPSAwLCBkeSA9IDApIHtcbiAgICBjb25zdCB7IHN1cnJvdW5kaW5nUmFkaXVzIH0gPSB0aGlzO1xuICAgIGlmIChzdXJyb3VuZGluZ1JhZGl1cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICB7IHg6IGJveC54ICsgZHgsIHk6IGJveC55ICsgZHkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGggKyBkeCwgeTogYm94LnkgKyBkeSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCArIGR4LCB5OiBib3gueSArIGJveC5oZWlnaHQgKyBkeSB9LFxuICAgICAgeyB4OiBib3gueCArIGR4LCB5OiBib3gueSArIGJveC5oZWlnaHQgKyBkeSB9XG4gICAgXTtcbiAgICBjb25zdCBzdXIyID0gc3Vycm91bmRpbmdSYWRpdXMgKiogMjtcbiAgICByZXR1cm4gY29ybmVycy5zb21lKChjb3JuZXIpID0+IGNvcm5lci54ICoqIDIgKyBjb3JuZXIueSAqKiAyID4gc3VyMik7XG4gIH1cbiAgY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIHJldHVybiAhbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDA7XG4gICAgfTtcbiAgICBjb25zdCBmdWxsRGF0YSA9IHRoaXMuY2FsbG91dE5vZGVEYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdWxsRGF0YS5maWx0ZXIoKHQpID0+ICFzaG91bGRTa2lwKHQpKTtcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IHZvaWQgMDtcbiAgICAgIGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSAwO1xuICAgIH0pO1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZnRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPCAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCByaWdodExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA+PSAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCB0b3BMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPCAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGJvdHRvbUxhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA+PSAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGdldFRleHRCQm94ID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gQkJveC56ZXJvLmNsb25lKCk7XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExpbmUubGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduO1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgcmV0dXJuIFRleHQuY29tcHV0ZUJCb3gobGFiZWwudGV4dCwgeCwgeSwge1xuICAgICAgICBmb250OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZE5laWdoYm91cllDb2xsaXNpb24gPSAobGFiZWwsIG5leHQsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgYm94ID0gZ2V0VGV4dEJCb3gobGFiZWwpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3Qgb3RoZXIgPSBnZXRUZXh0QkJveChuZXh0KS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVzT3JCZWhpbmQgPSBib3gueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiBib3gueCArIGJveC53aWR0aCA+IG90aGVyLnggJiYgKGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCA+IG90aGVyLnkpO1xuICAgICAgaWYgKGNvbGxpZGVzT3JCZWhpbmQpIHtcbiAgICAgICAgY29uc3QgZHkgPSBkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSAtIG90aGVyLnkgLSBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgLSBvdGhlci55O1xuICAgICAgICBuZXh0LmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gZHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFlDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbWlkTGFiZWwgPSBsYWJlbHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhLm1pZFNpbikgLSBNYXRoLmFicyhiLm1pZFNpbikpWzBdO1xuICAgICAgY29uc3QgbWlkSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtaWRMYWJlbCk7XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tdG9wXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4ICsgMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tYm90dG9tXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRYQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgPSBkYXRhLnNvbWUoKGRhdHVtKSA9PiBkYXR1bS5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMCk7XG4gICAgICBjb25zdCBib3hlcyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiBnZXRUZXh0QkJveChsYWJlbCkpO1xuICAgICAgY29uc3QgcGFkZGVkQm94ZXMgPSBib3hlcy5tYXAoKGJveCkgPT4gYm94LmNsb25lKCkuZ3JvdyhtaW5TcGFjaW5nIC8gMikpO1xuICAgICAgbGV0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQm94ZXMubGVuZ3RoICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYOyBpKyspIHtcbiAgICAgICAgY29uc3QgYm94ID0gcGFkZGVkQm94ZXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxhYmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFkZGVkQm94ZXNbal07XG4gICAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3gob3RoZXIpKSB7XG4gICAgICAgICAgICBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VjdG9ycyA9IGZ1bGxEYXRhLm1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVTZWN0b3JzID0gYm94ZXMuc29tZSgoYm94KSA9PiB7XG4gICAgICAgIHJldHVybiBzZWN0b3JzLnNvbWUoKHNlY3RvcikgPT4gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlZICYmICFsYWJlbHNDb2xsaWRlU2VjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYWJlbHMuZmlsdGVyKChkKSA9PiBkLmNhbGxvdXRMYWJlbC50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkLmNhbGxvdXRMYWJlbDtcbiAgICAgICAgaWYgKGQubWlkQ29zIDwgMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChkLm1pZENvcyA+IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGF2b2lkWUNvbGxpc2lvbnMobGVmdExhYmVscyk7XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhyaWdodExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyh0b3BMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnMoYm90dG9tTGFiZWxzKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBjb2xvciB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IHRlbXBUZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMSAvKiBMYWJlbCAqLykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSB9ID0gdGV4dDtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydChkYXR1bS5yYWRpdXMpO1xuICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCByYWRpdXMpO1xuICAgICAgaWYgKCFsYWJlbD8udGV4dCB8fCBvdXRlclJhZGl1cyA9PT0gMCB8fCBsYWJlbC5oaWRkZW4pIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gb3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCBhbGlnbiA9IHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICAgIHRlbXBUZXh0Tm9kZS50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRlbXBUZXh0Tm9kZS54ID0geDtcbiAgICAgIHRlbXBUZXh0Tm9kZS55ID0geTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGVtcFRleHROb2RlLnNldEFsaWduKGFsaWduKTtcbiAgICAgIGNvbnN0IGJveCA9IHRlbXBUZXh0Tm9kZS5nZXRCQm94KCk7XG4gICAgICBsZXQgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xuICAgICAgaWYgKGNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3cobGFiZWwudGV4dCwgYm94LCBzZXJpZXNSZWN0KTtcbiAgICAgICAgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA9PT0gdGV4dExlbmd0aCA/IGxhYmVsLnRleHQgOiBgJHtsYWJlbC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0TGVuZ3RoKX1cXHUyMDI2YDtcbiAgICAgICAgdmlzaWJsZSA9ICFoYXNWZXJ0aWNhbE92ZXJmbG93O1xuICAgICAgfVxuICAgICAgdGV4dC50ZXh0ID0gZGlzcGxheVRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0LnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbXB1dGVMYWJlbHNCQm94KG9wdGlvbnMsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtYXhDb2xsaXNpb25PZmZzZXQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShmYWxzZSk7XG4gICAgdGhpcy5jb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpO1xuICAgIGNvbnN0IHRleHRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgIGxldCB0aXRsZUJveDtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKHRpdGxlPy50ZXh0ICYmIHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICB0ZXh0LnRleHQgPSB0aXRsZS50ZXh0O1xuICAgICAgICB0ZXh0LnggPSAwO1xuICAgICAgICB0ZXh0LnkgPSBkeTtcbiAgICAgICAgdGV4dC5zZXRGb250KHRpdGxlKTtcbiAgICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVCb3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgdGV4dEJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxvdXROb2RlRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAoIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgbGFiZWwuYm94ID0gYm94O1xuICAgICAgaWYgKE1hdGguYWJzKGxhYmVsLmNvbGxpc2lvbk9mZnNldFkpID4gbWF4Q29sbGlzaW9uT2Zmc2V0KSB7XG4gICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgICAgIGNvbnN0IHRpdGxlQ2xlYW5BcmVhID0gbmV3IEJCb3goXG4gICAgICAgICAgdGl0bGVCb3gueCAtIG1pblNwYWNpbmcsXG4gICAgICAgICAgc2VyaWVzVG9wLFxuICAgICAgICAgIHRpdGxlQm94LndpZHRoICsgMiAqIG1pblNwYWNpbmcsXG4gICAgICAgICAgdGl0bGVCb3gueSArIHRpdGxlQm94LmhlaWdodCArIG1pblNwYWNpbmcgLSBzZXJpZXNUb3BcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3godGl0bGVDbGVhbkFyZWEpKSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhpZGVXaGVuTmVjZXNzYXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KFxuICAgICAgICAgIGxhYmVsLnRleHQsXG4gICAgICAgICAgYm94LFxuICAgICAgICAgIHNlcmllc1JlY3RcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNUb29TaG9ydCA9IGxhYmVsLnRleHQubGVuZ3RoID4gMiAmJiB0ZXh0TGVuZ3RoIDwgMjtcbiAgICAgICAgaWYgKGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfHwgaXNUb29TaG9ydCB8fCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93KSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGV4dEJveGVzLnB1c2goYm94KTtcbiAgICB9KTtcbiAgICBpZiAodGV4dEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKHRleHRCb3hlcyk7XG4gIH1cbiAgdXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCB7IGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIHBvc2l0aW9uT2Zmc2V0LCBwb3NpdGlvblJhdGlvLCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsO1xuICAgIGNvbnN0IGlzRG9udXQgPSBpbm5lclJhZGl1cyA+IDA7XG4gICAgY29uc3Qgc2luZ2xlVmlzaWJsZVNlY3RvciA9IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuZmlsdGVyKEJvb2xlYW4pLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JMYWJlbCA9ICh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBkYXR1bTtcbiAgICAgIGxldCBpc1RleHRWaXNpYmxlID0gZmFsc2U7XG4gICAgICBpZiAoc2VjdG9yTGFiZWwgJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBpbm5lclJhZGl1cyAqICgxIC0gcG9zaXRpb25SYXRpbykgKyBvdXRlclJhZGl1cyAqIHBvc2l0aW9uUmF0aW8gKyBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dCA9IHNlY3RvckxhYmVsLnRleHQ7XG4gICAgICAgIGNvbnN0IHNob3VsZFB1dFRleHRJbkNlbnRlciA9ICFpc0RvbnV0ICYmIHNpbmdsZVZpc2libGVTZWN0b3I7XG4gICAgICAgIGlmIChzaG91bGRQdXRUZXh0SW5DZW50ZXIpIHtcbiAgICAgICAgICB0ZXh0LnggPSAwO1xuICAgICAgICAgIHRleHQueSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dC54ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICAgICAgdGV4dC55ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIGNvbnN0IGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgICAgICBbYmJveC54LCBiYm94LnldLFxuICAgICAgICAgIFtiYm94LnggKyBiYm94LndpZHRoLCBiYm94LnldLFxuICAgICAgICAgIFtiYm94LnggKyBiYm94LndpZHRoLCBiYm94LnkgKyBiYm94LmhlaWdodF0sXG4gICAgICAgICAgW2Jib3gueCwgYmJveC55ICsgYmJveC5oZWlnaHRdXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNlY3RvckJvdW5kcyA9IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgICBpZiAoY29ybmVycy5ldmVyeSgoW3gsIHldKSA9PiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yQm91bmRzKSkpIHtcbiAgICAgICAgICBpc1RleHRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dC52aXNpYmxlID0gaXNUZXh0VmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgfVxuICB1cGRhdGVaZXJvc3VtUmluZ3MoKSB7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnNpemUgPSB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICB9XG4gIGdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgY2FsbG91dExhYmVsLCBsZWdlbmRJdGVtIH0gPSBub2RlRGF0dW07XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVnZW5kSXRlbS50ZXh0O1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjYWxsb3V0TGFiZWwudGV4dDtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBzZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc2VjdG9yTGFiZWwudGV4dDtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gcGlja0J5TWF0Y2hpbmdBbmdsZSh0aGlzLCBwb2ludCk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgZmlsbDogY29sb3IgfSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwodGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy50ZXh0KTtcbiAgICBjb25zdCBjb250ZW50ID0gaXNGaW5pdGVOdW1iZXIoYW5nbGVWYWx1ZSkgPyB0b0ZpeGVkKGFuZ2xlVmFsdWUpIDogU3RyaW5nKGFuZ2xlVmFsdWUpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSk7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSA/PyBsYWJlbFRleHQsXG4gICAgICAgIGNvbnRlbnQ6IHRpdGxlICYmIGxhYmVsVGV4dCA/IGAke2xhYmVsVGV4dH06ICR7Y29udGVudH1gIDogY29udGVudCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHZpc2libGUsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YT8uZGF0YS5sZW5ndGggfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWxlZ2VuZEl0ZW1LZXkgJiYgKCFjYWxsb3V0TGFiZWxLZXkgfHwgY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSkgJiYgKCFzZWN0b3JMYWJlbEtleSB8fCBzZWN0b3JMYWJlbEtleSA9PT0gYW5nbGVLZXkpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsSWR4LCBzZWN0b3JMYWJlbElkeCwgbGVnZW5kSXRlbUlkeCB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHRpdGxlVGV4dCA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc2hvd0luTGVnZW5kICYmIHRoaXMucHJvcGVydGllcy50aXRsZS50ZXh0O1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29uc3QgbGFiZWxQYXJ0cyA9IFtdO1xuICAgICAgaWYgKHRpdGxlVGV4dCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2godGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxhYmVscy5sZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5sZWdlbmRJdGVtLnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxQYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBsZWdlbmREYXRhLnB1c2goe1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFBhcnRzLmpvaW4oXCIgLSBcIilcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBmaWxsOiBzZWN0b3JGb3JtYXQuZmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzZWN0b3JGb3JtYXQuc3Ryb2tlLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWU6IGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCA/IGRhdHVtW2xlZ2VuZEl0ZW1LZXldIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZERhdGE7XG4gIH1cbiAgb25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBsZWdlbmRJdGVtTmFtZSB9ID0gZXZlbnQ7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgfSBlbHNlIGlmIChsZWdlbmRJdGVtTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCkge1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaXRlbUlkXSA9IGVuYWJsZWQ7XG4gICAgaWYgKHRoaXMubm9kZURhdGFbaXRlbUlkXSkge1xuICAgICAgdGhpcy5ub2RlRGF0YVtpdGVtSWRdLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gIH1cbiAgdG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhsZWdlbmRJdGVtTmFtZSwgZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgfHwgIXRoaXMuZGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZ2VuZEl0ZW1JZHggPSB0aGlzLmRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCk7XG4gICAgdGhpcy5wcm9jZXNzZWREYXRhPy5kYXRhLmZvckVhY2goKHsgdmFsdWVzIH0sIGRhdHVtSXRlbUlkKSA9PiB7XG4gICAgICBpZiAodmFsdWVzW2xlZ2VuZEl0ZW1JZHhdID09PSBsZWdlbmRJdGVtTmFtZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oZGF0dW1JdGVtSWQsIGVuYWJsZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgdHJ1ZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHRoaXMucmFkaXVzU2NhbGUsXG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW3RoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24sIHRoaXMucGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSlcbiAgICApO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCBwcm9jZXNzZWREYXRhLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGRhdGFEaWZmID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZjtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkRGlmZiA9IChkYXRhRGlmZj8ubW92ZWQuc2l6ZSA/PyAwKSA9PT0gMDtcbiAgICBjb25zdCBoYXNLZXlzID0gKHByb2Nlc3NlZERhdGE/LmRlZnMua2V5cy5sZW5ndGggPz8gMCkgPiAwO1xuICAgIGNvbnN0IGhhc1VuaXF1ZUtleXMgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzID8/IHRydWU7XG4gICAgaWYgKCFzdXBwb3J0ZWREaWZmIHx8ICFoYXNLZXlzIHx8ICFoYXNVbmlxdWVLZXlzKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eSgpIHtcbiAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbiwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIHByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2l0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSlcbiAgICApO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBnZXREYXR1bUlkRnJvbURhdGEoZGF0dW0pIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2xlZ2VuZEl0ZW1LZXldO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bY2FsbG91dExhYmVsS2V5XTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bc2VjdG9yTGFiZWxLZXldO1xuICAgIH1cbiAgfVxuICBnZXREYXR1bUlkKGRhdHVtKSB7XG4gICAgY29uc3QgeyBpbmRleCB9ID0gZGF0dW07XG4gICAgY29uc3QgZGF0dW1JZCA9IHRoaXMuZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtLmRhdHVtKTtcbiAgICByZXR1cm4gZGF0dW1JZCAhPSBudWxsID8gU3RyaW5nKGRhdHVtSWQpIDogYCR7aW5kZXh9YDtcbiAgfVxuICBvbkRhdGFDaGFuZ2UoKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXJpZXNJdGVtRW5hYmxlZCB9ID0gdGhpcztcbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkID0gZGF0YT8ubWFwKChfLCBpbmRleCkgPT4gc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdID8/IHRydWUpID8/IFtdO1xuICB9XG59O1xuUGllU2VyaWVzLmNsYXNzTmFtZSA9IFwiUGllU2VyaWVzXCI7XG5QaWVTZXJpZXMudHlwZSA9IFwicGllXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVTZXJpZXNNb2R1bGUudHNcbnZhciBQaWVTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLFxuICBpZGVudGlmaWVyOiBcInBpZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgUGllU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIHRoZW1lVGVtcGxhdGU6IHBpZVRoZW1lLFxuICBwYWxldHRlRmFjdG9yeTogcGllUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhclByb3BlcnRpZXMudHNcbnZhciBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKG9uQ2hhbmdlLCBvbkJ1dHRvbnNDaGFuZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICB0aGlzLm9uQnV0dG9uc0NoYW5nZSA9IG9uQnV0dG9uc0NoYW5nZTtcbiAgICB0aGlzLmFsaWduID0gXCJzdGFydFwiO1xuICAgIHRoaXMucG9zaXRpb24gPSBcInRvcFwiIC8qIFRvcCAqLztcbiAgICB0aGlzLnNpemUgPSBcIm5vcm1hbFwiO1xuICAgIHRoaXMuYnV0dG9uT3ZlcnJpZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBidXR0b25Db25maWd1cmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5idXR0b25zPy5tYXAoKGJ1dHRvbikgPT4ge1xuICAgICAgY29uc3QgaWQgPSBidXR0b24uaWQgPz8gYnV0dG9uLnZhbHVlO1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gdGhpcy5idXR0b25PdmVycmlkZXMuZ2V0KGlkKTtcbiAgICAgIHJldHVybiBvdmVycmlkZXMgIT0gbnVsbCA/IHsgLi4uYnV0dG9uLCAuLi5vdmVycmlkZXMgfSA6IGJ1dHRvbjtcbiAgICB9KSA/PyBbXTtcbiAgfVxuICBidXR0b25zQ2hhbmdlZChjb25maWd1cmF0aW9uT25seSkge1xuICAgIHRoaXMub25CdXR0b25zQ2hhbmdlKHRoaXMuYnV0dG9uQ29uZmlndXJhdGlvbnMoKSwgY29uZmlndXJhdGlvbk9ubHkpO1xuICB9XG4gIG92ZXJyaWRlQnV0dG9uQ29uZmlndXJhdGlvbihpZCwgb3B0aW9ucykge1xuICAgIGxldCBvdmVycmlkZXMgPSB0aGlzLmJ1dHRvbk92ZXJyaWRlcy5nZXQoaWQpO1xuICAgIGlmIChvdmVycmlkZXMgPT0gbnVsbCkge1xuICAgICAgb3ZlcnJpZGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmJ1dHRvbk92ZXJyaWRlcy5zZXQoaWQsIG92ZXJyaWRlcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ZlcnJpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5idXR0b25zQ2hhbmdlZCh0cnVlKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0Lm9uQ2hhbmdlKHRhcmdldC5lbmFibGVkKTtcbiAgfSksXG4gIFZhbGlkYXRlKFVOSU9OKFsuLi5UT09MQkFSX0FMSUdOTUVOVFNdKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYWxpZ25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0Lm9uQ2hhbmdlKHRhcmdldC5lbmFibGVkKTtcbiAgfSksXG4gIFZhbGlkYXRlKFVOSU9OKFRPT0xCQVJfUE9TSVRJT05TKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0Lm9uQ2hhbmdlKHRhcmdldC5lbmFibGVkKTtcbiAgfSksXG4gIFZhbGlkYXRlKFVOSU9OKFtcInNtYWxsXCIsIFwibm9ybWFsXCJdKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0YXJnZXQuYnV0dG9ucyA/PyBbXSkge1xuICAgICAgaWYgKGJ1dHRvbi5pY29uICE9IG51bGwgJiYgSUNPTlNfTEVHQUNZLmluY2x1ZGVzKGJ1dHRvbi5pY29uKSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYEljb24gJyR7YnV0dG9uLmljb259JyBpcyBkZXByZWNhdGVkLCB1c2UgYW5vdGhlciBpY29uIGluc3RlYWQuYCk7XG4gICAgICB9XG4gICAgICBpZiAoYnV0dG9uLmFyaWFMYWJlbCA9PT0gXCJ0b29sYmFyQW5ub3RhdGlvbnNDb2xvclwiKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgQXJpYSBsYWJlbCAnJHtidXR0b24uYXJpYUxhYmVsfScgaXMgZGVwcmVjYXRlZCwgdXNlICd0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3InIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQuYnV0dG9uc0NoYW5nZWQoZmFsc2UpO1xuICB9KSxcbiAgVmFsaWRhdGUoQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcImJ1dHRvbnNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhclN0eWxlcy50c1xudmFyIGJsb2NrMiA9IFwiYWctY2hhcnRzLXRvb2xiYXJcIjtcbnZhciBlbGVtZW50czIgPSB7XG4gIGFsaWduOiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnblwiLFxuICBzZWN0aW9uOiBcImFnLWNoYXJ0cy10b29sYmFyX19zZWN0aW9uXCIsXG4gIGJ1dHRvbjogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uXCIsXG4gIGljb246IFwiYWctY2hhcnRzLXRvb2xiYXJfX2ljb25cIixcbiAgbGFiZWw6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2xhYmVsXCJcbn07XG52YXIgbW9kaWZpZXJzMiA9IHtcbiAgW1widG9wXCIgLyogVG9wICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tdG9wXCIsXG4gIFtcInJpZ2h0XCIgLyogUmlnaHQgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1yaWdodFwiLFxuICBbXCJib3R0b21cIiAvKiBCb3R0b20gKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1ib3R0b21cIixcbiAgW1wibGVmdFwiIC8qIExlZnQgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0XCIsXG4gIFtcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZ1wiLFxuICBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcFwiLFxuICBbXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbVwiLFxuICBzbWFsbDogXCJhZy1jaGFydHMtdG9vbGJhci0tc21hbGxcIixcbiAgbm9ybWFsOiBcImFnLWNoYXJ0cy10b29sYmFyLS1ub3JtYWxcIixcbiAgaGlkZGVuOiBcImFnLWNoYXJ0cy10b29sYmFyLS1oaWRkZW5cIixcbiAgcHJldmVudEZsYXNoOiBcImFnLWNoYXJ0cy10b29sYmFyLS1wcmV2ZW50LWZsYXNoXCIsXG4gIGZsb2F0aW5nSGlkZGVuOiBcImFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1oaWRkZW5cIixcbiAgYWxpZ246IHtcbiAgICBzdGFydDogXCJhZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLXN0YXJ0XCIsXG4gICAgY2VudGVyOiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyXCIsXG4gICAgZW5kOiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5kXCJcbiAgfSxcbiAgYnV0dG9uOiB7XG4gICAgYWN0aXZlOiBgYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tYWN0aXZlYCxcbiAgICBoaWRkZW5WYWx1ZTogYGFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi12YWx1ZWAsXG4gICAgaGlkZGVuVG9nZ2xlZDogYGFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVkYCxcbiAgICBmaWxsVmlzaWJsZTogYGFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpbGwtdmlzaWJsZWBcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyLnRzXG52YXIgVG9vbGJhciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2VyaWVzVHlwZSA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwic2VyaWVzVHlwZVwiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJzZXJpZXNUeXBlXCIpXG4gICAgKTtcbiAgICB0aGlzLmFubm90YXRpb25zID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJhbm5vdGF0aW9uc1wiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJhbm5vdGF0aW9uc1wiKVxuICAgICk7XG4gICAgdGhpcy5hbm5vdGF0aW9uT3B0aW9ucyA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbk9wdGlvbnNcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbk9wdGlvbnNcIilcbiAgICApO1xuICAgIHRoaXMucmFuZ2VzID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJyYW5nZXNcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwicmFuZ2VzXCIpXG4gICAgKTtcbiAgICB0aGlzLnpvb20gPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcInpvb21cIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwiem9vbVwiKVxuICAgICk7XG4gICAgdGhpcy5ob3Jpem9udGFsU3BhY2luZyA9IDEwO1xuICAgIHRoaXMudmVydGljYWxTcGFjaW5nID0gMTA7XG4gICAgdGhpcy5mbG9hdGluZ0RldGVjdGlvblJhbmdlID0gMzg7XG4gICAgdGhpcy5wb3NpdGlvbnMgPSB7XG4gICAgICBbXCJ0b3BcIiAvKiBUb3AgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wicmlnaHRcIiAvKiBSaWdodCAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJib3R0b21cIiAvKiBCb3R0b20gKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wibGVmdFwiIC8qIExlZnQgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHRoaXMucG9zaXRpb25BbGlnbm1lbnRzID0ge1xuICAgICAgW1widG9wXCIgLyogVG9wICovXToge30sXG4gICAgICBbXCJyaWdodFwiIC8qIFJpZ2h0ICovXToge30sXG4gICAgICBbXCJib3R0b21cIiAvKiBCb3R0b20gKi9dOiB7fSxcbiAgICAgIFtcImxlZnRcIiAvKiBMZWZ0ICovXToge30sXG4gICAgICBbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXToge30sXG4gICAgICBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqL106IHt9LFxuICAgICAgW1wiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dOiB7fVxuICAgIH07XG4gICAgdGhpcy5ncm91cENhbGxlcnMgPSB7XG4gICAgICBzZXJpZXNUeXBlOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgYW5ub3RhdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBhbm5vdGF0aW9uT3B0aW9uczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHJhbmdlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHpvb206IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHRoaXMuZ3JvdXBCdXR0b25zID0ge1xuICAgICAgc2VyaWVzVHlwZTogW10sXG4gICAgICBhbm5vdGF0aW9uczogW10sXG4gICAgICBhbm5vdGF0aW9uT3B0aW9uczogW10sXG4gICAgICByYW5nZXM6IFtdLFxuICAgICAgem9vbTogW11cbiAgICB9O1xuICAgIHRoaXMuYXJpYVRvb2xiYXJzID0gW1xuICAgICAgeyBncm91cHM6IFtcInNlcmllc1R5cGVcIiwgXCJhbm5vdGF0aW9uc1wiXSwgZGVzdHJveUZuczogW10gfSxcbiAgICAgIHsgZ3JvdXBzOiBbXCJhbm5vdGF0aW9uT3B0aW9uc1wiXSwgZGVzdHJveUZuczogW10gfSxcbiAgICAgIHsgZ3JvdXBzOiBbXCJyYW5nZXNcIl0sIGRlc3Ryb3lGbnM6IFtdIH0sXG4gICAgICB7IGdyb3VwczogW1wiem9vbVwiXSwgZGVzdHJveUZuczogW10gfVxuICAgIF07XG4gICAgdGhpcy5wZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBQcm94aWVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhc05ld0xvY2FsZSA9IHRydWU7XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbcG9zaXRpb25dID0gY3R4LmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBgdG9vbGJhci0ke3Bvc2l0aW9ufWApO1xuICAgICAgdGhpcy5lbGVtZW50c1twb3NpdGlvbl0ucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICB0aGlzLnJlbmRlclRvb2xiYXIocG9zaXRpb24pO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIHRoaXMub25Ib3Zlci5iaW5kKHRoaXMpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgY3R4LmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImxlYXZlXCIsIHRoaXMub25MZWF2ZS5iaW5kKHRoaXMpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYnV0dG9uLXRvZ2dsZWRcIiwgdGhpcy5vbkJ1dHRvblRvZ2dsZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJidXR0b24tdXBkYXRlZFwiLCB0aGlzLm9uQnV0dG9uVXBkYXRlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImdyb3VwLXRvZ2dsZWRcIiwgdGhpcy5vbkdyb3VwVG9nZ2xlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImZsb2F0aW5nLWFuY2hvci1jaGFuZ2VkXCIsIHRoaXMub25GbG9hdGluZ0FuY2hvckNoYW5nZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJwcm94eS1ncm91cC1vcHRpb25zXCIsIHRoaXMub25Qcm94eUdyb3VwT3B0aW9ucy5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIHRoaXMub25MYXlvdXRDb21wbGV0ZS5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmhhc05ld0xvY2FsZSA9IHRydWU7XG4gICAgICB9KSxcbiAgICAgICgpID0+IHRoaXMuZGVzdHJveUVsZW1lbnRzKClcbiAgICApO1xuICB9XG4gIGRlc3Ryb3lFbGVtZW50cygpIHtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhibG9jazIpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudDIgb2YgT2JqZWN0LmtleXModGhpcy5lbGVtZW50cykpIHtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBgdG9vbGJhci0ke2VsZW1lbnQyfWApO1xuICAgIH1cbiAgfVxuICBvbkhvdmVyKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlZCxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50czMsXG4gICAgICBmbG9hdGluZ0RldGVjdGlvblJhbmdlLFxuICAgICAgY3R4OiB7IHNjZW5lIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRZLFxuICAgICAgc291cmNlRXZlbnQ6IHsgdGFyZ2V0IH1cbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBGbG9hdGluZ0JvdHRvbSwgRmxvYXRpbmdUb3AgfSA9IFRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAoIWVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYm90dG9tID0gZWxlbWVudHMzW0Zsb2F0aW5nQm90dG9tXTtcbiAgICBjb25zdCB0b3AgPSBlbGVtZW50czNbRmxvYXRpbmdUb3BdO1xuICAgIGNvbnN0IGJvdHRvbURldGVjdGlvblkgPSBib3R0b20ub2Zmc2V0VG9wIC0gZmxvYXRpbmdEZXRlY3Rpb25SYW5nZTtcbiAgICBjb25zdCBib3R0b21WaXNpYmxlID0gb2Zmc2V0WSA+IGJvdHRvbURldGVjdGlvblkgJiYgb2Zmc2V0WSA8IHNjZW5lLmNhbnZhcy5lbGVtZW50Lm9mZnNldEhlaWdodCB8fCB0YXJnZXQgPT09IGJvdHRvbTtcbiAgICBjb25zdCB0b3BEZXRlY3Rpb25ZID0gdG9wLm9mZnNldFRvcCArIHRvcC5vZmZzZXRIZWlnaHQgKyBmbG9hdGluZ0RldGVjdGlvblJhbmdlO1xuICAgIGNvbnN0IHRvcFZpc2libGUgPSBvZmZzZXRZID4gMCAmJiBvZmZzZXRZIDwgdG9wRGV0ZWN0aW9uWSB8fCB0YXJnZXQgPT09IHRvcDtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdCb3R0b20sIGJvdHRvbVZpc2libGUpO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ1RvcCwgdG9wVmlzaWJsZSk7XG4gIH1cbiAgb25MZWF2ZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVuYWJsZWQsXG4gICAgICBjdHg6IHsgc2NlbmUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgRmxvYXRpbmdCb3R0b20sIEZsb2F0aW5nVG9wIH0gPSBUb29sYmFyUG9zaXRpb247XG4gICAgaWYgKCFlbmFibGVkIHx8IHRhcmdldEVsZW1lbnQgIT09IHNjZW5lLmNhbnZhcy5lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzVGFyZ2V0QnV0dG9uID0gVE9PTEJBUl9HUk9VUFMuc29tZShcbiAgICAgIChncm91cCkgPT4gdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLnNvbWUoKGJ1dHRvbikgPT4gYnV0dG9uID09PSByZWxhdGVkRWxlbWVudClcbiAgICApO1xuICAgIGlmIChpc1RhcmdldEJ1dHRvbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdCb3R0b20sIGZhbHNlKTtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdUb3AsIGZhbHNlKTtcbiAgfVxuICBvbkdyb3VwQ2hhbmdlZChncm91cCkge1xuICAgIGlmICh0aGlzW2dyb3VwXSA9PSBudWxsIHx8IHRoaXMuZ3JvdXBQcm94aWVkLmhhcyhncm91cCkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jcmVhdGVHcm91cChncm91cCk7XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICBvbkdyb3VwQnV0dG9uc0NoYW5nZWQoZ3JvdXAsIGJ1dHRvbnMsIGNvbmZpZ3VyYXRpb25Pbmx5KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgdGhpcy5ncm91cFByb3hpZWQuaGFzKGdyb3VwKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY29uZmlndXJhdGlvbk9ubHkpIHtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uT3B0aW9ucyBvZiB0aGlzW2dyb3VwXS5idXR0b25Db25maWd1cmF0aW9ucygpKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaEJ1dHRvbkNvbnRlbnQoZ3JvdXAsIGJ1dHRvbk9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZUdyb3VwQnV0dG9ucyhncm91cCwgYnV0dG9ucyk7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgb25MYXlvdXRDb21wbGV0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXS5jbGFzc0xpc3QucmVtb3ZlKG1vZGlmaWVyczIucHJldmVudEZsYXNoKTtcbiAgICB9XG4gIH1cbiAgb25CdXR0b25VcGRhdGVkKGV2ZW50KSB7XG4gICAgY29uc3QgeyB0eXBlOiBfdHlwZSwgZ3JvdXAsIGlkLCAuLi5wYXJhbXMgfSA9IGV2ZW50O1xuICAgIHRoaXNbZ3JvdXBdLm92ZXJyaWRlQnV0dG9uQ29uZmlndXJhdGlvbihpZCwgeyAuLi5wYXJhbXMgfSk7XG4gIH1cbiAgc2V0QnV0dG9uQWN0aXZlKGJ1dHRvbiwgYWN0aXZlKSB7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzMi5idXR0b24uYWN0aXZlLCBhY3RpdmUpO1xuICB9XG4gIG9uQnV0dG9uVG9nZ2xlZChldmVudCkge1xuICAgIGNvbnN0IHsgZ3JvdXAsIGlkLCBhY3RpdmUsIGVuYWJsZWQsIHZpc2libGUgfSA9IGV2ZW50O1xuICAgIGlmICh0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgIGlmIChidXR0b24uZGF0YXNldC50b29sYmFySWQgIT09IGAke2lkfWApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgYnV0dG9uLmFyaWFEaXNhYmxlZCA9IGAkeyFlbmFibGVkfWA7XG4gICAgICBzZXRWaXNpYmlsaXR5KGJ1dHRvbiwgbW9kaWZpZXJzMi5idXR0b24uaGlkZGVuVG9nZ2xlZCwgIXZpc2libGUpO1xuICAgICAgdGhpcy5zZXRCdXR0b25BY3RpdmUoYnV0dG9uLCBhY3RpdmUpO1xuICAgIH1cbiAgfVxuICBvbkdyb3VwVG9nZ2xlZChldmVudCkge1xuICAgIGNvbnN0IHsgY2FsbGVyLCBncm91cCwgYWN0aXZlLCB2aXNpYmxlIH0gPSBldmVudDtcbiAgICB0aGlzLnRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgdmlzaWJsZSk7XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICBvbkZsb2F0aW5nQW5jaG9yQ2hhbmdlZChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50czMsXG4gICAgICBncm91cEJ1dHRvbnMsXG4gICAgICBwb3NpdGlvbnMsXG4gICAgICBob3Jpem9udGFsU3BhY2luZyxcbiAgICAgIHZlcnRpY2FsU3BhY2luZyxcbiAgICAgIGN0eDogeyBkb21NYW5hZ2VyLCB0b29sYmFyTWFuYWdlciB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBncm91cCwgYW5jaG9yIH0gPSBldmVudDtcbiAgICBpZiAoIXBvc2l0aW9uc1tcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dLmhhcyhncm91cCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudDIgPSBlbGVtZW50czNbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXTtcbiAgICBpZiAoZWxlbWVudDIuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVyczIuaGlkZGVuKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGFuY2hvci5wb3NpdGlvbiA/PyBcImFib3ZlXCI7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aDogd2lkdGgsIG9mZnNldEhlaWdodDogaGVpZ2h0IH0gPSBlbGVtZW50MjtcbiAgICBsZXQgdG9wID0gYW5jaG9yLnkgLSBoZWlnaHQgLSB2ZXJ0aWNhbFNwYWNpbmc7XG4gICAgbGV0IGxlZnQgPSBhbmNob3IueCAtIHdpZHRoIC8gMjtcbiAgICBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgdG9wID0gYW5jaG9yLnkgLSBoZWlnaHQgLyAyO1xuICAgICAgbGVmdCA9IGFuY2hvci54ICsgaG9yaXpvbnRhbFNwYWNpbmc7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJhYm92ZS1sZWZ0XCIpIHtcbiAgICAgIGxlZnQgPSBhbmNob3IueDtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdG9wID0gY2xhbXAoMCwgdG9wLCBjYW52YXNSZWN0LmhlaWdodCAtIGhlaWdodCk7XG4gICAgbGVmdCA9IGNsYW1wKDAsIGxlZnQsIGNhbnZhc1JlY3Qud2lkdGggLSB3aWR0aCk7XG4gICAgZWxlbWVudDIuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbiAgICBlbGVtZW50Mi5zdHlsZS5sZWZ0ID0gYCR7bGVmdH1weGA7XG4gICAgY29uc3QgZ3JvdXBCQm94ID0gbmV3IEJCb3gobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiBncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICBpZiAoYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMyLmJ1dHRvbi5oaWRkZW5Ub2dnbGVkKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBwYXJlbnQgPSBidXR0b24ub2Zmc2V0UGFyZW50O1xuICAgICAgdG9vbGJhck1hbmFnZXIuYnV0dG9uTW92ZWQoXG4gICAgICAgIGdyb3VwLFxuICAgICAgICBidXR0b24uZGF0YXNldC50b29sYmFySWQsXG4gICAgICAgIG5ldyBCQm94KFxuICAgICAgICAgIGJ1dHRvbi5vZmZzZXRMZWZ0ICsgKHBhcmVudD8ub2Zmc2V0TGVmdCA/PyAwKSxcbiAgICAgICAgICBidXR0b24ub2Zmc2V0VG9wICsgKHBhcmVudD8ub2Zmc2V0VG9wID8/IDApLFxuICAgICAgICAgIGJ1dHRvbi5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBidXR0b24ub2Zmc2V0SGVpZ2h0XG4gICAgICAgICksXG4gICAgICAgIGdyb3VwQkJveFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYnV0dG9uUmVjdChidXR0b24sIGNhbnZhc1JlY3QgPSB0aGlzLmN0eC5kb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB7XG4gICAgY29uc3QgYnV0dG9uUmVjdCA9IGJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gbmV3IEJCb3goXG4gICAgICBidXR0b25SZWN0LmxlZnQgLSBjYW52YXNSZWN0LmxlZnQsXG4gICAgICBidXR0b25SZWN0LnRvcCAtIGNhbnZhc1JlY3QudG9wLFxuICAgICAgYnV0dG9uUmVjdC53aWR0aCxcbiAgICAgIGJ1dHRvblJlY3QuaGVpZ2h0XG4gICAgKTtcbiAgfVxuICBvblByb3h5R3JvdXBPcHRpb25zKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjYWxsZXIsIGdyb3VwLCBvcHRpb25zIH0gPSBldmVudDtcbiAgICB0aGlzLmdyb3VwUHJveGllZC5zZXQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHRoaXNbZ3JvdXBdLnNldChvcHRpb25zKTtcbiAgICB0aGlzLnRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIHZvaWQgMCwgb3B0aW9ucy5lbmFibGVkKTtcbiAgICB0aGlzLmNyZWF0ZUdyb3VwKGdyb3VwLCBvcHRpb25zLmVuYWJsZWQsIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIGlmIChvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY3JlYXRlR3JvdXBCdXR0b25zKGdyb3VwLCBvcHRpb25zLmJ1dHRvbnMpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVHcm91cChncm91cCwgZW5hYmxlZCwgcG9zaXRpb24pIHtcbiAgICBlbmFibGVkID8/IChlbmFibGVkID0gdGhpc1tncm91cF0uZW5hYmxlZCk7XG4gICAgcG9zaXRpb24gPz8gKHBvc2l0aW9uID0gdGhpc1tncm91cF0ucG9zaXRpb24pO1xuICAgIGZvciAoY29uc3QgcG9zIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICBpZiAoZW5hYmxlZCAmJiBwb3NpdGlvbiA9PT0gcG9zKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zW3Bvc10uYWRkKGdyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zW3Bvc10uZGVsZXRlKGdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlR3JvdXBCdXR0b25zKGdyb3VwLCBidXR0b25zID0gW10pIHtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgIGJ1dHRvbi5yZW1vdmUoKTtcbiAgICB9XG4gICAgY29uc3QgYXJpYVRvb2xiYXIgPSB0aGlzLmdldEFyaWFUb29sYmFyKGdyb3VwKTtcbiAgICB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0gPSBbXTtcbiAgICBhcmlhVG9vbGJhci5kZXN0cm95Rm5zLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgYXJpYVRvb2xiYXIuZGVzdHJveUZucyA9IFtdO1xuICAgIGlmIChidXR0b25zLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGFsaWduLCBwb3NpdGlvbiB9ID0gdGhpc1tncm91cF07XG4gICAgY29uc3QgYWxpZ25FbGVtZW50ID0gdGhpcy5wb3NpdGlvbkFsaWdubWVudHNbcG9zaXRpb25dW2FsaWduXTtcbiAgICBpZiAoIWFsaWduRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXh0U2VjdGlvbiA9IChzZWN0aW9uMikgPT4ge1xuICAgICAgY29uc3QgYWxpZ25FbGVtZW50Q2hpbGRyZW4gPSBBcnJheS5mcm9tKGFsaWduRWxlbWVudC5jaGlsZHJlbik7XG4gICAgICBjb25zdCBkYXRhR3JvdXAgPSBcImRhdGEtZ3JvdXBcIjtcbiAgICAgIGNvbnN0IGRhdGFTZWN0aW9uID0gXCJkYXRhLXNlY3Rpb25cIjtcbiAgICAgIGxldCBzZWN0aW9uRWxlbWVudCA9IGFsaWduRWxlbWVudENoaWxkcmVuLmZpbmQoKHByZXZTZWN0aW9uMikgPT4ge1xuICAgICAgICByZXR1cm4gcHJldlNlY3Rpb24yLmdldEF0dHJpYnV0ZShkYXRhR3JvdXApID09PSBncm91cCAmJiBwcmV2U2VjdGlvbjIuZ2V0QXR0cmlidXRlKGRhdGFTZWN0aW9uKSA9PT0gKHNlY3Rpb24yID8/IFwiXCIpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc2VjdGlvbkVsZW1lbnQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LnNldEF0dHJpYnV0ZShkYXRhR3JvdXAsIGdyb3VwKTtcbiAgICAgICAgc2VjdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGFTZWN0aW9uLCBzZWN0aW9uMiA/PyBcIlwiKTtcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IFRPT0xCQVJfR1JPVVBfT1JERVJJTkdbZ3JvdXBdO1xuICAgICAgICBjb25zdCBpbnNlcnRCZWZvcmVFbGVtZW50ID0gYWxpZ25FbGVtZW50Q2hpbGRyZW4uZmluZCgocHJldlNlY3Rpb24yKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldkdyb3VwID0gcHJldlNlY3Rpb24yLmdldEF0dHJpYnV0ZShkYXRhR3JvdXApO1xuICAgICAgICAgIGNvbnN0IHByZXZHcm91cEluZGV4ID0gVE9PTEJBUl9HUk9VUF9PUkRFUklOR1twcmV2R3JvdXBdO1xuICAgICAgICAgIHJldHVybiBwcmV2R3JvdXBJbmRleCA+IGdyb3VwSW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxpZ25FbGVtZW50Lmluc2VydEJlZm9yZShzZWN0aW9uRWxlbWVudCwgaW5zZXJ0QmVmb3JlRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxpZ25FbGVtZW50LmFwcGVuZENoaWxkKHNlY3Rpb25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCgoKSA9PiBzZWN0aW9uRWxlbWVudC5yZW1vdmUoKSk7XG4gICAgICB9XG4gICAgICBzZWN0aW9uRWxlbWVudC5jbGFzc0xpc3QuYWRkKGVsZW1lbnRzMi5zZWN0aW9uLCBtb2RpZmllcnMyW3RoaXNbZ3JvdXBdLnNpemVdKTtcbiAgICAgIHJldHVybiBzZWN0aW9uRWxlbWVudDtcbiAgICB9O1xuICAgIGxldCBwcmV2U2VjdGlvbiA9IGJ1dHRvbnMuYXQoMCk/LnNlY3Rpb247XG4gICAgbGV0IHNlY3Rpb24gPSBuZXh0U2VjdGlvbihwcmV2U2VjdGlvbik7XG4gICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGJ1dHRvbnMpIHtcbiAgICAgIGlmIChwcmV2U2VjdGlvbiAhPT0gb3B0aW9ucy5zZWN0aW9uKSB7XG4gICAgICAgIHNlY3Rpb24gPSBuZXh0U2VjdGlvbihvcHRpb25zLnNlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcHJldlNlY3Rpb24gPSBvcHRpb25zLnNlY3Rpb247XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbkVsZW1lbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLnB1c2goYnV0dG9uKTtcbiAgICB9XG4gICAgY29uc3Qgb25Fc2NhcGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmN0eC50b29sYmFyTWFuYWdlci5jYW5jZWwoZ3JvdXApO1xuICAgIH07XG4gICAgbGV0IG9uRm9jdXM7XG4gICAgbGV0IG9uQmx1cjtcbiAgICBpZiAoaXNBbmltYXRpbmdGbG9hdGluZ1Bvc2l0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgb25Gb2N1cyA9ICgpID0+IHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhwb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBvbkJsdXIgPSAoKSA9PiB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMocG9zaXRpb24sIGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmNvbXB1dGVBcmlhT3JpZW50YXRpb24odGhpc1tncm91cF0ucG9zaXRpb24pO1xuICAgIGNvbnN0IGFyaWFUb29sYmFyQnV0dG9ucyA9IGFyaWFUb29sYmFyLmdyb3Vwcy5tYXAoKGcpID0+IHRoaXMuZ3JvdXBCdXR0b25zW2ddKS5mbGF0KCk7XG4gICAgYXJpYVRvb2xiYXIuZGVzdHJveUZucyA9IGluaXRUb29sYmFyS2V5TmF2KHtcbiAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgdG9vbGJhcjogYWxpZ25FbGVtZW50LFxuICAgICAgYnV0dG9uczogYXJpYVRvb2xiYXJCdXR0b25zLFxuICAgICAgb25Fc2NhcGUsXG4gICAgICBvbkZvY3VzLFxuICAgICAgb25CbHVyXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyQXJpYUxhYmVsKGdyb3VwLCBhbGlnbkVsZW1lbnQpO1xuICB9XG4gIGNvbXB1dGVBcmlhT3JpZW50YXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBcImhvcml6b250YWxcIixcbiAgICAgIHJpZ2h0OiBcInZlcnRpY2FsXCIsXG4gICAgICBib3R0b206IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgbGVmdDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgZmxvYXRpbmc6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgXCJmbG9hdGluZy10b3BcIjogXCJob3Jpem9udGFsXCIsXG4gICAgICBcImZsb2F0aW5nLWJvdHRvbVwiOiBcImhvcml6b250YWxcIlxuICAgIH1bcG9zaXRpb25dO1xuICB9XG4gIHRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgZW5hYmxlZCkge1xuICAgIGlmIChlbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmdyb3VwQ2FsbGVyc1tncm91cF0uYWRkKGNhbGxlcik7XG4gICAgfSBlbHNlIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5ncm91cENhbGxlcnNbZ3JvdXBdLmRlbGV0ZShjYWxsZXIpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgICB0aGlzLnNldEJ1dHRvbkFjdGl2ZShidXR0b24sIGFjdGl2ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByb2Nlc3NQZW5kaW5nRXZlbnRzKCkge1xuICAgIGNvbnN0IHBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID0gKHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPz8gW10pLnNsaWNlKCk7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBwZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cykge1xuICAgICAgdGhpcy5vbkJ1dHRvblRvZ2dsZWQoZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID0gW107XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybiBjdHg7XG4gICAgdGhpcy5yZWZyZXNoT3V0ZXJMYXlvdXQoY3R4LnNocmlua1JlY3QpO1xuICAgIHRoaXMucmVmcmVzaExvY2FsZSgpO1xuICAgIHJldHVybiBjdHg7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUNhcnRlc2lhbkxheW91dChvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZWZyZXNoSW5uZXJMYXlvdXQob3B0cy5zZXJpZXNSZWN0KTtcbiAgfVxuICByZWZyZXNoT3V0ZXJMYXlvdXQoc2hyaW5rUmVjdCkge1xuICAgIGNvbnN0IHsgZWxlbWVudHM6IGVsZW1lbnRzMywgaG9yaXpvbnRhbFNwYWNpbmcsIHZlcnRpY2FsU3BhY2luZyB9ID0gdGhpcztcbiAgICBpZiAoIWVsZW1lbnRzMy50b3AuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVyczIuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMzLnRvcC5vZmZzZXRIZWlnaHQgKyB2ZXJ0aWNhbFNwYWNpbmcsIFwidG9wXCIpO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnRzMy5yaWdodC5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzMi5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czMucmlnaHQub2Zmc2V0V2lkdGggKyBob3Jpem9udGFsU3BhY2luZywgXCJyaWdodFwiKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50czMuYm90dG9tLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMyLmhpZGRlbikpIHtcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKGVsZW1lbnRzMy5ib3R0b20ub2Zmc2V0SGVpZ2h0ICsgdmVydGljYWxTcGFjaW5nLCBcImJvdHRvbVwiKTtcbiAgICAgIGVsZW1lbnRzMy5ib3R0b20uc3R5bGUudG9wID0gYCR7c2hyaW5rUmVjdC55ICsgc2hyaW5rUmVjdC5oZWlnaHQgKyB2ZXJ0aWNhbFNwYWNpbmd9cHhgO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnRzMy5sZWZ0LmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMyLmhpZGRlbikpIHtcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKGVsZW1lbnRzMy5sZWZ0Lm9mZnNldFdpZHRoICsgaG9yaXpvbnRhbFNwYWNpbmcsIFwibGVmdFwiKTtcbiAgICB9XG4gIH1cbiAgcmVmcmVzaExvY2FsZSgpIHtcbiAgICBjb25zdCB7IGhhc05ld0xvY2FsZSB9ID0gdGhpcztcbiAgICBpZiAoIWhhc05ld0xvY2FsZSlcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFRPT0xCQVJfR1JPVVBTKSB7XG4gICAgICBjb25zdCBidXR0b25zID0gdGhpc1tncm91cF0uYnV0dG9uQ29uZmlndXJhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uT3B0aW9ucyBvZiBidXR0b25zKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaEJ1dHRvbkNvbnRlbnQoZ3JvdXAsIGJ1dHRvbk9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUb29sYmFyQXJpYUxhYmVsKGdyb3VwKTtcbiAgICB9XG4gICAgdGhpcy5oYXNOZXdMb2NhbGUgPSBmYWxzZTtcbiAgfVxuICByZWZyZXNoSW5uZXJMYXlvdXQocmVjdCkge1xuICAgIGNvbnN0IHsgZWxlbWVudHM6IGVsZW1lbnRzMywgdmVydGljYWxTcGFjaW5nIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgRmxvYXRpbmdCb3R0b20sIEZsb2F0aW5nVG9wIH0gPSBUb29sYmFyUG9zaXRpb247XG4gICAgZWxlbWVudHMzLnRvcC5zdHlsZS50b3AgPSBgJHtyZWN0LnkgLSBlbGVtZW50czMudG9wLm9mZnNldEhlaWdodCAtIHZlcnRpY2FsU3BhY2luZ31weGA7XG4gICAgZWxlbWVudHMzLnRvcC5zdHlsZS5sZWZ0ID0gYCR7cmVjdC54fXB4YDtcbiAgICBlbGVtZW50czMudG9wLnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aH1weGA7XG4gICAgZWxlbWVudHMzLmJvdHRvbS5zdHlsZS5sZWZ0ID0gYCR7cmVjdC54fXB4YDtcbiAgICBlbGVtZW50czMuYm90dG9tLnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aH1weGA7XG4gICAgZWxlbWVudHMzLnJpZ2h0LnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgZWxlbWVudHMzLnJpZ2h0LnN0eWxlLnJpZ2h0ID0gYDBweGA7XG4gICAgZWxlbWVudHMzLnJpZ2h0LnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICBlbGVtZW50czMubGVmdC5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIGVsZW1lbnRzMy5sZWZ0LnN0eWxlLmxlZnQgPSBgMHB4YDtcbiAgICBlbGVtZW50czMubGVmdC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGA7XG4gICAgZWxlbWVudHMzW0Zsb2F0aW5nVG9wXS5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIGVsZW1lbnRzM1tGbG9hdGluZ0JvdHRvbV0uc3R5bGUudG9wID0gYCR7cmVjdC55ICsgcmVjdC5oZWlnaHQgLSBlbGVtZW50czNbRmxvYXRpbmdCb3R0b21dLm9mZnNldEhlaWdodH1weGA7XG4gIH1cbiAgcmVmcmVzaEJ1dHRvbkNvbnRlbnQoZ3JvdXAsIGJ1dHRvbk9wdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuYnV0dG9uSWQoYnV0dG9uT3B0aW9ucyk7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5ncm91cFByb3hpZWQuZ2V0KGdyb3VwKT8uYnV0dG9ucz8uZmluZCgoYikgPT4gdGhpcy5idXR0b25JZChiKSA9PT0gaWQpID8/IGJ1dHRvbk9wdGlvbnM7XG4gICAgY29uc3QgZWxlbWVudDIgPSB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0uZmluZCgoYikgPT4gYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvb2xiYXItaWRcIikgPT09IGlkKTtcbiAgICBpZiAoZWxlbWVudDIgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZUJ1dHRvbihlbGVtZW50MiwgYnV0dG9uKTtcbiAgfVxuICB0b2dnbGVWaXNpYmlsaXRpZXMoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudHMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpc0dyb3VwVmlzaWJsZSA9IChncm91cCkgPT4gdGhpc1tncm91cF0uZW5hYmxlZCAmJiB0aGlzLmdyb3VwQ2FsbGVyc1tncm91cF0uc2l6ZSA+IDA7XG4gICAgY29uc3QgaXNCdXR0b25WaXNpYmxlID0gKGVsZW1lbnQyKSA9PiAoYnV0dG9uKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuYnV0dG9uSWQoYnV0dG9uKTtcbiAgICAgIHJldHVybiBpZCA9PSBudWxsIHx8IGlkID09PSBlbGVtZW50Mi5kYXRhc2V0LnRvb2xiYXJJZDtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLmVuYWJsZWQgJiYgQXJyYXkuZnJvbSh0aGlzLnBvc2l0aW9uc1twb3NpdGlvbl0udmFsdWVzKCkpLnNvbWUoaXNHcm91cFZpc2libGUpO1xuICAgICAgc2V0VmlzaWJpbGl0eSh0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXSwgbW9kaWZpZXJzMi5oaWRkZW4sICF2aXNpYmxlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBUT09MQkFSX0dST1VQUykge1xuICAgICAgaWYgKHRoaXNbZ3JvdXBdID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZ3JvdXBWaXNpYmxlID0gaXNHcm91cFZpc2libGUoZ3JvdXApO1xuICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvblZpc2libGUgPSBncm91cFZpc2libGUgJiYgdGhpc1tncm91cF0uYnV0dG9uQ29uZmlndXJhdGlvbnMoKS5zb21lKGlzQnV0dG9uVmlzaWJsZShidXR0b24pKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eShidXR0b24sIG1vZGlmaWVyczIuYnV0dG9uLmhpZGRlblZhbHVlLCAhYnV0dG9uVmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMocG9zaXRpb24sIHZpc2libGUpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRzOiBlbGVtZW50czMsIHZlcnRpY2FsU3BhY2luZzogdmVydGljYWxNYXJnaW4sIHBvc2l0aW9uQWxpZ25tZW50cyB9ID0gdGhpcztcbiAgICBjb25zdCBlbGVtZW50MiA9IGVsZW1lbnRzM1twb3NpdGlvbl07XG4gICAgY29uc3QgYWxpZ25tZW50cyA9IE9iamVjdC52YWx1ZXMocG9zaXRpb25BbGlnbm1lbnRzW3Bvc2l0aW9uXSk7XG4gICAgc2V0VmlzaWJpbGl0eShlbGVtZW50MiwgbW9kaWZpZXJzMi5mbG9hdGluZ0hpZGRlbiwgIXZpc2libGUpO1xuICAgIGNvbnN0IGRpciA9IHBvc2l0aW9uID09PSBcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovID8gMSA6IC0xO1xuICAgIGZvciAoY29uc3QgYWxpZ24gb2YgYWxpZ25tZW50cykge1xuICAgICAgYWxpZ24uc3R5bGUudHJhbnNmb3JtID0gdmlzaWJsZSAmJiBhbGlnbi5zdHlsZS50cmFuc2Zvcm0gIT09IFwiXCIgPyBcInRyYW5zbGF0ZVkoMClcIiA6IGB0cmFuc2xhdGVZKCR7KGVsZW1lbnQyLm9mZnNldEhlaWdodCArIHZlcnRpY2FsTWFyZ2luKSAqIGRpcn1weClgO1xuICAgIH1cbiAgfVxuICByZW5kZXJUb29sYmFyKHBvc2l0aW9uID0gXCJ0b3BcIiAvKiBUb3AgKi8pIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IHRoaXMuZWxlbWVudHNbcG9zaXRpb25dO1xuICAgIGVsZW1lbnQyLmNsYXNzTGlzdC5hZGQoYmxvY2syLCBtb2RpZmllcnMyW3Bvc2l0aW9uXSwgbW9kaWZpZXJzMi5wcmV2ZW50Rmxhc2gpO1xuICAgIGlmIChpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICBlbGVtZW50Mi5jbGFzc0xpc3QuYWRkKG1vZGlmaWVyczIuZmxvYXRpbmdIaWRkZW4pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFsaWduIG9mIFRPT0xCQVJfQUxJR05NRU5UUykge1xuICAgICAgY29uc3QgYWxpZ25tZW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBhbGlnbm1lbnRFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgYWxpZ25tZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKGVsZW1lbnRzMi5hbGlnbiwgbW9kaWZpZXJzMi5hbGlnblthbGlnbl0pO1xuICAgICAgYWxpZ25tZW50RWxlbWVudC5kYXRhc2V0LnBvaW50ZXJDYXB0dXJlID0gXCJleGNsdXNpdmVcIjtcbiAgICAgIGVsZW1lbnQyLmFwcGVuZENoaWxkKGFsaWdubWVudEVsZW1lbnQpO1xuICAgICAgdGhpcy5wb3NpdGlvbkFsaWdubWVudHNbcG9zaXRpb25dW2FsaWduXSA9IGFsaWdubWVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUJ1dHRvbkVsZW1lbnQoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidXR0b24gPSBjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGVsZW1lbnRzMi5idXR0b24pO1xuICAgIGJ1dHRvbi5kYXRhc2V0LnRvb2xiYXJHcm91cCA9IGdyb3VwO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IC0xO1xuICAgIGJ1dHRvbi5kYXRhc2V0LnRvb2xiYXJJZCA9IHRoaXMuYnV0dG9uSWQob3B0aW9ucyk7XG4gICAgYnV0dG9uLm9uY2xpY2sgPSBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXIoXG4gICAgICBidXR0b24sXG4gICAgICB0aGlzLm9uQnV0dG9uUHJlc3MuYmluZCh0aGlzLCBidXR0b24sIGdyb3VwLCBvcHRpb25zLmlkLCBvcHRpb25zLnZhbHVlKVxuICAgICk7XG4gICAgdGhpcy51cGRhdGVCdXR0b24oYnV0dG9uLCBvcHRpb25zKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCgoKSA9PiBidXR0b24ucmVtb3ZlKCkpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgZ2V0QXJpYVRvb2xiYXIoZ3JvdXApIHtcbiAgICBmb3IgKGNvbnN0IGFyaWFUb29sYmFyIG9mIHRoaXMuYXJpYVRvb2xiYXJzKSB7XG4gICAgICBpZiAoYXJpYVRvb2xiYXIuZ3JvdXBzLmluY2x1ZGVzKGdyb3VwKSkge1xuICAgICAgICByZXR1cm4gYXJpYVRvb2xiYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gY2Fubm90IGZpbmQgYXJpYS10b29sYmFyIG9mICcke2dyb3VwfSdgKTtcbiAgfVxuICB1cGRhdGVUb29sYmFyQXJpYUxhYmVsKGdyb3VwLCBhbGlnbkVsZW1lbnQpIHtcbiAgICBpZiAoIWFsaWduRWxlbWVudCkge1xuICAgICAgY29uc3QgeyBhbGlnbiwgcG9zaXRpb24gfSA9IHRoaXNbZ3JvdXBdO1xuICAgICAgYWxpZ25FbGVtZW50ID0gdGhpcy5wb3NpdGlvbkFsaWdubWVudHNbcG9zaXRpb25dW2FsaWduXTtcbiAgICAgIGlmICghYWxpZ25FbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgIHNlcmllc1R5cGU6IFwiYXJpYUxhYmVsRmluYW5jaWFsQ2hhcnRzXCIsXG4gICAgICBhbm5vdGF0aW9uczogXCJhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHNcIixcbiAgICAgIGFubm90YXRpb25PcHRpb25zOiBcImFyaWFMYWJlbEFubm90YXRpb25PcHRpb25zVG9vbGJhclwiLFxuICAgICAgcmFuZ2VzOiBcImFyaWFMYWJlbFJhbmdlc1Rvb2xiYXJcIixcbiAgICAgIHpvb206IFwiYXJpYUxhYmVsWm9vbVRvb2xiYXJcIlxuICAgIH07XG4gICAgYWxpZ25FbGVtZW50LmFyaWFMYWJlbCA9IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChtYXBbZ3JvdXBdKTtcbiAgfVxuICB1cGRhdGVCdXR0b24oYnV0dG9uLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGRvbU1hbmFnZXIsIGxvY2FsZU1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgIGNvbnN0IHRvb2x0aXAgPSBsb2NhbGVNYW5hZ2VyLnQob3B0aW9ucy50b29sdGlwKTtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IHRvb2x0aXA7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMuaWNvbiAhPSBudWxsKSB7XG4gICAgICBpbm5lciA9IGA8c3BhbiBjbGFzcz1cIiR7ZG9tTWFuYWdlci5nZXRJY29uQ2xhc3NOYW1lcyhvcHRpb25zLmljb24pfSAke2VsZW1lbnRzMi5pY29ufVwiPjwvc3Bhbj5gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYWJlbCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IGxvY2FsZU1hbmFnZXIudChvcHRpb25zLmxhYmVsKTtcbiAgICAgIGlubmVyID0gYCR7aW5uZXJ9PHNwYW4gY2xhc3M9XCIke2VsZW1lbnRzMi5sYWJlbH1cIj4ke2xhYmVsfTwvc3Bhbj5gO1xuICAgIH1cbiAgICBidXR0b24uaW5uZXJIVE1MID0gaW5uZXI7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzMi5idXR0b24uZmlsbFZpc2libGUsIG9wdGlvbnMuZmlsbCAhPSBudWxsKTtcbiAgICBidXR0b24uc3R5bGUuc2V0UHJvcGVydHkoXCItLWZpbGxcIiwgb3B0aW9ucy5maWxsID8/IG51bGwpO1xuICAgIGNvbnN0IGFyaWFMYWJlbCA9IG9wdGlvbnMuYXJpYUxhYmVsID8gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KG9wdGlvbnMuYXJpYUxhYmVsKSA6IHZvaWQgMDtcbiAgICBzZXRBdHRyaWJ1dGUoYnV0dG9uLCBcImFyaWEtbGFiZWxcIiwgYXJpYUxhYmVsKTtcbiAgfVxuICBvbkJ1dHRvblByZXNzKGJ1dHRvbiwgZ3JvdXAsIGlkLCB2YWx1ZSkge1xuICAgIHRoaXMuY3R4LnRvb2xiYXJNYW5hZ2VyLnByZXNzQnV0dG9uKGdyb3VwLCB0aGlzLmJ1dHRvbklkKHsgaWQsIHZhbHVlIH0pLCB2YWx1ZSwgdGhpcy5idXR0b25SZWN0KGJ1dHRvbikpO1xuICB9XG4gIGJ1dHRvbklkKGJ1dHRvbikge1xuICAgIGNvbnN0IHsgaWQsIHZhbHVlLCBsYWJlbCB9ID0gYnV0dG9uO1xuICAgIGlmIChpZCAhPSBudWxsKVxuICAgICAgcmV0dXJuIGlkO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIHJldHVybiBsYWJlbCA/PyBcIlwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5wcm9jZXNzUGVuZGluZ0V2ZW50cygpO1xuICAgIHRhcmdldC50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgfSksXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sYmFyLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sYmFyL3Rvb2xiYXJNb2R1bGUudHNcbnZhciBEQVkgPSAxZTMgKiA2MCAqIDYwICogMjQ7XG52YXIgTU9OVEggPSBEQVkgKiAzMDtcbnZhciBZRUFSID0gREFZICogMzY1O1xudmFyIHNlcmllc1R5cGUgPSB7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gIGFsaWduOiBcInN0YXJ0XCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJTZXJpZXNUeXBlRHJvcGRvd25cIixcbiAgICAgIHZhbHVlOiBcInR5cGVcIlxuICAgIH1cbiAgXVxufTtcbnZhciBhbm5vdGF0aW9ucyA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcG9zaXRpb246IFwibGVmdFwiLFxuICBhbGlnbjogXCJzdGFydFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgaWNvbjogXCJ0cmVuZC1saW5lLWRyYXdpbmdcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zTGluZUFubm90YXRpb25zXCIsXG4gICAgICB2YWx1ZTogXCJsaW5lLW1lbnVcIixcbiAgICAgIHNlY3Rpb246IFwibGluZS1hbm5vdGF0aW9uc1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInRleHQtYW5ub3RhdGlvblwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNUZXh0QW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBcInRleHQtbWVudVwiLFxuICAgICAgc2VjdGlvbjogXCJ0ZXh0LWFubm90YXRpb25zXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiZGVsZXRlXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0NsZWFyQWxsXCIsXG4gICAgICB2YWx1ZTogXCJjbGVhclwiLFxuICAgICAgc2VjdGlvbjogXCJ0b29sc1wiXG4gICAgfVxuICBdXG59O1xudmFyIGFubm90YXRpb25PcHRpb25zID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBwb3NpdGlvbjogXCJmbG9hdGluZ1wiLFxuICBhbGlnbjogXCJzdGFydFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgaWNvbjogXCJ0ZXh0LWFubm90YXRpb25cIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVGV4dENvbG9yXCIsXG4gICAgICB2YWx1ZTogXCJ0ZXh0LWNvbG9yXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwibGluZS1jb2xvclwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3JcIixcbiAgICAgIHZhbHVlOiBcImxpbmUtY29sb3JcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJmaWxsLWNvbG9yXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0ZpbGxDb2xvclwiLFxuICAgICAgdmFsdWU6IFwiZmlsbC1jb2xvclwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1RleHRTaXplXCIsXG4gICAgICB2YWx1ZTogXCJ0ZXh0LXNpemVcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJ1bmxvY2tlZFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMb2NrXCIsXG4gICAgICB2YWx1ZTogXCJsb2NrXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwibG9ja2VkXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1VubG9ja1wiLFxuICAgICAgdmFsdWU6IFwidW5sb2NrXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiZGVsZXRlXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0RlbGV0ZVwiLFxuICAgICAgdmFsdWU6IFwiZGVsZXRlXCJcbiAgICB9XG4gIF1cbn07XG52YXIgcmFuZ2VzID0ge1xuICBlbmFibGVkOiBmYWxzZSxcbiAgcG9zaXRpb246IERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTFNb250aFwiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTFNb250aEFyaWFcIixcbiAgICAgIHZhbHVlOiBNT05USFxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlM01vbnRoc1wiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTNNb250aHNBcmlhXCIsXG4gICAgICB2YWx1ZTogMyAqIE1PTlRIXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2U2TW9udGhzXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlNk1vbnRoc0FyaWFcIixcbiAgICAgIHZhbHVlOiA2ICogTU9OVEhcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZVllYXJUb0RhdGVcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2VZZWFyVG9EYXRlQXJpYVwiLFxuICAgICAgdmFsdWU6IChfc3RhcnQsIGVuZCkgPT4gWygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoYCR7bmV3IERhdGUoZW5kKS5nZXRGdWxsWWVhcigpfS0wMS0wMWApKS5nZXRUaW1lKCksIGVuZF0sXG4gICAgICBpZDogXCJ5ZWFyLXRvLWRhdGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlMVllYXJcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2UxWWVhckFyaWFcIixcbiAgICAgIHZhbHVlOiBZRUFSXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2VBbGxcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2VBbGxBcmlhXCIsXG4gICAgICB2YWx1ZTogKHN0YXJ0LCBlbmQpID0+IFtzdGFydCwgZW5kXSxcbiAgICAgIGlkOiBcImFsbFwiXG4gICAgfVxuICBdXG59O1xudmFyIHpvb20gPSB7XG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBvc2l0aW9uOiBcInRvcFwiLFxuICBhbGlnbjogXCJlbmRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGljb246IFwiem9vbS1vdXRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21ab29tT3V0XCIsXG4gICAgICB2YWx1ZTogXCJ6b29tLW91dFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInpvb20taW5cIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21ab29tSW5cIixcbiAgICAgIHZhbHVlOiBcInpvb20taW5cIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJwYW4tbGVmdFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVBhbkxlZnRcIixcbiAgICAgIHZhbHVlOiBcInBhbi1sZWZ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLXJpZ2h0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUGFuUmlnaHRcIixcbiAgICAgIHZhbHVlOiBcInBhbi1yaWdodFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1zdGFydFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVBhblN0YXJ0XCIsXG4gICAgICB2YWx1ZTogXCJwYW4tc3RhcnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJwYW4tZW5kXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUGFuRW5kXCIsXG4gICAgICB2YWx1ZTogXCJwYW4tZW5kXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicmVzZXRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21SZXNldFwiLFxuICAgICAgdmFsdWU6IFwicmVzZXRcIlxuICAgIH1cbiAgXVxufTtcbnZhciBUb29sYmFyTW9kdWxlID0ge1xuICB0eXBlOiBcInJvb3RcIixcbiAgb3B0aW9uc0tleTogXCJ0b29sYmFyXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBUb29sYmFyKGN0eCksXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICB0b29sYmFyOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgc2VyaWVzVHlwZSxcbiAgICAgIGFubm90YXRpb25zLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnMsXG4gICAgICByYW5nZXMsXG4gICAgICB6b29tXG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3JlZ2lzdGVySW5idWlsdE1vZHVsZXMudHNcbmZ1bmN0aW9uIHJlZ2lzdGVySW5idWlsdE1vZHVsZXMoKSB7XG4gIG1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyKFxuICAgIEJhY2tncm91bmRNb2R1bGUsXG4gICAgQ29tbXVuaXR5TGVnZW5kTW9kdWxlLFxuICAgIExvY2FsZU1vZHVsZSxcbiAgICBOYXZpZ2F0b3JNb2R1bGUsXG4gICAgVG9vbGJhck1vZHVsZSxcbiAgICBBcmVhU2VyaWVzTW9kdWxlLFxuICAgIEJhclNlcmllc01vZHVsZSxcbiAgICBCdWJibGVTZXJpZXNNb2R1bGUsXG4gICAgTGluZVNlcmllc01vZHVsZSxcbiAgICBTY2F0dGVyU2VyaWVzTW9kdWxlLFxuICAgIERvbnV0U2VyaWVzTW9kdWxlLFxuICAgIFBpZVNlcmllc01vZHVsZSxcbiAgICBIaXN0b2dyYW1TZXJpZXNNb2R1bGVcbiAgKTtcbiAgZm9yIChjb25zdCBBeGlzQ29uc3RydWN0b3Igb2YgW051bWJlckF4aXMsIENhdGVnb3J5QXhpcywgVGltZUF4aXMsIEdyb3VwZWRDYXRlZ29yeUF4aXMsIExvZ0F4aXNdKSB7XG4gICAgYXhpc1JlZ2lzdHJ5LnJlZ2lzdGVyKEF4aXNDb25zdHJ1Y3Rvci50eXBlLCB7XG4gICAgICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQXhpc0NvbnN0cnVjdG9yKGN0eCksXG4gICAgICBoaWRkZW46IEF4aXNDb25zdHJ1Y3RvciA9PT0gR3JvdXBlZENhdGVnb3J5QXhpc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3Rvcnkvc2V0dXBNb2R1bGVzLnRzXG5mdW5jdGlvbiBzZXR1cE1vZHVsZXMoKSB7XG4gIGZvciAoY29uc3QgbSBvZiBtb2R1bGVSZWdpc3RyeS5tb2R1bGVzKSB7XG4gICAgaWYgKG0ucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiICYmICF2ZXJpZnlJZk1vZHVsZUV4cGVjdGVkKG0pKSB7XG4gICAgICBMb2dnZXIuZXJyb3JPbmNlKFwiVW5leHBlY3RlZCBlbnRlcnByaXNlIG1vZHVsZSByZWdpc3RlcmVkOiBcIiArIG0uaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwicm9vdFwiICYmIG0udGhlbWVUZW1wbGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBjaGFydFR5cGUyIG9mIG0uY2hhcnRUeXBlcykge1xuICAgICAgICBjaGFydERlZmF1bHRzLnNldChjaGFydFR5cGUyLCBtLnRoZW1lVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcInNlcmllc1wiKSB7XG4gICAgICBpZiAobS5jaGFydFR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBNb2R1bGUgZGVmaW5pdGlvbiBlcnJvcjogJHttLmlkZW50aWZpZXJ9YCk7XG4gICAgICB9XG4gICAgICBzZXJpZXNSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcInNlcmllcy1vcHRpb25cIiAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzVHlwZTIgb2YgbS5zZXJpZXNUeXBlcykge1xuICAgICAgICBzZXJpZXNSZWdpc3RyeS5zZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyLCBtLnRoZW1lVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcImF4aXMtb3B0aW9uXCIgJiYgbS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF4aXNUeXBlIG9mIG0uYXhpc1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IGF4aXNUeXBlVGhlbWUgPSBheGlzUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSk7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gbWVyZ2VEZWZhdWx0cyhtLnRoZW1lVGVtcGxhdGUsIGF4aXNUeXBlVGhlbWUpO1xuICAgICAgICBheGlzUmVnaXN0cnkuc2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSwgdGhlbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcImF4aXNcIikge1xuICAgICAgYXhpc1JlZ2lzdHJ5LnJlZ2lzdGVyKG0uaWRlbnRpZmllciwgbSk7XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwibGVnZW5kXCIpIHtcbiAgICAgIGxlZ2VuZFJlZ2lzdHJ5LnJlZ2lzdGVyKG0uaWRlbnRpZmllciwgbSk7XG4gICAgfVxuICB9XG4gIGlmIChtb2R1bGVSZWdpc3RyeS5oYXNFbnRlcnByaXNlTW9kdWxlcygpKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRCdXRVbnVzZWQgPSBnZXRVbnVzZWRFeHBlY3RlZE1vZHVsZXMoKTtcbiAgICBpZiAoZXhwZWN0ZWRCdXRVbnVzZWQubGVuZ3RoID4gMCkge1xuICAgICAgTG9nZ2VyLmVycm9yT25jZShcIkVudGVycHJpc2UgbW9kdWxlcyBleHBlY3RlZCBidXQgbm90IHJlZ2lzdGVyZWQ6IFwiLCBleHBlY3RlZEJ1dFVudXNlZCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Zsb3dQcm9wb3J0aW9uQ2hhcnQudHNcbmZ1bmN0aW9uIGlzRmxvd1Byb3BvcnRpb24oc2VyaWVzKSB7XG4gIHJldHVybiBzZXJpZXMudHlwZSA9PT0gXCJzYW5rZXlcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJjaG9yZFwiO1xufVxudmFyIEZsb3dQcm9wb3J0aW9uQ2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcImZsb3ctcHJvcG9ydGlvblwiO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdGEoKSB7XG4gICAgYXdhaXQgc3VwZXIudXBkYXRlRGF0YSgpO1xuICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgaWYgKGlzRmxvd1Byb3BvcnRpb24oc2VyaWVzKSkge1xuICAgICAgICBzZXJpZXMuc2V0Q2hhcnROb2Rlcyhub2Rlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dCgpIHtcbiAgICBjb25zdCBzaHJpbmtSZWN0ID0gYXdhaXQgc3VwZXIucGVyZm9ybUxheW91dCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcmllc0FyZWE6IHsgcGFkZGluZyB9LFxuICAgICAgc2VyaWVzUm9vdCxcbiAgICAgIGFubm90YXRpb25Sb290LFxuICAgICAgaGlnaGxpZ2h0Um9vdFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZ1bGxTZXJpZXNSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcubGVmdCwgXCJsZWZ0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcudG9wLCBcInRvcFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCBcInJpZ2h0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcuYm90dG9tLCBcImJvdHRvbVwiKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzaHJpbmtSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgY29uc3Qgc2VyaWVzVmlzaWJsZSA9IHRoaXMuc2VyaWVzLnNvbWUoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gc2VyaWVzVmlzaWJsZTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC55KTtcbiAgICAgIGdyb3VwLnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShcbiAgICAgICAgbmV3IEJCb3goZnVsbFNlcmllc1JlY3QueCwgZnVsbFNlcmllc1JlY3QueSwgZnVsbFNlcmllc1JlY3Qud2lkdGgsIGZ1bGxTZXJpZXNSZWN0LmhlaWdodClcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZSh7XG4gICAgICB0eXBlOiBcImxheW91dC1jb21wbGV0ZVwiLFxuICAgICAgY2hhcnQ6IHsgd2lkdGg6IHRoaXMuY3R4LnNjZW5lLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3R4LnNjZW5lLmhlaWdodCB9LFxuICAgICAgY2xpcFNlcmllczogZmFsc2UsXG4gICAgICBzZXJpZXM6IHsgcmVjdDogZnVsbFNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IHNocmlua1JlY3QsIHZpc2libGU6IHNlcmllc1Zpc2libGUgfSxcbiAgICAgIGF4ZXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHNocmlua1JlY3Q7XG4gIH1cbn07XG5GbG93UHJvcG9ydGlvbkNoYXJ0LmNsYXNzTmFtZSA9IFwiRmxvd1Byb3BvcnRpb25DaGFydFwiO1xuRmxvd1Byb3BvcnRpb25DaGFydC50eXBlID0gXCJmbG93LXByb3BvcnRpb25cIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaGllcmFyY2h5Q2hhcnQudHNcbnZhciBIaWVyYXJjaHlDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJoaWVyYXJjaHlcIjtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KCkge1xuICAgIGNvbnN0IHNocmlua1JlY3QgPSBhd2FpdCBzdXBlci5wZXJmb3JtTGF5b3V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgc2VyaWVzQXJlYTogeyBwYWRkaW5nIH0sXG4gICAgICBzZXJpZXNSb290LFxuICAgICAgYW5ub3RhdGlvblJvb3QsXG4gICAgICBoaWdobGlnaHRSb290XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZnVsbFNlcmllc1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCk7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5sZWZ0LCBcImxlZnRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy50b3AsIFwidG9wXCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcucmlnaHQsIFwicmlnaHRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5ib3R0b20sIFwiYm90dG9tXCIpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2hyaW5rUmVjdDtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC55KTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLnNlcmllcy5tYXAoYXN5bmMgKHNlcmllcykgPT4ge1xuICAgICAgICBhd2FpdCBzZXJpZXMudXBkYXRlKHsgc2VyaWVzUmVjdDogc2hyaW5rUmVjdCB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBzZXJpZXNSb290LnZpc2libGUgPSB0aGlzLnNlcmllc1swXS52aXNpYmxlO1xuICAgIHNlcmllc1Jvb3Quc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKFxuICAgICAgbmV3IEJCb3goc2hyaW5rUmVjdC54LCBzaHJpbmtSZWN0LnksIHNocmlua1JlY3Qud2lkdGgsIHNocmlua1JlY3QuaGVpZ2h0KVxuICAgICk7XG4gICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaExheW91dENvbXBsZXRlKHtcbiAgICAgIHR5cGU6IFwibGF5b3V0LWNvbXBsZXRlXCIsXG4gICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5jdHguc2NlbmUud2lkdGgsIGhlaWdodDogdGhpcy5jdHguc2NlbmUuaGVpZ2h0IH0sXG4gICAgICBjbGlwU2VyaWVzOiBmYWxzZSxcbiAgICAgIHNlcmllczogeyByZWN0OiBmdWxsU2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogc2hyaW5rUmVjdCwgdmlzaWJsZTogdHJ1ZSB9LFxuICAgICAgYXhlczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gc2hyaW5rUmVjdDtcbiAgfVxuICBnZXRBcmlhTGFiZWwoKSB7XG4gICAgY29uc3QgY2FwdGlvblRleHQgPSB0aGlzLmdldENhcHRpb25UZXh0KCk7XG4gICAgcmV0dXJuIGBoaWVyYXJjaGljYWwgY2hhcnQsICR7Y2FwdGlvblRleHR9YDtcbiAgfVxufTtcbkhpZXJhcmNoeUNoYXJ0LmNsYXNzTmFtZSA9IFwiSGllcmFyY2h5Q2hhcnRcIjtcbkhpZXJhcmNoeUNoYXJ0LnR5cGUgPSBcImhpZXJhcmNoeVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL3BvbGFyQXhpcy50c1xudmFyIFBvbGFyQXhpcyA9IGNsYXNzIGV4dGVuZHMgQXhpcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaGFwZSA9IFwicG9seWdvblwiO1xuICAgIHRoaXMuaW5uZXJSYWRpdXNSYXRpbyA9IDA7XG4gICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSAyMDtcbiAgfVxuICBjb21wdXRlTGFiZWxzQkJveChfb3B0aW9ucywgX3Nlcmllc1JlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInBvbHlnb25cIiwgXCJjaXJjbGVcIl0sIFwiYSBwb2xhciBheGlzIHNoYXBlXCIpKVxuXSwgUG9sYXJBeGlzLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUG9sYXJBeGlzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1JhdGlvXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9wb2xhckNoYXJ0LnRzXG52YXIgUG9sYXJDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIHRoaXMucGFkZGluZyA9IG5ldyBQYWRkaW5nKDQwKTtcbiAgICB0aGlzLmN0eC5heGlzTWFuYWdlci5heGlzR3JvdXAuekluZGV4ID0gNiAvKiBBWElTX0ZPUkVHUk9VTkRfWklOREVYICovO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJwb2xhclwiO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgY29uc3Qgc2hyaW5rUmVjdCA9IGF3YWl0IHN1cGVyLnBlcmZvcm1MYXlvdXQoKTtcbiAgICBjb25zdCBmdWxsU2VyaWVzUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcbiAgICB0aGlzLmNvbXB1dGVTZXJpZXNSZWN0KHNocmlua1JlY3QpO1xuICAgIGF3YWl0IHRoaXMuY29tcHV0ZUNpcmNsZShzaHJpbmtSZWN0KTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gYXhpcy51cGRhdGUoKSk7XG4gICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaExheW91dENvbXBsZXRlKHtcbiAgICAgIHR5cGU6IFwibGF5b3V0LWNvbXBsZXRlXCIsXG4gICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5jdHguc2NlbmUud2lkdGgsIGhlaWdodDogdGhpcy5jdHguc2NlbmUuaGVpZ2h0IH0sXG4gICAgICBjbGlwU2VyaWVzOiBmYWxzZSxcbiAgICAgIHNlcmllczogeyByZWN0OiBmdWxsU2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogc2hyaW5rUmVjdCwgdmlzaWJsZTogdHJ1ZSB9LFxuICAgICAgYXhlczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gc2hyaW5rUmVjdDtcbiAgfVxuICB1cGRhdGVBeGVzKGN4LCBjeSwgcmFkaXVzKSB7XG4gICAgY29uc3QgYW5nbGVBeGlzID0gdGhpcy5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKTtcbiAgICBjb25zdCByYWRpdXNBeGlzID0gdGhpcy5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKTtcbiAgICBpZiAoIShhbmdsZUF4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXMpIHx8ICEocmFkaXVzQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5nbGVTY2FsZSA9IGFuZ2xlQXhpcy5zY2FsZTtcbiAgICBjb25zdCBhbmdsZXMgPSBhbmdsZVNjYWxlLnRpY2tzPy4oKS5tYXAoKHZhbHVlKSA9PiBhbmdsZVNjYWxlLmNvbnZlcnQodmFsdWUpKTtcbiAgICBjb25zdCBpbm5lclJhZGl1c1JhdGlvID0gcmFkaXVzQXhpcy5pbm5lclJhZGl1c1JhdGlvO1xuICAgIGFuZ2xlQXhpcy5pbm5lclJhZGl1c1JhdGlvID0gaW5uZXJSYWRpdXNSYXRpbztcbiAgICBhbmdsZUF4aXMuY29tcHV0ZVJhbmdlPy4oKTtcbiAgICBhbmdsZUF4aXMuZ3JpZExlbmd0aCA9IHJhZGl1cztcbiAgICByYWRpdXNBeGlzLmdyaWRBbmdsZXMgPSBhbmdsZXM7XG4gICAgcmFkaXVzQXhpcy5ncmlkUmFuZ2UgPSBhbmdsZUF4aXMucmFuZ2U7XG4gICAgcmFkaXVzQXhpcy5yYW5nZSA9IFtyYWRpdXMsIHJhZGl1cyAqIGlubmVyUmFkaXVzUmF0aW9dO1xuICAgIFthbmdsZUF4aXMsIHJhZGl1c0F4aXNdLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMudHJhbnNsYXRpb24ueCA9IGN4O1xuICAgICAgYXhpcy50cmFuc2xhdGlvbi55ID0gY3k7XG4gICAgICBheGlzLmNhbGN1bGF0ZUxheW91dCgpO1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGVTZXJpZXNSZWN0KHNocmlua1JlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXJpZXNBcmVhOiB7IHBhZGRpbmcgfVxuICAgIH0gPSB0aGlzO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcubGVmdCwgXCJsZWZ0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcudG9wLCBcInRvcFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCBcInJpZ2h0XCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcuYm90dG9tLCBcImJvdHRvbVwiKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzaHJpbmtSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHNocmlua1JlY3Q7XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUNpcmNsZShzZXJpZXNCb3gpIHtcbiAgICBjb25zdCBwb2xhclNlcmllcyA9IHRoaXMuc2VyaWVzLmZpbHRlcigoc2VyaWVzKSA9PiB7XG4gICAgICByZXR1cm4gc2VyaWVzIGluc3RhbmNlb2YgUG9sYXJTZXJpZXM7XG4gICAgfSk7XG4gICAgY29uc3QgcG9sYXJBeGVzID0gdGhpcy5heGVzLmZpbHRlcigoYXhpcykgPT4ge1xuICAgICAgcmV0dXJuIGF4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXM7XG4gICAgfSk7XG4gICAgY29uc3Qgc2V0U2VyaWVzQ2lyY2xlID0gKGN4LCBjeSwgcikgPT4ge1xuICAgICAgdGhpcy51cGRhdGVBeGVzKGN4LCBjeSwgcik7XG4gICAgICBwb2xhclNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgICAgc2VyaWVzLmNlbnRlclggPSBjeDtcbiAgICAgICAgc2VyaWVzLmNlbnRlclkgPSBjeTtcbiAgICAgICAgc2VyaWVzLnJhZGl1cyA9IHI7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBpZVNlcmllcyA9IHBvbGFyU2VyaWVzLmZpbHRlcigocykgPT4gcy50eXBlID09PSBcImRvbnV0XCIgfHwgcy50eXBlID09PSBcInBpZVwiKTtcbiAgICAgIGlmIChwaWVTZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBpbm5lclJhZGlpID0gcGllU2VyaWVzLm1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSBzZXJpZXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICAgICAgICByZXR1cm4geyBzZXJpZXMsIGlubmVyUmFkaXVzIH07XG4gICAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGEuaW5uZXJSYWRpdXMgLSBiLmlubmVyUmFkaXVzKTtcbiAgICAgICAgaW5uZXJSYWRpaS5hdCgtMSkuc2VyaWVzLnN1cnJvdW5kaW5nUmFkaXVzID0gdm9pZCAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyUmFkaWkubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgaW5uZXJSYWRpaVtpXS5zZXJpZXMuc3Vycm91bmRpbmdSYWRpdXMgPSBpbm5lclJhZGlpW2kgKyAxXS5pbm5lclJhZGl1cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2VudGVyWCA9IHNlcmllc0JveC54ICsgc2VyaWVzQm94LndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2VyaWVzQm94LnkgKyBzZXJpZXNCb3guaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBpbml0aWFsUmFkaXVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VyaWVzQm94LndpZHRoLCBzZXJpZXNCb3guaGVpZ2h0KSAvIDIpO1xuICAgIGxldCByYWRpdXMgPSBpbml0aWFsUmFkaXVzO1xuICAgIHNldFNlcmllc0NpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpO1xuICAgIGNvbnN0IHNoYWtlID0gYXN5bmMgKHsgaGlkZVdoZW5OZWNlc3NhcnkgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsQm94ZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIFsuLi5wb2xhckF4ZXMsIC4uLnBvbGFyU2VyaWVzXSkge1xuICAgICAgICBjb25zdCBib3ggPSBhd2FpdCBzZXJpZXMuY29tcHV0ZUxhYmVsc0JCb3goeyBoaWRlV2hlbk5lY2Vzc2FyeSB9LCBzZXJpZXNCb3gpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgbGFiZWxCb3hlcy5wdXNoKGJveCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXRTZXJpZXNDaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgaW5pdGlhbFJhZGl1cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsQm94ID0gQkJveC5tZXJnZShsYWJlbEJveGVzKTtcbiAgICAgIGNvbnN0IHJlZmluZWQgPSB0aGlzLnJlZmluZUNpcmNsZShsYWJlbEJveCwgcmFkaXVzLCBzZXJpZXNCb3gpO1xuICAgICAgc2V0U2VyaWVzQ2lyY2xlKHJlZmluZWQuY2VudGVyWCwgcmVmaW5lZC5jZW50ZXJZLCByZWZpbmVkLnJhZGl1cyk7XG4gICAgICBpZiAocmVmaW5lZC5yYWRpdXMgPT09IHJhZGl1cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByYWRpdXMgPSByZWZpbmVkLnJhZGl1cztcbiAgICB9O1xuICAgIGF3YWl0IHNoYWtlKCk7XG4gICAgYXdhaXQgc2hha2UoKTtcbiAgICBhd2FpdCBzaGFrZSgpO1xuICAgIGF3YWl0IHNoYWtlKHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSk7XG4gICAgYXdhaXQgc2hha2UoeyBoaWRlV2hlbk5lY2Vzc2FyeTogdHJ1ZSB9KTtcbiAgICByZXR1cm4geyByYWRpdXMsIGNlbnRlclgsIGNlbnRlclkgfTtcbiAgfVxuICByZWZpbmVDaXJjbGUobGFiZWxzQm94LCByYWRpdXMsIHNlcmllc0JveCkge1xuICAgIGNvbnN0IG1pbkNpcmNsZVJhdGlvID0gMC41O1xuICAgIGNvbnN0IGNpcmNsZUxlZnQgPSAtcmFkaXVzO1xuICAgIGNvbnN0IGNpcmNsZVRvcCA9IC1yYWRpdXM7XG4gICAgY29uc3QgY2lyY2xlUmlnaHQgPSByYWRpdXM7XG4gICAgY29uc3QgY2lyY2xlQm90dG9tID0gcmFkaXVzO1xuICAgIGxldCBwYWRMZWZ0ID0gTWF0aC5tYXgoMCwgY2lyY2xlTGVmdCAtIGxhYmVsc0JveC54KTtcbiAgICBsZXQgcGFkVG9wID0gTWF0aC5tYXgoMCwgY2lyY2xlVG9wIC0gbGFiZWxzQm94LnkpO1xuICAgIGxldCBwYWRSaWdodCA9IE1hdGgubWF4KDAsIGxhYmVsc0JveC54ICsgbGFiZWxzQm94LndpZHRoIC0gY2lyY2xlUmlnaHQpO1xuICAgIGxldCBwYWRCb3R0b20gPSBNYXRoLm1heCgwLCBsYWJlbHNCb3gueSArIGxhYmVsc0JveC5oZWlnaHQgLSBjaXJjbGVCb3R0b20pO1xuICAgIHBhZExlZnQgPSBwYWRSaWdodCA9IE1hdGgubWF4KHBhZExlZnQsIHBhZFJpZ2h0KTtcbiAgICBwYWRUb3AgPSBwYWRCb3R0b20gPSBNYXRoLm1heChwYWRUb3AsIHBhZEJvdHRvbSk7XG4gICAgY29uc3QgYXZhaWxDaXJjbGVXaWR0aCA9IHNlcmllc0JveC53aWR0aCAtIHBhZExlZnQgLSBwYWRSaWdodDtcbiAgICBjb25zdCBhdmFpbENpcmNsZUhlaWdodCA9IHNlcmllc0JveC5oZWlnaHQgLSBwYWRUb3AgLSBwYWRCb3R0b207XG4gICAgbGV0IG5ld1JhZGl1cyA9IE1hdGgubWluKGF2YWlsQ2lyY2xlV2lkdGgsIGF2YWlsQ2lyY2xlSGVpZ2h0KSAvIDI7XG4gICAgY29uc3QgbWluSG9yaXpvbnRhbFJhZGl1cyA9IG1pbkNpcmNsZVJhdGlvICogc2VyaWVzQm94LndpZHRoIC8gMjtcbiAgICBjb25zdCBtaW5WZXJ0aWNhbFJhZGl1cyA9IG1pbkNpcmNsZVJhdGlvICogc2VyaWVzQm94LmhlaWdodCAvIDI7XG4gICAgY29uc3QgbWluUmFkaXVzID0gTWF0aC5taW4obWluSG9yaXpvbnRhbFJhZGl1cywgbWluVmVydGljYWxSYWRpdXMpO1xuICAgIGlmIChuZXdSYWRpdXMgPCBtaW5SYWRpdXMpIHtcbiAgICAgIG5ld1JhZGl1cyA9IG1pblJhZGl1cztcbiAgICAgIGNvbnN0IGhvcml6b250YWxQYWRkaW5nID0gcGFkTGVmdCArIHBhZFJpZ2h0O1xuICAgICAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gcGFkVG9wICsgcGFkQm90dG9tO1xuICAgICAgaWYgKDIgKiBuZXdSYWRpdXMgKyB2ZXJ0aWNhbFBhZGRpbmcgPiBzZXJpZXNCb3guaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHBhZEhlaWdodCA9IHNlcmllc0JveC5oZWlnaHQgLSAyICogbmV3UmFkaXVzO1xuICAgICAgICBpZiAoTWF0aC5taW4ocGFkVG9wLCBwYWRCb3R0b20pICogMiA+IHBhZEhlaWdodCkge1xuICAgICAgICAgIHBhZFRvcCA9IHBhZEhlaWdodCAvIDI7XG4gICAgICAgICAgcGFkQm90dG9tID0gcGFkSGVpZ2h0IC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwYWRUb3AgPiBwYWRCb3R0b20pIHtcbiAgICAgICAgICBwYWRUb3AgPSBwYWRIZWlnaHQgLSBwYWRCb3R0b207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkQm90dG9tID0gcGFkSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoMiAqIG5ld1JhZGl1cyArIGhvcml6b250YWxQYWRkaW5nID4gc2VyaWVzQm94LndpZHRoKSB7XG4gICAgICAgIGNvbnN0IHBhZFdpZHRoID0gc2VyaWVzQm94LndpZHRoIC0gMiAqIG5ld1JhZGl1cztcbiAgICAgICAgaWYgKE1hdGgubWluKHBhZExlZnQsIHBhZFJpZ2h0KSAqIDIgPiBwYWRXaWR0aCkge1xuICAgICAgICAgIHBhZExlZnQgPSBwYWRXaWR0aCAvIDI7XG4gICAgICAgICAgcGFkUmlnaHQgPSBwYWRXaWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGFkTGVmdCA+IHBhZFJpZ2h0KSB7XG4gICAgICAgICAgcGFkTGVmdCA9IHBhZFdpZHRoIC0gcGFkUmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkUmlnaHQgPSBwYWRXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3V2lkdGggPSBwYWRMZWZ0ICsgMiAqIG5ld1JhZGl1cyArIHBhZFJpZ2h0O1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHBhZFRvcCArIDIgKiBuZXdSYWRpdXMgKyBwYWRCb3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlclg6IHNlcmllc0JveC54ICsgKHNlcmllc0JveC53aWR0aCAtIG5ld1dpZHRoKSAvIDIgKyBwYWRMZWZ0ICsgbmV3UmFkaXVzLFxuICAgICAgY2VudGVyWTogc2VyaWVzQm94LnkgKyAoc2VyaWVzQm94LmhlaWdodCAtIG5ld0hlaWdodCkgLyAyICsgcGFkVG9wICsgbmV3UmFkaXVzLFxuICAgICAgcmFkaXVzOiBuZXdSYWRpdXNcbiAgICB9O1xuICB9XG59O1xuUG9sYXJDaGFydC5jbGFzc05hbWUgPSBcIlBvbGFyQ2hhcnRcIjtcblBvbGFyQ2hhcnQudHlwZSA9IFwicG9sYXJcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3RvcG9sb2d5L21lcmNhdG9yU2NhbGUudHNcbnZhciByYWRzSW5EZWcgPSBNYXRoLlBJIC8gMTgwO1xudmFyIGxvblggPSAobG9uKSA9PiBsb24gKiByYWRzSW5EZWc7XG52YXIgbGF0WSA9IChsYXQpID0+IC1NYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJICogMC4yNSArIGxhdCAqIHJhZHNJbkRlZyAqIDAuNSkpO1xudmFyIHhMb24gPSAoeCkgPT4geCAvIHJhZHNJbkRlZztcbnZhciB5TGF0ID0gKHkpID0+IChNYXRoLmF0YW4oTWF0aC5leHAoLXkpKSAtIE1hdGguUEkgKiAwLjI1KSAvIChyYWRzSW5EZWcgKiAwLjUpO1xudmFyIE1lcmNhdG9yU2NhbGUgPSBjbGFzcyBfTWVyY2F0b3JTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGRvbWFpbiwgcmFuZ2UzKSB7XG4gICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlMztcbiAgICB0aGlzLnR5cGUgPSBcIm1lcmNhdG9yXCI7XG4gICAgdGhpcy5ib3VuZHMgPSBfTWVyY2F0b3JTY2FsZS5ib3VuZHMoZG9tYWluKTtcbiAgfVxuICBzdGF0aWMgYm91bmRzKGRvbWFpbikge1xuICAgIGNvbnN0IFtbbG9uMCwgbGF0MF0sIFtsb24xLCBsYXQxXV0gPSBkb21haW47XG4gICAgY29uc3QgeDAgPSBsb25YKGxvbjApO1xuICAgIGNvbnN0IHkwID0gbGF0WShsYXQwKTtcbiAgICBjb25zdCB4MSA9IGxvblgobG9uMSk7XG4gICAgY29uc3QgeTEgPSBsYXRZKGxhdDEpO1xuICAgIHJldHVybiBuZXcgQkJveChNYXRoLm1pbih4MCwgeDEpLCBNYXRoLm1pbih5MCwgeTEpLCBNYXRoLmFicyh4MSAtIHgwKSwgTWF0aC5hYnMoeTEgLSB5MCkpO1xuICB9XG4gIHN0YXRpYyBmaXhlZFNjYWxlKCkge1xuICAgIHJldHVybiBuZXcgX01lcmNhdG9yU2NhbGUoXG4gICAgICBbXG4gICAgICAgIFt4TG9uKDApLCB5TGF0KDApXSxcbiAgICAgICAgW3hMb24oMSksIHlMYXQoMSldXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxLCAxXVxuICAgICAgXVxuICAgICk7XG4gIH1cbiAgY29udmVydChbbG9uLCBsYXRdKSB7XG4gICAgY29uc3QgW1t4MCwgeTBdLCBbeDEsIHkxXV0gPSB0aGlzLnJhbmdlO1xuICAgIGNvbnN0IHhTY2FsZSA9ICh4MSAtIHgwKSAvIHRoaXMuYm91bmRzLndpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9ICh5MSAtIHkwKSAvIHRoaXMuYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gWyhsb25YKGxvbikgLSB0aGlzLmJvdW5kcy54KSAqIHhTY2FsZSArIHgwLCAobGF0WShsYXQpIC0gdGhpcy5ib3VuZHMueSkgKiB5U2NhbGUgKyB5MF07XG4gIH1cbiAgaW52ZXJ0KFt4LCB5XSkge1xuICAgIGNvbnN0IFtbeDAsIHkwXSwgW3gxLCB5MV1dID0gdGhpcy5yYW5nZTtcbiAgICBjb25zdCB4U2NhbGUgPSAoeDEgLSB4MCkgLyB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSAoeTEgLSB5MCkgLyB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIFt4TG9uKCh4IC0geDApIC8geFNjYWxlICsgdGhpcy5ib3VuZHMueCksIHlMYXQoKHkgLSB5MCkgLyB5U2NhbGUgKyB0aGlzLmJvdW5kcy55KV07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RvcG9sb2d5Q2hhcnQudHNcbmZ1bmN0aW9uIGlzVG9wb2xvZ3lTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiBzZXJpZXMudHlwZSA9PT0gXCJtYXAtc2hhcGVcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtbGluZVwiIHx8IHNlcmllcy50eXBlID09PSBcIm1hcC1tYXJrZXJcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtc2hhcGUtYmFja2dyb3VuZFwiIHx8IHNlcmllcy50eXBlID09PSBcIm1hcC1saW5lLWJhY2tncm91bmRcIjtcbn1cbnZhciBUb3BvbG9neUNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gICAgdGhpcy54QXhpcyA9IG5ldyBOdW1iZXJBeGlzKHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKTtcbiAgICB0aGlzLnhBeGlzLnBvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgICB0aGlzLnlBeGlzID0gbmV3IE51bWJlckF4aXModGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpO1xuICAgIHRoaXMueUF4aXMucG9zaXRpb24gPSBcImxlZnRcIjtcbiAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVBeGVzKFt0aGlzLnhBeGlzLCB0aGlzLnlBeGlzXSk7XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcInRvcG9sb2d5XCI7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0YSgpIHtcbiAgICBhd2FpdCBzdXBlci51cGRhdGVEYXRhKCk7XG4gICAgY29uc3QgeyB0b3BvbG9neSB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoaXNUb3BvbG9neVNlcmllcyhzZXJpZXMpKSB7XG4gICAgICAgIHNlcmllcy5zZXRDaGFydFRvcG9sb2d5KHRvcG9sb2d5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KCkge1xuICAgIGNvbnN0IHNocmlua1JlY3QgPSBhd2FpdCBzdXBlci5wZXJmb3JtTGF5b3V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgc2VyaWVzQXJlYTogeyBwYWRkaW5nIH0sXG4gICAgICBzZXJpZXNSb290LFxuICAgICAgYW5ub3RhdGlvblJvb3QsXG4gICAgICBoaWdobGlnaHRSb290XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZnVsbFNlcmllc1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCk7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5sZWZ0LCBcImxlZnRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy50b3AsIFwidG9wXCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcucmlnaHQsIFwicmlnaHRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5ib3R0b20sIFwiYm90dG9tXCIpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2hyaW5rUmVjdDtcbiAgICBjb25zdCBtYXBTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoaXNUb3BvbG9neVNlcmllcyk7XG4gICAgY29uc3QgY29tYmluZWRCYm94ID0gbWFwU2VyaWVzLnJlZHVjZSgoY29tYmluZWQsIHNlcmllcykgPT4ge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSlcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgICAgY29uc3QgYmJveCA9IHNlcmllcy50b3BvbG9neUJvdW5kcztcbiAgICAgIGlmIChiYm94ID09IG51bGwpXG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgIGlmIChjb21iaW5lZCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIGNvbWJpbmVkLm1lcmdlKGJib3gpO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH0sIHZvaWQgMCk7XG4gICAgbGV0IHNjYWxlMjtcbiAgICBpZiAoY29tYmluZWRCYm94ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgbG9uMCwgbGF0MCwgbG9uMSwgbGF0MSB9ID0gY29tYmluZWRCYm94O1xuICAgICAgY29uc3QgZG9tYWluID0gW1xuICAgICAgICBbbG9uMCwgbGF0MF0sXG4gICAgICAgIFtsb24xLCBsYXQxXVxuICAgICAgXTtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IE1lcmNhdG9yU2NhbGUuYm91bmRzKGRvbWFpbik7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNocmlua1JlY3Q7XG4gICAgICBjb25zdCB2aWV3Qm94U2NhbGUgPSBNYXRoLm1pbih3aWR0aCAvIGJvdW5kcy53aWR0aCwgaGVpZ2h0IC8gYm91bmRzLmhlaWdodCk7XG4gICAgICBjb25zdCB2aWV3Qm94V2lkdGggPSBib3VuZHMud2lkdGggKiB2aWV3Qm94U2NhbGU7XG4gICAgICBjb25zdCB2aWV3Qm94SGVpZ2h0ID0gYm91bmRzLmhlaWdodCAqIHZpZXdCb3hTY2FsZTtcbiAgICAgIGNvbnN0IHZpZXdCb3hPcmlnaW5YID0gKHdpZHRoIC0gdmlld0JveFdpZHRoKSAvIDI7XG4gICAgICBjb25zdCB2aWV3Qm94T3JpZ2luWSA9IChoZWlnaHQgLSB2aWV3Qm94SGVpZ2h0KSAvIDI7XG4gICAgICBjb25zdCB4MCA9IHZpZXdCb3hPcmlnaW5YO1xuICAgICAgY29uc3QgeTAgPSB2aWV3Qm94T3JpZ2luWTtcbiAgICAgIGNvbnN0IHgxID0gdmlld0JveE9yaWdpblggKyB2aWV3Qm94V2lkdGg7XG4gICAgICBjb25zdCB5MSA9IHZpZXdCb3hPcmlnaW5ZICsgdmlld0JveEhlaWdodDtcbiAgICAgIGNvbnN0IHhab29tID0gdGhpcy5jdHguem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20odGhpcy54QXhpcy5pZCk7XG4gICAgICBjb25zdCB5Wm9vbSA9IHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmdldEF4aXNab29tKHRoaXMueUF4aXMuaWQpO1xuICAgICAgY29uc3QgeFNwYW4gPSAoeDEgLSB4MCkgLyAoeFpvb20ubWF4IC0geFpvb20ubWluKTtcbiAgICAgIGNvbnN0IHhTdGFydCA9IHgwIC0geFNwYW4gKiB4Wm9vbS5taW47XG4gICAgICBjb25zdCB5U3BhbiA9ICh5MSAtIHkwKSAvICgxIC0geVpvb20ubWluIC0gKDEgLSB5Wm9vbS5tYXgpKTtcbiAgICAgIGNvbnN0IHlTdGFydCA9IHkwIC0geVNwYW4gKiAoMSAtIHlab29tLm1heCk7XG4gICAgICBzY2FsZTIgPSBuZXcgTWVyY2F0b3JTY2FsZShkb21haW4sIFtcbiAgICAgICAgW3hTdGFydCwgeVN0YXJ0XSxcbiAgICAgICAgW3hTdGFydCArIHhTcGFuLCB5U3RhcnQgKyB5U3Bhbl1cbiAgICAgIF0pO1xuICAgIH1cbiAgICBtYXBTZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMuc2NhbGUgPSBzY2FsZTI7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VyaWVzVmlzaWJsZSA9IHRoaXMuc2VyaWVzLnNvbWUoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gc2VyaWVzVmlzaWJsZTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC55KTtcbiAgICAgIGdyb3VwLnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShcbiAgICAgICAgbmV3IEJCb3goc2hyaW5rUmVjdC54LCBzaHJpbmtSZWN0LnksIHNocmlua1JlY3Qud2lkdGgsIHNocmlua1JlY3QuaGVpZ2h0KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaExheW91dENvbXBsZXRlKHtcbiAgICAgIHR5cGU6IFwibGF5b3V0LWNvbXBsZXRlXCIsXG4gICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5jdHguc2NlbmUud2lkdGgsIGhlaWdodDogdGhpcy5jdHguc2NlbmUuaGVpZ2h0IH0sXG4gICAgICBjbGlwU2VyaWVzOiBmYWxzZSxcbiAgICAgIHNlcmllczogeyByZWN0OiBmdWxsU2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogc2hyaW5rUmVjdCwgdmlzaWJsZTogc2VyaWVzVmlzaWJsZSB9LFxuICAgICAgYXhlczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gc2hyaW5rUmVjdDtcbiAgfVxufTtcblRvcG9sb2d5Q2hhcnQuY2xhc3NOYW1lID0gXCJUb3BvbG9neUNoYXJ0XCI7XG5Ub3BvbG9neUNoYXJ0LnR5cGUgPSBcInRvcG9sb2d5XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9lbnRlcnByaXNlTW9kdWxlLnRzXG52YXIgZW50ZXJwcmlzZU1vZHVsZSA9IHtcbiAgaXNFbnRlcnByaXNlOiBmYWxzZVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3ByZXNldC9wcmljZVZvbHVtZVByZXNldC50c1xuZnVuY3Rpb24gZnJvbVRoZW1lKHRoZW1lLCBjYikge1xuICBpZiAoaXNPYmplY3QodGhlbWUpKSB7XG4gICAgcmV0dXJuIGNiKHRoZW1lKTtcbiAgfVxufVxudmFyIGNoYXJ0VHlwZXMyID0gW1wib2hsY1wiLCBcImxpbmVcIiwgXCJzdGVwLWxpbmVcIiwgXCJobGNcIiwgXCJoaWdoLWxvd1wiLCBcImNhbmRsZXN0aWNrXCIsIFwiaG9sbG93LWNhbmRsZXN0aWNrXCJdO1xuZnVuY3Rpb24gcHJpY2VWb2x1bWUob3B0cywgZ2V0VGhlbWUpIHtcbiAgY29uc3Qge1xuICAgIHhLZXksXG4gICAgZGF0ZUtleSA9IHhLZXkgPz8gXCJkYXRlXCIsXG4gICAgaGlnaEtleSA9IFwiaGlnaFwiLFxuICAgIG9wZW5LZXkgPSBcIm9wZW5cIixcbiAgICBsb3dLZXkgPSBcImxvd1wiLFxuICAgIGNsb3NlS2V5ID0gXCJjbG9zZVwiLFxuICAgIHZvbHVtZUtleSA9IFwidm9sdW1lXCIsXG4gICAgY2hhcnRUeXBlOiBjaGFydFR5cGUyID0gXCJjYW5kbGVzdGlja1wiLFxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yMiA9IGZhbHNlLFxuICAgIHZvbHVtZSA9IHRydWUsXG4gICAgcmFuZ2VUb29sYmFyLFxuICAgIHJhbmdlQnV0dG9ucyA9IHJhbmdlVG9vbGJhciA/PyB0cnVlLFxuICAgIHN0YXR1c0JhciA9IHRydWUsXG4gICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zMixcbiAgICB0b29sYmFyID0gYW5ub3RhdGlvbnMyID8/IHRydWUsXG4gICAgem9vbTogem9vbTIgPSB0cnVlLFxuICAgIHRoZW1lLFxuICAgIGRhdGEsXG4gICAgLi4udW51c2VkT3B0c1xuICB9ID0gb3B0cztcbiAgaWYgKHhLZXkgIT0gbnVsbCkge1xuICAgIExvZ2dlci53YXJuT25jZShcIlByb3BlcnR5IFt4S2V5XSBpcyBkZXByZWNhdGVkLCB1c2UgW2RhdGVLZXldIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChyYW5nZVRvb2xiYXIgIT0gbnVsbCkge1xuICAgIExvZ2dlci53YXJuT25jZShcIlByb3BlcnR5IFtyYW5nZVRvb2xiYXJdIGlzIGRlcHJlY2F0ZWQsIHVzZSBbcmFuZ2VCdXR0b25zXSBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAoYW5ub3RhdGlvbnMyICE9IG51bGwpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXCJQcm9wZXJ0eSBbYW5ub3RhdGlvbnNdIGlzIGRlcHJlY2F0ZWQsIHVzZSBbdG9vbGJhcl0gaW5zdGVhZC5cIik7XG4gIH1cbiAgY29uc3QgcHJpY2VTZXJpZXMgPSBjcmVhdGVQcmljZVNlcmllcyh0aGVtZSwgY2hhcnRUeXBlMiwgZGF0ZUtleSwgaGlnaEtleSwgbG93S2V5LCBvcGVuS2V5LCBjbG9zZUtleSk7XG4gIGNvbnN0IHZvbHVtZVNlcmllcyA9IGNyZWF0ZVZvbHVtZVNlcmllcyh0aGVtZSwgZ2V0VGhlbWUsIG9wZW5LZXksIGNsb3NlS2V5LCB2b2x1bWUsIHZvbHVtZUtleSk7XG4gIGNvbnN0IG1pbmlDaGFydCA9IHZvbHVtZSA/IHtcbiAgICBtaW5pQ2hhcnQ6IHtcbiAgICAgIGVuYWJsZWQ6IG5hdmlnYXRvcjIsXG4gICAgICBzZXJpZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgIHhLZXk6IGRhdGVLZXksXG4gICAgICAgICAgeUtleTogdm9sdW1lS2V5LFxuICAgICAgICAgIG1hcmtlcjogeyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIH0gOiBudWxsO1xuICBjb25zdCBuYXZpZ2F0b3JPcHRzID0ge1xuICAgIG5hdmlnYXRvcjoge1xuICAgICAgZW5hYmxlZDogbmF2aWdhdG9yMixcbiAgICAgIC4uLm1pbmlDaGFydFxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhdHVzQmFyT3B0cyA9IHN0YXR1c0JhciA/IHtcbiAgICBzdGF0dXNCYXI6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBkYXRhLFxuICAgICAgaGlnaEtleSxcbiAgICAgIG9wZW5LZXksXG4gICAgICBsb3dLZXksXG4gICAgICBjbG9zZUtleSxcbiAgICAgIHZvbHVtZUtleTogdm9sdW1lID8gdm9sdW1lS2V5IDogdm9pZCAwXG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3Qgem9vbU9wdHMgPSB7XG4gICAgem9vbToge1xuICAgICAgZW5hYmxlZDogem9vbTIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBlbmFibGVJbmRlcGVuZGVudEF4ZXM6IHRydWVcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRvb2xiYXJPcHRzID0ge1xuICAgIGNoYXJ0VG9vbGJhcjogeyBlbmFibGVkOiB0cnVlIH0sXG4gICAgdG9vbGJhcjoge1xuICAgICAgc2VyaWVzVHlwZToge1xuICAgICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgICB9LFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgICAgfSxcbiAgICAgIGFubm90YXRpb25zOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRvb2xiYXJcbiAgICAgIH0sXG4gICAgICByYW5nZXM6IHtcbiAgICAgICAgZW5hYmxlZDogcmFuZ2VCdXR0b25zXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB2b2x1bWVBeGlzID0gdm9sdW1lID8gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgICBrZXlzOiBbdm9sdW1lS2V5XSxcbiAgICAgIGxhYmVsOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBjcm9zc2hhaXI6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBuaWNlOiBmYWxzZSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGxheW91dENvbnN0cmFpbnRzOiB7XG4gICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMjAsXG4gICAgICAgIHVuaXQ6IFwicGVyY2VudGFnZVwiLFxuICAgICAgICBhbGlnbjogXCJlbmRcIlxuICAgICAgfVxuICAgIH1cbiAgXSA6IFtdO1xuICByZXR1cm4ge1xuICAgIHRoZW1lOiB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IHtcbiAgICAgIGJhc2VUaGVtZTogXCJhZy1maW5hbmNpYWxcIixcbiAgICAgIC4uLnRoZW1lID8/IHt9XG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBsZWdlbmQ6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBzZXJpZXM6IFsuLi52b2x1bWVTZXJpZXMsIC4uLnByaWNlU2VyaWVzXSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDYsXG4gICAgICByaWdodDogOCxcbiAgICAgIGJvdHRvbTogNVxuICAgIH0sXG4gICAgYXhlczogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgICAgICBrZXlzOiBbb3BlbktleSwgY2xvc2VLZXksIGhpZ2hLZXksIGxvd0tleV0sXG4gICAgICAgIGludGVydmFsOiB7XG4gICAgICAgICAgbWF4U3BhY2luZzogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNvbW1vbj8uYXhlcz8ubnVtYmVyPy5pbnRlcnZhbD8ubWF4U3BhY2luZykgPz8gNDVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBmb3JtYXQ6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5jb21tb24/LmF4ZXM/Lm51bWJlcj8ubGFiZWw/LmZvcm1hdCkgPz8gXCIuMmZcIlxuICAgICAgICB9LFxuICAgICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHNuYXA6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGF5b3V0Q29uc3RyYWludHM6IHtcbiAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICAgIHVuaXQ6IFwicGVyY2VudGFnZVwiLFxuICAgICAgICAgIGFsaWduOiBcInN0YXJ0XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLnZvbHVtZUF4aXMsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwib3JkaW5hbC10aW1lXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0sXG4gICAgYW5ub3RhdGlvbnM6IHtcbiAgICAgIGVuYWJsZWQ6IHRvb2xiYXJcbiAgICB9LFxuICAgIHRvb2x0aXA6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBkYXRhLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB0aXRsZVBhZGRpbmc6IDQsXG4gICAgLi4ubmF2aWdhdG9yT3B0cyxcbiAgICAuLi5zdGF0dXNCYXJPcHRzLFxuICAgIC4uLnpvb21PcHRzLFxuICAgIC4uLnRvb2xiYXJPcHRzLFxuICAgIC4uLnVudXNlZE9wdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZvbHVtZVNlcmllcyh0aGVtZSwgZ2V0VGhlbWUsIG9wZW5LZXksIGNsb3NlS2V5LCB2b2x1bWUsIHZvbHVtZUtleSkge1xuICBpZiAoIXZvbHVtZSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGJhclNlcmllc0ZpbGwgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uYmFyPy5zZXJpZXM/LmZpbGwpO1xuICBjb25zdCBpdGVtU3R5bGVyID0gYmFyU2VyaWVzRmlsbCA/IHsgZmlsbDogYmFyU2VyaWVzRmlsbCB9IDoge1xuICAgIGl0ZW1TdHlsZXIoeyBkYXR1bSB9KSB7XG4gICAgICBjb25zdCB7IHVwLCBkb3duIH0gPSBnZXRUaGVtZSgpLnBhbGV0dGU7XG4gICAgICByZXR1cm4geyBmaWxsOiBkYXR1bVtvcGVuS2V5XSA8IGRhdHVtW2Nsb3NlS2V5XSA/IHVwPy5maWxsIDogZG93bj8uZmlsbCB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgeEtleTogXCJkYXRlXCIsXG4gICAgICB5S2V5OiB2b2x1bWVLZXksXG4gICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoaWdobGlnaHQ6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uYmFyPy5zZXJpZXM/LmZpbGxPcGFjaXR5KSA/PyAwLjUsXG4gICAgICAuLi5pdGVtU3R5bGVyXG4gICAgfVxuICBdO1xufVxudmFyIFJBTkdFX0FSRUFfVFlQRSA9IFwicmFuZ2UtYXJlYVwiO1xuZnVuY3Rpb24gY3JlYXRlUHJpY2VTZXJpZXModGhlbWUsIGNoYXJ0VHlwZTIsIHhLZXksIGhpZ2hLZXksIGxvd0tleSwgb3BlbktleSwgY2xvc2VLZXkpIHtcbiAgaWYgKGNoYXJ0VHlwZTIgPT09IFJBTkdFX0FSRUFfVFlQRSkge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtjaGFydFR5cGUyfScgaXMgZGVwcmVjYXRlZCwgdXNlICdobGMnIGNoYXJ0IHR5cGUgaW5zdGVhZGApO1xuICAgIGNoYXJ0VHlwZTIgPSBcImhsY1wiO1xuICB9XG4gIGNvbnN0IGtleXMgPSB7XG4gICAgeEtleSxcbiAgICBvcGVuS2V5LFxuICAgIGNsb3NlS2V5LFxuICAgIGhpZ2hLZXksXG4gICAgbG93S2V5XG4gIH07XG4gIGNvbnN0IHNpbmdsZUtleXMgPSB7XG4gICAgeEtleSxcbiAgICB5S2V5OiBjbG9zZUtleVxuICB9O1xuICBjb25zdCBjb21tb24gPSB7XG4gICAgcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzOiB0cnVlXG4gIH07XG4gIHN3aXRjaCAoY2hhcnRUeXBlMiA/PyBcImNhbmRsZXN0aWNrXCIpIHtcbiAgICBjYXNlIFwib2hsY1wiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2hsY1wiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImxpbmVcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgICAgICBzdHJva2U6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZSkgPz8gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcInN0ZXAtbGluZVwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5zaW5nbGVLZXlzLFxuICAgICAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIGludGVycG9sYXRpb246IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LmludGVycG9sYXRpb24pID8/IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RlcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImhsY1wiOlxuICAgICAgY29uc3QgcmFuZ2VBcmVhQ29sb3JzID0gZ2V0VGhlbWVDb2xvcnMoUkFOR0VfQVJFQV9UWVBFLCB0aGVtZSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogUkFOR0VfQVJFQV9UWVBFLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHlIaWdoS2V5OiBoaWdoS2V5LFxuICAgICAgICAgIHlMb3dLZXk6IGNsb3NlS2V5LFxuICAgICAgICAgIGZpbGw6IHJhbmdlQXJlYUNvbG9ycy5maWxsID8/IFBBTEVUVEVfVVBfRklMTCxcbiAgICAgICAgICBzdHJva2U6IHJhbmdlQXJlYUNvbG9ycy5zdHJva2UgPz8gUEFMRVRURV9VUF9TVFJPS0UsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LmZpbGxPcGFjaXR5KSA/PyAwLjMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LnN0cm9rZVdpZHRoKSA/PyAyXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBSQU5HRV9BUkVBX1RZUEUsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIHhLZXksXG4gICAgICAgICAgeUhpZ2hLZXk6IGNsb3NlS2V5LFxuICAgICAgICAgIHlMb3dLZXk6IGxvd0tleSxcbiAgICAgICAgICBmaWxsOiByYW5nZUFyZWFDb2xvcnMuZmlsbCA/PyBQQUxFVFRFX0RPV05fRklMTCxcbiAgICAgICAgICBzdHJva2U6IHJhbmdlQXJlYUNvbG9ycy5zdHJva2UgPz8gUEFMRVRURV9ET1dOX1NUUk9LRSxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uZmlsbE9wYWNpdHkpID8/IDAuMyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5zaW5nbGVLZXlzLFxuICAgICAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDIsXG4gICAgICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJoaWdoLWxvd1wiOlxuICAgICAgY29uc3QgcmFuZ2VCYXJDb2xvcnMgPSBnZXRUaGVtZUNvbG9ycyhcInJhbmdlLWJhclwiLCB0aGVtZSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJyYW5nZS1iYXJcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgeEtleSxcbiAgICAgICAgICB5SGlnaEtleTogaGlnaEtleSxcbiAgICAgICAgICB5TG93S2V5OiBsb3dLZXksXG4gICAgICAgICAgZmlsbDogcmFuZ2VCYXJDb2xvcnMuZmlsbCA/PyBQQUxFVFRFX05FVVRSQUxfRklMTCxcbiAgICAgICAgICBzdHJva2U6IHJhbmdlQmFyQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHJhbmdlOiBcIm5lYXJlc3RcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiY2FuZGxlc3RpY2tcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLmtleXNcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiaG9sbG93LWNhbmRsZXN0aWNrXCI6XG4gICAgICBjb25zdCBpdGVtID0gZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNhbmRsZXN0aWNrPy5zZXJpZXM/Lml0ZW0pO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY2FuZGxlc3RpY2tcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICB1cDoge1xuICAgICAgICAgICAgICBmaWxsOiBpdGVtPy51cD8uZmlsbCA/PyBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgIExvZ2dlci53YXJuT25jZShgdW5rbm93biBjaGFydCB0eXBlOiAke2NoYXJ0VHlwZTJ9OyBleHBlY3RlZCBvbmUgb2Y6ICR7Y2hhcnRUeXBlczIuam9pbihcIiwgXCIpfWApO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY2FuZGxlc3RpY2tcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5c1xuICAgICAgICB9XG4gICAgICBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUaGVtZUNvbG9ycyhzZXJpZXNUeXBlMiwgdGhlbWUpIHtcbiAgY29uc3QgZmlsbCA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bc2VyaWVzVHlwZTJdPy5zZXJpZXM/LmZpbGwpO1xuICBjb25zdCBzdHJva2UgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW3Nlcmllc1R5cGUyXT8uc2VyaWVzPy5zdHJva2UpO1xuICByZXR1cm4geyBmaWxsLCBzdHJva2UgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3ByZXNldC9wcmVzZXRzLnRzXG52YXIgUFJFU0VUUyA9IHtcbiAgXCJwcmljZS12b2x1bWVcIjogcHJpY2VWb2x1bWVcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvcHJvY2Vzc0VudGVycHJpc2VPcHRpb25zLnRzXG5mdW5jdGlvbiByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnMob3B0aW9ucywgc2lsZW50KSB7XG4gIGNvbnN0IHVzZWRPcHRpb25zID0gW107XG4gIGNvbnN0IG9wdGlvbnNDaGFydFR5cGUgPSBjaGFydFR5cGVzLmdldChvcHRpb25zVHlwZShvcHRpb25zKSk7XG4gIGZvciAoY29uc3Qge1xuICAgIHR5cGUsXG4gICAgY2hhcnRUeXBlczogbW9kdWxlQ2hhcnRUeXBlcyxcbiAgICBvcHRpb25zS2V5LFxuICAgIG9wdGlvbnNJbm5lcktleSxcbiAgICBpZGVudGlmaWVyXG4gIH0gb2YgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTKSB7XG4gICAgaWYgKG9wdGlvbnNDaGFydFR5cGUgIT09IFwidW5rbm93blwiICYmICFtb2R1bGVDaGFydFR5cGVzLmluY2x1ZGVzKG9wdGlvbnNDaGFydFR5cGUpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGUgPT09IFwicm9vdFwiIHx8IHR5cGUgPT09IFwibGVnZW5kXCIpIHtcbiAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gb3B0aW9uc1tvcHRpb25zS2V5XTtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICghb3B0aW9uc0lubmVyS2V5KSB7XG4gICAgICAgIHVzZWRPcHRpb25zLnB1c2gob3B0aW9uc0tleSk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbnNLZXldO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25WYWx1ZVtvcHRpb25zSW5uZXJLZXldKSB7XG4gICAgICAgIHVzZWRPcHRpb25zLnB1c2goYCR7b3B0aW9uc0tleX0uJHtvcHRpb25zSW5uZXJLZXl9YCk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25WYWx1ZVtvcHRpb25zSW5uZXJLZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJheGlzXCIpIHtcbiAgICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXM/LnNvbWUoKGF4aXMpID0+IGF4aXMudHlwZSA9PT0gaWRlbnRpZmllcikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgYXhpc1t0eXBlPSR7aWRlbnRpZmllcn1dYCk7XG4gICAgICBvcHRpb25zLmF4ZXMgPSBvcHRpb25zLmF4ZXMuZmlsdGVyKChheGlzKSA9PiBheGlzLnR5cGUgIT09IGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJheGlzLW9wdGlvblwiKSB7XG4gICAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSB8fCAhb3B0aW9ucy5heGVzPy5zb21lKChheGlzKSA9PiBheGlzW29wdGlvbnNLZXldKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB1c2VkT3B0aW9ucy5wdXNoKGBheGlzLiR7b3B0aW9uc0tleX1gKTtcbiAgICAgIG9wdGlvbnMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICAgIGlmIChheGlzW29wdGlvbnNLZXldKSB7XG4gICAgICAgICAgZGVsZXRlIGF4aXNbb3B0aW9uc0tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgaWYgKCFvcHRpb25zLnNlcmllcz8uc29tZSgoc2VyaWVzKSA9PiBzZXJpZXMudHlwZSA9PT0gaWRlbnRpZmllcikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgc2VyaWVzW3R5cGU9JHtpZGVudGlmaWVyfV1gKTtcbiAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMuZmlsdGVyKChzZXJpZXMpID0+IHNlcmllcy50eXBlICE9PSBpZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2VyaWVzLW9wdGlvblwiKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2VyaWVzPy5zb21lKChzZXJpZXMpID0+IHNlcmllc1tvcHRpb25zS2V5XSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgc2VyaWVzLiR7b3B0aW9uc0tleX1gKTtcbiAgICAgIG9wdGlvbnMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBpZiAoc2VyaWVzW29wdGlvbnNLZXldKSB7XG4gICAgICAgICAgZGVsZXRlIHNlcmllc1tvcHRpb25zS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh1c2VkT3B0aW9ucy5sZW5ndGggJiYgIXNpbGVudCkge1xuICAgIGxldCBlbnRlcnByaXNlUGFja2FnZU5hbWUgPSBcImFnLWNoYXJ0cy1lbnRlcnByaXNlXCI7XG4gICAgbGV0IGVudGVycHJpc2VSZWZlcmVuY2VVcmwgPSBcImh0dHBzOi8vY2hhcnRzLmFnLWdyaWQuY29tL2phdmFzY3JpcHQvaW5zdGFsbGF0aW9uL1wiO1xuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICBlbnRlcnByaXNlUGFja2FnZU5hbWUgPSBcImFnLWdyaWQtY2hhcnRzLWVudGVycHJpc2UnIG9yICdhZy1ncmlkLWVudGVycHJpc2UvY2hhcnRzLWVudGVycHJpc2VcIjtcbiAgICAgIGVudGVycHJpc2VSZWZlcmVuY2VVcmwgPSBcImh0dHBzOi8vd3d3LmFnLWdyaWQuY29tL2phdmFzY3JpcHQtZGF0YS1ncmlkL2ludGVncmF0ZWQtY2hhcnRzLWluc3RhbGxhdGlvbi9cIjtcbiAgICB9XG4gICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgW1xuICAgICAgICBgdW5hYmxlIHRvIHVzZSB0aGVzZSBlbnRlcnByaXNlIGZlYXR1cmVzIGFzICcke2VudGVycHJpc2VQYWNrYWdlTmFtZX0nIGhhcyBub3QgYmVlbiBsb2FkZWQ6YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgLi4udXNlZE9wdGlvbnMsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIGBTZWU6ICR7ZW50ZXJwcmlzZVJlZmVyZW5jZVVybH1gXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc3RyaW5nLnV0aWwudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggPSBJbmZpbml0eSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCl9Li4uICgrJHt2YWx1ZS5sZW5ndGggLSBtYXhMZW5ndGh9IGNoYXJhY3RlcnMpYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZhbGlkYXRlLnRzXG52YXIgZGVzY3JpcHRpb25TeW1ib2wgPSBTeW1ib2woXCJkZXNjcmlwdGlvblwiKTtcbnZhciByZXF1aXJlZFN5bWJvbCA9IFN5bWJvbChcInJlcXVpcmVkXCIpO1xuZnVuY3Rpb24gaXNWYWxpZChvcHRpb25zLCBvcHRpb25zRGVmcywgcGF0aCkge1xuICBjb25zdCB7IGVycm9ycyB9ID0gdmFsaWRhdGUob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGgpO1xuICBmb3IgKGNvbnN0IHsgbWVzc2FnZSB9IG9mIGVycm9ycykge1xuICAgIExvZ2dlci53YXJuKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHBhdGgsIHZhbHVlLCB2YWxpZGF0b3JPckRlZnMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBpc1N0cmluZyh2YWxpZGF0b3JPckRlZnMpID8gdmFsaWRhdG9yT3JEZWZzIDogdmFsaWRhdG9yT3JEZWZzW2Rlc2NyaXB0aW9uU3ltYm9sXTtcbiAgY29uc3QgZXhwZWN0aW5nID0gZGVzY3JpcHRpb24gPyBgOyBleHBlY3RpbmcgJHtkZXNjcmlwdGlvbn1gIDogXCJcIjtcbiAgY29uc3QgcHJlZml4ID0gcGF0aCA/IGBPcHRpb24gXFxgJHtwYXRofVxcYGAgOiBcIlZhbHVlXCI7XG4gIHJldHVybiBgJHtwcmVmaXh9IGNhbm5vdCBiZSBzZXQgdG8gXFxgJHtzdHJpbmdpZnlWYWx1ZSh2YWx1ZSl9XFxgJHtleHBlY3Rpbmd9LCBpZ25vcmluZy5gO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IG51bGwsXG4gICAgICBlcnJvcnM6IFt7IHBhdGgsIHZhbHVlOiBvcHRpb25zLCBtZXNzYWdlOiB2YWxpZGF0ZU1lc3NhZ2UocGF0aCwgb3B0aW9ucywgXCJhbiBvYmplY3RcIikgfV1cbiAgICB9O1xuICB9XG4gIGNvbnN0IG9wdGlvbnNLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhvcHRpb25zKSk7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCB2YWxpZCA9IHt9O1xuICBmdW5jdGlvbiBleHRlbmRQYXRoKGtleSkge1xuICAgIGlmIChpc0FycmF5KG9wdGlvbnNEZWZzKSkge1xuICAgICAgcmV0dXJuIGAke3BhdGh9WyR7a2V5fV1gO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWxpZGF0b3JPckRlZnNdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNEZWZzKSkge1xuICAgIG9wdGlvbnNLZXlzLmRlbGV0ZShrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgIGlmICghdmFsaWRhdG9yT3JEZWZzW3JlcXVpcmVkU3ltYm9sXSAmJiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3JPckRlZnMpKSB7XG4gICAgICBpZiAodmFsaWRhdG9yT3JEZWZzKHZhbHVlKSkge1xuICAgICAgICB2YWxpZFtrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaCh7IGtleSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IHZhbGlkYXRlTWVzc2FnZShleHRlbmRQYXRoKGtleSksIHZhbHVlLCB2YWxpZGF0b3JPckRlZnMpIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXN0ZWRSZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzLCBleHRlbmRQYXRoKGtleSkpO1xuICAgICAgdmFsaWRba2V5XSA9IG5lc3RlZFJlc3VsdC52YWxpZDtcbiAgICAgIGVycm9ycy5wdXNoKC4uLm5lc3RlZFJlc3VsdC5lcnJvcnMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIHBhdGgsXG4gICAgICB1bmtub3duOiB0cnVlLFxuICAgICAgbWVzc2FnZTogYFVua25vd24gb3B0aW9uIFxcYCR7ZXh0ZW5kUGF0aChrZXkpfVxcYCwgaWdub3JpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7IHZhbGlkLCBlcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIGF0dGFjaERlc2NyaXB0aW9uKHZhbGlkYXRvciwgZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKHZhbHVlKSA9PiB2YWxpZGF0b3IodmFsdWUpLCB7IFtkZXNjcmlwdGlvblN5bWJvbF06IGRlc2NyaXB0aW9uIH0pO1xufVxudmFyIG9yID0gKC4uLnZhbGlkYXRvcnMpID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IHZhbGlkYXRvcnMuc29tZSgodmFsaWRhdG9yKSA9PiB2YWxpZGF0b3IodmFsdWUpKSxcbiAgdmFsaWRhdG9ycy5tYXAoKHYpID0+IHZbZGVzY3JpcHRpb25TeW1ib2xdKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBvciBcIilcbik7XG52YXIgYXJyYXkgPSBhdHRhY2hEZXNjcmlwdGlvbihpc0FycmF5LCBcImFuIGFycmF5XCIpO1xudmFyIGJvb2xlYW4gPSBhdHRhY2hEZXNjcmlwdGlvbihpc0Jvb2xlYW4sIFwiYSBib29sZWFuXCIpO1xudmFyIGNhbGxiYWNrID0gYXR0YWNoRGVzY3JpcHRpb24oaXNGdW5jdGlvbiwgXCJhIGZ1bmN0aW9uXCIpO1xudmFyIG51bWJlciA9IGF0dGFjaERlc2NyaXB0aW9uKGlzRmluaXRlTnVtYmVyLCBcImEgbnVtYmVyXCIpO1xudmFyIG9iamVjdCA9IGF0dGFjaERlc2NyaXB0aW9uKGlzT2JqZWN0LCBcImFuIG9iamVjdFwiKTtcbnZhciBzdHJpbmcgPSBhdHRhY2hEZXNjcmlwdGlvbihpc1N0cmluZywgXCJhIHN0cmluZ1wiKTtcbnZhciBudW1iZXJNaW4gPSAobWluLCBpbmNsdXNpdmUgPSB0cnVlKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgKHZhbHVlID4gbWluIHx8IGluY2x1c2l2ZSAmJiB2YWx1ZSA9PT0gbWluKSxcbiAgYGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAke2luY2x1c2l2ZSA/IFwib3IgZXF1YWwgdG8gXCIgOiBcIlwifSR7bWlufWBcbik7XG52YXIgbnVtYmVyUmFuZ2UgPSAobWluLCBtYXgpID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4LFxuICBgYSBudW1iZXIgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSBpbmNsdXNpdmVgXG4pO1xudmFyIHBvc2l0aXZlTnVtYmVyID0gbnVtYmVyTWluKDApO1xudmFyIG1pbk9uZU51bWJlciA9IG51bWJlck1pbigxKTtcbnZhciByYXRpbyA9IG51bWJlclJhbmdlKDAsIDEpO1xudmFyIGRlZ3JlZSA9IG51bWJlclJhbmdlKDAsIDM2MCk7XG52YXIgYXJyYXlPZiA9ICh2YWxpZGF0b3IsIGRlc2NyaXB0aW9uKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWxpZGF0b3IpLFxuICBkZXNjcmlwdGlvbiA/PyBgJHt2YWxpZGF0b3JbZGVzY3JpcHRpb25TeW1ib2xdfSBhcnJheWBcbik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9jb3JlTW9kdWxlc1R5cGVzLnRzXG5mdW5jdGlvbiBwYWxldHRlVHlwZShwYXJ0aWFsKSB7XG4gIGlmIChwYXJ0aWFsPy51cCB8fCBwYXJ0aWFsPy5kb3duIHx8IHBhcnRpYWw/Lm5ldXRyYWwpIHtcbiAgICByZXR1cm4gXCJ1c2VyLWZ1bGxcIjtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsPy5maWxscyB8fCBwYXJ0aWFsPy5zdHJva2VzKSB7XG4gICAgcmV0dXJuIFwidXNlci1pbmRleGVkXCI7XG4gIH1cbiAgcmV0dXJuIFwiaW5idWlsdFwiO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvY2hhcnRUaGVtZS50c1xudmFyIERFRkFVTFRfQkFDS0dST1VORF9GSUxMID0gXCJ3aGl0ZVwiO1xudmFyIENIQVJUX1RZUEVfQ09ORklHID0ge1xuICBnZXQgY2FydGVzaWFuKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmNhcnRlc2lhblR5cGVzLCBjb21tb25PcHRpb25zOiBbXCJ6b29tXCIsIFwibmF2aWdhdG9yXCJdIH07XG4gIH0sXG4gIGdldCBwb2xhcigpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5wb2xhclR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9LFxuICBnZXQgaGllcmFyY2h5KCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmhpZXJhcmNoeVR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9LFxuICBnZXQgdG9wb2xvZ3koKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMudG9wb2xvZ3lUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IFwiZmxvdy1wcm9wb3J0aW9uXCIoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMuZmxvd1Byb3BvcnRpb25UeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfVxufTtcbnZhciBDSEFSVF9UWVBFX1NQRUNJRklDX0NPTU1PTl9PUFRJT05TID0gT2JqZWN0LnZhbHVlcyhDSEFSVF9UWVBFX0NPTkZJRykucmVkdWNlKChyLCB7IGNvbW1vbk9wdGlvbnMgfSkgPT4gci5jb25jYXQoY29tbW9uT3B0aW9ucyksIFtdKTtcbnZhciBfQ2hhcnRUaGVtZSA9IGNsYXNzIF9DaGFydFRoZW1lIHtcbiAgc3RhdGljIGdldEF4aXNEZWZhdWx0cyhvdmVycmlkZURlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMob3ZlcnJpZGVEZWZhdWx0cywge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6IFwiQXhpcyBUaXRsZVwiLFxuICAgICAgICBzcGFjaW5nOiAyNSxcbiAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICAgIGZvbnRTaXplOiAxMyAvKiBNRURJVU0gKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgcGFkZGluZzogNSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgICBhdm9pZENvbGxpc2lvbnM6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6IERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIHRpY2s6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6IERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIGdyaWRMaW5lOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHN0eWxlOiBbeyBzdHJva2U6IERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgbGluZURhc2g6IFtdIH1dXG4gICAgICB9LFxuICAgICAgY3Jvc3NMaW5lczoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZmlsbDogREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsXG4gICAgICAgIHN0cm9rZTogREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjEsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldENoYXJ0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbkhlaWdodDogMzAwLFxuICAgICAgbWluV2lkdGg6IDMwMCxcbiAgICAgIGJhY2tncm91bmQ6IHsgdmlzaWJsZTogdHJ1ZSwgZmlsbDogREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiB9LFxuICAgICAgcGFkZGluZzogeyB0b3A6IERFRkFVTFRfUEFERElORywgcmlnaHQ6IERFRkFVTFRfUEFERElORywgYm90dG9tOiBERUZBVUxUX1BBRERJTkcsIGxlZnQ6IERFRkFVTFRfUEFERElORyB9LFxuICAgICAga2V5Ym9hcmQ6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6IFwiVGl0bGVcIixcbiAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICAgIGZvbnRTaXplOiAxNyAvKiBMQVJHRSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgICB3cmFwcGluZzogXCJoeXBoZW5hdGVcIixcbiAgICAgICAgbGF5b3V0U3R5bGU6IERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsXG4gICAgICAgIHRleHRBbGlnbjogREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVFxuICAgICAgfSxcbiAgICAgIHN1YnRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIlN1YnRpdGxlXCIsXG4gICAgICAgIHNwYWNpbmc6IDIwLFxuICAgICAgICBmb250U2l6ZTogMTMgLyogTUVESVVNICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gICAgICAgIHdyYXBwaW5nOiBcImh5cGhlbmF0ZVwiLFxuICAgICAgICBsYXlvdXRTdHlsZTogREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgICAgICAgdGV4dEFsaWduOiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UXG4gICAgICB9LFxuICAgICAgZm9vdG5vdGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6IFwiRm9vdG5vdGVcIixcbiAgICAgICAgc3BhY2luZzogMjAsXG4gICAgICAgIGZvbnRTaXplOiAxMyAvKiBNRURJVU0gKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBcInJnYigxNDAsIDE0MCwgMTQwKVwiLFxuICAgICAgICB3cmFwcGluZzogXCJoeXBoZW5hdGVcIixcbiAgICAgICAgbGF5b3V0U3R5bGU6IERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsXG4gICAgICAgIHRleHRBbGlnbjogREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVFxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi8sXG4gICAgICAgIHNwYWNpbmc6IDMwLFxuICAgICAgICBsaXN0ZW5lcnM6IHt9LFxuICAgICAgICB0b2dnbGVTZXJpZXM6IHRydWUsXG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBwYWRkaW5nWDogMTYsXG4gICAgICAgICAgcGFkZGluZ1k6IDgsXG4gICAgICAgICAgbWFya2VyOiB7IHNpemU6IDE1LCBwYWRkaW5nOiA4IH0sXG4gICAgICAgICAgc2hvd1Nlcmllc1N0cm9rZTogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmV2ZXJzZU9yZGVyOiBmYWxzZSxcbiAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgIG1hcmtlcjogeyBzaXplOiAxMiB9LFxuICAgICAgICAgIGFjdGl2ZVN0eWxlOiB7IGZpbGw6IERFRkFVTFRfTEFCRUxfQ09MT1VSIH0sXG4gICAgICAgICAgaW5hY3RpdmVTdHlsZTogeyBmaWxsOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUiB9LFxuICAgICAgICAgIGhpZ2hsaWdodFN0eWxlOiB7IGZpbGw6IERFRkFVTFRfTEFCRUxfQ09MT1VSIH0sXG4gICAgICAgICAgbGFiZWw6IHsgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZGFya1RoZW1lOiBJU19EQVJLX1RIRU1FLFxuICAgICAgICBkZWxheTogMFxuICAgICAgfSxcbiAgICAgIG92ZXJsYXlzOiB7IGRhcmtUaGVtZTogSVNfREFSS19USEVNRSB9LFxuICAgICAgbGlzdGVuZXJzOiB7fVxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBvdmVycmlkZXMsIHBhbGV0dGUgfSA9IGRlZXBDbG9uZShvcHRpb25zKTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHRoaXMuY3JlYXRlQ2hhcnRDb25maWdQZXJDaGFydFR5cGUodGhpcy5nZXREZWZhdWx0cygpKTtcbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLm1lcmdlT3ZlcnJpZGVzKGRlZmF1bHRzLCBvdmVycmlkZXMpO1xuICAgIH1cbiAgICBjb25zdCB7IGZpbGxzLCBzdHJva2VzLCAuLi5vdGhlckNvbG9ycyB9ID0gdGhpcy5nZXREZWZhdWx0Q29sb3JzKCk7XG4gICAgdGhpcy5wYWxldHRlID0gbWVyZ2VEZWZhdWx0cyhwYWxldHRlLCB7XG4gICAgICBmaWxsczogT2JqZWN0LnZhbHVlcyhmaWxscyksXG4gICAgICBzdHJva2VzOiBPYmplY3QudmFsdWVzKHN0cm9rZXMpLFxuICAgICAgLi4ub3RoZXJDb2xvcnNcbiAgICB9KTtcbiAgICB0aGlzLnBhbGV0dGVUeXBlID0gcGFsZXR0ZVR5cGUocGFsZXR0ZSk7XG4gICAgdGhpcy5jb25maWcgPSBPYmplY3QuZnJlZXplKHRoaXMudGVtcGxhdGVUaGVtZShkZWZhdWx0cykpO1xuICB9XG4gIG1lcmdlT3ZlcnJpZGVzKGRlZmF1bHRzLCBvdmVycmlkZXMpIHtcbiAgICBmb3IgKGNvbnN0IHsgc2VyaWVzVHlwZXMsIGNvbW1vbk9wdGlvbnMgfSBvZiBPYmplY3QudmFsdWVzKENIQVJUX1RZUEVfQ09ORklHKSkge1xuICAgICAgY29uc3QgY2xlYW5lZENvbW1vbiA9IHsgLi4ub3ZlcnJpZGVzLmNvbW1vbiB9O1xuICAgICAgZm9yIChjb25zdCBjb21tb25LZXkgb2YgQ0hBUlRfVFlQRV9TUEVDSUZJQ19DT01NT05fT1BUSU9OUykge1xuICAgICAgICBpZiAoIWNvbW1vbk9wdGlvbnMuaW5jbHVkZXMoY29tbW9uS2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBjbGVhbmVkQ29tbW9uW2NvbW1vbktleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2xlYW5lZENvbW1vbilcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHMgb2Ygc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZTIgPSBzO1xuICAgICAgICBkZWZhdWx0c1tzZXJpZXNUeXBlMl0gPSBtZXJnZURlZmF1bHRzKGNsZWFuZWRDb21tb24sIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoYXJ0VHlwZXMuc2VyaWVzVHlwZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVHlwZTIgPSBzO1xuICAgICAgaWYgKG92ZXJyaWRlc1tzZXJpZXNUeXBlMl0pIHtcbiAgICAgICAgZGVmYXVsdHNbc2VyaWVzVHlwZTJdID0gbWVyZ2VEZWZhdWx0cyhvdmVycmlkZXNbc2VyaWVzVHlwZTJdLCBkZWZhdWx0c1tzZXJpZXNUeXBlMl0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKGNvbmZpZykge1xuICAgIGZvciAoY29uc3QgW25leHRUeXBlLCB7IHNlcmllc1R5cGVzIH1dIG9mIE9iamVjdC5lbnRyaWVzKENIQVJUX1RZUEVfQ09ORklHKSkge1xuICAgICAgY29uc3QgdHlwZURlZmF1bHRzID0gY2hhcnREZWZhdWx0cy5nZXQobmV4dFR5cGUpO1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlMiBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICBjb25maWdbc2VyaWVzVHlwZTJdIHx8IChjb25maWdbc2VyaWVzVHlwZTJdID0gZGVlcENsb25lKHR5cGVEZWZhdWx0cykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIGdldERlZmF1bHRzKCkge1xuICAgIGNvbnN0IGdldE92ZXJyaWRlc0J5VHlwZSA9IChjaGFydFR5cGUyLCBzZXJpZXNUeXBlcykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBjb25zdCBjaGFydFR5cGVEZWZhdWx0cyA9IHtcbiAgICAgICAgYXhlczoge30sXG4gICAgICAgIC4uLmxlZ2VuZFJlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGVzKCksXG4gICAgICAgIC4uLnRoaXMuZ2V0Q2hhcnREZWZhdWx0cygpLFxuICAgICAgICAuLi5jaGFydERlZmF1bHRzLmdldChjaGFydFR5cGUyKVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzVHlwZTIgb2Ygc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgcmVzdWx0W3Nlcmllc1R5cGUyXSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgICAgc2VyaWVzUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiksXG4gICAgICAgICAgcmVzdWx0W3Nlcmllc1R5cGUyXSA/PyBkZWVwQ2xvbmUoY2hhcnRUeXBlRGVmYXVsdHMpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgYXhlcyB9ID0gcmVzdWx0W3Nlcmllc1R5cGUyXTtcbiAgICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBheGlzUmVnaXN0cnkua2V5cygpKSB7XG4gICAgICAgICAgYXhlc1theGlzVHlwZV0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICAgICAgYXhlc1theGlzVHlwZV0sXG4gICAgICAgICAgICBheGlzUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSksXG4gICAgICAgICAgICBfQ2hhcnRUaGVtZS5jYXJ0ZXNpYW5BeGlzRGVmYXVsdFtheGlzVHlwZV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJjYXJ0ZXNpYW5cIiwgY2hhcnRUeXBlcy5jYXJ0ZXNpYW5UeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJwb2xhclwiLCBjaGFydFR5cGVzLnBvbGFyVHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwiaGllcmFyY2h5XCIsIGNoYXJ0VHlwZXMuaGllcmFyY2h5VHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwidG9wb2xvZ3lcIiwgY2hhcnRUeXBlcy50b3BvbG9neVR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImZsb3ctcHJvcG9ydGlvblwiLCBjaGFydFR5cGVzLmZsb3dQcm9wb3J0aW9uVHlwZXMpXG4gICAgKTtcbiAgfVxuICB0ZW1wbGF0ZVRoZW1lKHRoZW1lVGVtcGxhdGUpIHtcbiAgICBjb25zdCB0aGVtZUluc3RhbmNlID0gZGVlcENsb25lKHRoZW1lVGVtcGxhdGUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAganNvbldhbGsodGhlbWVJbnN0YW5jZSwgKG5vZGUpID0+IHtcbiAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IG5vZGVbaV07XG4gICAgICAgICAgaWYgKHBhcmFtcy5oYXMoc3ltYm9sKSkge1xuICAgICAgICAgICAgbm9kZVtpXSA9IHBhcmFtcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgIGlmIChwYXJhbXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgbm9kZVtuYW1lXSA9IHBhcmFtcy5nZXQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhlbWVJbnN0YW5jZSk7XG4gIH1cbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IERFRkFVTFRfRklMTFMsXG4gICAgICBzdHJva2VzOiBERUZBVUxUX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkdSRUVOLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBERUZBVUxUX0ZJTExTLlJFRCwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5CTFVFLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuT1JBTkdFLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHBhcmFtcy5zZXQoSVNfREFSS19USEVNRSwgZmFsc2UpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GT05UX0ZBTUlMWSwgXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9MQUJFTF9DT0xPVVIsIFwicmdiKDcwLCA3MCwgNzApXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIsIFwid2hpdGVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUiwgXCJyZ2IoMTQwLCAxNDAsIDE0MClcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIFwicmdiKDIyNCwyMzQsMjQxKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUiwgXCJyZ2IoMTk1LCAxOTUsIDE5NSlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUiwgXCJyZ2IoNzAsIDcwLCA3MClcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1NIQURPV19DT0xPVVIsIFwicmdiYSgwLCAwLCAwLCAwLjUpXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgREVGQVVMVF9GSUxMUy5PUkFOR0UsXG4gICAgICBERUZBVUxUX0ZJTExTLllFTExPVyxcbiAgICAgIERFRkFVTFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUEFERElORywgMjApO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJibG9ja1wiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsIFwiY2VudGVyXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsIFtcIiNmZmZmZmZcIiwgXCIjZTBlNWVhXCIsIFwiI2MxY2NkNVwiLCBcIiNhM2I0YzFcIiwgXCIjODU5Y2FkXCJdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMsIFtcIiNmZmZmZmZcIiwgXCIjYzVjYmQxXCIsIFwiI2E0YjFiZFwiLCBcIiM4NDk4YTlcIiwgXCIjNjQ4MDk2XCJdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IsIERFRkFVTFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfRklMTCwgXCIjZmFmYWZhXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX1NUUk9LRSwgXCIjZGRkZGRkXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0NPTE9SLCBcIiMwMDAwMDBcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sIFwidG9wXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HUklETElORV9FTkFCTEVELCBmYWxzZSk7XG4gICAgY29uc3QgZGVmYXVsdENvbG9ycyA9IHRoaXMuZ2V0RGVmYXVsdENvbG9ycygpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9VUF9TVFJPS0UsIHRoaXMucGFsZXR0ZS51cD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMudXAuc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfVVBfRklMTCwgdGhpcy5wYWxldHRlLnVwPy5maWxsID8/IGRlZmF1bHRDb2xvcnMudXAuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0RPV05fU1RST0tFLCB0aGlzLnBhbGV0dGUuZG93bj8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMuZG93bi5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ET1dOX0ZJTEwsIHRoaXMucGFsZXR0ZS5kb3duPy5maWxsID8/IGRlZmF1bHRDb2xvcnMuZG93bi5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsIHRoaXMucGFsZXR0ZS5uZXV0cmFsPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5uZXV0cmFsLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX05FVVRSQUxfRklMTCwgdGhpcy5wYWxldHRlLm5ldXRyYWw/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5uZXV0cmFsLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfVVBfU1RST0tFLCB0aGlzLnBhbGV0dGUuYWx0VXA/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLnVwLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9VUF9GSUxMLCB0aGlzLnBhbGV0dGUuYWx0VXA/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy51cC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX0RPV05fU1RST0tFLCB0aGlzLnBhbGV0dGUuYWx0RG93bj8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMuZG93bi5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfRE9XTl9GSUxMLCB0aGlzLnBhbGV0dGUuYWx0RG93bj8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmRvd24uZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEwsIHRoaXMucGFsZXR0ZS5hbHROZXV0cmFsPy5maWxsID8/IGRlZmF1bHRDb2xvcnMuYWx0TmV1dHJhbC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFLCB0aGlzLnBhbGV0dGUuYWx0TmV1dHJhbD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMuYWx0TmV1dHJhbC5zdHJva2UpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5fQ2hhcnRUaGVtZS5jYXJ0ZXNpYW5BeGlzRGVmYXVsdCA9IHtcbiAgW1wibnVtYmVyXCIgLyogTlVNQkVSICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcImxvZ1wiIC8qIExPRyAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgYmFzZTogMTAsXG4gICAgbGluZTogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBncm91cFBhZGRpbmdJbm5lcjogMC4xLFxuICAgIGxhYmVsOiB7IGF1dG9Sb3RhdGU6IHRydWUgfSxcbiAgICBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfSxcbiAgICBjcm9zc2hhaXI6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1widGltZVwiIC8qIFRJTUUgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoeyBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfSB9KSxcbiAgW1wib3JkaW5hbC10aW1lXCIgLyogT1JESU5BTF9USU1FICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBncm91cFBhZGRpbmdJbm5lcjogMCxcbiAgICBsYWJlbDogeyBhdXRvUm90YXRlOiBmYWxzZSB9LFxuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9XG4gIH0pLFxuICBbXCJhbmdsZS1jYXRlZ29yeVwiIC8qIEFOR0xFX0NBVEVHT1JZICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfVxuICB9KSxcbiAgW1wiYW5nbGUtbnVtYmVyXCIgLyogQU5HTEVfTlVNQkVSICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHsgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH0gfSksXG4gIFtcInJhZGl1cy1jYXRlZ29yeVwiIC8qIFJBRElVU19DQVRFR09SWSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgbGluZTogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJyYWRpdXMtbnVtYmVyXCIgLyogUkFESVVTX05VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgbGluZTogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBcImdyb3VwZWQtY2F0ZWdvcnlcIjogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICB0aWNrOiB7IGVuYWJsZWQ6IHRydWUgfVxuICB9KVxufTtcbnZhciBDaGFydFRoZW1lID0gX0NoYXJ0VGhlbWU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9kYXJrVGhlbWUudHNcbnZhciBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMID0gXCIjMTkyMjMyXCI7XG52YXIgREVGQVVMVF9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgT1JBTkdFOiBcIiNmZmEwM2FcIixcbiAgR1JFRU46IFwiIzQ1OWQ1NVwiLFxuICBDWUFOOiBcIiMzNGJmZTFcIixcbiAgWUVMTE9XOiBcIiNlMWNjMDBcIixcbiAgVklPTEVUOiBcIiM5NjY5Y2JcIixcbiAgR1JBWTogXCIjYjViNWI1XCIsXG4gIE1BR0VOVEE6IFwiI2JkNWFhN1wiLFxuICBCUk9XTjogXCIjOGE2MjI0XCIsXG4gIFJFRDogXCIjZWY1NDUyXCJcbn07XG52YXIgREVGQVVMVF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzc0YThlNlwiLFxuICBPUkFOR0U6IFwiI2ZmYmU3MFwiLFxuICBHUkVFTjogXCIjNmNiMTc2XCIsXG4gIENZQU46IFwiIzc1ZDRlZlwiLFxuICBZRUxMT1c6IFwiI2Y2ZTU1OVwiLFxuICBWSU9MRVQ6IFwiI2FhODZkOFwiLFxuICBHUkFZOiBcIiNhMWExYTFcIixcbiAgTUFHRU5UQTogXCIjY2U3YWI5XCIsXG4gIEJST1dOOiBcIiM5OTdiNTJcIixcbiAgUkVEOiBcIiNmZjc4NzJcIlxufTtcbnZhciBEYXJrVGhlbWUgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogREVGQVVMVF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogREVGQVVMVF9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KElTX0RBUktfVEhFTUUsIHRydWUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTEFCRUxfQ09MT1VSLCBcIndoaXRlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsIFwiIzdEOTFBMFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCIjNTQ1QTZFXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsIFwid2hpdGVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsIFtcIiMxOTI4MzRcIiwgXCIjMjUzNzQ2XCIsIFwiIzMyNDg1OVwiLCBcIiMzZjU5NmNcIiwgXCIjNGQ2YTgwXCJdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMsIFtcIiMxOTI4MzRcIiwgXCIjM2I1MTY0XCIsIFwiIzQ5NjI3NVwiLCBcIiM1NzcyODdcIiwgXCIjNjY4Mzk5XCJdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUiwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIERFRkFVTFRfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLCBcIndoaXRlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgREVGQVVMVF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9GSUxMLCBcIiMyODMxM2VcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfU1RST0tFLCBcIiM0YjUyNWRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfQ09MT1IsIFwiI2ZmZmZmZlwiKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2ZpbmFuY2lhbERhcmsudHNcbnZhciBGSU5BTkNJQUxfREFSS19GSUxMUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjQTlBOUE5XCJcbn07XG52YXIgRklOQU5DSUFMX0RBUktfU1RST0tFUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjOTA5MDkwXCJcbn07XG52YXIgRmluYW5jaWFsRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uRklOQU5DSUFMX0RBUktfRklMTFMgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uRklOQU5DSUFMX0RBUktfU1RST0tFUyB9LFxuICAgICAgdXA6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSRUVOLFxuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSxcbiAgICAgIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcIiMzNDNBNEVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BBRERJTkcsIDApO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJvdmVybGF5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJsZWZ0XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcImJvdHRvbVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2ZpbmFuY2lhbExpZ2h0LnRzXG52YXIgRklOQU5DSUFMX0xJR0hUX0ZJTExTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiNBOUE5QTlcIlxufTtcbnZhciBGSU5BTkNJQUxfTElHSFRfU1RST0tFUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjOTA5MDkwXCJcbn07XG52YXIgRmluYW5jaWFsTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5GSU5BTkNJQUxfTElHSFRfRklMTFMgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMgfSxcbiAgICAgIHVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JFRU4sXG4gICAgICBGSU5BTkNJQUxfTElHSFRfRklMTFMuQkxVRSxcbiAgICAgIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcIiNGMkYzRjNcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BBRERJTkcsIDApO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJvdmVybGF5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJsZWZ0XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcImJvdHRvbVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL21hdGVyaWFsRGFyay50c1xudmFyIE1BVEVSSUFMX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzIxOTZGM1wiLFxuICBPUkFOR0U6IFwiI0ZGOTgwMFwiLFxuICBHUkVFTjogXCIjNENBRjUwXCIsXG4gIENZQU46IFwiIzAwQkNENFwiLFxuICBZRUxMT1c6IFwiI0ZGRUIzQlwiLFxuICBWSU9MRVQ6IFwiIzdFNTdDMlwiLFxuICBHUkFZOiBcIiM5RTlFOUVcIixcbiAgTUFHRU5UQTogXCIjRjA2MjkyXCIsXG4gIEJST1dOOiBcIiM3OTU1NDhcIixcbiAgUkVEOiBcIiNGNDQzMzZcIlxufTtcbnZhciBNQVRFUklBTF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzkwQ0FGOVwiLFxuICBPUkFOR0U6IFwiI0ZGQ0M4MFwiLFxuICBHUkVFTjogXCIjQTVENkE3XCIsXG4gIENZQU46IFwiIzgwREVFQVwiLFxuICBZRUxMT1c6IFwiI0ZGRjlDNFwiLFxuICBWSU9MRVQ6IFwiI0IzOUREQlwiLFxuICBHUkFZOiBcIiNFMEUwRTBcIixcbiAgTUFHRU5UQTogXCIjRjQ4RkIxXCIsXG4gIEJST1dOOiBcIiNBMTg4N0ZcIixcbiAgUkVEOiBcIiNFRjlBOUFcIlxufTtcbnZhciBNYXRlcmlhbERhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBNQVRFUklBTF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogTUFURVJJQUxfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBNQVRFUklBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgTUFURVJJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvbWF0ZXJpYWxMaWdodC50c1xudmFyIE1BVEVSSUFMX0xJR0hUX0ZJTExTID0ge1xuICBCTFVFOiBcIiMyMTk2RjNcIixcbiAgT1JBTkdFOiBcIiNGRjk4MDBcIixcbiAgR1JFRU46IFwiIzRDQUY1MFwiLFxuICBDWUFOOiBcIiMwMEJDRDRcIixcbiAgWUVMTE9XOiBcIiNGRkVCM0JcIixcbiAgVklPTEVUOiBcIiM3RTU3QzJcIixcbiAgR1JBWTogXCIjOUU5RTlFXCIsXG4gIE1BR0VOVEE6IFwiI0YwNjI5MlwiLFxuICBCUk9XTjogXCIjNzk1NTQ4XCIsXG4gIFJFRDogXCIjRjQ0MzM2XCJcbn07XG52YXIgTUFURVJJQUxfTElHSFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMTU2NUMwXCIsXG4gIE9SQU5HRTogXCIjRTY1MTAwXCIsXG4gIEdSRUVOOiBcIiMyRTdEMzJcIixcbiAgQ1lBTjogXCIjMDA4MzhGXCIsXG4gIFlFTExPVzogXCIjRjlBODI1XCIsXG4gIFZJT0xFVDogXCIjNDUyN0EwXCIsXG4gIEdSQVk6IFwiIzYxNjE2MVwiLFxuICBNQUdFTlRBOiBcIiNDMjE4NUJcIixcbiAgQlJPV046IFwiIzRFMzQyRVwiLFxuICBSRUQ6IFwiI0I3MUMxQ1wiXG59O1xudmFyIE1hdGVyaWFsTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogTUFURVJJQUxfTElHSFRfRklMTFMsXG4gICAgICBzdHJva2VzOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIE1BVEVSSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9wb2x5Y2hyb21hRGFyay50c1xudmFyIFBPTFlDSFJPTUFfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNDM2ZmY0XCIsXG4gIFBVUlBMRTogXCIjOWE3YmZmXCIsXG4gIE1BR0VOVEE6IFwiI2QxNjVkMlwiLFxuICBQSU5LOiBcIiNmMDU5OGJcIixcbiAgUkVEOiBcIiNmNDczNDhcIixcbiAgT1JBTkdFOiBcIiNmMmE2MDJcIixcbiAgWUVMTE9XOiBcIiNlOWUyMDFcIixcbiAgR1JFRU46IFwiIzIxYjQ0OFwiLFxuICBDWUFOOiBcIiMwMGI5YTJcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjMDBhZWU0XCIsXG4gIEdSQVk6IFwiI2JiYmJiYlwiXG59O1xudmFyIFBPTFlDSFJPTUFfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM2Njk4ZmZcIixcbiAgUFVSUExFOiBcIiNjMGEzZmZcIixcbiAgTUFHRU5UQTogXCIjZmM4ZGZjXCIsXG4gIFBJTks6IFwiI2ZmODJiMVwiLFxuICBSRUQ6IFwiI2ZmOWI3MFwiLFxuICBPUkFOR0U6IFwiI2ZmY2Y0ZVwiLFxuICBZRUxMT1c6IFwiI2ZmZmY1OFwiLFxuICBHUkVFTjogXCIjNThkZDcwXCIsXG4gIENZQU46IFwiIzUxZTJjOVwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM0ZmQ3ZmZcIixcbiAgR1JBWTogXCIjZWVlZWVlXCJcbn07XG52YXIgUG9seWNocm9tYURhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBQT0xZQ0hST01BX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1BPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVEXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFBPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFBPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvcG9seWNocm9tYUxpZ2h0LnRzXG52YXIgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjNDM2ZmY0XCIsXG4gIFBVUlBMRTogXCIjOWE3YmZmXCIsXG4gIE1BR0VOVEE6IFwiI2QxNjVkMlwiLFxuICBQSU5LOiBcIiNmMDU5OGJcIixcbiAgUkVEOiBcIiNmNDczNDhcIixcbiAgT1JBTkdFOiBcIiNmMmE2MDJcIixcbiAgWUVMTE9XOiBcIiNlOWUyMDFcIixcbiAgR1JFRU46IFwiIzIxYjQ0OFwiLFxuICBDWUFOOiBcIiMwMGI5YTJcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjMDBhZWU0XCIsXG4gIEdSQVk6IFwiI2JiYmJiYlwiXG59O1xudmFyIFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMjM0NmM5XCIsXG4gIFBVUlBMRTogXCIjNzY1M2Q0XCIsXG4gIE1BR0VOVEE6IFwiI2E3M2RhOVwiLFxuICBQSU5LOiBcIiNjMzJkNjZcIixcbiAgUkVEOiBcIiNjODRiMWNcIixcbiAgT1JBTkdFOiBcIiNjODdmMDBcIixcbiAgWUVMTE9XOiBcIiNjMWI5MDBcIixcbiAgR1JFRU46IFwiIzAwOGMxY1wiLFxuICBDWUFOOiBcIiMwMDkyN2NcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjMDA4N2JiXCIsXG4gIEdSQVk6IFwiIzg4ODg4OFwiXG59O1xudmFyIFBvbHljaHJvbWFMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLFxuICAgICAgc3Ryb2tlczogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvc2hlZXRzRGFyay50c1xudmFyIFNIRUVUU19EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiM0NDcyQzRcIixcbiAgT1JBTkdFOiBcIiNFRDdEMzFcIixcbiAgR1JBWTogXCIjQTVBNUE1XCIsXG4gIFlFTExPVzogXCIjRkZDMDAwXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzVCOUJENVwiLFxuICBHUkVFTjogXCIjNzBBRDQ3XCIsXG4gIERBUktfR1JBWTogXCIjN0I3QjdCXCIsXG4gIERBUktfQkxVRTogXCIjMjY0NDc4XCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM2MzYzNjNcIixcbiAgREFSS19ZRUxMT1c6IFwiIzk5NzMwMFwiXG59O1xudmFyIFNIRUVUU19EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzY4OTllZVwiLFxuICBPUkFOR0U6IFwiI2ZmYTU1ZFwiLFxuICBHUkFZOiBcIiNjZGNkY2RcIixcbiAgWUVMTE9XOiBcIiNmZmVhNTNcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjODJjM2ZmXCIsXG4gIEdSRUVOOiBcIiM5NmQ1NmZcIixcbiAgREFSS19HUkFZOiBcIiNhMWExYTFcIixcbiAgREFSS19CTFVFOiBcIiM0NzY4OWZcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzg3ODc4N1wiLFxuICBEQVJLX1lFTExPVzogXCIjYzA5OTNkXCJcbn07XG52YXIgU2hlZXRzRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uU0hFRVRTX0RBUktfRklMTFMsIFJFRDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLlNIRUVUU19EQVJLX1NUUk9LRVMsIFJFRDogU0hFRVRTX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIHVwOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgU0hFRVRTX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBTSEVFVFNfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvc2hlZXRzTGlnaHQudHNcbnZhciBTSEVFVFNfTElHSFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzUyODFkNVwiLFxuICBPUkFOR0U6IFwiI2ZmOGQ0NFwiLFxuICBHUkFZOiBcIiNiNWI1YjVcIixcbiAgWUVMTE9XOiBcIiNmZmQwMmZcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjNmFhYmU2XCIsXG4gIEdSRUVOOiBcIiM3ZmJkNTdcIixcbiAgREFSS19HUkFZOiBcIiM4YThhOGFcIixcbiAgREFSS19CTFVFOiBcIiMzMzUyODdcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzcxNzE3MVwiLFxuICBEQVJLX1lFTExPVzogXCIjYTk4MjIwXCJcbn07XG52YXIgU0hFRVRTX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzIxNGQ5YlwiLFxuICBPUkFOR0U6IFwiI2MyNTYwMFwiLFxuICBHUkFZOiBcIiM3ZjdmN2ZcIixcbiAgWUVMTE9XOiBcIiNkNTk4MDBcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjMzU3NWFjXCIsXG4gIEdSRUVOOiBcIiM0Yjg2MWFcIixcbiAgREFSS19HUkFZOiBcIiM1NzU3NTdcIixcbiAgREFSS19CTFVFOiBcIiMwNjIyNTNcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzQxNDE0MVwiLFxuICBEQVJLX1lFTExPVzogXCIjNzM0ZjAwXCJcbn07XG52YXIgU2hlZXRzTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5TSEVFVFNfTElHSFRfRklMTFMsIFJFRDogU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5TSEVFVFNfTElHSFRfU1RST0tFUywgUkVEOiBTSEVFVFNfTElHSFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIHVwOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkFZLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLFxuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3ZpdmlkRGFyay50c1xudmFyIFZJVklEX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzAwODNmZlwiLFxuICBPUkFOR0U6IFwiI2ZmNjYwMFwiLFxuICBHUkVFTjogXCIjMDBhZjAwXCIsXG4gIENZQU46IFwiIzAwY2NmZlwiLFxuICBZRUxMT1c6IFwiI2Y3YzcwMFwiLFxuICBWSU9MRVQ6IFwiI2FjMjZmZlwiLFxuICBHUkFZOiBcIiNhN2E3YjdcIixcbiAgTUFHRU5UQTogXCIjZTgwMGM1XCIsXG4gIEJST1dOOiBcIiNiNTQzMDBcIixcbiAgUkVEOiBcIiNmZjAwMDBcIlxufTtcbnZhciBWSVZJRF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzY3YjdmZlwiLFxuICBPUkFOR0U6IFwiI2ZmYzI0ZFwiLFxuICBHUkVFTjogXCIjNWNjODZmXCIsXG4gIENZQU46IFwiIzU0ZWJmZlwiLFxuICBWSU9MRVQ6IFwiI2ZmZjY1M1wiLFxuICBZRUxMT1c6IFwiI2MxOGFmZlwiLFxuICBHUkFZOiBcIiNhZWFlYWVcIixcbiAgTUFHRU5UQTogXCIjZjA3OGQ0XCIsXG4gIEJST1dOOiBcIiNiYTg0MzhcIixcbiAgUkVEOiBcIiNmZjcyNmVcIlxufTtcbnZhciBWaXZpZERhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBWSVZJRF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogVklWSURfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIFZJVklEX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgVklWSURfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBWSVZJRF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgVklWSURfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdml2aWRMaWdodC50c1xudmFyIFZJVklEX0ZJTExTID0ge1xuICBCTFVFOiBcIiMwMDgzZmZcIixcbiAgT1JBTkdFOiBcIiNmZjY2MDBcIixcbiAgR1JFRU46IFwiIzAwYWYwMFwiLFxuICBDWUFOOiBcIiMwMGNjZmZcIixcbiAgWUVMTE9XOiBcIiNmN2M3MDBcIixcbiAgVklPTEVUOiBcIiNhYzI2ZmZcIixcbiAgR1JBWTogXCIjYTdhN2I3XCIsXG4gIE1BR0VOVEE6IFwiI2U4MDBjNVwiLFxuICBCUk9XTjogXCIjYjU0MzAwXCIsXG4gIFJFRDogXCIjZmYwMDAwXCJcbn07XG52YXIgVklWSURfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMGY2OGMwXCIsXG4gIE9SQU5HRTogXCIjZDQ3MTAwXCIsXG4gIEdSRUVOOiBcIiMwMDc5MjJcIixcbiAgQ1lBTjogXCIjMDA5YWMyXCIsXG4gIFZJT0xFVDogXCIjYmNhNDAwXCIsXG4gIFlFTExPVzogXCIjNzUzY2FjXCIsXG4gIEdSQVk6IFwiIzY0NjQ2NFwiLFxuICBNQUdFTlRBOiBcIiM5YjI2ODVcIixcbiAgQlJPV046IFwiIzZjM2IwMFwiLFxuICBSRUQ6IFwiI2NiMDAyMVwiXG59O1xudmFyIFZpdmlkTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogVklWSURfRklMTFMsXG4gICAgICBzdHJva2VzOiBWSVZJRF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogVklWSURfRklMTFMuR1JFRU4sIHN0cm9rZTogVklWSURfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBWSVZJRF9GSUxMUy5SRUQsIHN0cm9rZTogVklWSURfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogVklWSURfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFZJVklEX0ZJTExTLkJMVUUsIHN0cm9rZTogVklWSURfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFZJVklEX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbVklWSURfRklMTFMuT1JBTkdFLCBWSVZJRF9GSUxMUy5ZRUxMT1csIFZJVklEX0ZJTExTLkdSRUVOXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFZJVklEX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgVklWSURfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy90aGVtZXMudHNcbnZhciBsaWdodFRoZW1lID0gKCkgPT4gbmV3IENoYXJ0VGhlbWUoKTtcbnZhciBkYXJrVGhlbWUgPSAoKSA9PiBuZXcgRGFya1RoZW1lKCk7XG52YXIgdGhlbWVzID0ge1xuICAvLyBkYXJrVGhlbWVzLFxuICBcImFnLWRlZmF1bHQtZGFya1wiOiBkYXJrVGhlbWUsXG4gIFwiYWctc2hlZXRzLWRhcmtcIjogKCkgPT4gbmV3IFNoZWV0c0RhcmsoKSxcbiAgXCJhZy1wb2x5Y2hyb21hLWRhcmtcIjogKCkgPT4gbmV3IFBvbHljaHJvbWFEYXJrKCksXG4gIFwiYWctdml2aWQtZGFya1wiOiAoKSA9PiBuZXcgVml2aWREYXJrKCksXG4gIFwiYWctbWF0ZXJpYWwtZGFya1wiOiAoKSA9PiBuZXcgTWF0ZXJpYWxEYXJrKCksXG4gIFwiYWctZmluYW5jaWFsLWRhcmtcIjogKCkgPT4gbmV3IEZpbmFuY2lhbERhcmsoKSxcbiAgLy8gbGlnaHRUaGVtZXMsXG4gIG51bGw6IGxpZ2h0VGhlbWUsXG4gIHVuZGVmaW5lZDogbGlnaHRUaGVtZSxcbiAgXCJhZy1kZWZhdWx0XCI6IGxpZ2h0VGhlbWUsXG4gIFwiYWctc2hlZXRzXCI6ICgpID0+IG5ldyBTaGVldHNMaWdodCgpLFxuICBcImFnLXBvbHljaHJvbWFcIjogKCkgPT4gbmV3IFBvbHljaHJvbWFMaWdodCgpLFxuICBcImFnLXZpdmlkXCI6ICgpID0+IG5ldyBWaXZpZExpZ2h0KCksXG4gIFwiYWctbWF0ZXJpYWxcIjogKCkgPT4gbmV3IE1hdGVyaWFsTGlnaHQoKSxcbiAgXCJhZy1maW5hbmNpYWxcIjogKCkgPT4gbmV3IEZpbmFuY2lhbExpZ2h0KClcbn07XG5mdW5jdGlvbiBnZXRDaGFydFRoZW1lKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENoYXJ0VGhlbWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3Qgc3RvY2tUaGVtZSA9IHRoZW1lc1t2YWx1ZV07XG4gICAgaWYgKHN0b2NrVGhlbWUpIHtcbiAgICAgIHJldHVybiBzdG9ja1RoZW1lKCk7XG4gICAgfVxuICAgIExvZ2dlci53YXJuT25jZShgdGhlIHRoZW1lIFske3ZhbHVlfV0gaXMgaW52YWxpZCwgdXNpbmcgW2FnLWRlZmF1bHRdIGluc3RlYWQuYCk7XG4gICAgcmV0dXJuIGxpZ2h0VGhlbWUoKTtcbiAgfVxuICBpZiAoaXNWYWxpZCh2YWx1ZSwgdGhlbWVPcHRpb25zRGVmLCBcInRoZW1lXCIpKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkVGhlbWUgPSByZWR1Y2VUaGVtZU9wdGlvbnModmFsdWUpO1xuICAgIGNvbnN0IGJhc2VUaGVtZSA9IGZsYXR0ZW5lZFRoZW1lLmJhc2VUaGVtZSA/IGdldENoYXJ0VGhlbWUoZmxhdHRlbmVkVGhlbWUuYmFzZVRoZW1lKSA6IGxpZ2h0VGhlbWUoKTtcbiAgICByZXR1cm4gbmV3IGJhc2VUaGVtZS5jb25zdHJ1Y3RvcihmbGF0dGVuZWRUaGVtZSk7XG4gIH1cbiAgcmV0dXJuIGxpZ2h0VGhlbWUoKTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVRoZW1lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGxldCBtYXliZU5lc3RlZCA9IG9wdGlvbnM7XG4gIGxldCBwYWxldHRlO1xuICBjb25zdCBvdmVycmlkZXMgPSBbXTtcbiAgd2hpbGUgKHR5cGVvZiBtYXliZU5lc3RlZCA9PT0gXCJvYmplY3RcIikge1xuICAgIHBhbGV0dGUgPz8gKHBhbGV0dGUgPSBtYXliZU5lc3RlZC5wYWxldHRlKTtcbiAgICBpZiAobWF5YmVOZXN0ZWQub3ZlcnJpZGVzKSB7XG4gICAgICBvdmVycmlkZXMucHVzaChtYXliZU5lc3RlZC5vdmVycmlkZXMpO1xuICAgIH1cbiAgICBtYXliZU5lc3RlZCA9IG1heWJlTmVzdGVkLmJhc2VUaGVtZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhc2VUaGVtZTogbWF5YmVOZXN0ZWQsXG4gICAgb3ZlcnJpZGVzOiBtZXJnZURlZmF1bHRzKC4uLm92ZXJyaWRlcyksXG4gICAgcGFsZXR0ZVxuICB9O1xufVxudmFyIHRoZW1lT3B0aW9uc0RlZiA9IHtcbiAgYmFzZVRoZW1lOiBvcihzdHJpbmcsIG9iamVjdCksXG4gIG92ZXJyaWRlczogb2JqZWN0LFxuICBwYWxldHRlOiB7XG4gICAgZmlsbHM6IGFycmF5T2Yoc3RyaW5nKSxcbiAgICBzdHJva2VzOiBhcnJheU9mKHN0cmluZyksXG4gICAgdXA6IHsgZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZyB9LFxuICAgIGRvd246IHsgZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZyB9LFxuICAgIG5ldXRyYWw6IHsgZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZyB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9vcHRpb25zTW9kdWxlLnRzXG52YXIgdW50aGVtZWRTZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJtYXAtc2hhcGUtYmFja2dyb3VuZFwiLCBcIm1hcC1saW5lLWJhY2tncm91bmRcIl0pO1xudmFyIENoYXJ0T3B0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodXNlck9wdGlvbnMsIHNwZWNpYWxPdmVycmlkZXMpIHtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwib3B0c1wiKTtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2xvbmVPcHRpb25zID0geyBzaGFsbG93OiBbXCJkYXRhXCJdIH07XG4gICAgdXNlck9wdGlvbnMgPSBkZWVwQ2xvbmUodXNlck9wdGlvbnMsIGNsb25lT3B0aW9ucyk7XG4gICAgY29uc3QgY2hhcnRUeXBlMiA9IHRoaXMub3B0aW9uc1R5cGUodXNlck9wdGlvbnMpO1xuICAgIGlmICghZW50ZXJwcmlzZU1vZHVsZS5pc0VudGVycHJpc2UpIHtcbiAgICAgIHJlbW92ZVVzZWRFbnRlcnByaXNlT3B0aW9ucyh1c2VyT3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBvcHRpb25zID0gZGVlcENsb25lKHVzZXJPcHRpb25zLCBjbG9uZU9wdGlvbnMpO1xuICAgIHRoaXMudHlwZSA9IHNwZWNpYWxPdmVycmlkZXM/LnR5cGU7XG4gICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVzZXRPcHRpb25zID0gUFJFU0VUU1t0aGlzLnR5cGVdPy4ob3B0aW9ucywgKCkgPT4gdGhpcy5hY3RpdmVUaGVtZSkgPz8gb3B0aW9ucztcbiAgICAgIHRoaXMuZGVidWcoXCI+Pj4gQWdDaGFydHMuY3JlYXRlT3JVcGRhdGUoKSAtIGFwcGx5aW5nIHByZXNldFwiLCBvcHRpb25zLCBwcmVzZXRPcHRpb25zKTtcbiAgICAgIG9wdGlvbnMgPSBwcmVzZXRPcHRpb25zO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVRoZW1lID0gZ2V0Q2hhcnRUaGVtZShvcHRpb25zLnRoZW1lKTtcbiAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5hY3RpdmVUaGVtZS50ZW1wbGF0ZVRoZW1lKG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnNhbml0eUNoZWNrQW5kQ2xlYW51cChvcHRpb25zKTtcbiAgICB0aGlzLmRlZmF1bHRBeGVzID0gdGhpcy5nZXREZWZhdWx0QXhlcyhvcHRpb25zKTtcbiAgICB0aGlzLnNwZWNpYWxPdmVycmlkZXMgPSB0aGlzLnNwZWNpYWxPdmVycmlkZXNEZWZhdWx0cyh7IC4uLnNwZWNpYWxPdmVycmlkZXMgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYXhlczogYXhlc1RoZW1lcyA9IHt9LFxuICAgICAgYW5ub3RhdGlvbnM6IHsgYXhlc0J1dHRvbnMgPSBudWxsLCAuLi5hbm5vdGF0aW9uc1RoZW1lcyB9ID0ge30sXG4gICAgICBzZXJpZXM6IF8sXG4gICAgICAuLi50aGVtZURlZmF1bHRzXG4gICAgfSA9IHRoaXMuZ2V0U2VyaWVzVGhlbWVDb25maWcoY2hhcnRUeXBlMik7XG4gICAgdGhpcy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuICAgIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyA9IGRlZXBDbG9uZShcbiAgICAgIG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGF4ZXNCdXR0b25zICE9IG51bGwgPyB7IGFubm90YXRpb25zOiB7IGF4ZXNCdXR0b25zIH0gfSA6IHt9LFxuICAgICAgICB0aGVtZURlZmF1bHRzLFxuICAgICAgICB0aGlzLmRlZmF1bHRBeGVzXG4gICAgICApLFxuICAgICAgY2xvbmVPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLnByb2Nlc3NBeGVzT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMsIGF4ZXNUaGVtZXMpO1xuICAgIHRoaXMucHJvY2Vzc1Nlcmllc09wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgICB0aGlzLnByb2Nlc3NNaW5pQ2hhcnRTZXJpZXNPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgdGhpcy5hbm5vdGF0aW9uVGhlbWVzID0gYW5ub3RhdGlvbnNUaGVtZXM7XG4gICAgaWYgKChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucykgfHwgaXNBZ1BvbGFyQ2hhcnRPcHRpb25zV2l0aFNlcmllc0Jhc2VkTGVnZW5kKHRoaXMucHJvY2Vzc2VkT3B0aW9ucykpICYmIHRoaXMucHJvY2Vzc2VkT3B0aW9ucy5sZWdlbmQ/LmVuYWJsZWQgPT0gbnVsbCkge1xuICAgICAgKF9hID0gdGhpcy5wcm9jZXNzZWRPcHRpb25zKS5sZWdlbmQgPz8gKF9hLmxlZ2VuZCA9IHt9KTtcbiAgICAgIHRoaXMucHJvY2Vzc2VkT3B0aW9ucy5sZWdlbmQuZW5hYmxlZCA9IHRoaXMucHJvY2Vzc2VkT3B0aW9ucy5zZXJpZXMubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVDb25maWd1cmVkT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIGlmICghZW50ZXJwcmlzZU1vZHVsZS5pc0VudGVycHJpc2UpIHtcbiAgICAgIHJlbW92ZVVzZWRFbnRlcnByaXNlT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMsIHRydWUpO1xuICAgIH1cbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NlZE9wdGlvbnMgPz8ge307XG4gIH1cbiAgZGlmZk9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBqc29uRGlmZihvcHRpb25zLCB0aGlzLnByb2Nlc3NlZE9wdGlvbnMpO1xuICB9XG4gIGdldFNlcmllc1RoZW1lQ29uZmlnKHNlcmllc1R5cGUyKSB7XG4gICAgY29uc3QgdGhlbWVDb25maWcgPSBkZWVwQ2xvbmUodGhpcy5hY3RpdmVUaGVtZT8uY29uZmlnW3Nlcmllc1R5cGUyXSA/PyB7fSk7XG4gICAgdGhpcy5yZW1vdmVMZWZ0b3ZlclN5bWJvbHModGhlbWVDb25maWcpO1xuICAgIHJldHVybiB0aGVtZUNvbmZpZztcbiAgfVxuICBnZXREZWZhdWx0QXhlcyhvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc1R5cGUyID0gdGhpcy5vcHRpb25zVHlwZShvcHRpb25zKTtcbiAgICBjb25zdCBheGVzRGVmYXVsdHMgPSBzZXJpZXNSZWdpc3RyeS5jbG9uZURlZmF1bHRBeGVzKG9wdGlvbnNUeXBlMik7XG4gICAgaWYgKHNlcmllc1JlZ2lzdHJ5LmlzRGVmYXVsdEF4aXNTd2FwTmVlZGVkKG9wdGlvbnMpKSB7XG4gICAgICB0aGlzLnN3YXBBeGVzUG9zaXRpb24oYXhlc0RlZmF1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4ZXNEZWZhdWx0cztcbiAgfVxuICBvcHRpb25zVHlwZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuc2VyaWVzPy5bMF0/LnR5cGUgPz8gXCJsaW5lXCI7XG4gIH1cbiAgc2FuaXR5Q2hlY2tBbmRDbGVhbnVwKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ3Mob3B0aW9ucyk7XG4gICAgdGhpcy5heGVzVHlwZUludGVncml0eShvcHRpb25zKTtcbiAgICB0aGlzLnNlcmllc1R5cGVJbnRlZ3JpdHkob3B0aW9ucyk7XG4gICAgdGhpcy5zb2xvU2VyaWVzSW50ZWdyaXR5KG9wdGlvbnMpO1xuICAgIHRoaXMucmVtb3ZlRGlzYWJsZWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMucmVtb3ZlTGVmdG92ZXJTeW1ib2xzKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnNlcmllcz8uc29tZSgocykgPT4gcy50eXBlID09PSBcImJ1bGxldFwiKSAmJiBvcHRpb25zLnN5bmMgIT0gbnVsbCAmJiBvcHRpb25zLnN5bmMuZW5hYmxlZCAhPT0gZmFsc2UpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcImJ1bGxldCBzZXJpZXMgY2Fubm90IGJlIHN5bmNlZCwgZGlzYWJsaW5nIHN5bmNocm9uaXphdGlvbi5cIik7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zeW5jO1xuICAgIH1cbiAgfVxuICBzd2FwQXhlc1Bvc2l0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgY29uc3QgW2F4aXMwLCBheGlzMV0gPSBvcHRpb25zLmF4ZXMgPz8gW107XG4gICAgICBvcHRpb25zLmF4ZXMgPSBbXG4gICAgICAgIHsgLi4uYXhpczAsIHBvc2l0aW9uOiBheGlzMS5wb3NpdGlvbiB9LFxuICAgICAgICB7IC4uLmF4aXMxLCBwb3NpdGlvbjogYXhpczAucG9zaXRpb24gfVxuICAgICAgXTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc0F4ZXNPcHRpb25zKG9wdGlvbnMsIGF4ZXNUaGVtZXMpIHtcbiAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSlcbiAgICAgIHJldHVybjtcbiAgICBvcHRpb25zLmF4ZXMgPSBvcHRpb25zLmF4ZXMubWFwKChheGlzKSA9PiB7XG4gICAgICBjb25zdCB7IGNyb3NzTGluZXM6IGNyb3NzTGluZXNUaGVtZSwgLi4uYXhpc1RoZW1lIH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICBheGVzVGhlbWVzW2F4aXMudHlwZV0/LltheGlzLnBvc2l0aW9uXSxcbiAgICAgICAgYXhlc1RoZW1lc1theGlzLnR5cGVdXG4gICAgICApO1xuICAgICAgaWYgKGF4aXMuY3Jvc3NMaW5lcykge1xuICAgICAgICBheGlzLmNyb3NzTGluZXMgPSBtZXJnZUFycmF5RGVmYXVsdHMoYXhpcy5jcm9zc0xpbmVzLCBjcm9zc0xpbmVzVGhlbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JpZExpbmVTdHlsZSA9IGF4aXNUaGVtZS5ncmlkTGluZT8uc3R5bGU7XG4gICAgICBpZiAoYXhpcy5ncmlkTGluZT8uc3R5bGUgJiYgZ3JpZExpbmVTdHlsZT8ubGVuZ3RoKSB7XG4gICAgICAgIGF4aXMuZ3JpZExpbmUuc3R5bGUgPSBheGlzLmdyaWRMaW5lLnN0eWxlLm1hcChcbiAgICAgICAgICAoc3R5bGUsIGluZGV4KSA9PiBzdHlsZS5zdHJva2UgIT0gbnVsbCB8fCBzdHlsZS5saW5lRGFzaCAhPSBudWxsID8gbWVyZ2VEZWZhdWx0cyhzdHlsZSwgZ3JpZExpbmVTdHlsZS5hdChpbmRleCAlIGdyaWRMaW5lU3R5bGUubGVuZ3RoKSkgOiBzdHlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3A6IF8xLCByaWdodDogXzIsIGJvdHRvbTogXzMsIGxlZnQ6IF80LCAuLi5heGlzT3B0aW9ucyB9ID0gbWVyZ2VEZWZhdWx0cyhheGlzLCBheGlzVGhlbWUpO1xuICAgICAgcmV0dXJuIGF4aXNPcHRpb25zO1xuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NTZXJpZXNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0U2VyaWVzVHlwZSA9IHRoaXMuZ2V0RGVmYXVsdFNlcmllc1R5cGUob3B0aW9ucyk7XG4gICAgY29uc3QgZGVmYXVsdFRvb2x0aXBQb3NpdGlvbiA9IHRoaXMuZ2V0VG9vbHRpcFBvc2l0aW9uRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgY29uc3QgdXNlclBhbGV0dGUgPSBpc09iamVjdChvcHRpb25zLnRoZW1lKSA/IHBhbGV0dGVUeXBlKG9wdGlvbnMudGhlbWU/LnBhbGV0dGUpIDogXCJpbmJ1aWx0XCI7XG4gICAgY29uc3QgcGFsZXR0ZU9wdGlvbnMgPSB7XG4gICAgICBjb2xvdXJJbmRleDogMCxcbiAgICAgIHVzZXJQYWxldHRlXG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzZWRTZXJpZXMgPSBvcHRpb25zLnNlcmllcz8ubWFwKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy50eXBlID8/IChzZXJpZXMudHlwZSA9IGRlZmF1bHRTZXJpZXNUeXBlKTtcbiAgICAgIGNvbnN0IHsgaW5uZXJMYWJlbHM6IGlubmVyTGFiZWxzVGhlbWUsIC4uLnNlcmllc1RoZW1lIH0gPSB0aGlzLmdldFNlcmllc1RoZW1lQ29uZmlnKHNlcmllcy50eXBlKS5zZXJpZXMgPz8ge307XG4gICAgICBjb25zdCBzZXJpZXNQYWxldHRlT3B0aW9ucyA9IHVudGhlbWVkU2VyaWVzLmhhcyhzZXJpZXMudHlwZSkgPyB7IGNvbG91ckluZGV4OiAwLCB1c2VyUGFsZXR0ZSB9IDogcGFsZXR0ZU9wdGlvbnM7XG4gICAgICBjb25zdCBwYWxldHRlID0gdGhpcy5nZXRTZXJpZXNQYWxldHRlKHNlcmllcy50eXBlLCBzZXJpZXNQYWxldHRlT3B0aW9ucyk7XG4gICAgICBjb25zdCBkZWZhdWx0VG9vbHRpcFJhbmdlID0gdGhpcy5nZXRUb29sdGlwUmFuZ2VEZWZhdWx0cyhvcHRpb25zLCBzZXJpZXMudHlwZSk7XG4gICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoc2VyaWVzKSxcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBkZWZhdWx0VG9vbHRpcFBvc2l0aW9uLFxuICAgICAgICBkZWZhdWx0VG9vbHRpcFJhbmdlLFxuICAgICAgICBzZXJpZXNUaGVtZSxcbiAgICAgICAgcGFsZXR0ZSxcbiAgICAgICAgeyB2aXNpYmxlOiB0cnVlIH1cbiAgICAgICk7XG4gICAgICBpZiAoc2VyaWVzT3B0aW9ucy5pbm5lckxhYmVscykge1xuICAgICAgICBzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzID0gbWVyZ2VBcnJheURlZmF1bHRzKHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMsIGlubmVyTGFiZWxzVGhlbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGhlbWUudGVtcGxhdGVUaGVtZShzZXJpZXNPcHRpb25zKTtcbiAgICB9KTtcbiAgICBvcHRpb25zLnNlcmllcyA9IHRoaXMuc2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHByb2Nlc3NlZFNlcmllcyA/PyBbXSk7XG4gIH1cbiAgcHJvY2Vzc01pbmlDaGFydFNlcmllc09wdGlvbnMob3B0aW9ucykge1xuICAgIGxldCBtaW5pQ2hhcnRTZXJpZXMgPSBvcHRpb25zLm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXM7XG4gICAgaWYgKG1pbmlDaGFydFNlcmllcyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBhbGV0dGVPcHRpb25zID0ge1xuICAgICAgY29sb3VySW5kZXg6IDAsXG4gICAgICB1c2VyUGFsZXR0ZTogaXNPYmplY3Qob3B0aW9ucy50aGVtZSkgPyBwYWxldHRlVHlwZShvcHRpb25zLnRoZW1lLnBhbGV0dGUpIDogXCJpbmJ1aWx0XCJcbiAgICB9O1xuICAgIG1pbmlDaGFydFNlcmllcyA9IG1pbmlDaGFydFNlcmllcy5tYXAoKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnR5cGUgPz8gKHNlcmllcy50eXBlID0gXCJsaW5lXCIpO1xuICAgICAgY29uc3QgeyBpbm5lckxhYmVsczogXywgLi4uc2VyaWVzVGhlbWUgfSA9IHRoaXMuZ2V0U2VyaWVzVGhlbWVDb25maWcoc2VyaWVzLnR5cGUpLnNlcmllcyA/PyB7fTtcbiAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICB0aGlzLmdldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhzZXJpZXMpLFxuICAgICAgICBzZXJpZXMsXG4gICAgICAgIHNlcmllc1RoZW1lLFxuICAgICAgICB0aGlzLmdldFNlcmllc1BhbGV0dGUoc2VyaWVzLnR5cGUsIHBhbGV0dGVPcHRpb25zKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRoZW1lLnRlbXBsYXRlVGhlbWUoc2VyaWVzT3B0aW9ucyk7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5uYXZpZ2F0b3IubWluaUNoYXJ0LnNlcmllcyA9IHRoaXMuc2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKG1pbmlDaGFydFNlcmllcyk7XG4gIH1cbiAgZ2V0U2VyaWVzUGFsZXR0ZShzZXJpZXNUeXBlMiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhbGV0dGVGYWN0b3J5ID0gc2VyaWVzUmVnaXN0cnkuZ2V0UGFsZXR0ZUZhY3Rvcnkoc2VyaWVzVHlwZTIpO1xuICAgIGNvbnN0IHsgY29sb3VySW5kZXg6IGNvbG91ck9mZnNldCwgdXNlclBhbGV0dGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyBmaWxscyA9IFtdLCBzdHJva2VzID0gW10gfSA9IHRoaXMuYWN0aXZlVGhlbWUucGFsZXR0ZTtcbiAgICByZXR1cm4gcGFsZXR0ZUZhY3Rvcnk/Lih7XG4gICAgICB1c2VyUGFsZXR0ZSxcbiAgICAgIGNvbG9yc0NvdW50OiBNYXRoLm1heChmaWxscy5sZW5ndGgsIHN0cm9rZXMubGVuZ3RoKSxcbiAgICAgIHRoZW1lVGVtcGxhdGVQYXJhbWV0ZXJzOiB0aGlzLmFjdGl2ZVRoZW1lLmdldFRlbXBsYXRlUGFyYW1ldGVycygpLFxuICAgICAgcGFsZXR0ZTogdGhpcy5hY3RpdmVUaGVtZS5wYWxldHRlLFxuICAgICAgdGFrZUNvbG9ycyhjb3VudCkge1xuICAgICAgICBvcHRpb25zLmNvbG91ckluZGV4ICs9IGNvdW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZpbGxzOiBjaXJjdWxhclNsaWNlQXJyYXkoZmlsbHMsIGNvdW50LCBjb2xvdXJPZmZzZXQpLFxuICAgICAgICAgIHN0cm9rZXM6IGNpcmN1bGFyU2xpY2VBcnJheShzdHJva2VzLCBjb3VudCwgY29sb3VyT2Zmc2V0KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhzZXJpZXMpIHtcbiAgICBjb25zdCBncm91cGFibGUgPSBzZXJpZXNSZWdpc3RyeS5pc0dyb3VwYWJsZShzZXJpZXMudHlwZSk7XG4gICAgY29uc3Qgc3RhY2thYmxlID0gc2VyaWVzUmVnaXN0cnkuaXNTdGFja2FibGUoc2VyaWVzLnR5cGUpO1xuICAgIGNvbnN0IHN0YWNrZWRCeURlZmF1bHQgPSBzZXJpZXNSZWdpc3RyeS5pc1N0YWNrZWRCeURlZmF1bHQoc2VyaWVzLnR5cGUpO1xuICAgIGlmIChzZXJpZXMuZ3JvdXBlZCAmJiAhZ3JvdXBhYmxlKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYHVuc3VwcG9ydGVkIGdyb3VwaW5nIG9mIHNlcmllcyB0eXBlIFwiJHtzZXJpZXMudHlwZX1cIi5gKTtcbiAgICB9XG4gICAgaWYgKChzZXJpZXMuc3RhY2tlZCB8fCBzZXJpZXMuc3RhY2tHcm91cCkgJiYgIXN0YWNrYWJsZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGB1bnN1cHBvcnRlZCBzdGFja2luZyBvZiBzZXJpZXMgdHlwZSBcIiR7c2VyaWVzLnR5cGV9XCIuYCk7XG4gICAgfVxuICAgIGxldCB7IGdyb3VwZWQsIHN0YWNrZWQgfSA9IHNlcmllcztcbiAgICBzdGFja2VkID8/IChzdGFja2VkID0gKHN0YWNrZWRCeURlZmF1bHQgfHwgc2VyaWVzLnN0YWNrR3JvdXAgIT0gbnVsbCkgJiYgIShncm91cGFibGUgJiYgZ3JvdXBlZCkpO1xuICAgIGdyb3VwZWQgPz8gKGdyb3VwZWQgPSB0cnVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhY2tlZDogc3RhY2thYmxlICYmIHN0YWNrZWQsXG4gICAgICBncm91cGVkOiBncm91cGFibGUgJiYgZ3JvdXBlZCAmJiAhKHN0YWNrYWJsZSAmJiBzdGFja2VkKVxuICAgIH07XG4gIH1cbiAgc2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKGFsbFNlcmllcykge1xuICAgIGNvbnN0IHNlcmllc0dyb3VwcyA9IHRoaXMuZ2V0U2VyaWVzR3JvdXBpbmcoYWxsU2VyaWVzKTtcbiAgICB0aGlzLmRlYnVnKFwic2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKCkgLSBzZXJpZXMgZ3JvdXBpbmc6IFwiLCBzZXJpZXNHcm91cHMpO1xuICAgIGNvbnN0IGdyb3VwSWR4ID0ge307XG4gICAgY29uc3QgZ3JvdXBDb3VudDIgPSBzZXJpZXNHcm91cHMucmVkdWNlKChjb3VudE1hcCwgc2VyaWVzR3JvdXApID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzZXJpZXNHcm91cC5ncm91cFR5cGUgPT09IFwiZGVmYXVsdFwiIC8qIERFRkFVTFQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGNvdW50TWFwO1xuICAgICAgfVxuICAgICAgY291bnRNYXBbX2EgPSBzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSA/PyAoY291bnRNYXBbX2FdID0gMCk7XG4gICAgICBjb3VudE1hcFtzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSArPSBzZXJpZXNHcm91cC5ncm91cFR5cGUgPT09IFwic3RhY2tcIiAvKiBTVEFDSyAqLyA/IDEgOiBzZXJpZXNHcm91cC5zZXJpZXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGNvdW50TWFwO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gc2VyaWVzR3JvdXBzLmZsYXRNYXAoKHNlcmllc0dyb3VwKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBncm91cElkeFtfYSA9IHNlcmllc0dyb3VwLnNlcmllc1R5cGVdID8/IChncm91cElkeFtfYV0gPSAwKTtcbiAgICAgIHN3aXRjaCAoc2VyaWVzR3JvdXAuZ3JvdXBUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFja1wiIC8qIFNUQUNLICovOlxuICAgICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBncm91cElkeFtzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSsrO1xuICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5zZXJpZXMubWFwKFxuICAgICAgICAgICAgKHNlcmllcywgc3RhY2tJbmRleCkgPT4gT2JqZWN0LmFzc2lnbihzZXJpZXMsIHtcbiAgICAgICAgICAgICAgc2VyaWVzR3JvdXBpbmc6IHtcbiAgICAgICAgICAgICAgICBncm91cElkOiBzZXJpZXNHcm91cC5ncm91cElkLFxuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgZ3JvdXBDb3VudDogZ3JvdXBDb3VudDJbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0sXG4gICAgICAgICAgICAgICAgc3RhY2tJbmRleCxcbiAgICAgICAgICAgICAgICBzdGFja0NvdW50OiBzZXJpZXNHcm91cC5zZXJpZXMubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImdyb3VwXCIgLyogR1JPVVAgKi86XG4gICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLnNlcmllcy5tYXAoXG4gICAgICAgICAgICAoc2VyaWVzKSA9PiBPYmplY3QuYXNzaWduKHNlcmllcywge1xuICAgICAgICAgICAgICBzZXJpZXNHcm91cGluZzoge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHNlcmllc0dyb3VwLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJZHhbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0rKyxcbiAgICAgICAgICAgICAgICBncm91cENvdW50OiBncm91cENvdW50MltzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSxcbiAgICAgICAgICAgICAgICBzdGFja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIHN0YWNrQ291bnQ6IDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLnNlcmllcztcbiAgICB9KS5tYXAoKHsgc3RhY2tlZDogXywgZ3JvdXBlZDogX18sIC4uLnNlcmllc09wdGlvbnMgfSkgPT4gc2VyaWVzT3B0aW9ucyk7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBJZChzZXJpZXMpIHtcbiAgICByZXR1cm4gW3Nlcmllcy50eXBlLCBzZXJpZXMueEtleSwgc2VyaWVzLnN0YWNrZWQgPyBzZXJpZXMuc3RhY2tHcm91cCA/PyBcInN0YWNrZWRcIiA6IFwiZ3JvdXBlZFwiXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIi1cIik7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBpbmcoYWxsU2VyaWVzKSB7XG4gICAgY29uc3QgZ3JvdXBNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJldHVybiBhbGxTZXJpZXMucmVkdWNlKChyZXN1bHQsIHNlcmllcykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVHlwZTIgPSBzZXJpZXMudHlwZTtcbiAgICAgIGlmICghc2VyaWVzLnN0YWNrZWQgJiYgIXNlcmllcy5ncm91cGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgZ3JvdXBUeXBlOiBcImRlZmF1bHRcIiAvKiBERUZBVUxUICovLCBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlMiwgc2VyaWVzOiBbc2VyaWVzXSwgZ3JvdXBJZDogXCJfX2RlZmF1bHRfX1wiIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZ3JvdXBJZCA9IHRoaXMuZ2V0U2VyaWVzR3JvdXBJZChzZXJpZXMpO1xuICAgICAgICBpZiAoIWdyb3VwTWFwLmhhcyhncm91cElkKSkge1xuICAgICAgICAgIGNvbnN0IGdyb3VwVHlwZSA9IHNlcmllcy5zdGFja2VkID8gXCJzdGFja1wiIC8qIFNUQUNLICovIDogXCJncm91cFwiIC8qIEdST1VQICovO1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHsgZ3JvdXBUeXBlLCBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlMiwgc2VyaWVzOiBbXSwgZ3JvdXBJZCB9O1xuICAgICAgICAgIGdyb3VwTWFwLnNldChncm91cElkLCByZWNvcmQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBNYXAuZ2V0KGdyb3VwSWQpLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgfVxuICBnZXREZWZhdWx0U2VyaWVzVHlwZShvcHRpb25zKSB7XG4gICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcImxpbmVcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwicGllXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJ0cmVlbWFwXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcIm1hcC1zaGFwZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ0Zsb3dQcm9wb3J0aW9uQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJzYW5rZXlcIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFydCBvcHRpb25zIHR5cGUgZGV0ZWN0ZWQuXCIpO1xuICB9XG4gIGdldFRvb2x0aXBQb3NpdGlvbkRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnMudG9vbHRpcD8ucG9zaXRpb247XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQgfSA9IHBvc2l0aW9uO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChpc1N0cmluZyh0eXBlKSAmJiBpc0VudW1WYWx1ZShBZ1Rvb2x0aXBQb3NpdGlvblR5cGUsIHR5cGUpKSB7XG4gICAgICByZXN1bHQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcih4T2Zmc2V0KSkge1xuICAgICAgcmVzdWx0LnhPZmZzZXQgPSB4T2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoeU9mZnNldCkpIHtcbiAgICAgIHJlc3VsdC55T2Zmc2V0ID0geU9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9vbHRpcDogeyBwb3NpdGlvbjogcmVzdWx0IH0gfTtcbiAgfVxuICAvLyBBRy0xMTU5MSBTdXBwb3J0IGZvciBuZXcgc2VyaWVzLXNwZWNpZmljICYgbGVnYWN5IGNoYXJ0LWdsb2JhbCAndG9vbHRpcC5yYW5nZScgb3B0aW9uc1xuICAvL1xuICAvLyBUaGUgYGNoYXJ0LnNlcmllc1tdLnRvb2x0aXAucmFuZ2VgIG9wdGlvbiBpcyBhIGJpdCBkaWZmZXJlbnQgZm9yIGxlZ2FjeSByZWFzb24uIFRoaXMgdXNlIHRvIGJlXG4gIC8vIGdsb2JhbCBvcHRpb24gKGBjaGFydC50b29sdGlwLnJhbmdlYCkgdGhhdCBjb3VsZCBvdmVycmlkZSB0aGUgdGhlbWUuIEJ1dCBub3csIHRoZSB0b29sdGlwIHJhbmdlXG4gIC8vIG9wdGlvbiBpcyBzZXJpZXMtc3BlY2lmaWMuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIGJhY2t3YXJkIGNvbXBhdGlibGl0eSwgdGhlIGBjaGFydC50b29sdGlwLnJhbmdlYCB0aGVtZSBkZWZhdWx0IGhhcyBiZWVuIGNoYW5nZWQgZnJvbVxuICAvLyAnbmVhcmVzdCcgdG8gdW5kZWZpbmVkLlxuICBnZXRUb29sdGlwUmFuZ2VEZWZhdWx0cyhvcHRpb25zLCBzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIHJhbmdlOiBvcHRpb25zLnRvb2x0aXA/LnJhbmdlID8/IHNlcmllc1JlZ2lzdHJ5LmdldFRvb2x0aXBEZWZhdWxzKHNlcmllc1R5cGUyKT8ucmFuZ2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZ3Mob3B0aW9ucykge1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRBcnJheVByb3BzID0geyB5S2V5czogXCJ5S2V5XCIsIHlOYW1lczogXCJ5TmFtZVwiIH07XG4gICAgT2JqZWN0LmVudHJpZXMoZGVwcmVjYXRlZEFycmF5UHJvcHMpLmZvckVhY2goKFtvbGRQcm9wLCBuZXdQcm9wXSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzPy5zb21lKChzKSA9PiBzW29sZFByb3BdICE9IG51bGwpKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgUHJvcGVydHkgW3Nlcmllcy4ke29sZFByb3B9XSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFtzZXJpZXMuJHtuZXdQcm9wfV0gYW5kIG11bHRpcGxlIHNlcmllcyBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBheGVzVHlwZUludGVncml0eShvcHRpb25zKSB7XG4gICAgaWYgKFwiYXhlc1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGF4ZXMgPSBvcHRpb25zLmF4ZXMgPz8gW107XG4gICAgICBmb3IgKGNvbnN0IHsgdHlwZSB9IG9mIGF4ZXMpIHtcbiAgICAgICAgaWYgKCFpc0F4aXNPcHRpb25UeXBlKHR5cGUpKSB7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuYXhlcztcbiAgICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gYXhpc1JlZ2lzdHJ5LnB1YmxpY0tleXMoKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB1bmtub3duIGF4aXMgdHlwZTogJHt0eXBlfTsgZXhwZWN0ZWQgb25lIG9mOiAke2V4cGVjdGVkVHlwZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2VyaWVzVHlwZUludGVncml0eShvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcz8uZmlsdGVyKCh7IHR5cGUgfSkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT0gbnVsbCB8fCBpc1Nlcmllc09wdGlvblR5cGUodHlwZSkgfHwgaXNFbnRlcnByaXNlU2VyaWVzVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgYHVua25vd24gc2VyaWVzIHR5cGU6ICR7dHlwZX07IGV4cGVjdGVkIG9uZSBvZjogJHtwdWJsaWNDaGFydFR5cGVzLnNlcmllc1R5cGVzLmpvaW4oXCIsIFwiKX1gXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHNvbG9TZXJpZXNJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIGNvbnN0IGFsbFNlcmllcyA9IG9wdGlvbnMuc2VyaWVzO1xuICAgIGlmIChhbGxTZXJpZXMgJiYgYWxsU2VyaWVzLmxlbmd0aCA+IDEgJiYgYWxsU2VyaWVzLnNvbWUoKHNlcmllcykgPT4gc2VyaWVzUmVnaXN0cnkuaXNTb2xvKHNlcmllcy50eXBlKSkpIHtcbiAgICAgIGNvbnN0IG1haW5TZXJpZXNUeXBlID0gdGhpcy5vcHRpb25zVHlwZShvcHRpb25zKTtcbiAgICAgIGlmIChzZXJpZXNSZWdpc3RyeS5pc1NvbG8obWFpblNlcmllc1R5cGUpKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICAgIGBzZXJpZXNbMF0gb2YgdHlwZSAnJHttYWluU2VyaWVzVHlwZX0nIGlzIGluY29tcGF0aWJsZSB3aXRoIG90aGVyIHNlcmllcyB0eXBlcy4gT25seSBwcm9jZXNzaW5nIHNlcmllc1swXWBcbiAgICAgICAgKTtcbiAgICAgICAgb3B0aW9ucy5zZXJpZXMgPSBhbGxTZXJpZXMuc2xpY2UoMCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHNvbG8sIG5vblNvbG8gfSA9IGdyb3VwQnkoXG4gICAgICAgICAgYWxsU2VyaWVzLFxuICAgICAgICAgIChzKSA9PiBzZXJpZXNSZWdpc3RyeS5pc1NvbG8ocy50eXBlKSA/IFwic29sb1wiIDogXCJub25Tb2xvXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVqZWN0cyA9IHVuaXF1ZShzb2xvLm1hcCgocykgPT4gcy50eXBlKSkuam9pbihcIiwgXCIpO1xuICAgICAgICBMb2dnZXIud2FybihgVW5hYmxlIHRvIG1peCB0aGVzZSBzZXJpZXMgdHlwZXMgd2l0aCB0aGUgbGVhZCBzZXJpZXMgdHlwZTogJHtyZWplY3RzfWApO1xuICAgICAgICBvcHRpb25zLnNlcmllcyA9IG5vblNvbG87XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuYWJsZUNvbmZpZ3VyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhcbiAgICAgIHRoaXMudXNlck9wdGlvbnMsXG4gICAgICAodmlzaXRpbmdVc2VyT3B0cywgdmlzaXRpbmdNZXJnZWRPcHRzKSA9PiB7XG4gICAgICAgIGlmICh2aXNpdGluZ01lcmdlZE9wdHMgJiYgXCJlbmFibGVkXCIgaW4gdmlzaXRpbmdNZXJnZWRPcHRzICYmICF2aXNpdGluZ01lcmdlZE9wdHMuX2VuYWJsZWRGcm9tVGhlbWUgJiYgdmlzaXRpbmdVc2VyT3B0cy5lbmFibGVkID09IG51bGwpIHtcbiAgICAgICAgICB2aXNpdGluZ01lcmdlZE9wdHMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIiwgXCJ0aGVtZVwiXSB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAganNvbldhbGsoXG4gICAgICBvcHRpb25zLFxuICAgICAgKHZpc2l0aW5nTWVyZ2VkT3B0cykgPT4ge1xuICAgICAgICBpZiAodmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lICE9IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgdmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCIsIFwidGhlbWVcIl0gfVxuICAgICk7XG4gIH1cbiAgcmVtb3ZlRGlzYWJsZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhcbiAgICAgIG9wdGlvbnMsXG4gICAgICAob3B0aW9uc05vZGUpID0+IHtcbiAgICAgICAgaWYgKFwiZW5hYmxlZFwiIGluIG9wdGlvbnNOb2RlICYmIG9wdGlvbnNOb2RlLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9uc05vZGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJlbmFibGVkXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTm9kZVtrZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCIsIFwidGhlbWVcIl0gfVxuICAgICk7XG4gIH1cbiAgcmVtb3ZlTGVmdG92ZXJTeW1ib2xzKG9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhcbiAgICAgIG9wdGlvbnMsXG4gICAgICAob3B0aW9uc05vZGUpID0+IHtcbiAgICAgICAgaWYgKCFvcHRpb25zTm9kZSB8fCAhaXNPYmplY3Qob3B0aW9uc05vZGUpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9uc05vZGUpKSB7XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNOb2RlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCJdIH1cbiAgICApO1xuICB9XG4gIHNwZWNpYWxPdmVycmlkZXNEZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHNldFdpbmRvdyhvcHRpb25zLndpbmRvdyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLndpbmRvdyA9IHdpbmRvdztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMud2luZG93ID0gZ2xvYmFsLndpbmRvdztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgc2V0RG9jdW1lbnQob3B0aW9ucy5kb2N1bWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMuZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndpbmRvdyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgd2luZG93XCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb2N1bWVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgZG9jdW1lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvYWdDaGFydHMudHNcbnZhciBkZWJ1ZzIgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJvcHRzXCIpO1xuZnVuY3Rpb24gY2hhcnRUeXBlKG9wdGlvbnMpIHtcbiAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJjYXJ0ZXNpYW5cIjtcbiAgfSBlbHNlIGlmIChpc0FnUG9sYXJDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJwb2xhclwiO1xuICB9IGVsc2UgaWYgKGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJoaWVyYXJjaHlcIjtcbiAgfSBlbHNlIGlmIChpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJ0b3BvbG9neVwiO1xuICB9IGVsc2UgaWYgKGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcImZsb3ctcHJvcG9ydGlvblwiO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnQgLSB1bmtub3duIHR5cGUgb2YgY2hhcnQgZm9yIG9wdGlvbnMgd2l0aCB0eXBlOiAke29wdGlvbnMudHlwZX1gKTtcbn1cbnZhciBBZ0NoYXJ0cyA9IGNsYXNzIHtcbiAgc3RhdGljIGxpY2Vuc2VDaGVjayhvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMubGljZW5zZUNoZWNrZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlciA9IGVudGVycHJpc2VNb2R1bGUubGljZW5zZU1hbmFnZXI/LihvcHRpb25zKTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyPy5zZXRMaWNlbnNlS2V5KHRoaXMubGljZW5zZUtleSwgdGhpcy5ncmlkQ29udGV4dCk7XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlcj8udmFsaWRhdGVMaWNlbnNlKCk7XG4gICAgdGhpcy5saWNlbnNlQ2hlY2tlZCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIHNldExpY2Vuc2VLZXkobGljZW5zZUtleSkge1xuICAgIHRoaXMubGljZW5zZUtleSA9IGxpY2Vuc2VLZXk7XG4gIH1cbiAgc3RhdGljIHNldEdyaWRDb250ZXh0KGdyaWRDb250ZXh0KSB7XG4gICAgdGhpcy5ncmlkQ29udGV4dCA9IGdyaWRDb250ZXh0O1xuICB9XG4gIHN0YXRpYyBnZXRMaWNlbnNlRGV0YWlscyhsaWNlbnNlS2V5KSB7XG4gICAgcmV0dXJuIGVudGVycHJpc2VNb2R1bGUubGljZW5zZU1hbmFnZXI/Lih7fSkuZ2V0TGljZW5zZURldGFpbHMobGljZW5zZUtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBBZ0NoYXJ0SW5zdGFuY2VgIGZvciBhIERPTSBub2RlLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudDIpIHtcbiAgICByZXR1cm4gQWdDaGFydHNJbnRlcm5hbC5nZXRJbnN0YW5jZShlbGVtZW50Mik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQWdDaGFydEluc3RhbmNlYCBiYXNlZCB1cG9uIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxpY2Vuc2VDaGVjayhvcHRpb25zKTtcbiAgICBjb25zdCBjaGFydCA9IEFnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUob3B0aW9ucywgdm9pZCAwLCB0aGlzLmxpY2Vuc2VNYW5hZ2VyKTtcbiAgICBpZiAoZW50ZXJwcmlzZU1vZHVsZS5zdHlsZXMgIT0gbnVsbCkge1xuICAgICAgY2hhcnQuY2hhcnQuY3R4LmRvbU1hbmFnZXIuYWRkU3R5bGVzKFwiYWctY2hhcnRzLWVudGVycHJpc2VcIiwgZW50ZXJwcmlzZU1vZHVsZS5zdHlsZXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5saWNlbnNlTWFuYWdlcj8uaXNEaXNwbGF5V2F0ZXJtYXJrKCkgJiYgdGhpcy5saWNlbnNlTWFuYWdlcikge1xuICAgICAgZW50ZXJwcmlzZU1vZHVsZS5pbmplY3RXYXRlcm1hcms/LihjaGFydC5jaGFydC5jdHguZG9tTWFuYWdlciwgdGhpcy5saWNlbnNlTWFuYWdlci5nZXRXYXRlcm1hcmtNZXNzYWdlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZpbmFuY2lhbENoYXJ0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgX3R5cGU6IFwicHJpY2Utdm9sdW1lXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbn07XG5BZ0NoYXJ0cy5saWNlbnNlQ2hlY2tlZCA9IGZhbHNlO1xuQWdDaGFydHMuZ3JpZENvbnRleHQgPSBmYWxzZTtcbnZhciBfQWdDaGFydHNJbnRlcm5hbCA9IGNsYXNzIF9BZ0NoYXJ0c0ludGVybmFsIHtcbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQyKSB7XG4gICAgY29uc3QgY2hhcnQgPSBDaGFydC5nZXRJbnN0YW5jZShlbGVtZW50Mik7XG4gICAgcmV0dXJuIGNoYXJ0ID8gQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuZ2V0KGNoYXJ0KSA6IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGlzZU1vZHVsZXMoKSB7XG4gICAgaWYgKF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIHJlZ2lzdGVySW5idWlsdE1vZHVsZXMoKTtcbiAgICBzZXR1cE1vZHVsZXMoKTtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZU9yVXBkYXRlKG9wdGlvbnMsIHByb3h5LCBsaWNlbnNlTWFuYWdlcikge1xuICAgIF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VNb2R1bGVzKCk7XG4gICAgZGVidWcyKFwiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgdXNlciBvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRUeXBlID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy50eXBlO1xuICAgIGNvbnN0IHsgX3R5cGUgPSBkZWZhdWx0VHlwZSwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIGxldCBtdXRhYmxlT3B0aW9ucyA9IG90aGVyT3B0aW9ucztcbiAgICBpZiAoQWdDaGFydHMub3B0aW9uc011dGF0aW9uRm4pIHtcbiAgICAgIG11dGFibGVPcHRpb25zID0gQWdDaGFydHMub3B0aW9uc011dGF0aW9uRm4obXV0YWJsZU9wdGlvbnMsIF90eXBlKTtcbiAgICAgIGRlYnVnMihcIj4+PiBBZ0NoYXJ0cy5jcmVhdGVPclVwZGF0ZSgpIE1VVEFURUQgdXNlciBvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB7IG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbywgZG9jdW1lbnQ6IGRvY3VtZW50Miwgd2luZG93OiB1c2VyV2luZG93LCAuLi51c2VyT3B0aW9ucyB9ID0gbXV0YWJsZU9wdGlvbnM7XG4gICAgY29uc3QgY2hhcnRPcHRpb25zID0gbmV3IENoYXJ0T3B0aW9ucyh1c2VyT3B0aW9ucywge1xuICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50MixcbiAgICAgIHdpbmRvdzogdXNlcldpbmRvdyxcbiAgICAgIHR5cGU6IF90eXBlXG4gICAgfSk7XG4gICAgbGV0IGNoYXJ0ID0gcHJveHk/LmNoYXJ0O1xuICAgIGlmIChjaGFydCA9PSBudWxsIHx8IGNoYXJ0VHlwZSh1c2VyT3B0aW9ucykgIT09IGNoYXJ0VHlwZShjaGFydD8uY2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMpKSB7XG4gICAgICBjaGFydCA9IF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZUNoYXJ0SW5zdGFuY2UoY2hhcnRPcHRpb25zLCBjaGFydCk7XG4gICAgfVxuICAgIGlmIChwcm94eSA9PSBudWxsKSB7XG4gICAgICBwcm94eSA9IG5ldyBBZ0NoYXJ0SW5zdGFuY2VQcm94eShjaGFydCwgX0FnQ2hhcnRzSW50ZXJuYWwuY2FsbGJhY2tBcGksIGxpY2Vuc2VNYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveHkuY2hhcnQgPSBjaGFydDtcbiAgICB9XG4gICAgaWYgKGRlYnVnMi5jaGVjaygpICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzID8/ICh3aW5kb3cuYWdDaGFydEluc3RhbmNlcyA9IHt9KTtcbiAgICAgIHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuICAgIH1cbiAgICBjaGFydC5xdWV1ZWRVc2VyT3B0aW9ucy5wdXNoKHVzZXJPcHRpb25zKTtcbiAgICBjaGFydC5yZXF1ZXN0RmFjdG9yeVVwZGF0ZSgoY2hhcnRSZWYpID0+IHtcbiAgICAgIGNoYXJ0UmVmLmFwcGx5T3B0aW9ucyhjaGFydE9wdGlvbnMpO1xuICAgICAgY29uc3QgcXVldWVJZHggPSBjaGFydFJlZi5xdWV1ZWRVc2VyT3B0aW9ucy5pbmRleE9mKHVzZXJPcHRpb25zKSArIDE7XG4gICAgICBjaGFydFJlZi5xdWV1ZWRVc2VyT3B0aW9ucy5zcGxpY2UoMCwgcXVldWVJZHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlVXNlckRlbHRhKHByb3h5LCBkZWx0YU9wdGlvbnMpIHtcbiAgICBkZWx0YU9wdGlvbnMgPSBkZWVwQ2xvbmUoZGVsdGFPcHRpb25zLCB7IHNoYWxsb3c6IFtcImRhdGFcIl0gfSk7XG4gICAganNvbldhbGsoXG4gICAgICBkZWx0YU9wdGlvbnMsXG4gICAgICAobm9kZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obm9kZSwgeyBba2V5XTogU3ltYm9sKFwiVU5TRVRcIikgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCJdIH1cbiAgICApO1xuICAgIGNvbnN0IHsgY2hhcnQgfSA9IHByb3h5O1xuICAgIGNvbnN0IGxhc3RVcGRhdGVPcHRpb25zID0gY2hhcnQuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IHVzZXJPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhkZWx0YU9wdGlvbnMsIGxhc3RVcGRhdGVPcHRpb25zKTtcbiAgICBkZWJ1ZzIoXCI+Pj4gQWdDaGFydHMudXBkYXRlVXNlckRlbHRhKCkgdXNlciBkZWx0YVwiLCBkZWx0YU9wdGlvbnMpO1xuICAgIGRlYnVnMihcIkFnQ2hhcnRzLnVwZGF0ZVVzZXJEZWx0YSgpIC0gYmFzZSBvcHRpb25zXCIsIGxhc3RVcGRhdGVPcHRpb25zKTtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZSh1c2VyT3B0aW9ucywgcHJveHkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVDaGFydEluc3RhbmNlKG9wdGlvbnMsIG9sZENoYXJ0KSB7XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlUmVzb3VyY2UgPSBvbGRDaGFydD8uZGVzdHJveSh7IGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM6IHRydWUgfSk7XG4gICAgY29uc3QgQ2hhcnRDb25zdHJ1Y3RvciA9IF9BZ0NoYXJ0c0ludGVybmFsLmdldENoYXJ0QnlPcHRpb25zKG9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBDaGFydENvbnN0cnVjdG9yKG9wdGlvbnMsIHRyYW5zZmVyYWJsZVJlc291cmNlKTtcbiAgfVxuICBzdGF0aWMgZ2V0Q2hhcnRCeU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gQ2FydGVzaWFuQ2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gSGllcmFyY2h5Q2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnUG9sYXJDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBQb2xhckNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gVG9wb2xvZ3lDaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIEZsb3dQcm9wb3J0aW9uQ2hhcnQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBRyBDaGFydHMgLSBjb3VsZG4ndCBhcHBseSBjb25maWd1cmF0aW9uLCBjaGVjayBvcHRpb25zIGFyZSBjb3JyZWN0bHkgc3RydWN0dXJlZCBhbmQgc2VyaWVzIHR5cGVzIGFyZSBzcGVjaWZpZWRgXG4gICAgKTtcbiAgfVxufTtcbl9BZ0NoYXJ0c0ludGVybmFsLmNhcmV0YWtlciA9IG5ldyBNZW1lbnRvQ2FyZXRha2VyKFZFUlNJT04pO1xuX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbl9BZ0NoYXJ0c0ludGVybmFsLmNhbGxiYWNrQXBpID0ge1xuICBjYXJldGFrZXI6IF9BZ0NoYXJ0c0ludGVybmFsLmNhcmV0YWtlcixcbiAgY3JlYXRlT3JVcGRhdGUob3B0cywgY2hhcnQpIHtcbiAgICByZXR1cm4gX0FnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUob3B0cywgY2hhcnQpO1xuICB9LFxuICB1cGRhdGVVc2VyRGVsdGEoY2hhcnQsIGRlbHRhT3B0aW9ucykge1xuICAgIHJldHVybiBfQWdDaGFydHNJbnRlcm5hbC51cGRhdGVVc2VyRGVsdGEoY2hhcnQsIGRlbHRhT3B0aW9ucyk7XG4gIH1cbn07XG52YXIgQWdDaGFydHNJbnRlcm5hbCA9IF9BZ0NoYXJ0c0ludGVybmFsO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9pbnRlZ3JhdGVkLWNoYXJ0cy1zY2VuZS50c1xudmFyIGludGVncmF0ZWRfY2hhcnRzX3NjZW5lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGludGVncmF0ZWRfY2hhcnRzX3NjZW5lX2V4cG9ydHMsIHtcbiAgQXJjOiAoKSA9PiBBcmMyLFxuICBCQm94OiAoKSA9PiBCQm94LFxuICBCYW5kU2NhbGU6ICgpID0+IEJhbmRTY2FsZSxcbiAgQ2FwdGlvbjogKCkgPT4gQ2FwdGlvbixcbiAgQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXM6ICgpID0+IENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzLFxuICBDaXJjbGU6ICgpID0+IENpcmNsZSxcbiAgQ29udGludW91c1NjYWxlOiAoKSA9PiBDb250aW51b3VzU2NhbGUsXG4gIERpYW1vbmQ6ICgpID0+IERpYW1vbmQsXG4gIERyb3BTaGFkb3c6ICgpID0+IERyb3BTaGFkb3csXG4gIEV4dGVuZGVkUGF0aDJEOiAoKSA9PiBFeHRlbmRlZFBhdGgyRCxcbiAgR3JvdXA6ICgpID0+IEdyb3VwLFxuICBIZHBpQ2FudmFzOiAoKSA9PiBIZHBpQ2FudmFzLFxuICBJbWFnZTogKCkgPT4gSW1hZ2UsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGluZTogKCkgPT4gTGluZSxcbiAgTGluZWFyR3JhZGllbnRGaWxsOiAoKSA9PiBMaW5lYXJHcmFkaWVudEZpbGwsXG4gIExpbmVhclNjYWxlOiAoKSA9PiBMaW5lYXJTY2FsZSxcbiAgTWFya2VyOiAoKSA9PiBNYXJrZXIsXG4gIE5vZGU6ICgpID0+IE5vZGUsXG4gIE9yZGluYWxUaW1lU2NhbGU6ICgpID0+IE9yZGluYWxUaW1lU2NhbGUsXG4gIFBhdGg6ICgpID0+IFBhdGgsXG4gIFBvaW50ZXJFdmVudHM6ICgpID0+IFBvaW50ZXJFdmVudHMsXG4gIFJhZGlhbENvbHVtblNoYXBlOiAoKSA9PiBSYWRpYWxDb2x1bW5TaGFwZSxcbiAgUmVjdDogKCkgPT4gUmVjdCxcbiAgUmVkcmF3VHlwZTogKCkgPT4gUmVkcmF3VHlwZSxcbiAgU2NlbmU6ICgpID0+IFNjZW5lLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbjogKCkgPT4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24sXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbjogKCkgPT4gU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uLFxuICBTZWN0b3I6ICgpID0+IFNlY3RvcixcbiAgU2VjdG9yQm94OiAoKSA9PiBTZWN0b3JCb3gsXG4gIFNlbGVjdGlvbjogKCkgPT4gU2VsZWN0aW9uLFxuICBTaGFwZTogKCkgPT4gU2hhcGUsXG4gIFNxdWFyZTogKCkgPT4gU3F1YXJlLFxuICBTdmdQYXRoOiAoKSA9PiBTdmdQYXRoLFxuICBUZXh0OiAoKSA9PiBUZXh0LFxuICBUb29sdGlwOiAoKSA9PiBUb29sdGlwLFxuICBUcmlhbmdsZTogKCkgPT4gVHJpYW5nbGUsXG4gIGRyYXdDb3JuZXI6ICgpID0+IGRyYXdDb3JuZXIsXG4gIGVhc2luZzogKCkgPT4gZWFzaW5nX2V4cG9ydHMsXG4gIGV2YWx1YXRlQmV6aWVyOiAoKSA9PiBldmFsdWF0ZUJlemllcixcbiAgZ2V0Rm9udDogKCkgPT4gZ2V0Rm9udCxcbiAgZ2V0TWFya2VyOiAoKSA9PiBnZXRNYXJrZXIsXG4gIGdldFJhZGlhbENvbHVtbldpZHRoOiAoKSA9PiBnZXRSYWRpYWxDb2x1bW5XaWR0aCxcbiAgbW90aW9uOiAoKSA9PiBtb3Rpb24sXG4gIHNlY3RvckJveDogKCkgPT4gc2VjdG9yQm94LFxuICBzb2x2ZUJlemllcjogKCkgPT4gc29sdmVCZXppZXIsXG4gIHNwbGl0QmV6aWVyOiAoKSA9PiBzcGxpdEJlemllcixcbiAgdG9SYWRpYW5zOiAoKSA9PiB0b1JhZGlhbnMsXG4gIHRvVG9vbHRpcEh0bWw6ICgpID0+IHRvVG9vbHRpcEh0bWxcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9hcmMudHNcbnZhciBBcmMyID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgdGhpcy5yYWRpdXMgPSAxMDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMjtcbiAgICB0aGlzLmNvdW50ZXJDbG9ja3dpc2UgPSBmYWxzZTtcbiAgICB0aGlzLnR5cGUgPSAwIC8qIE9wZW4gKi87XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgZ2V0IGZ1bGxQaWUoKSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobm9ybWFsaXplQW5nbGUzNjAodGhpcy5zdGFydEFuZ2xlKSwgbm9ybWFsaXplQW5nbGUzNjAodGhpcy5lbmRBbmdsZSkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5hcmModGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMucmFkaXVzLCB0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUsIHRoaXMuY291bnRlckNsb2Nrd2lzZSk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gMSAvKiBDaG9yZCAqLykge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gMiAvKiBSb3VuZCAqLyAmJiAhdGhpcy5mdWxsUGllKSB7XG4gICAgICBwYXRoLmxpbmVUbyh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3godGhpcy5jZW50ZXJYIC0gdGhpcy5yYWRpdXMsIHRoaXMuY2VudGVyWSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICByZXR1cm4gdGhpcy50eXBlICE9PSAwIC8qIE9wZW4gKi8gJiYgYmJveC5jb250YWluc1BvaW50KHBvaW50LngsIHBvaW50LnkpICYmIHRoaXMucGF0aC5pc1BvaW50SW5QYXRoKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG59O1xuQXJjMi5jbGFzc05hbWUgPSBcIkFyY1wiO1xuQXJjMi5kZWZhdWx0U3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2hhcGUuZGVmYXVsdFN0eWxlcywge1xuICBsaW5lV2lkdGg6IDEsXG4gIGZpbGxTdHlsZTogbnVsbFxufSk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiY2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJjZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcInJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImNvdW50ZXJDbG9ja3dpc2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvbGluZWFyR3JhZGllbnRGaWxsLnRzXG52YXIgTGluZWFyR3JhZGllbnRGaWxsID0gY2xhc3MgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInRvLXJpZ2h0XCI7XG4gICAgdGhpcy5zdG9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9tYXNrID0gdm9pZCAwO1xuICB9XG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICB9XG4gIHNldCBtYXNrKG5ld01hc2spIHtcbiAgICBpZiAodGhpcy5fbWFzayAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuX21hc2spO1xuICAgIH1cbiAgICBpZiAobmV3TWFzayAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld01hc2spO1xuICAgIH1cbiAgICB0aGlzLl9tYXNrID0gbmV3TWFzaztcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrPy5pc1BvaW50SW5QYXRoKHgsIHkpID8/IGZhbHNlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiB0aGlzLm1hc2s/LmdldEJCb3goKTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBtYXNrLCBzdG9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGN0eCwgZGV2aWNlUGl4ZWxSYXRpbyB9ID0gcmVuZGVyQ3R4O1xuICAgIGNvbnN0IHBpeGVsTGVuZ3RoID0gMSAvIGRldmljZVBpeGVsUmF0aW87XG4gICAgY29uc3QgbWFza0Jib3ggPSBtYXNrPy5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgaWYgKG1hc2sgPT0gbnVsbCB8fCBzdG9wcyA9PSBudWxsIHx8IG1hc2tCYm94ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKG1hc2suZGlydHlQYXRoKSB7XG4gICAgICBtYXNrLnVwZGF0ZVBhdGgoKTtcbiAgICAgIG1hc2suZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmNsaXAobWFzay5wYXRoLmdldFBhdGgyRCgpKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRldmljZVBpeGVsUmF0aW8sIDAsIDAsIGRldmljZVBpeGVsUmF0aW8sIDAsIDApO1xuICAgIGNvbnN0IHgwID0gTWF0aC5mbG9vcihtYXNrQmJveC54KTtcbiAgICBjb25zdCB4MSA9IE1hdGguY2VpbChtYXNrQmJveC54ICsgbWFza0Jib3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5mbG9vcihtYXNrQmJveC55KTtcbiAgICBjb25zdCB5MSA9IE1hdGguY2VpbChtYXNrQmJveC55ICsgbWFza0Jib3guaGVpZ2h0KTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5kaXJlY3Rpb24gPT09IFwidG8tcmlnaHRcIiB8fCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ0by1sZWZ0XCI7XG4gICAgY29uc3QgcmV2ZXJzZWQgPSB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiB8fCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ0by1sZWZ0XCI7XG4gICAgY29uc3QgY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gICAgY29uc3QgW2kwLCBpMV0gPSBob3Jpem9udGFsID8gW3gwLCB4MV0gOiBbeTAsIHkxXTtcbiAgICBjb2xvclNjYWxlLmRvbWFpbiA9IHN0b3BzLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBpMCArIChpMSAtIGkwKSAqIGluZGV4IC8gKHN0b3BzLmxlbmd0aCAtIDEpO1xuICAgIH0pO1xuICAgIGNvbG9yU2NhbGUucmFuZ2UgPSByZXZlcnNlZCA/IHN0b3BzLnNsaWNlKCkucmV2ZXJzZSgpIDogc3RvcHM7XG4gICAgY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MSAtIHkwO1xuICAgIGNvbnN0IHdpZHRoID0geDEgLSB4MDtcbiAgICBzd2l0Y2ggKHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIFwidG8tcmlnaHRcIjpcbiAgICAgIGNhc2UgXCJ0by1sZWZ0XCI6XG4gICAgICAgIGZvciAobGV0IHggPSB4MDsgeCA8PSB4MTsgeCArPSBwaXhlbExlbmd0aCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvclNjYWxlLmNvbnZlcnQoeCk7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHkwLCBwaXhlbExlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0by1ib3R0b21cIjpcbiAgICAgIGNhc2UgXCJ0by10b3BcIjpcbiAgICAgICAgZm9yIChsZXQgeSA9IHkwOyB5IDw9IHkxOyB5ICs9IHBpeGVsTGVuZ3RoKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yU2NhbGUuY29udmVydCh5KTtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoeDAsIHksIHdpZHRoLCBwaXhlbExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZWFyR3JhZGllbnRGaWxsLnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZWFyR3JhZGllbnRGaWxsLnByb3RvdHlwZSwgXCJzdG9wc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lYXJHcmFkaWVudEZpbGwucHJvdG90eXBlLCBcIl9tYXNrXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9yYWRpYWxDb2x1bW5TaGFwZS50c1xuZnVuY3Rpb24gcm90YXRlUG9pbnQoeCwgeSwgcm90YXRpb24pIHtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KHggKiogMiArIHkgKiogMik7XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIGNvbnN0IHJvdGF0ZWQgPSBhbmdsZTIgKyByb3RhdGlvbjtcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLmNvcyhyb3RhdGVkKSAqIHJhZGl1cyxcbiAgICB5OiBNYXRoLnNpbihyb3RhdGVkKSAqIHJhZGl1c1xuICB9O1xufVxudmFyIFJhZGlhbENvbHVtblNoYXBlID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmlzQmV2ZWxlZCA9IHRydWU7XG4gICAgdGhpcy5jb2x1bW5XaWR0aCA9IDA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmF4aXNJbm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5heGlzT3V0ZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuaXNSYWRpdXNBeGlzUmV2ZXJzZWQgPSBmYWxzZTtcbiAgfVxuICBzZXQgY29ybmVyUmFkaXVzKF92YWx1ZSkge1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjb2x1bW5XaWR0aCB9ID0gdGhpcztcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCBsZWZ0ID0gLWNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzO1xuICAgIGxldCB4MCA9IEluZmluaXR5O1xuICAgIGxldCB5MCA9IEluZmluaXR5O1xuICAgIGxldCB4MSA9IC1JbmZpbml0eTtcbiAgICBsZXQgeTEgPSAtSW5maW5pdHk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcm90YXRlUG9pbnQoaSAlIDIgPT09IDAgPyBsZWZ0IDogcmlnaHQsIGkgPCAyID8gdG9wIDogYm90dG9tLCByb3RhdGlvbik7XG4gICAgICB4MCA9IE1hdGgubWluKHgsIHgwKTtcbiAgICAgIHkwID0gTWF0aC5taW4oeSwgeTApO1xuICAgICAgeDEgPSBNYXRoLm1heCh4LCB4MSk7XG4gICAgICB5MSA9IE1hdGgubWF4KHksIHkxKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCQm94KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gIH1cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gdGhpcztcbiAgICBjb25zdCBtaWRBbmdsZSA9IGFuZ2xlQmV0d2VlbihzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFuZ2xlMzYwKHN0YXJ0QW5nbGUgKyBtaWRBbmdsZSAvIDIgKyBNYXRoLlBJIC8gMik7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IGlzQmV2ZWxlZCB9ID0gdGhpcztcbiAgICBpZiAoaXNCZXZlbGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJldmVsZWRQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlUmVjdGFuZ3VsYXJQYXRoKCk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICB1cGRhdGVSZWN0YW5ndWxhclBhdGgoKSB7XG4gICAgY29uc3QgeyBjb2x1bW5XaWR0aCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxlZnQgPSAtY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHJpZ2h0ID0gY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHRvcCA9IC1vdXRlclJhZGl1cztcbiAgICBjb25zdCBib3R0b20gPSAtaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgW2xlZnQsIGJvdHRvbV0sXG4gICAgICBbbGVmdCwgdG9wXSxcbiAgICAgIFtyaWdodCwgdG9wXSxcbiAgICAgIFtyaWdodCwgYm90dG9tXVxuICAgIF0ubWFwKChbeCwgeV0pID0+IHJvdGF0ZVBvaW50KHgsIHksIHJvdGF0aW9uKSk7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBwYXRoLm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgIHBhdGgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzJdLngsIHBvaW50c1syXS55KTtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbM10ueCwgcG9pbnRzWzNdLnkpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbiAgdXBkYXRlQmV2ZWxlZFBhdGgoKSB7XG4gICAgY29uc3QgeyBjb2x1bW5XaWR0aCwgcGF0aCwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBheGlzSW5uZXJSYWRpdXMsIGF4aXNPdXRlclJhZGl1cywgaXNSYWRpdXNBeGlzUmV2ZXJzZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNTdGFja0JvdHRvbSA9IGlzRXF1YWwoaW5uZXJSYWRpdXMsIGF4aXNJbm5lclJhZGl1cyk7XG4gICAgY29uc3Qgc2lkZVJvdGF0aW9uID0gTWF0aC5hc2luKGNvbHVtbldpZHRoIC8gMiAvIGlubmVyUmFkaXVzKTtcbiAgICBjb25zdCBwb2ludFJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IHJvdGF0ZTIgPSAoeCwgeSkgPT4gcm90YXRlUG9pbnQoeCwgeSwgcG9pbnRSb3RhdGlvbik7XG4gICAgY29uc3QgZ2V0VHJpYW5nbGVIeXBvdGVudXNlID0gKGxlZywgb3RoZXJMZWcpID0+IE1hdGguc3FydChsZWcgKiogMiArIG90aGVyTGVnICoqIDIpO1xuICAgIGNvbnN0IGdldFRyaWFuZ2xlTGVnID0gKGh5cG90ZW51c2UsIG90aGVyTGVnKSA9PiB7XG4gICAgICBpZiAob3RoZXJMZWcgPiBoeXBvdGVudXNlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc3FydChoeXBvdGVudXNlICoqIDIgLSBvdGhlckxlZyAqKiAyKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBhcmUgPSAodmFsdWUsIG90aGVyVmFsdWUsIGxlc3NUaGFuKSA9PiBsZXNzVGhhbiA/IHZhbHVlIDwgb3RoZXJWYWx1ZSA6IHZhbHVlID4gb3RoZXJWYWx1ZTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlID0gaXNTdGFja0JvdHRvbSAmJiAhaXNOYU4oc2lkZVJvdGF0aW9uKSAmJiBzaWRlUm90YXRpb24gPCBNYXRoLlBJIC8gNjtcbiAgICBsZXQgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgbGV0IHJpZ2h0ID0gY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHRvcCA9IC1vdXRlclJhZGl1cztcbiAgICBjb25zdCBib3R0b20gPSAtaW5uZXJSYWRpdXMgKiAoc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSA/IE1hdGguY29zKHNpZGVSb3RhdGlvbikgOiAxKTtcbiAgICBjb25zdCBoYXNCb3R0b21JbnRlcnNlY3Rpb24gPSBjb21wYXJlKFxuICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgZ2V0VHJpYW5nbGVIeXBvdGVudXNlKGlubmVyUmFkaXVzLCBjb2x1bW5XaWR0aCAvIDIpLFxuICAgICAgIWlzUmFkaXVzQXhpc1JldmVyc2VkXG4gICAgKTtcbiAgICBpZiAoaGFzQm90dG9tSW50ZXJzZWN0aW9uKSB7XG4gICAgICBjb25zdCBib3R0b21JbnRlcnNlY3Rpb25YID0gZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBpbm5lclJhZGl1cyk7XG4gICAgICBsZWZ0ID0gLWJvdHRvbUludGVyc2VjdGlvblg7XG4gICAgICByaWdodCA9IGJvdHRvbUludGVyc2VjdGlvblg7XG4gICAgfVxuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgY29uc3QgYm90dG9tTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBib3R0b20pO1xuICAgIHBhdGgubW92ZVRvKGJvdHRvbUxlZnRQdC54LCBib3R0b21MZWZ0UHQueSk7XG4gICAgY29uc3QgaXNFbXB0eSA9IGlzRXF1YWwoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKTtcbiAgICBjb25zdCBoYXNTaWRlSW50ZXJzZWN0aW9uID0gY29tcGFyZShcbiAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgIGdldFRyaWFuZ2xlSHlwb3RlbnVzZShvdXRlclJhZGl1cywgY29sdW1uV2lkdGggLyAyKSxcbiAgICAgICFpc1JhZGl1c0F4aXNSZXZlcnNlZFxuICAgICk7XG4gICAgaWYgKGlzRW1wdHkgJiYgc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSkge1xuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MCgtc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChoYXNTaWRlSW50ZXJzZWN0aW9uKSB7XG4gICAgICBjb25zdCBzaWRlSW50ZXJzZWN0aW9uWSA9IC1nZXRUcmlhbmdsZUxlZyhheGlzT3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoIC8gMik7XG4gICAgICBjb25zdCB0b3BJbnRlcnNlY3Rpb25YID0gZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gICAgICBpZiAoIWhhc0JvdHRvbUludGVyc2VjdGlvbikge1xuICAgICAgICBjb25zdCB0b3BMZWZ0UHQgPSByb3RhdGUyKGxlZnQsIHNpZGVJbnRlcnNlY3Rpb25ZKTtcbiAgICAgICAgcGF0aC5saW5lVG8odG9wTGVmdFB0LngsIHRvcExlZnRQdC55KTtcbiAgICAgIH1cbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICAgIE1hdGguYXRhbjIoc2lkZUludGVyc2VjdGlvblksIGxlZnQpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgTWF0aC5hdGFuMih0b3AsIC10b3BJbnRlcnNlY3Rpb25YKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaWYgKCFpc0VxdWFsKHRvcEludGVyc2VjdGlvblgsIDApKSB7XG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0QmV2ZWxQdCA9IHJvdGF0ZTIodG9wSW50ZXJzZWN0aW9uWCwgdG9wKTtcbiAgICAgICAgcGF0aC5saW5lVG8odG9wUmlnaHRCZXZlbFB0LngsIHRvcFJpZ2h0QmV2ZWxQdC55KTtcbiAgICAgIH1cbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICAgIE1hdGguYXRhbjIodG9wLCB0b3BJbnRlcnNlY3Rpb25YKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIE1hdGguYXRhbjIoc2lkZUludGVyc2VjdGlvblksIHJpZ2h0KSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b3BMZWZ0UHQgPSByb3RhdGUyKGxlZnQsIHRvcCk7XG4gICAgICBjb25zdCB0b3BSaWdodFB0ID0gcm90YXRlMihyaWdodCwgdG9wKTtcbiAgICAgIHBhdGgubGluZVRvKHRvcExlZnRQdC54LCB0b3BMZWZ0UHQueSk7XG4gICAgICBwYXRoLmxpbmVUbyh0b3BSaWdodFB0LngsIHRvcFJpZ2h0UHQueSk7XG4gICAgfVxuICAgIGNvbnN0IGJvdHRvbVJpZ2h0UHQgPSByb3RhdGUyKHJpZ2h0LCBib3R0b20pO1xuICAgIHBhdGgubGluZVRvKGJvdHRvbVJpZ2h0UHQueCwgYm90dG9tUmlnaHRQdC55KTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSkge1xuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MChzaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MCgtc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm90YXRlZEJvdHRvbUxlZnRQdCA9IHJvdGF0ZTIobGVmdCwgYm90dG9tKTtcbiAgICAgIHBhdGgubGluZVRvKHJvdGF0ZWRCb3R0b21MZWZ0UHQueCwgcm90YXRlZEJvdHRvbUxlZnRQdC55KTtcbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblJhZGlhbENvbHVtblNoYXBlLmNsYXNzTmFtZSA9IFwiUmFkaWFsQ29sdW1uU2hhcGVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiaXNCZXZlbGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJjb2x1bW5XaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiYXhpc0lubmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJheGlzT3V0ZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImlzUmFkaXVzQXhpc1JldmVyc2VkXCIsIDIpO1xuZnVuY3Rpb24gZ2V0UmFkaWFsQ29sdW1uV2lkdGgoc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGF4aXNPdXRlclJhZGl1cywgY29sdW1uV2lkdGhSYXRpbywgbWF4Q29sdW1uV2lkdGhSYXRpbykge1xuICBjb25zdCByb3RhdGlvbiA9IGFuZ2xlQmV0d2VlbihzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gIGNvbnN0IHBhZDIgPSByb3RhdGlvbiAqICgxIC0gY29sdW1uV2lkdGhSYXRpbykgLyAyO1xuICBzdGFydEFuZ2xlICs9IHBhZDI7XG4gIGVuZEFuZ2xlIC09IHBhZDI7XG4gIGlmIChyb3RhdGlvbiA8IDFlLTMpIHtcbiAgICByZXR1cm4gMiAqIGF4aXNPdXRlclJhZGl1cyAqIG1heENvbHVtbldpZHRoUmF0aW87XG4gIH1cbiAgaWYgKHJvdGF0aW9uID49IDIgKiBNYXRoLlBJKSB7XG4gICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgcm90YXRpb24gLyAyO1xuICAgIHN0YXJ0QW5nbGUgPSBtaWRBbmdsZSAtIE1hdGguUEk7XG4gICAgZW5kQW5nbGUgPSBtaWRBbmdsZSArIE1hdGguUEk7XG4gIH1cbiAgY29uc3Qgc3RhcnRYID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gIGNvbnN0IHN0YXJ0WSA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBlbmRYID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpO1xuICBjb25zdCBlbmRZID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpO1xuICBjb25zdCBjb2xXaWR0aCA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KChzdGFydFggLSBlbmRYKSAqKiAyICsgKHN0YXJ0WSAtIGVuZFkpICoqIDIpKTtcbiAgY29uc3QgbWF4V2lkdGggPSAyICogYXhpc091dGVyUmFkaXVzICogbWF4Q29sdW1uV2lkdGhSYXRpbztcbiAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGgubWluKG1heFdpZHRoLCBjb2xXaWR0aCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9zdmdQYXRoLnRzXG52YXIgU3ZnUGF0aCA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKGQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgZm9yIChjb25zdCBbXywgY29tbWFuZCwgcGFyYW1zU3RyaW5nXSBvZiBkLm1hdGNoQWxsKC8oW0EtWl0pKFswLTkuIF0rKS9nKSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gcGFyYW1zU3RyaW5nLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbY29tbWFuZCwgcGFyYW1zXSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5IH0gPSB0aGlzO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBsZXQgbGFzdFggPSB4O1xuICAgIGxldCBsYXN0WSA9IHk7XG4gICAgZm9yIChjb25zdCBbY29tbWFuZCwgcGFyYW1zXSBvZiB0aGlzLmNvbW1hbmRzKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICBwYXRoLm1vdmVUbyh4ICsgcGFyYW1zWzBdLCB5ICsgcGFyYW1zWzFdKTtcbiAgICAgICAgICBsYXN0WCA9IHggKyBwYXJhbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICAgICAgICB4ICsgcGFyYW1zWzBdLFxuICAgICAgICAgICAgeSArIHBhcmFtc1sxXSxcbiAgICAgICAgICAgIHggKyBwYXJhbXNbMl0sXG4gICAgICAgICAgICB5ICsgcGFyYW1zWzNdLFxuICAgICAgICAgICAgeCArIHBhcmFtc1s0XSxcbiAgICAgICAgICAgIHkgKyBwYXJhbXNbNV1cbiAgICAgICAgICApO1xuICAgICAgICAgIGxhc3RYID0geCArIHBhcmFtc1s0XTtcbiAgICAgICAgICBsYXN0WSA9IHkgKyBwYXJhbXNbNV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcGF0aC5saW5lVG8oeCArIHBhcmFtc1swXSwgbGFzdFkpO1xuICAgICAgICAgIGxhc3RYID0geSArIHBhcmFtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICBwYXRoLmxpbmVUbyh4ICsgcGFyYW1zWzBdLCB5ICsgcGFyYW1zWzFdKTtcbiAgICAgICAgICBsYXN0WCA9IHggKyBwYXJhbXNbMF07XG4gICAgICAgICAgbGFzdFkgPSB5ICsgcGFyYW1zWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCB5ICsgcGFyYW1zWzBdKTtcbiAgICAgICAgICBsYXN0WSA9IHkgKyBwYXJhbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgdHJhbnNsYXRlIGNvbW1hbmQgJyR7Y29tbWFuZH0nIHdpdGggJyR7cGFyYW1zLmpvaW4oXCIgXCIpfSdgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTdmdQYXRoLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFN2Z1BhdGgucHJvdG90eXBlLCBcInlcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2ludGVncmF0ZWQtY2hhcnRzLXNjZW5lLnRzXG52YXIgbW90aW9uID0geyAuLi5mcm9tVG9Nb3Rpb25fZXhwb3J0cywgLi4ucmVzZXRNb3Rpb25fZXhwb3J0cyB9O1xudmFyIGdldEZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9pbnRlZ3JhdGVkLWNoYXJ0cy10aGVtZS50c1xudmFyIGludGVncmF0ZWRfY2hhcnRzX3RoZW1lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGludGVncmF0ZWRfY2hhcnRzX3RoZW1lX2V4cG9ydHMsIHtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTogKCkgPT4gQ0FSVEVTSUFOX0FYSVNfVFlQRSxcbiAgQ2hhcnRUaGVtZTogKCkgPT4gQ2hhcnRUaGVtZSxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTDogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTDogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMLFxuICBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVI6ICgpID0+IERFRkFVTFRfQVhJU19HUklEX0NPTE9VUixcbiAgREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0FYSVNfTElORV9DT0xPVVIsXG4gIERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVI6ICgpID0+IERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsXG4gIERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQ6ICgpID0+IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsXG4gIERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEU6ICgpID0+IERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsXG4gIERFRkFVTFRfQ09MT1VSUzogKCkgPT4gREVGQVVMVF9DT0xPVVJTLFxuICBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUjogKCkgPT4gREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsXG4gIERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0U6ICgpID0+IERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsXG4gIERFRkFVTFRfRk9OVF9GQU1JTFk6ICgpID0+IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gIERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRDogKCkgPT4gREVGQVVMVF9HUklETElORV9FTkFCTEVELFxuICBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUzogKCkgPT4gREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsXG4gIERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVM6ICgpID0+IERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMsXG4gIERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfUEFERElORzogKCkgPT4gREVGQVVMVF9QQURESU5HLFxuICBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0U6ICgpID0+IERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSxcbiAgREVGQVVMVF9TSEFET1dfQ09MT1VSOiAoKSA9PiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gIERFRkFVTFRfVEVYVEJPWF9DT0xPUjogKCkgPT4gREVGQVVMVF9URVhUQk9YX0NPTE9SLFxuICBERUZBVUxUX1RFWFRCT1hfRklMTDogKCkgPT4gREVGQVVMVF9URVhUQk9YX0ZJTEwsXG4gIERFRkFVTFRfVEVYVEJPWF9TVFJPS0U6ICgpID0+IERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsXG4gIERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SOiAoKSA9PiBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUixcbiAgREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OOiAoKSA9PiBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sXG4gIEZPTlRfU0laRTogKCkgPT4gRk9OVF9TSVpFLFxuICBGT05UX1dFSUdIVDogKCkgPT4gRk9OVF9XRUlHSFQyLFxuICBJU19EQVJLX1RIRU1FOiAoKSA9PiBJU19EQVJLX1RIRU1FLFxuICBQQUxFVFRFX0FMVF9ET1dOX0ZJTEw6ICgpID0+IFBBTEVUVEVfQUxUX0RPV05fRklMTCxcbiAgUEFMRVRURV9BTFRfRE9XTl9TVFJPS0U6ICgpID0+IFBBTEVUVEVfQUxUX0RPV05fU1RST0tFLFxuICBQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEw6ICgpID0+IFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCxcbiAgUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFLFxuICBQQUxFVFRFX0FMVF9VUF9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9VUF9GSUxMLFxuICBQQUxFVFRFX0FMVF9VUF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfQUxUX1VQX1NUUk9LRSxcbiAgUEFMRVRURV9ET1dOX0ZJTEw6ICgpID0+IFBBTEVUVEVfRE9XTl9GSUxMLFxuICBQQUxFVFRFX0RPV05fU1RST0tFOiAoKSA9PiBQQUxFVFRFX0RPV05fU1RST0tFLFxuICBQQUxFVFRFX05FVVRSQUxfRklMTDogKCkgPT4gUEFMRVRURV9ORVVUUkFMX0ZJTEwsXG4gIFBBTEVUVEVfTkVVVFJBTF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gIFBBTEVUVEVfVVBfRklMTDogKCkgPT4gUEFMRVRURV9VUF9GSUxMLFxuICBQQUxFVFRFX1VQX1NUUk9LRTogKCkgPT4gUEFMRVRURV9VUF9TVFJPS0UsXG4gIFBPTEFSX0FYSVNfU0hBUEU6ICgpID0+IFBPTEFSX0FYSVNfU0hBUEUsXG4gIFBPTEFSX0FYSVNfVFlQRTogKCkgPT4gUE9MQVJfQVhJU19UWVBFLFxuICBQT1NJVElPTjogKCkgPT4gUE9TSVRJT04yLFxuICBnZXRDaGFydFRoZW1lOiAoKSA9PiBnZXRDaGFydFRoZW1lLFxuICBtYXJrZXJQYWxldHRlRmFjdG9yeTogKCkgPT4gbWFya2VyUGFsZXR0ZUZhY3RvcnksXG4gIHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5OiAoKSA9PiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeSxcbiAgdGhlbWVzOiAoKSA9PiB0aGVtZXMyXG59KTtcbnZhciB0aGVtZXMyID0gbWFwVmFsdWVzKFxuICB0aGVtZXMsXG4gICh0aGVtZUZhY3RvcnkpID0+IHRoZW1lRmFjdG9yeT8uKClcbik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NwYXJrbGluZXMtc2NhbGUudHNcbnZhciBzcGFya2xpbmVzX3NjYWxlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNwYXJrbGluZXNfc2NhbGVfZXhwb3J0cywge1xuICBCYW5kU2NhbGU6ICgpID0+IEJhbmRTY2FsZSxcbiAgQ29sb3JTY2FsZTogKCkgPT4gQ29sb3JTY2FsZSxcbiAgQ29udGludW91c1NjYWxlOiAoKSA9PiBDb250aW51b3VzU2NhbGUsXG4gIEludmFsaWRhdGluZzogKCkgPT4gSW52YWxpZGF0aW5nLFxuICBMaW5lYXJTY2FsZTogKCkgPT4gTGluZWFyU2NhbGUsXG4gIE9yZGluYWxUaW1lU2NhbGU6ICgpID0+IE9yZGluYWxUaW1lU2NhbGUsXG4gIFRpbWVTY2FsZTogKCkgPT4gVGltZVNjYWxlXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3BhcmtsaW5lcy11dGlsLnRzXG52YXIgc3BhcmtsaW5lc191dGlsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNwYXJrbGluZXNfdXRpbF9leHBvcnRzLCB7XG4gIENvbG9yOiAoKSA9PiBDb2xvcixcbiAgRGVidWc6ICgpID0+IERlYnVnLFxuICBMb2dnZXI6ICgpID0+IExvZ2dlcixcbiAgUGFkZGluZzogKCkgPT4gUGFkZGluZyxcbiAgVGltZUludGVydmFsOiAoKSA9PiBUaW1lSW50ZXJ2YWwsXG4gIFZlYzI6ICgpID0+IFZlYzIsXG4gIGFuZ2xlQmV0d2VlbjogKCkgPT4gYW5nbGVCZXR3ZWVuLFxuICBhbmdsZURpZmY6ICgpID0+IGFuZ2xlRGlmZixcbiAgYXJlQXJyYXlOdW1iZXJzRXF1YWw6ICgpID0+IGFyZUFycmF5TnVtYmVyc0VxdWFsLFxuICBiaWZ1cmNhdGU6ICgpID0+IGJpZnVyY2F0ZSxcbiAgY2hlY2tEYXR1bTogKCkgPT4gY2hlY2tEYXR1bSxcbiAgY2xhbXA6ICgpID0+IGNsYW1wLFxuICBjbGFtcEFycmF5OiAoKSA9PiBjbGFtcEFycmF5LFxuICBjb3VudEZyYWN0aW9uRGlnaXRzOiAoKSA9PiBjb3VudEZyYWN0aW9uRGlnaXRzLFxuICBjcmVhdGVJZDogKCkgPT4gY3JlYXRlSWQsXG4gIGRheTogKCkgPT4gZGF5LFxuICBkZWVwQ2xvbmU6ICgpID0+IGRlZXBDbG9uZSxcbiAgZGlzcGxhY2VQb2ludEZyb21WZWN0b3I6ICgpID0+IGRpc3BsYWNlUG9pbnRGcm9tVmVjdG9yLFxuICBleHRlbnQ6ICgpID0+IGV4dGVudCxcbiAgZmluZE1pbk1heDogKCkgPT4gZmluZE1pbk1heCxcbiAgZmluZFJhbmdlRXh0ZW50OiAoKSA9PiBmaW5kUmFuZ2VFeHRlbnQsXG4gIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZSxcbiAgZm9ybWF0UGVyY2VudGFnZTogKCkgPT4gZm9ybWF0UGVyY2VudGFnZSxcbiAgZnJpZGF5OiAoKSA9PiBmcmlkYXksXG4gIGhvdXI6ICgpID0+IGhvdXIsXG4gIGludGVycG9sYXRlQ29sb3I6ICgpID0+IGludGVycG9sYXRlQ29sb3IsXG4gIGludGVycG9sYXRlTnVtYmVyOiAoKSA9PiBpbnRlcnBvbGF0ZU51bWJlcixcbiAgaXNCZXR3ZWVuQW5nbGVzOiAoKSA9PiBpc0JldHdlZW5BbmdsZXMsXG4gIGlzQ29udGludW91czogKCkgPT4gaXNDb250aW51b3VzLFxuICBpc0RhdGU6ICgpID0+IGlzVmFsaWREYXRlLFxuICBpc0RlbnNlSW50ZXJ2YWw6ICgpID0+IGlzRGVuc2VJbnRlcnZhbCxcbiAgaXNFcXVhbDogKCkgPT4gaXNFcXVhbCxcbiAgaXNOZWdhdGl2ZTogKCkgPT4gaXNOZWdhdGl2ZSxcbiAgaXNOdW1iZXI6ICgpID0+IGlzRmluaXRlTnVtYmVyLFxuICBpc051bWJlckVxdWFsOiAoKSA9PiBpc0VxdWFsLFxuICBpc051bWJlck9iamVjdDogKCkgPT4gaXNOdW1iZXJPYmplY3QsXG4gIGlzU3RyaW5nOiAoKSA9PiBpc1N0cmluZyxcbiAgaXNTdHJpbmdPYmplY3Q6ICgpID0+IGlzU3RyaW5nT2JqZWN0LFxuICBqc29uQXBwbHk6ICgpID0+IGpzb25BcHBseSxcbiAganNvbkRpZmY6ICgpID0+IGpzb25EaWZmLFxuICBqc29uV2FsazogKCkgPT4ganNvbldhbGssXG4gIG1pbGxpc2Vjb25kOiAoKSA9PiBtaWxsaXNlY29uZCxcbiAgbWludXRlOiAoKSA9PiBtaW51dGUsXG4gIG1vZDogKCkgPT4gbW9kLFxuICBtb25kYXk6ICgpID0+IG1vbmRheSxcbiAgbW9udGg6ICgpID0+IG1vbnRoLFxuICBub3JtYWxpc2VkRXh0ZW50OiAoKSA9PiBub3JtYWxpc2VkRXh0ZW50LFxuICBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhOiAoKSA9PiBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhLFxuICBub3JtYWxpemVBbmdsZTE4MDogKCkgPT4gbm9ybWFsaXplQW5nbGUxODAsXG4gIG5vcm1hbGl6ZUFuZ2xlMzYwOiAoKSA9PiBub3JtYWxpemVBbmdsZTM2MCxcbiAgbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmU6ICgpID0+IG5vcm1hbGl6ZUFuZ2xlMzYwSW5jbHVzaXZlLFxuICByYW5nZTogKCkgPT4gcmFuZ2UsXG4gIHJlc2V0SWRzOiAoKSA9PiByZXNldElkcyxcbiAgcm91bmQ6ICgpID0+IHJvdW5kLFxuICBzYW5pdGl6ZUh0bWw6ICgpID0+IHNhbml0aXplSHRtbCxcbiAgc2F0dXJkYXk6ICgpID0+IHNhdHVyZGF5LFxuICBzZWNvbmQ6ICgpID0+IHNlY29uZCxcbiAgc2V0QXR0cmlidXRlOiAoKSA9PiBzZXRBdHRyaWJ1dGUsXG4gIHNldFZpc2liaWxpdHk6ICgpID0+IHNldFZpc2liaWxpdHksXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzdW5kYXk6ICgpID0+IHN1bmRheSxcbiAgdGh1cnNkYXk6ICgpID0+IHRodXJzZGF5LFxuICB0aWNrRm9ybWF0OiAoKSA9PiB0aWNrRm9ybWF0LFxuICB0aWNrU3RlcDogKCkgPT4gdGlja1N0ZXAsXG4gIHRpY2tzOiAoKSA9PiBjcmVhdGVUaWNrcyxcbiAgdG9EZWdyZWVzOiAoKSA9PiB0b0RlZ3JlZXMsXG4gIHRvRml4ZWQ6ICgpID0+IHRvRml4ZWQsXG4gIHRvUmFkaWFuczogKCkgPT4gdG9SYWRpYW5zLFxuICB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZTogKCkgPT4gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUsXG4gIHR1ZXNkYXk6ICgpID0+IHR1ZXNkYXksXG4gIHV0Y0RheTogKCkgPT4gdXRjRGF5LFxuICB1dGNIb3VyOiAoKSA9PiB1dGNIb3VyLFxuICB1dGNNaW51dGU6ICgpID0+IHV0Y01pbnV0ZSxcbiAgdXRjTW9udGg6ICgpID0+IHV0Y01vbnRoLFxuICB1dGNZZWFyOiAoKSA9PiB1dGNZZWFyLFxuICB1dWlkOiAoKSA9PiB1dWlkLFxuICB3ZWRuZXNkYXk6ICgpID0+IHdlZG5lc2RheSxcbiAgeWVhcjogKCkgPT4geWVhcixcbiAgemlwT2JqZWN0OiAoKSA9PiB6aXBPYmplY3Rcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZlY3Rvci50c1xudmFyIFZlYzIgPSB7XG4gIGFkZCxcbiAgYW5nbGUsXG4gIGFwcGx5LFxuICBlcXVhbCxcbiAgZGlzdGFuY2U6IGRpc3RhbmNlMixcbiAgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQyLFxuICBmcm9tLFxuICBmcm9tT2Zmc2V0LFxuICBsZW5ndGgsXG4gIGxlbmd0aFNxdWFyZWQsXG4gIHJlcXVpcmVkLFxuICByb3RhdGUsXG4gIHN1YlxufTtcbmZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiB7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH07XG59XG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xufVxuZnVuY3Rpb24gbGVuZ3RoU3F1YXJlZChhKSB7XG4gIHJldHVybiBhLnggKiBhLnggKyBhLnkgKiBhLnk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZTIoYSwgYikge1xuICBjb25zdCBkID0gc3ViKGEsIGIpO1xuICByZXR1cm4gTWF0aC5zcXJ0KGQueCAqIGQueCArIGQueSAqIGQueSk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZVNxdWFyZWQyKGEsIGIpIHtcbiAgY29uc3QgZCA9IHN1YihhLCBiKTtcbiAgcmV0dXJuIGQueCAqIGQueCArIGQueSAqIGQueTtcbn1cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoYS55LCBhLngpIC0gTWF0aC5hdGFuMihiLnksIGIueCk7XG59XG5mdW5jdGlvbiByb3RhdGUoYSwgdGhldGEsIGIgPSByZXF1aXJlZCgpKSB7XG4gIGNvbnN0IGwgPSBWZWMyLmxlbmd0aChhKTtcbiAgcmV0dXJuIHsgeDogYi54ICsgbCAqIE1hdGguY29zKHRoZXRhKSwgeTogYi55ICsgbCAqIE1hdGguc2luKHRoZXRhKSB9O1xufVxuZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG59XG5mdW5jdGlvbiBmcm9tKHgsIHkpIHtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuZnVuY3Rpb24gZnJvbU9mZnNldChhKSB7XG4gIHJldHVybiB7IHg6IGEub2Zmc2V0WCwgeTogYS5vZmZzZXRZIH07XG59XG5mdW5jdGlvbiBhcHBseShhLCBiKSB7XG4gIGEueCA9IGIueDtcbiAgYS55ID0gYi55O1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVkKGEpIHtcbiAgcmV0dXJuIHsgeDogYT8ueCA/PyAwLCB5OiBhPy55ID8/IDAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC96aXAudHNcbmZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgY29uc3QgemlwcGVkID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHppcHBlZFtgJHtrZXlzW2ldfWBdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHppcHBlZFtgJHtrZXlzW2ldfWBdID0gdmFsdWVzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gemlwcGVkO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUtc3VwcG9ydC50c1xudmFyIG1vZHVsZV9zdXBwb3J0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1vZHVsZV9zdXBwb3J0X2V4cG9ydHMsIHtcbiAgQU5EOiAoKSA9PiBBTkQsXG4gIEFSUkFZOiAoKSA9PiBBUlJBWSxcbiAgQVJSQVlfT0Y6ICgpID0+IEFSUkFZX09GLFxuICBBYnN0cmFjdEJhclNlcmllczogKCkgPT4gQWJzdHJhY3RCYXJTZXJpZXMsXG4gIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllczogKCkgPT4gQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzLFxuICBBY3Rpb25PblNldDogKCkgPT4gQWN0aW9uT25TZXQsXG4gIEFuaW1hdGlvbjogKCkgPT4gQW5pbWF0aW9uLFxuICBBbmltYXRpb25NYW5hZ2VyOiAoKSA9PiBBbmltYXRpb25NYW5hZ2VyLFxuICBBcmVhU2VyaWVzVGFnOiAoKSA9PiBBcmVhU2VyaWVzVGFnLFxuICBBeGlzOiAoKSA9PiBBeGlzLFxuICBBeGlzSW50ZXJ2YWw6ICgpID0+IEF4aXNJbnRlcnZhbCxcbiAgQXhpc0xhYmVsOiAoKSA9PiBBeGlzTGFiZWwsXG4gIEF4aXNUaWNrOiAoKSA9PiBBeGlzVGljayxcbiAgQXhpc1RpY2tzOiAoKSA9PiBBeGlzVGlja3MsXG4gIEJPT0xFQU46ICgpID0+IEJPT0xFQU4sXG4gIEJPT0xFQU5fQVJSQVk6ICgpID0+IEJPT0xFQU5fQVJSQVksXG4gIEJhY2tncm91bmQ6ICgpID0+IEJhY2tncm91bmQsXG4gIEJhY2tncm91bmRNb2R1bGU6ICgpID0+IEJhY2tncm91bmRNb2R1bGUsXG4gIEJhc2VNb2R1bGVJbnN0YW5jZTogKCkgPT4gQmFzZU1vZHVsZUluc3RhbmNlLFxuICBCYXNlUHJvcGVydGllczogKCkgPT4gQmFzZVByb3BlcnRpZXMsXG4gIENPTE9SX1NUUklORzogKCkgPT4gQ09MT1JfU1RSSU5HLFxuICBDT0xPUl9TVFJJTkdfQVJSQVk6ICgpID0+IENPTE9SX1NUUklOR19BUlJBWSxcbiAgQ2FjaGVkVGV4dE1lYXN1cmVyOiAoKSA9PiBDYWNoZWRUZXh0TWVhc3VyZXIsXG4gIENhY2hlZFRleHRNZWFzdXJlclBvb2w6ICgpID0+IENhY2hlZFRleHRNZWFzdXJlclBvb2wsXG4gIENhcnRlc2lhbkF4aXM6ICgpID0+IENhcnRlc2lhbkF4aXMsXG4gIENhcnRlc2lhblNlcmllczogKCkgPT4gQ2FydGVzaWFuU2VyaWVzLFxuICBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQ6ICgpID0+IENhcnRlc2lhblNlcmllc05vZGVFdmVudCxcbiAgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllczogKCkgPT4gQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyxcbiAgQ2F0ZWdvcnlBeGlzOiAoKSA9PiBDYXRlZ29yeUF4aXMsXG4gIENoYXJ0QXhpc0RpcmVjdGlvbjogKCkgPT4gQ2hhcnRBeGlzRGlyZWN0aW9uLFxuICBDaGFydEV2ZW50TWFuYWdlcjogKCkgPT4gQ2hhcnRFdmVudE1hbmFnZXIsXG4gIENoYXJ0T3B0aW9uczogKCkgPT4gQ2hhcnRPcHRpb25zLFxuICBDaGFydFVwZGF0ZVR5cGU6ICgpID0+IENoYXJ0VXBkYXRlVHlwZSxcbiAgQ29udGV4dE1lbnVSZWdpc3RyeTogKCkgPT4gQ29udGV4dE1lbnVSZWdpc3RyeSxcbiAgQ3Vyc29yOiAoKSA9PiBDdXJzb3IsXG4gIEN1cnNvck1hbmFnZXI6ICgpID0+IEN1cnNvck1hbmFnZXIsXG4gIERBVEU6ICgpID0+IERBVEUsXG4gIERBVEVfQVJSQVk6ICgpID0+IERBVEVfQVJSQVksXG4gIERBVEVfT1JfREFURVRJTUVfTVM6ICgpID0+IERBVEVfT1JfREFURVRJTUVfTVMsXG4gIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTOiAoKSA9PiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTOiAoKSA9PiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gIERFRkFVTFRfVE9PTFRJUF9DTEFTUzogKCkgPT4gREVGQVVMVF9UT09MVElQX0NMQVNTLFxuICBERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUzogKCkgPT4gREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1MsXG4gIERFR1JFRTogKCkgPT4gREVHUkVFLFxuICBESVJFQ1RJT046ICgpID0+IERJUkVDVElPTixcbiAgRE9NTWFuYWdlcjogKCkgPT4gRE9NTWFuYWdlcixcbiAgRGF0YUNvbnRyb2xsZXI6ICgpID0+IERhdGFDb250cm9sbGVyLFxuICBEYXRhTW9kZWw6ICgpID0+IERhdGFNb2RlbCxcbiAgRGF0YU1vZGVsU2VyaWVzOiAoKSA9PiBEYXRhTW9kZWxTZXJpZXMsXG4gIERhdGFTZXJ2aWNlOiAoKSA9PiBEYXRhU2VydmljZSxcbiAgRGVmYXVsdDogKCkgPT4gRGVmYXVsdCxcbiAgRGVwcmVjYXRlZDogKCkgPT4gRGVwcmVjYXRlZCxcbiAgRGVwcmVjYXRlZEFuZFJlbmFtZWRUbzogKCkgPT4gRGVwcmVjYXRlZEFuZFJlbmFtZWRUbyxcbiAgRU1QVFlfVE9PTFRJUF9DT05URU5UOiAoKSA9PiBFTVBUWV9UT09MVElQX0NPTlRFTlQsXG4gIEZPTlRfU1RZTEU6ICgpID0+IEZPTlRfU1RZTEUsXG4gIEZPTlRfV0VJR0hUOiAoKSA9PiBGT05UX1dFSUdIVCxcbiAgRlVOQ1RJT046ICgpID0+IEZVTkNUSU9OLFxuICBHUkVBVEVSX1RIQU46ICgpID0+IEdSRUFURVJfVEhBTixcbiAgR2VzdHVyZURldGVjdG9yOiAoKSA9PiBHZXN0dXJlRGV0ZWN0b3IsXG4gIEdyb3VwZWRDYXRlZ29yeUF4aXM6ICgpID0+IEdyb3VwZWRDYXRlZ29yeUF4aXMsXG4gIEhpZXJhcmNoeU5vZGU6ICgpID0+IEhpZXJhcmNoeU5vZGUsXG4gIEhpZXJhcmNoeVNlcmllczogKCkgPT4gSGllcmFyY2h5U2VyaWVzLFxuICBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLFxuICBIaWdobGlnaHRNYW5hZ2VyOiAoKSA9PiBIaWdobGlnaHRNYW5hZ2VyLFxuICBIaWdobGlnaHRQcm9wZXJ0aWVzOiAoKSA9PiBIaWdobGlnaHRQcm9wZXJ0aWVzLFxuICBIaWdobGlnaHRTdHlsZTogKCkgPT4gSGlnaGxpZ2h0U3R5bGUsXG4gIElOVEVSQUNUSU9OX1JBTkdFOiAoKSA9PiBJTlRFUkFDVElPTl9SQU5HRSxcbiAgSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OOiAoKSA9PiBJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT04sXG4gIElOVEVSUE9MQVRJT05fVFlQRTogKCkgPT4gSU5URVJQT0xBVElPTl9UWVBFLFxuICBJbnRlcmFjdGlvbk1hbmFnZXI6ICgpID0+IEludGVyYWN0aW9uTWFuYWdlcixcbiAgSW50ZXJhY3Rpb25TdGF0ZTogKCkgPT4gSW50ZXJhY3Rpb25TdGF0ZSxcbiAgSW50ZXJwb2xhdGlvblByb3BlcnRpZXM6ICgpID0+IEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLFxuICBLZXlOYXZNYW5hZ2VyOiAoKSA9PiBLZXlOYXZNYW5hZ2VyLFxuICBMQUJFTF9QTEFDRU1FTlQ6ICgpID0+IExBQkVMX1BMQUNFTUVOVCxcbiAgTEFSR0VTVF9LRVlfSU5URVJWQUw6ICgpID0+IExBUkdFU1RfS0VZX0lOVEVSVkFMLFxuICBMRVNTX1RIQU46ICgpID0+IExFU1NfVEhBTixcbiAgTElORV9DQVA6ICgpID0+IExJTkVfQ0FQLFxuICBMSU5FX0RBU0g6ICgpID0+IExJTkVfREFTSCxcbiAgTElORV9KT0lOOiAoKSA9PiBMSU5FX0pPSU4sXG4gIExheWVyczogKCkgPT4gTGF5ZXJzLFxuICBMYXlvdXRTZXJ2aWNlOiAoKSA9PiBMYXlvdXRTZXJ2aWNlLFxuICBMb25MYXRCQm94OiAoKSA9PiBMb25MYXRCQm94LFxuICBNQVJLRVJfU0hBUEU6ICgpID0+IE1BUktFUl9TSEFQRSxcbiAgTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEU6ICgpID0+IE1BVENISU5HX0NST1NTTElORV9UWVBFLFxuICBNQVhfU1BBQ0lORzogKCkgPT4gTUFYX1NQQUNJTkcsXG4gIE1JTl9TUEFDSU5HOiAoKSA9PiBNSU5fU1BBQ0lORyxcbiAgTWVyY2F0b3JTY2FsZTogKCkgPT4gTWVyY2F0b3JTY2FsZSxcbiAgTW9kdWxlUmVnaXN0cnk6ICgpID0+IE1vZHVsZVJlZ2lzdHJ5LFxuICBNb3Rpb246ICgpID0+IGVhc2luZ19leHBvcnRzLFxuICBOQU46ICgpID0+IE5BTixcbiAgTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORzogKCkgPT4gTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORyxcbiAgTlVNQkVSOiAoKSA9PiBOVU1CRVIsXG4gIE5VTUJFUl9BUlJBWTogKCkgPT4gTlVNQkVSX0FSUkFZLFxuICBOVU1CRVJfT1JfTkFOOiAoKSA9PiBOVU1CRVJfT1JfTkFOLFxuICBOYXZpZ2F0b3I6ICgpID0+IE5hdmlnYXRvcixcbiAgTmF2aWdhdG9yTW9kdWxlOiAoKSA9PiBOYXZpZ2F0b3JNb2R1bGUsXG4gIE9CSkVDVDogKCkgPT4gT0JKRUNULFxuICBPQkpFQ1RfQVJSQVk6ICgpID0+IE9CSkVDVF9BUlJBWSxcbiAgT1I6ICgpID0+IE9SLFxuICBPVkVSRkxPV19TVFJBVEVHWTogKCkgPT4gT1ZFUkZMT1dfU1RSQVRFR1ksXG4gIE9ic2VydmVDaGFuZ2VzOiAoKSA9PiBPYnNlcnZlQ2hhbmdlcyxcbiAgUEhBU0VfTUVUQURBVEE6ICgpID0+IFBIQVNFX01FVEFEQVRBLFxuICBQSEFTRV9PUkRFUjogKCkgPT4gUEhBU0VfT1JERVIsXG4gIFBMQUNFTUVOVDogKCkgPT4gUExBQ0VNRU5ULFxuICBQTEFJTl9PQkpFQ1Q6ICgpID0+IFBMQUlOX09CSkVDVCxcbiAgUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUzogKCkgPT4gUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUyxcbiAgUE9TSVRJT046ICgpID0+IFBPU0lUSU9OLFxuICBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVM6ICgpID0+IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyxcbiAgUE9TSVRJVkVfTlVNQkVSOiAoKSA9PiBQT1NJVElWRV9OVU1CRVIsXG4gIFBvbGFyQXhpczogKCkgPT4gUG9sYXJBeGlzLFxuICBQb2xhclNlcmllczogKCkgPT4gUG9sYXJTZXJpZXMsXG4gIFByb3BlcnRpZXNBcnJheTogKCkgPT4gUHJvcGVydGllc0FycmF5LFxuICBQcm94eU9uV3JpdGU6ICgpID0+IFByb3h5T25Xcml0ZSxcbiAgUHJveHlQcm9wZXJ0eTogKCkgPT4gUHJveHlQcm9wZXJ0eSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGU6ICgpID0+IFByb3h5UHJvcGVydHlPbldyaXRlLFxuICBRVUlDS19UUkFOU0lUSU9OOiAoKSA9PiBRVUlDS19UUkFOU0lUSU9OLFxuICBSQVRJTzogKCkgPT4gUkFUSU8sXG4gIFJFR0lPTlM6ICgpID0+IFJFR0lPTlMsXG4gIFJlZ2lvbk1hbmFnZXI6ICgpID0+IFJlZ2lvbk1hbmFnZXIsXG4gIFJlcGVhdFR5cGU6ICgpID0+IFJlcGVhdFR5cGUsXG4gIFNLSVBfSlNfQlVJTFRJTlM6ICgpID0+IFNLSVBfSlNfQlVJTFRJTlMsXG4gIFNNQUxMRVNUX0tFWV9JTlRFUlZBTDogKCkgPT4gU01BTExFU1RfS0VZX0lOVEVSVkFMLFxuICBTT1JUX0RPTUFJTl9HUk9VUFM6ICgpID0+IFNPUlRfRE9NQUlOX0dST1VQUyxcbiAgU1RSSU5HOiAoKSA9PiBTVFJJTkcsXG4gIFNUUklOR19BUlJBWTogKCkgPT4gU1RSSU5HX0FSUkFZLFxuICBTZXJpZXM6ICgpID0+IFNlcmllcyxcbiAgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQ6ICgpID0+IFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50LFxuICBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGU6ICgpID0+IFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSxcbiAgU2VyaWVzTWFya2VyOiAoKSA9PiBTZXJpZXNNYXJrZXIsXG4gIFNlcmllc05vZGVFdmVudDogKCkgPT4gU2VyaWVzTm9kZUV2ZW50LFxuICBTZXJpZXNOb2RlUGlja01vZGU6ICgpID0+IFNlcmllc05vZGVQaWNrTW9kZSxcbiAgU2VyaWVzUHJvcGVydGllczogKCkgPT4gU2VyaWVzUHJvcGVydGllcyxcbiAgU2VyaWVzVG9vbHRpcDogKCkgPT4gU2VyaWVzVG9vbHRpcCxcbiAgU2ltcGxlVGV4dE1lYXN1cmVyOiAoKSA9PiBTaW1wbGVUZXh0TWVhc3VyZXIsXG4gIFN0YXRlTWFjaGluZTogKCkgPT4gU3RhdGVNYWNoaW5lLFxuICBURVhUX0FMSUdOOiAoKSA9PiBURVhUX0FMSUdOLFxuICBURVhUX1dSQVA6ICgpID0+IFRFWFRfV1JBUCxcbiAgVElDS19JTlRFUlZBTDogKCkgPT4gVElDS19JTlRFUlZBTCxcbiAgVGV4dFV0aWxzOiAoKSA9PiBUZXh0VXRpbHMsXG4gIFRleHRXcmFwcGVyOiAoKSA9PiBUZXh0V3JhcHBlcixcbiAgVG9vbGJhck1hbmFnZXI6ICgpID0+IFRvb2xiYXJNYW5hZ2VyLFxuICBUb29sdGlwOiAoKSA9PiBUb29sdGlwLFxuICBUb29sdGlwTWFuYWdlcjogKCkgPT4gVG9vbHRpcE1hbmFnZXIsXG4gIFRvb2x0aXBQb3NpdGlvbjogKCkgPT4gVG9vbHRpcFBvc2l0aW9uLFxuICBVTklPTjogKCkgPT4gVU5JT04sXG4gIFVwZGF0ZVNlcnZpY2U6ICgpID0+IFVwZGF0ZVNlcnZpY2UsXG4gIFZFUlRJQ0FMX0FMSUdOOiAoKSA9PiBWRVJUSUNBTF9BTElHTixcbiAgVmFsaWRhdGU6ICgpID0+IFZhbGlkYXRlLFxuICBab29tTWFuYWdlcjogKCkgPT4gWm9vbU1hbmFnZXIsXG4gIF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTjogKCkgPT4gX19GT1JDRV9NT0RVTEVfREVURUNUSU9OLFxuICBhY2N1bXVsYXRlR3JvdXA6ICgpID0+IGFjY3VtdWxhdGVHcm91cCxcbiAgYWNjdW11bGF0ZVN0YWNrOiAoKSA9PiBhY2N1bXVsYXRlU3RhY2ssXG4gIGFjY3VtdWxhdGVkVmFsdWU6ICgpID0+IGFjY3VtdWxhdGVkVmFsdWUsXG4gIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHk6ICgpID0+IGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHksXG4gIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlOiAoKSA9PiBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZSxcbiAgYWRqdXN0TGFiZWxQbGFjZW1lbnQ6ICgpID0+IGFkanVzdExhYmVsUGxhY2VtZW50LFxuICBhbGxJblN0cmluZ1VuaW9uOiAoKSA9PiBhbGxJblN0cmluZ1VuaW9uLFxuICBhbmltYXRpb25WYWxpZGF0aW9uOiAoKSA9PiBhbmltYXRpb25WYWxpZGF0aW9uLFxuICBhcmVhOiAoKSA9PiBhcmVhLFxuICBhcnJheXNFcXVhbDogKCkgPT4gYXJyYXlzRXF1YWwsXG4gIGJhY2tmaWxsUGF0aFBvaW50RGF0YTogKCkgPT4gYmFja2ZpbGxQYXRoUG9pbnREYXRhLFxuICBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbjogKCkgPT4gYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb24sXG4gIGJpZnVyY2F0ZTogKCkgPT4gYmlmdXJjYXRlLFxuICBidWlsZEZvcm1hdHRlcjogKCkgPT4gYnVpbGRGb3JtYXR0ZXIsXG4gIGJ1aWxkUmVzZXRQYXRoRm46ICgpID0+IGJ1aWxkUmVzZXRQYXRoRm4sXG4gIGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdDogKCkgPT4gY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0LFxuICBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZzogKCkgPT4gY2FsY3VsYXRlTGFiZWxDaGFydFBhZGRpbmcsXG4gIGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb246ICgpID0+IGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb24sXG4gIGNhbGN1bGF0ZVBsYWNlbWVudDogKCkgPT4gY2FsY3VsYXRlUGxhY2VtZW50LFxuICBjaGVja0NyaXNwOiAoKSA9PiBjaGVja0NyaXNwLFxuICBjaGlsZHJlbkl0ZXI6ICgpID0+IGNoaWxkcmVuSXRlcixcbiAgY2lyY3VsYXJTbGljZUFycmF5OiAoKSA9PiBjaXJjdWxhclNsaWNlQXJyYXksXG4gIGNsYW1wOiAoKSA9PiBjbGFtcCxcbiAgY2xhbXBBcnJheTogKCkgPT4gY2xhbXBBcnJheSxcbiAgY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbjogKCkgPT4gY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbixcbiAgY29tcHV0ZUJhckZvY3VzQm91bmRzOiAoKSA9PiBjb21wdXRlQmFyRm9jdXNCb3VuZHMsXG4gIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kczogKCkgPT4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzLFxuICBjb252ZXJ0VmFsdWVzVG9TY2FsZUJ5RGVmczogKCkgPT4gY29udmVydFZhbHVlc1RvU2NhbGVCeURlZnMsXG4gIGNvdW50RnJhY3Rpb25EaWdpdHM6ICgpID0+IGNvdW50RnJhY3Rpb25EaWdpdHMsXG4gIGNyZWF0ZURhdHVtSWQ6ICgpID0+IGNyZWF0ZURhdHVtSWQsXG4gIGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZzogKCkgPT4gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nLFxuICBjcmVhdGVFbGVtZW50OiAoKSA9PiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVFbGVtZW50TlM6ICgpID0+IGNyZWF0ZUVsZW1lbnROUyxcbiAgZGF0ZVRvTnVtYmVyOiAoKSA9PiBkYXRlVG9OdW1iZXIsXG4gIGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXM6ICgpID0+IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMsXG4gIGRlZXBDbG9uZTogKCkgPT4gZGVlcENsb25lLFxuICBkZWVwTWVyZ2U6ICgpID0+IGRlZXBNZXJnZSxcbiAgZGVmYXVsdFRpbWVUaWNrRm9ybWF0OiAoKSA9PiBkZWZhdWx0VGltZVRpY2tGb3JtYXQsXG4gIGRldGVybWluZVBhdGhTdGF0dXM6ICgpID0+IGRldGVybWluZVBhdGhTdGF0dXMsXG4gIGRpZmY6ICgpID0+IGRpZmYsXG4gIGRvd25sb2FkVXJsOiAoKSA9PiBkb3dubG9hZFVybCxcbiAgZW50ZXJwcmlzZU1vZHVsZTogKCkgPT4gZW50ZXJwcmlzZU1vZHVsZSxcbiAgZXh0ZW50OiAoKSA9PiBleHRlbnQsXG4gIGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzOiAoKSA9PiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydGllcyxcbiAgZmluZE1heFZhbHVlOiAoKSA9PiBmaW5kTWF4VmFsdWUsXG4gIGZpbmRNaW5NYXg6ICgpID0+IGZpbmRNaW5NYXgsXG4gIGZpbmRRdWFkdHJlZU1hdGNoOiAoKSA9PiBmaW5kUXVhZHRyZWVNYXRjaCxcbiAgZmluZFJhbmdlRXh0ZW50OiAoKSA9PiBmaW5kUmFuZ2VFeHRlbnQsXG4gIGZpeE51bWVyaWNFeHRlbnQ6ICgpID0+IGZpeE51bWVyaWNFeHRlbnQsXG4gIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZSxcbiAgZm9ybWF0UGVyY2VudGFnZTogKCkgPT4gZm9ybWF0UGVyY2VudGFnZSxcbiAgZnJvbVRvTW90aW9uOiAoKSA9PiBmcm9tVG9Nb3Rpb24sXG4gIGdldERvY3VtZW50OiAoKSA9PiBnZXREb2N1bWVudCxcbiAgZ2V0TWlzc0NvdW50OiAoKSA9PiBnZXRNaXNzQ291bnQsXG4gIGdldFBhdGg6ICgpID0+IGdldFBhdGgsXG4gIGdldFBhdGhDb21wb25lbnRzOiAoKSA9PiBnZXRQYXRoQ29tcG9uZW50cyxcbiAgZ2V0UmVjdENvbmZpZzogKCkgPT4gZ2V0UmVjdENvbmZpZyxcbiAgZ2V0V2luZG93OiAoKSA9PiBnZXRXaW5kb3csXG4gIGdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eTogKCkgPT4gZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5LFxuICBncm91cEF2ZXJhZ2U6ICgpID0+IGdyb3VwQXZlcmFnZSxcbiAgZ3JvdXBCeTogKCkgPT4gZ3JvdXBCeSxcbiAgZ3JvdXBDb3VudDogKCkgPT4gZ3JvdXBDb3VudCxcbiAgZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHk6ICgpID0+IGdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5LFxuICBncm91cFN1bTogKCkgPT4gZ3JvdXBTdW0sXG4gIGluaXRNZW51S2V5TmF2OiAoKSA9PiBpbml0TWVudUtleU5hdixcbiAgaW5pdFRvb2xiYXJLZXlOYXY6ICgpID0+IGluaXRUb29sYmFyS2V5TmF2LFxuICBpc0FycmF5OiAoKSA9PiBpc0FycmF5LFxuICBpc0Jvb2xlYW46ICgpID0+IGlzQm9vbGVhbixcbiAgaXNEYXRlOiAoKSA9PiBpc0RhdGUsXG4gIGlzRGVjb3JhdGVkT2JqZWN0OiAoKSA9PiBpc0RlY29yYXRlZE9iamVjdCxcbiAgaXNEZWZpbmVkOiAoKSA9PiBpc0RlZmluZWQsXG4gIGlzRW51bUtleTogKCkgPT4gaXNFbnVtS2V5LFxuICBpc0VudW1WYWx1ZTogKCkgPT4gaXNFbnVtVmFsdWUsXG4gIGlzRXF1YWw6ICgpID0+IGlzRXF1YWwsXG4gIGlzRmluaXRlTnVtYmVyOiAoKSA9PiBpc0Zpbml0ZU51bWJlcixcbiAgaXNGdW5jdGlvbjogKCkgPT4gaXNGdW5jdGlvbixcbiAgaXNIdG1sRWxlbWVudDogKCkgPT4gaXNIdG1sRWxlbWVudCxcbiAgaXNOZWdhdGl2ZTogKCkgPT4gaXNOZWdhdGl2ZSxcbiAgaXNOdW1iZXI6ICgpID0+IGlzTnVtYmVyLFxuICBpc09iamVjdDogKCkgPT4gaXNPYmplY3QsXG4gIGlzT2JqZWN0TGlrZTogKCkgPT4gaXNPYmplY3RMaWtlLFxuICBpc1BsYWluT2JqZWN0OiAoKSA9PiBpc1BsYWluT2JqZWN0LFxuICBpc1Byb3BlcnRpZXM6ICgpID0+IGlzUHJvcGVydGllcyxcbiAgaXNSZWdFeHA6ICgpID0+IGlzUmVnRXhwLFxuICBpc1N0cmluZzogKCkgPT4gaXNTdHJpbmcsXG4gIGlzU3ltYm9sOiAoKSA9PiBpc1N5bWJvbCxcbiAgaXNWYWxpZERhdGU6ICgpID0+IGlzVmFsaWREYXRlLFxuICBqc29uQXBwbHk6ICgpID0+IGpzb25BcHBseSxcbiAganNvbkRpZmY6ICgpID0+IGpzb25EaWZmLFxuICBqc29uV2FsazogKCkgPT4ganNvbldhbGssXG4gIGtleVByb3BlcnR5OiAoKSA9PiBrZXlQcm9wZXJ0eSxcbiAgbGFiZWxEaXJlY3Rpb25IYW5kbGluZzogKCkgPT4gbGFiZWxEaXJlY3Rpb25IYW5kbGluZyxcbiAgbGlzdERlY29yYXRlZFByb3BlcnRpZXM6ICgpID0+IGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzLFxuICBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXI6ICgpID0+IG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcixcbiAgbWFwSXRlcmFibGU6ICgpID0+IG1hcEl0ZXJhYmxlLFxuICBtYXBWYWx1ZXM6ICgpID0+IG1hcFZhbHVlcyxcbiAgbWFya2VyRmFkZUluQW5pbWF0aW9uOiAoKSA9PiBtYXJrZXJGYWRlSW5BbmltYXRpb24sXG4gIG1hcmtlclBhbGV0dGVGYWN0b3J5OiAoKSA9PiBtYXJrZXJQYWxldHRlRmFjdG9yeSxcbiAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyU2NhbGVJbkFuaW1hdGlvbixcbiAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uOiAoKSA9PiBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24sXG4gIG1lcmdlQXJyYXlEZWZhdWx0czogKCkgPT4gbWVyZ2VBcnJheURlZmF1bHRzLFxuICBtZXJnZURlZmF1bHRzOiAoKSA9PiBtZXJnZURlZmF1bHRzLFxuICBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb246ICgpID0+IG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbixcbiAgbWluTWF4OiAoKSA9PiBtaW5NYXgsXG4gIG1vZDogKCkgPT4gbW9kLFxuICBtb2R1bGVSZWdpc3RyeTogKCkgPT4gbW9kdWxlUmVnaXN0cnksXG4gIG5lYXJlc3RTcXVhcmVkOiAoKSA9PiBuZWFyZXN0U3F1YXJlZCxcbiAgbmVhcmVzdFNxdWFyZWRJbkNvbnRhaW5lcjogKCkgPT4gbmVhcmVzdFNxdWFyZWRJbkNvbnRhaW5lcixcbiAgbm9ybWFsaXNlR3JvdXBUbzogKCkgPT4gbm9ybWFsaXNlR3JvdXBUbyxcbiAgbm9ybWFsaXNlUHJvcGVydHlUbzogKCkgPT4gbm9ybWFsaXNlUHJvcGVydHlUbyxcbiAgbm9ybWFsaXNlZEV4dGVudDogKCkgPT4gbm9ybWFsaXNlZEV4dGVudCxcbiAgbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YTogKCkgPT4gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YSxcbiAgcGFpckNhdGVnb3J5RGF0YTogKCkgPT4gcGFpckNhdGVnb3J5RGF0YSxcbiAgcGFpckNvbnRpbnVvdXNEYXRhOiAoKSA9PiBwYWlyQ29udGludW91c0RhdGEsXG4gIHBhcnRpYWxBc3NpZ246ICgpID0+IHBhcnRpYWxBc3NpZ24sXG4gIHBhdGhGYWRlSW5BbmltYXRpb246ICgpID0+IHBhdGhGYWRlSW5BbmltYXRpb24sXG4gIHBhdGhGYWRlT3V0QW5pbWF0aW9uOiAoKSA9PiBwYXRoRmFkZU91dEFuaW1hdGlvbixcbiAgcGF0aFJhbmdlUG9pbnRzOiAoKSA9PiBwYXRoUmFuZ2VQb2ludHMsXG4gIHBhdGhSYW5nZVBvaW50c1JldmVyc2U6ICgpID0+IHBhdGhSYW5nZVBvaW50c1JldmVyc2UsXG4gIHBhdGhSYW5nZXM6ICgpID0+IHBhdGhSYW5nZXMsXG4gIHBhdGhTd2lwZUluQW5pbWF0aW9uOiAoKSA9PiBwYXRoU3dpcGVJbkFuaW1hdGlvbixcbiAgcGlja0J5TWF0Y2hpbmdBbmdsZTogKCkgPT4gcGlja0J5TWF0Y2hpbmdBbmdsZSxcbiAgcGlja05vZGU6ICgpID0+IHBpY2tOb2RlLFxuICBwbG90UGF0aDogKCkgPT4gcGxvdFBhdGgsXG4gIHByZWRpY2F0ZVdpdGhNZXNzYWdlOiAoKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZSxcbiAgcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uOiAoKSA9PiBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24sXG4gIHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dDogKCkgPT4gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0LFxuICBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9uczogKCkgPT4gcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnMsXG4gIHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnM6ICgpID0+IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMsXG4gIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uLFxuICBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnM6ICgpID0+IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyxcbiAgcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb246ICgpID0+IHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uLFxuICBwcmVwYXJlTWFya2VyQW5pbWF0aW9uOiAoKSA9PiBwcmVwYXJlTWFya2VyQW5pbWF0aW9uLFxuICBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zOiAoKSA9PiBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zLFxuICByYW5nZTogKCkgPT4gcmFuZ2UyLFxuICByYW5nZWRWYWx1ZVByb3BlcnR5OiAoKSA9PiByYW5nZWRWYWx1ZVByb3BlcnR5LFxuICByZW5kZXJQYXJ0aWFsUGF0aDogKCkgPT4gcmVuZGVyUGFydGlhbFBhdGgsXG4gIHJlc2V0QXhpc0dyb3VwRm46ICgpID0+IHJlc2V0QXhpc0dyb3VwRm4sXG4gIHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm4sXG4gIHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbjogKCkgPT4gcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuLFxuICByZXNldEF4aXNTZWxlY3Rpb25GbjogKCkgPT4gcmVzZXRBeGlzU2VsZWN0aW9uRm4sXG4gIHJlc2V0QmFyU2VsZWN0aW9uc0ZuOiAoKSA9PiByZXNldEJhclNlbGVjdGlvbnNGbixcbiAgcmVzZXRJZHM6ICgpID0+IHJlc2V0SWRzLFxuICByZXNldExhYmVsRm46ICgpID0+IHJlc2V0TGFiZWxGbixcbiAgcmVzZXRNYXJrZXJGbjogKCkgPT4gcmVzZXRNYXJrZXJGbixcbiAgcmVzZXRNYXJrZXJQb3NpdGlvbkZuOiAoKSA9PiByZXNldE1hcmtlclBvc2l0aW9uRm4sXG4gIHJlc2V0TW90aW9uOiAoKSA9PiByZXNldE1vdGlvbixcbiAgcmVzZXRQaWVTZWxlY3Rpb25zRm46ICgpID0+IHJlc2V0UGllU2VsZWN0aW9uc0ZuLFxuICByb3VuZDogKCkgPT4gcm91bmQsXG4gIHNjYWxlOiAoKSA9PiBzY2FsZSxcbiAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb246ICgpID0+IHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uLFxuICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb246ICgpID0+IHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbixcbiAgc2V0RG9jdW1lbnQ6ICgpID0+IHNldERvY3VtZW50LFxuICBzZXRFbGVtZW50QkJveDogKCkgPT4gc2V0RWxlbWVudEJCb3gsXG4gIHNldFBhdGg6ICgpID0+IHNldFBhdGgsXG4gIHNldFdpbmRvdzogKCkgPT4gc2V0V2luZG93LFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnk6ICgpID0+IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5LFxuICBzcGxpdFBhaXJEYXRhOiAoKSA9PiBzcGxpdFBhaXJEYXRhLFxuICBzdGF0aWNGcm9tVG9Nb3Rpb246ICgpID0+IHN0YXRpY0Zyb21Ub01vdGlvbixcbiAgc3RyaW5naWZ5OiAoKSA9PiBzdHJpbmdpZnksXG4gIHN1bTogKCkgPT4gc3VtLFxuICBzdW1WYWx1ZXM6ICgpID0+IHN1bVZhbHVlcyxcbiAgdGltZXM6ICgpID0+IHRpbWVzLFxuICB0b0FycmF5OiAoKSA9PiB0b0FycmF5LFxuICB0b0ZpeGVkOiAoKSA9PiB0b0ZpeGVkLFxuICB0b1Rvb2x0aXBIdG1sOiAoKSA9PiB0b1Rvb2x0aXBIdG1sLFxuICB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWU6ICgpID0+IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSxcbiAgdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHk6ICgpID0+IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5LFxuICB1bmlxdWU6ICgpID0+IHVuaXF1ZSxcbiAgdXBkYXRlQ2xpcFBhdGg6ICgpID0+IHVwZGF0ZUNsaXBQYXRoLFxuICB1cGRhdGVMYWJlbE5vZGU6ICgpID0+IHVwZGF0ZUxhYmVsTm9kZSxcbiAgdXBkYXRlUmVjdDogKCkgPT4gdXBkYXRlUmVjdCxcbiAgdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXM6ICgpID0+IHZhbGlkYXRlQ3Jvc3NMaW5lVmFsdWVzLFxuICB2YWx1ZVByb3BlcnR5OiAoKSA9PiB2YWx1ZVByb3BlcnR5LFxuICB3aXRob3V0OiAoKSA9PiB3aXRob3V0XG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZXByZWNhdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICByZXR1cm4gKGtleSwgbWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IG1zZyA9IFtgUHJvcGVydHkgWyR7a2V5fV0gaXMgZGVwcmVjYXRlZC5gLCBtZXNzYWdlXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gICAgTG9nZ2VyLndhcm5PbmNlKG1zZyk7XG4gIH07XG59XG5mdW5jdGlvbiBEZXByZWNhdGVkKG1lc3NhZ2UsIG9wdHMpIHtcbiAgY29uc3Qgd2FybkRlcHJlY2F0ZWQgPSBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKTtcbiAgY29uc3QgZGVmID0gb3B0cz8uZGVmYXVsdDtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgoXywga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSAhPT0gZGVmKSB7XG4gICAgICB3YXJuRGVwcmVjYXRlZChrZXkudG9TdHJpbmcoKSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBEZXByZWNhdGVkQW5kUmVuYW1lZFRvKG5ld1Byb3BOYW1lLCBtYXBWYWx1ZSkge1xuICBjb25zdCB3YXJuRGVwcmVjYXRlZCA9IGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZygpO1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdGFyZ2V0W25ld1Byb3BOYW1lXSkge1xuICAgICAgICB3YXJuRGVwcmVjYXRlZChrZXkudG9TdHJpbmcoKSwgYFVzZSBbJHtuZXdQcm9wTmFtZX1dIGluc3RlYWQuYCk7XG4gICAgICAgIHNldFBhdGgodGFyZ2V0LCBuZXdQcm9wTmFtZSwgbWFwVmFsdWUgPyBtYXBWYWx1ZSh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQlJFQUtfVFJBTlNGT1JNX0NIQUlOO1xuICAgIH0sXG4gICAgKHRhcmdldCwga2V5KSA9PiB7XG4gICAgICB3YXJuRGVwcmVjYXRlZChrZXkudG9TdHJpbmcoKSwgYFVzZSBbJHtuZXdQcm9wTmFtZX1dIGluc3RlYWQuYCk7XG4gICAgICByZXR1cm4gZ2V0UGF0aCh0YXJnZXQsIG5ld1Byb3BOYW1lKTtcbiAgICB9XG4gICk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2VhcmNoLnV0aWwudHNcbmZ1bmN0aW9uIGZpbmRNYXhWYWx1ZShtaW4sIG1heCwgaXRlcmF0ZWUpIHtcbiAgaWYgKG1pbiA+IG1heClcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZDtcbiAgd2hpbGUgKG1heCA+PSBtaW4pIHtcbiAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IoKG1heCArIG1pbikgLyAyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbWF4ID0gaW5kZXggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgbWluID0gaW5kZXggKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9oaWVyYXJjaHkvaGllcmFyY2h5U2VyaWVzLnRzXG52YXIgX0hpZXJhcmNoeU5vZGUgPSBjbGFzcyBfSGllcmFyY2h5Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHNlcmllcywgaW5kZXgsIGRhdHVtLCBzaXplLCBjb2xvclZhbHVlLCBmaWxsLCBzdHJva2UsIHN1bVNpemUsIGRlcHRoLCBwYXJlbnQsIGNoaWxkcmVuKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuY29sb3JWYWx1ZSA9IGNvbG9yVmFsdWU7XG4gICAgdGhpcy5maWxsID0gZmlsbDtcbiAgICB0aGlzLnN0cm9rZSA9IHN0cm9rZTtcbiAgICB0aGlzLnN1bVNpemUgPSBzdW1TaXplO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5taWRQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGNvbnRhaW5zKG90aGVyKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBvdGhlcjtcbiAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQuaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB3YWxrKGNhbGxiYWNrMiwgb3JkZXIgPSBfSGllcmFyY2h5Tm9kZS5XYWxrLlByZU9yZGVyKSB7XG4gICAgaWYgKG9yZGVyID09PSBfSGllcmFyY2h5Tm9kZS5XYWxrLlByZU9yZGVyKSB7XG4gICAgICBjYWxsYmFjazIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLndhbGsoY2FsbGJhY2syLCBvcmRlcik7XG4gICAgfSk7XG4gICAgaWYgKG9yZGVyID09PSBfSGllcmFyY2h5Tm9kZS5XYWxrLlBvc3RPcmRlcikge1xuICAgICAgY2FsbGJhY2syKHRoaXMpO1xuICAgIH1cbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQgdGhpcztcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHlpZWxkKiBjaGlsZDtcbiAgICB9XG4gIH1cbn07XG5fSGllcmFyY2h5Tm9kZS5XYWxrID0ge1xuICBQcmVPcmRlcjogMCxcbiAgUG9zdE9yZGVyOiAxXG59O1xudmFyIEhpZXJhcmNoeU5vZGUgPSBfSGllcmFyY2h5Tm9kZTtcbnZhciBIaWVyYXJjaHlTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIHBpY2tNb2RlczogWzMgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWw6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yb290Tm9kZSA9IG5ldyBIaWVyYXJjaHlOb2RlKFxuICAgICAgdGhpcyxcbiAgICAgIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIFtdXG4gICAgKTtcbiAgICB0aGlzLmNvbG9yRG9tYWluID0gWzAsIDBdO1xuICAgIHRoaXMubWF4RGVwdGggPSAwO1xuICAgIHRoaXMuZm9jdXNQYXRoID0gW107XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXG4gICAgICBcImVtcHR5XCIsXG4gICAgICB7XG4gICAgICAgIGVtcHR5OiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgdXBkYXRlRGF0YTogXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgY2xlYXI6IFwiY2xlYXJpbmdcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcbiAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbktleSwgc2l6ZUtleSwgY29sb3JLZXksIGZpbGxzLCBzdHJva2VzLCBjb2xvclJhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBnZXRJbmRleCA9ICgpID0+IHtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBsZXQgbWF4RGVwdGggPSAwO1xuICAgIGxldCBtaW5Db2xvciA9IEluZmluaXR5O1xuICAgIGxldCBtYXhDb2xvciA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgQXJyYXkoKHRoaXMuZGF0YT8ubGVuZ3RoID8/IDApICsgMSkuZmlsbCh2b2lkIDApO1xuICAgIGNvbnN0IGNyZWF0ZU5vZGUgPSAoZGF0dW0sIHBhcmVudCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICAgIGNvbnN0IGRlcHRoID0gcGFyZW50LmRlcHRoICE9IG51bGwgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW5LZXkgIT0gbnVsbCA/IGRhdHVtW2NoaWxkcmVuS2V5XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGNoaWxkcmVuID09IG51bGwgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgICAgbGV0IHNpemUgPSBzaXplS2V5ICE9IG51bGwgPyBkYXR1bVtzaXplS2V5XSA6IHZvaWQgMDtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2l6ZSkpIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IGlzTGVhZiA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VtU2l6ZSA9IHNpemU7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgICBjb25zdCBjb2xvciA9IGNvbG9yS2V5ICE9IG51bGwgPyBkYXR1bVtjb2xvcktleV0gOiB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbG9yc1tub2RlSW5kZXhdID0gY29sb3I7XG4gICAgICAgIG1pbkNvbG9yID0gTWF0aC5taW4obWluQ29sb3IsIGNvbG9yKTtcbiAgICAgICAgbWF4Q29sb3IgPSBNYXRoLm1heChtYXhDb2xvciwgY29sb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFwcGVuZENoaWxkcmVuKFxuICAgICAgICBuZXcgSGllcmFyY2h5Tm9kZShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5vZGVJbmRleCxcbiAgICAgICAgICBkYXR1bSxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgc3VtU2l6ZSxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgW11cbiAgICAgICAgKSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmRDaGlsZHJlbiA9IChub2RlLCBkYXRhKSA9PiB7XG4gICAgICBkYXRhPy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNyZWF0ZU5vZGUoZGF0dW0sIG5vZGUpO1xuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBub2RlLnN1bVNpemUgKz0gY2hpbGQuc3VtU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByb290Tm9kZSA9IGFwcGVuZENoaWxkcmVuKFxuICAgICAgbmV3IEhpZXJhcmNoeU5vZGUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgdGhpcy5kYXRhXG4gICAgKTtcbiAgICBjb25zdCBjb2xvckRvbWFpbiA9IFttaW5Db2xvciwgbWF4Q29sb3JdO1xuICAgIGxldCBjb2xvclNjYWxlO1xuICAgIGlmIChjb2xvclJhbmdlICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKG1pbkNvbG9yKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4Q29sb3IpKSB7XG4gICAgICBjb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgICAgIGNvbG9yU2NhbGUuZG9tYWluID0gY29sb3JEb21haW47XG4gICAgICBjb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIGNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgfVxuICAgIHJvb3ROb2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBjaGlsZEluZGV4KSA9PiB7XG4gICAgICBjaGlsZC53YWxrKChub2RlKSA9PiB7XG4gICAgICAgIGxldCBmaWxsO1xuICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yc1tub2RlLmluZGV4XTtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICBmaWxsID0gY29sb3JTY2FsZT8uY29udmVydChjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbCA/PyAoZmlsbCA9IGZpbGxzPy5bY2hpbGRJbmRleCAlIGZpbGxzLmxlbmd0aF0pO1xuICAgICAgICBub2RlLmZpbGwgPSBmaWxsO1xuICAgICAgICBub2RlLnN0cm9rZSA9IGNvbG9yU2NhbGUgPT0gbnVsbCA/IHN0cm9rZXM/LltjaGlsZEluZGV4ICUgc3Ryb2tlcy5sZW5ndGhdIDogXCJyZ2JhKDAsIDAsIDAsIDAuMilcIjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcbiAgICB0aGlzLm1heERlcHRoID0gbWF4RGVwdGg7XG4gICAgdGhpcy5jb2xvckRvbWFpbiA9IGNvbG9yRG9tYWluO1xuICAgIHRoaXMuZm9jdXNQYXRoID0gW3sgbm9kZURhdHVtOiB0aGlzLnJvb3ROb2RlLCBjaGlsZEluZGV4OiAwIH1dO1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoKTtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0gdGhpcy5nZXRBbmltYXRpb25EYXRhKCk7XG4gICAgY29uc3QgcmVzaXplID0gdGhpcy5jaGVja1Jlc2l6ZShzZXJpZXNSZWN0KTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNpemVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgfVxuICByZXNldEFsbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zPy5kYXR1bTtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgaWYgKGRhdHVtICE9IG51bGwpIHtcbiAgICAgIHJlc2V0TW90aW9uKGRhdGEuZGF0dW1TZWxlY3Rpb25zLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnM/LmRhdHVtO1xuICAgIGlmIChkYXR1bSAhPSBudWxsKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YV0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJjbGVhclwiLCB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKSk7XG4gIH1cbiAgZ2V0QW5pbWF0aW9uRGF0YSgpIHtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0ge1xuICAgICAgZGF0dW1TZWxlY3Rpb25zOiBbdGhpcy5ncm91cFNlbGVjdGlvbl1cbiAgICB9O1xuICAgIHJldHVybiBhbmltYXRpb25EYXRhO1xuICB9XG4gIGlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oKSB7XG4gICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyBjb2xvcktleSwgY29sb3JOYW1lLCBjb2xvclJhbmdlLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIGxlZ2VuZFR5cGUgPT09IFwiZ3JhZGllbnRcIiAmJiBjb2xvcktleSAhPSBudWxsICYmIGNvbG9yUmFuZ2UgIT0gbnVsbCA/IFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJncmFkaWVudFwiLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgY29sb3JOYW1lLFxuICAgICAgICBjb2xvclJhbmdlLFxuICAgICAgICBjb2xvckRvbWFpbjogdGhpcy5jb2xvckRvbWFpblxuICAgICAgfVxuICAgIF0gOiBbXTtcbiAgfVxuICBnZXREYXR1bUlkRnJvbURhdGEobm9kZSkge1xuICAgIHJldHVybiBgJHtub2RlLmluZGV4fWA7XG4gIH1cbiAgZ2V0RGF0dW1JZChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0dW1JZEZyb21EYXRhKG5vZGUpO1xuICB9XG4gIHBpY2tGb2N1cyhvcHRzKSB7XG4gICAgaWYgKHRoaXMucm9vdE5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAodGhpcy5mb2N1c1BhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoXCJ0aGlzLmZvY3VzUGF0aCBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdHVtSW5kZXhEZWx0YTogY2hpbGREZWx0YSwgb3RoZXJJbmRleERlbHRhOiBkZXB0aERlbHRhIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgZm9jdXNQYXRoOiBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlcHRoID0gcGF0aC5sZW5ndGggLSAyO1xuICAgIGlmIChkZXB0aERlbHRhICE9PSAwIHx8IHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCB0YXJnZXREZXB0aCA9IE1hdGgubWF4KDAsIGRlcHRoICsgZGVwdGhEZWx0YSk7XG4gICAgICBpZiAocGF0aFt0YXJnZXREZXB0aCArIDFdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGF0aC5sZW5ndGggPSB0YXJnZXREZXB0aCArIDI7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMocGF0aFt0YXJnZXREZXB0aCArIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZWVwZXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB3aGlsZSAoZGVlcGVzdC5ub2RlRGF0dW0uY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAoZGVlcGVzdC5ub2RlRGF0dW0uZGVwdGggPz8gLTEpIDwgdGFyZ2V0RGVwdGgpIHtcbiAgICAgICAgICBjb25zdCBuZXh0RGVlcGVzdCA9IHsgbm9kZURhdHVtOiBkZWVwZXN0Lm5vZGVEYXR1bS5jaGlsZHJlblswXSwgY2hpbGRJbmRleDogMCB9O1xuICAgICAgICAgIHBhdGgucHVzaChuZXh0RGVlcGVzdCk7XG4gICAgICAgICAgZGVlcGVzdCA9IG5leHREZWVwZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMoZGVlcGVzdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZERlbHRhICE9PSAwKSB7XG4gICAgICBjb25zdCB0YXJnZXRDaGlsZCA9IHBhdGhbZGVwdGggKyAxXS5jaGlsZEluZGV4ICsgY2hpbGREZWx0YTtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYXJlbnQgPSBwYXRoW2RlcHRoXS5ub2RlRGF0dW07XG4gICAgICBjb25zdCBjaGlsZENvdW50ID0gY3VycmVudFBhcmVudD8uY2hpbGRyZW4/Lmxlbmd0aDtcbiAgICAgIGlmIChjaGlsZENvdW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjbGFtcCgwLCB0YXJnZXRDaGlsZCwgY2hpbGRDb3VudCAtIDEpO1xuICAgICAgICBjb25zdCBuZXdGb2N1cyA9IHsgbm9kZURhdHVtOiBjdXJyZW50UGFyZW50LmNoaWxkcmVuW25ld0NoaWxkXSwgY2hpbGRJbmRleDogbmV3Q2hpbGQgfTtcbiAgICAgICAgcGF0aFtkZXB0aCArIDFdID0gbmV3Rm9jdXM7XG4gICAgICAgIHBhdGgubGVuZ3RoID0gZGVwdGggKyAyO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKG5ld0ZvY3VzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUZvY3VzT3V0cHV0cyhwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgfVxuICBnZXREYXR1bUFyaWFUZXh0KGRhdHVtLCBkZXNjcmlwdGlvbikge1xuICAgIGlmICghKGRhdHVtIGluc3RhbmNlb2YgSGllcmFyY2h5Tm9kZSkpIHtcbiAgICAgIExvZ2dlci5lcnJvcihgZGF0dW0gaXMgbm90IEhpZXJhcmNoeU5vZGU6ICR7ZGF0dW19YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VIaWVyYXJjaHlEYXR1bVwiLCB7XG4gICAgICBsZXZlbDogKGRhdHVtLmRlcHRoID8/IC0xKSArIDEsXG4gICAgICBjb3VudDogZGF0dW0uY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNPdXRwdXRzKHsgbm9kZURhdHVtLCBjaGlsZEluZGV4IH0pIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNvbXB1dGVGb2N1c0JvdW5kcyhub2RlRGF0dW0pO1xuICAgIGlmIChib3VuZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdHVtOiBub2RlRGF0dW0sXG4gICAgICAgIGRhdHVtSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIG90aGVySW5kZXg6IG5vZGVEYXR1bS5kZXB0aCxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBzaG93Rm9jdXNCb3g6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9oaWVyYXJjaHkvaGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy50c1xudmFyIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2hpbGRyZW5LZXkgPSBcImNoaWxkcmVuXCI7XG4gICAgdGhpcy5maWxscyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9GSUxMUyk7XG4gICAgdGhpcy5zdHJva2VzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2hpbGRyZW5LZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yUmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy90b3BvbG9neS9sb25MYXRCYm94LnRzXG52YXIgTG9uTGF0QkJveCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobG9uMCwgbGF0MCwgbG9uMSwgbGF0MSkge1xuICAgIHRoaXMubG9uMCA9IGxvbjA7XG4gICAgdGhpcy5sYXQwID0gbGF0MDtcbiAgICB0aGlzLmxvbjEgPSBsb24xO1xuICAgIHRoaXMubGF0MSA9IGxhdDE7XG4gIH1cbiAgbWVyZ2Uob3RoZXIpIHtcbiAgICB0aGlzLmxvbjAgPSBNYXRoLm1pbih0aGlzLmxvbjAsIG90aGVyLmxvbjApO1xuICAgIHRoaXMubGF0MCA9IE1hdGgubWluKHRoaXMubGF0MCwgb3RoZXIubGF0MCk7XG4gICAgdGhpcy5sb24xID0gTWF0aC5tYXgodGhpcy5sb24xLCBvdGhlci5sb24xKTtcbiAgICB0aGlzLmxhdDEgPSBNYXRoLm1heCh0aGlzLmxhdDEsIG90aGVyLmxhdDEpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RlbXBVdGlscy50c1xuZnVuY3Rpb24gY3JlYXRlSWRzR2VuZXJhdG9yKCkge1xuICBjb25zdCBpZHNDb3VudGVyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIChuYW1lKSA9PiB7XG4gICAgY29uc3QgY291bnRlciA9IGlkc0NvdW50ZXIuZ2V0KG5hbWUpO1xuICAgIGlmIChjb3VudGVyKSB7XG4gICAgICBpZHNDb3VudGVyLnNldChuYW1lLCBjb3VudGVyICsgMSk7XG4gICAgICByZXR1cm4gYCR7bmFtZX0ke2NvdW50ZXJ9YDtcbiAgICB9XG4gICAgaWRzQ291bnRlci5zZXQobmFtZSwgMSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpY2tzLnRzXG52YXIgX0F4aXNUaWNrcyA9IGNsYXNzIF9BeGlzVGlja3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzVGlja3NgLCB6SW5kZXg6IDIgLyogQVhJU19aSU5ERVggKi8gfSk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5heGlzR3JvdXAsIFRleHQsIGZhbHNlKTtcbiAgICB0aGlzLmludGVydmFsID0gbmV3IEF4aXNJbnRlcnZhbCgpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQXhpc0xhYmVsKCk7XG4gICAgdGhpcy5zY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucG9zaXRpb24gPSBcImJvdHRvbVwiO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgfVxuICBhdHRhY2hBeGlzKGF4aXNOb2RlKSB7XG4gICAgYXhpc05vZGUuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dCgpIHtcbiAgICB0aGlzLnNjYWxlLmludGVydmFsID0gdGhpcy5pbnRlcnZhbC5zdGVwO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgY29uc3QgdGlja0RhdGEgPSB0aGlzLmdlbmVyYXRlVGlja3MoKTtcbiAgICBjb25zdCB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSB0aGlzO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgdGlja0RhdGEudGlja3MubWFwKChkKSA9PiB0aGlzLmNyZWF0ZUxhYmVsRGF0dW0oZCkpLFxuICAgICAgKGdyb3VwKSA9PiBncm91cC5hcHBlbmRDaGlsZChuZXcgVGV4dCgpKSxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0udGlja0lkXG4gICAgKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZGF0dW0pO1xuICAgICAgaWYgKGRhdHVtLnZpc2libGUpIHtcbiAgICAgICAgYm94ZXMucHVzaChub2RlLmdldEJCb3goKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5heGlzR3JvdXAuc2V0UHJvcGVydGllcyh7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0pO1xuICAgIHJldHVybiBCQm94Lm1lcmdlKGJveGVzKTtcbiAgfVxuICBnZXRMYWJlbFBhcmFtcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRyYW5zbGF0ZSB9ID0gZGF0dW07XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdHJhbnNsYXRlLFxuICAgICAgICAgIHk6IHBhZGRpbmcsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIlxuICAgICAgICB9O1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHBhZGRpbmcsXG4gICAgICAgICAgeTogdHJhbnNsYXRlLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJzdGFydFwiLFxuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIlxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICBpblJhbmdlKHgsIHRvbGVyYW5jZSA9IDFlLTMpIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heCh0aGlzLnNjYWxlLnJhbmdlKTtcbiAgICByZXR1cm4geCA+PSBtaW4gLSB0b2xlcmFuY2UgJiYgeCA8PSBtYXggKyB0b2xlcmFuY2U7XG4gIH1cbiAgY3JlYXRlTGFiZWxEYXR1bShkYXR1bSkge1xuICAgIGNvbnN0IHsgeCwgeSwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSA9IHRoaXMuZ2V0TGFiZWxQYXJhbXMoZGF0dW0pO1xuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlOiBCb29sZWFuKGRhdHVtLnRpY2tMYWJlbCksXG4gICAgICB0aWNrSWQ6IGRhdHVtLnRpY2tJZCxcbiAgICAgIGZpbGw6IHRoaXMubGFiZWwuY29sb3IsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmxhYmVsLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5sYWJlbC5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5sYWJlbC5mb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogMCxcbiAgICAgIHRleHQ6IGRhdHVtLnRpY2tMYWJlbCxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tzKCkge1xuICAgIGNvbnN0IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCBleHRlbnRXaXRoQmxlZWQgPSByb3VuZChmaW5kUmFuZ2VFeHRlbnQodGhpcy5zY2FsZS5yYW5nZSksIDIpO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIHRpY2tDb3VudCB9ID0gZXN0aW1hdGVUaWNrQ291bnQoXG4gICAgICBleHRlbnRXaXRoQmxlZWQsXG4gICAgICBtaW5TcGFjaW5nLFxuICAgICAgbWF4U3BhY2luZyxcbiAgICAgIF9BeGlzVGlja3MuRGVmYXVsdFRpY2tDb3VudCxcbiAgICAgIF9BeGlzVGlja3MuRGVmYXVsdE1pblNwYWNpbmdcbiAgICApO1xuICAgIGlmICh0aWNrQ291bnQpIHtcbiAgICAgIHRoaXMuc2NhbGUudGlja0NvdW50ID0gdGlja0NvdW50O1xuICAgICAgdGhpcy5zY2FsZS5taW5UaWNrQ291bnQgPSBtaW5UaWNrQ291bnQ7XG4gICAgICB0aGlzLnNjYWxlLm1heFRpY2tDb3VudCA9IG1heFRpY2tDb3VudDtcbiAgICB9XG4gICAgY29uc3QgdGlja0RhdGEgPSB0aGlzLmdldFRpY2tzRGF0YSgpO1xuICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSBcImJvdHRvbVwiIHx8IHRoaXMucG9zaXRpb24gPT09IFwidG9wXCIpIHtcbiAgICAgIGNvbnN0IG1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQ6IHRoaXMubGFiZWwgfSk7XG4gICAgICBsZXQgbGFzdFRpY2tQb3NpdGlvbiA9IC1JbmZpbml0eTtcbiAgICAgIHRpY2tEYXRhLnRpY2tzID0gdGlja0RhdGEudGlja3MuZmlsdGVyKChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChsYXN0VGlja1Bvc2l0aW9uIDwgZGF0YS50cmFuc2xhdGUpIHtcbiAgICAgICAgICBsYXN0VGlja1Bvc2l0aW9uID0gZGF0YS50cmFuc2xhdGUgKyBtZWFzdXJlci50ZXh0V2lkdGgoZGF0YS50aWNrTGFiZWwsIHRydWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tEYXRhO1xuICB9XG4gIGdldFRpY2tzRGF0YSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IHJhd1RpY2tzID0gdGhpcy5zY2FsZS50aWNrcygpO1xuICAgIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gcmF3VGlja3MucmVkdWNlKChtYXgsIHRpY2spID0+IE1hdGgubWF4KG1heCwgY291bnRGcmFjdGlvbkRpZ2l0cyh0aWNrKSksIDApO1xuICAgIGNvbnN0IGlkR2VuZXJhdG9yID0gY3JlYXRlSWRzR2VuZXJhdG9yKCk7XG4gICAgY29uc3QgbGFiZWxGb3JtYXR0ZXIgPSB0aGlzLmxhYmVsLmZvcm1hdCA/IHRoaXMuc2NhbGUudGlja0Zvcm1hdCh7IHRpY2tzOiByYXdUaWNrcywgc3BlY2lmaWVyOiB0aGlzLmxhYmVsLmZvcm1hdCB9KSA6ICh4KSA9PiBpc051bWJlcih4KSA/IHgudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykgOiBTdHJpbmcoeCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJhd1RpY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgdGljayA9IHJhd1RpY2tzW2luZGV4XTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHRoaXMuc2NhbGUuY29udmVydCh0aWNrKTtcbiAgICAgIGlmICghdGhpcy5pblJhbmdlKHRyYW5zbGF0ZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGlja0xhYmVsID0gdGhpcy5sYWJlbC5mb3JtYXR0ZXI/Lih7IHZhbHVlOiB0aWNrLCBpbmRleCwgZnJhY3Rpb25EaWdpdHMgfSkgPz8gbGFiZWxGb3JtYXR0ZXIodGljayk7XG4gICAgICBjb25zdCB0aWNrSWQgPSBpZEdlbmVyYXRvcih0aWNrTGFiZWwpO1xuICAgICAgdGlja3MucHVzaCh7IHRpY2ssIHRpY2tJZCwgdGlja0xhYmVsLCB0cmFuc2xhdGUgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IHJhd1RpY2tzLCBmcmFjdGlvbkRpZ2l0cywgdGlja3MgfTtcbiAgfVxufTtcbl9BeGlzVGlja3MuRGVmYXVsdFRpY2tDb3VudCA9IDU7XG5fQXhpc1RpY2tzLkRlZmF1bHRNaW5TcGFjaW5nID0gNTA7XG52YXIgQXhpc1RpY2tzID0gX0F4aXNUaWNrcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kRGF0dW0udHNcbnZhciBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT04gPSAwO1xuZXhwb3J0IHtcbiAgQUdfQ0hBUlRTX0xPQ0FMRV9FTl9VUyxcbiAgQWdDaGFydHMsXG4gIEFnRXJyb3JCYXJTdXBwb3J0ZWRTZXJpZXNUeXBlcyxcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlLFxuICBJQ09OU19MRUdBQ1ksXG4gIE1hcmtlcixcbiAgVkVSU0lPTixcbiAgbW9kdWxlX3N1cHBvcnRfZXhwb3J0cyBhcyBfTW9kdWxlU3VwcG9ydCxcbiAgc3BhcmtsaW5lc19zY2FsZV9leHBvcnRzIGFzIF9TY2FsZSxcbiAgaW50ZWdyYXRlZF9jaGFydHNfc2NlbmVfZXhwb3J0cyBhcyBfU2NlbmUsXG4gIGludGVncmF0ZWRfY2hhcnRzX3RoZW1lX2V4cG9ydHMgYXMgX1RoZW1lLFxuICBzcGFya2xpbmVzX3V0aWxfZXhwb3J0cyBhcyBfVXRpbCxcbiAgdGltZV9leHBvcnRzIGFzIHRpbWVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\n");

/***/ })

};
;